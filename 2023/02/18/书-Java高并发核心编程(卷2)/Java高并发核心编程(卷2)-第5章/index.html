<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="5.1 显式锁使用 Java内置锁 时，无需通过 Java 代码显式地对同步对象的监视器进行抢占和释放，使用起来非常方便。但是不具备一些比较高级的锁功能：  限时抢锁：设置超时时长，不至于无限等下去  可中断抢锁：抢锁时，外部线程给抢锁线程发一个中断信号，就能唤起等待锁的线程，并终止抢占过程  多个等待队列：为锁维持多个等待队列，以提高锁的效率。比如生产者-消费者模式中，生产者和消费者公用一把锁，">
<meta property="og:type" content="article">
<meta property="og:title" content="第5章：JUC显式锁的原理与实战">
<meta property="og:url" content="https://glassx.github.io/2023/02/18/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC5%E7%AB%A0/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="5.1 显式锁使用 Java内置锁 时，无需通过 Java 代码显式地对同步对象的监视器进行抢占和释放，使用起来非常方便。但是不具备一些比较高级的锁功能：  限时抢锁：设置超时时长，不至于无限等下去  可中断抢锁：抢锁时，外部线程给抢锁线程发一个中断信号，就能唤起等待锁的线程，并终止抢占过程  多个等待队列：为锁维持多个等待队列，以提高锁的效率。比如生产者-消费者模式中，生产者和消费者公用一把锁，">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-18T07:54:00.000Z">
<meta property="article:modified_time" content="2023-02-22T14:36:01.591Z">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="Java高并发核心编程(卷2)">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/2023/02/18/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC5%E7%AB%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>第5章：JUC显式锁的原理与实战 | glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">158</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/18/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          第5章：JUC显式锁的原理与实战
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-18 15:54:00" itemprop="dateCreated datePublished" datetime="2023-02-18T15:54:00+08:00">2023-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-22 22:36:01" itemprop="dateModified" datetime="2023-02-22T22:36:01+08:00">2023-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <html><head></head><body></body></html><html><head></head><body><h2 id="5-1-显式锁"><a href="#5-1-显式锁" class="headerlink" title="5.1 显式锁"></a>5.1 显式锁</h2><p>使用 Java内置锁 时，无需通过 Java 代码显式地对同步对象的监视器进行抢占和释放，使用起来非常方便。但是不具备一些比较高级的锁功能：</p>
<ul>
<li><p>限时抢锁：设置超时时长，不至于无限等下去</p>
</li>
<li><p>可中断抢锁：抢锁时，外部线程给抢锁线程发一个中断信号，就能唤起等待锁的线程，并终止抢占过程</p>
</li>
<li><p>多个等待队列：为锁维持多个等待队列，以提高锁的效率。比如生产者-消费者模式中，生产者和消费者公用一把锁，锁上维持2个队列：一个生产队列和一个消费者队列</p>
</li>
</ul>
<h3 id="5-1-3-使用显式锁的模板代码"><a href="#5-1-3-使用显式锁的模板代码" class="headerlink" title="5.1.3 使用显式锁的模板代码"></a>5.1.3 使用显式锁的模板代码</h3><p>因为 JUC 中的显式锁都实现了 Lock 接口，所以不同类型的显式锁对象使用的方法都是模板化的、套路化的，模板代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建锁对象，SomeLock 为 Lock 的某个实现类，如 ReentrantLock</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> SomeLock();</span><br><span class="line"><span class="comment">//step 1： 抢占锁</span></span><br><span class="line">lock.lock;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//step2 ： 抢锁成功，执行临界区代码</span></span><br><span class="line">    doSomething();</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    lock.unlock(); <span class="comment">//step3： 释放锁</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>模板代码有几个需要注意的点：</p>
<ul>
<li><p>释放锁操作 unlock 必须在 try-catch 的finally 中执行，否则如果临界区代码抛出异常，锁就可能永远也得不到释放了</p>
</li>
<li><p>抢占锁的操作<strong>lock 必须在 try 语句之外</strong>，原因：lock 方法不一定能够抢锁成功（我猜测作者是想说 tryLock() 之类的方法不一定会获取成功），如果没有抢占到锁，也肯定不需要释放锁，<strong>在没有占有锁的情况下释放锁可能导致异常</strong>。</p>
</li>
<li><p>在抢占锁操作 lock 和 try 语句之间不要插入任何代码，避免抛出异常而无法执行到 try，进而无法释放锁。</p>
</li>
</ul>
<h3 id="5-1-4-基于显式锁进行“等待-通知”方式的线程间通信"><a href="#5-1-4-基于显式锁进行“等待-通知”方式的线程间通信" class="headerlink" title="5.1.4 基于显式锁进行“等待-通知”方式的线程间通信"></a>5.1.4 基于显式锁进行“等待-通知”方式的线程间通信</h3><p>Java 内置锁可以通过 Object 的 wait 和 notify 方法来实现简单的线程间通信，与此类似的是，基于 Lock 显式锁，JUC 也提供了一个用于线程间通信的接口 Condition</p>
<p>Condition 接口有2类主要方法：</p>
<ul>
<li>await() ： 在功能上与 Object.wait() 语意等效，线程会加入 await() 等待队列，<strong>并释放当前锁</strong></li>
<li>signal() ： 在功能上与 Object.notify() 语意等效，唤醒 await() 等待队列中的线程</li>
</ul>
<blockquote>
<p>为了避免与 Object 中的 wait/notify 2类方法在使用时发生混淆，JUC 对 Condition 接口方法改了名称，成为了 await/signal。Condition 对象的 signal 和<strong>同一个对象的 await 是一一配对使用的</strong>。</p>
</blockquote>
<p><strong>Condition 对象是基于显式锁的，所以不能独立创建 Condition 对象，可以通过 lock.newCondition() 方法获取</strong>一个与当前显式锁绑定的 Condition 对象。用法举例如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitTarget</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        lock.lock();<span class="comment">//抢锁</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            print(<span class="string">"开始等待"</span>);</span><br><span class="line">            condition.await();<span class="comment">//开始等待，并且释放锁</span></span><br><span class="line">            print(<span class="string">"收到通知，开始继续执行"</span>);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用 await 方法前必须要先获取锁，await 方法会让当前线程加入 Condition 的等待队列，同理， signal 方法也要在获取锁之后才能调用，调用 signal 之后一定要释放锁，只有这样被唤醒的等待线程才能抢锁。</p>
<h3 id="5-1-5-LockSupport"><a href="#5-1-5-LockSupport" class="headerlink" title="5.1.5 LockSupport"></a>5.1.5 LockSupport</h3><p>LockSupport 是JUC 提供的一个 <strong>线程阻塞与唤醒的工具类</strong>。大体有2类方法(阻塞和唤醒)：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无限期阻塞当前线程</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span></span>; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 唤醒某个被阻塞的线程</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>一个简单的演示的实例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitTarget</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            print(<span class="string">"即将进入阻塞"</span>);</span><br><span class="line">            LockSupport.park();<span class="comment">//阻塞当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) {</span><br><span class="line">                print(<span class="string">"被中断了"</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                print(<span class="string">"被重新唤醒"</span>);</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-1-5-1-LockSupport-park-的对比（自己改的标题）"><a href="#5-1-5-1-LockSupport-park-的对比（自己改的标题）" class="headerlink" title="5.1.5.1 LockSupport.park() 的对比（自己改的标题）"></a>5.1.5.1 LockSupport.park() 的对比（自己改的标题）</h4><p>1、与 Thread.sleep() 的区别</p>
<ul>
<li>Thread.sleep() 只能自己醒来，没法外部唤醒；LockSupport.park() 可以通过 unpark 唤醒</li>
<li>Thread.sleep() 声明了中断异常(InterruptedException) ，而LockSupport.park() 没有</li>
<li>被中断的时候，虽然线程都会被设置中断标记，但是线程表现不同：sleep 会抛异常，park 不会</li>
</ul>
<p>2、与 Object.wait() 的区别</p>
<ul>
<li>wait 需要在同步块中执行，park 可以在任意地方执行</li>
<li>当阻塞线程被中断时，wait 方法抛出中断异常；而park 不会抛出异常</li>
<li>如果没有调用过 wait 而直接执行 notify 会导致 IllegalMonitorStateException异常；而未做park 直接做 unpark 不会有任何异常</li>
</ul>
<blockquote>
<p>自己看了下 LockSupport 的源码，发现 park 和 unpark 都是 native 方法，所以在代码层面就没对比了</p>
</blockquote>
<h3 id="5-1-6-显式锁分类"><a href="#5-1-6-显式锁分类" class="headerlink" title="5.1.6 显式锁分类"></a>5.1.6 显式锁分类</h3><p>从多个维度分类： 可重入、悲观/乐观、公平、共享/独占、可中断/不可中断</p>
<h3 id="5-2-2-通过-CAS-实现乐观锁"><a href="#5-2-2-通过-CAS-实现乐观锁" class="headerlink" title="5.2.2 通过 CAS 实现乐观锁"></a>5.2.2 通过 CAS 实现乐观锁</h3><p>乐观锁通过 CAS 实现主要就是两个步骤：</p>
<ol>
<li>冲突检测 （CAS 检测内存位置 V 的值是否为 A）</li>
<li>数据更新 (CAS 上述检测如果是，则将位置 V 更新为 B 值，否则不更改)</li>
</ol>
<p>在实际使用中，仅仅进行一次 CAS 是不够的，一般情况下需要不断循环重试直到CAS 操作成功，也即<strong>自旋</strong></p>
<blockquote>
<p>乐观锁是一种思想，CAS 是这种思想的一种实现</p>
</blockquote>
<p>作为演示，这里设计一个简单版本的不可重入（如果需要重入就count计数，这里不贴例子了）的自旋锁：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前锁的拥有者</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//书中的例子这里是写错了，它写成 while(owner.compareAndSet(null, t))</span></span><br><span class="line">        <span class="keyword">while</span>(!owner.compareAndSet(<span class="keyword">null</span>, t)) {<span class="comment">//循环竞争锁</span></span><br><span class="line">            <span class="comment">//没获取到锁，让出cpu</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span>(t == owner.get()) {</span><br><span class="line">            owner.set(<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-2-5-CAS-可能导致“总线风暴”"><a href="#5-2-5-CAS-可能导致“总线风暴”" class="headerlink" title="5.2.5 CAS 可能导致“总线风暴”"></a>5.2.5 CAS 可能导致“总线风暴”</h3><p>为了保障“缓存一致性”，不同的内核需要通过总线来回通信，使用 lock 前缀（用于内存屏障）指令的 Java 操作（比如CAS、volatile）会产生缓存一致性流量，很多线程同时执行lock前缀操作时，会在总线上产生过多的流量，也就是 “总线风暴”。</p>
<p>那么，基于 JUC 实现的轻量级锁怎么避免总线风暴？答案是：使用队列对抢锁线程进行排队。</p>
<h3 id="5-2-6-CLH自旋锁"><a href="#5-2-6-CLH自旋锁" class="headerlink" title="5.2.6 CLH自旋锁"></a>5.2.6 CLH自旋锁</h3><p>CLH锁就是一种基于队列排队的自旋锁（由3个发明人的名字命名的），AQS 也是基于这种原理，为了说明其原理，这里实现一个 CLH 锁的学习版本，并不是真正的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点的线程本地变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Node&gt; curNodeLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CLHLock队列的尾部指针，使用AtomicReference，方便进行</span></span><br><span class="line"><span class="comment">     * CAS操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Node&gt; tail = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CLHLock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//设置尾部节点</span></span><br><span class="line">        tail.getAndSet(Node.EMPTY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁操作：将节点添加到等待队列的尾部</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        Node curNode = <span class="keyword">new</span> Node(<span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node preNode = tail.get();</span><br><span class="line">        <span class="comment">//CAS自旋：将当前节点插入队列的尾部</span></span><br><span class="line">        <span class="keyword">while</span> (!tail.compareAndSet(preNode, curNode)) {</span><br><span class="line">            preNode = tail.get();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//设置前驱节点</span></span><br><span class="line">        curNode.setPrevNode(preNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自旋，监听前驱节点的locked变量，直到其值为false</span></span><br><span class="line">        <span class="comment">// 若前驱节点的locked状态为true，则表示前一个线程还在抢占或者占有锁</span></span><br><span class="line">        <span class="keyword">while</span> (curNode.getPrevNode().isLocked()) {</span><br><span class="line">            <span class="comment">//让出CPU时间片，提高性能</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 能执行到这里，说明当前线程获取到了锁</span></span><br><span class="line">        <span class="comment">// Print.tcfo("获取到了锁！！！");</span></span><br><span class="line">        <span class="comment">//将当前节点缓存在线程本地变量中，释放锁会用到</span></span><br><span class="line">        curNodeLocal.set(curNode);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">        Node curNode = curNodeLocal.get();</span><br><span class="line">        curNode.setLocked(<span class="keyword">false</span>);</span><br><span class="line">        curNode.setPrevNode(<span class="keyword">null</span>); <span class="comment">//help for GC</span></span><br><span class="line">        curNodeLocal.set(<span class="keyword">null</span>); <span class="comment">//方便下一次抢锁</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虚拟等待队列的节点</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> locked, Node prevNode)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.locked = locked;</span><br><span class="line">            <span class="keyword">this</span>.prevNode = prevNode;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// true：当前线程正在抢占锁，或者已经占有锁</span></span><br><span class="line">        <span class="comment">// false：当前线程已经释放锁，下一个线程可以占有锁了</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">boolean</span> locked;</span><br><span class="line">        <span class="comment">// 前一个节点，需要监听其locked字段</span></span><br><span class="line">        Node prevNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Node EMPTY = <span class="keyword">new</span> Node(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>CLH 算法的几个要点就是（我理解的是，这种步骤就是公平锁环境下弄的，非公平锁不会每次头节点获得锁）：</p>
<ol>
<li>初始状态队列尾部(tail)指向一个 EMPTY节点，tail 节点使用 AtomicReference 类型是为了让多线程并发操作时安全</li>
<li>Thread 在抢锁时会创建一个 Node 加入等待队列尾部（默认lock 属性为true），同时自己作为新的尾部，这些操作通过 CAS 自旋操作</li>
<li>Node 加入之后，会循环判断前去节点的 lock 属性是否为false，如果为false，即前驱节点释放了锁，当前节点获得了锁</li>
<li>当前node 获得锁之后，将locked 属性设置为true</li>
<li>临界区代码执行完毕后，当前节点的 locked 置为 false，方便后续节点获取锁</li>
</ol>
<h3 id="5-4-2-死锁的监测与中断"><a href="#5-4-2-死锁的监测与中断" class="headerlink" title="5.4.2 死锁的监测与中断"></a>5.4.2 死锁的监测与中断</h3><p>JDK 8 中包含一个 ThreadMXBean 接口，提供多种监视线程的方法：</p>
<ul>
<li>findDeadlockedThreads ：用于检测由于抢占JUC显式锁、Java内置锁引起死锁的线程。</li>
<li>findMonitorDeadlockedThreads：仅仅用于检测由于抢占Java内置锁引起死锁的线程。</li>
</ul>
<h2 id="5-5-共享锁与独占锁"><a href="#5-5-共享锁与独占锁" class="headerlink" title="5.5 共享锁与独占锁"></a>5.5 共享锁与独占锁</h2><p>JUC 中的共享锁包括 Semaphore（信号量）、ReadLock（读写锁中的读锁）、CountDownLatch 倒数闩</p>
<h3 id="5-5-2-共享锁-Semaphore"><a href="#5-5-2-共享锁-Semaphore" class="headerlink" title="5.5.2 共享锁 Semaphore"></a>5.5.2 共享锁 Semaphore</h3><p>Semaphore 可以用来控制在同一时刻共享资源的线程数量，维护了一组虚拟许可。<strong>将 Semaphore 称为一个许可管理器 更形象。</strong></p>
<h4 id="5-5-2-1-Semaphore-使用示例"><a href="#5-5-2-1-Semaphore-使用示例" class="headerlink" title="5.5.2.1 Semaphore 使用示例"></a>5.5.2.1 Semaphore 使用示例</h4><p>Semaphore 使用一个很形象的场景是银行排队办理业务，只有 N 个窗口，M 个人在排队，那么其实相当于有 N 个许可：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(N);</span><br><span class="line"></span><br><span class="line">Runnable r = () -&gt; {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//阻塞开始获取许可</span></span><br><span class="line">        semaphore.acquire(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//获取了一个许可</span></span><br><span class="line">        print(<span class="string">"业务办理中"</span>);</span><br><span class="line">        <span class="comment">//模拟业务操作: 处理排队业务</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//用完了释放许可</span></span><br><span class="line">        semaphore.release(<span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">catch</span>(Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-5-3-共享锁-CountDownLatch"><a href="#5-5-3-共享锁-CountDownLatch" class="headerlink" title="5.5.3 共享锁 CountDownLatch"></a>5.5.3 共享锁 CountDownLatch</h3><p>CountDownLatch 功能相当于一个多线程环境下的倒数门闩，它可以指定一个计数值，在并发环境下由线程进行减1操作，当计数变为 0 之后，被 await 阻塞的线程将会唤醒。</p>
<p>它的一个经典示例就是，司机开车之前需要每个人报数，报数到 100 后说明人到齐发车：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) {<span class="comment">// 启动报数任务</span></span><br><span class="line">    threadPoll.execute(<span class="keyword">new</span> Runable() {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            print(<span class="string">"第"</span> + i + <span class="string">"个人已到"</span>);</span><br><span class="line">            <span class="comment">//倒数闩减1</span></span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"> doneSignal.await(); <span class="comment">//step2：等待报数完成，倒数闩计数值为0</span></span><br><span class="line"> print(<span class="string">"人到齐，开车"</span>); </span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-6-读写锁"><a href="#5-6-读写锁" class="headerlink" title="5.6 读写锁"></a>5.6 读写锁</h2><p>读写锁的读和写操作的互斥原则如下：</p>
<ul>
<li>读读能共存</li>
<li>读写不能共存</li>
<li>写写不能共存</li>
</ul>
<p>JUC 包中的读写锁接口为 ReadWriteLock ，主要有2个方法： </p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>{</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回读锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回写锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其主要实现类为 ReentrantReadWriteLock ，与 ReentrantLock 相比，<strong>前者更适合 读多写少 的场景，而 ReentrantLock 适合 读写比例相差不大 的场景</strong>。</p>
<h3 id="5-6-3-StampedLock-印戳锁"><a href="#5-6-3-StampedLock-印戳锁" class="headerlink" title="5.6.3 StampedLock 印戳锁"></a>5.6.3 StampedLock 印戳锁</h3><p>StampedLock 是对 ReentrantReadWriteLock 读写所的一种改进，主要改进为： 在没有写只有读的场景，<strong>StampedLock 支持不用加读锁而是直接进行读操作，最大限度提升读的效率，只有发生过写操作后，再加读锁才能进行读操作。</strong></p>
</body></html>
    </div>

    
    
    
        <div class="reward-container">
  <div>谢谢你的鼓励</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/WechatReward.png" alt="glassx 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%8D%B72/" rel="tag"># Java高并发核心编程(卷2)</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2023/02/17/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC4%E7%AB%A0/" rel="next" title="第4章：可见性与有序性的原理">
                  <i class="fa fa-chevron-left"></i> 第4章：可见性与有序性的原理
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2023/02/22/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC6%E7%AB%A0/" rel="prev" title="第6章：AQS 抽象同步器的核心原理">
                  第6章：AQS 抽象同步器的核心原理 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E6%98%BE%E5%BC%8F%E9%94%81"><span class="nav-number">1.</span> <span class="nav-text">5.1 显式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-%E4%BD%BF%E7%94%A8%E6%98%BE%E5%BC%8F%E9%94%81%E7%9A%84%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.</span> <span class="nav-text">5.1.3 使用显式锁的模板代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-4-%E5%9F%BA%E4%BA%8E%E6%98%BE%E5%BC%8F%E9%94%81%E8%BF%9B%E8%A1%8C%E2%80%9C%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E2%80%9D%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">1.2.</span> <span class="nav-text">5.1.4 基于显式锁进行“等待-通知”方式的线程间通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-5-LockSupport"><span class="nav-number">1.3.</span> <span class="nav-text">5.1.5 LockSupport</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-5-1-LockSupport-park-%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%88%E8%87%AA%E5%B7%B1%E6%94%B9%E7%9A%84%E6%A0%87%E9%A2%98%EF%BC%89"><span class="nav-number">1.3.1.</span> <span class="nav-text">5.1.5.1 LockSupport.park() 的对比（自己改的标题）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-6-%E6%98%BE%E5%BC%8F%E9%94%81%E5%88%86%E7%B1%BB"><span class="nav-number">1.4.</span> <span class="nav-text">5.1.6 显式锁分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-%E9%80%9A%E8%BF%87-CAS-%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">1.5.</span> <span class="nav-text">5.2.2 通过 CAS 实现乐观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-5-CAS-%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E2%80%9C%E6%80%BB%E7%BA%BF%E9%A3%8E%E6%9A%B4%E2%80%9D"><span class="nav-number">1.6.</span> <span class="nav-text">5.2.5 CAS 可能导致“总线风暴”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-6-CLH%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">1.7.</span> <span class="nav-text">5.2.6 CLH自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-2-%E6%AD%BB%E9%94%81%E7%9A%84%E7%9B%91%E6%B5%8B%E4%B8%8E%E4%B8%AD%E6%96%AD"><span class="nav-number">1.8.</span> <span class="nav-text">5.4.2 死锁的监测与中断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E5%85%B1%E4%BA%AB%E9%94%81%E4%B8%8E%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="nav-number">2.</span> <span class="nav-text">5.5 共享锁与独占锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-2-%E5%85%B1%E4%BA%AB%E9%94%81-Semaphore"><span class="nav-number">2.1.</span> <span class="nav-text">5.5.2 共享锁 Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-2-1-Semaphore-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">5.5.2.1 Semaphore 使用示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-3-%E5%85%B1%E4%BA%AB%E9%94%81-CountDownLatch"><span class="nav-number">2.2.</span> <span class="nav-text">5.5.3 共享锁 CountDownLatch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">3.</span> <span class="nav-text">5.6 读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-3-StampedLock-%E5%8D%B0%E6%88%B3%E9%94%81"><span class="nav-number">3.1.</span> <span class="nav-text">5.6.3 StampedLock 印戳锁</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共320.9k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '014f25b646a6b4e4caf9',
      clientSecret: '1874f37da4d837c5866039f706ec722ea42d790d',
      repo: 'comments',
      owner: 'glassx',
      admin: ['glassx'],
      id: '1371a446326ae11bc34674dd60ae66d7',
        language: 'zh-CN',
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

</body>
</html>
