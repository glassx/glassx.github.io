<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/8/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">38</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">218</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/13/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC7%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC7%E7%AB%A0/" class="post-title-link" itemprop="url">第7章：Kotlin协程在Android上的应用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-13 11:33:00" itemprop="dateCreated datePublished" datetime="2023-03-13T11:33:00+08:00">2023-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-11 11:51:57" itemprop="dateModified" datetime="2023-03-11T11:51:57+08:00">2023-03-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>未开始</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/11/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/11/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">第5章：Kotlin协程框架开发初探</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-11 09:10:00" itemprop="dateCreated datePublished" datetime="2023-03-11T09:10:00+08:00">2023-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-10 21:01:35" itemprop="dateModified" datetime="2023-03-10T21:01:35+08:00">2023-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>为了学习官方协程，我们先实现一些轻量级的复合协程，只是用于学习，不适合生产环境。</p>
<h2 id="5-1-开胃菜：实现一个-delay-函数"><a href="#5-1-开胃菜：实现一个-delay-函数" class="headerlink" title="5.1 开胃菜：实现一个 delay 函数"></a>5.1 开胃菜：实现一个 delay 函数</h2><p>使用线程的时候，如果希望代码延迟一段时间再执行，通常会调用 Thread.sleep 函数，<strong>这会令当前线程阻塞</strong>。在协程中也可以这样，不过协程可以挂起还去阻塞线程，就很浪费资源，我们的目的是后面的代码延迟一段时间执行，因此可以确定以下2点：</p>
<ul>
<li><p>不要阻塞线程</p>
</li>
<li><p>是个挂起函数，指定时间之后能够恢复执行即可</p>
</li>
</ul>
<p>从上面 2 点我们可以给出 delay 函数的声明： </p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(time: <span class="type">Long</span>, unit: <span class="type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">    。。。</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来要考虑挂起，<strong>自然就想到了 suspendCoroutin</strong>：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(time: <span class="type">Long</span>, unit: <span class="type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> {</span><br><span class="line">    。。。</span><br><span class="line">    suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; {continuation: Continuation&lt;<span class="built_in">Unit</span>&gt; -&gt;  </span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    。。。</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>只需要做到在指定的 time 之后执行 continuation.resume() 就行，因此，<strong>我们只需要提供这样一个定时回调机制就可以！</strong>,定时任务很容易想到 <strong>ScheduledExecutorService</strong>，因此代码可以这样写：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> executor = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="keyword">object</span> : ThreadFactory{</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newThread</span><span class="params">(r: <span class="type">Runnable</span>)</span></span>: Thread {</span><br><span class="line">        <span class="keyword">return</span> Thread(r, <span class="string">"Scheduler"</span>).apply {</span><br><span class="line">            isDaemon = <span class="literal">true</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>这里为什么要设置 isDaemon ，放到后面说。接着我们可以实现功能了：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(time: <span class="type">Long</span>, unit: <span class="type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> {</span><br><span class="line">    suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; {continuation: Continuation&lt;<span class="built_in">Unit</span>&gt; -&gt;</span><br><span class="line">        executor.schedule(<span class="keyword">object</span>: Runnable{</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> {</span><br><span class="line">                continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">            }</span><br><span class="line">        }, time, unit)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="5-1-1-为什么这样用-ScheduledExecutorService（自己加的标题）"><a href="#5-1-1-为什么这样用-ScheduledExecutorService（自己加的标题）" class="headerlink" title="5.1.1 为什么这样用 ScheduledExecutorService（自己加的标题）"></a>5.1.1 为什么这样用 ScheduledExecutorService（自己加的标题）</h3><p>了解 ScheduledExecutorService 工作机制的朋友还会有疑惑：Scheduled-ExecutorService <strong>在等待延时的阶段还是会阻塞</strong>，这不也浪费资源吗？这里说明下2个原因：</p>
<ul>
<li><p>如果当前线程有特殊地位，例如 UI线程 等，那么它们是不能被阻塞的，因此我们将阻塞动作放到后台线程上是有意义的</p>
</li>
<li><p>后台<strong>一个线程可以承载非常多的延时任务</strong>，例如：有 10 个协程调用 delay ，那么只需要阻塞一个 后台线程即可实现这 10 个协程的延时执行 ！参考下图：</p>
</li>
</ul>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kotlin%E5%8D%8F%E7%A8%8B/%E7%AC%AC5%E7%AB%A0/%E5%A4%9A%E4%B8%AAdelay%E5%8D%8F%E7%A8%8B%E5%85%AC%E7%94%A8%E4%B8%80%E4%B8%AA%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B.png" alt="多个delay协程公用一个后台线程"></p>
<h2 id="5-2-协程的描述"><a href="#5-2-协程的描述" class="headerlink" title="5.2 协程的描述"></a>5.2 协程的描述</h2><p>Java 平台上 Thread 的定义很直观，让人很容易识别 Java 线程；而协程一开始只是在标准库中放了协程基础设施，导致难以上手和分辨。这里我们尝试给一个类来描述协程，按照官方的做法把它命名为 Job ，如下代码清单：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Job</span> : <span class="type">CoroutineContext.Element {</span></span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;Job&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt; <span class="keyword">get</span>() = Job</span><br><span class="line">    <span class="keyword">val</span> isActive: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnCancel</span><span class="params">(onCancel: <span class="type">OnCancel</span>)</span></span>: Disposable</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnCompletion</span><span class="params">(onComplete: <span class="type">OnComplete</span>)</span></span>: Disposable</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(disposable: <span class="type">Disposable</span>)</span></span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>与 Thread 相比， Job 同样有 join ，调用时会挂起( 而线程的 join 则会阻塞线程 )，直到协程完成；cancel() 类比与 Thread 的 interrupt() ，用于取消协程； isAlive() 类比 Thread 的 isAlive()  ，用于查询协程是仍在执行。</p>
<p>invokeOnCancel 用于协程取消时的回调；invokeOnCompletion 可以注册协程完成的回调。remove 用于移除回调。 key 将协程 Job 存入上下文，这样就很容易拿到 Job 实例。</p>
<h3 id="5-2-2-协程的状态"><a href="#5-2-2-协程的状态" class="headerlink" title="5.2.2 协程的状态"></a>5.2.2 协程的状态</h3><p>我们对协程进行封装，目的就是让它状态更容易管理。对于协程来讲，启动之后主要就是 <strong>未完成、已取消、已完成</strong>这几种状态，接下来定义一下状态：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineState</span> </span>{</span><br><span class="line">    <span class="comment">//未完成：协程启动后立即进入该状态，直到完成获取取消</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Imcomplete</span> : <span class="type">CoroutineState</span></span>()</span><br><span class="line">    <span class="comment">//已取消：协程被取消后立即进入该状态</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cancelling</span> : <span class="type">CoroutineState</span></span>()</span><br><span class="line">    <span class="comment">//已完成：协程执行完后（不管成功失败）进入该状态</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Complete</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> value: T? = <span class="literal">null</span>, <span class="keyword">val</span> exception: Throwable? = <span class="literal">null</span>) : CoroutineState()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>——————-中间略过一大截，看不懂—————————–</p>
<h2 id="5-4-协程的执行调度"><a href="#5-4-协程的执行调度" class="headerlink" title="5.4 协程的执行调度"></a>5.4 协程的执行调度</h2><p>协程在哪里挂起、什么时候恢复都是开发者自己决定的，意味着不像线程那样把调度工作交给操作系统，而是在用户态解决，所以协程也经常被称为<strong>用户态线程</strong>。</p>
<h3 id="5-4-2-协程的调度位置"><a href="#5-4-2-协程的调度位置" class="headerlink" title="5.4.2 协程的调度位置"></a>5.4.2 协程的调度位置</h3><p><strong>当协程执行到挂起点为止时，如果产生异步行为，协程就会在这个挂起点挂起</strong>，这里的一部情形包括以下形式：</p>
<ul>
<li><p>挂起点对应的挂起函数内部切换了线程，并在线程内部调用 Continuation 的恢复调用来恢复。</p>
</li>
<li><p>挂起函数内部通过某种事件循环机制将 Continuation 的恢复调用转到新的线程调用栈上执行。如：Android平台通过 Handler 的 post 操作，实际上这个过程不一定发生线程切换</p>
</li>
<li><p>挂起函数内部将 Continuation 保存，在后续某个时机再执行恢复调用，这个过程也不一定发生线程切换，但是函数调用栈会发生变化。</p>
</li>
</ul>
<p><strong>综上所述，不管何种形式，恢复和挂起不再同一个函数调用栈中执行就是挂起点挂起的充分条件！</strong>只有当挂起点真正挂起，我们才有机会实现调度，而<strong>实现调度需要使用协程拦截器</strong>。</p>
<h3 id="5-4-3-协程的调度器设计"><a href="#5-4-3-协程的调度器设计" class="headerlink" title="5.4.3 协程的调度器设计"></a>5.4.3 协程的调度器设计</h3><p>官方协程框架的默认调度器就是基于线程池实现的：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DefaultDispatcher : Dispatcher {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> threadGroup = ThreadGroup(<span class="string">"DefaultDispatcher"</span>) </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> threadIndex = AtomicInteger(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> executor = Executors.newFixedThreadPool(</span><br><span class="line">        Runtime.getRuntime().availableProcessors() + <span class="number">1</span></span><br><span class="line">    ) { runnable -&gt;</span><br><span class="line">        Thread(</span><br><span class="line">            threadGroup,</span><br><span class="line">            runnable,</span><br><span class="line">            <span class="string">"<span class="subst">${threadGroup.name}</span>-worker-<span class="subst">${threadIndex.getAndIncrement()}</span>"</span></span><br><span class="line">        ).apply { isDaemon = <span class="literal">true</span> }</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> {</span><br><span class="line">        executor.submit(block)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>调用dispatch 方法的时候，实际上是将 block 扔给 executor 放到线程中执行。</p>
<p>其实也可以实现成基于拦截器的方式：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> {</span><br><span class="line">    dispatcher.dispatch { delegate.resumeWith(result) }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>基于UI事件循环的调度器就是通过在disptch() 方法中用 Handler 的 post 实现：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> AndroidDispatcher : Dispatcher {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> handler = Handler(Looper.getMainLooper()) </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> {</span><br><span class="line">        handler.post(block)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<p>——————-后续的又看懵逼了—————————–</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/10/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC4%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/10/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC4%E7%AB%A0/" class="post-title-link" itemprop="url">第4章：Kotlin协程的拓展实践</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-10 16:55:00 / 修改时间：17:25:33" itemprop="dateCreated datePublished" datetime="2023-03-10T16:55:00+08:00">2023-03-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>前面的介绍了解了协程可以挂起和恢复，但是对于协程如何使用仍然倍感疑惑，所以还需要机遇简单协程构建足够有好的上层 API ，即复合协程。</p>
<h2 id="4-1-序列生成器"><a href="#4-1-序列生成器" class="headerlink" title="4.1 序列生成器"></a>4.1 序列生成器</h2><p>看得云里雾里，先略过</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/07/%E9%9D%A2-%E7%9F%A5%E8%AF%86/MP4%E8%A7%86%E9%A2%91%E9%A6%96%E5%B8%A7%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/07/%E9%9D%A2-%E7%9F%A5%E8%AF%86/MP4%E8%A7%86%E9%A2%91%E9%A6%96%E5%B8%A7%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">MP4视频首帧加载时间过长的问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-07 18:20:00" itemprop="dateCreated datePublished" datetime="2023-03-07T18:20:00+08:00">2023-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-14 22:23:41" itemprop="dateModified" datetime="2023-04-14T22:23:41+08:00">2023-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>MP4 格式的课程视频从打开播放器到第一帧画面显式，加载时间过长</p>
<h2 id="时间埋点"><a href="#时间埋点" class="headerlink" title="时间埋点"></a>时间埋点</h2><p>博客作者使用的是 ijkPlayer ，我们项目中使用的是 ExoPlayer ，不过这个关系不太大。给播放器加载过程埋点的时候需要关闭播放器自己打印的日志，否则会打印很多无关的内容。在本地视频模式和在线视频模式下分别打印关键方法的耗时。</p>
<p>从作者分析的数据可以看到，在线模式下，首帧耗时为 4.967s ，在线模式下首帧耗时 0.257s ，然后发现主要耗时是 avformat_open_input 方法（Exoplayer中方法可能是另一个）</p>
<h3 id="avformat-open-input-方法"><a href="#avformat-open-input-方法" class="headerlink" title="avformat_open_input 方法"></a>avformat_open_input 方法</h3><p>这个函数的主要作用是<strong>打开一个输入流并且读取它的头部信息</strong>。</p>
<h2 id="分析视频结构"><a href="#分析视频结构" class="headerlink" title="分析视频结构"></a>分析视频结构</h2><p>请求视频头部信息，在 MP4 格式下即为请求 moov 数据，可以使用 Media Parser 解析问题视频如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%9F%A5%E8%AF%86/%E9%97%AE%E9%A2%98%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.png" alt="问题视频数据可视化"></p>
<p>从图可以看出， moov 在视频文件尾部。本地播放时，可以通过指针快速定位到 moov ；<strong>在线播放时，需要先加载一部分头部数据，如 fytp、free、madat 等，计算出 moov 的偏移量，再通过 Http Range Bytes 请求 moov 数据。</strong></p>
<p>moov 数据约有 2.2M ，在线播放视频时，avformat_open_input 方法需要获取全部的 moov 数据，建立索引表后再解析音视频数据。而本地播放无需这个网络请求。</p>
<h2 id="结论及解决方案"><a href="#结论及解决方案" class="headerlink" title="结论及解决方案"></a>结论及解决方案</h2><h4 id="视频头过大导致的首帧过慢"><a href="#视频头过大导致的首帧过慢" class="headerlink" title="视频头过大导致的首帧过慢"></a>视频头过大导致的首帧过慢</h4><p><strong>问题：</strong>视频头过大，导致下载时间比较长，然后首帧出来就比较迟了</p>
<p><strong>解决方案：</strong>避免加载提及过大的视频头：1）将长视频拆分为多个短视频，减少 moov 的长度   2）使用轻量级格式，如分段FLV（爱奇艺、优酷）、DASH （YoTuBe、B站）等方案</p>
<h4 id="结构特性导致首帧过慢"><a href="#结构特性导致首帧过慢" class="headerlink" title="结构特性导致首帧过慢"></a>结构特性导致首帧过慢</h4><p><strong>问题：</strong> moov 在视频文件尾部，多了一次 seek 请求操作，这个问题比上述的问题要轻</p>
<p><strong>解决方案：</strong>在服务端使用 ffmpeg 命令将 moov 文件移到 ftyp 后面</p>
<h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><p><strong>问题：</strong> 播放的时候，还要同时先去下载视频头，导致了耗时较长</p>
<p><strong>解决方案：</strong>预加载，在适当时机提前加载视频头部数据，写入本地文件，播放器从本地读取数据，快速构建索引表，进入首帧解码</p>
<blockquote>
<p>以上内容参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/865c566c0a06">简书上的博客</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/07/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E9%A6%96%E5%B8%A7%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/07/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E9%A6%96%E5%B8%A7%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">MP4视频首帧加载时间过长的问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-07 16:18:00 / 修改时间：22:37:29" itemprop="dateCreated datePublished" datetime="2023-03-07T16:18:00+08:00">2023-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>MP4 格式的课程视频从打开播放器到第一帧画面显式，加载时间过长</p>
<h2 id="时间埋点"><a href="#时间埋点" class="headerlink" title="时间埋点"></a>时间埋点</h2><p>博客作者使用的是 ijkPlayer ，我们项目中使用的是 ExoPlayer ，不过这个关系不太大。给播放器加载过程埋点的时候需要关闭播放器自己打印的日志，否则会打印很多无关的内容。在本地视频模式和在线视频模式下分别打印关键方法的耗时。</p>
<p>从作者分析的数据可以看到，在线模式下，首帧耗时为 4.967s ，在线模式下首帧耗时 0.257s ，然后发现主要耗时是 avformat_open_input 方法（Exoplayer中方法可能是另一个）</p>
<h3 id="avformat-open-input-方法"><a href="#avformat-open-input-方法" class="headerlink" title="avformat_open_input 方法"></a>avformat_open_input 方法</h3><p>这个函数的主要作用是<strong>打开一个输入流并且读取它的头部信息</strong>。</p>
<h2 id="分析视频结构"><a href="#分析视频结构" class="headerlink" title="分析视频结构"></a>分析视频结构</h2><p>请求视频头部信息，在 MP4 格式下即为请求 moov 数据，可以使用 Media Parser 解析问题视频如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/Android%E5%9F%BA%E7%A1%80/MP4%E5%A4%B4%E7%BB%93%E6%9E%84.PNG" alt="问题视频数据可视化"></p>
<p>从图可以看出， moov 在视频文件尾部。本地播放时，可以通过指针快速定位到 moov ；<strong>在线播放时，需要先加载一部分头部数据，如 fytp、free、madat 等，计算出 moov 的偏移量，再通过 Http Range Bytes 请求 moov 数据。</strong></p>
<p>moov 数据约有 2.2M ，在线播放视频时，avformat_open_input 方法需要获取全部的 moov 数据，建立索引表后再解析音视频数据。而本地播放无需这个网络请求。</p>
<h2 id="结论及解决方案"><a href="#结论及解决方案" class="headerlink" title="结论及解决方案"></a>结论及解决方案</h2><h4 id="视频头过大导致的首帧过慢"><a href="#视频头过大导致的首帧过慢" class="headerlink" title="视频头过大导致的首帧过慢"></a>视频头过大导致的首帧过慢</h4><p><strong>问题：</strong>视频头过大，导致下载时间比较长，然后首帧出来就比较迟了</p>
<p><strong>解决方案：</strong>避免加载提及过大的视频头：1）将长视频拆分为多个短视频，减少 moov 的长度   2）使用轻量级格式，如分段FLV（爱奇艺、优酷）、DASH （YoTuBe、B站）等方案</p>
<h4 id="结构特性导致首帧过慢"><a href="#结构特性导致首帧过慢" class="headerlink" title="结构特性导致首帧过慢"></a>结构特性导致首帧过慢</h4><p><strong>问题：</strong> moov 在视频文件尾部，多了一次 seek 请求操作，这个问题比上述的问题要轻</p>
<p><strong>解决方案：</strong>在服务端使用 ffmpeg 命令将 moov 文件移到 ftyp 后面</p>
<h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><p><strong>问题：</strong> 播放的时候，还要同时先去下载视频头，导致了耗时较长</p>
<p><strong>解决方案：</strong>预加载，在适当时机提前加载视频头部数据，写入本地文件，播放器从本地读取数据，快速构建索引表，进入首帧解码</p>
<blockquote>
<p>以上内容参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/865c566c0a06">简书上的博客</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/27/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/27/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：Kotlin协程的基础设施</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-27 14:25:00" itemprop="dateCreated datePublished" datetime="2023-02-27T14:25:00+08:00">2023-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-10 16:54:39" itemprop="dateModified" datetime="2023-03-10T16:54:39+08:00">2023-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="3-1-协程的构造"><a href="#3-1-协程的构造" class="headerlink" title="3.1 协程的构造"></a>3.1 协程的构造</h2><h3 id="3-1-1-协程的创建"><a href="#3-1-1-协程的创建" class="headerlink" title="3.1.1 协程的创建"></a>3.1.1 协程的创建</h3><p>Kotlin 提供了一个 createCoroutine 函数用来创建协程：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>其中 suspend() -&gt; T 是 createCoroutin 函数的 Receiver，对 Kotlin 函数不了解的话，这个还是有点费解的。我们依次剖析 createCoroutine 的参数和返回值：</p>
<ul>
<li><p>Receiver 是一个被 suspend 修饰的挂起函数，这也是协程协程的执行体（协程体）</p>
</li>
<li><p>参数是 completion（是 Continuation 类型）会在协程体执行完后调用，实际上就是<strong>协程完成的回调</strong></p>
</li>
<li><p>返回值也是一个 Continuation 对象，由于现在协程仅仅被创建出来，因此需要通过这个值在之后触发协程的启动</p>
</li>
</ul>
<p>以一个例子来说明 createCoroutine 的用法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> continuation = <span class="keyword">suspend</span> {</span><br><span class="line">    println(<span class="string">"In Coroutine."</span>)</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">}.createCoroutine(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt; {</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">        println(<span class="string">"Coroutine End: <span class="variable">$result</span>"</span>)</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>目前协程被创建出来了，但是它还未启动。</p>
<h3 id="3-1-2-协程的启动"><a href="#3-1-2-协程的启动" class="headerlink" title="3.1.2 协程的启动"></a>3.1.2 协程的启动</h3><p>在上述的例子中，我们已经创建了协程，之后只需要调用 continuation.resume(Unit) 之后，协程就会立即开始。为什么这样就可以触发协程体执行呢？</p>
<p>其实，我们创建协程得到的 continuation 是 SafeContinuation 的实例，不过这也是个“马甲”，它有个 delegate 属性，里面将 suspend() -&gt; T  封装成了一个 Continuation 对象</p>
<p><strong>也就是说，我们创建协程得到的 continuation 其实就是套了几层“马甲”的协程体，故调用这个 continuation.resume() 可以触发协程体的执行</strong></p>
<p>一般来讲，我们创建协程之后就会启动它，所以标准库还提供了另一个一步到位的API——startCoroutin ：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(completion: Continuation&lt;T&gt;)</span><br></pre></td></tr></tbody></table></figure>

<p>我们知道，作为参数传入的 completion 就如同回调一样，**协程体的返回值会作为 resumeWith 的参数传入，例如，下面的例子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">suspend</span> {</span><br><span class="line">        println(<span class="string">"我跑在协程里"</span>)</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    }.startCoroutine(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt; {</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">            <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">            println(<span class="string">"协程执行完成，result = <span class="variable">$result</span>"</span>)</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果协程体执行正常，则 result 为 Success 结果；否则返回 Failure 结果。上述代码结果如下：</p>
<blockquote>
<p>我跑在协程里<br>//协程执行完成，result = Failure(java.lang.IllegalStateException: 抛出异常)<br>协程执行完成，result = Success(3)</p>
</blockquote>
<h3 id="3-1-3-协程体的-Receiver"><a href="#3-1-3-协程体的-Receiver" class="headerlink" title="3.1.3 协程体的 Receiver"></a>3.1.3 协程体的 Receiver</h3><p>与协程创建和启动相关的 API 还有一组：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> R.()</span></span> -&gt; T).create(</span><br><span class="line">    receiver: R,</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start 方法略</span></span><br></pre></td></tr></tbody></table></figure>

<p>上述的 R 可以为协程体提供一个作用域，在协程体内我们可以直接使用，如下代码所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先把上述方法封装下，如果不封装怎么调用？</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">launchCoroutine</span><span class="params">(receiver: <span class="type">R</span>, block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span>)</span></span> {</span><br><span class="line">    block.startCoroutine(receiver, <span class="keyword">object</span> : Continuation&lt;T&gt; {</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> {</span><br><span class="line">            println(<span class="string">"Coroutine End: <span class="variable">$result</span>"</span>)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context = EmptyCoroutineContext</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建额外的域</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerScope</span>&lt;<span class="type">T</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">(value: <span class="type">T</span>)</span></span> {</span><br><span class="line">        println(<span class="string">"我在额外的 Receiver 中了: <span class="variable">$value</span>"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    launchCoroutine(ProducerScope&lt;<span class="built_in">Int</span>&gt;()) {</span><br><span class="line">        println(<span class="string">"In Coroutine."</span>)</span><br><span class="line">        produce (<span class="number">1024</span>)</span><br><span class="line">        <span class="comment">//delay (1000)  //我自己测试的时候，如果放开这个注释，就不会打到 2048，coroutine end 也不会执行到</span></span><br><span class="line">        produce (<span class="number">2048</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>这里要注意的一点是，如果额外的域 ProducerScope 添加了 @RestrictsSuspension 注解，则无法使用外部的函数，因此例子中的 delay 也不会调用</p>
</blockquote>
<h3 id="3-1-4-可挂起的-main-函数"><a href="#3-1-4-可挂起的-main-函数" class="headerlink" title="3.1.4 可挂起的 main 函数"></a>3.1.4 可挂起的 main 函数</h3><p>前面我们一直这样写：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样就能在程序入口就获得一个协程了，这到底是怎么实现的呢？首先，我们能确认2点：</p>
<ul>
<li><p>JVM 压根就不知道什么挂起函数，kotlin协程</p>
</li>
<li><p>JVM 肯定有一个 main 函数的</p>
</li>
</ul>
<p>为了搞清楚原理，我们可以对 Kotlin 反编译成 Java 代码（IDEA的 Kotlin byteCode 功能）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>{</span><br><span class="line">   RunSuspendKt.runSuspend(<span class="keyword">new</span> KotlinMainKt$$$main(var0));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，其实它是有真正的 main 函数的，里面的协程封装逻辑都被扔到 RunSuspendKt里面了</p>
<h3 id="3-2-1-挂起函数"><a href="#3-2-1-挂起函数" class="headerlink" title="3.2.1 挂起函数"></a>3.2.1 挂起函数</h3><p>整个 kotlin 语境下有 2种函数： 普通函数和挂起函数，<strong>其中：挂起函数能调用任何函数，但是普通函数不能调用挂起函数。</strong></p>
<p>所谓的协程挂起其实就是程序执行流程发生异步调用时，当前调用流程进入等待状态。注意：<strong>挂起函数不一定真的会挂起，只是提供了挂起的条件</strong>，那额什么情况才会真正挂起呢？</p>
<h3 id="3-2-2-挂起点"><a href="#3-2-2-挂起点" class="headerlink" title="3.2.2 挂起点"></a>3.2.2 挂起点</h3><p>回想下协程的创建过程，我们的协程体本身就是一个 Continuation 实例，正因如此，挂起函数才能在协程体内运行。<strong>在协程体内部，挂起函数的调用处称为挂起点，挂起点如果出现异步调用，当前协程就会被挂起，直到对应的 Continuation.resume 函数被调用才会恢复执行。</strong></p>
<p><strong>异步调用如何发生，取决于 resume 函数与对应的挂起函数的调用是否在相同的调用栈上</strong></p>
<h3 id="3-2-3-CPS-变换"><a href="#3-2-3-CPS-变换" class="headerlink" title="3.2.3 CPS 变换"></a>3.2.3 CPS 变换</h3><p>我们知道，挂起函数如果需要挂起，则需要通过 suspendCoroutine 来获取 Continuation 实例，我们已经知道它是协程体封装成的 Continuation，但是这个实例是怎么传入的呢？先看下面的suspend 函数：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">notSuspend</span><span class="params">()</span></span> = suspendCoroutine&lt;<span class="built_in">Int</span>&gt; { continuation -&gt;</span><br><span class="line">    continuation.resume(<span class="number">100</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看起来这个方法没有接收任何参数，kotlin 中看不出来我们就用 Java 直接调用它：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Object result = KotlinMainKt.notSuspend(<span class="keyword">new</span> Continuation&lt;Integer&gt;() {</span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CoroutineContext <span class="title">getContext</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resumeWith</span><span class="params">(<span class="meta">@NotNull</span> Object o)</span> </span>{</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们发现用Java 调用的时候，需要传入一个 Continuation<integer> ，也就是说kotlin 中的 suspend() -&gt; Int 类型 在Java 看来实际上是 Continuation<integer> -&gt; Object 类型 ！</integer></integer></p>
<p>这与我们平时写的异步回调相似，传入callback 等待结果回调。但是为什么会有返回值 Object？这里的 Object 会有 2 种情况：</p>
<ul>
<li><p>挂起函数同步返回时：作为参数传入的 Continuation 的 resumeWith 不会被调用，函数实际地返回值 Object 就是挂起函数的返回值</p>
</li>
<li><p>挂起函数挂起，执行异步逻辑。此时函数返回值 Object 是一个挂起标志，通过这个标志外部协程就可以知道该函数需要挂起等到异步逻辑执行。</p>
</li>
</ul>
<p>挂起标志是一个常量，定义在 Intrinsics.kt 当中：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> COROUTINE_SUSPENDED: Any <span class="keyword">get</span>() = CoroutineSingletons.COROUTINE_SUSPENDED</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineSingletons</span> </span>{ </span><br><span class="line">    COROUTINE_SUSPENDED, </span><br><span class="line">    UNDECIDED, </span><br><span class="line">    RESUMED </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在大家知道了原来挂起函数就是普通函数<strong>参数</strong>中多了一个 Continuation 实例，这也难怪<strong>普通函数不能调用挂起函数，但是挂起函数可以调用普通函数的原因</strong>。</p>
<p>还可以仔细想想，为什么Kotlin 语法要求挂起函数一定要运行在协程体内或者挂起函数中呢？答案是：协程体或者挂起函数中都隐含了 Continuation 实例 </p>
<h2 id="3-3-协程的上下文"><a href="#3-3-协程的上下文" class="headerlink" title="3.3 协程的上下文"></a>3.3 协程的上下文</h2><h3 id="3-3-1-协程上下文的集合特征"><a href="#3-3-1-协程上下文的集合特征" class="headerlink" title="3.3.1 协程上下文的集合特征"></a>3.3.1 协程上下文的集合特征</h3><p>协程的 Context 更像是个 List 结构，都有空的表示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list: List&lt;<span class="built_in">Int</span>&gt; = emptyList()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> context: CoroutineContext = EmptyCoroutineContext</span><br></pre></td></tr></tbody></table></figure>

<p>接下来，我们往里面添加数据(<strong>要记得将 list 和 context 设置为 var 而不是 val ，我就是因为设置 val 所以不能用  “+” 操作</strong>)：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list += <span class="number">0</span>   <span class="comment">//添加一个元素，得到一个新的list</span></span><br><span class="line">list += listOf&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">//将listOf中的元素都添加进去，生成一个新的 list</span></span><br><span class="line"></span><br><span class="line">context += EmptyCoroutineContext</span><br></pre></td></tr></tbody></table></figure>

<p>协程 Context 是一个集合，那么它的元素类型是什么呢？看下代码:</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineContext</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the element with the given [key] from this context or `null`.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An element of the [CoroutineContext]. An element of the coroutine context is a singleton context by itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> : <span class="type">CoroutineContext {</span></span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A key of this coroutine context element.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line">        <span class="comment">//省略其他代码</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>Element 是本身也实现了 CoroutineContext 接口，这看上去就好像  Int 实现了 List<int> 接口一样，这就很奇怪。其实这主要是为了 API 设计方便，Element 中是不会存放除了它自己以外的其他数据的（<strong>这句话其实不太明白，还需要后续的理解</strong>）</int></p>
<p>Element 中有个属性 key ，这个属性很关键，虽然我们往 list中添加元素时没有明确指出，但是我们都知道 list 中的元素都有一个 index 索引，而<strong>这里的协程上下文Element 的 key 就是这个集合中元素的索引，不同之处是这个索引“长”在数据里面，意味着上下文的数据在出生时就找到了自己的位置</strong>（这句话同样不太理解。。。）</p>
<blockquote>
<p>可能有人觉得协程 Context 和 Map 似乎更近，为什么这里要与 List 对比呢？一是 List 的 Key 类型是固定的 Int ，而 Map 的Key 有很多种类型；二是是协程上下文内部实现是一个单链表，这也反映出它与 List 之间的关系。</p>
</blockquote>
<h3 id="3-3-2-协程上下文元素的实现"><a href="#3-3-2-协程上下文元素的实现" class="headerlink" title="3.3.2 协程上下文元素的实现"></a>3.3.2 协程上下文元素的实现</h3><p>上一节知道协程 Conext 是个接口，实际上还有个抽象类 AbstractCoroutineContextElement，能让我们实现协程上下文更加方便：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCoroutineContextElement</span></span>(<span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> key: Key&lt;*&gt;) : Element</span><br></pre></td></tr></tbody></table></figure>

<p>创建元素并不难，<strong>只需要提供对应的 Key 即可，以下是协程名的实现（系统源码）：</strong></p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineName</span></span>(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * User-defined coroutine name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">) : AbstractCoroutineContextElement(CoroutineName) {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Key for [CoroutineName] instance in the coroutine context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineName&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以下是协程异常处理器的实现源码：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineExceptionHandler</span></span>(<span class="keyword">val</span> onErrorAction: (Throwable) -&gt; <span class="built_in">Unit</span>) : AbstractCoroutineContextElement(Key) {</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(error: <span class="type">Throwable</span>)</span></span> {</span><br><span class="line">        error.printStackTrace()</span><br><span class="line">        onErrorAction(error)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-3-3-协程上下文的使用"><a href="#3-3-3-协程上下文的使用" class="headerlink" title="3.3.3 协程上下文的使用"></a>3.3.3 协程上下文的使用</h3><p>前面说了，可以为协程上下文添加多个 Context，添加好之后，我们可以将 Context 绑定到协程上了：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> {</span><br><span class="line">    println(<span class="string">"我在协程里面"</span>)</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">}.createCoroutine(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt; {</span><br><span class="line">    <span class="keyword">var</span> tempContext: CoroutineContext = CoroutineName(<span class="string">"name-01"</span>) + </span><br><span class="line">            CoroutineExceptionHandler(){</span><br><span class="line">        println(<span class="string">"出错啦"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = tempContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>先自己构建出 tempContext 然后再将 tempContext 赋值给 context。绑定了协程的上下文，我们的协程就初步成型了！接下来演示如何使用这个CoroutineExceptionHandler:</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">    result.onFailure {</span><br><span class="line">        context[CoroutineExceptionHandler]?.onError(it)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>不管结果如何，这个 resumeWith 是一定会被调用的，如果有异常出现，我们就从协程上下文找到 CoroutineExceptionHandler 实例，调用它的 onError 方法即可</strong>，这个上下文在协程内部都是可以直接获取的，比如，在协程内部获取名字：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> {</span><br><span class="line">    println(<span class="string">"协程名字：<span class="subst">${coroutineContext[CoroutineName]?.name}</span>"</span>)</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">}.createCoroutine(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>这样，我们就知道了协程上下文的设置和获取方法了。</p>
<h2 id="3-4-协程的拦截器"><a href="#3-4-协程的拦截器" class="headerlink" title="3.4 协程的拦截器"></a>3.4 协程的拦截器</h2><p>之前的内容知道 Kotlin 协程<strong>通过调用挂起函数实现挂起，通过Continuation 的恢复调用来实现恢复</strong>，还可以通过 Context 的设置来丰富协程能力，那么，如果处理线程的调度？其实标准库还提供了拦截器（Interceptor）的组件，允许我们拦截协程异步回调时的恢复调用，那么线程调度应该也不是什么难事。</p>
<h3 id="3-4-2-拦截器的使用"><a href="#3-4-2-拦截器的使用" class="headerlink" title="3.4.2 拦截器的使用"></a>3.4.2 拦截器的使用</h3><p>拦截器 ContinuationInterceptor 继承了 CoroutineContext.Element ，而Element 又继承 CoroutineContext 类型，所以<strong>拦截器也是 上下文 的一种实现</strong>。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ContinuationInterceptor</span> : <span class="type">CoroutineContext.Element</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> : <span class="type">CoroutineContext</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>自己定义拦截器只需要实现拦截器接口 ContinuationInterceptor 即可，比如打印日志(<strong>注意：拦截器的 Key 是一个固定值: ContinuationInterceptor</strong>,协程执行时会拿到拦截器并拦截)：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span></span>() : ContinuationInterceptor{</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt; = ContinuationInterceptor</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; {</span><br><span class="line">        <span class="keyword">return</span> LogContinuation(continuation)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogContinuation</span>&lt;<span class="type">T</span>&gt; </span>(<span class="keyword">private</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; <span class="keyword">by</span> continuation {</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> {</span><br><span class="line">        println(<span class="string">"执行前"</span>)</span><br><span class="line">        continuation.resumeWith(result)</span><br><span class="line">        println(<span class="string">"执行后"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来使用的时候，我们就将拦截器作为context就好了，前面说了拦截器本来就是上下文：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">haha</span> <span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">val</span> continuation = <span class="keyword">suspend</span> {</span><br><span class="line">        println(<span class="string">"我在协程里面"</span>)</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    }.startCoroutine(<span class="keyword">object</span> : Continuation&lt;<span class="built_in">Int</span>&gt;{</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = LogInterceptor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">            <span class="comment">//。。。</span></span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="3-4-3-拦截器的执行细节"><a href="#3-4-3-拦截器的执行细节" class="headerlink" title="3.4.3 拦截器的执行细节"></a>3.4.3 拦截器的执行细节</h3><p>略</p>
<h2 id="3-5-Kotlin-协程所属类别"><a href="#3-5-Kotlin-协程所属类别" class="headerlink" title="3.5 Kotlin 协程所属类别"></a>3.5 Kotlin 协程所属类别</h2><p>略</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/26/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/26/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：协程基本概念</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-26 10:05:00" itemprop="dateCreated datePublished" datetime="2023-02-26T10:05:00+08:00">2023-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-27 21:05:41" itemprop="dateModified" datetime="2023-02-27T21:05:41+08:00">2023-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="2-2-协程的分类"><a href="#2-2-协程的分类" class="headerlink" title="2.2 协程的分类"></a>2.2 协程的分类</h2><p>可以按照按照调用栈（函数调用栈，用来保存函数调用时的状态信息的数据结构）来分，因为<strong>协程需要挂起和恢复</strong>，因此对于挂起点的状态保存就极其关键。</p>
<h3 id="2-2-1-按照调用栈分类"><a href="#2-2-1-按照调用栈分类" class="headerlink" title="2.2.1 按照调用栈分类"></a>2.2.1 按照调用栈分类</h3><p>根据是否开辟相应的调用栈来分的话可以分为 2 类：</p>
<ul>
<li><p>有栈协程，需要额外的栈空间，但是灵活，可以在任意函数调用层级的任意位置挂起</p>
</li>
<li><p>无栈协程， 节省内存，咱 Kotlin 协程一般认为就归为这一类，<strong>依靠对协程体本身编译生成的状态机的状态流转来实现控制流</strong></p>
</li>
</ul>
<blockquote>
<p>不过，Kotlin 协程可以在<strong>挂起函数范围</strong>内任意调用层次挂起，换句话说，我们启动一个 Kotlin 协程，可以在其中任意嵌套 suspend 函数 ！</p>
</blockquote>
<h3 id="2-2-2-按调度方式分类"><a href="#2-2-2-按调度方式分类" class="headerlink" title="2.2.2 按调度方式分类"></a>2.2.2 按调度方式分类</h3><ul>
<li><p>对称协程： 任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移</p>
</li>
<li><p>非对称协程：协程出让调度权的目标只能是它的调用者，即<strong>协程之间存在调用和非调用关系</strong></p>
</li>
</ul>
<blockquote>
<p>可以看出来，对称协程和线程已经非常接近了</p>
</blockquote>
<h2 id="2-3-协程的实现举例"><a href="#2-3-协程的实现举例" class="headerlink" title="2.3 协程的实现举例"></a>2.3 协程的实现举例</h2><p>列举了各种语言协程的实现，这里先略过。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/26/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC8%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/26/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC8%E7%AB%A0/" class="post-title-link" itemprop="url">第8章：JUC容器类</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-26 09:12:00" itemprop="dateCreated datePublished" datetime="2023-02-26T09:12:00+08:00">2023-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-21 22:34:05" itemprop="dateModified" datetime="2023-02-21T22:34:05+08:00">2023-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>高并发场景下常见的设计模式可能存在线程安全问题，比如传统的单例模式就是典型。本章介绍几种高并发场景下常用的几种模式：<strong>线程安全的单例模式、ForkJoin模式、生产者-消费者模式、Master-Worker模式和 Future模式。</strong></p>
<h2 id="8-1-线程安全的单例模式"><a href="#8-1-线程安全的单例模式" class="headerlink" title="8.1 线程安全的单例模式"></a>8.1 线程安全的单例模式</h2><p>没有volatile 情况下的双重检查实现的单例模式，可能会存在问题，可以看到下面这句代码：</p>
<blockquote>
<p>instance = new Singleton();</p>
</blockquote>
<p>转换成（具有原子性的）汇编指令大致会分为 3个：</p>
<ol>
<li><p>分派一块内存 M</p>
</li>
<li><p>在 M 上初始化 Singleton 对象</p>
</li>
<li><p>M 的地址赋值给 instance 变量</p>
</li>
</ol>
<p>但是，以前说过可能会进行重排序，上面 3 个指令优化之后可能会变为：</p>
<ol>
<li><p>分派一块内存 M</p>
</li>
<li><p>M 的地址赋值给 instance 变量</p>
</li>
<li><p>在 M 上初始化 Singleton 对象</p>
</li>
</ol>
<p>指令重排后，获取单例可能导致问题发生，假设 A 、B线程过来获取单例：</p>
<ol>
<li><p>A 通过 getInstance() 方法，执行到分配一块内存并将地址赋值给 instance，恰好发生了线程切换，<strong>此时，A 还没来得及对 M 指向的内存初始化</strong></p>
</li>
<li><p>线程 B 进入 getInstance() 方法，判断 instance 不为空，于是 B 直接获取到了未初始化的 instance</p>
</li>
<li><p>线程 B 使用未初始化完全的对象 instance 在访问 instance 的成员变量时可能会发生异常</p>
</li>
</ol>
<p>所以需要添加 volatile 防止指令重排。</p>
<h3 id="8-1-5-使用静态内部类实现懒汉式单例模式"><a href="#8-1-5-使用静态内部类实现懒汉式单例模式" class="headerlink" title="8.1.5 使用静态内部类实现懒汉式单例模式"></a>8.1.5 使用静态内部类实现懒汉式单例模式</h3><p>虽然通过 <strong>双重锁检查+volatile</strong>相结合的方式能实现高性能、线程安全的单例模式，但是该实现的底层原理比较复杂、实现繁琐，另一种易于理解、编程简单的单例模式实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取单例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这种方式只有在调用 getInstance() 的时候才会初始化单例，该方式既解决了线程安全问题，又解决了写法繁琐的问题。书中推荐使用这种方案。</p>
<h2 id="8-2-Master-worker-模式"><a href="#8-2-Master-worker-模式" class="headerlink" title="8.2 Master-worker 模式"></a>8.2 Master-worker 模式</h2><p>这是一种常见的高并发模式，它的核心思想是：任务的调度和执行分离，调度任务的角色是 Master，执行任务的角色是 Worker，Master 负责接收、分配和合并（Merge）任务结果，Worker 负责执行任务。</p>
<h3 id="8-2-1-Master-worker-模式的参考实现"><a href="#8-2-1-Master-worker-模式的参考实现" class="headerlink" title="8.2.1 Master-worker 模式的参考实现"></a>8.2.1 Master-worker 模式的参考实现</h3><h4 id="Master-的参考代码"><a href="#Master-的参考代码" class="headerlink" title="Master 的参考代码"></a>Master 的参考代码</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Task</span>, <span class="title">R</span>&gt; </span>{</span><br><span class="line">    <span class="comment">// 所有Worker的集合</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Worker&lt;T, R&gt;&gt; workers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务的集合</span></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;T&gt; taskQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务处理结果集合</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;String, R&gt; resultMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Master的任务调度线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保持最终的和</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong sum = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Master</span><span class="params">(<span class="keyword">int</span> workerCount)</span> </span>{</span><br><span class="line">        <span class="comment">// 每个Worker对象都需要持有queue的引用，用于领任务与提交结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workerCount; i++) {</span><br><span class="line">            Worker&lt;T, R&gt; worker = <span class="keyword">new</span> Worker&lt;&gt;();</span><br><span class="line">            workers.put(<span class="string">"子节点: "</span> + i, worker);</span><br><span class="line">        }</span><br><span class="line">        thread = <span class="keyword">new</span> Thread(() -&gt; <span class="keyword">this</span>.execute());</span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(T task)</span> </span>{</span><br><span class="line">        taskQueue.add(task);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取worker结果处理的回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resultCallBack</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        Task&lt;R&gt; task = (Task&lt;R&gt;) o;</span><br><span class="line">        String taskName = <span class="string">"Worker:"</span> + task.getWorkerId() + <span class="string">"-"</span> + <span class="string">"Task:"</span> + task.getId();</span><br><span class="line">        R result = task.getResult();</span><br><span class="line">        resultMap.put(taskName, result);</span><br><span class="line">        sum.getAndAdd((Integer) result); <span class="comment">//和的累加</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动所有的子任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; ; ) {</span><br><span class="line">            <span class="comment">// 从任务队列中获取任务，然后Worker节点轮询，轮流分</span></span><br><span class="line">            配任务</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Worker&lt;T, R&gt;&gt; entry :workers.entrySet()) {</span><br><span class="line">                T task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    task = <span class="keyword">this</span>.taskQueue.take();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取任务</span></span><br><span class="line">                    Worker worker = entry.getValue(); <span class="comment">//</span></span><br><span class="line">                    获取节点</span><br><span class="line">                    worker.submit(task, <span class="keyword">this</span>::resultCallBack); <span class="comment">//分配任务</span></span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最终的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printResult</span><span class="params">()</span> </span>{</span><br><span class="line">        Print.tco(<span class="string">"----------sum is :"</span> + sum.get());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, R&gt; entry : resultMap.entrySet()) {</span><br><span class="line">            String taskName = entry.getKey();</span><br><span class="line">            Print.fo(taskName + <span class="string">":"</span> + entry.getValue());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="Worker-的代码实现"><a href="#Worker-的代码实现" class="headerlink" title="Worker 的代码实现"></a>Worker 的代码实现</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Task</span>, <span class="title">R</span>&gt; </span>{</span><br><span class="line">    <span class="comment">//接收任务的阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;T&gt; taskQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">//Worker 的编号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger index = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerId;</span><br><span class="line">    <span class="comment">//执行任务的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.workerId = index.getAndIncrement();</span><br><span class="line">        thread = <span class="keyword">new</span> Thread(() -&gt; <span class="keyword">this</span>.run());</span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 轮询执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 轮询启动所有的子任务</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//从阻塞队列中提取任务</span></span><br><span class="line">                T task = <span class="keyword">this</span>.taskQueue.take();</span><br><span class="line">                task.setWorkerId(workerId);</span><br><span class="line">                task.execute();</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收任务到异步队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(T task, Consumer&lt;R&gt; action)</span> </span>{</span><br><span class="line">        task.resultAction = action; <span class="comment">//设置任务的回调方法</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">this</span>.taskQueue.put(task);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="8-3-FokJoin模式"><a href="#8-3-FokJoin模式" class="headerlink" title="8.3 FokJoin模式"></a>8.3 FokJoin模式</h2><p>目前没心思看，先略过</p>
<h2 id="8-4-生产者-消费者模式"><a href="#8-4-生产者-消费者模式" class="headerlink" title="8.4 生产者-消费者模式"></a>8.4 生产者-消费者模式</h2><p>略过</p>
<h2 id="8-5-Future模式"><a href="#8-5-Future模式" class="headerlink" title="8.5 Future模式"></a>8.5 Future模式</h2><p>略</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/25/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC7%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/25/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC7%E7%AB%A0/" class="post-title-link" itemprop="url">第7章：JUC容器类</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-25 21:21:00" itemprop="dateCreated datePublished" datetime="2023-02-25T21:21:00+08:00">2023-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-21 21:52:01" itemprop="dateModified" datetime="2023-02-21T21:52:01+08:00">2023-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>Java的基础容器主要有 List、Set、Queue、Map 四大类，但是大家熟知的 ArrayList、LinkedList 、HashMap 等都不是线程安全的。为了解决安全问题，Java用内置锁提供了一套线程安全的同步容器类，但是效率不高；因此，JUC提供了一套高并发容器。</p>
<h2 id="7-1-线程安全的同步容器类"><a href="#7-1-线程安全的同步容器类" class="headerlink" title="7.1 线程安全的同步容器类"></a>7.1 线程安全的同步容器类</h2><p>Java 同步容器类通过 synchronized 来实现同步的容器，比如 HashTable、Vector 以及 SynchronizedList 等容器，另外，Java 还提供了一组包装方法，将一个普通的基础容器包装成线程安全的同步容器，例如通过 Collections.synchronizedMap() 包装方法能将Map 包装成线程安全的 Map，看代码就能知道其原理：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.util.Collections</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K, V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedMap&lt;&gt;(m);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;,<span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;</span><br><span class="line">    <span class="keyword">final</span> Object mutext;</span><br><span class="line"></span><br><span class="line">    SynchronizedMap(Map&lt;K,V&gt; m) {</span><br><span class="line">        <span class="keyword">this</span>.m = Objects.requeireNonNull(m);</span><br><span class="line">        <span class="keyword">this</span>.mutext = <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span> <span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (mutext) {</span><br><span class="line">            <span class="keyword">return</span> m.size();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isEmpty</span> <span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (mutext) {</span><br><span class="line">            <span class="keyword">return</span> m.isEmpty();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ....省略其他方法</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过上述代码可以看出，Collections 提供的包装方法实现步骤：<strong>首先实现了容器的操作接口，在操作接口上使用 synchronized 进行线程同步，然后在 synchronized 临界区将实际的操作委托给被包装的基础容器。</strong></p>
<h3 id="7-1-1-同步容器面临的问题"><a href="#7-1-1-同步容器面临的问题" class="headerlink" title="7.1.1 同步容器面临的问题"></a>7.1.1 同步容器面临的问题</h3><p>由前面的描述可知：同步容器实现线程安全的方式是(包括HashTable之类的以及 Collections包装类之类的)*<em>在需要同步访问的方法上添加关键字 synchonized *</em>。所以效率并不高。</p>
<h2 id="7-2-JUC-高并发容器"><a href="#7-2-JUC-高并发容器" class="headerlink" title="7.2 JUC 高并发容器"></a>7.2 JUC 高并发容器</h2><p>为了解决同步容器的性能问题，有了 JUC 高并发容器。高并发容器是基于<strong>非阻塞算法(也说无锁编程算法)</strong>实现的容器类，<strong>主要通过 CAS(Compare And Swap) + volatile 组合实现，其中 CAS 保证原子性，volatile 保证可见性</strong>。其主要优点如下：</p>
<ul>
<li>开销小：无需在内核态和用户态来回切换</li>
<li>读写不互斥： 读读操作之间可以不互斥，只有写操作需要使用基于 CAS 机制的乐观锁</li>
</ul>
<h2 id="7-3-CopyOnWriteArrayList"><a href="#7-3-CopyOnWriteArrayList" class="headerlink" title="7.3 CopyOnWriteArrayList"></a>7.3 CopyOnWriteArrayList</h2><p>很多应用场景读操作可能会远远大于写操作，由于读操作不会修改原有数据，因此每次读取都要加锁其实是一种浪费。</p>
<h3 id="7-3-2-CopyOnWriteArrayList-原理"><a href="#7-3-2-CopyOnWriteArrayList-原理" class="headerlink" title="7.3.2 CopyOnWriteArrayList 原理"></a>7.3.2 CopyOnWriteArrayList 原理</h3><p>CopyOnWrite(写时复制)就是在修改器对一块内存进行修改时，不直接在原有内存块上进行写操作，而是将内存复制一份，在新的内存中进行写操作，写完之后，再将原来的指针(引用)指向新的内存，原来的内存GC 。CopyOnWriteArrayList 的核心成员如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>,<span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 对所有的修改器方法进行保护，访问器方法并不需要保护 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">     <span class="comment">/** 内部对象数组，通过 getArray/setArray 方法访问 */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *获取内部对象数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] getArray() {</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *设置内部对象数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>{</span><br><span class="line">      array = a;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-3-3-CopyOnWriteArrayList-的读取操作"><a href="#7-3-3-CopyOnWriteArrayList-的读取操作" class="headerlink" title="7.3.3 CopyOnWriteArrayList 的读取操作"></a>7.3.3 CopyOnWriteArrayList 的读取操作</h3><p>读取操作没有任何同步操作和锁控制，理由是内部数组array 不会发生修改，只会被另一个 array 替换，因此可以保证数据安全：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 操作内存的引用*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line"><span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回操作内存</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() {</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-3-4-CopyOnWriteArrayList-写入操作"><a href="#7-3-4-CopyOnWriteArrayList-写入操作" class="headerlink" title="7.3.4 CopyOnWriteArrayList 写入操作"></a>7.3.4 CopyOnWriteArrayList 写入操作</h3><p>写入操作 add() 方法在执行时加了独占锁以确保只能有一个线程进行写入操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); </span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>每次进行添加操作时，都会重新复制一份数组，再往新数组中添加元素，添加完了，再将array 引用指向新的数组。也就是<strong>当add() 操作完成后，array 的引用就已经指向新的存储空间了</strong>。</p>
<h3 id="7-3-5-CopyOnWriteArrayList-优缺点以及对比-自己加的章节"><a href="#7-3-5-CopyOnWriteArrayList-优缺点以及对比-自己加的章节" class="headerlink" title="7.3.5 CopyOnWriteArrayList 优缺点以及对比(自己加的章节)"></a>7.3.5 CopyOnWriteArrayList 优缺点以及对比(自己加的章节)</h3><h4 id="7-3-5-1-优缺点-自己加的章节"><a href="#7-3-5-1-优缺点-自己加的章节" class="headerlink" title="7.3.5.1 优缺点(自己加的章节)"></a>7.3.5.1 优缺点(自己加的章节)</h4><ul>
<li>优点：高并发操作下读取、遍历操作不需要同步，速度非常快，适用于“读多写少“的场景</li>
<li>缺点： 每次添加要复制一份，增加内存开销</li>
</ul>
<h4 id="7-3-5-2-比较-自己加的章节"><a href="#7-3-5-2-比较-自己加的章节" class="headerlink" title="7.3.5.2 比较(自己加的章节)"></a>7.3.5.2 比较(自己加的章节)</h4><p>CopyOnWriteArrayList 和 ReentrantReadWriteLock (读写锁) 的思想非常类似，ReentrantReadWriteLock 的泗县时：读读共享、写写互斥、读写互斥、写读互斥，而 CopyOnWriteArrayList 更进一步了：为了将读取的性能发挥到极致，读取时完全不加锁。</p>
<h2 id="7-4-BlockingQueue"><a href="#7-4-BlockingQueue" class="headerlink" title="7.4 BlockingQueue"></a>7.4 BlockingQueue</h2><p>在多线程环境中，通过 BlockingQueue (阻塞队列) 可以很容易实现多线程之间的数据共享和通信，比如在经典的“生产者-消费者“模型中，通过 BlockingQueue 可以完成一个高性能版本。</p>
<h3 id="7-4-3-常见的-BlockingQueue"><a href="#7-4-3-常见的-BlockingQueue" class="headerlink" title="7.4.3 常见的 BlockingQueue"></a>7.4.3 常见的 BlockingQueue</h3><p>BlockingQueue 的实现类大概有 ：ArrayBlockingQueue、DelayQueue、LinkedBlockingDeque、<br>PriorityBlockingQueue、SynchronousQueue等。</p>
<h4 id="7-4-3-1-ArrayBlockingQueue"><a href="#7-4-3-1-ArrayBlockingQueue" class="headerlink" title="7.4.3.1 ArrayBlockingQueue"></a>7.4.3.1 ArrayBlockingQueue</h4><p>ArrayBlockingQueue 内部<strong>采用定长数组来存储元素，添加和删除操作采用同一个锁对象，也就是说添加和删除无法并行运行(为什么不能并行呢？因为作者认为ArrayBlockingQueue的写入和获取操作已经足够轻量了)</strong>。</p>
<blockquote>
<p>为什么 ArrayBlockingQueue 比 LinkedBlockingQueue 更加常用？因为前者添加或者删除的时候不会产生或者销毁任何额外的 Node 实例，在高并发场景下，这可以减轻系统 GC 压力</p>
</blockquote>
<h4 id="7-4-3-2-LinkedBlockingQueue"><a href="#7-4-3-2-LinkedBlockingQueue" class="headerlink" title="7.4.3.2 LinkedBlockingQueue"></a>7.4.3.2 LinkedBlockingQueue</h4><p>LinkedBlockingQueue 是基于链表的阻塞队列，对于添加和删除元素分别才用了独立的锁控制，也就是在高并发场景下，消费者和生产者可以并行地操作队列中数据。</p>
<blockquote>
<p>需要注意的是，新建 LinkedBlockingQueue 时如果没有指定其容量大小，则默认大小近乎无限(Integer.MAX_VALUE)，这样的话，一旦生产速度大于消费速度，也许还没等到队列满阻塞产生，系统内存就消耗光了。</p>
</blockquote>
<h4 id="7-4-3-3-DelayQueue"><a href="#7-4-3-3-DelayQueue" class="headerlink" title="7.4.3.3 DelayQueue"></a>7.4.3.3 DelayQueue</h4><p>DelayQueue 只有当其指定的延迟时间到了才能够从队列中取该元素，<strong>它是一个没有大小限制的队列，因此添加(生产者)永远不会被阻塞，只有获取数据(消费者)才会被阻塞。</strong></p>
<blockquote>
<p>DelayQueue 的适用场景较少，常见的例子是用来管理一个超时未响应的连接队列</p>
</blockquote>
<h4 id="7-4-3-4-PriorityBlockingQueue"><a href="#7-4-3-4-PriorityBlockingQueue" class="headerlink" title="7.4.3.4 PriorityBlockingQueue"></a>7.4.3.4 PriorityBlockingQueue</h4><p>PriorityBlockingQueue 和 DelayQueue 类似，它也不会阻塞生产者，只会在没有可消费的数据时阻塞消费者。</p>
<h4 id="7-4-3-5-SynchronousQueue"><a href="#7-4-3-5-SynchronousQueue" class="headerlink" title="7.4.3.5 SynchronousQueue"></a>7.4.3.5 SynchronousQueue</h4><p>SynchronousQueue 是一种无缓冲的等待队列，不像 LinkedBlockingQueue 有中间缓冲区，所以吞吐率相对而言会低一些。不过对于单个任务来说，正因为没有缓冲区，所以响应会快一些。</p>
<p>LinkedBlockingQueue、DelayQueue 以及 PriorityBlockingQueue 都需要注意生产速度不能快于消费者，否则容易耗光内存。</p>
<h3 id="7-4-4-ArrayBlockingQueue-的基本使用"><a href="#7-4-4-ArrayBlockingQueue-的基本使用" class="headerlink" title="7.4.4 ArrayBlockingQueue 的基本使用"></a>7.4.4 ArrayBlockingQueue 的基本使用</h3><p>用 ArrayBlockingQueue 队列实现一个生产者-消费者的案例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 省略import</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueuePetStore</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AMOUNT = <span class="number">10</span>; <span class="comment">//数据区长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//共享数据区，类定义</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBuffer</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">        <span class="comment">//使用阻塞队列保存数据</span></span><br><span class="line">        <span class="keyword">private</span> ArrayBlockingQueue&lt;T&gt; dataList = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(MAX_AMOUNT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向数据区增加一个元素，委托给阻塞队列</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T element)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            dataList.add(element); <span class="comment">//直接委托</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 从数据区取出一个商品，委托给阻塞队列</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">return</span> dataList.take(); <span class="comment">//直接委托</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Print.cfo(<span class="string">"当前进程的ID是"</span> + JvmUtil.getProcessID());</span><br><span class="line">        System.setErr(System.out);</span><br><span class="line">        <span class="comment">//共享数据区，实例对象</span></span><br><span class="line">        DataBuffer&lt;IGoods&gt; dataBuffer = <span class="keyword">new</span> DataBuffer&lt;&gt;();</span><br><span class="line">        <span class="comment">//生产者执行的操作</span></span><br><span class="line">        Callable&lt;IGoods&gt; produceAction = () -&gt; {</span><br><span class="line">            <span class="comment">//首先生成一个随机的商品</span></span><br><span class="line">            IGoods goods = Goods.produceOne();</span><br><span class="line">            <span class="comment">//将商品加上共享数据区</span></span><br><span class="line">            dataBuffer.add(goods);</span><br><span class="line">            <span class="keyword">return</span> goods;</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//消费者执行的操作</span></span><br><span class="line">        Callable&lt;IGoods&gt; consumerAction = () -&gt; {</span><br><span class="line">        <span class="comment">// 从PetStore获取商品</span></span><br><span class="line">            IGoods goods = <span class="keyword">null</span>;</span><br><span class="line">            goods = dataBuffer.fetch();</span><br><span class="line">            <span class="keyword">return</span> goods;</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> THREAD_TOTAL = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 线程池，用于多线程模拟测试</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_TOTAL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假定共11个线程，其中有10个消费者，但是只有1个生产者</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> CONSUMER_TOTAL = <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PRODUCE_TOTAL = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PRODUCE_TOTAL; i++) {</span><br><span class="line">            <span class="comment">//生产者线程每生产一个商品，间隔50毫秒</span></span><br><span class="line">            threadPool.submit(<span class="keyword">new</span></span><br><span class="line">            Producer(produceAction, <span class="number">50</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONSUMER_TOTAL; i++){</span><br><span class="line">            <span class="comment">//消费者线程每消费一个商品，间隔100毫秒</span></span><br><span class="line">            threadPool.submit(<span class="keyword">new</span></span><br><span class="line">            Consumer(consumerAction, <span class="number">100</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-4-6-非阻塞式添加元素-add-、offer-方法的原理"><a href="#7-4-6-非阻塞式添加元素-add-、offer-方法的原理" class="headerlink" title="7.4.6 非阻塞式添加元素 add()、offer() 方法的原理"></a>7.4.6 非阻塞式添加元素 add()、offer() 方法的原理</h3><p>首先来看非阻塞式添加元素，<strong>在队列满而不能添加元素时，非阻塞式添加元素的方法会立即返回，所以线程不会被阻塞。</strong>add() 方法的实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出直接调用了 offer 方法，如果 offer 方法添加失败，直接抛出异常，否则返回true。</p>
<p>offer() 方法的实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//offer()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    checkNotNull(e); <span class="comment">//检查元素是否为null</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)<span class="comment">//判断数组是否已满</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            enqueue(e);<span class="comment">//添加元素到队列</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，offer() 方法的操作如下：</p>
<ol>
<li>如果数组满了，就直接释放锁，返回false</li>
<li>数组没满，将元素加入队(通过enqueue()方法)然后返回true</li>
</ol>
<h3 id="7-4-7-阻塞式添加元素：put-方法的原理"><a href="#7-4-7-阻塞式添加元素：put-方法的原理" class="headerlink" title="7.4.7 阻塞式添加元素：put() 方法的原理"></a>7.4.7 阻塞式添加元素：put() 方法的原理</h3><p>put() 方法是一个阻塞方法，如果队列元素已满，那么当前线程会被加入 notFull 条件等待队列中，直到有空位置才会被唤醒执行添加操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put()方法，阻塞时可中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();<span class="comment">//该方法可中断</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//当队列元素个数与数组长度相等时，无法添加元素</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">        <span class="comment">//将当前调用线程挂起，添加到notFull条件队列中，等待被唤醒</span></span><br><span class="line">        notFull.await();</span><br><span class="line">        enqueue(e);<span class="comment">//如果队列没有满，就直接添加</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结一下put()流程:</p>
<ol>
<li>获取 putLock 锁</li>
<li>如果队列满了，就被阻塞，put线程进入 notFull 等待队列，等着被唤醒</li>
<li>如果队列未满，通过 enqueue 方法入队</li>
<li>释放 putLock 锁</li>
</ol>
<h3 id="7-4-8-非阻塞式删除元素：-poll-方法"><a href="#7-4-8-非阻塞式删除元素：-poll-方法" class="headerlink" title="7.4.8 非阻塞式删除元素： poll() 方法"></a>7.4.8 非阻塞式删除元素： poll() 方法</h3><p>当队列空而不能删除元素时，非阻塞删除元素的方法会立即返回，执行线程不会被阻塞。poll() 方法实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//判断队列是否为null，不为null执行dequeue()方法，否则返回null</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>里面使用了 dequeue() 方法出队：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除队列头元素并返回</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//拿到当前数组的数据</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">    <span class="comment">//获取要删除的对象</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    <span class="comment">//清空位置：将数组中的takeIndex索引位置设置为null</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//takeIndex索引加1并判断是否与数组长度相等</span></span><br><span class="line">    <span class="comment">//如果相等就说明已到尽头，恢复为0</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;<span class="comment">//元素个数减1</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();<span class="comment">//同时更新迭代器中的元素数据</span></span><br><span class="line">    <span class="comment">//删除了元素说明队列有空位，唤醒notFull条件等待队列中的put线程，执行添加操作</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>主要注意后面的通过 notFull.signal() 唤醒条件等待队列中的一个 put 线程。阻塞式的 take() 方法略。</p>
<h2 id="7-5-ConcurrentHashMap"><a href="#7-5-ConcurrentHashMap" class="headerlink" title="7.5 ConcurrentHashMap"></a>7.5 ConcurrentHashMap</h2><p>在 Java 7 之前版本 ConcurrentHashMap 采用分段锁实现，数据分为一段一段的，每段分配一把锁，当一个线程访问其中一段数据的时候，其他段的数据能被正常访问，实现了真正的并发访问；Java8对内部存储结构进行了优化，性能进一步提升。</p>
<h3 id="7-5-1-HashMap-和-HashTable-的问题"><a href="#7-5-1-HashMap-和-HashTable-的问题" class="headerlink" title="7.5.1 HashMap 和 HashTable 的问题"></a>7.5.1 HashMap 和 HashTable 的问题</h3><p>HashMap 不是线程安全的，<strong>多线程环境下，HashMap 的 put() 操作可能会引起死循环，导致CPU使用率接近100%。</strong>于是JDK提供了线程安全的Map-HashTable，它使用几乎与 HashMap 几乎一样区别有2点：</p>
<ul>
<li>HashTable 不允许key 和value 为null</li>
<li>HashTable 的包括 get/set 在内的方法都是用 synchronized 来保证线程安全，对整个 Hash 表锁定，但是代价会非常大的</li>
</ul>
<h3 id="7-5-2-Java-1-7-及以前版本的-ConcurrentHashMap"><a href="#7-5-2-Java-1-7-及以前版本的-ConcurrentHashMap" class="headerlink" title="7.5.2 Java 1.7 及以前版本的 ConcurrentHashMap"></a>7.5.2 Java 1.7 及以前版本的 ConcurrentHashMap</h3><p>分段锁是一种锁设计，并不是具体的锁。对于 ConcurrentHashMap 而言，分段锁技术将 key 分成一个个小 segment 存储，给每段数据一把锁，当一个线程占用锁访问其中一段数据时，其他段数据也能被其他线程访问，实现真正的并发。</p>
<p>这个原理已经比较了解了，这里就不按照书本的章节走，略过了</p>
<h3 id="7-5-4-JDK-1-8版本-ConcurrentHashMap-的结构"><a href="#7-5-4-JDK-1-8版本-ConcurrentHashMap-的结构" class="headerlink" title="7.5.4 JDK 1.8版本 ConcurrentHashMap 的结构"></a>7.5.4 JDK 1.8版本 ConcurrentHashMap 的结构</h3><p>1.7 版本虽然<strong>通过 segment 方式实现了并发热点分离</strong>，默认情况下将一个table 分裂成 16 个小的 table(Segment表示)，从而在 Segment 维度实现并发。但是这样并发粒度还不够细。1.8 版本抛弃了 Segment 分段锁机制，存储结构采用数组+链表或者红黑树的组合方式，<strong>将并发粒度细化到每一个桶，进一步细化了热点</strong>，利用 CAS + Synchronized 来保证并发更新安全。</p>
<blockquote>
<p>JDK 1.7 的 ConcurrentHashMap 每个桶为链表结构，1.8 引入了红黑树结构，当桶的节点超过阈值(默认64)时，自动将链表结构转换为红黑树，<strong>可以理解为将链式桶转为树状桶</strong>。这样的好处在于，访问的时候只需要对一个桶锁定，而不需要将整个 Map 集合都进行粗粒度锁定。事实上，引入红黑树的一个原因是：链表查询复杂度 O(n) ，红黑树查询复杂度 O(log(n))</p>
</blockquote>
<p><img src="/assets/Book-Notes/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%8D%B72/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%8D%B72-%E7%AC%AC7%E7%AB%A0-%E4%B8%80%E4%B8%AA1.8%E7%89%88%E6%9C%AC%E7%9A%84ConcurrentHashMap%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.jpg" alt="一个1.8版本的ConcurrentHashMap实例内部结构"></p>
<h3 id="7-5-5-ConcurrentHashMap的核心原理-1-8-版本"><a href="#7-5-5-ConcurrentHashMap的核心原理-1-8-版本" class="headerlink" title="7.5.5 ConcurrentHashMap的核心原理-1.8 版本"></a>7.5.5 ConcurrentHashMap的核心原理-1.8 版本</h3><p>JDK 1.8版本的ConcurrentHashMap中通过一个 Node&lt;K,V&gt;[] 数组table 来保存添加到哈希表中的桶，在同一个 Bucket 位置是通过链表和 红黑树的形式来保存的，<strong>但是 table 是懒加载的，只有在第一次添加元素的时候才会初始化</strong>。它的主要成员属性大致如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class"><span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"> <span class="comment">//常量：表示正在转移</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED = -<span class="number">1</span>;</span><br><span class="line"> <span class="comment">// 常量：表示已经转换成树</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN = -<span class="number">2</span>; </span><br><span class="line"> <span class="comment">// 常量：hash for transient reservations</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED = -<span class="number">3</span>; </span><br><span class="line"> <span class="comment">// 常量：usable bits of normal node hash</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; </span><br><span class="line"> <span class="comment">//数组，用来保存元素</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"> <span class="comment">//转移时用的数组</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来控制表初始化和扩容的控制属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 省略其他</span></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<p>重要属性介绍如下：</p>
<ul>
<li>table用于保存添加到哈希表中的桶</li>
<li>DEFAULT_CAPACITY： table的默认长度。默认初期长度为16，在第一次添加元素时，会将table初始化成16个元素的数组</li>
<li>sizeCtl：sizeCtl用来控制table的初始化和扩容操作的过程</li>
</ul>
<p>涉及修改 sizeCtl 的方法有 5 个：</p>
<ul>
<li>initTable()：初始化哈希表时，涉及sizeCtl的修改</li>
<li>addCount()：增加容量时，涉及sizeCtl的修改</li>
<li>tryPresize()：ConcurrentHashMap扩容方法之一</li>
<li>transfer()：table数据转移到 nextTable，扩容操作的核心在于数据的转移，把旧数组中的数据前一到新的数组。ConcurrentHashMap可以利用多线程来协同扩容，简单说是把 table 数组当做多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程锁负责的取件，一个已经迁移完的 Bucket 会被替换为一个 ForwardingNode 节点，标记当前 Bucket 已经被其他线程迁移完成。</li>
<li>helpTransfer()：并发添加元素时，如果正在扩容，其他线程会帮助扩容，也就是多线程扩容。</li>
</ul>
<h3 id="7-5-6-JDK-1-8-版本-ConcurrentHashMap的核心源码"><a href="#7-5-6-JDK-1-8-版本-ConcurrentHashMap的核心源码" class="headerlink" title="7.5.6 JDK 1.8 版本 ConcurrentHashMap的核心源码"></a>7.5.6 JDK 1.8 版本 ConcurrentHashMap的核心源码</h3><p>下面来看JDK 1.8版本ConcurrentHashMap的put()操作:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自旋：并发情况下，也可以保障安全添加成功</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K, V&gt;[] tab = table; ; ) {</span><br><span class="line">        Node&lt;K, V&gt; f;</span><br><span class="line">        <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">//第一次添加，先初始化node数组</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//计算出table[i]无节点，创建节点</span></span><br><span class="line">            <span class="comment">//使用Unsafe.compareAndSwapObject 原子操作table[i]位置</span></span><br><span class="line">            <span class="comment">//如果为null，就添加新建的node节点，跳出循环</span></span><br><span class="line">            <span class="comment">//反之，再循环进入执行添加操作</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key, value, <span class="keyword">null</span>))) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) {</span><br><span class="line">            <span class="comment">//如果当前处于转移状态，返回新的tab内部表，然后进入循环执行添加操作</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//在链表或红黑树中追加节点</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//使用synchronized 对 f 对象加锁</span></span><br><span class="line">            <span class="comment">// f = tabAt(tab, i = (n - 1) &amp; hash) ： table[i] 的node对象(桶)</span></span><br><span class="line">            <span class="comment">//注意：这里没用ReentrantLock，而是使用 synchronized 进行同步</span></span><br><span class="line">            <span class="comment">//在争用不激烈的场景中，synchronized 的性能和 ReentrantLock不相上下</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) {</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) {</span><br><span class="line">                    <span class="comment">//在链表上追加节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) {</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; e = f; ; ++binCount) {</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) {</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent) {</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                }</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                            Node&lt;K, V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) {</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//在红黑树上追加节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) {</span><br><span class="line">                        Node&lt;K, V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K, V&gt;) f).putTreeVal(hash, key, value)) != <span class="keyword">null</span>) {</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) p.val = value;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">//节点数大于临界值，转换成红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD) {</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从源码可以看出，使用 CAS 自旋完成桶的设置时，使用 synchronized 内置锁保证桶内并发操作的线程安全。尽管对同一个 Map 操作的线程争夺会非常激烈，但是在同一个桶内的线程争夺通常不会很激烈，所以使用 CAS 自旋、synchronized 的偏向锁或轻量级锁 不会降低 ConcurrentHashMap 的性能。为什么不用显式锁 ReentrantLock 呢？因为如果为每个桶都创建一个 ReentrantLock 实例，就会带来大量的内存消耗，而前面那些方法带来的内存消耗微乎其微。</p>
<p>get方法也没有加锁操作，与 JDK1.7差不多，就不赘述了。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/25/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC1%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/25/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC1%E7%AB%A0/" class="post-title-link" itemprop="url">第1章：异步程序设计介绍</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-25 15:46:00" itemprop="dateCreated datePublished" datetime="2023-02-25T15:46:00+08:00">2023-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-27 21:03:50" itemprop="dateModified" datetime="2023-02-27T21:03:50+08:00">2023-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1-2-异步程序设计的关键问题"><a href="#1-2-异步程序设计的关键问题" class="headerlink" title="1.2 异步程序设计的关键问题"></a>1.2 异步程序设计的关键问题</h2><h3 id="1-2-1-结果传递"><a href="#1-2-1-结果传递" class="headerlink" title="1.2.1 结果传递"></a>1.2.1 结果传递</h3><p>不同于同步调用，异步调用是立即返回的，因此被调用方的逻辑通常存在2种情形：</p>
<ul>
<li><p>结果尚未就绪：进入任务执行的状态，等结果就绪后通过回调传递给调用方</p>
</li>
<li><p>结果已经就绪，可以立即提供结果</p>
</li>
</ul>
<p>用图片获取作为例子，上述2种情况代码示意如下所示（<strong>这是我个人觉得理解Kotlin协程实现最巧妙的例子了，其实后面的本质就是这个</strong>）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法实现</span></span><br><span class="line"><span class="function">fun <span class="title">asyncBitmap</span><span class="params">(url: String, callback: (Bitmap)</span> -&gt; Unit): Bitmap </span>{</span><br><span class="line">          val bitmap = asyncBitmap(url) {</span><br><span class="line">        show(it) <span class="comment">//...② 异步请求</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) {</span><br><span class="line">        show(bitmap) <span class="comment">//... ① 直接返回了</span></span><br><span class="line">    }  <span class="keyword">return</span> when (val bitmap = Cache.get(url)) {</span><br><span class="line">        <span class="keyword">null</span> -&gt; {</span><br><span class="line">            thread {</span><br><span class="line">                download(url)</span><br><span class="line">                    .also { Cache.put(url, it) }</span><br><span class="line">                    .also(callback)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> -&gt; bitmap</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法，如果有同步返回，就使用同步返回，否则依赖异步回调</span></span><br><span class="line"><span class="meta">@JvmStatic</span></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>{</span><br><span class="line">    val bitmap = asyncBitmap(url) {</span><br><span class="line">        show(it) <span class="comment">//...② 异步请求</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) {</span><br><span class="line">        show(bitmap) <span class="comment">//... ① 直接返回了</span></span><br><span class="line">    }</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>Kotlin 协程的挂起函数 (suspend function) 本质上就是采取了这个异步返回值的设计思路</p>
</blockquote>
<h3 id="1-2-2-异常处理"><a href="#1-2-2-异常处理" class="headerlink" title="1.2.2 异常处理"></a>1.2.2 异常处理</h3><p>我们希望异步的任务在 suspend 的时候执行，执行完成后 resume 回来，之后再同步判断是否发生了异常。这样逻辑就会简单很多。<strong>异步逻辑同步化也是 Kotlin 协程要解决的问题。</strong></p>
<h3 id="1-2-4-复杂分支"><a href="#1-2-4-复杂分支" class="headerlink" title="1.2.4 复杂分支"></a>1.2.4 复杂分支</h3><p>为同步操作添加分支甚至循环操作是很容易的，比如获取图片是同步的情况下，获取多个图片：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val bitmap = urls.map { syncBitmap(it) }</span><br></pre></td></tr></tbody></table></figure>

<p>在上述情况下我们甚至还能方便地通过一个 try-catch 捕捉所有异常。而当获取图片的操作是异步的情况时，就变得复杂，还需要用到一些同步工具来辅助：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">val countDownLatch = CountDownLatch(urls.size)</span><br><span class="line"></span><br><span class="line">val map = urls.map { it to EMPTY_BITMAP }</span><br><span class="line">    .toMap(ConcurrentHashMap&lt;String, Bitmap&gt;())</span><br><span class="line"></span><br><span class="line">urls.map { url -&gt;</span><br><span class="line">    asyncBitmap(url, onSuccess = {</span><br><span class="line">        map[url] = it</span><br><span class="line">        countDownLatch.countDown() <span class="comment">//...②</span></span><br><span class="line">    }, onError = {</span><br><span class="line">        showError(it)</span><br><span class="line">        countDownLatch.countDown()<span class="comment">//...③</span></span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">countDownLatch.await() <span class="comment">//...①</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有的图片 bitmap</span></span><br><span class="line">val bitmaps = map.values</span><br></pre></td></tr></tbody></table></figure>

<p>这里还需要借助 <strong>CountDownLatch 门闩</strong> 来实现，因此在 ① 处会阻塞当前线程，直到所有回调的 ② 或 ③ 位置执行之后，才会执行获取所有图片的操作：val bitmaps = map.values ，总之，这个过程还是挺复杂的。</p>
<blockquote>
<p>EMPTY_BITMAP 是一个空的 Bitmap 对象，为什么要这么做呢？<strong>因为 ConcurrentHashMap 不允许 value 为空！</strong></p>
</blockquote>
<h2 id="1-3-常见异步程序设计思路"><a href="#1-3-常见异步程序设计思路" class="headerlink" title="1.3 常见异步程序设计思路"></a>1.3 常见异步程序设计思路</h2><h3 id="1-3-1-Future"><a href="#1-3-1-Future" class="headerlink" title="1.3.1 Future"></a>1.3.1 Future</h3><p>但是 Future.get() 方法会造成当前调用阻塞。</p>
<h3 id="1-3-2-CompletableFuture"><a href="#1-3-2-CompletableFuture" class="headerlink" title="1.3.2 CompletableFuture"></a>1.3.2 CompletableFuture</h3><p>它的 get() 方法无需阻塞，异步调用不阻塞主流程调用但是结果脱离了主调用流程（需要回调获取）</p>
<h3 id="1-3-3-JavaScript-的-Promise——async-await"><a href="#1-3-3-JavaScript-的-Promise——async-await" class="headerlink" title="1.3.3 JavaScript 的 Promise——async/await"></a>1.3.3 JavaScript 的 Promise——async/await</h3><p>比较完好地实现了需求，他们 async/await 的语义稍微不同。</p>
<h3 id="1-3-5-Kotlin协程"><a href="#1-3-5-Kotlin协程" class="headerlink" title="1.3.5 Kotlin协程"></a>1.3.5 Kotlin协程</h3><p>Kotlin 协程是为异步程序设计而生的。</p>
<blockquote>
<p>有人称协程只是“一个线程框架”，认为协程就是用来切换线程的，显然有点“一叶障目不见泰山”了</p>
</blockquote>
<p>Kotlin 协程用一个 suspend 关键字，包含了<strong>异步调用</strong> 和 <strong>回调</strong> 两层含义。我们知道，所有异步回调对于当前调用流程只是一个<strong>挂起点</strong>。在这个挂起点可以做的事情非常多：既可以做异步回调，还可以添加调度器来处理线程切换，还可以作为协程取消响应的位置。</p>
<p>看一个 Kotlin 处理异步调用的例子：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">suspend fun <span class="title">bitmapSuspendable</span><span class="params">(url: String)</span>: Bitmap </span>=</span><br><span class="line">    suspendCoroutine&lt;Bitmap&gt; { continuation -&gt;</span><br><span class="line">        thread {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                continuation.resume(download(url))</span><br><span class="line">            } <span class="keyword">catch</span> (e: Exception) {</span><br><span class="line">                continuation.resumeWithException(e)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>suspend 修饰函数，意味着支持同步化的异步调用。上述代码中，</p>
<ul>
<li><p>continuation.resume(download(url)) 将正常的结果返回</p>
</li>
<li><p>continuation.resumeWithException(e) 则是将异常返回，在调用 bitmapSuspendable() 方法时，如果产生异常会把这个异常抛出</p>
</li>
</ul>
<p>效果如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">suspend fun <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        val bitmap = bitmapSuspendable(<span class="string">"xxxx"</span>)</span><br><span class="line">        <span class="comment">//todo 正常图片处理</span></span><br><span class="line">    } <span class="keyword">catch</span> (e: Exception) {</span><br><span class="line">        <span class="comment">//todo 异常处理</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>从 1.3.0 开始，开始支持 suspend fun main 作为函数入口了</p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">218</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共437.3k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/8/',]
      });
      });
  </script>


</body>
</html>
