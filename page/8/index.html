<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/8/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">39</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">223</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/14/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC15%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/14/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC15%E7%AB%A0/" class="post-title-link" itemprop="url">第15章：TCP数据流与窗口管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-14 19:50:00" itemprop="dateCreated datePublished" datetime="2023-03-14T19:50:00+08:00">2023-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-15 16:13:20" itemprop="dateModified" datetime="2023-03-15T16:13:20+08:00">2023-03-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="15-3-延时确认"><a href="#15-3-延时确认" class="headerlink" title="15.3 延时确认"></a>15.3 延时确认</h2><p>累积确认可以允许 TCP 延迟一段时间发送 ACK ，<strong>以便将 ACK 和相同方向上需要传的数据结合发送</strong>。不过TCP 不能任意时长地延迟 ACK，否则对方会误认为数据丢失而出现不必要的重传。</p>
<h2 id="15-4-Nagle-算法"><a href="#15-4-Nagle-算法" class="headerlink" title="15.4 Nagle 算法"></a>15.4 Nagle 算法</h2><p>从前面可知， ssh 连接中，通常单次按键就会引发数据流的传输。这些包很小，但是会造成相当高的网络传输代价，也就是说与其他包相比，有效的应用数据占比较低（IP头部有 20 字节，TCP头部 20 字节，数据部分仅仅 48 字节）。</p>
<p>Nagle 算法要求：当一个 TCP 在传数据时，小的报文段不能被发送，直到所有的在传数据都收到了 ACK，并且，TCP 需要收集这些小数据，将其整合到一个报文段中发送。</p>
<h3 id="15-5-流量控制与窗口管理"><a href="#15-5-流量控制与窗口管理" class="headerlink" title="15.5 流量控制与窗口管理"></a>15.5 流量控制与窗口管理</h3><p>前面提到可以采用可变滑动窗口来实现流量控制。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/14/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC14%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/14/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC14%E7%AB%A0/" class="post-title-link" itemprop="url">第14章：TCP超时与重传</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-14 09:00:00 / 修改时间：19:48:00" itemprop="dateCreated datePublished" datetime="2023-03-14T09:00:00+08:00">2023-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="14-1-引言"><a href="#14-1-引言" class="headerlink" title="14.1 引言"></a>14.1 引言</h2><p>TCP 拥有<strong>2套</strong>独立的机制来完成重传：</p>
<ul>
<li><p><strong>基于时间:</strong> 发送数据后设置计时器，若超时还未收到数据确认，则触发超时重传。</p>
</li>
<li><p><strong>基于确认信息的构成:</strong> 也叫做<strong>快速重传</strong>，通常发生在没有延时的情况下（根据以前的知识就是连续收到 3 个相同的 ACK），重传可能丢失的分组</p>
</li>
</ul>
<p>当失序数据到达时，重复 ACK 应当立即返回，不能延时发送，原因在于 <strong>使发送端尽早得知有失序报文，并告诉其空缺在哪</strong></p>
<blockquote>
<p>与超时重传相比，快速重传能更有效地修复丢包情况</p>
</blockquote>
<h2 id="14-3-设置超时重传"><a href="#14-3-设置超时重传" class="headerlink" title="14.3 设置超时重传"></a>14.3 设置超时重传</h2><p>TCP 并非对其接收到的每个报文段都返回 ACK，例如：当传输大批量数据时，TCP 通常采取每2个报文段返回一个 ACK 方法；另外，当数据出现丢失、失序或者重传成功时TCP 的累积确认机制表明报文段与ACK 之间并非严格一一对应的。</p>
<p>在TCP 握手阶段，SYN 、ACK 等数据包并未包含实际数据，由于 <strong>TCP 对不包含数据的报文段不提供可靠传输</strong>，意味着若出现丢包不会重传，因此<strong>无须设定重传计时器</strong>！</p>
<blockquote>
<p>由于接收端在收到失序的数据后会立即返回 ACK，以此来帮助触发快速重传，<strong>因此网络中任何一个失序的数据包都会生成重复的ACK</strong>。如果我们一旦收到重复 ACK 就立即启动快速重传，那就会导致大量不必要的重传发生，为了解决这一问题，快速重传仅在达到<strong>重复阈值</strong>之后才会被触发</p>
</blockquote>
<h2 id="14-10-重新组包"><a href="#14-10-重新组包" class="headerlink" title="14.10 重新组包"></a>14.10 重新组包</h2><p>当TCP 超时重传时，并不需要完全重传相同的报文段。TCP 允许执行<strong>重新组包</strong>发送一个更大的报文来提高性能。</p>
<blockquote>
<p>允许这样做的原因在于，TCP 是通过字节号来识别发送和接收的数据，而非报文段(或包)号。</p>
</blockquote>
<p>可以基于重新组包的方式来检测伪超时。</p>
<h2 id="14-11-与-TCP-重传相关的攻击"><a href="#14-11-与-TCP-重传相关的攻击" class="headerlink" title="14.11 与 TCP 重传相关的攻击"></a>14.11 与 TCP 重传相关的攻击</h2><p>有一类 DoS 攻击称为 低速率DoS 攻击。这类攻击向网关或主机发送大量数据，使得受害系统持续处于重传超时的状态，由于攻击者可以预知受害TCP何时启动重传，并在每次重传时发送大量数据，因此，受害 TCP 总能感知到拥塞的存在，根据Karn算法不断减小发送速率并退避发送，导致无法正常使用网络宽带</p>
<p>解决方案：随机选择 RTO，<strong>使得攻击者无法预知准确的重传时间</strong></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC13%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC13%E7%AB%A0/" class="post-title-link" itemprop="url">第13章：TCP连接管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-13 18:02:00 / 修改时间：18:59:10" itemprop="dateCreated datePublished" datetime="2023-03-13T18:02:00+08:00">2023-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="13-1-引言"><a href="#13-1-引言" class="headerlink" title="13.1 引言"></a>13.1 引言</h2><p>TCP 必须检测并修补所有在 IP 层产生的数据传输问题： 比如丢包、重复 以及 错误。</p>
<h3 id="13-5-2-TIME-WAIT-状态"><a href="#13-5-2-TIME-WAIT-状态" class="headerlink" title="13.5.2 TIME_WAIT 状态"></a>13.5.2 TIME_WAIT 状态</h3><p>TIME_WAIT 状态也称为 2MSL 等待状态，该状态下，TCP 将会等待 2 倍于<strong>最大段生存期（Maximum  Segment Lifetime， MSL</strong>的时间，这段时间连接不可用，等待链路上的报文段过期，防止复用这个连接时，将老的连接中的报文当成新连接发送的数据。</p>
<h3 id="13-5-3-静默时间"><a href="#13-5-3-静默时间" class="headerlink" title="13.5.3 静默时间"></a>13.5.3 静默时间</h3><p>在本地与外地的 IP 地址、端口号 都相同的情况下，2MSL 状态能防止新的连接将前一个连接的延迟报文解释成自身数据的状况。然而，这种方法只有在与<strong>处于2MSL等待状态的连接相关的主机未关闭的情况</strong>才有意义。为什么呢？</p>
<p>假如一台与处于 TIME_WAIT 状态下的链接相关联的主机崩溃，然后再 MSL 内重新启动，并且使用与主机崩溃之前处于 TIME_WAIT 状态的连接相同的 IP 地址与端口号，那要怎么处理呢？解决办法就是：在崩溃或者重启后，TCP 应该在创建新的连接之前等待一个 MSL 的时间，这段时间称为 <strong>静默时间</strong>。</p>
<h2 id="13-8-与-TCP-连接管理相关的攻击"><a href="#13-8-与-TCP-连接管理相关的攻击" class="headerlink" title="13.8 与 TCP 连接管理相关的攻击"></a>13.8 与 TCP 连接管理相关的攻击</h2><p>SYN 洪泛攻击时一种 TCP 拒绝服务攻击。在这种攻击中一个或者多个恶意的客户端产生一系列 TCP 连接尝试，并将他们发送给一台服务器，他们通常采用“伪造”的源 IP 地址。服务器回味每条链接分配一定数量的连接资源，由于连接尚未完全建立，服务器为了维护大量的半打开连接会在耗尽自身内存后拒绝为后续的合法连接请求服务。</p>
<blockquote>
<p>解决办法：只有当 SYN+ACK 报文段本身被确认后，才会分配真正的内存</p>
</blockquote>
<p>还有一种攻击与路径最大传输单元发现过程相关。攻击者伪造一个非常小的 MTU 值，迫使受害的 TCP  尝试采用非常小的数据报来填充数据，从而大大降低性能。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC12%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC12%E7%AB%A0/" class="post-title-link" itemprop="url">第12章：TCP:传输控制协议（初步）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-13 16:00:00 / 修改时间：18:01:08" itemprop="dateCreated datePublished" datetime="2023-03-13T16:00:00+08:00">2023-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="12-1-引言"><a href="#12-1-引言" class="headerlink" title="12.1 引言"></a>12.1 引言</h2><h3 id="12-1-1-ARQ-和-重传"><a href="#12-1-1-ARQ-和-重传" class="headerlink" title="12.1.1 ARQ 和 重传"></a>12.1.1 ARQ 和 重传</h3><p>重传的时候，接收方可能收到被传送分苏的重复副本，这就要求使用序列号来解决：在被远端发送时，每个唯一的分组都有一个新的序列号。</p>
<p>如果想要吞吐量更高，我们就要求在网络中可以同时存在多个分组，这就变得更加复杂：发送方不仅要决定什么时候注入一个分组到网络中，还要考虑注入多少个，并且在等待 ACK 的时候，怎样维持计时器，同时还需要保存每个还没收到 ACK 分组的副本防止重传需要。</p>
<h3 id="12-1-2-分组窗口和滑动窗口"><a href="#12-1-2-分组窗口和滑动窗口" class="headerlink" title="12.1.2 分组窗口和滑动窗口"></a>12.1.2 分组窗口和滑动窗口</h3><p>为了解决上述问题，我们假设每个分组有一个序列号，并且定义一个分组窗口作为<strong>已经被发送但是还没完成确认</strong>的分组集合，我们把窗口中分组的数量称为<strong>窗口大小</strong>，如下图所示：</p>
<p><img src="/assets/Book-Notes/TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/12%E7%AB%A0/%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F.png" alt="发送窗口示意图"></p>
<p>上图显示当前窗口有3个分组，整个窗口大小是3。其中，3号分组已经被发送和确认，所以发送方保存的副本可以释放了；分组 7 在发送方已经准备好，但是还没发送，因为还没“进入窗口”。现在假如发送方下一步收到分组 4 的 ACK，此时窗口向右边 “滑动”一个分组，意味着 4 可以释放了，而 7 可以发送了。这种就叫做 “滑动窗口”协议。</p>
<p>一般来说，这个滑动窗口在发送方和接收方都会有，在发送方，它记录着哪些分组可以释放，哪些正在等待 ACK，哪些分组还不能被发送；在接收方，它记录着哪些分组已经被接收和确认，哪些分组时下一步期望的，哪些分组即使接收了也会被丢弃。</p>
<h3 id="12-1-3-变量窗口：流量控制和拥塞控制"><a href="#12-1-3-变量窗口：流量控制和拥塞控制" class="headerlink" title="12.1.3 变量窗口：流量控制和拥塞控制"></a>12.1.3 变量窗口：流量控制和拥塞控制</h3><p>为了处理接收方相对发送方太慢的问题，我们在接收方跟不上时会强迫发送方慢下来，这称为<strong>流量控制</strong>。主要有以下2种方式：</p>
<ul>
<li><p>基于速率流量控制：给发送方指定某个速率，去报数据不能超过这个速率发送。多用于流应用程序，可被用于广播和组播发现</p>
</li>
<li><p>基于窗口流量控制：这是使用滑动窗口最流行的方法，思想是：窗口大小不固定，允许随时间变化而变化，必须有一种方法让接收方可以通知到发送方使用多大窗口（即窗口通告）</p>
</li>
</ul>
<p>拥塞控制用于发送方减低速度以不至于压垮发送方与接收方之间的网络。</p>
<h2 id="12-2-TCP的引入"><a href="#12-2-TCP的引入" class="headerlink" title="12.2 TCP的引入"></a>12.2 TCP的引入</h2><p>TCP 提供一种字节流抽象概念给应用程序使用，这就意味着没有消息边界。举例解释一下：如果应用程序一一端写入 10 字节，随后又写入 20 字节，再随后写入 50 字节，那么在另一端时不知道每次写入多少字节的；另一端可能以每次读取20字节分4次读取或者一次性读取80字节的方式读取。</p>
<p><strong>TCP根本不会解读字节流中的字节内容</strong>，它不知道传输的是二进制数据、ASCII 还是其他东西。</p>
<h3 id="12-2-2-TCP中的可靠性"><a href="#12-2-2-TCP中的可靠性" class="headerlink" title="12.2.2 TCP中的可靠性"></a>12.2.2 TCP中的可靠性</h3><p>TCP 必须把应用程序发送的字节流转换为一组 IP可以携带的分组，这被称为组包。这些分组包含序列号，该序列号在TCP 中代表了每个分组的第一个字节在整个数据流中的字节偏移，而不是分组号。TCP传给IP的块称为 <strong>报文段</strong>。</p>
<p>而UDP 就不同了，应用程序每次写入通常就产生一个 UDP 数据，其大小就是写入的那么大（加上头部）。</p>
<p>TCP 发送一组报文段时会设置一个<strong>重传计时器</strong>，等待对方的确认。不过它不会为每个报文段设置，而是发送一个窗口的数据，它只设置一个计时器，当 ACK 到达时再更新超时。如果有一个确认没有及时接收到，这个报文段就会被重传。</p>
<h2 id="12-3-TCP-头部封装"><a href="#12-3-TCP-头部封装" class="headerlink" title="12.3 TCP 头部封装"></a>12.3 TCP 头部封装</h2><p>UDP 的头部一般是 8 字节，TCP 头部通常是 20 个字节（带选项的话可达 60 字节）。每个TCP 的头部都包含了 源和目的IP地址，以及源和目的 端口号。</p>
<blockquote>
<p>在 TCP 术语中，一个 IP 地址和一个端口的组合被称为 套接字（Socket） 或者 端点（endpoint）</p>
</blockquote>
<p>TCP 报文段的数据部分是可选的，基于后面的知识我们可以看到：当一个连接被建立和终止时（我理解的是 握手和挥手），交换的报文段只包含 TCP 头部而没有数据。</p>
<h2 id="12-4-总结"><a href="#12-4-总结" class="headerlink" title="12.4 总结"></a>12.4 总结</h2><p>处理传输过程的差错主要有2种方法：</p>
<ul>
<li><p>差错校正码：添加一些冗余比特，使得即使某些比特被毁，真实的信息也能被恢复过来</p>
</li>
<li><p>重传，直至信息被正确接收</p>
</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC10%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC10%E7%AB%A0/" class="post-title-link" itemprop="url">第10章：用户数据报协议和IP分片</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-13 14:37:00 / 修改时间：15:59:36" itemprop="dateCreated datePublished" datetime="2023-03-13T14:37:00+08:00">2023-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="10-2-UDP-头部"><a href="#10-2-UDP-头部" class="headerlink" title="10.2 UDP 头部"></a>10.2 UDP 头部</h2><p>在UDP 中，源端口号是可选的，如果数据报的发送者不要求对方回复的话，它可以被置为 0。</p>
<p>TCP 的端口号只能被 TCP 使用，UDP 端口号只能被 UDP 使用，以此类推。这样导致的一个结果就是：2个完全不同的服务器可以使用相同的端口号和 IP 地址，只要它们属于不同的传输协议。</p>
<p>UDP 头部中的 Length 字段表示的是长度，这个长度包括 UDP 头部 和 UDP 数据 的总长度；需要注意的是，发送一个带 0 字节数据的 UDP 数据报是允许的，尽管很少见。</p>
<h2 id="10-3-UDP-校验和"><a href="#10-3-UDP-校验和" class="headerlink" title="10.3 UDP 校验和"></a>10.3 UDP 校验和</h2><p>UDP 在 IPv4 头部中的校验和只覆盖整个头部（并不覆盖IP分组中的任何数据），头部中的校验和是可选的。不过，在 IPv6 中，UDP 的校验和的计算与使用时强制的，因为在 IP 层没有头部校验和。</p>
<h2 id="10-7-IP-分片"><a href="#10-7-IP-分片" class="headerlink" title="10.7 IP 分片"></a>10.7 IP 分片</h2><p>链路层通常对可传输的每个帧的最大长度有一个上限， IP 比较外出接口的 MTU 和数据大小，如果数据报太大则进行分片。当一个 IP 数据报被分片了，直到它到大最终目的地才会被重组，这是为什么呢？为什么不在中途重组呢？有 2 个原因，第 2 个原因比第 1 个原因更重要：</p>
<ol>
<li><p>在网络中不进行重组要比重组更能减轻路由转发软件（或硬件）的负担</p>
</li>
<li><p>同一数据报的不同分片可能经由不同的路径到达相同的目的地。也就是说路径上的路由通常没有能力来重组原始数据报（因为手头只有所有分片的一个子集）</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>UDP 不提供差错纠正、队列管理、重复消除、流量控制和拥塞控制，它提供了差错检测，包含校验和。当要避免连接的开销、使用多端点（组播/广播）传送时，或者不需要 TCP 相对“笨重”的可靠语义时，最常用的就是 UDP，主要用途就是支持 DNS ，多媒体上也得到广泛使用。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/13/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC7%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC7%E7%AB%A0/" class="post-title-link" itemprop="url">第7章：Kotlin协程在Android上的应用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-13 11:33:00" itemprop="dateCreated datePublished" datetime="2023-03-13T11:33:00+08:00">2023-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-11 11:51:57" itemprop="dateModified" datetime="2023-03-11T11:51:57+08:00">2023-03-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>未开始</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/11/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/11/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">第5章：Kotlin协程框架开发初探</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-11 09:10:00" itemprop="dateCreated datePublished" datetime="2023-03-11T09:10:00+08:00">2023-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-10 21:01:35" itemprop="dateModified" datetime="2023-03-10T21:01:35+08:00">2023-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>为了学习官方协程，我们先实现一些轻量级的复合协程，只是用于学习，不适合生产环境。</p>
<h2 id="5-1-开胃菜：实现一个-delay-函数"><a href="#5-1-开胃菜：实现一个-delay-函数" class="headerlink" title="5.1 开胃菜：实现一个 delay 函数"></a>5.1 开胃菜：实现一个 delay 函数</h2><p>使用线程的时候，如果希望代码延迟一段时间再执行，通常会调用 Thread.sleep 函数，<strong>这会令当前线程阻塞</strong>。在协程中也可以这样，不过协程可以挂起还去阻塞线程，就很浪费资源，我们的目的是后面的代码延迟一段时间执行，因此可以确定以下2点：</p>
<ul>
<li><p>不要阻塞线程</p>
</li>
<li><p>是个挂起函数，指定时间之后能够恢复执行即可</p>
</li>
</ul>
<p>从上面 2 点我们可以给出 delay 函数的声明： </p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(time: <span class="type">Long</span>, unit: <span class="type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">    。。。</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来要考虑挂起，<strong>自然就想到了 suspendCoroutin</strong>：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(time: <span class="type">Long</span>, unit: <span class="type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> {</span><br><span class="line">    。。。</span><br><span class="line">    suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; {continuation: Continuation&lt;<span class="built_in">Unit</span>&gt; -&gt;  </span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    。。。</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>只需要做到在指定的 time 之后执行 continuation.resume() 就行，因此，<strong>我们只需要提供这样一个定时回调机制就可以！</strong>,定时任务很容易想到 <strong>ScheduledExecutorService</strong>，因此代码可以这样写：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> executor = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="keyword">object</span> : ThreadFactory{</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newThread</span><span class="params">(r: <span class="type">Runnable</span>)</span></span>: Thread {</span><br><span class="line">        <span class="keyword">return</span> Thread(r, <span class="string">"Scheduler"</span>).apply {</span><br><span class="line">            isDaemon = <span class="literal">true</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>这里为什么要设置 isDaemon ，放到后面说。接着我们可以实现功能了：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(time: <span class="type">Long</span>, unit: <span class="type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> {</span><br><span class="line">    suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; {continuation: Continuation&lt;<span class="built_in">Unit</span>&gt; -&gt;</span><br><span class="line">        executor.schedule(<span class="keyword">object</span>: Runnable{</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> {</span><br><span class="line">                continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">            }</span><br><span class="line">        }, time, unit)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="5-1-1-为什么这样用-ScheduledExecutorService（自己加的标题）"><a href="#5-1-1-为什么这样用-ScheduledExecutorService（自己加的标题）" class="headerlink" title="5.1.1 为什么这样用 ScheduledExecutorService（自己加的标题）"></a>5.1.1 为什么这样用 ScheduledExecutorService（自己加的标题）</h3><p>了解 ScheduledExecutorService 工作机制的朋友还会有疑惑：Scheduled-ExecutorService <strong>在等待延时的阶段还是会阻塞</strong>，这不也浪费资源吗？这里说明下2个原因：</p>
<ul>
<li><p>如果当前线程有特殊地位，例如 UI线程 等，那么它们是不能被阻塞的，因此我们将阻塞动作放到后台线程上是有意义的</p>
</li>
<li><p>后台<strong>一个线程可以承载非常多的延时任务</strong>，例如：有 10 个协程调用 delay ，那么只需要阻塞一个 后台线程即可实现这 10 个协程的延时执行 ！参考下图：</p>
</li>
</ul>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kotlin%E5%8D%8F%E7%A8%8B/%E7%AC%AC5%E7%AB%A0/%E5%A4%9A%E4%B8%AAdelay%E5%8D%8F%E7%A8%8B%E5%85%AC%E7%94%A8%E4%B8%80%E4%B8%AA%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B.png" alt="多个delay协程公用一个后台线程"></p>
<h2 id="5-2-协程的描述"><a href="#5-2-协程的描述" class="headerlink" title="5.2 协程的描述"></a>5.2 协程的描述</h2><p>Java 平台上 Thread 的定义很直观，让人很容易识别 Java 线程；而协程一开始只是在标准库中放了协程基础设施，导致难以上手和分辨。这里我们尝试给一个类来描述协程，按照官方的做法把它命名为 Job ，如下代码清单：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Job</span> : <span class="type">CoroutineContext.Element {</span></span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;Job&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt; <span class="keyword">get</span>() = Job</span><br><span class="line">    <span class="keyword">val</span> isActive: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnCancel</span><span class="params">(onCancel: <span class="type">OnCancel</span>)</span></span>: Disposable</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnCompletion</span><span class="params">(onComplete: <span class="type">OnComplete</span>)</span></span>: Disposable</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(disposable: <span class="type">Disposable</span>)</span></span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>与 Thread 相比， Job 同样有 join ，调用时会挂起( 而线程的 join 则会阻塞线程 )，直到协程完成；cancel() 类比与 Thread 的 interrupt() ，用于取消协程； isAlive() 类比 Thread 的 isAlive()  ，用于查询协程是仍在执行。</p>
<p>invokeOnCancel 用于协程取消时的回调；invokeOnCompletion 可以注册协程完成的回调。remove 用于移除回调。 key 将协程 Job 存入上下文，这样就很容易拿到 Job 实例。</p>
<h3 id="5-2-2-协程的状态"><a href="#5-2-2-协程的状态" class="headerlink" title="5.2.2 协程的状态"></a>5.2.2 协程的状态</h3><p>我们对协程进行封装，目的就是让它状态更容易管理。对于协程来讲，启动之后主要就是 <strong>未完成、已取消、已完成</strong>这几种状态，接下来定义一下状态：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineState</span> </span>{</span><br><span class="line">    <span class="comment">//未完成：协程启动后立即进入该状态，直到完成获取取消</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Imcomplete</span> : <span class="type">CoroutineState</span></span>()</span><br><span class="line">    <span class="comment">//已取消：协程被取消后立即进入该状态</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cancelling</span> : <span class="type">CoroutineState</span></span>()</span><br><span class="line">    <span class="comment">//已完成：协程执行完后（不管成功失败）进入该状态</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Complete</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> value: T? = <span class="literal">null</span>, <span class="keyword">val</span> exception: Throwable? = <span class="literal">null</span>) : CoroutineState()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>——————-中间略过一大截，看不懂—————————–</p>
<h2 id="5-4-协程的执行调度"><a href="#5-4-协程的执行调度" class="headerlink" title="5.4 协程的执行调度"></a>5.4 协程的执行调度</h2><p>协程在哪里挂起、什么时候恢复都是开发者自己决定的，意味着不像线程那样把调度工作交给操作系统，而是在用户态解决，所以协程也经常被称为<strong>用户态线程</strong>。</p>
<h3 id="5-4-2-协程的调度位置"><a href="#5-4-2-协程的调度位置" class="headerlink" title="5.4.2 协程的调度位置"></a>5.4.2 协程的调度位置</h3><p><strong>当协程执行到挂起点为止时，如果产生异步行为，协程就会在这个挂起点挂起</strong>，这里的一部情形包括以下形式：</p>
<ul>
<li><p>挂起点对应的挂起函数内部切换了线程，并在线程内部调用 Continuation 的恢复调用来恢复。</p>
</li>
<li><p>挂起函数内部通过某种事件循环机制将 Continuation 的恢复调用转到新的线程调用栈上执行。如：Android平台通过 Handler 的 post 操作，实际上这个过程不一定发生线程切换</p>
</li>
<li><p>挂起函数内部将 Continuation 保存，在后续某个时机再执行恢复调用，这个过程也不一定发生线程切换，但是函数调用栈会发生变化。</p>
</li>
</ul>
<p><strong>综上所述，不管何种形式，恢复和挂起不再同一个函数调用栈中执行就是挂起点挂起的充分条件！</strong>只有当挂起点真正挂起，我们才有机会实现调度，而<strong>实现调度需要使用协程拦截器</strong>。</p>
<h3 id="5-4-3-协程的调度器设计"><a href="#5-4-3-协程的调度器设计" class="headerlink" title="5.4.3 协程的调度器设计"></a>5.4.3 协程的调度器设计</h3><p>官方协程框架的默认调度器就是基于线程池实现的：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DefaultDispatcher : Dispatcher {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> threadGroup = ThreadGroup(<span class="string">"DefaultDispatcher"</span>) </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> threadIndex = AtomicInteger(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> executor = Executors.newFixedThreadPool(</span><br><span class="line">        Runtime.getRuntime().availableProcessors() + <span class="number">1</span></span><br><span class="line">    ) { runnable -&gt;</span><br><span class="line">        Thread(</span><br><span class="line">            threadGroup,</span><br><span class="line">            runnable,</span><br><span class="line">            <span class="string">"<span class="subst">${threadGroup.name}</span>-worker-<span class="subst">${threadIndex.getAndIncrement()}</span>"</span></span><br><span class="line">        ).apply { isDaemon = <span class="literal">true</span> }</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> {</span><br><span class="line">        executor.submit(block)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>调用dispatch 方法的时候，实际上是将 block 扔给 executor 放到线程中执行。</p>
<p>其实也可以实现成基于拦截器的方式：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> {</span><br><span class="line">    dispatcher.dispatch { delegate.resumeWith(result) }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>基于UI事件循环的调度器就是通过在disptch() 方法中用 Handler 的 post 实现：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> AndroidDispatcher : Dispatcher {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> handler = Handler(Looper.getMainLooper()) </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> {</span><br><span class="line">        handler.post(block)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<p>——————-后续的又看懵逼了—————————–</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/10/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC4%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/10/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC4%E7%AB%A0/" class="post-title-link" itemprop="url">第4章：Kotlin协程的拓展实践</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-10 16:55:00 / 修改时间：17:25:33" itemprop="dateCreated datePublished" datetime="2023-03-10T16:55:00+08:00">2023-03-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>前面的介绍了解了协程可以挂起和恢复，但是对于协程如何使用仍然倍感疑惑，所以还需要机遇简单协程构建足够有好的上层 API ，即复合协程。</p>
<h2 id="4-1-序列生成器"><a href="#4-1-序列生成器" class="headerlink" title="4.1 序列生成器"></a>4.1 序列生成器</h2><p>看得云里雾里，先略过</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/07/%E9%9D%A2-%E7%9F%A5%E8%AF%86/MP4%E8%A7%86%E9%A2%91%E9%A6%96%E5%B8%A7%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/07/%E9%9D%A2-%E7%9F%A5%E8%AF%86/MP4%E8%A7%86%E9%A2%91%E9%A6%96%E5%B8%A7%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">MP4视频首帧加载时间过长的问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-07 18:20:00" itemprop="dateCreated datePublished" datetime="2023-03-07T18:20:00+08:00">2023-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-14 22:23:41" itemprop="dateModified" datetime="2023-04-14T22:23:41+08:00">2023-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>MP4 格式的课程视频从打开播放器到第一帧画面显式，加载时间过长</p>
<h2 id="时间埋点"><a href="#时间埋点" class="headerlink" title="时间埋点"></a>时间埋点</h2><p>博客作者使用的是 ijkPlayer ，我们项目中使用的是 ExoPlayer ，不过这个关系不太大。给播放器加载过程埋点的时候需要关闭播放器自己打印的日志，否则会打印很多无关的内容。在本地视频模式和在线视频模式下分别打印关键方法的耗时。</p>
<p>从作者分析的数据可以看到，在线模式下，首帧耗时为 4.967s ，在线模式下首帧耗时 0.257s ，然后发现主要耗时是 avformat_open_input 方法（Exoplayer中方法可能是另一个）</p>
<h3 id="avformat-open-input-方法"><a href="#avformat-open-input-方法" class="headerlink" title="avformat_open_input 方法"></a>avformat_open_input 方法</h3><p>这个函数的主要作用是<strong>打开一个输入流并且读取它的头部信息</strong>。</p>
<h2 id="分析视频结构"><a href="#分析视频结构" class="headerlink" title="分析视频结构"></a>分析视频结构</h2><p>请求视频头部信息，在 MP4 格式下即为请求 moov 数据，可以使用 Media Parser 解析问题视频如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%9F%A5%E8%AF%86/%E9%97%AE%E9%A2%98%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.png" alt="问题视频数据可视化"></p>
<p>从图可以看出， moov 在视频文件尾部。本地播放时，可以通过指针快速定位到 moov ；<strong>在线播放时，需要先加载一部分头部数据，如 fytp、free、madat 等，计算出 moov 的偏移量，再通过 Http Range Bytes 请求 moov 数据。</strong></p>
<p>moov 数据约有 2.2M ，在线播放视频时，avformat_open_input 方法需要获取全部的 moov 数据，建立索引表后再解析音视频数据。而本地播放无需这个网络请求。</p>
<h2 id="结论及解决方案"><a href="#结论及解决方案" class="headerlink" title="结论及解决方案"></a>结论及解决方案</h2><h4 id="视频头过大导致的首帧过慢"><a href="#视频头过大导致的首帧过慢" class="headerlink" title="视频头过大导致的首帧过慢"></a>视频头过大导致的首帧过慢</h4><p><strong>问题：</strong>视频头过大，导致下载时间比较长，然后首帧出来就比较迟了</p>
<p><strong>解决方案：</strong>避免加载提及过大的视频头：1）将长视频拆分为多个短视频，减少 moov 的长度   2）使用轻量级格式，如分段FLV（爱奇艺、优酷）、DASH （YoTuBe、B站）等方案</p>
<h4 id="结构特性导致首帧过慢"><a href="#结构特性导致首帧过慢" class="headerlink" title="结构特性导致首帧过慢"></a>结构特性导致首帧过慢</h4><p><strong>问题：</strong> moov 在视频文件尾部，多了一次 seek 请求操作，这个问题比上述的问题要轻</p>
<p><strong>解决方案：</strong>在服务端使用 ffmpeg 命令将 moov 文件移到 ftyp 后面</p>
<h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><p><strong>问题：</strong> 播放的时候，还要同时先去下载视频头，导致了耗时较长</p>
<p><strong>解决方案：</strong>预加载，在适当时机提前加载视频头部数据，写入本地文件，播放器从本地读取数据，快速构建索引表，进入首帧解码</p>
<blockquote>
<p>以上内容参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/865c566c0a06">简书上的博客</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/07/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E9%A6%96%E5%B8%A7%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/07/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E9%A6%96%E5%B8%A7%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">MP4视频首帧加载时间过长的问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-07 16:18:00 / 修改时间：22:37:29" itemprop="dateCreated datePublished" datetime="2023-03-07T16:18:00+08:00">2023-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>MP4 格式的课程视频从打开播放器到第一帧画面显式，加载时间过长</p>
<h2 id="时间埋点"><a href="#时间埋点" class="headerlink" title="时间埋点"></a>时间埋点</h2><p>博客作者使用的是 ijkPlayer ，我们项目中使用的是 ExoPlayer ，不过这个关系不太大。给播放器加载过程埋点的时候需要关闭播放器自己打印的日志，否则会打印很多无关的内容。在本地视频模式和在线视频模式下分别打印关键方法的耗时。</p>
<p>从作者分析的数据可以看到，在线模式下，首帧耗时为 4.967s ，在线模式下首帧耗时 0.257s ，然后发现主要耗时是 avformat_open_input 方法（Exoplayer中方法可能是另一个）</p>
<h3 id="avformat-open-input-方法"><a href="#avformat-open-input-方法" class="headerlink" title="avformat_open_input 方法"></a>avformat_open_input 方法</h3><p>这个函数的主要作用是<strong>打开一个输入流并且读取它的头部信息</strong>。</p>
<h2 id="分析视频结构"><a href="#分析视频结构" class="headerlink" title="分析视频结构"></a>分析视频结构</h2><p>请求视频头部信息，在 MP4 格式下即为请求 moov 数据，可以使用 Media Parser 解析问题视频如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/Android%E5%9F%BA%E7%A1%80/MP4%E5%A4%B4%E7%BB%93%E6%9E%84.PNG" alt="问题视频数据可视化"></p>
<p>从图可以看出， moov 在视频文件尾部。本地播放时，可以通过指针快速定位到 moov ；<strong>在线播放时，需要先加载一部分头部数据，如 fytp、free、madat 等，计算出 moov 的偏移量，再通过 Http Range Bytes 请求 moov 数据。</strong></p>
<p>moov 数据约有 2.2M ，在线播放视频时，avformat_open_input 方法需要获取全部的 moov 数据，建立索引表后再解析音视频数据。而本地播放无需这个网络请求。</p>
<h2 id="结论及解决方案"><a href="#结论及解决方案" class="headerlink" title="结论及解决方案"></a>结论及解决方案</h2><h4 id="视频头过大导致的首帧过慢"><a href="#视频头过大导致的首帧过慢" class="headerlink" title="视频头过大导致的首帧过慢"></a>视频头过大导致的首帧过慢</h4><p><strong>问题：</strong>视频头过大，导致下载时间比较长，然后首帧出来就比较迟了</p>
<p><strong>解决方案：</strong>避免加载提及过大的视频头：1）将长视频拆分为多个短视频，减少 moov 的长度   2）使用轻量级格式，如分段FLV（爱奇艺、优酷）、DASH （YoTuBe、B站）等方案</p>
<h4 id="结构特性导致首帧过慢"><a href="#结构特性导致首帧过慢" class="headerlink" title="结构特性导致首帧过慢"></a>结构特性导致首帧过慢</h4><p><strong>问题：</strong> moov 在视频文件尾部，多了一次 seek 请求操作，这个问题比上述的问题要轻</p>
<p><strong>解决方案：</strong>在服务端使用 ffmpeg 命令将 moov 文件移到 ftyp 后面</p>
<h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><p><strong>问题：</strong> 播放的时候，还要同时先去下载视频头，导致了耗时较长</p>
<p><strong>解决方案：</strong>预加载，在适当时机提前加载视频头部数据，写入本地文件，播放器从本地读取数据，快速构建索引表，进入首帧解码</p>
<blockquote>
<p>以上内容参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/865c566c0a06">简书上的博客</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">223</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共444.1k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/8/',]
      });
      });
  </script>


</body>
</html>
