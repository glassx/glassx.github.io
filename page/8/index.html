<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.gitee.io/page/8/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.gitee.io/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">111</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/07/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC6%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC6%E7%AB%A0/" class="post-title-link" itemprop="url">第6章: 类文件结构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-27 14:56:00" itemprop="dateCreated datePublished" datetime="2019-07-27T14:56:00+08:00">2019-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:49:25" itemprop="dateModified" datetime="2019-11-17T21:49:25+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>计算机只认识0和1，但是最近10年虚拟机以及大量建立在虚拟上的语言的发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。</p>
<h2 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h2><p>Sun公司及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现程序的“一次编写，到处运行”。而各种不同平台的虚拟机以及平台无关的字节码（ByteCode）是构成平台无关性的基石。  </p>
<p>到目前为止，或许大部分程序员都还认为Java虚拟机执行Java程序是一件理所当然的事情，但在Java发展之初，Java的规范就分为Java语言规范以及Java虚拟机规范，时至今日，Java语言之外已经有一大批语言运行在Java虚拟机之上，如 Groovy、JRuby、Jython等。  </p>
<p>Java 虚拟机不和包括Java在内的任何语言绑定，它只与“Class 文件”这种特定的二进制文件格式所关联，任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。</p>
<h2 id="Class-类文件的结构"><a href="#Class-类文件的结构" class="headerlink" title="Class 类文件的结构"></a>Class 类文件的结构</h2><p>Class 文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有任何分隔符。遇到需要占用8位字节以上空间的数据项时，会按照高位在前的方式分割成若干个8位字节进行存储。</p>
<p>Class 文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种结构只有两种数据类型： 无符号数和表。</p>
<p>无符号数属于基本的数据类型，以u1、u2、u4、u8分别代表1、2、4、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8 编码构成的字符串值。</p>
<p>表示由多个无符号数或者其他表作为数据项的复合数据类型，表用于描述有层次关系的复合结构的数据，整个Class文件本质就是一张表。</p>
<h3 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h3><p>Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。Class 文件的魔数值为 0xCAFEBABE (咖啡宝贝？)，很有浪漫气息。紧接着魔数的4个字节存储着Class文件的版本号，高版本的JDK能乡下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p>
<blockquote>
<p>很多文件存储标准中都使用魔数来进行身份识别，如gif和jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来识别主要是基于安全考虑： 文件扩展可以随意改动。</p>
</blockquote>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%89%88/%E7%AC%AC6%E7%AB%A0/%E9%AD%94%E6%95%B0.png" alt="魔数示意图"></p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>版本号之后是常量池入口，该区域可以理解为Class文件中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值。</p>
<p>常量池中主要存放两大类常量：字面量（Literal） 和 符号引用（Symbolic References）。<strong>字面量比较接近于Java语言层面的常量概念，如 文本字符串、声明为final的常量值等</strong>，而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>
<ul>
<li>类和接口的全限定名(Fully Qualified Name)</li>
<li>字段的名称和描述符(Descriptor)</li>
<li>方法的名称和描述符</li>
</ul>
<p>Java代码在javac编译的时候，并不像c和c++那样有“连接”这一步骤，而是在虚拟机加载 Class 文件的时候进行动态连接，也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息。虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时解析、翻译到具体的内存地址中。</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>常量池结束后，紧接着2个字节代表访问标志（access_flags<br>），这个标志用于识别一些类或者接口层次的访问信息，包括： 这个Class 是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等等。</p>
<h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><p>类索引（this_class） 和父类索引(super_class)都是一个u2类型的数据，而接口索引集合(interfaces)是一组u2类型的数据的集合，class 文件中由这三项数据来确定这个类的继承关系。</p>
<p>其中，类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于Java不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此，父类索引都不为0。接口索引集合用来描述这个类实现了哪些接口，按照implement语句后的接口顺序从左到右排列在接口索引集合中。</p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>字段表(field_info)用于描述接口或者类中声明的变量，包括类级变量和实例级变量，不包括方法内的局部变量。这个描述可以包括的信息有： 字段的作用域(public、private、protected修饰符)、实例变量还是类变量(static修饰符)、可变性(final)、并发可见性(volatile 修饰符，是否强制从主内存读写)、可否被序列化(transient修饰符) 等等。</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，只是些微的区别，比如volatile关键字和transient关键字不能修饰方法 。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息(这一块内容也没耐心看下去，下次看明白再补)。</p>
<h2 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h2><p>这章离App开发比较远，因此第一遍的时候先略过。</p>
<h2 id="公有设计和私有实现"><a href="#公有设计和私有实现" class="headerlink" title="公有设计和私有实现"></a>公有设计和私有实现</h2><p>理解公有设计与私有实现之间的分界线是非常有必要的，Java虚拟机实现必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。按照Java虚拟机规范一成不变地逐字实现其中要求的内容是一种可行的途径，但是一个优秀的虚拟机实现，在满足虚拟机规范的约束下对具体实现做出修改和优化也是完全可行的。虚拟机实现的方式主要有以下两种：</p>
<ul>
<li>将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。</li>
<li>将输入的Java虚拟机代码在加载或执行翻译成宿主机CPU的本地指令集（即 JIT 代码生成技术）</li>
</ul>
<h2 id="Class-文件结构的发展"><a href="#Class-文件结构的发展" class="headerlink" title="Class 文件结构的发展"></a>Class 文件结构的发展</h2><p>略。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/07/10/%E6%80%BB%E7%BB%93-%E6%96%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/10/%E6%80%BB%E7%BB%93-%E6%96%B0/" class="post-title-link" itemprop="url">总结-新</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-10 22:50:00" itemprop="dateCreated datePublished" datetime="2019-07-10T22:50:00+08:00">2019-07-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-25 17:35:42" itemprop="dateModified" datetime="2020-07-25T17:35:42+08:00">2020-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%B6%E6%AE%B5/" itemprop="url" rel="index">
                    <span itemprop="name">阶段</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="书籍笔记"><a href="#书籍笔记" class="headerlink" title="书籍笔记"></a>书籍笔记</h2><ol>
<li>开启多进程的方式，<a href="https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/">看这里</a>           </li>
<li>多进程缺陷(Application多次启动，静态成员失效，单例失效，sp的可靠性下降，断点调试会麻烦)，解决办法(判断主进程，aidl，断点调试先去掉多进程)    </li>
<li>Android中的IPC方式，总共7种(别漏了广播)，<a href="https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/">看这里</a>               </li>
<li>Activity 的启动模式，<a href="https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC1%E7%AB%A0/">看这里</a>                </li>
<li>standard模式的Activity 默认会进入启动它的Activity所属的任务栈中，由于非Activity类型的Context 没有所谓的任务栈，所以会报错。解决这个问题的方法是为待启动的Activity指定 FLAG_ACTIVITY_NEW_TASK 标记             </li>
<li>卡顿优化的步骤，各项指标过高代表啥(cpu、内存) ，<a href="https://glassx.gitee.io/2020/05/27/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-5,6%E8%AF%BE/">看这里</a>      </li>
<li>Bitmap 内存分配的变化过程 <a href="https://glassx.gitee.io/2020/05/27/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-3,4%E8%AF%BE/">看这里</a>       </li>
<li>如何做启动优化(预览窗口、闪屏、懒加载防止集中、业务优先级-第三方框架、线程管理-数量-线程池,启动过程勿出现io-负载高的时候，io性能下降很快、启动时只读很小的sp文件)，<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-7,8%E8%AF%BE/">看这里</a>          </li>
<li>启动耗时的监控方式(录屏、线上监控-talkingdata)              </li>
<li>ppi、dpi 概念，<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-20%E8%AF%BE/">看这里</a>                       </li>
<li>软件绘制和硬件绘制的区别，硬件加速快的原理是啥，<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-20%E8%AF%BE/">看这里</a>                  </li>
<li>SurfaceFlinger 管理Graphic Buffer (比如三缓冲就有三个 buffer)，通过<strong>匿名共享内存</strong>与App应用层交互                     </li>
<li>ui优化手段(尽量硬件加速、view创建优化-不用xml-提前-异步-重用、measure与layout优化-ui层次-constranLayout-无用背景)，<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-21%E8%AF%BE/">看这里</a>                          </li>
<li>网络优化之网络请求过程是啥，网络怎么监控？ <a href="https://glassx.gitee.io/2020/06/26/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-16,17%E8%AF%BE/">看这里</a>             </li>
<li>SELinux 进一步定义沙盒边界，即使应用进程有root权限也不能为所欲为(还得在安全策略配置文件中赋予权限)                  </li>
<li>sp的缺点(跨进程不安全、加载慢-让主线程等待、全量写入-mommit和apply都这样、卡顿-onPause强制把sp写入磁盘、json复杂格式会有转义开销)，可以使用mmkv 代替，<a href="https://glassx.gitee.io/2020/06/28/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-12%E8%AF%BE/">看这里</a>            </li>
<li>ContentProvider 的onCreate 在 Application 的 attachBaseContext 之后，在Application 的onCreate 之前，并且还是在主线程，因此在provider的构造函数、静态代码块、onCreate中不要耗时操作                       </li>
<li>ContentProvider 跨进程传递的原理：<strong>利用 Android 的 Binder 和 匿名共享内存机制。</strong>即通过Binder 传递 CursorWindow 对象内部的匿名共享内存的文件描述符，<a href="https://glassx.gitee.io/2020/06/28/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-12%E8%AF%BE/">看这里</a>                 </li>
<li>Serializable 的原理，效率低的原因，反序列的时候会执行构造函数吗？，<a href="https://glassx.gitee.io/2020/07/04/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-13%E8%AF%BE/">看这里</a>              </li>
<li>Parcelable 可以永久存储吗？原理是啥？，<a href="https://glassx.gitee.io/2020/07/04/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-13%E8%AF%BE/">看这里</a>              </li>
<li>Android 事件分发，<a href="https://glassx.gitee.io/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/">看这里</a>                </li>
<li>让一个View 滑动起来，有几种方法？  <a href="https://glassx.gitee.io/2019/07/06/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89-%E7%AC%AC3%E7%AB%A0/">看这里</a>                  </li>
<li>init 进程做了哪些事情？ <a href="https://glassx.gitee.io/2019/11/22/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC2%E7%AB%A0/">看这里</a>                  </li>
<li>Zygote 进程做了哪些事情？(创建了虚拟机，创建systemServer进程、fork应用程序、创建server类型的socket)           </li>
<li>SystemServer 的主要作用？ (创建系统服务AMS、WMS、PMS)                  </li>
<li>Android 系统启动流程，   <a href="https://glassx.gitee.io/2019/11/22/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC2%E7%AB%A0/">看这里</a>               </li>
<li>Zogote 进程 fork 自身创建应用进程的时候，会为应用进程创建Binder线程池和消息循环，会通过检查，确保Binder 进程只启动一次， <a href="https://glassx.gitee.io/2019/11/24/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC3%E7%AB%A0/">看这里</a>                   </li>
<li>应用进程创建完毕，通过反射调用 ActivityThread 的main方法，在main方法里面prepareMainLooper、创建了  ActivityThread 对象，再从这个ActivityThread 对象中获取 handler 作为成员变量保存，之后再loop，不允许退出             </li>
<li>Instrumentation 主要用于监控应用程序和系统的交互                  </li>
<li>AMS 与 应用进程通信时，是与 ApplicationThread 打交道的，而不是直接与 ActivityThread ，ApplicationThread 是 ActivityThread 的内部类                 </li>
<li>点击桌面图标，App的启动过程，<a href="https://glassx.gitee.io/2019/11/25/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC4%E7%AB%A0/">看这里</a>                 </li>
<li>获取 Application Context时，首先从 LoadApk 类型的 mPackageinfo 中获取，如果为null ，则从 ActivityThread 类型的 mMainThread 中获取                    </li>
<li>Dalvik 与 ART 的区别，art 有dalvik 堆空间划分区别？<a href="https://glassx.gitee.io/2019/11/23/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC11%E7%AB%A0/">看这里</a>              </li>
<li>热修复原理之Instant Run，自己创建一个AssetManager ，反射调用其addAssetPath 加载外部的resource。反射每个Activity 的AssetManager字段 mAsset，并将 mAsset 的值改成新建的 AssetManager即可。<a href="https://glassx.gitee.io/2020/01/15/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC13%E7%AB%A0/">看这里</a>                     </li>
<li>linux中常见的进程间通信有哪些？  （管道、信号、socket、消息队列-Message、共享内存等） <a href="https://glassx.gitee.io/2019/09/15/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90-%E7%AC%AC5%E7%AB%A0/">看这里</a>     </li>
<li>描述下 Binder 的工作流程，为什么是一次复制           </li>
<li>mmap(memory map，内存映射)将某个设备或者文件映射到应用进程的内存空间，这样，访问这块内存就相当于对设备/文件进行读写。这种基于内存共享的方式如果用于进程间通信，则需要注意实现同步，因为这个过程并没有同步机制，而Binder中是 c/s 模式，因此不存在同步问题         </li>
<li>Ashmem(Anony Shared Memory，匿名共享内存)的原理也是将指定的物理内存分别映射到各个进程的地址空间，从而实现内存共享。Ashmem 也是一个 misc 设备，<a href="https://glassx.gitee.io/2019/03/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC4%E7%AB%A0/">看这里</a>                         </li>
<li>主线程的 prepareMainLooper 和 普通线程的 prepare 方法的区别是啥？   <a href="https://glassx.gitee.io/2019/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC5%E7%AB%A0/">看这里</a>            </li>
<li>飞快拉动进度条或者音量SeekBar，如何保证界面流畅又要听到实时声音？  <a href="https://glassx.gitee.io/2019/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC5%E7%AB%A0/">看这里</a>         </li>
<li>ActivityThread 启动并做好相应的初始化工作后，需要调用 attachApplication 来通知 AMS ，后者才能继续执行未完成的 startActivity 流程,<a href="https://glassx.gitee.io/2019/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC5%E7%AB%A0/">看这里</a>                  </li>
<li>系统对 Parcel 是有缓存的，系统预先产生一个大小为6的parcel 池，所以我们可以通过 Parcel.obtain() 方法获取一个 Parcel 对象，如果还有现成Parcel 对象，则直接使用，否则new一个。<strong>并且，Parcel存储数据时，会提供数据当前位置dataPosition，类似游标，每当存储新数据时，从这个位置接着往后存，空间不够再申请</strong> <a href="https://glassx.gitee.io/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC6%E7%AB%A0/">看这里</a>                 </li>
<li>binder 主要提供open、mmap、ioctl 三个接口，接口的作用是啥？ <a href="https://glassx.gitee.io/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC6%E7%AB%A0/">看这里</a>        </li>
<li>用户申请binder 服务的流程（A、B进程间数据传递），： open-&gt;mmap-&gt;ioctl，应用程序申请binder 的空间大小？  <a href="https://glassx.gitee.io/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC6%E7%AB%A0/">看这里</a>                 </li>
<li>Binder 的优点：性能、稳定、安全、使用简单， <a href="https://glassx.gitee.io/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC6%E7%AB%A0/">看这里</a>                </li>
<li>Java 内存区域划分及可能存在的异常，啥是直接内存？ 啥叫运行时常量池，这个常量池在哪？ <a href="https://glassx.gitee.io/2019/04/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0/">看这里</a>                </li>
<li>如何产生各种异常，oom，stackoverflow ？  <a href="https://glassx.gitee.io/2019/04/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0/">看这里</a>                </li>
<li>哪些对象可以做 GCRoot ？ 谈谈引用？ 不可达非死不可吗，流程咋样？ <a href="https://glassx.gitee.io/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/">看这里</a>                          </li>
<li>垃圾收集算法，并发收集的缺点？ 内存分配策略？  <a href="https://glassx.gitee.io/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/">看这里</a>                         </li>
<li>类加载过程如何？ 各个过程做啥？ 类啥时候会初始化？特殊情形-获取父类静态值、作为数组类型-static final 字符串入常量池了、<a href="https://glassx.gitee.io/2019/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC7%E7%AB%A0/">看这里</a>               </li>
<li>虚拟机执行非静态方法时，通过局部变量表完成参数值到参数变量列表的传递，第0位索引默认用于传递方法所属实例，这样，在方法中可以使用this 关键字来访问这个实例了，<a href="https://glassx.gitee.io/2019/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0/">看这里</a>          </li>
<li>在有继承关系存在的情况下，虚拟机如何做到 方法调用分派？ 根据各个类的虚方法表中方法的指向，  <a href="https://glassx.gitee.io/2019/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0/">看这里</a>          </li>
<li>静态变量和静态方法的重写，只跟声明的类型有关， <a href="https://glassx.gitee.io/2019/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0/">看这里</a>          </li>
<li>volatile 禁止指令重排的原理？ (赋值后lock,相当于store 和 write操作) ，volatile、synchronize、final 都能保证可见性 ，volatile、synchronize、锁 可以保证有序性  <a href="https://glassx.gitee.io/2019/09/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC12%E7%AB%A0/">看这里</a>                 </li>
<li>线程状态转换？ <a href="https://glassx.gitee.io/2019/09/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC12%E7%AB%A0/">看这里</a>                 </li>
<li>实现线程安全的方法？(互斥同步、非阻塞同步-CAS操作、无同步-无共享)  synchronized 关键字原理？     <a href="https://glassx.gitee.io/2019/09/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC13%E7%AB%A0/">看这里</a>           </li>
<li>锁优化方式？(自旋、消除、粗化、轻量级、偏向)  ，<a href="https://glassx.gitee.io/2019/09/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC13%E7%AB%A0/">看这里</a>          </li>
<li>为什么不是总选择tcp，而要在有时候udp呢？ udp 首部应该包括什么呢？ <a href="https://glassx.gitee.io/2020/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87%E7%AC%AC6%E7%89%88-%E7%AC%AC3%E7%AB%A0/">看这里</a>                </li>
<li>快重传、流量控制、拥塞控制 分别是啥？拥塞控制 的确定？ 拥塞控制的算法？-慢启动、拥塞避免、快速恢复      ，<a href="https://glassx.gitee.io/2020/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87%E7%AC%AC6%E7%89%88-%E7%AC%AC3%E7%AB%A0/">看这里</a>                 </li>
<li>ssl握手流程？ <a href="https://glassx.gitee.io/2020/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87%E7%AC%AC6%E7%89%88-%E7%AC%AC8%E7%AB%A0/">看这里</a>                 </li>
<li>TCP的时延有哪些？(握手、慢启动的拥塞控制、捎带确认)，http性能提升手段？(并行连接-发起多条tcp连接、持久连接、管道化发送-同一条tcp连接连续发送多条，无需等回复)， <a href="https://glassx.gitee.io/2018/05/21/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0/">看这里</a>             </li>
<li>签名是加了密的校验和。<a href="https://glassx.gitee.io/2018/05/25/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC14%E7%AB%A0/">看这里</a>               </li>
<li>死锁条件？(互斥条件、不可剥夺、保持等待、环路等待)，<a href="https://glassx.gitee.io/2018/05/30/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-%E7%AC%AC6%E7%AB%A0/">看这里</a>          </li>
<li>第一次启动Service 会执行 onCreate，多次启动则 onStartCommand 多次启动   ，<a href="https://glassx.gitee.io/2018/07/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%8D%81%E7%AB%A0/">看这里</a>      </li>
<li>debug 包获取cookies： adb shell ，run-as ，再cd 到目录即可，  <a href="https://glassx.gitee.io/2020/02/27/Android%E8%8E%B7%E5%8F%96debug%E5%8C%85%E7%9A%84cookies%E7%9A%84db%E6%96%87%E4%BB%B6/">看这里</a>       </li>
<li>Toast显示流程 <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>             </li>
</ol>
<h2 id="Android开发高手课"><a href="#Android开发高手课" class="headerlink" title="Android开发高手课"></a>Android开发高手课</h2><ol>
<li>Android 的bitmap 内存分配随着 Android 版本的变化过程？NativeAllocationRegistry? <a href="https://glassx.gitee.io/2020/05/27/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-3,4%E8%AF%BE/">看这里</a>             </li>
<li>卡顿考虑cpu，怎么看？ 用户时间过多或者 系统调用时间过多？ <a href="https://glassx.gitee.io/2020/05/27/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-5,6%E8%AF%BE/">看这里</a>                  </li>
<li>启动优化方式？(闪屏-当做view浮、业务优先级梳理、线程优化-线程池控制总量)，监控指标？  ，<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-7,8%E8%AF%BE/">看这里</a>           </li>
<li>ppi、dpi、density？ dp * density = px ，软件绘制/硬件绘制流程 ，硬件绘制为啥快， surface 与window 关系，<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-20%E8%AF%BE/">看这里</a>            </li>
<li>ui优化方式？(硬件加速、view创建-不用xml-提前创建/异步创建-重用、measure/layout优化-减少层次-constranlayout-背景优化)  ，<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-21%E8%AF%BE/">看这里</a>                  </li>
<li>完整的网络请求？ <a href="https://glassx.gitee.io/2020/06/26/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-16,17%E8%AF%BE/">看这里</a>               </li>
<li>sp 缺点？替代方式？ContentProvider注意事项？    <a href="https://glassx.gitee.io/2020/06/28/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-12%E8%AF%BE/">看这里</a>               </li>
<li>Serializable 的原理？Parcelable 的永久存储？  <a href="https://glassx.gitee.io/2020/07/04/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-13%E8%AF%BE/">看这里</a>              </li>
</ol>
<h2 id="高级进阶课"><a href="#高级进阶课" class="headerlink" title="高级进阶课"></a>高级进阶课</h2><p><a href="https://glassx.gitee.io/2020/04/19/%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E8%AF%BE%E7%A8%8B/">全部链接</a>        </p>
<ol>
<li>如何停止线程？为什么stop和suspend会有问题？               </li>
<li>ThreadLocal 使用建议          </li>
<li>禁止指令重排的方法？可见性方法？保证原子性方法？              </li>
<li>HashTable问题？ConcurrentHashMap？ ConcurrentHashMap的解决方案？所以，如何进行锁优化？         </li>
<li>Rxjava 存在的问题？         </li>
<li>cpu 架构适配优化方案？？</li>
<li>Activity 是通过反射创建出来的，所以不要去写它的构造函数。同理，Fragment 也不要去写，因为恢复Fragment的时候，也是反射的，这也是为什么我们推荐使用argument 传递参数的原因              </li>
<li>在 resume 回调之后，才调用 makeVisible 将 DecorView 展示出来(layout,draw)，所以在resume之前我们是无法准确获得view的高度的                   </li>
<li>如何启动外部应用的Activity？ (uid、exported-且全路径，action和category)，为了避免别的应用乱启动 exported 的Acivity，可以给Activity 添加权限，没有在Manifest中声明就启动不了                </li>
<li>别人如何攻击暴露的Activity产生异常？            </li>
<li>如何在任意位置为当前Activity 添加View ？           </li>
<li>为什么不能在非主线程更新ui？一定不能吗？               </li>
<li>ANR 怎么产生的，Looper 为什么不会cpu占用过高？             </li>
<li>内存越大越好吗？不，导致gc时间长，避免oom？bitmap选择合适分辨率，不要使用帧动画，bitmap重采样，Native Heap 优雅避免堆限制  谨慎多进程？新进程会有一些公共资源，也是会消耗内存的                  </li>
<li>如何对图片进行缓存？           </li>
<li>如何计算图片大小？                 </li>
<li>图片体积优化？ 图片格式无关跟argb_8888或者565有关、裁剪合适尺寸、采样、矩阵变换来放大图片、.9             </li>
<li>如何开展优化工作？ 目标-找原因-优化           </li>
<li>如何设计短视频？视频处理、来源、分享、打赏、社交、聊天、耗电问题、防止视频泄露、防止广告劫持                </li>
<li>如何设计网络框架？  http和websocket、异步、可移植性、缓存策略、拦截器、日志、重试机制-重试多少次-间隔、结果组装            </li>
</ol>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol>
<li>mvc、mvp、mvvm 设计模式区别？ mvc中view可以直接改数据         <a href="https://glassx.gitee.io/2019/11/23/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">看这里</a>                  </li>
<li>Android中内存分配的执行流程？ Android GC 过程？ <a href="https://glassx.gitee.io/2019/11/23/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%99%9A%E6%8B%9F%E6%9C%BA/">看这里</a>                 </li>
<li>三次握手？为毛3次能2次吗？ 序列号为什么随机？握手会有什么安全问题？三次握手可以携带数据吗？ <a href="https://glassx.gitee.io/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">看这里</a>            </li>
<li>TCP与udp 区别 ？ 不用维护连接， <a href="https://glassx.gitee.io/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">看这里</a>            </li>
<li>啥是中间人攻击？  http1与http2的区别？    <a href="https://glassx.gitee.io/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">看这里</a>          </li>
<li>RxJava 线程切换原理？<a href="https://glassx.gitee.io/2019/11/20/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/">看这里</a>       </li>
<li>为什么使用fresco？ThreadLocal 原理？LocalBroadcastManager 原理？<a href="https://glassx.gitee.io/2019/11/20/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/">看这里</a>           </li>
<li>ThreadPoolExecutor 原理？线程池异常处理？AsyncTask 源码解析？ <a href="https://glassx.gitee.io/2019/11/20/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/">看这里</a>      </li>
<li>Synchronized 与 Lock 的区别？ <a href="https://glassx.gitee.io/2019/11/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86/">看这里</a>        </li>
<li>wait、notify、notifyAll 方法在object 类中，而sleep 在Thread 类中? notify/wait 方法为什么一定要放在同步块中？ <a href="https://glassx.gitee.io/2019/11/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86/">看这里</a>      </li>
<li>synchronized原理？单例中，volatile 的作用？如何停止一个线程 ？ <a href="https://glassx.gitee.io/2019/11/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86/">看这里</a>     </li>
<li>写个死锁程序？ <a href="https://glassx.gitee.io/2019/11/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86/">看这里</a>     </li>
<li>synchronized 锁持有的object 是Thread 对象的情况?同理，Java 中的 join原理？  <a href="https://glassx.gitee.io/2019/11/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86/">看这里</a>     </li>
<li>集合-ArrayList、LinkedList、HashMap、HashTable、ConcurrentHashMap、LinkedHashMap、WeakHashMap、TreeMap <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>    </li>
<li>泛型信息不会进入到运行时阶段，由于系统中并不会真正生成泛型类，因此，instanceof运算符后不能使用泛型类          </li>
<li>抽象类和接口的区别，<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>transient 关键字， <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>        </li>
<li>Java 的finally 与 return 的执行顺序 ？system.exit(0)、正常情况return语句先返回，但没有真正返回值，等finally执行完后真正返回、finally中有return则会覆盖try中的return、finally没有return，则看情况，如果是简单类型，则在finally中改没关系，如果是复杂类型，改了就会影响最终值 <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>              </li>
<li>Java 中HashCode 与 equals 方法理解，HashCode 生成注意事项？同一个对象多次调用hashcode都是一致的、两个对象相等，则hashcode要相等、两个对象不相等，尽量hashcode不相等，避免Hashmap等冲突、int型防止溢出 <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>类的初始化步骤是啥？  <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>         </li>
<li>String、StringBuilder、StringBuffer、CharSequence 区别？本质都是通过字符数组实现的，StringBuilder 和StringBuffer 初始空间都是16，如果超过，就申请新的空间，并把老数组赋值过去。 <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>     </li>
<li>String 为毛设计成不可变？字符串常量需要、String的HashCode被频繁使用，会缓存HashCode、为了安全：用在url之类的场合。 一定不可变吗？  <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>        </li>
<li>成员内部类、静态内部类、局部内部类和匿名内部类的理解。内部类的优势：方便组织类关系、完善的Java的多继承机制、方便实现事件驱动程序(如点击事件)<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>       </li>
<li>是否可以在子线程更新UI？首先settext了，然后执行ViewGroup的invalidateChild，最后在ViewRootImpl中检测线程，而在onCreate中，由于attachInfo 还是空的，所以走不到ViewRootImpl，走不了检查线程，所以可以设置。 可以参考<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">这里</a>、<a href="https://glassx.gitee.io/2020/04/19/%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E8%AF%BE%E7%A8%8B/">以及这里</a>     </li>
<li>LruCache原理。<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>Handler 机制？如何保证一个线程一个Looper？postDelay 怎么实现？ nativePollOnce 和 nativeWake 分别来阻塞和唤起线程。  Android 的消息屏障？Handler三种消息：同步消息、异步消息、消息屏障。  通过MessageQueue.postSyncBarrier 来发送屏障，消息屏障就是没有target字段的Message，需要手动移除，屏障在就会执行查询异步消息，知道移除屏障。   IdelHandler？ <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>       </li>
<li>RecyclerView 的优化方式？ 如何保存嵌套 RecyclerView 的滑动装填？ <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>     </li>
<li>Activity 生命周期几种普通情况。  <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>谈谈对Application 的理解？即有啥特性、有什么坑？ <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>Binder 理解？ 为什么要使用Binder 机制进程间通信？-五个维度 <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>    </li>
<li>Android 为什么用Bundle 而不是使用HashMap 来传递数据？  <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>       </li>
<li>SharedPreference 的理解 ？ <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>常见内存泄漏场景 ？如何监测？LeakCanary 的原理是啥？ <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>     </li>
<li>APK 安装步骤。 <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>ListView 原理？  <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>     </li>
<li>Android 5.0, 6.0, 7.0, 8.0新特性 ？   <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>        </li>
<li>UI卡顿之BlockCanary？  <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>       </li>
<li>Android 中大图加载 ？如果不需要展示，则BitmapFactory.option设置inJustDecodeBounds即可、图片非常多，可以使用LruCache、 <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>     </li>
<li>彻底理解android 应用无响应机制？<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>理解Android签名？<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>       </li>
<li>为什么 epoll 快？   <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>        </li>
<li>BroadCastReceiver 怎么执行耗时操作(异步)？  <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>       </li>
</ol>
<h2 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h2><ol>
<li>HashMap 为毛链表转成红黑树？红黑树特点？  <a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>      </li>
<li>一个无序，实际上是逆序的数组排序用什么算法好？  <a target="_blank" rel="noopener" href="https://blog.csdn.net/hongtaya/article/details/105548059?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">看这里-参考别人的博客</a>            </li>
<li>Android heap 的结构？主要用来分配对象的堆空间 Zygote Space 和 Allocation Space 的底层都是匿名共享内存，使用C库的 malloc 和 free 来进行管理，<strong>通过 dlmalloc 技术来尽量解决碎片</strong>问题。 <a target="_blank" rel="noopener" href="https://blog.csdn.net/luoshengyang/article/details/42492621">看这里</a>      </li>
<li>多个Fragment 销毁后重建之后重叠？ <a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>      </li>
<li>Bitmap 能否复用？怎么复用？  <a href="https://glassx.gitee.io/2020/05/27/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-3,4%E8%AF%BE/">看这里</a>       </li>
<li>TreeMap 如何对两个元素比较？HashMap 转红黑树的时候，怎么比较？ 非compareble对象如何比较？ <a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>      </li>
<li>object 有哪些方法？ <a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>        </li>
<li>Android系统中存在的代理模式？理解动态代理和静态代理？ <a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>         </li>
<li>SharedPreference 是线程/进程 安全的吗？apply和commit 有什么区别(提交到哪？内存还是本地xml)？有什么坑？<a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>      </li>
<li>Handler 中我想指定某个消息先执行，可以吗？ <a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>         </li>
<li>http与http2的区别？http与https区别？https怎么做到安全的？ <a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>           </li>
<li>java中this编译时的原理？<strong>构造方法(对，构造方法也是)</strong>、实例方法第一个参数就是this，它的类型为Base，这是编译器自动添加的。 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41920291/article/details/98118035">可以看别人的博客了解</a>              </li>
<li>Android 自定义控件方式？———————</li>
<li>fresco加载图片原理？ 优势是什么？ ashmem 减少gc，webp            </li>
<li>事件分发 cancel事件一般在什么时候被触发？ 某个子View处理了Down事件之后，那么接下来的 Move 和 Up 事件也会交给他处理，但在交给他处理前，父view还是可以拦截事件的，如果拦截了事件，子View就会收到一个Cancel事件，并且不会收到后续的Move 和Up事件。 <a target="_blank" rel="noopener" href="https://blog.csdn.net/cufelsd/article/details/89471402">看这里</a>       </li>
<li>onSaveInstanceState 调用时机。onSaveInstanceState是Activity的生命周期方法，主要用于在Activity 销毁时保存信息，Activity 只执行opause时(打开的另一个Activity透明)，在 Android 3.0 及以上不会执行 onSaveInstanceState，以下就会执行。当Activity 执行 onStop 时，就都会执行 onSaveInstanceState。 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_23547831/article/details/51464535">看这里</a>        </li>
<li>Fragment View区别？ Fragment复用粒度更大、从代码设计上Fragment可以提高代码内聚、Fragment完整的生命周期、Fragment更复杂，消耗资源大。<a target="_blank" rel="noopener" href="https://blog.csdn.net/mba16c35/java/article/details/44408623">看这里</a>        </li>
<li>notifyAll方法唤醒的线程，怎么决定哪一个线程得到运行?</li>
<li>handler的sendMessage方法和postRunable方法区别?</li>
</ol>
<h2 id="针对xx的问题"><a href="#针对xx的问题" class="headerlink" title="针对xx的问题"></a>针对xx的问题</h2><p><a href="https://glassx.gitee.io/2019/03/08/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%92%88%E5%AF%B9%E7%AE%80%E5%8E%86%E7%9A%84%E9%97%AE%E9%A2%98/">统一的链接看这里</a></p>
<ol>
<li>聊聊kotlin的协程？优缺点？适用场景？kotlin 如何实现空安全？       </li>
<li>MeasureSpec 的理解？            </li>
<li>如何处理手势冲突？内部法和外部法            </li>
<li>如何优化App的性能？具体指标变化如何？               </li>
<li>ArrayMap 与 SparseArray 的原理？         </li>
<li>三次握手和四次挥手？           </li>
<li>锁的种类？       </li>
<li>HandlerThread?run的时候prepare() 了，退出的时候需要执行 handlerThread.quit() 以便退出loop        </li>
<li>IntentService 原理？多次调用Service 会咋样？为毛 onHandleIntent 之后，执行的是 stopSelf(int) ？           </li>
<li>什么是大接口？为毛要用大接口？如何实现？            </li>
<li>怎样防止劫持？             </li>
<li>聊聊内部sdk的设计？有什么收获？           </li>
<li>最有成就感的？最棘手的？          </li>
<li>为了安全，做了哪些努力？ apk签名校验、https证书校验、本地广播、sp加密             </li>
<li>平时逛论坛？关注的技术？  </li>
<li>如何做的证书校验？ <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里Android基础</a>     </li>
<li>如何移除Handler的Message？有啥坑吗？ <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里Android基础</a>       </li>
<li>如何性能优化？lint无用资源、Application减轻负担(主进程，小sp，框架减少人为)、ui绘制优化(硬件加速、view创建优化-代码创建-提前-异步-View重用、measure/layout-布局层次-ConstranLayout减少layout开销-去除无用背景-shapelayout代替xml的shape)、启动优化（flash页面、减少cpu集中）、内存(泄漏、容器避免自动装箱、正确使用引用)、cpu(解析放在子线程、sp存储json、避开高峰-IdelHandler、线程管理-数量-线程池,启动过程勿出现io-负载高的时候，io性能下降很快)、网络优化(dns加速)、结构(mvp)、尽量不要有io操作   <a href="https://glassx.gitee.io/2019/03/08/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%92%88%E5%AF%B9%E7%AE%80%E5%8E%86%E7%9A%84%E9%97%AE%E9%A2%98/">看这里</a>、<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-7,8%E8%AF%BE/">以及Android开发高手课</a></li>
</ol>
<p>ANR 定位？tcp与udp</p>
<h2 id="基本排序"><a href="#基本排序" class="headerlink" title="基本排序"></a>基本排序</h2><p>插入排序：O(n^2)复杂度，稳定的排序<br>选择排序： 复杂度总是 O(n^2)，每次挑最大最小的，因此不稳定                    </p>
<p>shell 排序： 最差的时候：O(n^2)   平均复杂度 ： nlogn，不稳定<br>冒泡：有序的情况，一趟完成，OO(n)，平均复杂度O(n^2)，稳定的排序<br>快排序： 分治思想，平均 nlogn ，最坏 O(n^2)，交换数据啊，不稳定<br>堆排序：最坏最好和平均都是   nlogn  ，不稳定<br>归并排序： 分治思想，时间复杂度  nlogn ，稳定，主要用于外部排序</p>
<p>归并和快排的平均时间复杂度差不多，但是比快排最差情况要好。但是归并使用的空间比较多，因此一般情况下选择快排               </p>
<p>不稳定的排序：希尔、堆、快排</p>
<p>初始化顺序？</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/07/06/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/06/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：View体系与自定义View《一》</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-06 21:00:00" itemprop="dateCreated datePublished" datetime="2019-07-06T21:00:00+08:00">2019-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-18 20:55:29" itemprop="dateModified" datetime="2019-11-18T20:55:29+08:00">2019-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>Android 系统中有两种坐标系：Android 坐标系和 View 坐标系，了解这两种坐标系能够帮助我们实现View的各种操作。</p>
<h3 id="Android坐标系"><a href="#Android坐标系" class="headerlink" title="Android坐标系"></a>Android坐标系</h3><p>Android坐标系中， 将屏幕左上角的顶点作为原点， 这个原点向右是X轴正方向， 向下是Y轴正方向， 如下图所示。</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89/Android%E5%9D%90%E6%A0%87.png" alt="Android坐标系"></p>
<h3 id="View坐标系"><a href="#View坐标系" class="headerlink" title="View坐标系"></a>View坐标系</h3><p>View坐标系与Android坐标系并不冲突，两者是共同存在的，一起来帮助开发者更好地控制View。对于View坐标系，搞明白下图的信息即可：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89/View%E5%9D%90%E6%A0%87.png" alt="View坐标系"></p>
<p><strong>MotionEvent提供的方法：</strong>假设上图中间的那个圆点就是我们触摸点，无论是View还是ViewGroup，最终的点击事件都会由onTouchEvent(MotionEvent event)方法来处理。MotionEvent提供了获取焦点坐标的各种方法：</p>
<blockquote>
<ul>
<li>getX()：获取点击事件距离控件左边的距离，即视图坐标。  </li>
</ul>
</blockquote>
<ul>
<li>getY()：获取点击事件距离控件顶边的距离，即视图坐标。  </li>
<li>getRawX()：获取点击事件距离整个屏幕左边的距离，即绝对坐标。  </li>
<li>getRawY()：获取点击事件距离整个屏幕顶边的距离，即绝对坐标。  </li>
</ul>
<h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><p>View的滑动基本思想：当点击事件传到View时，系统记下触摸点的坐标，手指移动时系统记下移动后触摸的坐标并算出偏移量，并通过偏移量来修改View的坐标。 实现View滑动有很多种方法， 在这里主要讲解6种滑动方法， 分别是layout()、offsetLeftAndRight() 与 offsetTopAndBottom()、LayoutParams、动画、scollTo 与 scollBy ，以及Scroller。</p>
<h3 id="layout方法"><a href="#layout方法" class="headerlink" title="layout方法"></a>layout方法</h3><p>View进行绘制的时候会调用onLayout()方法来设置显示的位置， 因此我们同样也可以通过修改View的left、 top、 right、 bottom属性来控制View的坐标。以下是实现一个随手指滑动的自定义view的步骤：</p>
<ol>
<li>首先获取触摸点的坐标</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span>{</span><br><span class="line">    <span class="comment">//获取手指触摸点的横坐标和纵坐标</span></span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()){</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>在ACTION_MOVE事件中计算偏移量,再调用layout（ ） 方法重新放置这个自定义View的位置即可:</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">    <span class="comment">//计算移动距离</span></span><br><span class="line">     <span class="keyword">int</span> offsetX = x - lastX;</span><br><span class="line">     <span class="keyword">int</span> offsetY = y - lastY;</span><br><span class="line">     <span class="comment">//调用layout方法来重新确定它的位置</span></span><br><span class="line">     layout(getLeft() + offsetX,getTop()+offsetY,</span><br><span class="line">     getRight()+offsetX,getBottom()+offsetY)</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">break</span>  </span><br></pre></td></tr></tbody></table></figure>

<p>在每次移动时都会触发layout()方法对屏幕重新布局，从而达到移动View的效果。</p>
<h3 id="offsetLeftAndRight-与offsetTopAndBottom"><a href="#offsetLeftAndRight-与offsetTopAndBottom" class="headerlink" title="offsetLeftAndRight() 与offsetTopAndBottom()"></a>offsetLeftAndRight() 与offsetTopAndBottom()</h3><p>这两种方法和layout()方法的效果以及使用方式都差不多，只需要将上面ACTION_MOVE中的代码替换为以下代码即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">    <span class="comment">//计算移动距离</span></span><br><span class="line">     <span class="keyword">int</span> offsetX = x - lastX;</span><br><span class="line">     <span class="keyword">int</span> offsetY = y - lastY;</span><br><span class="line">     <span class="comment">//对left 及 right 进行偏移</span></span><br><span class="line">     offsetLeftAndRight(offsetX);</span><br><span class="line">     <span class="comment">//对top及bottom进行偏移</span></span><br><span class="line">     offsetTopAndBottom(offsetY);</span><br><span class="line">     <span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="LayoutParams（-改变布局参数）"><a href="#LayoutParams（-改变布局参数）" class="headerlink" title="LayoutParams（ 改变布局参数）"></a>LayoutParams（ 改变布局参数）</h3><p>LayoutParams主要保存了View的布局参数， 因此可以通过改变它来达到改变View位置的效果。 我们只需将 ACTION_MOVE 中的代码替换成如下代码即可(<strong>注意是：MarginLayoutParams</strong>)：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">    <span class="comment">//计算移动距离</span></span><br><span class="line">     <span class="keyword">int</span> offsetX = x - lastX;</span><br><span class="line">     <span class="keyword">int</span> offsetY = y - lastY;</span><br><span class="line">     ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams)getLayoutParams();</span><br><span class="line">     </span><br><span class="line">     params.leftMargin = getLeft() + offsetX;</span><br><span class="line">     params.topMargin = getTop() + offsetY;</span><br><span class="line">     setLayoutParams(params)</span><br><span class="line">     <span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>采用动画来移动，在res目录新建anim文件夹并创建如下translate.xml文件:</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fillAfter</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXDelta</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXDelta</span>=<span class="string">"300"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>在Java中调用：</p>
<blockquote>
<p>view.setAnimation(AnimationUtils.loadAnimation(this,R.anim.translate))</p>
</blockquote>
<p>需要注意的是，如果动画文件中没有添加 <strong>android:fillAfter=”true”</strong> ，则方块向右平移300像素后，又返回原来的位置。并且，View动画不能改变View的位置参数，如果对一个Button加上如上的平移动画，当Button平移300像素停留在当前位置时，我们点击这个Button并不会触发点击事件，但是点击原始位置却触发了点击事件，这是因为对于系统来说，Button并没有改变原来位置。</p>
<p>在Android 3.0出现的属性动画解决了上述问题，它不仅可以执行动画，还能改变View的位置参数，其操作如下：</p>
<blockquote>
<p>ObjectAnimator.ofFloat(view,”translationX”，0，300).setDuration(1000).start()</p>
</blockquote>
<h3 id="scrollTo-与-scrollBy"><a href="#scrollTo-与-scrollBy" class="headerlink" title="scrollTo 与 scrollBy"></a>scrollTo 与 scrollBy</h3><p>scollTo、scollBy移动的是<strong>View的内容</strong>，如果在ViewGroup中使用， 则是移动<strong>其所有的子View</strong>。scrollTo(x，y)表示移动到一个具体的坐标点，而scrollBy(dx，dy)则表示移动的增量为dx、dy。 其中， scollBy最终也是要调用scollTo的。二者的源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(mScrollX != x || mScrollY != y){</span><br><span class="line">        <span class="keyword">int</span> oldX = mScrollX;</span><br><span class="line">        <span class="keyword">int</span> oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        </span><br><span class="line">        invalidateParentCaches();</span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        <span class="keyword">if</span>(!awakenScrollBars()){</span><br><span class="line">            postInvalidateOnAnimation();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果要实现上面view随手指滑动的效果，就需要将ACTION_MOVE中的代码替换成如下代码：</p>
<blockquote>
<p>((View)getParent()).scrollBy(-offsetX,-offsetY);</p>
</blockquote>
<p>请注意，这里是对view的parent进行scroll，这是因为如果对view本身scroll的话，就是对自己的内容进行移动，而不是整个view。并且注意，这里设置的偏移量值都为负值，以下具体讲解一下。</p>
<p><strong>假设我们正用放大镜来看报纸，放大镜用来显示字的内容。同样我们可以把放大镜看作我们的手机屏幕，它们都是负责显示内容的；而报纸则可以被看作屏幕下的画布，它们都是用来提供内容的。放大镜外的内容，也就是报纸的内容不会随着放大镜的移动而消失，它一直存在。同样，我们的手机屏幕看不到的视图并不代表其不存在。过程的示意图如下：</strong></p>
<p>scrollBy之前：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89/scrollTo%E5%88%9D%E5%A7%8B.png" alt="scrollBy初始状态"></p>
<p>调用scrollBy(50,50)之后：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89/scrollBy%E4%B9%8B%E5%90%8E.png" alt="scrollBy之后"></p>
<h3 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h3><p>我们在用scollTo/scollBy方法进行滑动时，这个过程是瞬间完成的，所以用户体验不大好。这里我们可以使用 Scroller 来实现有过渡效果的滑动，这个过程不是瞬间完成的，而是在一定的时间间隔内完成的。Scroller本身是不能实现View的滑动的，它需要与View的computeScroll() 方法配合才能实现弹性滑动的效果。具体代码如下示意：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomView</span><span class="params">(Context context,AttributeSet attrs)</span></span>{</span><br><span class="line">    <span class="keyword">private</span> Scroller mScroller;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">super</span>(context,attrs);</span><br><span class="line">    <span class="comment">//初始化mScroller</span></span><br><span class="line">    mScroller = <span class="keyword">new</span> Scroller(conetxt);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.computeScroll();</span><br><span class="line">        <span class="keyword">if</span>(mScroller.computeScrollOffset()){</span><br><span class="line">            ((View)getParent()).scrollTo(mScroller.getCurrentX(),mScroller.getCurrentY());</span><br><span class="line">            invalidate();</span><br><span class="line">        }</span><br><span class="line">       </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提供调用的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX,<span class="keyword">int</span> destY)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> scrollX = getScrollX();</span><br><span class="line">        <span class="keyword">int</span> scrollY = getScrollY();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> deltaX = destX - scrollX;</span><br><span class="line">        <span class="keyword">int</span> deltaY = destY - scrollY;</span><br><span class="line">        mScroller.startScroll(scrollX, scrollY, deltaX, deltaY);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们首先初始化Scroller，之后重写computeScroll方法，系统会在绘制View的时候在 draw 方法中调用该方法。在computeScroll方法中， 我们调用父类的scrollTo() 方法并通过Scroller来不断获取当前的滚动值， 每滑动一小段距离我们就调用invalidate() 方法不断地进行重绘，重绘就会调用computeScroll()方法， 这样我们通过不断地移动一个小的距离并连贯起来就实现了平滑移动的效果。这里我们设定CustomView沿着X轴向右平移400像素(至于为什么是负数，上面已经解释过了):</p>
<blockquote>
<p>mCustomView.smoothScrollTo(-400,0);</p>
</blockquote>
<h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>在属性动画出现之前，Android系统提供的动画只有帧动画和 View 动画。View 动画我们都了解，它提供了AlphaAnimation、 RotateAnimation、 TranslateAnimation、 ScaleAnimation这4种动画方式，并提供了AnimationSet动画集合来混合使用多种动画。 随着Android 3.0属性动画的推出， View动画不再风光。 相比属性动画， View动画一个非常大的缺陷突显， 其不具有交互性。 当某个元素发生View动画后，其响应事件的位置依然在动画进行前的地方， 所以View动画只能做普通的动画效果， 要避免涉及交互操作。 但是它的优点也非常明显： 效率比较高， 使用也方便。 </p>
<p>在属性动画中使用最多的就是AnimatorSet和ObjectAnimator配合： 使用 ObjectAnimator 进行更精细化的控制， 控制一个对象和一个属性值， 而使用多个ObjectAnimator组合到AnimatorSet形成一个动画。 属性动画通<br>过调用属性get、 set方法来真实地控制一个View的属性值， 因此， 强大的属性动画框架基本可以实现所有的动画效果。</p>
<h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><p>ObjectAnimator 是属性动画最重要的类， 创建一个 ObjectAnimator 只需通过其静态工厂类直接返还一个ObjectAnimator对象。 参数包括一个对象和对象的属性名字， 但这个属性必须有get和set方法， 其内部会通<br>过Java反射机制来调用set方法修改对象的属性值。 一般使用方式如下：</p>
<blockquote>
<p>ObjectAnimator.ofFloat(view,”translationX”,200,0).start()</p>
</blockquote>
<p>ObjectAnimator的使用方法就不介绍了，需要注意的是， 在使用ObjectAnimator的时候， 要操作的属性必须要有get和set方法， 不然ObjectAnimator 就无法生效。 如果一个属性没有get、 set方法， 也可以通过自定义一个属性类或包装类来间接地给这个属性增加get和set方法。 如以下示例这种情况：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span></span>{</span><br><span class="line">    <span class="keyword">private</span> View mTarget;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyView</span><span class="params">(View target)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.mTarget = target;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> mTarget.getLayoutParams().widht</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span></span>{</span><br><span class="line">        mTarget.getLayoutParams().width = width;</span><br><span class="line">        mTarget.requestLayout();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>使用时只需要操作包类就可以调用get、 set方法了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyView mMyView = <span class="keyword">new</span> MyView(mButton);</span><br><span class="line">ObjectAnimator.ofInt(mMyView,<span class="string">"width,500).setDuration(500).start()</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h3><p>ValueAnimator不提供任何动画效果， 它更像一个数值发生器， 用来产生有一定规律的数字， 从而让调用者控制动画的实现过程。 通常情况下， 在ValueAnimator的AnimatorUpdateListener中监听数值的变化， 从而完成动画的变换。</p>
<h3 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a>AnimatorSet</h3><p>略</p>
<h3 id="在XML中使用属性动画"><a href="#在XML中使用属性动画" class="headerlink" title="在XML中使用属性动画"></a>在XML中使用属性动画</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectAnimator</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"3000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:propertyName</span>=<span class="string">"scaleX"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueFrom</span>=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueTo</span>=<span class="string">"2.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>在代码中引用xml属性动画也很简单：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animator animator = AnimatorInflater.loadAnimator(<span class="keyword">this</span>,R.anim.scale);</span><br><span class="line">animator.setTarget(view);</span><br><span class="line">animator.start();</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解析Scroller"><a href="#解析Scroller" class="headerlink" title="解析Scroller"></a>解析Scroller</h2><p>略，去看源码，看不懂再来添加这块内容</p>
<h2 id="View-事件分发机制"><a href="#View-事件分发机制" class="headerlink" title="View 事件分发机制"></a>View 事件分发机制</h2><p>这里了解Activity的构成就好了，如下图：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89/Activity%E6%9E%84%E6%88%90.png" alt="Activity构成"></p>
<p>事件分发机制则看<a target="_blank" rel="noopener" href="https://glassx.github.io/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/">之前写的文章</a>还容易理解一些，这里就略过了。</p>
<h2 id="View的工作流程"><a href="#View的工作流程" class="headerlink" title="View的工作流程"></a>View的工作流程</h2><p>这一章太长，作为第二部分内容。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/07/06/git%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/06/git%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95/" class="post-title-link" itemprop="url">常用的git命令</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-06 16:57:00" itemprop="dateCreated datePublished" datetime="2019-07-06T16:57:00+08:00">2019-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 22:00:04" itemprop="dateModified" datetime="2019-11-17T22:00:04+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9F%A5%E9%98%85%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index">
                    <span itemprop="name">查阅工具</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>常用的git命令（摘抄自官网）</p>
<h2 id="列显已有的标签"><a href="#列显已有的标签" class="headerlink" title="列显已有的标签"></a>列显已有的标签</h2><p>列出现有标签的命令非常简单，直接运行 git tag 即可：</p>
<blockquote>
<p>$ git tag<br>v0.1<br>v1.3</p>
</blockquote>
<p>我们可以用特定的搜索模式列出符合条件的标签。在 Git 自身项目仓库中，有着超过 240 个标签，如果你只对 1.4.2 系列的版本感兴趣，可以运行下面的命令：</p>
<blockquote>
<p>$ git tag -l ‘v1.4.2.*’<br>v1.4.2.1<br>v1.4.2.2<br>v1.4.2.3<br>v1.4.2.4</p>
</blockquote>
<h2 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h2><h3 id="含附注的标签"><a href="#含附注的标签" class="headerlink" title="含附注的标签"></a>含附注的标签</h3><p>创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可：</p>
<blockquote>
<p>$ git tag -a v1.4 -m ‘my version 1.4’</p>
</blockquote>
<h2 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h2><p>轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可：</p>
<blockquote>
<p>$ git tag v1.4-lw</p>
</blockquote>
<h2 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h2><p>默认情况下，git push  并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可：</p>
<blockquote>
<p>$ git push origin v1.5</p>
</blockquote>
<p>如果要一次推送所有本地新增的标签上去，可以使用 –tags 选项：</p>
<blockquote>
<p>$ git push origin –tags</p>
</blockquote>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><p>删除本地分支可以使用一下命令：</p>
<blockquote>
<p>$ git branch -d testing</p>
</blockquote>
<p>如果删除失败，需要强制删除可以使用 -D 选项强制删除它：</p>
<blockquote>
<p>$ git branch -D testing</p>
</blockquote>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><blockquote>
<p>可以运行带有 –delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：</p>
</blockquote>
<blockquote>
<p>$ git push origin –delete serverfix<br>To <a target="_blank" rel="noopener" href="https://github.com/schacon/simplegit">https://github.com/schacon/simplegit</a></p>
<ul>
<li>[deleted]         serverfix</li>
</ul>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/05/12/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/12/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第3章——View的事件体系</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-12 22:42:00" itemprop="dateCreated datePublished" datetime="2019-05-12T22:42:00+08:00">2019-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:43:42" itemprop="dateModified" datetime="2019-11-17T21:43:42+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="View-基础知识"><a href="#View-基础知识" class="headerlink" title="View 基础知识"></a>View 基础知识</h2><h3 id="1、-MotionEvent-和-TouchSlop"><a href="#1、-MotionEvent-和-TouchSlop" class="headerlink" title="1、 MotionEvent 和 TouchSlop"></a>1、 MotionEvent 和 TouchSlop</h3><h4 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h4><p>这里只需要注意一点，通过MotionEvent 可以获得点击事件发生的x和y坐标，系统提供了两组方法，getX/getY 和 getRawX/getRawY ，他们的区别很简单，前者返回的是相对于当前View的左上角的 x 和 y 坐标，后者返回的是相对于手机屏幕左上角的 x和y 坐标。</p>
<h4 id="TouchSlop"><a href="#TouchSlop" class="headerlink" title="TouchSlop"></a>TouchSlop</h4><p>TouchSlop 是系统所能识别出的被认为是滑动的最小距离，小于这个值就不认为是滑动操作。TouchSlop 是一个常量，和设备有关，在不同的设备上这个值可能是不同的。通过如下方式可以获取这个常量：</p>
<blockquote>
<p>ViewConfiguration.get(context).getScaledTouchSlop()</p>
</blockquote>
<h3 id="2、VelocityTracker、GestureDetector-和-Scroller"><a href="#2、VelocityTracker、GestureDetector-和-Scroller" class="headerlink" title="2、VelocityTracker、GestureDetector 和 Scroller"></a>2、VelocityTracker、GestureDetector 和 Scroller</h3><h4 id="VelocityTracker"><a href="#VelocityTracker" class="headerlink" title="VelocityTracker"></a>VelocityTracker</h4><p>用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。它的使用过程很简单，首先在 View 的 onTouchEvent 方法中追踪当前单击事件的速度：</p>
<blockquote>
<p>VelocityTracker velocityTracker = VelocityTracker.obtain();<br>velocityTracker.addMovement(event);</p>
</blockquote>
<p>接着，当我们想知道当前的滑动速度时，可以采用如下方法获得：</p>
<blockquote>
<p>velocityTracker.computeCurrentVelocity(1000);<br>int xVelocity = (int)velocityTracker.getXVelocity();<br>int yVelocity = (int)velocityTracker.getYVelocity();</p>
</blockquote>
<p>这里需要注意的是： 一、获取速度之前必须先计算速度；二、这里的速度是指一段时间内手指所划过的像素数，比如将时间间隔设置为 1000ms，在 1s 内水平从左至右滑过100像素，那么水平速度就是100 。如果将时间间隔设置为100ms，在这100ms 内滑过10像素，则水平速度会变成 10 。此外，这个速度是可以为负值的，当水平方向从右往左滑动时，水平方向的速度即为负值。</p>
<h4 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h4><p>手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。比如要监听双击行为，代码如下：</p>
<blockquote>
<p>GestureDetector mGestureDetector = new GestureDetector(listener);<br>//再加上这行可以解决长按屏幕后无法拖动的现象<br>mGestureDetector.setIsLongpressEnabled(false);</p>
</blockquote>
<p>接着，接管目标View的onTouchEvent方法，在待监听View的 onTouchEvent 方法中如下实现：</p>
<blockquote>
<p>boolean consume = mGestureDetector.onTouchEvent(event);<br>return consume;</p>
</blockquote>
<p>OnGestureListener 与 OnDoubleTapListener 里面的方法有很多，常用的有：onSingleTapUp（单击）、onScroll（拖动）、onLongPress（长按）、onFling（快速滑动）、onScroll（拖动）、onDoubleTap（双击）。</p>
<h4 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h4><p>弹性滑动对象，用于实现View的弹性滑动，我们知道，当使用View的scrollTo/scrollBy方法来进行滑动时，其过程是瞬间完成的，这时候就可以使用 Scroller 来实现有过渡效果的滑动，它需要和View的conputeScroll方法配合使用才能共同完成这个功能，典型的使用如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Scroller mScroller = newScroller(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓慢滑动到指定位置</span></span><br><span class="line"><span class="function">privte <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX,<span class="keyword">int</span> destY)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> scrollX = getScrollX();</span><br><span class="line">    <span class="keyword">int</span> delta = destX - scrollX;</span><br><span class="line">    <span class="comment">//1000ms内滑向destX就是，效果就是慢慢滑动</span></span><br><span class="line">    mScroller.startScroll(scrollX,<span class="number">0</span>,delta,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">    invalidate();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(mScroller.computeScrollOffset()){</span><br><span class="line">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">        postInvalidate()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="View-的滑动"><a href="#View-的滑动" class="headerlink" title="View 的滑动"></a>View 的滑动</h2><p>未完待续。。。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第2章——IPC机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-11 22:40:00" itemprop="dateCreated datePublished" datetime="2019-05-11T22:40:00+08:00">2019-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:43:34" itemprop="dateModified" datetime="2019-11-17T21:43:34+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>提到IPC的使用场景就必须提到多进程，如果只有一个进程，又何必使用进程间通信。多进程的情况分为两种：第一种是应用本身需要采用多进程模式实现（比如通过多个进程来获取多份内存空间）；第二种是当前应用需要向其他应用获取数据，由于是两个应用，因此必须采用跨进程通信方式。</p>
<h2 id="Android中的多进程模式"><a href="#Android中的多进程模式" class="headerlink" title="Android中的多进程模式"></a>Android中的多进程模式</h2><p>我们不讨论两个应用之间的多进程情况。</p>
<h3 id="1、开启多进程"><a href="#1、开启多进程" class="headerlink" title="1、开启多进程"></a>1、开启多进程</h3><p>，Android中使用多进程有两种方法：第一种是给四大组件在AndroidManifest中指定 android:process 属性；第二种是非常规方式，通过JNI在native层去fork一个新的进程。第二种情况属于特殊情况，暂时不考虑。</p>
<h3 id="2、多线程模式的运行机制"><a href="#2、多线程模式的运行机制" class="headerlink" title="2、多线程模式的运行机制"></a>2、多线程模式的运行机制</h3><p>如果用一句话形容多进程，那就是：“当应用开启了多进程以后，各种奇怪的现象都出现了”，开启多线程只需要给四大组件指定 android:process 属性，但是是否正常运行就是另外一回事了。看个例子：</p>
<blockquote>
<p>有 MainActivity 和 SecondActivity，其中 SecondActivity 指定运行在一个新的进程中，并且项目还新建一个 UserManager 类，类中有个public 的静态变量：</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserManager</span></span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sUserId = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在 MainActivity 的 onCreate 中把 sUserId 的值改为2，打印sUserId，之后再启动 SecondActivity ，在 SecondActivity 中打印 sUserId 。</p>
</blockquote>
<p><strong>可以发现在 MainActivity 中打印的值是2，在 SecondActivity 中打印的值是 1 ，看到这里，大家应该明白了多进程带来的问题，绝非只是指定一个 android:process 这么简单</strong>。</p>
<p><strong>分析：</strong>我们知道，Android 系统为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类的对象会产生<strong>多份副本</strong>。拿上面的例子来说，两个进程中都存在一个 UserManager 类，并且这两个类是互相不干扰的，在一个进程中修改 sUserId 的值只会影响当前进程，对其他进程不会造成任何影响。</p>
<p>通过以上可以知道，运行在不同进程中的四大组件，只要他们之间需要通过内存来共享数据，都会共享失败，这也是多进程所带来的主要影响。一般来说，使用多进程会造成如下几个方面的问题：</p>
<ul>
<li>静态成员和单例模式完全失效  </li>
</ul>
<blockquote>
<p>上面做了分析</p>
</blockquote>
<ul>
<li>线程同步机制完全失效 </li>
</ul>
<blockquote>
<p>既然都不是一块内存了，那么不管是锁对象还是锁全局类都无法保证线程同步，因为不同进程锁的不是同一个对象</p>
</blockquote>
<ul>
<li>SharedPreference 的可靠性下降  </li>
</ul>
<blockquote>
<p>是因为 SharedPreference 不支持两个进程同时去执行写操作，否则会导致可能的数据丢失（因其本质是通过读写xml文件来实现的）</p>
</blockquote>
<ul>
<li>Application 会多次创建  </li>
</ul>
<blockquote>
<p>这个问题是显而易见的，由于系统要在创建新的进程同时分配独立的虚拟机，所以这个过程其实就是启动一个应用的过程，因此相当于系统又把应用重新启动了一遍，自然就创建了新的Application。还可以这么理解，运行在同一个进程中的组件是属于同一个虚拟机和同一个Application的；同理，运行在不同进程中的组件是属于两个不同的虚拟机和Application。</p>
</blockquote>
<h2 id="IPC-基础概念介绍"><a href="#IPC-基础概念介绍" class="headerlink" title="IPC 基础概念介绍"></a>IPC 基础概念介绍</h2><p>IPC 中的基础概念包括3方面内容： Serializable 接口、Parcelable接口、Binder。</p>
<h3 id="1、Serializable-接口"><a href="#1、Serializable-接口" class="headerlink" title="1、Serializable 接口"></a>1、Serializable 接口</h3><p>Serializable 是Java提供的一个空的序列化接口，为对象提标准的序列化和反序列化操作。使用 Serializable 实现序列化非常简单，只需要类实现 Serializable 接口，并且在类的声明中指定一个类似下面的标识：</p>
<blockquote>
<p>private static final long serialVersionUID = 12345L</p>
</blockquote>
<p>实际上，这个 serialVersionUID 也不是必需的，因为serialVersionUID 的机制是这样的： 序列化时，系统会把当前类的 serialVersionUID 写入序列化的文件中；当反序列化的时候，会去检测文件中的 serialVersionUID 是否和当前类的 serialVersionUID 一致，如果一致说明序列化的类版本和当前类的版本是相同的，就可以成功反序列化；否则的话，说明当前类和序列化的类相比发生了某些变换，就无法正常反序列化。以下例子说明 Serializable 的使用：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">12345L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String userName;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********使用*****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="number">12</span>,<span class="string">"tom"</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"cache.txt"</span>));</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化过程</span></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"cache.txt"</span>));</span><br><span class="line">User newUser = (User)in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></tbody></table></figure>

<p>另外，系统默认的序列化过程也是可以改变的，通过重写 writeObject 和 readObject 方法即可，只不过大部分情况下我们无需去重写这两个方法。</p>
<h3 id="2、Parcelable-接口"><a href="#2、Parcelable-接口" class="headerlink" title="2、Parcelable 接口"></a>2、Parcelable 接口</h3><p>Parcelable 也是一个接口，只要实现这个接口，类的对象就可以实现序列化并通过 Intent 和 Binder 传递。</p>
<p>具体使用方法可以查看<a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/android/os/Parcelable.html">官方文档</a></p>
<p>既然 Parcelable 和 Serializable 都能实现序列化并且都可用于 Intent 间的数据传递，那如何取舍呢？Serializable 是Java中的序列化接口，序列化和反序列化需要大量I/O操作；而Parcelable 是 Android 中的序列化方式，主要用在内存序列化上，使用起来稍显麻烦，但是效率高，所以这是 Android 官方推荐的序列化方式。综上所述，将对象序列化存储到设备或者通过网络传输时使用 Serializable ，否则使用 Parcelable 。</p>
<h3 id="3、Binder"><a href="#3、Binder" class="headerlink" title="3、Binder"></a>3、Binder</h3><p>Binder 是 Android 中的一种 IPC 方式，还可以理解为一种虚拟的物理设备，它的设备驱动是 dev/binder。</p>
<h2 id="Android-中的-IPC-方式"><a href="#Android-中的-IPC-方式" class="headerlink" title="Android 中的 IPC 方式"></a>Android 中的 IPC 方式</h2><h3 id="使用Bundle"><a href="#使用Bundle" class="headerlink" title="使用Bundle"></a>使用Bundle</h3><p>由于Bundle 实现了 Parcelable 接口，所以它可以方便地再不同的进程间传输，基于这一点，当我们在一个进程中启动了另一个进程的 Activity、Service 和 Receiver，我们就可以在Bundle 中附加我们需要传给其他进程的信息，并通过Intent 发送出去，这是一种最简单的进程间通信方式。</p>
<h3 id="使用文件共享"><a href="#使用文件共享" class="headerlink" title="使用文件共享"></a>使用文件共享</h3><p>共享文件是一种不错的进程间通讯方式，适合在对数据同步要求不高的进程间通信。当然，SharedPreferences 是个特例，由于系统对它的读写会有一定的缓存策略，即在内存中会有一份 SharedPreferences 文件的缓存，因此在多进程模式下，面对高并发的的读写会有很大几率丢失数据，因此不建议在进程间通信中使用 SharedPreferences。</p>
<h3 id="使用-Messenger"><a href="#使用-Messenger" class="headerlink" title="使用 Messenger"></a>使用 Messenger</h3><p>顾名思义可以翻译成信使，通过它可以在不同的进程中传递 Message 对象,它是轻量级的 IPC 方案，底层实现是 AIDL 。Messenger 只是一串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务端，服务端仍然只能一个个处理。具体可以参考<a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/android/os/Messenger">官方文档</a></p>
<h3 id="使用-AIDL"><a href="#使用-AIDL" class="headerlink" title="使用 AIDL"></a>使用 AIDL</h3><p>由于 Messenger 服务端只能串行处理，所以可以使用 AIDL 来实现跨进程调用。具体内容可以参考<a target="_blank" rel="noopener" href="https://developer.android.google.cn/guide/components/aidl">官方文档</a></p>
<h3 id="使用-ContentProvider"><a href="#使用-ContentProvider" class="headerlink" title="使用 ContentProvider"></a>使用 ContentProvider</h3><p>这是Android 中提供的专门用于不同应用建进行数据共享的方式。</p>
<h3 id="使用-Socket"><a href="#使用-Socket" class="headerlink" title="使用 Socket"></a>使用 Socket</h3><p>Socket 是网络通信中的概念，也称为“套接字”，<strong>它分为流式套接字和用户数据报套接字两种，分别对应于网络的传输控制层中的TCP和UDP协议</strong>。</p>
<h2 id="选择合适的-IPC-方式"><a href="#选择合适的-IPC-方式" class="headerlink" title="选择合适的 IPC 方式"></a>选择合适的 IPC 方式</h2><table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Bundle</td>
<td>简单易用</td>
<td>只能传输Bundle支持的数据类型</td>
<td>四大组件之间的通信</td>
</tr>
<tr>
<td>文件共享</td>
<td>简单易用</td>
<td>不适合高并发</td>
<td>无并发，数据实时性要求不高</td>
</tr>
<tr>
<td>AIDL</td>
<td>功能强大，支持一对多，支持实时</td>
<td>使用复杂</td>
<td>一对多通信且有RPC需求</td>
</tr>
<tr>
<td>Messenger</td>
<td>一对多串行通信，支持实时</td>
<td>高并发困难，不支持RPC，只能传输Bundle支持的数据</td>
<td>低并发的一对多通信</td>
</tr>
<tr>
<td>ContentProvider</td>
<td>数据源访问功能强大</td>
<td>理解为受约束的AIDL，主要提供数据源的 CRUD 操作</td>
<td>一对多的进程间数据共享</td>
</tr>
<tr>
<td>Socket</td>
<td>支持一对多并发实时通信，支持字节流</td>
<td>实现繁琐</td>
<td>网络数据交换</td>
</tr>
</tbody></table>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC1%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC1%E7%AB%A0/" class="post-title-link" itemprop="url">第1章——Activity 生命周期和启动模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-11 15:42:00" itemprop="dateCreated datePublished" datetime="2019-05-11T15:42:00+08:00">2019-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-22 21:37:59" itemprop="dateModified" datetime="2020-07-22T21:37:59+08:00">2020-07-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Activity-的生命周期全面分析"><a href="#Activity-的生命周期全面分析" class="headerlink" title="Activity 的生命周期全面分析"></a>Activity 的生命周期全面分析</h2><p>本节将分为两部分内容，一部分是典型情况下的生命周期，一部分是异常情况下的生命周期（比如被系统回收或者由于当前设备Configuration 发生改变而导致 Activity 被销毁重建）。</p>
<h3 id="一、典型情况下的生命周期分析"><a href="#一、典型情况下的生命周期分析" class="headerlink" title="一、典型情况下的生命周期分析"></a>一、典型情况下的生命周期分析</h3><p>正常情况下，Activity 会经历如下生命周期：</p>
<ol>
<li>onCreate ： 表示Activity 正在创建，这是生命周期第一个方法。  </li>
<li>onRestart ： 表示Activity 正在重新启动。一般情况下，当前Activity 从不可见重新变为可见时，onRestart 就会被调用。    </li>
<li>onStart ： 表示Activity 正在被启动，这时候 Activity 已经可见了，但是还没出现在前台，无法和用户交互。<strong>可以理解为 Activity 已经显示出来了，但是我们还看不到</strong>。  </li>
<li>onResume ： 表示 Activity 已经可见了，并且出现在前台可以交互。  </li>
<li>onPause： 表示 Activity 正在停止，正常情况下，紧接着 onStop 会被调用；在特殊情况下，如果这个时候快速地再回到当前 Activity ，那么 onResume 将会被调用。此时可以做一些存储数据、停止动画等工作，但是注意不能太耗时，<strong>因为onPause必须先执行完，新Acitivty 的 onResume 才会执行</strong>。    </li>
<li>onStop ： 表示 Activity 即将停止，可以做一些稍微重量级的回收工作，同样不能太耗时。  </li>
<li>onDestroy： 表示 Activity 即将被销毁，这是Activity 生命周期中的最后一个回调，我们可以做一些回收工作和最终的资源释放。  </li>
</ol>
<p>以下再针对 Activity 的生命周期具体说明：  </p>
<ul>
<li>针对特定的Activity，第一次启动回调如下： onCreate-&gt;onStart-&gt;onResume  </li>
<li>打开新的Activity 或者(按Home键)回到桌面的时候，回调 onPause-&gt;onStop ；这里有种特殊情况，打开的新Activity 如果是透明主题（意味着当前Activity还是可见的），那么当前Activity 不会回调 onStop 。  </li>
<li>当用于再次回到原来的 Activity 时，回调 onRestart-&gt;onStart-&gt;onResume  </li>
<li>当用户按返回键返回上一个页面时，回调 onPause-&gt;onStop-&gt;onDestroy  </li>
<li>从整个生命周期来看，<strong>onCreate与onDestroy是配对的，分别标识着Activity的创建与销毁；onStart与onStop是配对的，标识着Activity是否可见；onResume 与 onPause 是配对的，标识着Activity是否在前台</strong>。 </li>
</ul>
<p>一个问题：当前 Activity 标识为 A，启动一个新的Activity 标识为 B，那么B的onResume 和 A 的onPause 哪个先执行？</p>
<blockquote>
<p>由上面的描述可知是限制性A的 onPause，再执行 B 的onResume ，具体看源码，<a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/android/app/Activity">官方文档</a>也是这么解释(<strong>Always followed by onPause()</strong>)。 </p>
</blockquote>
<h3 id="二、异常情况下的生命周期分析"><a href="#二、异常情况下的生命周期分析" class="headerlink" title="二、异常情况下的生命周期分析"></a>二、异常情况下的生命周期分析</h3><h4 id="1、资源相关的系统配置发生改变导致Activity被杀死并重建"><a href="#1、资源相关的系统配置发生改变导致Activity被杀死并重建" class="headerlink" title="1、资源相关的系统配置发生改变导致Activity被杀死并重建"></a>1、资源相关的系统配置发生改变导致Activity被杀死并重建</h4><p>如果没有做特殊处理，当横竖屏切换的时候，由于系统配置发生了改变，Activity 会加载不同的资源（比如横竖屏加载两张不同图片），此时 Activity 会被销毁并且重新创建。由于 Acitivity 是在异常情况下终止的，因此在销毁Activity的时候，<strong>确切来说是在onStop之前（但是跟onPause没有顺序关系，有可能在其之前，也可能在其之后）会调用 onSaveInstanceState 来保存当前 Activity 状态</strong>；  </p>
<p>Activity 被重新创建后，会把销毁时 onSaveInstanceState 方法保存的Bundle对象作为参数传给 onCreate 方法和 onRestoreInstanceState 方法，因此可以从这两个方法恢复之前保存的数据。<strong>从时序上来说，onRestoreInstanceState 调用时机在 onStart 之后。</strong></p>
<blockquote>
<p>这两个方法恢复数据的区别是：onRestoreInstanceState 一旦被调用，其参数 savedInstanceState 是一定有值的，我们不需要额外地判空；而 onCreate 中的数据是可能为空的，官方文档建议采用 onRestoreInstanceState 去恢复数据。</p>
</blockquote>
<p>如果没有覆写的话，onSaveInstanceState 和 onRestoreInstanceState 方法中，系统会自动为我们做一定的恢复工作。</p>
<h4 id="2、资源内存不足导致低优先级Activity被杀死"><a href="#2、资源内存不足导致低优先级Activity被杀死" class="headerlink" title="2、资源内存不足导致低优先级Activity被杀死"></a>2、资源内存不足导致低优先级Activity被杀死</h4><p>Activity 按照优先级从高到低可以分为如下三种：</p>
<p>（1）前台Activity——正在和用户交互的Activity，优先级最高<br>（2）可见但非前台Activity——比如Activity中弹出了dialog，导致Activity可见但是位于后台无法和用户直接交互。<br>（3）后台Activity——已经被暂停的的Activity，优先级最低。  </p>
<p>我们知道，当系统配置发生改变时，Activity 会被销毁并重新创建，当然我们也可以通过给 Activity 指定configChanges 属性来阻止销毁重建：</p>
<blockquote>
<p>android:configChanges=”orientation”</p>
</blockquote>
<p>当然这个属性可以配置的项目还有很多，比如切换系统语言、使用了新字号、界面模式改变（比如 是否开启/关闭夜间模式）。</p>
<h2 id="Activity-的启动模式"><a href="#Activity-的启动模式" class="headerlink" title="Activity 的启动模式"></a>Activity 的启动模式</h2><ul>
<li>standard： 标准模式。不复用，每次请求都创建新实例，并且就运行在启动它的那个Activity所在的栈。    </li>
<li>singleTop： 栈顶复用模式 。如果实例位于任务栈的栈顶就复用，复用时调用 onNewIntent方法，否则就创建新的实例。       </li>
<li>singleTask： 栈内复用模式。当前栈内没有实例，则创建实例放入栈中；如果实例在当前栈内，则复用，复用时调用 onNewIntent方法，并把它之上的Activity出栈。  </li>
<li>singleInstance： 单例模式。<strong>只能单独位于一个任务栈中</strong>，只要这个实例存在，后续的请求均不会创建新的Activity。复用时调用 onNewIntent方法。  </li>
</ul>
<p>在使用 ApplicationContext 启动standard 模式的Activity时会报错：</p>
<blockquote>
<p>Callking startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag</p>
</blockquote>
<p>这是因为standard模式的Activity 默认会进入启动它的Activity所属的任务栈中，由于非Activity类型的Context 没有所谓的任务栈，所以会报错。解决这个问题的方法是为待启动的Activity指定 FLAG_ACTIVITY_NEW_TASK 标记，这样启动的时候会为它创建一个新的任务栈（体会下，这时候实际上是以singleTask模式启动的）</p>
<h3 id="参考其他博客的启动模式的原理"><a href="#参考其他博客的启动模式的原理" class="headerlink" title="参考其他博客的启动模式的原理"></a>参考其他博客的启动模式的原理</h3><p>点击launcher 的startactivity 会调用到Instrumentation的execStartActivity，之后交给AMS 来处理启动操作，之后调用 ActivityStackSupervisor 的 startActivityMayWait 方来启动，而ActivityStackSupervisor 是管理Activity堆栈的类</p>
<p>另外提一下，Activity 在AMS中的形式是 ActivityRecord，task在AMS 中的形式是 TaskRecord，进程在 AMS 中的管理形式为 ProcessRecord</p>
<p>判断启动模式，根据当前的Activity 和 要启动的Activity 的启动模式，根据相应的启动模式设置launchFlags</p>
<p>在Android 5.0上 在 ActivityStackSupervisor 类的startActivityUncheckedLocked  里面判断launchmode</p>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/09365022adac">简书的博客上的内容</a></p>
</blockquote>
<h3 id="Activity-的Flags"><a href="#Activity-的Flags" class="headerlink" title="Activity 的Flags"></a>Activity 的Flags</h3><p>Activity 的Flags很多，这里分析比较常用的几个:</p>
<ul>
<li>FLAG_ ACTIVITY_ NEW_ TASK</li>
</ul>
<blockquote>
<p>为Activity 指定singleTask启动模式，其效果和在XML中指定 singleTask 启动模式相同</p>
</blockquote>
<ul>
<li>FLAG_ ACTIVITY_ SINGLE_ TOP</li>
</ul>
<blockquote>
<p>为Activity 指定 singleTop 启动模式，其效果和在XML中指定 singleTop 启动模式相同</p>
</blockquote>
<ul>
<li>FLAG_ ACTIVITY_ CLEAR_ TOP</li>
</ul>
<blockquote>
<p>具有此标记的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈，这个标记为一般会和FLAG_ACTIVITY_SINGLE_TOP标记位一起出现。由前面的分析可知，singleTask启动模式默认具有此标记位效果。</p>
</blockquote>
<ul>
<li>FLAG_ ACTIVITY_ EXCLUDE_ FROM_ RECENTS</li>
</ul>
<blockquote>
<p>具有这个标记位的Activity不会出现在历史Activity列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候，这个标记比较有用。这个标记等同于xml中指定Activity 的属性 android:excludeFromRecents = “true”</p>
</blockquote>
<h4 id="IntentFilter-的匹配规则"><a href="#IntentFilter-的匹配规则" class="headerlink" title="IntentFilter 的匹配规则"></a>IntentFilter 的匹配规则</h4><p>略</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/05/04/%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/04/%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-04 11:16:00" itemprop="dateCreated datePublished" datetime="2019-05-04T11:16:00+08:00">2019-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-10 10:15:31" itemprop="dateModified" datetime="2020-05-10T10:15:31+08:00">2020-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%B6%E6%AE%B5/" itemprop="url" rel="index">
                    <span itemprop="name">阶段</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>别漏了BroadCastReceiver</p>
</details>

<blockquote>
<p>参考链接：<a href="https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/">ipc机制</a></p>
</blockquote>
<h2 id="零散的知识点"><a href="#零散的知识点" class="headerlink" title="零散的知识点"></a>零散的知识点</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li><p>Service 多次启动， onStartCommand 会多次    </p>
</li>
<li><p>本地广播无法通过静态方式注册    </p>
</li>
<li><p>RemoteViews 通过id来给特定的view更新UI     </p>
</li>
<li><p>为毛Thread 废弃 suspend 方法，因为如果被suspend 了一直持有锁，那就可能导致死锁了      </p>
</li>
<li><p>stop 方法废弃，主要是防止数据写了一半，导致后期数据不一致问题     </p>
</li>
<li><p>在sleep过程中，有可能会执行 thread.interrupt 方法，所以要try-catch      </p>
</li>
<li><p>如何禁止指令重排和可见性：final、volatile、加锁             </p>
</li>
<li><p>保证原子性：加锁、CAS、原子类型(AtomicInteger等)                </p>
</li>
<li><p>onSaveInstanceState 的调用时机： 销毁Activity 的时候，在 onStop 之前(与onPause没啥关系)。          </p>
</li>
<li><p>onRestoreInstanceState 的调用时机是在 onStart 之后          </p>
</li>
<li><p>开启多进程，可以指定process，还可以在native 上fork出来          </p>
</li>
<li><p>多进程问题：Application多次、单例失效、sp不可靠、锁失效(即使锁类也不行了)            </p>
</li>
<li><p>view的滑动有几种方法：layout、offsetALeftAndRight/offsetTopAndBottom、LayoutParams、动画、scrollTo、scrollBy、scroller         </p>
</li>
<li><p>Android系统分层：应用层、应用框架层、系统运行库层、硬件抽象层、Linux内核        </p>
</li>
<li><p>init 进程工作：启动属性服务和zygote 进程       </p>
</li>
<li><p>zygote启动工作：创建java虚拟机，并注册jni方法、创建       SocketServer 来监听 fork 请求         </p>
</li>
<li><p>SystemServer 的工作：启动系统服务、启动Binder 线程池(用于与其他进程通信)         </p>
</li>
<li><p>Android系统启动流程，可以参考<a href="https://glassx.gitee.io/2019/11/22/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC2%E7%AB%A0/">博客</a>           </p>
</li>
<li><p>在zygote 通过fork创建进程后，启动它的binder线程池，并通过反射调用ActivityThread 的main 方法，创建主线程环境            </p>
</li>
<li><p>ActivityThread 的 attach 方法就是初始化 Application 对象            </p>
</li>
<li><p>Launcher 启动某个app应用，首先会为启动的 Activity 的intent 设置 FLAG_ACTIVITY_NEW_TASK，在新任务栈中         </p>
</li>
<li><p>新Activity 启动经历三个阶段： Launcher经过Instrumentation 到AMS、AMS 到 ApplicationThread、ActivityThread 启动Activity         </p>
</li>
<li><p>ApplicationThread 是ActivityThread 的内部类，负责与AMS 进程间通信，收到进程消息后，在ApplicationThread 中通过 handler.sendMessager 的方式向 ActivityThread 中发送消息启动Activity          </p>
</li>
<li><p>LoadApk 用于描述已经加载进来的 APK 文件的。       </p>
</li>
<li><p>通过反射创建Activity，attach 方法将新建的Context 设置成mBase          </p>
</li>
<li><p>Context包装类目的：ContextImpl 具体实现不会暴露给使用者、组合而不是继承，更灵活          </p>
</li>
<li><p>启动应用的的第一个Activity过程中(handleMessage中)，最终会使用LoadApk.makeApplication() 方式创建Application ，同样也是通过反射的方式。        </p>
</li>
<li><p>会将 Application 缓存到LoadApk中      </p>
</li>
<li><p>Application 的attach ，就是把新建的ContextImpl 设置为mBase，并且，Application 设置为ContextImpl的 mOut变量                </p>
</li>
<li><p>获取 Application Context 的方式，首先从 LoadApk中获取，否则 调用ActivityThread 中获取         </p>
</li>
<li><p>同理，Activity 的 attach 会将ContextImpl 设置为mBase，并将Activity 对象赋值给 ContextImpl 的 mOuterContext。               </p>
</li>
<li><p>类的生命周期，  加载-验证-准备-解析-初始化-使用-卸载                </p>
</li>
<li><p>垃圾收集算法： 标记-清除、复制、标记-整理、分代         </p>
</li>
<li><p>Java API 中标称自己是线程安全的类，其实大多数不是绝对的线程安全的，如你遍历的时候，读取size 是synchronize修饰的，但是在打印过程中可能被删除了某些元素，这时候读取就会抛异常     </p>
</li>
<li><p>线程安全的实现方法： 无同步方案(不共享)、互斥同步、非阻塞同步(如CAS操作)      </p>
</li>
<li><p>锁优化：自旋、锁消除(比如在方法内部new出来StringBuffer)、锁粗化(也是StringBuffer的append)、轻量级锁(CAS操作mark word)、偏向锁       </p>
</li>
<li><p>轻量级锁，使用CAS操作尝试将对象的 MarkWord 改成轻量级锁标志，如果成功，则拥有锁；否则，判断锁是否指向当前线程，如果是，则直接进入。否则，就等待(个人觉得应该是CAS重试)。如果有两个以上线程在争用这个锁，就升级为重量级锁，后面的线程阻塞。      </p>
</li>
<li><p>偏向锁：偏向锁在轻量级锁基础上连 CAS 都不做。在对象第一次被线程获取后，把线程id写在 MarkWord 中(这个当然是CAS操作)，当另一个线程尝试获取的时候，偏向模式就结束(指的是这个CAS操作不做了)，恢复到未锁定或者轻量级锁状态，后续就是轻量级锁规则了       </p>
</li>
<li><p>轻量级锁与偏向锁不一定总是有利的，如果程序中大多数锁都被不同线程访问，竞争激烈，那它还得转换状态，因此，有时候禁止它们反而性能提高      </p>
</li>
<li><p>https在http之下，tcp之上增加一层 SSL(Secure Socket Layer)    </p>
</li>
<li><p>ssl 握手前，先要tcp 握手     </p>
</li>
<li><p>ssl握手： 算法、随机数 -&gt; 算法(对称、非对称、摘要)、随机数、证书 -&gt; 验证证书、公钥加密“前主密钥” -&gt; 握手摘要 -&gt; 握手摘要      </p>
</li>
<li><p>udp：无需握手、无需维护连接(缓存、拥塞控制、序号确认等)、头部小，8个字节，tcp有20个，值得注意的是，它有校验和，用于防止传输过程引入的差错    </p>
</li>
<li><p>快重传：收到3个相同 ack，则立即重传     </p>
</li>
<li><p>流量控制：避免接收方缓存溢出     </p>
</li>
<li><p>拥塞控制：防止整体网络质量堵塞      </p>
</li>
<li><p>确定拥塞：超时没收到ack，或者3次重复的ack    </p>
</li>
<li><p>拥塞控制方法：慢启动、拥塞避免(收到ack之后，不像慢启动翻倍增长，而是缓慢增长)、快速恢复(窗口减半，之后执行拥塞避免)        </p>
</li>
<li><p>tcp 时延：握手、拥塞控制、捎带确认、TIME-WAIT      </p>
</li>
<li><p>多线程下载大文件速度快，为啥？1、多个下载线程能够抢占更多的实时网络带宽（相当于下载进程占用了更多带宽）             </p>
</li>
<li><p>改善tcp性能的方法：并行连接、长连接、管道化连接    </p>
</li>
<li><p>死锁条件：互斥条件、不可剥夺、占有等待、环路等待，可以采用基于矩阵的算法来检测死锁       </p>
</li>
<li><p>死锁恢复：回滚、杀死进程、抢占(需要人工干预)     </p>
</li>
<li><p>按返回键，要先清完当前的栈，再清其他的栈，比如：B是singleInstance，则 A启动B，B启动C，则此时按返回键先到A，再按返回键才看到B     </p>
</li>
<li><p>如果想fragment commit 立即生效，可以在 FragmentTrasation.commit() 之后，执行 fragmentManager.executePendingTransactions()       </p>
</li>
<li><p>Fragment 生命周期： onAttach、onCreate、onCreateView、onActivityCteated、onStart、onResume、onPause、onStop、onDestroyView、onDestroy、onDetach    </p>
</li>
<li><p>避免异步使用 commit，因为感知不到Activity 生命周期，可能commit的时候，Activity 结束了      </p>
</li>
<li><p>广播分类：标准广播、有序广播、本地广播       </p>
</li>
<li><p>BroadcastReceiver 的onReceiver 中也不是不能开启子线程，只是不推荐开启，因为 BroadcastReceiver 的生命周期本身就很短，在子线程还没结束的情况下，Activity 就被退出了，所以能，BroadcastReceiver 的耗时任务建议交给 IntentService 去做        </p>
</li>
<li><p>mmkv 可以替代 SharedPreference      </p>
</li>
<li><p>MVC 在Android 中导致 Activity 的职责不明确，很臃肿。没有涉及Model 时，View 可以直接调用Controller，Controller 可以直接调用View。并且，View 还可以直接更新Model，只不过Model要更新UI必须经过 Controller 。      </p>
</li>
<li><p>二叉搜索树查找代价：logN 或者 N，插入，基本上在logN，删除：O(1) 或者 logN    </p>
</li>
<li><p>平衡二叉搜索树：查： logN，插入：logN，删除： 2logN    </p>
</li>
<li><p>红黑树：查： logN，插入：logN，删除：logN      </p>
</li>
<li><p>发起tcp请求，序列号是随机的，这是防止多次重传时候，(假如已经建立连接了)分不出是哪一次了    </p>
</li>
<li><p>三次握手，第一二次不可以携带数据(第一次允许，容易引起攻击，并且不确认有接收能力)，但是第三次是可以携带数据的     </p>
</li>
<li><p>udp 面向报文，添加首部之后就可以交给ip层，不拆分；tcp 面向字节流，对报文拆分     </p>
</li>
<li><p>udp 没有拥塞控制，tcp会有拥塞控制，tcp还有滑动窗口实现流量控制     </p>
</li>
<li><p>http2特性：服务端push、新的二进制格式(而不是文本)、多路复用、新的压缩算法、header 压缩、更安全的ssl     </p>
</li>
<li><p>RxJava 线程切换原理：将Observer 封装成 SubscribeTask ，它实现了Runnable接口，如果在main线程的话，会启用Handler(getMainLooper)将Runnable封装成Message 发送出去，其他线程则交给相应的线程池。      </p>
</li>
<li><p>LocalBroadcastManager 初始化的时候会创建一个主线程的Handler，发送广播时，根据intent获取action，依次调用    </p>
</li>
<li><p>线程池异常处理：1、继承 ThreadPoolExecutor 再重写 afterExecute ，可以得到实际异常  2、对Runnable 里面的整个try-catch   3、自己写ThreadFactory，即自己创建线程，然后实现 setUncaughtExceptionHandler 来捕捉。       </p>
</li>
<li><p>synchronize 同步原理：代码块：monitorenter指令插入到同步代码块的开始处，将monitorexit插入到结束处  ，方法同步，采用另外的标记ACC-synchronized，其实是一样的效果，都是针对monitor      </p>
</li>
<li><p>线程阻塞的原因： 调用wait、等待同步锁、执行了sleep、执行了 join      </p>
</li>
<li><p>yield 将线程状态由Running 转变为 Runnable状态，但是系统可能不理会这个请求，所以不一定可靠，官方只建议用来调试      </p>
</li>
<li><p>onCreate 中，子线程可以刷新ui，是因为ViewGroup 的attachInfo 还是空的，后续的线程检测就不进行了。还有，线程判断主要是判断和new 这个view的线程是不是同一个。      </p>
</li>
<li><p>LruCache 原理：LinkedList，最近使用过的就插在头部，淘汰的时候，淘汰尾部      </p>
</li>
<li><p>Object 的方法：  clone、equals、finalize、getClass、hashCode、identityHashCode、notify、notifyAll、toString、wait       </p>
</li>
<li><p>HashMap 中链表元素达到一定阈值(8个)，就会转化为红黑树，然后转成树key总要通过什么对比吧，其实是通过 System.identityHashCode 来对比的，它不受hashCode 的影响        </p>
</li>
<li><p>RecyclerView 的优化：数据处理与视图分开(在bindViewHolder的时候不做数据处理了)、布局优化、设置setHasFixedSize(根据最初的高度、后面就不会重新测量了)、减少item的监听器创建、滑动过程停止加载、DiffUtil工具、公用 RecycledViewPool      </p>
</li>
<li><p>嵌套的RecyclerView 中可能用得着 Linearlayoutmanager 的 onSaveInstanceState 和 onRestoreInstanceState 来恢复嵌套的recyclerview的滑动状态        </p>
</li>
<li><p>全局捕捉异常，在Application 中为Thread.setUncatchExceptionHandler      </p>
</li>
<li><p>SharedPreference 在解析xml 的时候，commit 和apply 是不可以调用的，解析完了就会notifyAll            </p>
</li>
<li><p>每次调用edit()方法时，都会创建一个 EditorImpl 对象，所以不要频繁 调用 edit() 方法         </p>
</li>
<li><p>sp 执行 commit 时，首先更新到内存，之后再在当前线程直接写入到xml文件中，所以要注意这里的耗时          </p>
</li>
<li><p>sp的apply方法，首先写到内存，然后交给HandlerThread，即在子线程中，单线程地依次提交到xml文件中           </p>
</li>
<li><p>sp  不要跨进程使用sp(会有缓存，不可靠)、不要存储超大的key或者value，因为加载xml一直会等待，然后后来会放在内存中，占用内存、不要存储JSOn等特殊字符很多的value，会触发转义、不要多次执行 edit，不要多次apply(在api 11 之前，activity 退出时，要等待apply的那些 Runnable 执行完成才能退出，如果时间过长，就导致ANR 了)         </p>
</li>
<li><p>常见内存泄露：资源性资源未关闭(buffer/cursor)、非静态内部类的静态变量、Context泄露、非静态Handler泄露、注册的对象未反注册、匿名内部类和异步的线程(线程与外部类的生命周期不一致)                 </p>
</li>
<li><p>LeakCanary原理：registerActivityLifecycleCallbacks 监听生命周期、弱引用查看对象是否存在         </p>
</li>
<li><p>apk安装过程：安装源、复制apk到/data/data 、解析apk(签名、四大组件注册)、dexopt、更新权限信息(更新到pms)，判断是否允许这些权限、安装完成，发送广播           </p>
</li>
<li><p>Android 资源替换原理：替换 AssertManager                </p>
</li>
<li><p>热修复原理：DexClassLoder 可以从外部加载 classes.dex，插件化也是利用 DexClassLoder                </p>
</li>
<li><p>新特性：5.0-材料设计，ART、6.0-动态权限，Dozen模式、7.0-JIT和ART 交叉编译 、8.0-notification、画中画、9.0-刘海屏支持、Q、文件权限，uri，深色主题、折叠设备                 </p>
</li>
<li><p>Handler 有三种Message，同步消息、异步消息(Message 中 setAsynchronous(true) 了)、消息屏障消息                   </p>
</li>
<li><p>消息屏障，MessageQueue.postSyncBarrier 可以发送消息屏障，不过这是私有方法，需要反射(新的api貌似提供了puglic的的调用了)。其实就与普通的post一样，只是它的Message的target 为空，没有handler引用。当处理到这个屏障时，会一直查找是否有异步消息，先处理异步消息，这个过程持续到手动移除消息屏障为止(MessageQueue.removeSyncBarrier)             </p>
</li>
<li><p>IdleHandler ：在没有Messager 需要处理的时候，就调用IdleHandler 来处理了                       </p>
</li>
<li><p>BlockCanary 原理：在主线程loop中，在处理msg 之前，会调用Printer类型的mLogging 来打印一下，然后处理完了也打印一下，所以通过设置我们自定义的Printer就能监听到处理msg的耗时                   </p>
</li>
<li><p>图片巨大，可以使用 BitmapRegionDecoder 来每次加载一部分          </p>
</li>
<li><p>Android 16ms 时间是包括 layout、measure、、和draw 三个部分的，cpu执行计算任务将ui计算成多边图形，在交给gpu栅格化，最后gpu绘制到屏幕上                       </p>
</li>
<li><p>避免丢帧：避免cpu任务过重，减少layout，measure，onDraw 工作量、避免GPU 任务过重，避免无谓的invalidate、减少过度绘制            </p>
</li>
<li><p>像素密度：以160dpi 作为密度基准的，1dp = 1px            </p>
</li>
<li><p>无响应：input： 5s、service：前台20s，后台200s、广播：前台：10s，后台：60s、provider：10s、Activity 退出时等待 sp 的写入完成                 </p>
</li>
<li><p>哪些产生ANR： 理论上执行业务时，handler post 这个anr msg之后的任何步骤都可能ANR，因为执行完成之后才会remove 这个 anr 的 msg                    </p>
</li>
<li><p>为什么用Binder：安全、性能、c/s架构容易管理                </p>
</li>
<li><p>动画：帧动画、补间动画、属性动画                </p>
</li>
<li><p>签名：v1和v2                     </p>
</li>
<li><p>TouchDelegate 用来扩大点击区域，如果要设置多个，就建立TouchDelegate 的 list，在onTouchEvent 的时候遍历执行               </p>
</li>
<li><p>bitmap内存优化，2.3.3及以下，记得recycle，3.0及以上，可以使用 imBitmap 字段，复用bitmap 内存(当bitmap从Lrucache删除时，其软引用会放在HashSet中，之后通过inBitmap 复用)                </p>
</li>
</ul>
<h3 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h3><h3 id="基本查找"><a href="#基本查找" class="headerlink" title="基本查找"></a>基本查找</h3><h3 id="基本排序"><a href="#基本排序" class="headerlink" title="基本排序"></a>基本排序</h3><p>插入排序：O(n^2)复杂度，稳定的排序<br>选择排序： 复杂度总是 O(n^2)，每次挑最大最小的，因此不稳定                    </p>
<p>shell 排序： 最差的时候：O(n^2)   平均复杂度 ： nlogn，不稳定<br>冒泡：有序的情况，一趟完成，OO(n)，平均复杂度O(n^2)，稳定的排序<br>快排序： 分治思想，平均 nlogn ，最坏 O(n^2)，交换数据啊，不稳定<br>堆排序：最坏最好和平均都是   nlogn  ，不稳定<br>归并排序： 分治思想，时间复杂度  nlogn ，稳定，主要用于外部排序</p>
<p>归并和快排的平均时间复杂度差不多，但是比快排最差情况要好。但是归并使用的空间比较多，因此一般情况下选择快排               </p>
<p>不稳定的排序：希尔、堆、快排</p>
</details>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：垃圾收集器与内存分配策略</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-03 21:10:00" itemprop="dateCreated datePublished" datetime="2019-04-03T21:10:00+08:00">2019-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:49:12" itemprop="dateModified" datetime="2019-11-17T21:49:12+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。客观地说，引用计数法的实现简单，但它很难解决对象之间相互循环引用的问题，所以，主流实现中，并不使用这种方式。</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>在主流实现中，都是通过可达性分析来判定对象是否存活。这个算法的基本思路就是通过<strong>一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到GC Roots 没有任何引用链相连时，则证明此对象是不可用的</strong>。在Java语言中，可以作为 GC Roots 的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。  </li>
<li>本地方法栈中JNI引用的对象。  </li>
<li>方法区中类静态属性引用的对象。  </li>
<li>方法区中常量引用的对象。  </li>
</ul>
<h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>JDK 1.2 以前，对象只有引用和被引用两种状态，未能描述那些“食之无味，弃之可惜”的对象，我们希望描述这样一类对象：当内存还足够时，则能保留在内存之中；如果内存空间在GC后还是非常紧张，则可以抛弃这些对象。因此，JDK 1.2以后对引用的概念进行扩充，分为：</p>
<ul>
<li><p>强引用。代码中普遍存在的，类似于 Object obj = new Object() ，只要强引用还在，垃圾收集器永远不会回收被引用的对象。</p>
</li>
<li><p>软引用。是用来描述一些还有用，但是并非必需的对象，在系统将要发生内存溢出的异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
</li>
<li><p>弱引用。是用来描述非必需对象的，但是强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次GC发生之前。当GC工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>
</li>
<li><p>虚引用。是最弱的一种引用关系，不会对对象的生存时间构成影响，也无法通过虚引用获得对象实例。为对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p>
</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使在可达性分析算法中不可达的对象，也并非“非死不可”的。要真正宣告一个对象的死亡，至少要经历两次标记过程：如果对象在可达性分析后发现没有与GC Roots 相连接的引用链，那么它会被第一次标记，并进行筛选，筛选的条件是此对象是否有必要执行 finalize() 方法，当对象没有覆写 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则都没有必要执行；</p>
<p>如果对象判定有必要执行 finalize() 方法，则对象会被放入F-Queue队列中，稍后由低优先级的线程去触发 执行finalize() 方法，但不会承诺等待它运行结束。这样做的原因是防止 finalize 方法过于缓慢或者死循环。finalize() 方法是对象套多死亡命运的最后一次机会，因为稍后GC将对F-Queue中的对象进行第二次标记，如果对象要在finalize 中拯救自己————只要重新与某个引用链上的任意一个对象关联即可，那么在第二次标记的时候它将被移除出“即将回收”的集合；如果这时候对象还没逃脱，那它就会真的被回收了。</p>
<p>说明这一过程的示例代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span></span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"yes,i am still alive"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> finalize（） <span class="keyword">throws</span> Throwable{</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed"</span>);</span><br><span class="line">        FinalizeEscapeGc. SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>{</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为finalize方法优先级很低，所以暂停0.5秒等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>){</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            System.out.println(<span class="string">"no,i am dead"</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为finalize方法优先级很低，所以暂停0.5秒等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>){</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            System.out.println(<span class="string">"no,i am dead"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<blockquote>
<p>finalize method executed<br>yes,i am still alive<br>no,i am dead  </p>
</blockquote>
<p>从结果可以看出，SAVE_HOOK 对象的 finalize 方法确实被GC收集器触发过，并且收集前成功逃脱。但两段完全一样的代码，第二次却被回收了，因为finalize 方法只会被自动调用一次，因此第二次不执行了，所以自救失败。</p>
<p>有些教材上认为 finalize 中适合做“关闭外部资源”之类的工作，在了解以上机制之后，可以认为这完全是一种自我安慰，finalize 能做的，try-finally 或其他方法能做得更好，更及时，所以完全可以忘记这个方法存在（它也仅仅只是Java诞生时讨好C/C++程序员的一个妥协）。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>最基础的收集算法是 标记-清除(Mark-Sweep) 算法，它分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，在标记完成后统一回收被标记的对象。它的主要不足有两个：一是效率问题，标记和清除效率都不高；二是清除后会产生大量不连续的内存碎片。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，复制算法出现了。它将可用内存分为大小相等的两块，每次只使用其中一块，当这块内存用完了，就将还存活的对象复制到另一块上，然后把当前内存空间一次清理掉。这样每次都是对整个半区回收，内存分配也不会存在碎片。缺点是可用内存缩小了一半，代价太高。</p>
<blockquote>
<p>现在商业虚拟机采用这种方式回收新生代。一般将内存分为较大的 Eden 和两块较小的 Survivor 空间（HotSpot中 Eden 与 Survivor大小比例为 8：1），每次使用Eden 和其中一块 Survivor，当内存回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor，最后清理Eden和刚才用过的Survivor空间，因此，每次只有10%的内存“被浪费”。当然这是基于统计新生代的对象生命周期都很短，差不多只有10%的对象会存活，此外，如果超出10%的存活对象，Survivor空间不够时，需要依赖老年代的空间提供担保（Survivor空间存不下的对象直接通过担保机制进入老年代），这是该分配方式能够运行下去的保障。</p>
</blockquote>
<p>复制收集算法在对象存活率较高时要进行较多的复制操作，效率将会变低，更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行担保，防止对象100%存活的极端情况。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>根据老年代特点，有人提出另外一种<strong>标记-整理(Mark-Compact)算法</strong>，标记过程仍与“标记-清除”算法一样，但后续不是直接清理可回收对象，而是所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。标记整理算法的示意图如下：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%89%88/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记-整理算法"></p>
<p>关于怎么个移动法，书上没有说明，这里个人做个推测：</p>
<blockquote>
<p>1、整个老年代的内存划分为 A 和 B 两个区域，区域 A 的大小是所有还存活对象的总大小，区域 B 大小是是剩余空间。<br>2、按顺序在 A 中找到第一个还存活对象，将它移动到 A 空间的最前端，接下来找第二个还存活的对象，将其移动到第一个对象的后面<br>3、以此类推，即使存活的对象在 B 中也一样顺序复制到A中，直至最后填满A空间，之后清除 B 空间。</p>
</blockquote>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>商业虚拟机都采用“分代收集”，根据各个年代的特点分别采用适当的收集算法：</p>
<ul>
<li>在新生代中，每次垃圾收集时都会发现有大批对象死去，只有少量存活（前面提到的统计数据，大部分时候只有 10% 存活），那就选用复制算法。  </li>
<li>而老年代中因对象存活率高，没有额外空间对它进行担保，就必须使用“标记-清理”或者“标记-整理”算法进行回收。</li>
</ul>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>这是自己添加的这个标题，书中的结构并不是如此，因为 Android ART 虚拟机使用的也是CMS收集方式，所以这里特意抽出来理解，方便理解Android的虚拟机。 CMS (Concurrent Mark Sweep) 收集器，并发的“标记-清除”方式实现的收集器。它是一种以获取最短回收停顿时间为目标的收集器。它的整个过程分为4个步骤：</p>
<ul>
<li>初始标记  </li>
<li>并发标记  </li>
<li>重新标记  </li>
<li>并发清除  </li>
</ul>
<p>其中，初始标记、重新标记 这两个步骤仍然需要“Stop The World”，初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快；并发标记就是进行 GC Roots Tracing 的过程（根据初始标记过程中标识出来的直接关联对象，并发标记存活的对象）；重新标记阶段则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录；</p>
<p>由于整个过程中好事最长的 <strong>并发标记 和 并发清除</strong> 过程收集器线程都可以与用户线程一起工作，所以，从总体上来讲，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>CMS 是优秀的收集器，但是它也有3个明显的缺点：</p>
<ul>
<li><p>CMS 收集器对 CPU 资源非常敏感。与其他并发设计的程序一样，CMS收集器对 CPU 同样敏感，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用变慢。 </p>
</li>
<li><p>CMS 无法处理浮动垃圾(Floating Garbage,个人认为简而言之就是GC过程中用户线程产生的垃圾，类比于你妈妈在打扫房间卫生的时候，你还在继续撕的纸)。  </p>
</li>
<li><p>还有最后一个缺点，就是CMS本质还是“标记-清除”算法实现的，这种收集方式在结束后会产生大量的碎片化的空间。</p>
</li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>以下是几条最普遍的内存分配规则，可以通过代码去验证这些规则：</p>
<h3 id="对象优先在-Eden-上分配"><a href="#对象优先在-Eden-上分配" class="headerlink" title="对象优先在 Eden 上分配"></a>对象优先在 Eden 上分配</h3><p>大多数情况下，对象在新生代 Eden 区中分配，当 Eden 区没有足够空间时，虚拟机将发起一次 Minor GC （新生代GC）。可以采用以下方式验证：</p>
<p>通过 -Xms20M、-Xmx20M、-Xmn10M 三个参数限制Java 虚拟机堆大小 20MB，不可扩展，并且其中 10M 分配给新生代，剩下的 10MB 分配给老年代，-XX:SurvivorRatio=8决定新生代中 Edun 区与 一个 Survivor区的比例是 8：1，即 Eden 大小 8192K，两个 survivor 空间分别 1024K，所以新生代总共可用空间是 9216K （Eden 区 + 1个Survivor区）。<br>执行 testAllocation()尝试分配 3个 2M 的大小和1个 4MB 大小的对象。<br>代码执行完成后，可以发现 新生代Eden区被占用了 4M，而老年代被占用了 6M。<br>解释：分配前3个对象时，没有压力，均分配在Eden区域，当分配第4个对象时，内存已经不够了（可用空间是 9216K，而 2M*3 + 4M = 10），因此触发一次Minor GC，此时发现这3个对象都存活，并且 survivor 区间不够容纳存活的对象，因此这3个对象被直接通过担保机制提前转移到老年代中；这次GC结束后，第4个对象就可以顺利分配到Eden空间中。</p>
<blockquote>
<p>新生代GC(Minor GC):发生在新生代的垃圾收集，因为Java对象大多朝生夕死，所以Minor GC非常频繁，一般回收速度也比较快<br>老年代GC(Major GC/Full GC)：指的是老年代的GC，对于许多收集器而言，这时候都会伴随至少一次的 Minor GC，老年代的GC一般会比 Minor GC 慢10倍以上。</p>
</blockquote>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓大对象是指需要大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组。当然，比大对象更糟糕的是遇到一群朝生夕死的“短命大对象”，这种应当避免。经常出现大对象容易导致内存还有不少空间就提前触发垃圾收集器以获得足够的<strong>连续空间</strong>来安置它们。</p>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>如果对象在Eden出生并经历过第一次Minor GC 后仍然存活并且能被 Survivor 容纳的话，将被移动到Survivor 中，并且年龄设置为 1，此后，每熬过一次 Minor GC ，对象的年龄就加1，当达到某个阈值（系统一般默认 15），就会被晋升到老年代中。</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>为了更好地适应不同程序内存状况，并不总是要求对象必须达到某个年龄才进入老年代。如果 Survivor 中同龄对象达到某个阈值（一般是一半）时，大于或者等于这个年龄的对象就会移动到老年代。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>发生Minor GC 前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，则 Minor GC 可以确保是安全的，如果不成立，则会判断是否允许担保失败，如果允许担保失败，则最终可能会触发一次Full GC。虽然绕了一圈还是有可能触发 Full GC，但是这种情况相对较少。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/04/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：Java内存区域与内存溢出异常</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-02 21:10:00" itemprop="dateCreated datePublished" datetime="2019-04-02T21:10:00+08:00">2019-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:49:05" itemprop="dateModified" datetime="2019-11-17T21:49:05+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>根据《Java虚拟机规范(java SE 7)》规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%89%88/java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="Java运行时数据区域"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器可以看做是当前线程执行的字节码的行号指示器，它是线程私有的。在虚拟机概念模型里（具体虚拟机可能有更高效实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖程序计数器来完成。如果线程在执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行Native方法，这个计数器值为Undefined。<strong>此内存区域是Java虚拟机规范中唯一一个没有规定任何 OutOfMemoryError情况的区域</strong>。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>Java虚拟机栈也是线程私有的。它描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，一个方法从调用至完成，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。<strong>这个区域被规定了两种异常状况：如果线程请求的栈深度大于虚拟机允许的深度，就抛出 StackOverflowError异常；如果该区域可以动态扩展，则在扩展时无法申请到足够内存，就会抛出OutOfMemoryError异常</strong>。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈类似，区别只不过是虚拟机栈为执行Java方法(即字节码)服务，而本地方法栈为Native方法服务，同样，<strong>本地方法栈也可能抛出StackOverflowError异常以及OutOfMemoryError异常</strong>.</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆是被所有线程共享的一块内存，虚拟机启动时创建。虚拟机规范描述是，所有对象的实例以及数组都要在堆上分配(当然，不同虚拟机实现不同)。<strong>如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常</strong>。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>与Java堆一样，方法区也是各个线程共享的内存区域。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<strong>当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常</strong>。</p>
<blockquote>
<p>提到方法区，不得不提<strong>运行时常量池</strong>，它是方法区的一个部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是信息常量池，用于存放编译期生成的各种字面量和符号引用（一般来说，翻译出来的直接引用也会存储在运行时常量池中）。</p>
</blockquote>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存(Direct Memory)不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在Java 1.4中新加入了NIO（New Input/Output）类，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectBuffer对象作为这块内存额引用进行操作，这样能在一些场景中显著提高性能，因为它避免在 Java 堆和 Native 堆中来回复制数据。<strong>当然，该区域空间在动态扩展时也可能出现OutOfMemoryError异常</strong>。</p>
<h2 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>虚拟机遇到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，则必须限制性相应的类加载过程。类加载完成后，便可完全确定对象所需的内存大小，接下来为新生的对象真正分配内存。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)、和对齐填充(Padding)。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的refrence数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针，其中前者通过句柄池间接指向堆中的对象，后者直接指向堆中的对象。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="OutOfMemoryError异常"><a href="#OutOfMemoryError异常" class="headerlink" title="OutOfMemoryError异常"></a>OutOfMemoryError异常</h3><p>Java虚拟机规范中，除了程序计数器之外，其他区域都可能发生 OutOfMemoryError异常。</p>
<h3 id="JAVA堆溢出"><a href="#JAVA堆溢出" class="headerlink" title="JAVA堆溢出"></a>JAVA堆溢出</h3><p>Java堆用于存储实例对象，只要不断地创建对象，并且保证GC root 到对象之间有可达路径来避免垃圾回收，那么就能产生OutOfMemoryError异常。</p>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>虚拟机栈和本地方法栈理论上分配不到足够的内存同样会报 OutOfMemoryError异常，但是一般情况下，首先会出现StackOverflowError，OutOfMemoryError很难出现。</p>
<h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><p>由于运行时常量池是方法区的一个部分，因此这两个区域的溢出测试放在一起进行。在此之前我们先了解下String.intern()方法：</p>
<blockquote>
<p>String.intern()是一个Native方法，它的作用是，如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并返回此String对象的引用。</p>
</blockquote>
<p>在JDK1.6及以前，通过设置永久代区域的大小可以间接限制方法区大小，但是从JDK 1.7以后就“去永久代”了，因此以下代码只在JDK 1.6 ，并且设置了 MaxPermSize 时有效：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">    <span class="comment">//使用List保持常量池的引用，避免full gc 回收常量池</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line">        list.add(String.valueOf(i++).intern());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同样的原因，还可以引申一个更有意思的影响，如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">    String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append（“软件”）.toString();</span><br><span class="line">    Systemt.out.println(str1.intern() == str1);</span><br><span class="line">    </span><br><span class="line">    String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">    Systemt.out.println(str2.intern() == str2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码在JDK 1.6 中运行，会得到两个false（intern 方法会把首次遇到的字符串实例复制到永久代中，而StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用）；而在JDK 1.7 中会得到一个true（intern 实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此，intern返回的引用和由StringBuilder创建的字符串实例是同一个实例）一个false（“java”字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现，而“计算机软件”这个字符串则是首次出现的—这个解释没看懂，需要再次理解）。</p>
<h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>直接或者间接地使用NIO，就可能出现本机直接内存溢出。虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但是抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配。因此可以通过以下代码手动抛出异常，真正抛出异常的地方是unsafe.allocateMemory()。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码能够抛出异常的前提是，设置虚拟机参数 -XX: MaxDirectMemorySize 的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">	Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">	unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">		unsafe.allocateMemory(_1MB);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">111</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共261.3k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.gitee.io/page/8/',]
      });
      });
  </script>


</body>
</html>
