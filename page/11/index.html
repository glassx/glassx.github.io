<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/11/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">161</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/23/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/23/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">面试题-设计模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-23 21:40:00" itemprop="dateCreated datePublished" datetime="2019-11-23T21:40:00+08:00">2019-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-14 16:28:00" itemprop="dateModified" datetime="2021-03-14T16:28:00+08:00">2021-03-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1、mvc、mvp、mvvm"><a href="#1、mvc、mvp、mvvm" class="headerlink" title="1、mvc、mvp、mvvm"></a>1、mvc、mvp、mvvm</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="mvc"><a href="#mvc" class="headerlink" title="mvc"></a>mvc</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvc.png" alt="mvc示意图"></p>
<p><strong>特征：</strong></p>
<ul>
<li>view 接收用户的输入，并且可以通知Controller 更改Model 层数据，如果没有涉及逻辑，还可以直接通知Model 更改数据。    </li>
<li>需要ui变化，但是没有涉及业务数据，直接调用controller 即可(比如用户选择使用用户名/手机号登录)    </li>
<li>model 数据变化时，若需要修改ui，需要通过Controller 来通知更新。</li>
</ul>
<p><strong>在Android中存在问题：</strong></p>
<ul>
<li>Activity 的职责不明，并且臃肿。Activity 除了要展示view (加载view，接收用户操作)，还要承担部分逻辑处理(比如生命周期回调)    </li>
</ul>
<h3 id="mvp"><a href="#mvp" class="headerlink" title="mvp"></a>mvp</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvp.png" alt="mvp示意图"></p>
<p><strong>特点</strong>:</p>
<ul>
<li>View 层接收输入</li>
<li>Presenter 处理业务逻辑，View 与 Model 之间必须经过 Presenter</li>
</ul>
<p><strong>优点(相对MVC)：</strong></p>
<ul>
<li>避免了View、Model 直接联系，更加解耦，通过Presenter 实现两者之间的沟通    </li>
<li>Activity 更加简明，仅仅负责UI上的工作    </li>
</ul>
<h3 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvvm.png" alt="mvvm示意图"></p>
<p>可能主要关注view 通过databinding 与 viewmodel 相互绑定。</p>
<h3 id="mvc-与-mvp-的区别"><a href="#mvc-与-mvp-的区别" class="headerlink" title="mvc 与 mvp 的区别"></a>mvc 与 mvp 的区别</h3><ul>
<li>在mvc 中 Activity 具有 view 的功能，并且兼任部分 controller 功能，而mvp 中Activity 是纯粹的view    </li>
<li>mvc 中view 和model 可以直接沟通(没有逻辑情况下，view直接更改model，当然，有逻辑改动的情况下经过controller)，而mvp中二者沟通必须经过presenter。    </li>
</ul>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/100070713">carson_ho的博客</a></p>
</blockquote>
<h3 id="2、实现一个线程安全的单例模式"><a href="#2、实现一个线程安全的单例模式" class="headerlink" title="2、实现一个线程安全的单例模式"></a>2、实现一个线程安全的单例模式</h3><h3 id="3、观察者模式和回调有什么区别？"><a href="#3、观察者模式和回调有什么区别？" class="headerlink" title="3、观察者模式和回调有什么区别？"></a>3、观察者模式和回调有什么区别？</h3></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/23/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC11%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/23/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC11%E7%AB%A0/" class="post-title-link" itemprop="url">第11章：Dalvik 和 ART</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-23 10:30:00 / 修改时间：11:00:25" itemprop="dateCreated datePublished" datetime="2019-11-23T10:30:00+08:00">2019-11-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Dalvik虚拟机"><a href="#Dalvik虚拟机" class="headerlink" title="Dalvik虚拟机"></a>Dalvik虚拟机</h2><p>Dalvik虚拟机 简称 DVM，第10章提到，它不是一个 jvm，主要原因是它没有遵循jvm规范实现，二者的主要区别有：</p>
<ul>
<li>基于的架构不同</li>
</ul>
<blockquote>
<p>JVM 基于栈，DVM 基于寄存器。基于栈意味着需要去栈中读写数据，所需要的指令更多，并且速度更慢，对于性能优先的移动设备，显然是不合适的。</p>
</blockquote>
<ul>
<li>执行的字节码不同</li>
</ul>
<blockquote>
<p>在Java SE 程序中，Java 类被编译成一个或者多个.class 文件，并被打包成 jar 文件，之后JVM 会通过相应的 .class 和 jar 文件获取相应的字节码；而DVM 会用dx工具将所有的 .class 文件转换为一个 .dex 文件，然后DVM 从该 .dex 文件中读取指令和数据。<br>.jar文件里面包含多个.class 文件，每个.class文件包含了该类的常量池、类信息、属性等，当JVM 加载.jar文件的时候，会加载里面所有的.class文件，JVM 这种加载方式很慢(首先就是很多io操作)，对于内存有限的移动设备并不合适；而.dex文件将所有的.class里面所包含的信息全部整合到一块了，这样再加载就减少了I/O操作，加快查找速度；并且，相对Android而言，.class中有许多冗余信息，dex工具会去掉冗余信息。</p>
</blockquote>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC11%E7%AB%A0/dalvik%E4%B8%8Ejvm%E6%89%A7%E8%A1%8C%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="DVM与JVM执行的字节码不同"></p>
<ul>
<li>DVM 允许在有限的内存中同时运行多个进程</li>
</ul>
<blockquote>
<p>在Android中，每个应用都运行在一个DVM中，每个DVM 实例都运行在一个独立的进程中，这样，某一个虚拟机崩溃的时候不会导致其他app也关闭。</p>
</blockquote>
<ul>
<li>DVM 由Zygote创建和初始化</li>
</ul>
<blockquote>
<p>在第2章有介绍<strong>Zygote，它是一个DVM进程</strong>，当系统需要创建一个应用程序时，Zygote就会fork自身，快速地创建和初始化一个DVM实例。对于一些只读的库，所有的DVM实例都会和Zygote共享一块内存区域，节省内存开销。</p>
</blockquote>
<ul>
<li>DVM 有共享机制</li>
</ul>
<blockquote>
<p>DVM 的共享机制可以使<strong>不同应用之间在运行时可以共享相同的类</strong>，这带来更高的效率；而JVM不具有这种机制，不同的程序，打包以后的程序都是彼此独立的，即便它们在包里使用了同样的类，运行时也是单独加载和运行的。</p>
</blockquote>
<h3 id="DVM-运行时堆"><a href="#DVM-运行时堆" class="headerlink" title="DVM 运行时堆"></a>DVM 运行时堆</h3><p>DVM运行时堆使用标记-清除算法进行GC，它由两个Space以及多个辅助数据结构组成，两个Space分别是：Zygote Space(Zygote Heap) 和 Allocation Space(Active Heap)，前者用于管理Zygote进程在启动过程中预加载和创建的对象，并且Zygote Space不会触发GC，Zygote 进程和应用进程之间会共享Zygote Space。在Zygote 进程fork第一个子进程前，会把Zygote Space 分为两部分，原来已经被使用的部分对仍旧叫做Zygote Space，而未使用的那部分堆叫做 Allocation Space ，以后的对象都会在 Allocation Space上进行分配和释放。</p>
<h2 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h2><p>Android 4.4 的时候发布了ART虚拟机，但是4.4版本默认还是使用DVM，Android 5.0 及以后版本默认采用ART，从此，DVM退出历史舞台。</p>
<h3 id="ART-与-Dalvik-区别"><a href="#ART-与-Dalvik-区别" class="headerlink" title="ART 与 Dalvik 区别"></a>ART 与 Dalvik 区别</h3><p>ART 与 Dalvik 的区别主要有4点：</p>
<ul>
<li>DVM 是为32位CPU涉及的，而ART支持64位并且兼容32位 CPU。    </li>
<li>ART 对垃圾回收机制进行了改进，将 GC 暂停由2次减少为1次，并且频繁执行并行垃圾收集。    </li>
<li>ART 的运行时堆空间划分和DVM不同。    </li>
<li>DVM中应用每次运行时，字节码通过 JIT 编译器编译为机器码，使得应用程序运行效率低下；而在ART中，系统在安装应用程序时会进行一次AOT(ahead of time compilation,预编译)，将字节码预先编译成机器码并存储在本地，这样应用程序每次运行时就不需要执行编译了。</li>
</ul>
<blockquote>
<p>ART也有两个主要缺点：一是AOT使应用安装时间变长，二是预编译的机器码占用的存储空间比较大。为了解决上面的缺点，Android 7.0 版本在ART中加入了JIT编译器，作为AOT的补充：在安装应用时不会将字节码全部编译成机器码，而是在运行中将热点代码编译器机器码，以达到缩短应用安装时间并节省存储空间。</p>
</blockquote>
<p>更详细的内容，可以参考<a target="_blank" rel="noopener" href="https://source.android.google.cn/devices/tech/dalvik/gc-debug">官网上的描述</a></p>
<h3 id="ART-运行时堆"><a href="#ART-运行时堆" class="headerlink" title="ART 运行时堆"></a>ART 运行时堆</h3><p>与DVM 的GC不同的是，ART采用多种垃圾收集方案，每个方案会运行不同的垃圾收集器，默认是采用 CMS(Concurrent Mark-Sweep)方案，主要有sticky-CMS 和 partial-CMS，不同的CMS方案，ART运行时堆得空间划分也不同，默认由4个Space和多个辅助结构组成，采用标记-清除算法时，两种虚拟机运行时堆对比图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC11%E7%AB%A0/dalvik%E4%B8%8Eart%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4.png" alt="两种虚拟机运行时堆对比"></p>
<p>由图可以看到ART的4个Space，其中，Zygote Space 、Allocation Space 和 DVM 中的作用一样，ImageSpace 用来存放一些预加载类，Large Object Space 用来分配一些大对象。其中Zygote Space 与 Image Space 是进程共享的。</p>
<h3 id="ART-的GC-日志"><a href="#ART-的GC-日志" class="headerlink" title="ART 的GC 日志"></a>ART 的GC 日志</h3><ol>
<li>GC Reason<br>ART 虚拟机GC日志中会包含产生这次GC原因，主要会有：</li>
</ol>
<ul>
<li>Concurrent: 并发GC，在后台线程运行GC，不会使App的线程暂停，不会阻止内存分配。    </li>
<li>Alloc： 当堆内存已满，App尝试分配内存而引起的GC，<strong>这个GC发生在正在分配内存的线程中。</strong>    </li>
<li>Explicit： App显式请求垃圾收集，比如 System.gc()。    </li>
<li>NativeAlloc： Native 内存分配时触发的GC。    </li>
</ul>
<ol start="2">
<li>垃圾收集器名称<br>ART 虚拟机GC日志中会包含所使用的收集器名称，主要会有：</li>
</ol>
<ul>
<li>Concurrent Mark Sweep(CMS)： 它是以最短收集暂停时间为目标的收集器，采用标记-清除算法，<strong>能释放除了Image Space外的所有空间</strong>    </li>
<li>Concurrent Partial Mark Sweep： 能释放除了Image Space 和 Zygote space 意外的所有空间    </li>
<li>Concurrent Sticky Mark Sweep： 粘性收集器，<strong>基于分代的垃圾收集思想</strong>，只能释放自上次GC以来分配的对象，这个收集器扫描比较频繁，因为它很快并有很短的暂停时间。    </li>
<li>Marksweep + Semispace：非并发GC，复制GC用于堆转换以及堆碎片整理。    </li>
</ul>
<h2 id="DVM-和-ART-的诞生"><a href="#DVM-和-ART-的诞生" class="headerlink" title="DVM 和 ART 的诞生"></a>DVM 和 ART 的诞生</h2><p>它们是从Zygote进程诞生的，这样，Zygote进程就持有了DVM或者ART的实例，此后，Zygote进程每次fork自身创建新的应用进程时，应用程序进程也就得到了 DVM 或者ART 的实例，即每个应用进程都有一个单独的虚拟机实例。<strong>这样做的好处是，无需在每次启动应用程序进程时都要创建DVM或者ART，从而加快了应用程序进程的启动速度</strong>。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/22/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/22/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：Android系统启动</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-22 15:10:00" itemprop="dateCreated datePublished" datetime="2019-11-22T15:10:00+08:00">2019-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-03 21:22:20" itemprop="dateModified" datetime="2019-12-03T21:22:20+08:00">2019-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="init-进程启动过程"><a href="#init-进程启动过程" class="headerlink" title="init 进程启动过程"></a>init 进程启动过程</h2><p>init进程是Android系统中<strong>用户空间的第一个进程</strong>，进程号为1，它被赋予了很多重要职责，比如创建 Zygote 和属性服务等。</p>
<h3 id="引入init进程"><a href="#引入init进程" class="headerlink" title="引入init进程"></a>引入init进程</h3><p>了解Android系统启动流程的前几步，可以有助于引入init进程：</p>
<ol>
<li>启动电源以及系统启动。当电源按下时，引导芯片代码从预定义的地方(固化在ROM中)开始执行，<strong>加载引导程序到RAM中</strong>，然后执行。    </li>
<li>引导程序BootLoader。它是Android操作系统开始运行前的一个小程序，主要作用是把系统OS拉起来。    </li>
<li>Linux 内核启动。linux内核启动完成系统设置后，<strong>它首先在系统文件中寻找init.rc，并启动init进程。</strong>     </li>
<li>init进程启动。init进程的工作比较多，主要用于初始化、启动属性服务 以及 启动Zygote进程。</li>
</ol>
<h3 id="init进程入口"><a href="#init进程入口" class="headerlink" title="init进程入口"></a>init进程入口</h3><p>在Linux内核加载完成后，首先在系统文件中查找init.rc，并启动init进程。init的main函数中做了很多事情，我们主要了解以下几点：</p>
<ul>
<li>调用property_init 函数对属性初始化，调用 start_property_service函数启动属性服务。    </li>
<li>调用 signal_handler_init <strong>设置子进程信号处理函数，主要用于防止init进程的子进程成为僵尸进程。</strong>为了防止僵尸进程的出现，系统会在子进程暂停和终止的时候发出 SIGCHLD信号，signal_handler_init就是用来接收这个信号的。</li>
</ul>
<blockquote>
<p>僵尸进程：在linux中，父进程使用fork创建子线程，在子线程终止后，如果父进程并不知道子线程终止了，那么还会在系统进程表为它保留一定的信息。僵尸进程主要危害就是占用系统进程表，可能导致系统进程表被耗尽而无法创建新的进程。假设init的子进程Zygote终止了，signal_handler_init 函数会找到Zygote进程并移除所有Zygote进程信息，再重启Zygote。</p>
</blockquote>
<h3 id="解析-init-rc"><a href="#解析-init-rc" class="headerlink" title="解析 init.rc"></a>解析 init.rc</h3><p>init.rc 是一个配置文，是由Android 初始化语言编写的脚本，为了分析如何创建Zygote，我们主要查看其中的Service类型语句，在Android 8.0 及以后，每个Service 都对应一个rc 文件。init.rc 中定义Service 的格式如下：</p>
<blockquote>
<p>service <name> <pathname> [ <argument> ] * //&lt;service 的名字〉〈执行程序路径〉〈传递参数〉</argument></pathname></name></p>
</blockquote>
<p>举个栗子，zygote的Service配置文件就是：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin -- zygote --startsystem- server </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">main</span> </span></span><br><span class="line"><span class="class"><span class="title">priority</span> -20 </span></span><br><span class="line"><span class="class"><span class="title">user</span> <span class="title">root</span> </span></span><br><span class="line"><span class="class"><span class="title">group</span> <span class="title">root</span> <span class="title">readproc</span> </span></span><br></pre></td></tr></tbody></table></figure>

<p>来大概分析代码意思，Service用于通知 init 进程创建名为 zygote 的进程，这个进程执行程序的路径为 /system/bin/app_process64，其中 <font color="#008000">class main</font>指的是Zygote 的classname 为 main。<strong>后面的代码是要传给 app_process64的参数。</strong></p>
<h3 id="解析Service类型语句"><a href="#解析Service类型语句" class="headerlink" title="解析Service类型语句"></a>解析Service类型语句</h3><p>init.rc中Service类型语句使用ServiceParser类来解析，它将init.rc中的service解析生成的Service对象加入到 Service 链表中。</p>
<h3 id="init-启动Zygote"><a href="#init-启动Zygote" class="headerlink" title="init 启动Zygote"></a>init 启动Zygote</h3><p>我们来了解init是如何启动Service的，这里主要讲解 Zygote这个Service。前面提到，在Zygote的启动脚本中描述Zygote的classname为<font color="#008000">main</font>，在init.rc中会遍历 解析Service类型语句 过程生成的Service链表，找到 classname 为main的Zygote，如果Zygote Service 已经运行，则不再启动，否则就调用fork函数创建子进程，并在子进程中调用Service的main函数，Zygote的main函数代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main （<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv []) </span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (zygote) { </span><br><span class="line">        runtime.start （<span class="string">"com.android.internal.os.Zygoteinit”， args, zygote) ; //1</span></span><br><span class="line"><span class="string">    } else if (className) { </span></span><br><span class="line"><span class="string">        runtime .start （” com android nternal.os.Runtimeinit ”， args zygote) ; </span></span><br><span class="line"><span class="string">    } else{</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></tbody></table></figure>

<p>从注释1处可以看到调用runtime的start函数启动了 Zygote 。</p>
<h3 id="属性服务"><a href="#属性服务" class="headerlink" title="属性服务"></a>属性服务</h3><p>Windows上有注册表管理器以键值对的形式记录用户软件的一些使用信息，即使系统或者软件重启，其还是能够根据之前注册表中的记录进行相应初始化工作。Android中也提供了类似机制，叫做<strong>属性服务</strong>。init 进程启动时会启动属性服务，并为其分配内存存储这些属性，如果需要这些属性直接读取即可。启动属性服务的主要代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">property_set_fd =create_socket(PROP_SERVICE_NAME ,SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,<span class="number">0666</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>); <span class="comment">//1</span></span><br><span class="line">...</span><br><span class="line">listen(property_set_fd, <span class="number">8</span>); <span class="comment">//2  </span></span><br><span class="line">register_epoll_handler(property_set_fd , handle_property_set_fd) ; <span class="comment">//3 </span></span><br></pre></td></tr></tbody></table></figure>

<p>由代码可知，首先创建非阻塞的Socket，并对property_set_fd 监听，这样创建的Socket 就成为server，也就是属性服务；listener的参数意味着可以同时为8个试图设置属性的用户服务。最后使用epoll 来监听property_set_fd ：<strong>当property_set_fd中有数据到来时，init进程将调用handle_property_set_fd函数处理。</strong></p>
<blockquote>
<p>epoll是linux下多路复用I/O接口，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU的利用率。</p>
</blockquote>
<p>对属性进行修改时，首先判断属性的合法性，之后查找属性，如果属性存在就更新属性值，否则添加属性。</p>
<h3 id="init进程启动总结"><a href="#init进程启动总结" class="headerlink" title="init进程启动总结"></a>init进程启动总结</h3><p>主要做了3件事：1、创建和挂载启动所需文件目录  2、启动服务属性  3、解析init.rc ，并启动 Zygote 进程。</p>
<h2 id="Zygote进程启动过程"><a href="#Zygote进程启动过程" class="headerlink" title="Zygote进程启动过程"></a>Zygote进程启动过程</h2><p>在Android系统中，DVM(或者ART)、应用程序进程、SystemServer进程等都是由Zygote进程创建的。由于Zygote在启动时会创建 DVM(或者ART)，因此其fork的应用程序进程和SystemServer进程可以在内部获取一个 DVM 或者 ART。</p>
<p>在Zygote 中通过 JNI 调用 ZygoteInit(<font color="#008000">ZygoteInit是由Java编写的</font>)的 main 方法后，Zygote 便进入了Java 框架层，<strong>此前没有任何代码进入Java框架层的。</strong>即Zygote开创了Java框架层。</p>
<p>ZygoteInit的main方法中主要代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/com/android/internal/os/Zygotelnit.java </span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//创建一个 Server 端的 Socket socketName 的值为"zygote"</span></span><br><span class="line">zygoteServer.registerServerSocket(socketName);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//预加载类和资源</span></span><br><span class="line">preload(b otT U.ngsTraceLog);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (startSystemServer) { </span><br><span class="line">    <span class="comment">//启动 SystemServer 进程</span></span><br><span class="line">    startSystermServer(abiList, socketName, zygoteServer);</span><br><span class="line">}</span><br><span class="line">／／等待 AMS 请求</span><br><span class="line">zygoteServer.runSelectLoop(abiList);</span><br></pre></td></tr></tbody></table></figure>

<p>由代码可知，通过 registerServerSocket 方法创建一个Server端的Socket ，<strong><font color="#008000">这个名为 “zygote” 的Socket 用于等待 ActivityManagerService 请求 Zygote 来创建新的应用程序进程</font></strong>。总结一下，ZygoteInit 的main方法总共做了4件事：</p>
<ol>
<li>创建一个Server端的Socket    </li>
<li>预加载类和资源    </li>
<li>启动 SystemServer 进程    </li>
<li>等待 AMS 请求创建新的应用程序进程    </li>
</ol>
<h3 id="Zygote-进程启动总结"><a href="#Zygote-进程启动总结" class="headerlink" title="Zygote 进程启动总结"></a>Zygote 进程启动总结</h3><p>Zygote进程启动共做了以下几件事：</p>
<ol>
<li>创建AppRuntime ，并调用其start方法，启动Zygote 进程    </li>
<li>创建java虚拟机并未Java虚拟机注册 JNI 方法    </li>
<li>通过 JNI 调用ZygoteInit 的main函数进入Zygote 的Java 框架层    </li>
<li>通过 registerServerSocket 创建服务端 Socket ，循环等待AMS 请求来创建新的应用程序进程。    </li>
<li>启动 SystemServer    </li>
</ol>
<h2 id="SystemServer-处理过程"><a href="#SystemServer-处理过程" class="headerlink" title="SystemServer 处理过程"></a>SystemServer 处理过程</h2><p>SystemServer 进程主要用于创建系统服务，如 AMS、WMS、PMS 。在 ZygoteInit.java 中启动了 SystemServer，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span> <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException｛</span></span><br><span class="line"><span class="function">    <span class="comment">//当前运行在 SystemServer 进程中</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(p == <span class="number">0</span>)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) {</span><br><span class="line">            waitForSecondaryZygote (socketName ); </span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//关闭 Zygote 进程创建的 Socket</span></span><br><span class="line">        zygoteServer . closeServerSocket() ; <span class="comment">//1 </span></span><br><span class="line">        handleSystemServerProcess(parsedArgs) ; <span class="comment">//2 </span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>由以上代码可知，SystemServer 进程复制了 Zygote 进程的地址空间，因此也会得到Zygote 创建的 server Socket，这个socket对SystemServer 没有用处，因此在代码 1处将其关闭，之后通过 handleSystemServerProcess 方法启动 SystemServer 进程。接下来，在ZygoteInit中<strong>创建了 PathClassLoader</strong>，并且通过native 方法 ZygoteInit.nativeZygotelnit <strong>启动了Binder线程池</strong>，之后进入 SystemServer 的main 方法。</p>
<p>SystemServer 的run 方法中用  SystemServiceManager 启动了  ActivityManagerService、 PackageManagerService 等服务。在PackageManagerService 创建完成后，将其注册到 ServiceManager 中，<font color="#008000">ServiceManager 用于管理系统中各种Service，用于系统C/S 架构中的Binder 通信机制：Client端要使用某个Service，需要先到 ServiceManager 中查询Service 的相关信息，然后与Service 所在的Server 进程建立通信通路，这样Client就可以使用Service 了</font>。</p>
<h3 id="SystemServer-进程总结"><a href="#SystemServer-进程总结" class="headerlink" title="SystemServer 进程总结"></a>SystemServer 进程总结</h3><p>SystemServer 进程被创建后，主要工作：</p>
<ol>
<li>启动Binder 线程池，这样可以与其他进程通信。    </li>
<li>创建 SystemServiceManager，创建和管理系统服务    </li>
<li>启动各种服务    </li>
</ol>
<h2 id="Launcher-启动过程"><a href="#Launcher-启动过程" class="headerlink" title="Launcher 启动过程"></a>Launcher 启动过程</h2><p>系统启动的最后一步是启动一个应用程序来显示系统中已经安装的应用程序，即 Launcher。Launcher 在启动过程中请求 PackageManagerService 获取系统中已经安装的应用程序信息，并且将信息封装成一个个快捷图标列表显示在系统屏幕上，用户就可以通过点击图标来启动相应的应用程序了。Launcher 的启动过程时序图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC2%E7%AB%A0/Launcher%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE.jpeg" alt="Launcher的启动过程时序图"></p>
<p>启动Launcher的入口方法为AMS 的systemReady 方法，该方法在SystemServer 的startOtherService中被调用，之后调用 ActivityStack 的resumeTopActivityUncheckedLocked 方法，ActivityStack 用于描述Activity 栈的。最终调用到 AMS 的 startHomeActivityLocked 方法，在该方法中，创建了 Launcher 启动所需的 Intent，并且在一系列判断后，将该Intent 的 Action 设置为 Intent.ACTION_MAIN 、Category 为 Intent.CATEGORY_HOME，并且在 Launcher 的AndroidManifest 中也是这么配置的。</p>
<p>经过以上操作，com.android.launcher3.Launcher 的Activity 就成为了主 Activity，此时，如果Launcher 还未启动，AMS 就会调用 ActivityStarter 的 startHomeActivityLocked 来启动 Launcher 。</p>
<h2 id="Android系统启动流程"><a href="#Android系统启动流程" class="headerlink" title="Android系统启动流程"></a>Android系统启动流程</h2><p>结合前面几节内容，可以总结出Android系统启动流程：</p>
<ol>
<li><p>启动电源以及系统启动     </p>
<blockquote>
<p>按下电源键，从预定义地方开始执行，加载BootLoader 到RAM。</p>
</blockquote>
</li>
<li><p>引导程序BootLoader     </p>
<blockquote>
<p>主要作用是拉起系统OS。</p>
</blockquote>
</li>
<li><p>Linux 内核启动      </p>
<blockquote>
<p>内核启动，设置缓存、计划表、加载驱动等，之后寻找 init.rc 文件，并启动init 进程。</p>
</blockquote>
</li>
<li><p>init 进程启动      </p>
<blockquote>
<p>初始化和启动属性服务，并启动 Zygote 进程。</p>
</blockquote>
</li>
<li><p>Zygote进程启动     </p>
<blockquote>
<p>创建Java虚拟机，并未Java虚拟机注册 JNI 方法，创建服务端 Socket 循环等待AMS 请求来创建新的应用程序进程</p>
</blockquote>
</li>
<li><p>SystemServer 进程启动     </p>
<blockquote>
<p>启动Binder 线程池 和 SystemServiceManager ，并启动各种服务。</p>
</blockquote>
</li>
<li><p>Launcher启动   </p>
<blockquote>
<p>SystemServer 进程启动的 AMS 会启动 Launcher，Launcher 会将已安装的应用显示到界面上。</p>
</blockquote>
</li>
</ol>
<p>用图表示就是：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC2%E7%AB%A0/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.jpeg" alt="Android系统启动流程图"></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/22/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/22/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">面试题-网络知识</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-22 15:00:00" itemprop="dateCreated datePublished" datetime="2019-11-22T15:00:00+08:00">2019-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-25 15:41:11" itemprop="dateModified" datetime="2022-02-25T15:41:11+08:00">2022-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1、TCP-IP-三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）"><a href="#1、TCP-IP-三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）" class="headerlink" title="1、TCP/IP 三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）"></a>1、TCP/IP 三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）</h2><p><strong>首先要会画 三次握手和四次挥手 的图。很重要，画了两次错了</strong></p>
<h3 id="3次握手的示意图如下："><a href="#3次握手的示意图如下：" class="headerlink" title="3次握手的示意图如下："></a>3次握手的示意图如下：</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p>
<p>三次握手过程：TCP发起的一方A，由操作系统生成一个序列号 n，以这个n为原点，对自己每个将要发送的数据进行编号，连接的另一方 B 会对A每次发送的数据进行确认，如果A收到B的确认编号2001，则可以认为 n~2000编号已经全部到达B。</p>
<h3 id="为什么三次握手"><a href="#为什么三次握手" class="headerlink" title="为什么三次握手"></a>为什么三次握手</h3><ol>
<li>首先，三次握手证明双方收发能力正常    </li>
<li>其次，如果只需要两次握手，那第二次(从server发到client端)之后server就分配资源了，但是如果第二次丢失了，那就造成资源浪费    </li>
<li>还有，如果client没有收到确认，就会再次发送握手连接，如果服务端先接到了第二个消息，然后发送返回确认，双方通信完毕，关闭。这时候第一个请求到了服务端，服务端确认，然而客户端已经关闭了，不理睬，这时候服务端只能一直等。    </li>
<li>还有，握手就确认了双方的序列号规则    </li>
</ol>
<h3 id="可以不握手吗？"><a href="#可以不握手吗？" class="headerlink" title="可以不握手吗？"></a>可以不握手吗？</h3><p>tcp实现可靠通信与 报文序号和确认号(ack) 是分不开的，我们知道握手是干的啥，其中就有告知初始序号的功能，所以不能不握手。</p>
<h3 id="4次挥手示意图："><a href="#4次挥手示意图：" class="headerlink" title="4次挥手示意图："></a>4次挥手示意图：</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p>
<p>由上图看出，由client端发起挥手，server给client的2次回复中，一次是确认信息ack，一次是数据的传送，那可不可以只要3次挥手呢？答案是可能的，TCP是全双工的，Client在没有数据需要发送给Server后，就发送FIN告知server，然后终止对server发送消息，但这个时候server还以发送数据给client，这时候需要4次；但是如果server收到client的FIN后再也没有数据要发给client了，那么 对client的ack包和server自己的FIN包就能合并成一个包发送过去，四次挥手变成3次。</p>
<p>了解完挥手完成后，可能还想更深入了解 TIME_WAIT，可以查看<a href="https://glassx.github.io/2018/05/21/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0/">之前写的这篇</a>。</p>
<h2 id="2、延伸-握手可能有什么安全问题"><a href="#2、延伸-握手可能有什么安全问题" class="headerlink" title="2、延伸-握手可能有什么安全问题"></a>2、延伸-握手可能有什么安全问题</h2><p>首先，发起请求时候的序列是随机的，为什么是随机的呢？想想如果是固定的从0开始，那么客户端发送多次握手(重传)，那么，当新连接建立之后，如果上一次的请求再过来了，序列还是 0 ，那就乱了。相反，如果序列不固定，那么上一次的过来，我只要和新连接这里对比下 序列号 就知道是否合法了。</p>
<ul>
<li>client第一个 SYN 包丢失，这个无所谓，后续触发重传机制，隔5s，24s等     </li>
<li>server 收到 SYN ，但是回复的 SYN，ACK 丢失，也会触发重传，可能依次隔 3s,6s,12s 等    </li>
<li>client 最后依次发送的 ACK 丢了，server 因为没收到 ACK 而实现重传，但是client 已经进入 ESTABLISHED 状态了。因为多数情况下，client 发送完最后的 ACK之后，就认为连接建立，开始发送数据。现实中的情况是，在这种情况下 server 收到 client 的数据会进入 ESTABLISH 状态，并会认为数据有效。     </li>
<li>如果client 故意不发最后一次 ACK，那么服务端处于<strong>半连接状态</strong>，如果这种半连接很多的话，server 端很有压力，因为需要一直重传</li>
</ul>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102197175">知乎上的文章</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/85557012">知乎上的文章1</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/53658729/answer/498879547">知乎-泪花的回答</a>     </p>
</blockquote>
<h2 id="3、延伸-三次握手可以携带数据吗？"><a href="#3、延伸-三次握手可以携带数据吗？" class="headerlink" title="3、延伸-三次握手可以携带数据吗？"></a>3、延伸-三次握手可以携带数据吗？</h2><p>第一次、第二次不可以，第三次可以。想想为什么？</p>
<ul>
<li>假如第一次允许带数据，那么攻击者只需要在第一次SYN中放入大量数据，根本不考虑服务器接收能力，这会让server 花费很长时间和很多空间来处理这些报文       </li>
<li>并且，第一次不知道server 是否有接收能力；如果放第二次，server 也不知道clien 是否有接收能力。    </li>
</ul>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102197175">知乎上的文章</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/85557012">知乎上的文章1</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/53658729/answer/498879547">知乎-泪花的回答</a></p>
</blockquote>
<h2 id="4、引申——为什么要等待2MSL？"><a href="#4、引申——为什么要等待2MSL？" class="headerlink" title="4、引申——为什么要等待2MSL？"></a>4、引申——为什么要等待2MSL？</h2><p>原因有二：<strong>保证TCP协议的全双工连接能够可靠关闭</strong> 以及 <strong>保证这次连接的重复数据段从网络中消失</strong></p>
<p>第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p>
<p>第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p>
<h2 id="5、IP地址分类（A-B-C-D类）"><a href="#5、IP地址分类（A-B-C-D类）" class="headerlink" title="5、IP地址分类（A/B/C/D类）"></a>5、IP地址分类（A/B/C/D类）</h2><p>IP地址由四段组成，每个字段是一个字节，即4个字节、 每个字节有8位，最大值是255，IP地址 = 网络号+主机号。分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/ip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" alt="ip地址分类"></p>
<p>由图可知：</p>
<blockquote>
<p>A类：前1个字节(8位)为网络号，后3个字节(24位)为主机号。A类第1位必须是0<br>B类：前2个字节(16位)为网络号，后2个字节(16位)为主机号。B类前两位固定为10<br>C类：前3个字节(24位)为网络号，后1个字节(8位)为主机号。C类前3位固定为110<br>D类： 是多播地址，一般用于多路广播用户。该类IP地址的最前面为1110<br>E类： 是保留地址。该类IP地址的最前面为1111</p>
</blockquote>
<h2 id="6、TCP与UDP区别"><a href="#6、TCP与UDP区别" class="headerlink" title="6、TCP与UDP区别"></a>6、TCP与UDP区别</h2><ol>
<li>UDP发送数据前无需建立连接，TCP需要握手建立连接。    </li>
<li>UDP尽最大努力交付,不保证可靠交付；TCP提供可靠交付。    </li>
<li>UDP面向报文，对应用程序交下来的报文，在添加首部之后就交付给Ip层，不会对报文拆分；TCP面向字节流，会对应用程序的报文进行拆分。    </li>
<li>UDP支持一对一、一对多、多对一和多对一的通信；TCP全双工通信，并且只能点对点通信，允许通信双方在任何时候均能通信。    </li>
<li>UDP首部开销小，TCP开销大（UDP 8个字节，TCP20个字节）。    </li>
<li>UDP没有拥塞控制，在网络条件差的情况下发送端也不会降低发送速率；TCP有拥塞控制，慢开始避免拥塞，快重传、快恢复。  </li>
<li>TCP 通过滑动窗口实现流量控制，UDP 无。  </li>
</ol>
<p>需要参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/108822858">知乎上的讲解</a>)重写一下</p>
<h2 id="7、引申-TCP流量控制"><a href="#7、引申-TCP流量控制" class="headerlink" title="7、引申-TCP流量控制"></a>7、引申-TCP流量控制</h2><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p>
<p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.jpg" alt="tcp流量控制"></p>
<p>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。</p>
<p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p>
<h2 id="8、引申-快重传和快恢复"><a href="#8、引申-快重传和快恢复" class="headerlink" title="8、引申-快重传和快恢复"></a>8、引申-快重传和快恢复</h2><ul>
<li>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</li>
</ul>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E5%BF%AB%E9%87%8D%E4%BC%A0.webp" alt="快重传"></p>
<ul>
<li>快恢复：当发送方连续收到三个重复确认，就开始执行拥塞避免算法，缩小拥塞窗口，随后再使拥塞窗口缓慢地线性增大。</li>
</ul>
<h2 id="9、Http和Https的区别？"><a href="#9、Http和Https的区别？" class="headerlink" title="9、Http和Https的区别？"></a>9、Http和Https的区别？</h2><blockquote>
<p>Https是ssl加密传输，Http是明文传输<br>Https是使用端口443，而Http使用80<br>HttpsSSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比Http协议安全<br>Https协议需要到CA申请证书</p>
</blockquote>
<h2 id="10、中间人攻击"><a href="#10、中间人攻击" class="headerlink" title="10、中间人攻击"></a>10、中间人攻击</h2><p>带着下列问题去了解Https 安全性：</p>
<ul>
<li>为什么用了https 就是安全的？用了https就一定安全吗？    </li>
<li>https 的底层原理如何？    </li>
</ul>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="https的原理"><a href="#https的原理" class="headerlink" title="https的原理"></a>https的原理</h3><p>https的整体过程分为证书验证和数据传输阶段，具体交互如下图：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/https%E6%95%B4%E4%BD%93%E8%BF%87%E7%A8%8B.jpg" alt="https整体过程"></p>
<p>所以证书验证阶段流程就是：</p>
<ol>
<li>客户端发起https 请求     </li>
<li>服务端返回https 证书      </li>
<li>客户端验证证书是否合法</li>
</ol>
<p>数据传输阶段流程就是：</p>
<ol>
<li>证书合法后，在本地生成随机数    </li>
<li>通过公钥加密随机数，并把加密后的随机数传输给服务端    </li>
<li>服务端通过私钥对随机数解密     </li>
<li>服务端<strong>通过客户端传入的随机数构造对称加密算法</strong>，对返回结果内容进行加密后传输</li>
</ol>
<p>那我们再引申一下，为什么后来要使用对称加密传输数据。这是因为：</p>
<ul>
<li>非对称加密的效率低    </li>
<li>https 上述场景中，只有服务端保存了私钥，一对公私钥只能单向加解密，而对称加密可以实现双向的加解密</li>
</ul>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>了解以上原理之后，中间人攻击的具体流程如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="中间人攻击流程图"></p>
<p>主要包括以下步骤：</p>
<ol>
<li>本地请求被劫持(如dns劫持等)，所有请求均发送到中间人的服务器    </li>
<li>中间人<strong>返回自己自己的证书</strong>    </li>
<li>客户端创建随机数并通过中间人的证书公钥加密，之后凭随机数构造对称加密对传输内容加密    </li>
<li>中间人用私钥解密随机数，此时中间人拥有客户端的随机数，所以可以通过对称加密算法解密内容    </li>
<li>中间人再以客户端的请求内容向正规服务器发送请求，此时中间人发起的请求就是正规请求了，数据也是正规数据，所以合法，正规服务器会通过建立的安全通道返回加密数据      </li>
<li>此后流程都是合法化的了，中间人只是做了个转发而已     </li>
</ol>
<p>以上，就是中间人攻击的流程，我们日常使用的fiddler 代理，其实就很好地模拟了中间人攻击。因为我们使用fiddler 代理https 的时候，需要本地信任fiddler 的证书，其实就是中间人返回自己的证书过程，中间人攻击关键也是这一步。</p>
<p>一般客户端会验证证书的合法性，所以中间人的证书没有这么容易被信任，中间人攻击的难点也在这。</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/95293098">知乎-Java面试那些事儿</a></p>
</blockquote>
<h2 id="11、TCP-IP-流量控制，拥塞避免，可以结合这篇文章"><a href="#11、TCP-IP-流量控制，拥塞避免，可以结合这篇文章" class="headerlink" title="11、TCP/IP 流量控制，拥塞避免，可以结合这篇文章"></a>11、TCP/IP 流量控制，拥塞避免，可以结合<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486825&amp;idx=1&amp;sn=db596ed4b69bd9220f6a8ad79ef308db">这篇文章</a></h2><h2 id="12、Session-和-Cookie-的区别？"><a href="#12、Session-和-Cookie-的区别？" class="headerlink" title="12、Session 和 Cookie 的区别？"></a>12、Session 和 Cookie 的区别？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<p>HTTP是一种无状态的协议，为了分辨链接是谁发起的，Session和Cookie就是为解决这个问题而提出来的两个机制。<br><strong>Cookies是服务器下发，存储到本地机器上的一段文本，并随每一个请求发回服务器，是在客户端保持状态的方案。</strong><br>浏览器第一次发送请求时，服务器自动生成了一HashTable和一个Session ID来唯一标识这个HashTable，并将其通过响应发送回浏览器。Session的实现方式和Cookie有一定关系，一般会把session id存在Cookie中（<strong>也可以依赖于url重写</strong>），每次访问的时候将Session id带过去，服务器就根据id查找hashtable就可以识别当前用户状态了。<br>所以可以总结，cookie存在本地，session存在服务器；父路径不能享用子路径的cookies，而同一个session的窗口可以共享session；cookie没有session可靠。</p>
</blockquote>
</details>


<h2 id="13、在浏览器中输入www-baidu-com后执行的全部过程"><a href="#13、在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="13、在浏览器中输入www.baidu.com后执行的全部过程"></a>13、在浏览器中输入<a target="_blank" rel="noopener" href="http://www.baidu.com后执行的全部过程">www.baidu.com后执行的全部过程</a></h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ol>
<li><p>客户端浏览器通过DNS解析到<a target="_blank" rel="noopener" href="http://www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></p>
</li>
<li><p>在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</p>
</li>
<li><p>客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
</li>
<li><p>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p>
</li>
</ol>
</details>

<h2 id="14、HTTP中，POST与GET的区别"><a href="#14、HTTP中，POST与GET的区别" class="headerlink" title="14、HTTP中，POST与GET的区别"></a>14、HTTP中，POST与GET的区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ol>
<li><p>Get是从服务器上获取数据，Post是向服务器传送数据。</p>
</li>
<li><p>Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中科院看到。</p>
</li>
<li><p>Get传送的数据量小，不能大于2KB；post传送的数据量较大，一般被默认为不受限制。</p>
</li>
<li><p>根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p>
</li>
</ol>
</details>

<h2 id="15、http2-与http1-的区别"><a href="#15、http2-与http1-的区别" class="headerlink" title="15、http2 与http1 的区别"></a>15、http2 与http1 的区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>总结一下：1)、新的二进制格式  2)、多路复用   3)、header 压缩   4)、采用新的压缩算法  5)、server push  6)、更安全的SSL</p>
<ul>
<li>新的二进制格式    </li>
</ul>
<p><strong>解释：</strong> http1 设计的时候是基于文本，http2 基于二进制格式。http2 的格式定义更接近tcp层的方式，length 定义了整个frame 的开始到结束，type 定义了frame 的类型，stream id 用作流控制。如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.jpg" alt="http2格式变化"></p>
<p>虽然看上去写一个是和http1完全不同了，实际上并没有改变http1的语义，只是把http1的header 和 body 用frame 重新封装了一层而已。他们的对应关系如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E4%B8%8Ehttp1%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.jpg" alt="http2与http1对应关系"></p>
<p>上述http1的首部信息会封装到 Header 的 frame，而相应的 body 封装到 Data frame。</p>
<ul>
<li>多路复用    </li>
</ul>
<p><strong>解释：</strong>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。一个request对应一个 stream 并分配一个id，这样一个连接上可以有多个stream，每个stream 的frame 可以随机地混杂在一起，接收方可以根据stream id 将各个frame 再归属到不同的request 里面。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E8%BF%9E%E6%8E%A5%E5%85%B1%E4%BA%AB.jpg" alt="http2连接共享"></p>
<p>http 性能优化的关键并不在于<strong>高带宽</strong>，而是<strong>低延迟</strong>，tcp 连接会随着时间进行自我“调谐”，起初会限制最大速度，如果传输成功，会随着时间提高传输的速度，这种调谐称为“慢启动”。http2 通过让所有数据流共用同一个连接，可以更高效地使用TCP。</p>
<p>客户端依据域名来向服务器建立连接，一般pc端浏览器会针对单个域名的server 同时建立 6~8 个连接，<strong>连接无法复用会导致请求要经历三次握手和慢启动</strong>。在http1中，假如有5个连接同时发出，在第一个请求没有收到回复之前，后续从应用层发出的请求只能排队，请求2，3，4，5只能等请求1的response 回来之后才能逐个发出。网络通畅的时候性能影响不大，一旦请求1的request 因为什么原因没有抵达服务器，影响到后续所有的请求，问题就比较严重了。</p>
<ul>
<li>header 压缩    </li>
</ul>
<p><strong>解释：</strong>http2针对header 采用新的压缩方式，高效地压缩算法可以很大地压缩header。并且，通讯双方各自缓存一份 header fields 表，避免重复header 的传输。</p>
<ul>
<li>采用新的压缩算法</li>
</ul>
<p><strong>解释：</strong>http2在采用gzip之外的新的压缩算法，更加安全。</p>
<ul>
<li>server push</li>
</ul>
<p><strong>解释：</strong>http2 能通过push的方式将客户端需要的内容预先推送过去。</p>
<ul>
<li>更安全的SSL</li>
</ul>
<p><strong>解释：</strong>http2.0 对 tls 的安全性做了进一步加强。</p>
</details>
&gt; 以上内容参考自[知乎上的回答](https://www.zhihu.com/question/34074946)

<h2 id="16、网络状态码？以-2、3、4、5-开头的代表什么意思。"><a href="#16、网络状态码？以-2、3、4、5-开头的代表什么意思。" class="headerlink" title="16、网络状态码？以 2、3、4、5 开头的代表什么意思。"></a>16、网络状态码？以 2、3、4、5 开头的代表什么意思。</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="1xx-临时响应"><a href="#1xx-临时响应" class="headerlink" title="1xx-临时响应"></a>1xx-临时响应</h3><p>100： 继续。请求者应当继续提出请求<br>101： 切换协议。请求者要求服务器切换协议，服务器确认并准备切换   </p>
<h3 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx-成功"></a>2xx-成功</h3><p>200： 成功。服务器成功处理请求<br>201： 已创建。请求成功并且服务器创建了新的资源<br>202： 已接受。 服务器接受请求，但是尚未处理<br>203： 非授权信息。服务器成功处理请求，但返回的信息可能来自另一来源<br>204： 无内容。服务器成功处理请求，但是没有返回任何内容<br>205： 重置内容。服务器成功处理请求，但是没有返回任何内容<br>206： 部分内容。服务器成功处理了部分GET请求</p>
<h3 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx-重定向"></a>3xx-重定向</h3><p>300： 多种选择。服务器根据请求者选择一项操作，火提供操作列表供请求者选择<br>301： 永久移动。请求的资源永久移动到新位置了，返回此响应时会自动转到新位置<br>302： 临时移动。从不同位置响应请求，但是后续还是以原来位置继续请求<br>303： 查看其它位置。<br>304： 未修改。自上次请求后，请求的网页未修改过，此时不会返回网页内容<br>305： 使用代理。请求者只能使用代理访问请求的网页。    </p>
<h3 id="4xx-请求错误"><a href="#4xx-请求错误" class="headerlink" title="4xx-请求错误"></a>4xx-请求错误</h3><p>400： 错误请求。服务器不理解请求语法<br>401： 未授权。请求要求身份验证<br>403： 进制。服务器拒绝请求<br>404： 未找到。服务器找不到请求的网页<br>405： 方法禁用。禁用请求中指定的方法<br>408： 请求超时。服务器等候请求时发生超时<br>410： 已删除。请求的资源已永久删除<br>413： 请求实体过大。请求实体过大，服务器无法响应<br>414： 请求的URI过长。请求的URI（通常为网址）过长，无法处理<br>415： 不支持的媒体类型。</p>
<h3 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx-服务器错误"></a>5xx-服务器错误</h3><p>500： 服务器内部错误。服务器遇到错误，无法完成请求<br>501： 尚未实施。服务器不具备完成请求的功能<br>502： 错误网关。<br>503： 服务不可用。暂时地维护或者超载了<br>504： 网关超时。服务器作为网关或者代理，但是没有及时从上游服务器收到请求<br>505： HTTP版本不支持。服务器不支持请求中所用的HTTP协议版本   </p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="http://tool.chinaz.com/pagestatus/">站长工具</a> </p>
</blockquote>
<h2 id="17、HttpDNS"><a href="#17、HttpDNS" class="headerlink" title="17、HttpDNS"></a>17、HttpDNS</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="当前-DNS-系统存在的问题"><a href="#当前-DNS-系统存在的问题" class="headerlink" title="当前 DNS 系统存在的问题"></a>当前 DNS 系统存在的问题</h3><ul>
<li>域名缓存。运营商的 LocalDNS 会缓存域名解析的结果，而不是向权威域名发起递归。运营商缓存dns就可以实现把dns解析结果指向广告</li>
<li>解析转发。运营商自身不进行域名递归解析，而是把它发给其它运营商。一些小运营商就是这样做的。这样，比如说访问的是qq.com，则腾讯的权威dns收到的域名解析请求的来源就变成了其它运营商，最终导致用户流量被导向了错误的IDC，比如明明是广东的用户，被导向去了北京的服务器。    </li>
<li>NAT ，网络地址转换。运营商LocalDNS出口根据权威DNS目标ip进行NAT，导致腾讯权威dns无法正确识别运营商的 LocalDNS 的ip，引发域名解析错误，流量跨网等</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>使用 114 等中立DNS 服务器</p>
</li>
<li><p>使用HttpDNS，HttpDNS 的基本原理如下：</p>
</li>
</ul>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/HttpDNS%E5%8E%9F%E7%90%86.webp" alt="HttpDNS的原理"></p>
<p><strong>注意：HttpDNS主要用于客户端</strong></p>
<p>HttpDNS 的使用过程主要有两步：</p>
<ol>
<li>客户端直接访问HttpDNS 接口，获取Host对应的IP。     </li>
<li>客户端通过IP，向后台发送请求。以Http为例，通过在Header中指定host 字段，向HttpDNS 返回的IP 发送标准的Http请求即可。</li>
</ol>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/u6-53Kp9Jb48dKWzaJOKig">鹅厂网事上的博客</a></p>
</blockquote>
<h2 id="18、https的证书验证"><a href="#18、https的证书验证" class="headerlink" title="18、https的证书验证"></a>18、https的证书验证</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>证书是一级一级的验证的，验证当前的证书时，首先拿上一级的证书的公钥，用上一级的公钥来验证当前证书的签名，验证成功就通过，不成功就报错了。然后一级一级上去，顶级。因为本地(浏览器和操作系统)一般存有信任的根证书，顶级证书一般都能通过本地证书验证。</p>
</details>

<blockquote>
<p>以上内容可以参考<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/37370216">知乎上的内容</a></p>
</blockquote>
<h2 id="19、https的攻击方式"><a href="#19、https的攻击方式" class="headerlink" title="19、https的攻击方式"></a>19、https的攻击方式</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>1、中间人攻击。类似Fiddler 这种方式，前提是黑客通过某种特殊手段在被攻击者的手机上安装了根证书<br>2、Https协议降级攻击。比如说client端仅仅支持某个有漏洞的ssl版本(比如SSLv3.0)，那么服务端只能接收或者直接拒绝。如果接受的话，攻击者就能攻击(应该是 Padding Oracle 攻击)<br>3、使用对称加密的时候破解的对称加密</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/22917510">知乎的博客</a>、<a target="_blank" rel="noopener" href="https://blog.fundebug.com/2019/09/17/mitm-for-https/">中间人攻击</a></p>
</blockquote>
<h2 id="20、到底使用什么时候使用-GET-请求，什么时候使用-POST-请求？"><a href="#20、到底使用什么时候使用-GET-请求，什么时候使用-POST-请求？" class="headerlink" title="20、到底使用什么时候使用 GET 请求，什么时候使用 POST 请求？"></a>20、到底使用什么时候使用 GET 请求，什么时候使用 POST 请求？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>当请求无副作用（如搜索）的时候，可以使用 GET 方法；当请求有副作用（如添加数据）的时候，则使用 POST 。不过有个很实际的问题： <strong>GET 方法可能会产生很长的 url ，并且某些浏览器和服务器对 GET 请求的 url 长度是有限制的 ！</strong></p>
<p>若符合下列任一情况，用 POST : </p>
<ul>
<li>请求的结果有持续性的副作用</li>
<li>使用 GET 方法会使 url 过长</li>
<li>要传送的数据不是采用 7 位的 ASCII 编码</li>
</ul>
<p>若符合下列任一情况，用 GET：</p>
<ul>
<li>请求是为了查找资源</li>
<li>请求的结果无持续性副作用</li>
<li>收集的数据及 HTML 表单内输入字段名称的总长度不超过 1024 个字符</li>
</ul>
</details>



<blockquote>
<p>以上内容<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zy20160117/p/10973067.html">参考自 cnblogs 博客</a></p>
</blockquote>
<h2 id="21、TCP相关问题"><a href="#21、TCP相关问题" class="headerlink" title="21、TCP相关问题"></a>21、TCP相关问题</h2><h3 id="粘包处理"><a href="#粘包处理" class="headerlink" title="粘包处理"></a>粘包处理</h3><p>TCP 两端 A、B 建立了连接后，A 端先发送 100 个字节，再发送 100 个字节。那么 B 端会分别收到两次 100 字节吗？ <strong>答案是不一定</strong>。</p>
<p>我们常说 TCP 是一种流式连接，这个流字到底怎么理解？它是指 TCP 的数据传输就像一种水流一样，并不区分不同数据包之间的界限。</p>
<p>看过 TCP 协议内容的人就可以发现，TCP 协议允许发送端将几次发送的数据包缓存起来合成一个数据包发送到网络上去，因为这样可以获得更高的效率，这一行为通常是在操作系统提供的 SOCKET 中实现，所以在应用层对此毫无所觉。 所以我们在程序中调用 send 发送超过 MTU 的数据包时，操作系统提供的 SOCKET 的 send 发送了数据后，操作系统有可能缓存了起来，等待后续的数据一起发送，而不是立即发送出去。</p>
<p>分包发送 网络传输的概念中有 MTU 的概念，也即是网络中一个数据包最大的长度。如果要发送超过这个长度的数据包，就需要分包发送。当调用 SOCKET 的 send 发送超过 MTU 的数据包时，操作系统提供的 SOCKET 实现会自动将这个数据包分割成几个不超过 MTU 的数据包发送。 当出现这些上面这些情况的时候，接收端就会发现接收到的数据和发送的数据的次数不一致。这个就是<strong>粘包现象</strong>。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>当我们传输如文件这种数据时，流式的传输非常适合，但是当我们传输指令之类的数据结构时，流式模型就有一个问题：无法知道指令的结束。<strong>所以粘包问题是必须要解决的</strong>。</p>
<h4 id="粘包问题解决方案"><a href="#粘包问题解决方案" class="headerlink" title="粘包问题解决方案"></a>粘包问题解决方案</h4><ul>
<li>短连接。需要发送数据的时候建立 TCP 连接，发送完一个数据包后就断开 TCP 连接，这样接收端自然就知道数据结束了。这种方案多次建立 TCP 连接，性能低下</li>
<li>长连接。使用长连接能够获得更好的性能但不可避免的会遇到如何判断数据结构的开始与结束的问题。</li>
<li>定长结构。如果发送端发送了一个固定长度的数据结构，接收端必须每次都严格判断接收到额数据的长度，当收到的数据长度不足时，需要再次接收数据，直到满足长度，当收到的数据多于固定长度时，需要截断数据，并将多余的数据缓存起来，视为长度不足需要再次接收处理。 不定长结构<br>定长的数据结构是一种理想的情况，真正的应用中通常使用的都是不定长的数据结构。</li>
<li>不定长结构。<strong>目前最通用的做法是在每次发送的数据的固定偏移位置写入数据包的长度</strong>。<strong>所以对于处理粘包的关键在于提前获取到数据包的长度</strong>。</li>
</ul>
<h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><p>当 TCP 两端 A、B 建立了连接后，如果一端拔掉网线或者拔掉电源，那么另一端能够收到通知吗？</p>
<p><strong>答案是不会</strong></p>
<p>TCP 的建立连接和断开连接都是通过发送数据实现的，也就是我们常说的三次握手、四次挥手。</p>
<p>但是这就说明了一点，如果不发送数据那么是无法断开连接的。正常情况下当 TCP 的一端A调用了 SOCKET 的 close 或者进程结束，操作系统就会按照 TCP 协议发送FIN 数据报文。B 端收到后就会断开连接。但是当出现了上文所说的异常情况时：被拔掉网线或者断掉电源，总结起来就是没有机会发出断开的 FIN 数据报文。那么和 A 直连的路由设备虽然知道 A 设备已经断开了，但是路由设备并没有保存连接的状态信息，所以路由设备也就不可能去通知 B 端 A 端的断开。而 B 端没有收到断开的数据报文就会依然保持连接。<strong>所以 A 端拔掉网线或者断掉电源后 B 端是没办法收到断开连接的通知的。</strong></p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>KEEP_ALIVE</p>
<p>TCP 协议本身就提供了一种这样的机制来探测对端的存活。TCP 协议有一个KEEP_LIVE 开关，只要打开这个开关就会定时发送一些数据长度为零的探测心跳包，发送的频率和次数都可以设置</p>
<h3 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h3><p>TCP 如何保证数据的正确性，保证数据内容不会出错？</p>
<p>大部分人就会开始说丢包重传、接收确认之类的东西，但这些都扯偏了，只要少数人能够正确回答题目要问的问题<strong>：首部校验</strong>。</p>
<p>对于能答上这个问题的人，我会进一步问，这个校验机制能够确保数据传输不会出错吗？</p>
<p><strong>答案是不能</strong>。</p>
<p>TCP 协议中规定，TCP 的首部字段中有一个字段是校验和，发送方将伪首部、TCP 首部、TCP 数据使用累加和校验的方式计算出一个数字，然后存放在首部的校验和字段里，接收者收到 TCP 包后重复这个过程，然后将计算出的校验和和接收到的首部中的校验和比较，如果不一致则说明数据在传输过程中出错。这就是TCP 的数据校验机制。</p>
<p>但是这个机制能够保证检查出一切错误吗？显然不能。因为这种校验方式是累加和，也就是将一系列的数字(TCP 协议规定的是数据中的每 16 个比特位数据作为一个数字)求和后取末位。</p>
<p>但是小学生都知道 A+B=B+A。</p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>在应用层添加一层校验</p>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39705794/article/details/111363610">csdn的博客</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/20/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/20/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">面试题-系统源码理解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-20 11:13:00" itemprop="dateCreated datePublished" datetime="2019-11-20T11:13:00+08:00">2019-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-21 16:53:16" itemprop="dateModified" datetime="2021-12-21T16:53:16+08:00">2021-12-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1、okhttp的理解"><a href="#1、okhttp的理解" class="headerlink" title="1、okhttp的理解"></a>1、okhttp的理解</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先看下okhttp 的整个工作流程：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/okhttp%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="okhttp工作流程"></p>
<ol>
<li>首先通过 Builder 创建 OkhttpClient 对象    </li>
<li>根据设定的条件，使用Request.Builder 构建request 对象      </li>
<li>根据 OkhttpClient 与 request 创建 RealCall     </li>
<li>不论是通过execute 还是enqueue 方式异步执行，最终都通过 getResponseWithInterceptorChain 方式获取Http 的返回结果           </li>
<li>步骤4中，通过Okio 封装的Socket 请求网络，并获取返回结果    </li>
</ol>
<p>Interceptor 是Okhttp 中最重要的一个东西，它不止拦截请求执行一些额外处理，实际上实际的网络请求、缓存、透明压缩等都是通过Interceptor 实现，它们一起连成 Interceptor.chain，每一个Interceptor 决定它自己能处理哪些事件，如果不能处理，则交给下一个Interceptor 处理，也就是<strong>责任链模式。</strong>这很类似View 中对点击事件的处理。</p>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="http://www.androidos.net.cn/book/android-road/android/open-source-framework/okhttp.html">okhttp 解析</a></p>
</blockquote>
<h3 id="okhttp有几种发起请求的方式？"><a href="#okhttp有几种发起请求的方式？" class="headerlink" title="okhttp有几种发起请求的方式？"></a>okhttp有几种发起请求的方式？</h3><p>两种，分别是：</p>
<ul>
<li>同步请求，将同步请求任务加入调度器的<strong>同步执行的双端队列</strong>（即runningSyncCalls，意为正在执行） ，然后直接调用 getResponseWithInterceptorChain 返回结果</li>
<li>异步请求，异步请求加入调度器，经历 readyAsyncCalls 和 runningAsyncCalls，之后调用 getResponseWithInterceptorChain</li>
</ul>
<blockquote>
<p>同主机任务最多支持5个并发，同时执行的任务不超过64个。注意，任务执行完成之后，不管同步还是异步，都会将任务从队列中清除</p>
</blockquote>
<h3 id="okhttp的interceptor怎么实现责任链？"><a href="#okhttp的interceptor怎么实现责任链？" class="headerlink" title="okhttp的interceptor怎么实现责任链？"></a>okhttp的interceptor怎么实现责任链？</h3><ul>
<li>实现 Interceptor接口，重写intercept方法    </li>
<li>做自己需要的处理，比如更改header之后需要重新builder出request，如果不涉及这块，可以不用重新build</li>
<li>使用chain.proceed(request)将请求传到给下一级，并且会有response返回</li>
<li>可以对response进行处理，比如根据response重试之类的，如果不做处理就将response作为结果抛给上一级处理</li>
</ul>
<h3 id="okhttp的调度器"><a href="#okhttp的调度器" class="headerlink" title="okhttp的调度器"></a>okhttp的调度器</h3><p>Dispatcher维护了三个队列，分别是： 同步正在执行队列、异步准备执行队列 以及 异步正在执行队列</p>
<h3 id="有哪些拦截器"><a href="#有哪些拦截器" class="headerlink" title="有哪些拦截器"></a>有哪些拦截器</h3><ul>
<li>CacheInterceptor：处理cache相关处理，如果本地有了可⽤的Cache，就可以在没有网络交互的情况下就返回缓存结果</li>
<li>addInterceptor(Interceptor)，就是我们自定义的一些拦截器，在所有的拦截器处理之前进行最早的拦截处理，比如一些公共参数，Header都可以在这里添加</li>
<li>ConnectInterceptor，这里主要就是负责建立连接了，会建立TCP连接或者TLS连接</li>
<li>networkInterceptors，这里也是开发者自己设置的，但是由于位置不同，所以用处也不同。<strong>这个位置添加的拦截器可以看到请求和响应的数据了，所以可以做一些网络调试</strong>。它对应  addNetworkInterceptor 方法</li>
<li>RetryAndFollowUpInterceptor，这里会对连接做一些初始化工作，以及请求失败的充实工作，重定向的后续请求工作</li>
<li>。。。<strong>未完待续，下次做笔记写完整</strong></li>
</ul>
<h3 id="okhttp的线程池怎么实现"><a href="#okhttp的线程池怎么实现" class="headerlink" title="okhttp的线程池怎么实现"></a>okhttp的线程池怎么实现</h3><p>查看Dispatcher类这个代码就可以知道：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get:Synchronized</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">"executorService"</span>) <span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line">    <span class="keyword">get</span>() {</span><br><span class="line">      <span class="keyword">if</span> (executorServiceOrNull == <span class="literal">null</span>) {</span><br><span class="line">        executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">            SynchronousQueue(), threadFactory(<span class="string">"<span class="variable">$okHttpName</span> Dispatcher"</span>, <span class="literal">false</span>))</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> executorServiceOrNull!!</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<p>将线程池的<strong>核心线程数设置为0</strong>；线程池容纳的最大线程数量为 Int.MAX_VALUE；超时时间设置为 60s ；队列设置为同步队列 SynchronousQueue ，先来先服务；</p>
<p><strong>OkHttp线程池设计为核心线程为0是因为客户端可能在一段时间内不会有网络请求，为了避免浪费不必要的线程内存，所以不保留最低线程，同时最大线程设置为Int.MAX_VALUE为了防止同一时间有大量的请求进入，造成部分请求被抛弃的问题，设置60秒为线程空闲最大时间，在一段时间不使用的情况进行线程回收。</strong></p>
<p>SynchronousQueue每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。因此队列内部其实没有任何一个元素，或者说容量为0。<strong>因此我们可以理解来了任务直接执行</strong>。</p>
<p>还有要注意的一点就是，如果异步请求中，runningAsyncCalls 的数量大于64后，就会加入到 readyAsyncCall 排队等待</p>
<h3 id="okhttp用到什么设计模式"><a href="#okhttp用到什么设计模式" class="headerlink" title="okhttp用到什么设计模式"></a>okhttp用到什么设计模式</h3><ul>
<li>责任链模式(拦截器)</li>
<li>建造者(比如 Request 就是通过建造者模式建造出来的)</li>
<li>工厂模式(比如CacheInterCeptor中的策略工厂 CacheStrategy.Factory)</li>
<li>单例模式</li>
</ul>
<blockquote>
<p>以上内容参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37700275/article/details/105044858">csdn</a>、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/16425e270dd1">简书</a>、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7cb9300c6d71">简书2</a></p>
</blockquote>
</details>

<h2 id="2、谈谈对RxJava的理解"><a href="#2、谈谈对RxJava的理解" class="headerlink" title="2、谈谈对RxJava的理解"></a>2、谈谈对RxJava的理解</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="常用操作符"><a href="#常用操作符" class="headerlink" title="常用操作符"></a>常用操作符</h3><ul>
<li>map：将被观察者发送的数据类型转换为其他类型    </li>
<li>flatMap ： 将事件序列中的元素整合，返回一个新的被观察者    </li>
<li>zip ： 将多个观察者事件整合发送给观察者</li>
</ul>
<h3 id="如何实现线程切换"><a href="#如何实现线程切换" class="headerlink" title="如何实现线程切换"></a>如何实现线程切换</h3><ul>
<li>Observer 最终会封装成 SubscribeTask ，这个类实现了 Runnable 接口。    </li>
<li>最终在 Runnable 的run 方法中完成 观察者-被观察者的订阅关系      </li>
<li>也即，这个run 在哪个线程执行，observer 方法就在哪个方法执行。     </li>
<li>如果是 AndroidSchedulers.mainThread 的话，则会以Android主线程的Looper(Looper.getMainLooper())新建一个 Handler ，之后将上述Runnable 封装成Message ，通过Handler 发送到主线程。     </li>
<li>如果是其他线程，则会丢给特定线程或者线程池处理。     </li>
</ul>
<blockquote>
<p>以上内容参考自： <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1408083">rxjava2线程切换原理</a>、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5213fe112fa9">rxjava使用与原理</a></p>
</blockquote>
</details>

<h2 id="3、fresco的理解"><a href="#3、fresco的理解" class="headerlink" title="3、fresco的理解"></a>3、fresco的理解</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="为什么使用fresco"><a href="#为什么使用fresco" class="headerlink" title="为什么使用fresco"></a>为什么使用fresco</h3><ol>
<li>部门决定采用webp 格式的图片，而fresco 对其支持           </li>
<li>5.0 以下Android系统，使用 ashmem(匿名共享内存) 区域存储bitmap ，它的创建、释放都不会触发 GC，带来良好的性能。   </li>
</ol>
<blockquote>
<p>fresco 使用ashmem 区域存储bitmap ，gc不会处理这块区域，并且也不会被”ashmem内置清除机制”回收，所以减少gc，提升性能。在ashmem 中，fresco 采用引用计数方式，自己管理内存。</p>
</blockquote>
<ol start="3">
<li>使用了三级缓存，方便图片快速复用、加载：Bitmap 缓存 + 未解码缓存 + 硬盘缓存，前面两个是内存缓存，Bitmap 根据不同系统版本存放不同区域(5.0以下存放ashmem)，未解码存放在堆内存。      </li>
<li>fresco 的设计，UIThread 只做从内存缓存中加载图片和显示图片两件事，其他诸如 图片Decode、缓存读写 都放在非 UI线程。      </li>
</ol>
<h3 id="fresco-原理解析"><a href="#fresco-原理解析" class="headerlink" title="fresco 原理解析"></a>fresco 原理解析</h3><p>典型的MVC模式应用：</p>
<ul>
<li>DraweeView ： view 层，负责显示图片。它继承ImageView 的目的是使用它来显示 drawable ，其他的ImageView 方法都没有使用，也不推荐使用。   </li>
<li>Hierarchy： model 层，负责生成要显示的图片     </li>
<li>DraweeController： controller 层     </li>
</ul>
<p>DraweeView 把获得event 转给 controller，controller 决定是否隐藏或者显示什么图像，而这些图像存储在 Hierarchy，最后 DraweeView 直接通过 getTopLevelDrawable 获取要显示的图像。</p>
<p>DraweeView 不直接与 Hierarchy 及 DraweeController 打交道，而是通过 DraweeHolder 间接与他们打交道，因为 DraweeHolder 管理着 Hierarchy 与 Controller。</p>
<h2 id="图片库的选择"><a href="#图片库的选择" class="headerlink" title="图片库的选择"></a>图片库的选择</h2><h3 id="Picasso"><a href="#Picasso" class="headerlink" title="Picasso"></a>Picasso</h3><p>自己没有实现缓存，配合 Okhttp 在 Okhttp里面实现缓存</p>
<p>优点：</p>
<ul>
<li>与Square系的库搭配较好，如okhttp、retrofit等</li>
<li>包小</li>
<li>功能简单</li>
</ul>
<h3 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h3><p>优点：</p>
<ul>
<li>支持webp、gif、video</li>
<li>支持Memory和Disk缓存</li>
<li>默认RGB_565，开销小</li>
</ul>
<h2 id="fresco"><a href="#fresco" class="headerlink" title="fresco"></a>fresco</h2><p>优点</p>
<ul>
<li><p>支持webp图片</p>
</li>
<li><p>native层缓存图片，减少oom</p>
</li>
<li><p>使用简单，几乎都能在xml上搞定</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>太大</li>
</ul>
<h3 id="fresco-图片切换原理"><a href="#fresco-图片切换原理" class="headerlink" title="fresco 图片切换原理"></a>fresco 图片切换原理</h3><p>DraweeHierarchy 内部维护着一个Drawable序列，这些个Drawable代表不同层次的图片，如果没有设置，这层Drawable就会为null，如果设置了但此时不应该展示它，比如 ActualImage 已经加载到了，不需要placeHold图片了，就把这层Drawable的 alpha 置为 0 。</p>
<p>准确地说是 FadeDrawable 中包含了上述的Drawable，在调用 FadeDrawable 的onDraw() 方法时，就会一层一层绘制，如果该层为null或者alpha为0，就不绘制，这样就实现了切换。</p>
<h3 id="关于Ashmem"><a href="#关于Ashmem" class="headerlink" title="关于Ashmem"></a>关于Ashmem</h3><p>Ashmem不能被Java应用直接处理，但是也有一些例外，图片就是其中之一.当你创建一张没有经过压缩的Bitmap的时候，Android的API允许你指定是否是可清除的:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">options.inPurgeable = <span class="keyword">true</span>;</span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeByteArray(jpeg, <span class="number">0</span>, jpeg.length, options);</span><br></pre></td></tr></tbody></table></figure>



<p>经过以上处理，当 Android 绘制系统在渲染这些图片，Android 的系统库就会把这些 Bitmap 从 Ashmem 堆中抽取出来，而当渲染结束后，这些 Bitmap 又会被放回到原来的位置。如果一个被抽取的图片需要再绘制一次，系统仅仅需要把它再解码一次，这个操作非常迅速。</p>
<p>Fresco 如何将图片放到Ashmem中？<strong>Ashmem一般在应用层是无法直接访问的，除了几个特例之外，其中之一就是 decode bitmap</strong>。我们可以通过设置BitmapFactory.Options.inPurgeable = true 来创建一个Purgeable Bitmap，这样decode出来的bitmap是在Ashmem内存中的，GC无法直接回收它。当Bitmap在使用时会被pin住，这样就不会被释放，使用完之后就unpin，这样系统在未来某个时刻会释放这部分内存。如果unpin的图片后续又要使用，就得再次decode，如果是在ui线程执行decode，就可能掉帧，因此google建议使用 inBitmap 来尝试使用已经存在的内存区域，而不是新分配区域，不过，要使用inBitmap ，必须要求二者有相同的解码格式，比如都是8888或者都是 565 的。</p>
<p>Fresco 为了让inPurgeable的bitmap不被自动unpinned，可以使用jni函数  AndroidBitmap_lockPixels()来强制pin bitmap，这样避免在unpinned之后，重新decode 这个Bitmap 而引起掉帧，不过这样就需要自己来管理这块空间了，我们可以使用 AndroidBitmap_unlockPixels 来让bitmap 重新变为 unpinned 状态。这样，系统在内存不足的时候，就可以回收这块内存了。Fresco使用Ashmem这块的知识点详细<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wytiger/p/5690039.html">参考这篇文章</a></p>
<blockquote>
<p>参考<a target="_blank" rel="noopener" href="http://blog.itpub.net/69952849/viewspace-2685599/">itpub</a>、<a target="_blank" rel="noopener" href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0402/2683.html">jcodeer</a>、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2bb77edb3011">简书</a></p>
</blockquote>
</details>

<h2 id="4、ThreadLocal-详解"><a href="#4、ThreadLocal-详解" class="headerlink" title="4、ThreadLocal 详解"></a>4、ThreadLocal 详解</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>ThreadLocal 很典型的一个用处就是存储线程的 Looper，我们知道，子线程中初始化Handler 的时候，需要先执行 Looper.prepare ，这个操作就是新建一个Looper 并且将其保存到 ThreadLocal 中。</p>
<p>Thread 类中有个专门存储线程的 ThreadLocal 数据的结构，即 ThreadLocal.Values 。保存值时，首先通过 Thread.currentThread 获取到当前线程，再获取该线程的 ThreadLocal.Values ，这个 Values 中有个 Object[] table 的数组，ThreadLocal 对象就存在这个数组中。每个 ThreadLocal 对象根据自己的 hashcode 按照一定规则获取到在数组中的 index ，之后进行读取或者存储。</p>
<p>这样，每个线程通过同一个 ThreadLocal 获取到的是不同的值。各个线程可以相互独立地执行操作。</p>
</details>

<blockquote>
<p>以上内容总结自源码，部分语言参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/singwhatiwanna/article/details/48350919">任玉刚的博客内容</a></p>
</blockquote>
<h2 id="5、LocalBroadcastManager"><a href="#5、LocalBroadcastManager" class="headerlink" title="5、LocalBroadcastManager"></a>5、LocalBroadcastManager</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>LocalBroadcastManager 注册本地广播<strong>只能通过代码，不能通过xml静态注册</strong>。本地广播不会跨进程，不用跟system_server 交互。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>首先，LocalBroadcastManager.getInstance 是个单例，在初始化过程中，会根据 mainLooper 创建一个Handler：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LocalBroadcastManager</span><span class="params">(Context context)</span> </span>{</span><br><span class="line">    mAppContext = context;</span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler(context.getMainLooper()) {</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) {</span><br><span class="line">                <span class="keyword">case</span> MSG_EXEC_PENDING_BROADCASTS:</span><br><span class="line">                    executePendingBroadcasts();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其次，注册过程，其实可以理解成订阅某种消息，以便在符合条件的消息发送的时候，这里能接收：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerReceiver</span><span class="params">(<span class="meta">@NonNull</span> BroadcastReceiver receiver, <span class="meta">@NonNull</span> IntentFilter filter)</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) {</span><br><span class="line">    	<span class="comment">//创建ReceiverRecord对象</span></span><br><span class="line">        ReceiverRecord entry = <span class="keyword">new</span> ReceiverRecord(filter, receiver);</span><br><span class="line">        <span class="comment">//mReceivers：数据类型为HashMap&lt;BroadcastReceiver, ArrayList&gt;， 记录广播接收者与IntentFilter列表的对应关系</span></span><br><span class="line">        ArrayList&lt;ReceiverRecord&gt; filters = mReceivers.get(receiver);</span><br><span class="line">        <span class="keyword">if</span> (filters == <span class="keyword">null</span>) {</span><br><span class="line">            filters = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">            mReceivers.put(receiver, filters);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        filters.add(entry);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;filter.countActions(); i++) {</span><br><span class="line">            String action = filter.getAction(i);</span><br><span class="line">            <span class="comment">//mActions：数据类型为HashMap&lt;String, ArrayList&gt;， 记录action与广播接收者的对应关系</span></span><br><span class="line">            ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action);</span><br><span class="line">            <span class="keyword">if</span> (entries == <span class="keyword">null</span>) {</span><br><span class="line">                entries = <span class="keyword">new</span> ArrayList&lt;ReceiverRecord&gt;(<span class="number">1</span>);</span><br><span class="line">                mActions.put(action, entries);</span><br><span class="line">            }</span><br><span class="line">            entries.add(entry);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，发送广播，可以理解为，根据 sendBroadcast(Intent intent) 中 intent 的值获取 actions，再根据action 来查询相应的广播接收者，当然，如果当前receiver 正在处理其他广播，则跳过：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) {</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据Intent的action来查询相应的广播接收者列表</span></span><br><span class="line">        ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction());</span><br><span class="line">        <span class="keyword">if</span> (entries != <span class="keyword">null</span>) {</span><br><span class="line">        	<span class="comment">//用于存放与当前action匹配的receiver</span></span><br><span class="line">            ArrayList&lt;ReceiverRecord&gt; receivers = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;entries.size(); i++) {</span><br><span class="line">                ReceiverRecord receiver = entries.get(i);</span><br><span class="line">                <span class="keyword">if</span> (receiver.broadcasting) {</span><br><span class="line">                	<span class="comment">//当前receiver正在处理其他广播，则跳过</span></span><br><span class="line">                    <span class="keyword">continue</span>; </span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> match = receiver.filter.match(action, type, scheme, data,categories, <span class="string">"LocalBroadcastManager"</span>);</span><br><span class="line">                <span class="keyword">if</span> (match &gt;= <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (receivers == <span class="keyword">null</span>) {</span><br><span class="line">                        receivers = <span class="keyword">new</span> ArrayList&lt;ReceiverRecord&gt;();</span><br><span class="line">                    }</span><br><span class="line">                    receivers.add(receiver);</span><br><span class="line">                    receiver.broadcasting = <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (receivers != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;receivers.size(); i++) {</span><br><span class="line">                    receivers.get(i).broadcasting = <span class="keyword">false</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//创建相应广播，添加到mPendingBroadcasts队列</span></span><br><span class="line">                mPendingBroadcasts.add(<span class="keyword">new</span> BroadcastRecord(intent, receivers));</span><br><span class="line">                <span class="keyword">if</span> (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) {</span><br><span class="line">                    <span class="comment">//发送消息【见小节2.3.1】</span></span><br><span class="line">                    mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在 LocalBroadcastManager 的构造函数中我们初始化了这个以 mainLooper 建立的Handler，此时利用它 sendEmptyMessage，在handleMessage 中最终会调用 executePendingBroadcasts 方法（说明此函数也运行在主线程）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executePendingBroadcasts</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">        <span class="keyword">final</span> BroadcastRecord[] brs;</span><br><span class="line">        <span class="comment">//将mPendingBroadcasts保存到brs数组</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mReceivers) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mPendingBroadcasts.size();</span><br><span class="line">            <span class="keyword">if</span> (N &lt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            brs = <span class="keyword">new</span> BroadcastRecord[N];</span><br><span class="line">            mPendingBroadcasts.toArray(brs);</span><br><span class="line">            mPendingBroadcasts.clear();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//挨个回调相应广播接收者的onReceive</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;brs.length; i++) {</span><br><span class="line">            <span class="keyword">final</span> BroadcastRecord br = brs[i];</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> nbr = br.receivers.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;nbr; j++) {</span><br><span class="line">                <span class="keyword">final</span> ReceiverRecord rec = br.receivers.get(j);</span><br><span class="line">                <span class="keyword">if</span> (!rec.dead) {</span><br><span class="line">                    rec.receiver.onReceive(mAppContext, br.intent);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过以上的原理分析，我们知道本地广播只是在发送广播的时候，在主线程中挨个通知 action 符合的receiver，因此并不会超出进程范围，也不会超出 app 范围，只会在当前app 的当前进程发生。</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="http://gityuan.com/2017/04/23/local_broadcast_manager/">gityuan的分析</a></p>
</blockquote>
<h2 id="6、Java线程池ThreadPoolExecutor实现原理"><a href="#6、Java线程池ThreadPoolExecutor实现原理" class="headerlink" title="6、Java线程池ThreadPoolExecutor实现原理"></a>6、Java线程池ThreadPoolExecutor实现原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>ThreadPoolExecutor 构造函数参数非常多，有以下：</p>
<ul>
<li><p>corePoolSize： 通过 submit 或者 execute 提交任务时，如果当前线程池的线程数 n &lt; corePoolSize ，则创建一个新的线程处理任务，即使其他 core 线程是空闲的。    </p>
</li>
<li><p>maximumPoolSize: 如果当前线程数 n &gt; corePoolSize &amp;&amp; n &lt; maximumPoolSize ，那么不会创建新的线程；但是如果 n &gt;= maximumPoolSize 时，就会创建新的线程。如果是个无界队列(LinkedBlockingQueue)，那么不存在满的情况(n &gt;= maximumPoolSize),也就不会创建新线程。    </p>
</li>
<li><p>keepAliveTime: 如果当前线程池中的线程数 n &gt; corePoolSize,那么如果在 keepAliveTime 时间内没有新的任务需要处理，那么就会销毁 corePoolSize - n 个线程。    </p>
</li>
<li><p>handler ：异常处理策略。即当任务提交失败的时候，调用这个处理器。</p>
</li>
</ul>
<h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><p>ThreadPoolExecutor 使用一个 AtomicInteger 的前三位表示线程池状态，后 29 位表示线程数，因此是可以支持上亿的线程计数。线程池主要有几种状态：</p>
<ul>
<li>Running： 线程池正在运行，可以接收新任务。    </li>
<li>ShutDown： 不再接收新任务，但会继续处理队列中任务。    </li>
<li>Stop： 不接受新任务，也不处理队列中任务，并且<strong>中断正在处理的任务</strong>    </li>
<li>Tidying： 所有任务处理玩，线程数为 0(线程池为空)    </li>
<li>Terminated： 已经执行完毕(执行了 terminated)    </li>
</ul>
<p>submit 执行过程 就是将 Runnable 和 Callable 封装成 RunnableFuture 之后，最终提交给execute 执行。使用 HashSet 类型的 worker 来存储正在运行的任务，只要 worker.size() &lt; corePoolSize，提交新的任务就马上开启新线程执行(上面提到过)。在提交过程中要检查线程池的状态，检查是否关闭了。</p>
<p>worker的数目也是通过 CAS的方式 增减的。</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://github.com/aCoder2013/blog/issues/28">github上的博客</a></p>
</blockquote>
<h2 id="7、延伸-Java-线程池的异常处理机制"><a href="#7、延伸-Java-线程池的异常处理机制" class="headerlink" title="7、延伸-Java 线程池的异常处理机制"></a>7、延伸-Java 线程池的异常处理机制</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>如果是使用submit 提交的话，可以通过继承 ThreadPoolExecutor 再重写 afterExecute 方法，得到实际的异常 (包含 Runnable 和 Throwable)    </li>
<li>如果是调用的execute 方法提交的话，那就会抛到 dispatchUncaughtException 里面去了，这时候我们只有对线程 Thread.setUncaughtExceptionHandler(UncaughtExceptionHandler)  来捕捉。即自己写 ThreadFactory (thread 工厂类),并为创建的线程 setUncaughtExceptionHandler       </li>
<li>还有一种，就是对 Runnable 的 run 方法里面整个 try-catch    </li>
</ul>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="http://ifeve.com/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/">并发编程网</a> 或者它<a target="_blank" rel="noopener" href="https://github.com/aCoder2013/blog/issues/3">在github上的相同文章</a></p>
</blockquote>
<h2 id="8、AsyncTask-解析"><a href="#8、AsyncTask-解析" class="headerlink" title="8、AsyncTask 解析"></a>8、AsyncTask 解析</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>AsyncTask 是个抽象类，必须子类实现才能使用。在构建的时候，需要指定三个泛型参数类型，分别是 Params、Progress、Result ，即类似 AsyncTask&lt;Integers, Integers, ResponseBean&gt; ，当然，如果某个参数不需要，类型可以写成 Void 。</p>
<p>其整体原理还是 将task丢给ThreadPool 在子线程执行，得到结果后，通过 Handler 的 sendEmptyMessage 的方式将结果切换到主线程</p>
<p>在 AsyncTask 使用的过程中需要遵守如下原则：</p>
<ul>
<li>必须在UI线程中实例化             </li>
<li>execute 必须在UI线程中调用                </li>
<li>不要人为调用 onPreExecute、onPostExecute、doInBackground 和 onProgressUpdate               </li>
<li>一个 AsyncTask 实例只能执行一次，如果多次调用会报异常                  </li>
</ul>
<p>AsyncTask 中有 <strong>static</strong> 的 ThreadPool ，<strong>意味着不管有多少个实例，都只有这个线程池</strong>，而在初始化这个线程池的时候，corePoolSize 在不同版本的值默认被设置为 1 或者 5 (Android 3.0以前是5，还不能改；3.0之后设置为1，但是可以自己设置Excutor )，并且 BlockingQueue 基本上是个无界队列(BlockingQueue 或 SynchronousQueue，队列不存在满的情况)，根据 ThreadPool 的原理，我们每次最多只有一个线程或者 5 个线程在执行，<strong>意味着多的任务就要排队，并不能实时执行</strong>，并且在早期，我们不能设置自定义的 ThreadPoolExcutor，到后来才可以(貌似是Android 4.0以后)。</p>
<p>AsyncTask 存在的问题：</p>
<ol>
<li>AsyncTask 对象只能execute 一次，多次请求会导致多个对象创建          </li>
<li>生命周期与Activity 的生命周期不一致，有可能导致内存泄露           </li>
<li>cancle 并不马上生效，因为它就是线程，在cancle之后，还得等它完成           </li>
</ol>
</details>

<blockquote>
<p>以上内容参考自 系统源码、<a target="_blank" rel="noopener" href="http://zmywly8866.github.io/2015/09/29/android-call-asynctask-excute-not-run.html">github上的博客</a>、<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yanyojun/p/6414919.html">cnblogs的博客</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43507738/article/details/83418989">csdn的博客</a></p>
</blockquote>
<h2 id="9、阿里Alpha原理"><a href="#9、阿里Alpha原理" class="headerlink" title="9、阿里Alpha原理"></a>9、阿里Alpha原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>想象下有以下场景： </p>
<p>有6个任务需要在Application里面执行，其中Task1，Task4，Tas6需要在主线程执行，Task2，Task3需要在Task1执行完才能执行，Task4，Task5需要Task2和Task3执行完才能执行，Task6需要Task4和Task5执行完才能执行，Task4的耗时要大于Task5，是不是顿时就乱了？其实可以通过 PERT 图来捋一捋这个关系，涉及到具体实现的话，可以参考阿里巴巴的 alpha 框架。</p>
<p>Alpha是一个<strong>基于PERT图</strong>构建的Android异步启动框架</p>
<p>首先解决多进程疑惑，在start方法中就首先判断了 <strong>主进程任务、非主进程任务 以及 适用于所有进程的任务</strong>，这些任务是通过 public void addProject(Task project, int mode) 方法添加进去的。</p>
<p>在实际情况中，可能会有多个任务同时开始，并且也有可能多个任务作为结束节点，所以为了<strong>方便控制整个流程</strong>，alpha 设计了startTask 和 finishTask，标记流程的开始和结束，方便任务的监听</p>
<p>如果Task 是在主线程执行的，那么就通过Handler 将时间传递给主线程；如果是非主线程，则通过线程池去执行。</p>
<p>在一个Task执行完成后，就会遍历自己持有的 <strong>mSuccessorList(紧后任务列表，也就是当前任务执行完成之后可以执行的Task列表，这里面的Task会根据Priority进行排序)</strong>，并依次执行里面元素的 onPredecessorFinished 方法。</p>
<p>mSuccessorList 列表中的Task 是通过 after 方法加入的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//紧后任务添加</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">after</span><span class="params">(Task task)</span> </span>{</span><br><span class="line">    task.addSuccessor(mCacheTask);</span><br><span class="line">    mFinishTask.removePredecessor(task);</span><br><span class="line">    mIsSetPosition = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要操作在这个方法里</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSuccessor</span><span class="params">(Task task)</span> </span>{</span><br><span class="line">    <span class="comment">//task 添加紧前任务</span></span><br><span class="line">    task.addPredecessor(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//真正添加为紧后任务</span></span><br><span class="line">    mSuccessorList.add(task);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>意思是Task2要在Task1后面执行，这样，Task2就是Task1的紧后任务，同理，Task1也成了Task2的紧前任务，那这个紧前任务有什么用呢？试想一下，如果Task1、Task2、Task3的紧后任务都是 Task4，那么，在Task1执行完成之后，还要判断 Task2和Task3是否执行完成，然后才能决定是否执行Task4，这就是紧前任务的作用了。</p>
</details>

<blockquote>
<p>以上文章主要参考自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuzhengisme/article/details/106996006">积木zz的csdn博客</a>, 有博客说，使用 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/163014950">Anchors</a> 比使用 Alpha 更精细，后续再看</p>
</blockquote>
<h2 id="10、LeakCanary-原理"><a href="#10、LeakCanary-原理" class="headerlink" title="10、LeakCanary 原理"></a>10、LeakCanary 原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>原理：</p>
<ol>
<li>通过registerActivityLifecycleCallbacks 来监听 Activity 的生命周期 onActivityDestroyed。    </li>
<li>即 lifecycleCallbacks 监听Activity 的 onDestroy 方法，正常情况下执行了onDestroy 后资源立即回收。    </li>
<li>监察机制利用了 WeakReference 和 ReferenceQueue ，使用 WeakReference 对Activity 进行引用，在Activity回收的时候，就会将该WeakReference 引用放到 ReferenceQueue 中。     </li>
<li>在onDestroy 之后，等待一段时间，再通过监测 ReferenceQueue 是否包含 WeakReference 就能检查 Activity 是否被正确回收。    </li>
<li>如果Activity 没有被回收，就手动 GC 一次，等待若干时间，之后再次判断Activity 是否被回收，若未被回收，说明 Activity 已经泄露。    </li>
<li>如果Activity 泄露了，则抓取 dump 信息显示出来。</li>
</ol>
<p>以上要注意的是：</p>
<p>1、是使用<strong>WeakReference</strong>对Activity进行引用<br>2、LeakCanary可以配置<strong>忽略</strong>某些路径的内存泄漏<br>3、手动GC是使用的 Runtime.getRuntime().gc() 实现，代码中解释是这样触发gc的概率会比System.gc() 高一些: System.gc() does not garbage collect every time. Runtime.gc() is more likely to perform a gc.<br>4、 当Activity对象被回收时，会将 <strong>WeakReference(而不是Activity)对象</strong>放入 ReferenceQueue 中，自己写的测试代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> RecyclebleObject testObject;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;RecyclebleObject&gt; objectWeakReference;</span><br><span class="line">    <span class="keyword">private</span> ReferenceQueue&lt;RecyclebleObject&gt; referenceQueue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        testObject = <span class="keyword">new</span> RecyclebleObject();</span><br><span class="line">        referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        objectWeakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(testObject, referenceQueue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TextView btnClick = findViewById(R.id.click_view);</span><br><span class="line"></span><br><span class="line">        btnClick.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{</span><br><span class="line">                <span class="keyword">if</span> (testObject == <span class="keyword">null</span>) {</span><br><span class="line">                    testObject = <span class="keyword">new</span> RecyclebleObject();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                Log.e(<span class="string">"NullTest"</span>, <span class="string">"testObject = "</span> + testObject);</span><br><span class="line">                Log.e(<span class="string">"NullTest"</span>, <span class="string">"referenceQueue 中的内容： "</span> + referenceQueue.poll());</span><br><span class="line">                testObject = <span class="keyword">null</span>;</span><br><span class="line">                Runtime.getRuntime().gc();</span><br><span class="line"></span><br><span class="line">                btnClick.postDelayed(<span class="keyword">new</span> Runnable() {</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                        Log.e(<span class="string">"NullTest"</span>, <span class="string">"GC 后，testObject = "</span> + testObject);</span><br><span class="line">                        Reference result = referenceQueue.poll();</span><br><span class="line">                        Log.e(<span class="string">"NullTest"</span>, <span class="string">"GC 后，referenceQueue 的内容： "</span> + result + <span class="string">",这个对象与objectWeakReference 相等吗？ "</span> + (result == objectWeakReference));</span><br><span class="line">                    }</span><br><span class="line">                }, <span class="number">1000</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码将会打印出以下结果：</p>
<blockquote>
<p>testObject = com.example.myapplication.RecyclebleObject@86f4db5<br>referenceQueue 中的内容： null<br>GC 后，testObject = null<br>GC 后，referenceQueue 的内容： java.lang.ref.WeakReference@f6c4a,这个对象与objectWeakReference 相等吗？ true     </p>
</blockquote>
<p>说明在回收后， WeakReference 对象会出现在 referenceQueue 中，而不是 testObject 本身出现在 referenceQueue  。</p>
<hr>
<p>有意思的是，在 LeakCanary2 时，并不需要接入者手动初始化(LeakCanary.install(this);)了，而是只需要引入即可。其根本原理是：<strong>LeakCanary 写了个 ContentProvider 并在 AndroidManifest中注册了，并在 ContentProvider 的onCreate方法中执行了 install 操作！</strong>我们知道，ContentProvider 的 onCreate 方法会在启动App的时候自动执行，并且比 Application 的 onCreate 方法还要早，因此它自动执行完全没问题。</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/261e70f3083f">JasmineBen的博客</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/braintt/article/details/99685243">CSDN上的博客</a>、以及自己写的代码验证</p>
</blockquote>
<h2 id="11、Toast显示流程"><a href="#11、Toast显示流程" class="headerlink" title="11、Toast显示流程"></a>11、Toast显示流程</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先，为了避免Toast显示冲突，会将要显示的Toast放在队列中，然后依次取出来展示</p>
<ol>
<li>makeText的时候，创建Toast对象和TN对象，Toast创建好后，加载布局，创建mNextView，然后 TN 是控制Toast的显示和隐藏以及取消的，它里面有个 Handler ，以当前线程的Looper来初始化，Toast的显示隐藏取消就是通过这个Handler来处理的。        </li>
<li>Toast对象创建完成就 enqueueToast 到NotificationManagerService 进程中去排队的(所以这中间是有跨进程通信这个概念的)，在中间会判断是否要显示这个Toast(如果此Toast正在取消或者隐藏就不展示了)，接着就开始排队，显示的话，就是不断从队列里面取出 ToastRecord ，然后调用 Toast对应的TN 的show 方法展示Toast。</li>
<li>TN收到显示的消息，创建WindowManager对象，然后将第一步创建的 View 添加到 WindowManager ，之后Toast 就显示出来了。          </li>
</ol>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/Android%E5%9F%BA%E7%A1%80/Toast%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B.webp" alt="Toast显示流程"></p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7177360e3f63">简书上的博客</a></p>
</blockquote>
<h2 id="12、onTouchListener、onTouchListener-的onTouch方法、onTouchEvent、onClickListener、onLongClickListener-的执行顺序？"><a href="#12、onTouchListener、onTouchListener-的onTouch方法、onTouchEvent、onClickListener、onLongClickListener-的执行顺序？" class="headerlink" title="12、onTouchListener、onTouchListener 的onTouch方法、onTouchEvent、onClickListener、onLongClickListener 的执行顺序？"></a>12、onTouchListener、onTouchListener 的onTouch方法、onTouchEvent、onClickListener、onLongClickListener 的执行顺序？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>dispatchTouchEvent 在 onTouchListener 之前发生，如果在 dispatchTouchEvent 的 down 事件就return 了 false，则后续的事件压根就不会传过来了，所以不会有什么故事。        </li>
<li>但如果 down 事件返回了 true ，则事件虽然onTouchListener 和 onTouchEvent 会发生，但不会有点击事件了，即onLongClick 和 onClick 都不会响应了。    </li>
<li>onTouchListener 在onTouchEvent 之前发生， onLongClick 与 onClick 依赖于是在onTouchEvent 里面发生的，也就是说 click 事件是在 onTouchEvent 之后执行，并且 onClick 在 onLongClick 之后执行。        </li>
<li>如果在 onTouchListener 的 onTouch 方法中返回true，则没有后面的 onTouchEvent 什么事了，更别提 click 事件        </li>
<li>在onTouch 发生后，如果直接在 onTouchEvent 中返回true 或者false ，那就没有 click 什么事情了（因为click 是在super.onTouchEvent中）    </li>
<li>如果TouchEvent 不做处理，那么在down事件发生后长按，则会响应 onLongClick 事件，之后up，如果之前的 onLongClick 返回false ，则还会接着 onClick，反之，如果之前的 onLongClick 返回true，则 onClick 不会执行。     </li>
</ul>
</details>

<blockquote>
<p>以上内容来自自己的实验，以及<a target="_blank" rel="noopener" href="https://blog.csdn.net/qiantanlong/article/details/82017462">csdn上的博客1</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/wang_k516/article/details/52849565">csdn上的博客2</a></p>
</blockquote>
<h2 id="13、Android-事件中-CANCLE-事件是怎么来的？它的作用是啥？"><a href="#13、Android-事件中-CANCLE-事件是怎么来的？它的作用是啥？" class="headerlink" title="13、Android 事件中 CANCLE 事件是怎么来的？它的作用是啥？"></a>13、Android 事件中 CANCLE 事件是怎么来的？它的作用是啥？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>第一个问题：我们知道view如果处理了 Down 事件，则随之而来的 Move 和 Up 事件也会交给它处理，但是交给它处理之前，父View 可以拦截，如果被拦截了，就会返回 Cancel 事件，并且不会收到后续的 Move 和 Up 事件</p>
<p>第二个问题：</p>
</details>

<blockquote>
<p>以上内容参考自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/cufelsd/article/details/89471402">csdn上的博客</a></p>
</blockquote>
<h2 id="14、Handler-解析"><a href="#14、Handler-解析" class="headerlink" title="14、Handler 解析"></a>14、Handler 解析</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Handler 有多个构造函数，看下图：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/Handler.png" alt="Handler构造函数"></p>
<p>这些参数有几个需要解释下，callback：用于控制消息执行顺序的，具体参看Handler 的 dispatchMessage 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) {</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在执行时，如果 msg 设置了 callback，则优先执行，接下来，如果Handler 有设置了 callback ，则执行这个callback ，最后才是我们熟悉的 handleMessage 方法。因此，我们说 这个 callback 是控制执行顺序的。</p>
<p>Looper 参数表明的是，Handler 将在哪个线程执行，使用哪个线程的。</p>
<p>boolean 类型的 async 值是指 Handler 是否发送异步消息，这个异步消息要配合<strong>消息屏障</strong>使用。首先设置了消息屏障，之后 Looper 中只会执行异步消息了，直到消息屏障被 remove 。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                    <span class="keyword">do</span> {</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    } <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                    </span><br><span class="line">                    ...</span><br><span class="line">                    </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>

<h2 id="15、ViewStub源码解析"><a href="#15、ViewStub源码解析" class="headerlink" title="15、ViewStub源码解析"></a>15、ViewStub源码解析</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先，在构造函数里面有两个点值得关注：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewStub</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>{</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//置为不可见</span></span><br><span class="line">        setVisibility(GONE);</span><br><span class="line">        <span class="comment">//置为不会draw</span></span><br><span class="line">        setWillNotDraw(<span class="keyword">true</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>构造方法里面就直接将ViewStub置为不可见，并且，设置为不会 draw ，因为ViewStub本身不展示，所以无需 draw 。然后，我们一般都是通过inflate 或者 setVisibility 来设置ViewStub的可见性：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisibility</span><span class="params">(<span class="keyword">int</span> visibility)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mInflatedViewRef != <span class="keyword">null</span>) {</span><br><span class="line">        View view = mInflatedViewRef.get();</span><br><span class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span>) {</span><br><span class="line">            view.setVisibility(visibility);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"setVisibility called on un-referenced view"</span>);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">super</span>.setVisibility(visibility);</span><br><span class="line">        <span class="keyword">if</span> (visibility == VISIBLE || visibility == INVISIBLE) {</span><br><span class="line">            inflate();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//获取VIewStub的parent</span></span><br><span class="line">    <span class="keyword">final</span> ViewParent viewParent = getParent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewParent != <span class="keyword">null</span> &amp;&amp; viewParent <span class="keyword">instanceof</span> ViewGroup) {</span><br><span class="line">        <span class="keyword">if</span> (mLayoutResource != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">final</span> ViewGroup parent = (ViewGroup) viewParent;</span><br><span class="line">            <span class="comment">//也就是 .inflate(mLayoutResource, parent, false) 最后一个参数为false</span></span><br><span class="line">            <span class="keyword">final</span> View view = inflateViewNoAdd(parent);</span><br><span class="line">            replaceSelfWithView(view, parent);</span><br><span class="line"></span><br><span class="line">            mInflatedViewRef = <span class="keyword">new</span> WeakReference&lt;&gt;(view);</span><br><span class="line">            <span class="keyword">if</span> (mInflateListener != <span class="keyword">null</span>) {</span><br><span class="line">                mInflateListener.onInflate(<span class="keyword">this</span>, view);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"ViewStub must have a valid layoutResource"</span>);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ViewStub must have a non-null ViewGroup viewParent"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由以上代码可以看到，调用 setVisibility 时，如果以前有inflate出来真正的 view 了，那就直接对这个 view.setVisibility ;否则，如果 setVisibility 为 visible 或者 invisible ，都会触发 inflate 操作。</p>
<p>inflate 操作，如果没有指定真正的 view 的布局id (mLayoutResource)，那会抛出异常，之后，将真正的 view 以 ViewStub的parent 作为 parent 先inflate 出来，接下来 replaceSelfWithView 其实就是将真正的 view 替换到原来 viewstub的位置(位置 index 和布局参数 layoutparams 都拿过去)，而 原来的 ViewStub 会被remove 掉：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceSelfWithView</span><span class="params">(View view, ViewGroup parent)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = parent.indexOfChild(<span class="keyword">this</span>);</span><br><span class="line">    parent.removeViewInLayout(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewGroup.LayoutParams layoutParams = getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (layoutParams != <span class="keyword">null</span>) {</span><br><span class="line">        parent.addView(view, index, layoutParams);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        parent.addView(view, index);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="为何无大小不绘制"><a href="#为何无大小不绘制" class="headerlink" title="为何无大小不绘制"></a>为何无大小不绘制</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>{</span><br><span class="line">    setMeasuredDimension(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>从源码可以直接看到，在 onMeasure 中，直接 setMeasuredDimension(0, 0) 即宽和高都变为  0 了，并且draw 和 dispatchDraw 都是空方法。</p>
<h3 id="能inflate多次吗"><a href="#能inflate多次吗" class="headerlink" title="能inflate多次吗"></a>能inflate多次吗</h3><p>还是看inflate 的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ViewParent viewParent = getParent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewParent != <span class="keyword">null</span> &amp;&amp; viewParent <span class="keyword">instanceof</span> ViewGroup) {</span><br><span class="line">       ...</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ViewStub must have a non-null ViewGroup viewParent"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>能够看到，inflate 的时候，这里会获取 ViewStub 自己的 parent，然后呢，会判断  <strong>viewParent != null</strong>，由于前面说了，inflate 的时候已经将 ViewStub 从patent 中移除，所以这里肯定为 null ，因此，这就会报错啦。<strong>所以我们只能inflate一次</strong></p>
</details>

<blockquote>
<p>以上内容参考AS打开的源码，以及<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37700275/article/details/103180521">CSDN</a>上的观点</p>
</blockquote>
<h2 id="16、事件传递顺序"><a href="#16、事件传递顺序" class="headerlink" title="16、事件传递顺序"></a>16、事件传递顺序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先，由源代码可知：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>{  </span><br><span class="line">    <span class="keyword">if</span> (mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  </span><br><span class="line">            mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) {  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(event);  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先执行 dispatchTouchEvent ，其次 执行 OnTouchListener.onTouch，如果返回true ，则不会执行后续的 onTouchEvent 了</p>
<p>其次，看 onTouchEvent 的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>{  </span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) {  </span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:  </span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent){</span><br><span class="line">                    <span class="comment">// This is a tap, so remove the longpress check</span></span><br><span class="line">                    removeLongPressCallback();</span><br><span class="line">                    ...</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) {</span><br><span class="line">                        mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                    }</span><br><span class="line">                   </span><br><span class="line">                    <span class="comment">//触发OnClick事件</span></span><br><span class="line">                    <span class="keyword">if</span> (!post(mPerformClick)) {</span><br><span class="line">                        performClick();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:  </span><br><span class="line">                   <span class="keyword">if</span> (isInScrollingContainer) {</span><br><span class="line">                       ...</span><br><span class="line">                   } <span class="keyword">else</span> {</span><br><span class="line">                      <span class="comment">// Not inside a scrolling container, so show the feedback right away</span></span><br><span class="line">                      setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                      <span class="comment">// 触发事件</span></span><br><span class="line">                      checkForLongClick(<span class="number">0</span>, x, y);</span><br><span class="line">                  }</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            ...</span><br><span class="line">        }  </span><br><span class="line">        <span class="comment">//如果该控件是可以点击的，就一定会返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    }  </span><br><span class="line">    <span class="comment">//如果该控件是不可以点击的，就一定会返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由此可知，onLongClickListener 、onClickListerner 都是在 onTouchEvent 中触发的，前者是在DOWN事件中触发，后者是在UP事件中触发。如果 onLongClickListener  执行了，onClickListerner 就不会执行。</p>
<p>综上，dispatchTouchEvent -&gt; onTouchListener -&gt; onTouchEvent -&gt; onLongClick -&gt; onClick 的顺序</p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gucun4848/article/details/53487504">参考这</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37700275/article/details/93200473">这里</a></p>
</blockquote>
<h2 id="17、EventBus-原理"><a href="#17、EventBus-原理" class="headerlink" title="17、EventBus 原理"></a>17、EventBus 原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<p>注： 本文的EventBus版本为 3.0</p>
</blockquote>
<h3 id="Subscrib-注解"><a href="#Subscrib-注解" class="headerlink" title="Subscrib 注解"></a>Subscrib 注解</h3><p>自 3.0 以来，EventBus 使用 @Subscrib 注解来标记订阅事件的方法，方法命名随意。并不用像以前那样指定方法的命名：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEventBus</span><span class="params">(Object obj)</span></span>{ }</span><br></pre></td></tr></tbody></table></figure>

<p>这个注解的定义很有个性，可以看下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在</span></span><br><span class="line"><span class="meta">@Target({ElementType.METHOD})</span>  <span class="comment">// 作用在方法上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定事件订阅方法所在的线程模式，也就是决定订阅方法是在哪个线程，默认是POSTING模式</span></span><br><span class="line">    <span class="function">ThreadMode <span class="title">threadMode</span><span class="params">()</span> <span class="keyword">default</span> ThreadMode.POSTING</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否支持粘性事件</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">sticky</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级，如果指定了优先级，则若干方法接收同一事件时，优先级高的方法会先接收到。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中有几种线程模式，有以下几种：</p>
<ul>
<li><p><strong>ThreadMode.MAIN：</strong>如在主线程（UI线程）发送事件，则直接在主线程处理事件；如果在子线程发送事件，则先将事件入队列，然后通过 Handler 切换到主线程，依次处理事件。</p>
</li>
<li><p><strong>ThreadMode.ASYNC：</strong>与ThreadMode.MAIN_ORDERED相反，无论在哪个线程发送事件，都将事件加入到队列中，然后通过线程池执行事件</p>
</li>
<li><p><strong>ThreadMode.POSTING：</strong>默认的线程模式，在哪个线程发送事件就在对应线程处理事件，避免了线程切换，效率高。</p>
</li>
<li><p><strong>ThreadMode.MAIN_ORDERED：</strong>无论在哪个线程发送事件，都将事件加入到队列中，然后通过Handler切换到主线程，依次处理事件。</p>
</li>
<li><p><strong>ThreadMode.BACKGROUND：</strong>与ThreadMode.MAIN相反，如果在子线程发送事件，则直接在子线程处理事件；如果在主线程上发送事件，则先将事件入队列，然后通过线程池处理事件。</p>
</li>
</ul>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>注册过程很简单：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>{</span><br><span class="line">     Class&lt;?&gt; subscriberClass = subscriber.getClass(); <span class="comment">// 获取传入的要注册类的字节码文件</span></span><br><span class="line">     List&lt;SubscriberMethod&gt; subscriberMethods = </span><br><span class="line">     subscriberMethodFinder.findSubscriberMethods(subscriberClass); </span><br><span class="line">     </span><br><span class="line">     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 遍历订阅方法封装类的集合</span></span><br><span class="line">         <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) {</span><br><span class="line">              subscribe(subscriber, subscriberMethod); </span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>根据源码可以直到，这个方法就做了两件事情：</p>
<ul>
<li>根据传入的参数object ，获取其 Class ，然后通过这个 Class 获取所有的方法（当然，首先看有没有缓存），查看经过 @Subscrib 修饰的方法，即这个类中所有的订阅方法（会做封装），生成一个list</li>
<li>遍历上述生成的 list ，给 2 个 Map 填充数据：<strong>subscriptionsByEventType</strong>以 event （订阅方法的参数）的类型（Class）为key，value 为订阅方法list（CopyOnWriteArrayList）；<strong>typesBySubscriber</strong> 以register时传入的对象为key ，value 为 这个对象所有订阅方法所订阅的事件。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EventBus中变量的声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以根据event（订阅方法中的参数）类型 获取所有订阅方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"><span class="comment">//根据注册对象，获取这个对象上所有的订阅方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br></pre></td></tr></tbody></table></figure>



<h3 id="反注册"><a href="#反注册" class="headerlink" title="反注册"></a>反注册</h3><p>反注册也很简单：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>{</span><br><span class="line"></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果集合不为null    </span></span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) {</span><br><span class="line">            </span><br><span class="line">         <span class="comment">// 遍历集合，获取订阅事件的类型</span></span><br><span class="line">         <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) {</span><br><span class="line"></span><br><span class="line">              unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">         }</span><br><span class="line">         typesBySubscriber.remove(subscriber);</span><br><span class="line">     } <span class="keyword">else</span> {</span><br><span class="line">          logger.log(Level.WARNING, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>刚才在注册时候，说了其中一个 map 为 typesBySubscriber，它以注册对象为 key ，value 为这个对象中所有注册方法所注册的event 类型的列表。所以在反注册的时候，</p>
<ol>
<li>首先通过传入的对象，获取 注册的 event 的列表 </li>
<li>遍历这个列表，获取 event 的类型，然后通过这个类型在 subscriptionsByEventType 查找（经过封装的）订阅方法，根据封装在里面的 注册对象 是否是当前 unregister 传入的对象来判断，如果是当前传入的对象，就移除这个经过封装的订阅方法   </li>
</ol>
<h3 id="post-发布事件"><a href="#post-发布事件" class="headerlink" title="post 发布事件"></a>post 发布事件</h3><p>post的使用也很简单：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(<span class="keyword">new</span> Object());</span><br></pre></td></tr></tbody></table></figure>

<p>注册的时候，说了有一个map 为 subscriptionsByEventType ，以 event 的类型为key ，存储了所有订阅了这中 event 的（经过封装的）方法。post 的时候，根据post发送的事件类型（post方法的参数的 Class ）从 subscriptionsByEventType 这个集合中获取到所有的订阅方法。之后依次通过反射调用这些方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    } <span class="keyword">catch</span> (InvocationTargetException e) {</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalAccessException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>其中， subscription.subscriberMethod.method 是 Method 类型的，用过反射的话，就知道它可以直接 invoke ，它的定义是这样的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>第一个参数 obj 指的是用 obj 这个实例来调用这个方法（因为一个类可能会有多个实例，非静态方法需要指定一个实例来调用这个方法），后面的 args 就是方法需要传入的参数。</p>
<p>所以，在 invoke 的时候，subscription.subscriber 我们应该很容易知道是 register 时传入的那个 Object ！由此，我们一个消息就形成了闭环。</p>
<h3 id="最后问题，支持跨进程吗？"><a href="#最后问题，支持跨进程吗？" class="headerlink" title="最后问题，支持跨进程吗？"></a>最后问题，支持跨进程吗？</h3><p>先说结论：不支持跨进程，因为单例。经过上述分析，我们知道 EventBus 的注册、反注册、post 都是通过：EventBus.getDefault() 实现，我们看下它的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Convenience singleton for apps using a process-wide EventBus instance. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>{</span><br><span class="line">        EventBus instance = defaultInstance;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (EventBus.class) {</span><br><span class="line">                instance = EventBus.defaultInstance;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                    instance = EventBus.defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<p> 所以我们都是基于一个 <strong>static 类型的 defaultInstance</strong>去做一系列操作，由于跨进程后，静态会失效，所以，<strong>EventBus 并不能跨进程</strong>。</p>
</details>

<blockquote>
<p>以上参考自掘金<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903969517469709#heading-7">刘洋巴金的博客</a>，如果链接变得不可访问，可以参看这篇文章的<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a2f14b0cb217">Copy</a></p>
</blockquote>
<h3 id="18、ARouter-的原理"><a href="#18、ARouter-的原理" class="headerlink" title="18、ARouter 的原理"></a>18、ARouter 的原理</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>为了让业务逻辑彻底解耦，同时也为了每个module 都可以方便地单独运行和调试，上层的各个 module 不会相互依赖，而是共同依赖 base module，如下所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/%E4%B8%9A%E5%8A%A1module%E4%BE%9D%E8%B5%96baseModule.webp" alt="业务module依赖base_module"></p>
<p>由于module之间没有依赖，那如何实现业务跳转呢？ 首先，<strong>隐式跳转</strong>是一种可行的解决方案，但如果一个项目里面全是隐式跳转的，就会导致 Manifest 文件中有很多过滤配置，并且非常不利于后期维护。其实，<strong>在组件化中，我们通常都会在 base_module 上层再依赖一个 router_module ，这个 router_module 就是负责各个模块之间的页面跳转的</strong>。</p>
<h3 id="ARouter-源码理解"><a href="#ARouter-源码理解" class="headerlink" title="ARouter 源码理解"></a>ARouter 源码理解</h3><p>用过 ARouter的都知道，每个需要对其他 module 提供调用的 Activity ，在声明的时候都会带有 @Router 注解，我们称之为路由地址，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Router(path=/main/main)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个注解有什么用呢？路由框架会在项目编译期通过<strong>注解处理器扫描所有添加@Router注解的类</strong>，之后，将Router 注解中的 path 地址 和 Activity 的 class 文件映射关系保存到它自己生成的 java 文件中，示例如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, ClassBean&gt; <span class="title">getRouteInfo</span><span class="params">(HashMap(String, ClassBean)</span> routes) </span>{</span><br><span class="line">  routes.put(<span class="string">"/main/main"</span>, MainActivity.class);</span><br><span class="line">  routes.put(<span class="string">"/login/login"</span>, LoginActivity.class);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这样，我们想在app 模块之间跳转，就可以通过这个映射关系找到目标了，一般使用方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().build(<span class="string">"/login/login"</span>)</span><br><span class="line">            .withString(<span class="string">"password"</span>, <span class="number">666666</span>)</span><br><span class="line">            .withString(<span class="string">"name"</span>, <span class="string">"小三"</span>)</span><br><span class="line">            .navigation();</span><br></pre></td></tr></tbody></table></figure>

<p>上述例子中，通过 /login/login 可以找到对应的class ： LoginActivity.class ，最终会通过 ActivityCompat.startActivity() 方式启动目标Activity。</p>
<p>ARouter在初始化的时候只会一次性地加载所有的Root结点，而不会加载任何一个Group结点，这样就会极大地降低初始化时加载结点的数量。那么什么时候加载分组结点呢？其实就是当某一个分组下的某一个页面第一次被访问的时候，整个分组的全部页面都会被加载进去，这就是ARouter的按需加载。其实在整个APP运行的周期中，并不是所有的页面都需要被访问到，可能只有20%的页面能够被访问到，所以这时候使用按需加载的策略就显得非常重要了，这样就会减轻很大的内存压力。</p>
<p>其他细节略</p>
</details>



<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/C2Izps9HIF0cELAH1I76lw">玉刚说上的文章</a>(如果玉刚说的文章么有了可以参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/857aea5b54a8">简书上的原文</a>)、<a target="_blank" rel="noopener" href="https://blog.csdn.net/lbcwnu/article/details/86249671">CSDN上的博客</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/19/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC1%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/19/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC1%E7%AB%A0/" class="post-title-link" itemprop="url">第1章：Android系统架构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-19 22:26:00" itemprop="dateCreated datePublished" datetime="2019-11-19T22:26:00+08:00">2019-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-04 11:33:01" itemprop="dateModified" datetime="2020-01-04T11:33:01+08:00">2020-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>分为五层，从上往下依次是应用层、应用框架层、系统运行库层、硬件抽象层和Linux内核层。</p>
<ul>
<li>应用层(System Apps)：系统内置的应用程序以及非系统级的应用程序都属于应用层，负责与用户进行直接交互。    </li>
<li>应用框架层(Java API FrameWork)：应用框架层为开发人员提供了开发应用程序所需要的API，我们平时开发应用程序都是调用这一层提供的API。    </li>
<li>系统运行库层(Native)：系统运行库层分为两部分：分别是C/C++程序库和Android运行时库。运行时库又分为核心库和ART(Dalvik)，核心库提供了Java语言核心库的大多数功能，这样开发者可以使用Java语言来编写Android应用。     </li>
<li>硬件抽象层(HAL)：硬件抽象层是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商的知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台。    </li>
<li>Linux内核层(Linux Kernel)：Android 的核心系统服务基于Linux内核，在此基础上添加了部分Android专用驱动。</li>
</ul>
<h2 id="Android系统源码目录"><a href="#Android系统源码目录" class="headerlink" title="Android系统源码目录"></a>Android系统源码目录</h2><p>Android 8.0.0系统根目录结构说明如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC1%E7%AB%A0/Android%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95-1.png" alt="Android系统目录-1"></p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC1%E7%AB%A0/Android%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95-2.png" alt="Android系统目录-2"></p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层位于整个Android系统的最上层，开发者开发的应用程序以及系统内置应用程序都在应用层，它的目录结构如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC1%E7%AB%A0/%E5%BA%94%E7%94%A8%E5%B1%82%E7%9B%AE%E5%BD%95-1.png" alt="应用层目录-1"></p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC1%E7%AB%A0/%E5%BA%94%E7%94%A8%E5%B1%82%E7%9B%AE%E5%BD%95-2.png" alt="应用层目录-2"></p>
<h3 id="应用框架层部分"><a href="#应用框架层部分" class="headerlink" title="应用框架层部分"></a>应用框架层部分</h3><p>应用框架层是系统的核心部分，一方面向上提供接口给应用层调用，另一方面向下与下层进行衔接，应用框架层的主要实现代码在 frameworks/base 和 frameworks/av 目录下，其中frameworks/base 目录结构如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC1%E7%AB%A0/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E5%B1%82%E7%9B%AE%E5%BD%95.png" alt="应用框架层目录"></p>
<h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><p>系统源码阅读的方式有在线阅读和下载源码到本地用软件工具阅读。</p>
<h3 id="在线阅读"><a href="#在线阅读" class="headerlink" title="在线阅读"></a>在线阅读</h3><p>Android 在线阅读源码的网站有很多，比如：<a target="_blank" rel="noopener" href="http://androidxref.com/">http://androidxref.com/</a>,<a target="_blank" rel="noopener" href="http://www.androidos.net.cn/">http://www.androidos.net.cn/</a>,在书中，作者推荐使用前一个url在线阅读；我个人比较推荐第二个，因为它在类搜索这块做得非常舒服，像使用google、baidu 一样容易使用，此外，它还是中文界面。</p>
<h3 id="使用Source-Insight"><a href="#使用Source-Insight" class="headerlink" title="使用Source Insight"></a>使用Source Insight</h3><p>下载源码到本地，再用软件工具阅读源码是最好的方式，不受网速影响，效率更高，本地阅读源码可以采用 Android Studio、Eclipse、Sublime 和Source Insight 等软件，这里推荐使用Source Insight 。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/18/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC10%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/18/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC10%E7%AB%A0/" class="post-title-link" itemprop="url">第10章：Java虚拟机</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-18 20:48:00" itemprop="dateCreated datePublished" datetime="2019-11-18T20:48:00+08:00">2019-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-19 21:05:34" itemprop="dateModified" datetime="2019-11-19T21:05:34+08:00">2019-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>需要注意的是，Android中的Dalvik 和 ART 并不属于Java 虚拟机。</p>
<p>当一个Java 文件经过Java编译器后会生成Class 文件，这个Class 文件会由 Java 虚拟机进行处理，Java 虚拟机与 Java 语言没有必然的联系，它只与特定的二进制文件：Class 文件有关。任何语言只要能编译成 Class 文件，都能被Java 虚拟机识别并执行。</p>
<h2 id="Java虚拟机结构"><a href="#Java虚拟机结构" class="headerlink" title="Java虚拟机结构"></a>Java虚拟机结构</h2><p>按照Java虚拟机规范，抽象的Java 虚拟机如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC10%E7%AB%A0/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BB%93%E6%9E%84.png" alt="Java虚拟机结构"></p>
<p>从图可以看出，Java虚拟机结构包括 运行时数据区域、执行引擎、本地库接口和本地方法库，其中类加载子系统并不属于Java 虚拟机的内部结构。下面针对这个图来介绍Android 开发需要掌握的Class 文件格式和运行时数据区域。</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>类的生命周期如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC10%E7%AB%A0/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="类的生命周期"></p>
<p>类加载的各个阶段的工作：</p>
<ol>
<li><p>加载： 查找并加载Class文件    </p>
</li>
<li><p>连接： 包括验证、准备和解析    </p>
<ul>
<li>验证：确保被导入类型的正确性     </li>
<li>准备：为类的**静态字段分配字段，并用默认值初始化这些字段    </li>
<li>解析：虚拟机将常量池内的符号引用替换为直接引用    </li>
</ul>
</li>
<li><p>初始化： 将类变量初始化为正确的初始值。    </p>
</li>
</ol>
<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>可取的几点：</p>
<ul>
<li>为了在线程切换后能恢复到正确的执行位置，每个线程都会有个独立的程序计数器。如果线程执行的方法是Native方法，则程序计数器的值为空(Undefined)，否则，保存正在执行的字节码指令地址。    </li>
<li>可以选择在方法区不显示垃圾收集    </li>
</ul>
<p>其他的可以参考深入理解Java虚拟机的<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/04/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0/">这篇文章</a>即可。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>当虚拟机接收到一个 new 指令时，它会做如下操作：</p>
<ol>
<li>判断对象对应的类是否加载、链接、以及初始化。    </li>
<li>为对象分配内存：如果内存规整，则只需要将指针指示器向空闲的内存移动若干距离即可；若不规整，则需要由虚拟机维护一个列表记录哪些内存是可用的。</li>
<li>处理并发安全问题，有两种方式解决：   <ul>
<li>对分配内存空间的动作做同步处理，比如采用 CAS 方式配合失败重试</li>
<li>为每个线程在Java堆中预先分配一小块内存，只有这块内存被使用完后，才需要同步的方式分配新的内存。</li>
</ul>
</li>
<li>初始化分配到的内存空间：将分配到的内存，出对象头以外都初始化为零值。     </li>
<li>设置对象的对象头：将对象所属的类、对象的hashcode、以及GC分代年龄等存放在对象头。    </li>
<li>执行init方法进行初始化。</li>
</ol>
<h2 id="垃圾标记算法"><a href="#垃圾标记算法" class="headerlink" title="垃圾标记算法"></a>垃圾标记算法</h2><p>GC 主要做两个工作：一是内存的划分和分配，二是对垃圾进行回收。关于内存的划分和分配，目前Java虚拟机内存的划分是依赖于GC 的，比如现在的GC 都采用分代收集算法来回收垃圾的。<strong>Java 堆作为GC 的主要管理区域</strong>，被细分为新生代和老年代。</p>
<blockquote>
<p>查看gc日志的时候，[GC(Systemt.gc()) 和 [Full GC(Systemt.gc() 用于说明此次垃圾收集的<strong>停顿类型(而非区分新生代和老年代)</strong>，后者表示此次GC发生了 STW(Stop the World，只有GC线程在运行，其他线程都暂停)。</p>
</blockquote>
<p>其余主要内容，<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/">参考以前写的这篇文章</a></p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>首先标记可以被回收的对象，之后回收被标记的对象所占的空间。它主要有两大缺点：一个是标记和清除两个过程的效率都不高，另一个就是，容易产生大量的内存碎片，<strong>碎片太多可能会导致没有足够的连续内存分配给较大的对象</strong>，从而提前触发新的GC。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>把空间分为两个相等部分，每次只使用其中一部分，垃圾收集时，把存货的对象复制到另一部分，再把当前部分全部清理掉，这样不需要考虑碎片化问题，缺点就是可用内存变为了原来的一半。</p>
<h3 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h3><p>新生代一半存活的对象比较少，可以使用复制算法，但是老年代不能选择复制算法了，因为老年代的对象存活率会较高，这样会有很多复制操作，导致效率降低。它的主要方式是，在标记可回收的对象后，将所有还存活的对象压缩到内存的一端，使它们紧凑地排列在一起，然后对边界外的内存进行回收。<strong>标记-压缩算法解决了标记-清除算法容易产生大量内存碎片的问题，但是它的效率仍然是很低的。</strong></p>
<h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p>垃圾收集的类型分为两种，分别是：</p>
<ul>
<li>Minor Collection: 新生代垃圾收集    </li>
<li>Full Collection: 老年代垃圾收集，也称 Major Collection， Full Collection 通常会伴随至少一次的 Minor Collection。 Full Collection 收集频率低，耗时长。</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/15/%E9%9D%A2-%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-LeetCode-%E4%B9%A6%E7%B1%8D-%E5%89%91%E6%8C%87offer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/15/%E9%9D%A2-%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-LeetCode-%E4%B9%A6%E7%B1%8D-%E5%89%91%E6%8C%87offer/" class="post-title-link" itemprop="url">面试题-算法-LeetCode-书籍-剑指offer</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-15 20:58:00" itemprop="dateCreated datePublished" datetime="2019-11-15T20:58:00+08:00">2019-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-11 20:43:35" itemprop="dateModified" datetime="2020-04-11T20:43:35+08:00">2020-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="LeetCode-剑指offer系列"><a href="#LeetCode-剑指offer系列" class="headerlink" title="LeetCode-剑指offer系列"></a>LeetCode-剑指offer系列</h2><hr>
<h3 id="面试题03、数组中重复的数字"><a href="#面试题03、数组中重复的数字" class="headerlink" title="面试题03、数组中重复的数字"></a>面试题03、数组中重复的数字</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>HashSet 是否添加进去了</p>
<p>自己写的时候的问题：<strong>没啥，用hashset 搞定，但是忘了 new 关键字。。。</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-b-4/">力扣</a></p>
</blockquote>
<h3 id="面试题04、二维数组中的查找"><a href="#面试题04、二维数组中的查找" class="headerlink" title="面试题04、二维数组中的查找"></a>面试题04、二维数组中的查找</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>左下角标志法     </p>
<p>自己写的时候的问题：<strong>自己写得完美，没问题。为了加深印象，我们说行数 rowNum = matrix.length;  columnNum = matrix[0].length,  之后从左下角开始即可。</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/">力扣</a></p>
</blockquote>
<h3 id="面试题05、替换String空格"><a href="#面试题05、替换String空格" class="headerlink" title="面试题05、替换String空格"></a>面试题05、替换String空格</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>使用 StringBuilder</p>
<p>自己写的时候的问题：<strong>没啥问题，StringBuilder 疯狂拼接即可</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/">力扣</a></p>
</blockquote>
<h3 id="面试题10-I、斐波那契数列由-0-和-1-开始，之后的斐波那契数就是由之前的两数相加而得出，求第n个数，但是结果要对-1000000007，如计算初始结果为：1000000008，请返回-1。"><a href="#面试题10-I、斐波那契数列由-0-和-1-开始，之后的斐波那契数就是由之前的两数相加而得出，求第n个数，但是结果要对-1000000007，如计算初始结果为：1000000008，请返回-1。" class="headerlink" title="面试题10-I、斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出，求第n个数，但是结果要对 1000000007，如计算初始结果为：1000000008，请返回 1。"></a>面试题10-I、斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出，求第n个数，但是结果要对 1000000007，如计算初始结果为：1000000008，请返回 1。</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>使用 StringBuilder</p>
<p>自己写的时候的问题：<strong>大体上使用数组是对的，但是在做计算的时候写成了： arrs[i] = arrs[i - 1]%mod + arrs[i-2] % mod;，而实际上应该写成： arrs[i] = (arrs[i - 1] + arrs[i-2]) % mod; 以后要注意</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/zhi-xing-yong-shi-0-ms-zai-suo-you-java-ti-jiao-96/">力扣</a></p>
</blockquote>
<p>还可以延伸<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/mian-shi-ti-10-ii-qing-wa-tiao-tai-jie-wen-ti-dong/">青蛙跳台阶问题</a></p>
<h3 id="面试题11、旋转数组的最小数字"><a href="#面试题11、旋转数组的最小数字" class="headerlink" title="面试题11、旋转数组的最小数字"></a>面试题11、旋转数组的最小数字</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>二分法</p>
<p>自己写的时候的问题：<strong>没啥难，就是要注意细节，1、没有旋转的情况  2、所有数字都相同的情况  3、只有一个数字的情况  4、剩下的就是从后面往前面找，当到某一个数字它的前面一个数字比当前数字大的时候，那最小数字就是当前数字了。</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/">力扣</a></p>
</blockquote>
<h3 id="面试题15、二进制中1的个数"><a href="#面试题15、二进制中1的个数" class="headerlink" title="面试题15、二进制中1的个数"></a>面试题15、二进制中1的个数</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>n &amp; (n -1)</p>
<p>自己写的时候的问题：<strong>没啥，还是 n &amp; (n-1)</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/">力扣</a></p>
</blockquote>
<h3 id="面试题18、删除链表的节点"><a href="#面试题18、删除链表的节点" class="headerlink" title="面试题18、删除链表的节点"></a>面试题18、删除链表的节点</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>两个指针</p>
<p>自己写的时候的问题：<strong>没啥，处理好head，之后就是常用的pre 指针、current 指针了</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/solution/mian-shi-ti-18-shan-chu-lian-biao-de-jie-dian-shua/">力扣</a></p>
</blockquote>
<h3 id="面试题21、-调整数组顺序使奇数位于偶数前面"><a href="#面试题21、-调整数组顺序使奇数位于偶数前面" class="headerlink" title="面试题21、 调整数组顺序使奇数位于偶数前面"></a>面试题21、 调整数组顺序使奇数位于偶数前面</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首尾双指针</p>
<p>自己写的时候的问题：<strong>没啥，很顺利。双指针，快排思想</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/solution/ti-jie-shou-wei-shuang-zhi-zhen-kuai-man-shuang-zh/">力扣</a></p>
</blockquote>
<h3 id="面试题22、-链表中倒数第k个节点"><a href="#面试题22、-链表中倒数第k个节点" class="headerlink" title="面试题22、 链表中倒数第k个节点"></a>面试题22、 链表中倒数第k个节点</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>前后指针</p>
<p>自己写的时候的问题：<strong>没啥，快慢指针，快指针先走k步</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/javajie-fa-shuang-zhi-zhen-by-shi-na-de-ya/">力扣</a></p>
</blockquote>
<h3 id="面试题24、-反转链表。反转一个单链表，如输入：-1-gt-2-gt-3-gt-4-gt-5-gt-Null-，则输出：5-gt-4-gt-3-gt-2-gt-1-gt-Null"><a href="#面试题24、-反转链表。反转一个单链表，如输入：-1-gt-2-gt-3-gt-4-gt-5-gt-Null-，则输出：5-gt-4-gt-3-gt-2-gt-1-gt-Null" class="headerlink" title="面试题24、 反转链表。反转一个单链表，如输入： 1->2->3->4->5->Null  ，则输出：5->4->3->2->1->Null"></a>面试题24、 反转链表。反转一个单链表，如输入： 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;Null  ，则输出：5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;Null</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>存储当前节点和上一个节点</p>
<p>自己写的时候的问题：<strong>没啥，搞个pre</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/">LeetCode</a></p>
</blockquote>
<h3 id="面试题25、-合并两个排序的链表"><a href="#面试题25、-合并两个排序的链表" class="headerlink" title="面试题25、 合并两个排序的链表"></a>面试题25、 合并两个排序的链表</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>一个链表到表尾之后，需要接上另一个表的剩余部分</p>
<p>自己写的时候的问题：<strong>没啥，造一个空节点</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/solution/tu-jie-jian-zhi-offerzhi-he-bing-liang-ge-pai-xu-d/">力扣</a></p>
</blockquote>
<h3 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>两个栈，一个维持压入数据，一个维持最小数栈，注意相同最小值要都压入最小数栈</p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/shuang-zhan-wei-hu-jie-fa-ji-linkedlistjie-fa-by-c/">力扣</a></p>
</blockquote>
<h3 id="面试题39、-数组中出现次数超过一半的数字"><a href="#面试题39、-数组中出现次数超过一半的数字" class="headerlink" title="面试题39、 数组中出现次数超过一半的数字"></a>面试题39、 数组中出现次数超过一半的数字</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>既然出现次数超过一半 那么排序后在中间的就是所需数字</p>
<p>自己写的时候的问题：<strong>先排序后取值不难，但是时间复杂度太高，提交的时候耗时1.3s；使用hashMap 计数，也不难，只是略微繁琐，还有 HashMap 额外占用空间。要熟练 摩尔计数法，这才是最优解。</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution/ji-ran-chu-xian-ci-shu-chao-guo-yi-ban-na-yao-pai-/">力扣</a></p>
</blockquote>
<h3 id="面试题40、最小的k个数"><a href="#面试题40、最小的k个数" class="headerlink" title="面试题40、最小的k个数"></a>面试题40、最小的k个数</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>大顶堆</p>
<p>自己写的时候的问题：<strong>暂时还没做</strong></p>
</details>

<p>还可以引申<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/">数据流中中位数</a></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/javada-ding-dui-shi-xian-by-lsz/">力扣</a></p>
</blockquote>
<h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>要么取大值，要么另起炉灶</p>
<p>自己写的时候的问题：<strong>与之前写的 力扣53题的答案，这次更加简洁粗暴，直接判断result &lt; 0 是否成立，成立就放弃result，否则就还让它继续 result += element;重点记住这个答案就好</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/6xing-dai-ma-1ms-3xing-jie-shi-by-18716060157/">力扣</a></p>
</blockquote>
<h3 id="面试题50、第一个只出现一次的字符"><a href="#面试题50、第一个只出现一次的字符" class="headerlink" title="面试题50、第一个只出现一次的字符"></a>面试题50、第一个只出现一次的字符</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>hashmap 存储次数</p>
<p>自己写的时候的问题：<strong>HashMap 辅助，没啥难度。在 字符出现次数 &gt; 1 的时候，不要尝试去增加它的次数，节省put 操作。 因为 2次 和 100次 对我们意义是一样的</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/solution/java-shi-yong-ha-xi-biao-chang-gui-jie-fa-by-panc-/">力扣</a></p>
</blockquote>
<h3 id="面试题52、两个链表的第一个公共节点"><a href="#面试题52、两个链表的第一个公共节点" class="headerlink" title="面试题52、两个链表的第一个公共节点"></a>面试题52、两个链表的第一个公共节点</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。这样，当它们相遇时，所指向的结点就是第一个公共结点</p>
<p>自己写的时候的问题：<strong>刚开始脑抽只允许一个转换，其实 应该 A 和B两个链表应该各有一次转换机会。</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/shuang-zhi-zhen-fa-lang-man-xiang-yu-by-ml-zimingm/">力扣</a></p>
</blockquote>
<h3 id="面试题53-I、在排序数组中查找数字-I，统计一个数字在排序数组中出现的次数"><a href="#面试题53-I、在排序数组中查找数字-I，统计一个数字在排序数组中出现的次数" class="headerlink" title="面试题53 - I、在排序数组中查找数字 I，统计一个数字在排序数组中出现的次数"></a>面试题53 - I、在排序数组中查找数字 I，统计一个数字在排序数组中出现的次数</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>二分法</p>
<p>自己写的时候的问题：<strong>自己写没问题，二分查找没毛病。</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/java-liang-chong-er-fen-cha-zhao-fang-fa-by-caixia/">力扣</a></p>
</blockquote>
<h3 id="面试题53-II-0～n-1中缺失的数字。一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字"><a href="#面试题53-II-0～n-1中缺失的数字。一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字" class="headerlink" title="面试题53 - II. 0～n-1中缺失的数字。一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字"></a>面试题53 - II. 0～n-1中缺失的数字。一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>解法1：与下标是否相等 解法2：求和？(要考虑溢出)  解法3：二分法</p>
<p>自己写的时候的问题：<strong>在数组下标都对应得上的时候，缺失的就是最后一个数字，写的时候没想到这点。</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/solution/java-yi-ci-bian-li-hen-jian-dan-by-guard-2/">力扣</a></p>
</blockquote>
<h3 id="面试题56-I、数组中数字出现的次数。一个整型数组-nums-里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O-n-，空间复杂度是O-1"><a href="#面试题56-I、数组中数字出现的次数。一个整型数组-nums-里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O-n-，空间复杂度是O-1" class="headerlink" title="面试题56 - I、数组中数字出现的次数。一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)"></a>面试题56 - I、数组中数字出现的次数。一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>异或-&gt; 数字分组</p>
<p>自己写的时候的问题：<strong>不太熟练，自己只能想到全员异或，然后分组，之后想不到了。其实在分组过后，每组元素都是由 若干个出现两次的数字和一个只出现一次的数字  组成，组内异或就能得到那个只出现一次的数字。</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/zhi-chu-xian-yi-ci-de-shu-xi-lie-wei-yun-suan-by-a/">力扣</a></p>
</blockquote>
<h3 id="给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素"><a href="#给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素" class="headerlink" title="给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素"></a>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>全员异或</p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/solution/cou-yi-pian-ti-jie-hua-shuo-ti-jie-hen-hao-wan-by-/">力扣</a></p>
</blockquote>
<h3 id="面试题57、和为s的两个数字。输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可"><a href="#面试题57、和为s的两个数字。输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可" class="headerlink" title="面试题57、和为s的两个数字。输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可"></a>面试题57、和为s的两个数字。输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>双指针即可</p>
<p>自己写的时候的问题：<strong>没啥说的，提交完美。双指针即可</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/solution/2msshuang-100-by-wei-yu-13/">力扣</a></p>
</blockquote>
<h3 id="面试题58-I、翻转单词顺序。输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I-am-a-student-“，则输出”student-a-am-I”"><a href="#面试题58-I、翻转单词顺序。输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I-am-a-student-“，则输出”student-a-am-I”" class="headerlink" title="面试题58 - I、翻转单词顺序。输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”"></a>面试题58 - I、翻转单词顺序。输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>两次翻转</p>
<p>自己写的时候的问题：<strong>这题目本身就有点坑爹，注意审题，因为它首尾的空格要求在结果中去掉，并且单词间有多个空格也只保留一个。还有，清空StringBuilder 可以使用 sb.setLength(0) 的方式。其他的倒是没啥。</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/fan-zhuan-dan-ci-shun-xu-by-peterbrave/">力扣</a></p>
</blockquote>
<h3 id="面试题58-II、-左旋转字符串。字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”"><a href="#面试题58-II、-左旋转字符串。字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”" class="headerlink" title="面试题58 - II、 左旋转字符串。字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”"></a>面试题58 - II、 左旋转字符串。字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>subString即可</p>
<p>自己写的时候的问题：<strong>没啥，StringBuilder 拼接，简单粗暴</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/javaqie-pian-pin-jie-fa-by-abner-42/">leetcode</a></p>
</blockquote>
<h3 id="面试题59-I、-滑动窗口的最大值。给定一个数组-nums-和滑动窗口的大小-k，请找出所有滑动窗口里的最大值"><a href="#面试题59-I、-滑动窗口的最大值。给定一个数组-nums-和滑动窗口的大小-k，请找出所有滑动窗口里的最大值" class="headerlink" title="面试题59 - I、 滑动窗口的最大值。给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值"></a>面试题59 - I、 滑动窗口的最大值。给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>上一次的最大值是不是被滑过的位置</p>
<p>自己写的时候的问题：<strong>自己写，不难。充分利用好上一次的最大值即可</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/bu-shi-yong-shu-ju-jie-gou-shuang-100-by-sun-239/">leetcode</a></p>
</blockquote>
<h3 id="面试题61、-扑克牌中的顺子。从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为-0-，可以看成任意数字。A-不能视为-14"><a href="#面试题61、-扑克牌中的顺子。从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为-0-，可以看成任意数字。A-不能视为-14" class="headerlink" title="面试题61、 扑克牌中的顺子。从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14"></a>面试题61、 扑克牌中的顺子。从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>根据差值计算大小王是否够用就行</p>
<p>自己写的时候的问题：<strong>看懂原理，就不难(抄别人的)： 如果我们能够知道 5 张扑克牌中的最大值 maxValue 和最小值 minValue ，那我们就知道，要使它为顺子需要 maxValue - minValue + 1 张牌，所以我们只需要计算最大最小值(0除外)，然后通过上述规律来判断。当然，如果其中有重复的数字(0除外),那么肯定凑不齐了。所以我们关键是找最大最小值，以及判断是否重复。这里面的细节很多，比如boolean[] 用来表示元素是否重复的数组，它的index 不是 遍历牌的 i ，而是牌面值，即 nums[i]</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/solution/bu-ke-pai-zhong-de-shun-zi-pai-xu-fang-shi-he-bu-p/">leetcode</a></p>
</blockquote>
<h3 id="面试题62、圆圈中最后剩下的数字。0-1-n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字"><a href="#面试题62、圆圈中最后剩下的数字。0-1-n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字" class="headerlink" title="面试题62、圆圈中最后剩下的数字。0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字"></a>面试题62、圆圈中最后剩下的数字。0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>约瑟夫环，记得公式就行（返回的是数组下标）</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cir</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	{</span><br><span class="line">		p=(p+m)%i;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</details>

<blockquote>
<p>题目<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">leetcode</a>、解答参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011500062/article/details/72855826">csdn</a></p>
</blockquote>
<h3 id="面试题65、不用加减乘除做加法。写一个函数，求两个整数之和，要求在函数体内不得使用-“-”、“-”、“-”、“-”-四则运算符号"><a href="#面试题65、不用加减乘除做加法。写一个函数，求两个整数之和，要求在函数体内不得使用-“-”、“-”、“-”、“-”-四则运算符号" class="headerlink" title="面试题65、不用加减乘除做加法。写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号"></a>面试题65、不用加减乘除做加法。写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>异或操作</p>
<p>自己写的时候的问题：<strong>凭记忆做出来了，后续还是要加强。 注意一点再java中不要做 &lt;&lt;&lt; 操作，非法的。</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/ni-hao-fan-te-xi-by-chen-san-shi/">leetcode</a></p>
</blockquote>
<h3 id="面试题66、给定一个数组-A-0-1-…-n-1-，请构建一个数组-B-0-1-…-n-1-，其中-B-中的元素-B-i-A-0-×A-1-×…×A-i-1-×A-i-1-×…×A-n-1-。不能使用除法。"><a href="#面试题66、给定一个数组-A-0-1-…-n-1-，请构建一个数组-B-0-1-…-n-1-，其中-B-中的元素-B-i-A-0-×A-1-×…×A-i-1-×A-i-1-×…×A-n-1-。不能使用除法。" class="headerlink" title="面试题66、给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。"></a>面试题66、给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>对称数组</p>
<p>自己写的时候的问题：<strong>似懂非懂</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/solution/gou-jian-cheng-ji-shu-zu-dui-cheng-bian-li-by-huwt/">leetcode</a></p>
</blockquote>
<h3 id="66、加一，给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一，最高位存放在数组收尾，数组中每个元素只存储单个数字，可以假设除了0之外，这个整数不会以0开头。假如输入：-1-2-3-，代表123，则输出-1-2-4-；输入-4-3-2-1-，代表-4321，则输出-4-3-2-2"><a href="#66、加一，给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一，最高位存放在数组收尾，数组中每个元素只存储单个数字，可以假设除了0之外，这个整数不会以0开头。假如输入：-1-2-3-，代表123，则输出-1-2-4-；输入-4-3-2-1-，代表-4321，则输出-4-3-2-2" class="headerlink" title="66、加一，给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一，最高位存放在数组收尾，数组中每个元素只存储单个数字，可以假设除了0之外，这个整数不会以0开头。假如输入：[1,2,3] ，代表123，则输出 [1,2,4]；输入 [4,3,2,1] ，代表 4321，则输出 [4,3,2,2]"></a>66、加一，给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一，最高位存放在数组收尾，数组中每个元素只存储单个数字，可以假设除了0之外，这个整数不会以0开头。假如输入：[1,2,3] ，代表123，则输出 [1,2,4]；输入 [4,3,2,1] ，代表 4321，则输出 [4,3,2,2]</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>它只是加一的话，可能的情况只有两种：</p>
<ul>
<li>除9之外的数字加一    </li>
<li>数字9加一<br>加一得十，进一位，个位数为0；如加法运算不出现进位，则运算就结束了。还有一种情况就是 当出现 9，99，999 之类的数字时，循环到最后也需要进位，需要手动将它进一位</li>
</ul>
<p>自己写的时候的问题：<strong>没啥问题，遍历每个元素让每个元素 +1 ，当某个元素 +1 之后 &lt; 10,就将当前数组返回；否则，加到最后也还没返回，就要新建一个数组，最开始位为1</strong></p>
</details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/plus-one/solution/java-shu-xue-jie-ti-by-yhhzw/">LeetCode</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/11/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/11/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">面试题-多线程知识</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-11 21:02:00" itemprop="dateCreated datePublished" datetime="2019-11-11T21:02:00+08:00">2019-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-27 15:10:25" itemprop="dateModified" datetime="2020-06-27T15:10:25+08:00">2020-06-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1、线程同步，你了解哪几种方式？"><a href="#1、线程同步，你了解哪几种方式？" class="headerlink" title="1、线程同步，你了解哪几种方式？"></a>1、线程同步，你了解哪几种方式？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<ol>
<li>数据同步：可以使用Android 提供的同步容器。如： CopyOnWriteArrayList（当某个线程要修改list的元素时，首先copy一份出来，然后在修改前加锁，防止多个线程同时修改而copy多个副本，读的时候无需加锁，读的是副本）、concurrentHashMap（分段锁）、BlockingQueue（队列满了，在调用put，会阻塞，直到不再是满的；同理，取也是一样）。</li>
<li>用锁。同步锁：synchronize（无论synchronized关键字加在方法上还是对象上，他锁的都是对象，而不是把一段代码或函数当作锁）、ReentrantLock</li>
</ol>
</blockquote>
</details>

<h2 id="2、synchronized-与-Lock。讲下-RecentLock-可重入锁？-什么是可重入锁？为什么要设计可重入锁？"><a href="#2、synchronized-与-Lock。讲下-RecentLock-可重入锁？-什么是可重入锁？为什么要设计可重入锁？" class="headerlink" title="2、synchronized 与 Lock。讲下 RecentLock 可重入锁？ 什么是可重入锁？为什么要设计可重入锁？"></a>2、synchronized 与 Lock。讲下 RecentLock 可重入锁？ 什么是可重入锁？为什么要设计可重入锁？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<p><strong>介绍：</strong>synchronized：无论synchronized关键字加在方法上还是对象上，他锁的都是对象，而不是把一段代码或函数当作锁。<br>Lock：一般使用ReentrantLock类做为锁，需要显式指出加锁与释放锁的位置，在加锁和解锁处通过lock()和unlock()显示指出，所以一般会在finally块中写unlock()以防死锁。  </p>
</blockquote>
<blockquote>
<p><strong>区别：</strong>  </p>
</blockquote>
<ul>
<li>synchronized 是个关键字，而 Lock 是个接口  </li>
<li>synchronized 使用简单，会自动释放；Lock需要显式加锁与释放，要防止死锁  </li>
<li>synchronized是悲观锁，其他线程只能阻塞来等待线程释放锁；Lock是乐观锁。  </li>
<li>lock可以使我们多线程交互变得方便，而使用synchronized则无法做到这点。如：某个线程在等待锁的过程中需要中断、或者获知某个线程有没有获取到锁、或者需要指定notify哪个线程</li>
</ul>
</details>

<h2 id="3、为什么wait、notify、notifyAll-方法在object-类中，而sleep-在Thread-类中？"><a href="#3、为什么wait、notify、notifyAll-方法在object-类中，而sleep-在Thread-类中？" class="headerlink" title="3、为什么wait、notify、notifyAll 方法在object 类中，而sleep 在Thread 类中？"></a>3、为什么wait、notify、notifyAll 方法在object 类中，而sleep 在Thread 类中？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>一个例子，假如要做的事情是“生火-烧水-煮面”。sleep 就是，当我生火之后，觉得有点累，要休息一段时间，所以并不立即烧水，等过会再烧，休息的这段时间是由我自己来控制的，这个灶台我也要一直占用；而对于wait，首先，wait 是由某个object 来调用的，这个object 类似于监督人的角色，当我点火在烧水的过程中，监督人要求我停下来，不允许我继续烧水了，同时剥夺我灶台使用权，让其他人先用灶台，我在旁边等着，直到这个监督人通知(notify/notifyAll)我可以继续使用灶台了，我才能继续。</p>
<p>通过这个例子，我们可以知道：</p>
<ul>
<li>首先，sleep 和 其他的是有本质区别的：sleep 是一个线程的运行状态控制，所以交给Thread 自己更合适；而wait 是线程之间的通讯工具，交给object更合适，这样各个竞争线程不需要知道彼此的存在。       </li>
<li>其次，wait、notify与notifyAll 是锁级别的操作，而锁属于对象，每个对象都可能作为锁，所以它们定义在Object 类中。       </li>
</ul>
<p>从另一个角度来说是，假如不这样做的话，即如果wait、notify和notifyAll 都在Thread 中，会有什么问题：</p>
<p>首先，wait 方法仍然可以使当前线程挂起，但是挂起后怎么被其他线程唤起呢？因为唤起时需要知道要唤起哪个线程。<br>其次，notify 与 notifyAll 都需要知道目前需要唤醒哪些线程。</p>
<p>当然你可以说我们使用共享变量或者其他方式，这无疑会增加线程间通信的复杂性，并带来安全隐患，所以并没有必要。</p>
<blockquote>
<p>值得注意的是：必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()、notify()或notifyAll()方法。原因很简单，如果这个代码块或者方法不是同步的，那么进入其中必然是不需要获取锁的，所以释放锁和等待锁就无从谈起，这时候调用的话会报 IllegalMonitorStateException。Java 给报这个错，其实就是不想让我们的程序在不经意间出现 Lost Wake-Up 问题。</p>
</blockquote>
<blockquote>
<p>以上内容<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuzhe_2008/article/details/36901737">参考csdn的这篇文章</a></p>
</blockquote>
</details>

<h2 id="4、延伸-深究-notify-wait-方法为什么一定要放在同步块中？"><a href="#4、延伸-深究-notify-wait-方法为什么一定要放在同步块中？" class="headerlink" title="4、延伸-深究 notify/wait 方法为什么一定要放在同步块中？"></a>4、延伸-深究 notify/wait 方法为什么一定要放在同步块中？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>前面谈到的是没有同步就没必要释放或者等待锁，这里深究如果不放在同步块中会出现什么问题。这主要是涉及到 <strong>“Lost Wake-Up Problem”</strong>问题。</p>
<p>我们notify/wait 很典型的一个用途就是生产者-消费者 场景，伪代码如下：</p>
<p>生产者：</p>
<blockquote>
<p>count ++;<br>notify();    </p>
</blockquote>
<p>消费者：</p>
<blockquote>
<p>while(count &lt;= 0) wait();<br>count –;    </p>
</blockquote>
<p>生产者和消费着都有两个步骤，如果不在同步块中的话，多线程情况下执行顺序很难保证，有可能会出现如下图所示的执行顺序：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E4%B9%B1%E5%BA%8F.png" alt="生产消费乱序"></p>
<p>初始的时候，count == 0，消费者发现条件成立，此时，发生上下文切换，生产者线程一顿操作执行了 count ++，之后发出了通知准备唤醒一个线程，这时候消费者刚决定wait，但是还没进入wait，此时，由于消费者线程还未进入wait状态，因此在等待队列中还找不到消费者线程，这个notify就被丢掉了。</p>
<blockquote>
<p>以上内容<a target="_blank" rel="noopener" href="https://blog.csdn.net/belalds/article/details/89225104">参考自360linker</a>的博客</p>
</blockquote>
</details>

<h2 id="5、两个线程交替打印，一个输出偶数，一个输出奇数"><a href="#5、两个线程交替打印，一个输出偶数，一个输出奇数" class="headerlink" title="5、两个线程交替打印，一个输出偶数，一个输出奇数"></a>5、两个线程交替打印，一个输出偶数，一个输出奇数</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>第一种，使用synchronize 关键字，锁住对象，每次只能一个线程进入。每打印一个数，就释放锁，然后挂起自己，如此往复：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MainClass obj = <span class="keyword">new</span> MainClass();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(obj::printOdds);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(obj::printEven);</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printOdds</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i += <span class="number">2</span>) {</span><br><span class="line">            System.out.println(<span class="string">"t1---"</span> + i);</span><br><span class="line">            notify();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printEven</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i += <span class="number">2</span>) {</span><br><span class="line">            System.out.println(<span class="string">"t2---"</span> + i);</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>第二种，使用volatile 来保证:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                <span class="keyword">for</span> (;num&lt;=<span class="number">100</span>;){</span><br><span class="line">                    <span class="keyword">if</span> (!flag &amp;&amp; (num == <span class="number">0</span> || ++num %<span class="number">2</span> == <span class="number">0</span>)){<span class="comment">//打印偶数</span></span><br><span class="line">                        System.out.println(num);</span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                <span class="keyword">for</span> (;num&lt;<span class="number">100</span>;){</span><br><span class="line">                    <span class="keyword">if</span> (flag &amp;&amp; ++num %<span class="number">2</span> != <span class="number">0</span>){<span class="comment">//打印奇数</span></span><br><span class="line">                        System.out.println(num);</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码中 num 和flag 都必须为volatile ，根据短路机制，if 语句中基本上只需要管 flag的值，所以即使 ++num 这个操作是非原子性的，也无妨。</p>
<blockquote>
<p>以上内容参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/stateis0/p/9091254.html">莫那.鲁道的博客</a></p>
</blockquote>
<h3 id="如何控制某个方法允许并发访问线程的个数？"><a href="#如何控制某个方法允许并发访问线程的个数？" class="headerlink" title="如何控制某个方法允许并发访问线程的个数？"></a>如何控制某个方法允许并发访问线程的个数？</h3></details>

<h2 id="6、Java创建线程的三种方式"><a href="#6、Java创建线程的三种方式" class="headerlink" title="6、Java创建线程的三种方式"></a>6、Java创建线程的三种方式</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>继承Thread类。优点：使用简单 缺点：已经继承Thread 类，不能继承其它类。    </li>
<li>实现runnable 接口，创建线程类。    </li>
<li>通过Callable 和 Future 创建线程。</li>
</ul>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="https://www.androidos.net.cn/codebook/AndroidRoad/java/concurrence/CreateThread.html">Java创建线程的三种方式</a></p>
</blockquote>
</details>

<h2 id="7、synchronized原理"><a href="#7、synchronized原理" class="headerlink" title="7、synchronized原理"></a>7、synchronized原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>JVM基于进入和退出Monitor对象来实现 代码块同步 和 方法同步 ，两者实现细节不同。</p>
<p>代码块同步： 在编译后通过将monitorenter指令插入到同步代码块的开始处，将monitorexit指令插入到方法结束处和异常处，通过反编译字节码可以观察到。任何一个对象都有一个monitor与之关联，线程执行monitorenter指令时，会尝试获取对象对应的monitor的所有权，即尝试获得对象的锁。</p>
<p>方法同步： synchronized方法在method_info结构有ACC_synchronized标记，线程执行时会识别该标记，获取对应的锁，实现方法同步。</p>
<p>两者虽然实现细节不同，但本质上都是对一个对象的监视器（monitor）的获取。任意一个对象都拥有自己的监视器，当同步代码块或同步方法时，执行方法的线程必须先获得该对象的监视器才能进入同步块或同步方法，没有获取到监视器的线程将会被阻塞，并进入同步队列，状态变为BLOCKED。当成功获取监视器的线程释放了锁后，会唤醒阻塞在同步队列的线程，使其重新尝试对监视器的获取。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronize%E5%8E%9F%E7%90%86.png" alt="对象、监视器、同步队列和执行线程间的关系"></p>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="http://www.androidos.net.cn/book/android-road/java/concurrence/synchronized-reentrantlock.html">synchronized原理</a></p>
</blockquote>
</details>

<h2 id="8、线程间通信？"><a href="#8、线程间通信？" class="headerlink" title="8、线程间通信？"></a>8、线程间通信？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>1、通过内存共享，共享内存中的信息是公共可见的，但是需要显式地进行同步，可以使用Synchronize 和 Lock 来进行同步。    </p>
<p>2、notify/wait 方法</p>
<p>3、Condition 实现等待/通知</p>
<blockquote>
<p>以上内容部分参考自： <a target="_blank" rel="noopener" href="http://www.androidos.net.cn/book/android-road/java/concurrence/producer-consumer.html">线程通信</a></p>
</blockquote>
</details>

<h2 id="9、单例中，为什么要使用volatile-修饰instance？"><a href="#9、单例中，为什么要使用volatile-修饰instance？" class="headerlink" title="9、单例中，为什么要使用volatile 修饰instance？"></a>9、单例中，为什么要使用volatile 修饰instance？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:</p>
<p>1.给 instance 分配内存<br>2.调用 Singleton 的构造函数来初始化成员变量<br>3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。</p>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>
</details>

<h2 id="10、有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#10、有三个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="10、有三个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>10、有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>参考2个线程的即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                <span class="keyword">for</span> (;num&lt;=<span class="number">100</span>;){</span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="number">1</span>){</span><br><span class="line">                        ++num;</span><br><span class="line">                        System.out.println(<span class="string">"t1-"</span>+ num);</span><br><span class="line">                        flag = <span class="number">2</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                <span class="keyword">for</span> (;num&lt;<span class="number">100</span>;){</span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="number">2</span>){</span><br><span class="line">                        ++num;</span><br><span class="line">                        System.out.println(<span class="string">"t2-"</span>+ num);</span><br><span class="line">                        flag = <span class="number">3</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                <span class="keyword">for</span> (;num&lt;<span class="number">100</span>;){</span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="number">3</span>){</span><br><span class="line">                        ++num;</span><br><span class="line">                        System.out.println(<span class="string">"t3-"</span>+ num);</span><br><span class="line"></span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>

<h2 id="11、Java停止一个正在运行的线程"><a href="#11、Java停止一个正在运行的线程" class="headerlink" title="11、Java停止一个正在运行的线程"></a>11、Java停止一个正在运行的线程</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>采用经过volatile 标记的变量来控制    </li>
<li>Thread.stop() ，但是不推荐    </li>
<li>使用FutureTash 时，可以使用其 cancel() 方法来取消任务    </li>
<li>使用return 关键字    </li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(){</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"开始执行"</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">true</span>){</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"return 之后"</span>);</span><br><span class="line">        }</span><br><span class="line">    }.start();</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码只会打印 “开始执行”  ，代码中if是需要的，不然会提示编译不通过。</p>
<blockquote>
<p>以上部分内容参考自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/abreaking2012/article/details/83376951?utm_source=distribute.pc_relevant.none-task">Java如何停止线程</a></p>
</blockquote>
</details>

<h2 id="12、Java线程池工作原理"><a href="#12、Java线程池工作原理" class="headerlink" title="12、Java线程池工作原理"></a>12、Java线程池工作原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="线程池好处"><a href="#线程池好处" class="headerlink" title="线程池好处"></a>线程池好处</h3><ul>
<li>复用已经创建的线程，降低线程创建和销毁带来的损耗      </li>
<li>提高响应速度。当任务到达时，可以复用已有线程，无需等到线程创建就能立即执行    </li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制创建，不仅消耗系统资源，延长线程等待时间，还可能降低系统稳定性。</li>
</ul>
<h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h3><ol>
<li>新建状态(New)：新建一个线程对象    </li>
<li>就绪状态(Runnable)：调用线程的 start() 方法，线程变成可运行状态，其他资源都已经获取，只等cpu了     </li>
<li>运行状态(Running)：就绪状态的线程获取CPU，执行    </li>
<li>阻塞状态(Blocked)：由于某种原因放弃cpu使用权。可能是调用了线程的 wait() 方法、或者等待获取同步锁、或者是执行了sleep()或者其他线程执行了 join()    </li>
<li>死亡状态(Dead)：线程执行完了或者因为一场退出run()     </li>
</ol>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程生命周期"></p>
</details>

<blockquote>
<p>以上代码参考自：<a target="_blank" rel="noopener" href="https://itimetraveler.github.io/2018/02/13/%E3%80%90Java%E3%80%91%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">java线程池</a></p>
</blockquote>
<h2 id="13、死锁条件"><a href="#13、死锁条件" class="headerlink" title="13、死锁条件"></a>13、死锁条件</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>产生死锁的四个条件（满足才会死锁）：</p>
<ol>
<li>互斥使用    </li>
<li>不可剥夺    </li>
<li>请求保持    </li>
<li>循环等待    </li>
</ol>
<p>破坏任意一个条件即可解锁</p>
</details>

<h2 id="14、引申-写个简单的死锁程序"><a href="#14、引申-写个简单的死锁程序" class="headerlink" title="14、引申-写个简单的死锁程序"></a>14、引申-写个简单的死锁程序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">      Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">      Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">      Thread thread1 = <span class="keyword">new</span> Thread(<span class="string">"thread1"</span>){</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">              <span class="keyword">super</span>.run();</span><br><span class="line">              <span class="keyword">synchronized</span> (lock1){</span><br><span class="line">                  System.out.println(Thread.currentThread().getName() + <span class="string">"进入第1层锁"</span>);</span><br><span class="line">                  <span class="keyword">try</span> {</span><br><span class="line">                      sleep(<span class="number">1000</span>);</span><br><span class="line">                  } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  }</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">synchronized</span> (lock1){</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + <span class="string">"进入第2层锁"</span>);</span><br><span class="line">                  }</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">      };</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Thread thread2 = <span class="keyword">new</span> Thread(<span class="string">"thread1"</span>){</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">              <span class="keyword">super</span>.run();</span><br><span class="line">              <span class="keyword">synchronized</span> (lock2){</span><br><span class="line">                  System.out.println(Thread.currentThread().getName() + <span class="string">"进入第1层锁"</span>);</span><br><span class="line">                  <span class="keyword">try</span> {</span><br><span class="line">                      sleep(<span class="number">1000</span>);</span><br><span class="line">                  } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  }</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">synchronized</span> (lock2){</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + <span class="string">"进入第2层锁"</span>);</span><br><span class="line">                  }</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">      };</span><br><span class="line"></span><br><span class="line">      thread1.start();</span><br><span class="line">      thread2.start();</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>
</details>


<h2 id="15、synchronized-关键字"><a href="#15、synchronized-关键字" class="headerlink" title="15、synchronized 关键字"></a>15、synchronized 关键字</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>当执行如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        System.out.println(<span class="string">"Method 1 start"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>反编译之后能看到 monitorenter 和 monitorexit 字样，关于这两条指令，jvm中的解释如下：</p>
<blockquote>
<p>每个对象都有一个监视器锁(monitor)，当monitor 被占用时就处于锁定状态，线程执行 monitorenter 指令时，就尝试获取 monitor的所有权，过程如下：    </p>
</blockquote>
<blockquote>
<p>1、如果 monitor 的进入数为 0 ，则该线程进入 monitor，然后将进入数设置为 1，即该现成为 monitor 的所有者。    </p>
</blockquote>
<blockquote>
<p>2、如果有线程已经占有 monitor ，之后又重新进入，则 monitor 的进入数加 1。    </p>
</blockquote>
<blockquote>
<p>3、如果其他线程已经占用了 monitor ，则当前线程进入阻塞状态，直到 monitor 的进入数为 0(之后被唤醒)，再重新获取 monitor 的所有权。</p>
</blockquote>
<p>反之，monitorexit 则是线程退出的一个过程。</p>
<p>所以我们知道，修饰代码块时，synchronized 底层是通过 monitor 对象来完成的，<strong>其实，wait/notify方法也是依赖于 monitor 对象的，这也是为什么只有再同步块中才能调用 wait/notify 等方法(因为wait 等待的是啥？其实等待的就是对象的 monitor，由于所有类都是object ，里面内置有一个 monitor，因此自然所有类都应该有 wait/notify 方法)。</strong></p>
<p>在修饰成员方法时，如下代码所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>反编译过后就会有 ACC_SYNCHRONIZED 标识符(没有用 monitorenter 和 monitorexit，其实理论上也是可以的)，jvm 根据这个标识符来实现方法同步：当调用方法时，首先检查方法的 ACC_SYNCHRONIZED 标志是否被设置，如果设置了，则线程首先获取 monitor，获取成功后才能执行方法，方法执行完成后再释放 monitor，方法执行期间，其他对象无法再获得同一个 monitor。所以与修饰 代码块 的时候本质上是没有区别的。</p>
<p>最后，如果修饰的是静态方法，则锁定的是 class 对象。</p>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/paddix/p/5367116.html">Synchronized及其实现原理</a></p>
</blockquote>
</details>

<h2 id="16、synchronized-锁持有的object-是Thread-对象"><a href="#16、synchronized-锁持有的object-是Thread-对象" class="headerlink" title="16、synchronized 锁持有的object 是Thread 对象"></a>16、synchronized 锁持有的object 是Thread 对象</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>看过上面synchronized原理，我们来看一段代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Thread threadTest = <span class="keyword">new</span> Thread() {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"执行线程中方法"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    threadTest.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (threadTest) {<span class="comment">//这里不明白可以想象单例的 synchronized 用法</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            threadTest.wait();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"执行到了这里"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们知道，wait 必须在同步块中执行，上述代码也是这样的；同时我们也知道，wait() 方法后，必须收到 notify/notifyAll 之后才能结束等待状态。但是上述代码首先输出 “执行线程中方法”  ，之后输出 “执行到了这里” ，明明没有notify ，怎么就能结束 wait 状态呢？其实这是因为synchronized 获得对象锁是 Thread 对象的锁时，当该线程执行完成后，会调用线程自身的 notifyAll() 方法，通知所有等待在该线程对象上的线程。所以，用这种方式能够实现 join 的功能，使得线程依次执行。</p>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/chenkaibsw/article/details/80912878">csdn上的博客</a></p>
</blockquote>
</details>

<h2 id="17、引申-理解Java-中的-join"><a href="#17、引申-理解Java-中的-join" class="headerlink" title="17、引申-理解Java 中的 join"></a>17、引申-理解Java 中的 join</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>如果要用join 方法实现上述功能，可以这样：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Thread threadTest = <span class="keyword">new</span> Thread() {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"执行线程中方法"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    threadTest.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        threadTest.join();</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    System.out.println(<span class="string">"执行到了这里"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>join 方法从字面上理解就是新线程加入进来，等新线程执行完后，老的线程才继续执行。我们日常使用 join 方法是通过 join(0) 来实现的，我们看它的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">       <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) {</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">if</span> (millis == <span class="number">0</span>) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//如果时执行的join(0)</span></span><br><span class="line">           <span class="keyword">while</span> (isAlive()) {        <span class="comment">//如果线程是运行状态，就会执行下面的等待</span></span><br><span class="line">               wait(<span class="number">0</span>);</span><br><span class="line">           }</span><br><span class="line">       } <span class="keyword">else</span> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//如果是执行的join(time)</span></span><br><span class="line">           <span class="keyword">while</span> (isAlive()) {               <span class="comment">//如果线程时运行状态</span></span><br><span class="line">               <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">               <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) {</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               }</span><br><span class="line">               wait(delay);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="comment">//等待delay时间后自动返回继续执行</span></span><br><span class="line">               now = System.currentTimeMillis() - base;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中 while (isAlive()) { wait(0) } ，我们日常调用的 wait() 方法就是调用的 wait(0) 实现，因此这里本质还是 执行了 wait 方法，就是让其一直等待。所以我们上述代码： threadTest.join() 本质是利用 threadTest 对象作为对象锁，当线程终止时，会调用线程自身的 notifyAll ，因此这个 wait 就解除了。</p>
<p>再说下 while (isAlive())，这是在判断线程是否线程是否已经执行了start() 方法，因此如果还没有start() 则不会执行wait() 方法。可以用如下代码验证：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"t1"</span>);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                t1.join();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"t2"</span>);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    t2.start();<span class="comment">//先启动t2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    t1.start();<span class="comment">//延迟2秒后启动t1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码看起来执行了 t1.join() ，应该要等t1执行完了才会执行t2，但是呢，这里最终输出： t2  t1 ，即 t2 还是会先执行。这是因为在执行 t1.join() 的时候，t1并没有执行 start() ，isAlive() 为false，因此不生效。</p>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/chenkaibsw/article/details/80912878">csdn上的博客</a></p>
</blockquote>
</details>

<h2 id="18、wait-sleep-yield-join-方法"><a href="#18、wait-sleep-yield-join-方法" class="headerlink" title="18、wait/sleep/yield/join 方法"></a>18、wait/sleep/yield/join 方法</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>wait() 方法的作用是将当前线程挂起，让其进入阻塞状态，直到 notify/notifyAll 方法来唤醒线程，很容易理解，wait 是释放了锁资源的。</p>
<p>wait(long timeout)方法与 wait 相似，区别在于如果再指定时间内没有被notify/notifyAll ，则自动唤醒。</p>
<p>sleep方法只是暂时让出cpu执行权，并不释放锁，而 wait 是释放锁的。</p>
<p>yield 方法只是暂停当前线程，以便其他线程有机会运行，不过不能指定暂停时间，也不能保证当前线程立即停止。yield 方法只是将thread 的状态由 Running 转变为 Runable 状态。不过<strong>调度器可能会忽略这个方法，并且Java官方建议只用这个方法用于调试和测试。</strong></p>
<p>join 方法是父线程等待子线程执行完之后再执行。</p>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/paddix/p/5381958.html">cnblogs的博客</a></p>
</blockquote>
</details>

<h2 id="19、实现线程安全的方法（三种）"><a href="#19、实现线程安全的方法（三种）" class="headerlink" title="19、实现线程安全的方法（三种）"></a>19、实现线程安全的方法（三种）</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>互斥同步    </li>
</ul>
<blockquote>
<p>指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个(再使用信号量的时候可以是一些)线程使用，Java中典型的互斥同步手段是 synchronized 关键字，以及 ReentrantLock 类。</p>
</blockquote>
<ul>
<li>非阻塞同步    </li>
</ul>
<blockquote>
<p>互斥同步主要的问题就是线程阻塞和唤醒带来的性能问题，因此也称为阻塞同步。非阻塞同步就是先进行操作，如果没有其它线程争用共享数据，操作就成功了，否则产生冲突再补偿(比如自旋不断重试，直到成功为止)，这种乐观方式无需把线程挂起和唤醒，CAS 的出现也为非阻塞同步提供了条件。</p>
</blockquote>
<ul>
<li>无同步方案    </li>
</ul>
<blockquote>
<p>如果方法本来就没有涉及共享数据，每次输入相同的数据就能得到相同的输出，这种情况当然无需进行同步。</p>
</blockquote>
</details>


<h2 id="20、死锁"><a href="#20、死锁" class="headerlink" title="20、死锁"></a>20、死锁</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>产生死锁的四个条件（满足才会死锁）：</p>
<ol>
<li>互斥使用    </li>
<li>不可剥夺    </li>
<li>请求保持    </li>
<li>循环等待    </li>
</ol>
<p>破坏任意一个条件即可解锁</p>
<details>

<h2 id="21、引申-写个简单的死锁程序"><a href="#21、引申-写个简单的死锁程序" class="headerlink" title="21、引申-写个简单的死锁程序"></a>21、引申-写个简单的死锁程序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">      Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">      Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">      Thread thread1 = <span class="keyword">new</span> Thread(<span class="string">"thread1"</span>){</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">              <span class="keyword">super</span>.run();</span><br><span class="line">              <span class="keyword">synchronized</span> (lock1){</span><br><span class="line">                  System.out.println(Thread.currentThread().getName() + <span class="string">"进入第1层锁"</span>);</span><br><span class="line">                  <span class="keyword">try</span> {</span><br><span class="line">                      sleep(<span class="number">1000</span>);</span><br><span class="line">                  } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  }</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">synchronized</span> (lock1){</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + <span class="string">"进入第2层锁"</span>);</span><br><span class="line">                  }</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">      };</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Thread thread2 = <span class="keyword">new</span> Thread(<span class="string">"thread1"</span>){</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">              <span class="keyword">super</span>.run();</span><br><span class="line">              <span class="keyword">synchronized</span> (lock2){</span><br><span class="line">                  System.out.println(Thread.currentThread().getName() + <span class="string">"进入第1层锁"</span>);</span><br><span class="line">                  <span class="keyword">try</span> {</span><br><span class="line">                      sleep(<span class="number">1000</span>);</span><br><span class="line">                  } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  }</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">synchronized</span> (lock2){</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + <span class="string">"进入第2层锁"</span>);</span><br><span class="line">                  }</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">      };</span><br><span class="line"></span><br><span class="line">      thread1.start();</span><br><span class="line">      thread2.start();</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

</details>

<h2 id="22、synchronized-关键字"><a href="#22、synchronized-关键字" class="headerlink" title="22、synchronized 关键字"></a>22、synchronized 关键字</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>当执行如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        System.out.println(<span class="string">"Method 1 start"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>反编译之后能看到 monitorenter 和 monitorexit 字样，关于这两条指令，jvm中的解释如下：</p>
<blockquote>
<p>每个对象都有一个监视器锁(monitor)，当monitor 被占用时就处于锁定状态，线程执行 monitorenter 指令时，就尝试获取 monitor的所有权，过程如下：    </p>
</blockquote>
<blockquote>
<p>1、如果 monitor 的进入数为 0 ，则该线程进入 monitor，然后将进入数设置为 1，即该现成为 monitor 的所有者。    </p>
</blockquote>
<blockquote>
<p>2、如果有线程已经占有 monitor ，之后又重新进入，则 monitor 的进入数加 1。    </p>
</blockquote>
<blockquote>
<p>3、如果其他线程已经占用了 monitor ，则当前线程进入阻塞状态，直到 monitor 的进入数为 0(之后被唤醒)，再重新获取 monitor 的所有权。</p>
</blockquote>
<p>反之，monitorexit 则是线程退出的一个过程。</p>
<p>所以我们知道，修饰代码块时，synchronized 底层是通过 monitor 对象来完成的，<strong>其实，wait/notify方法也是依赖于 monitor 对象的，这也是为什么只有再同步块中才能调用 wait/notify 等方法(因为wait 等待的是啥？其实等待的就是对象的 monitor，由于所有类都是object ，里面内置有一个 monitor，因此自然所有类都应该有 wait/notify 方法)。</strong></p>
<p>在修饰成员方法时，如下代码所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>反编译过后就会有 ACC_SYNCHRONIZED 标识符(没有用 monitorenter 和 monitorexit，其实理论上也是可以的)，jvm 根据这个标识符来实现方法同步：当调用方法时，首先检查方法的 ACC_SYNCHRONIZED 标志是否被设置，如果设置了，则线程首先获取 monitor，获取成功后才能执行方法，方法执行完成后再释放 monitor，方法执行期间，其他对象无法再获得同一个 monitor。所以与修饰 代码块 的时候本质上是没有区别的。</p>
<p>最后，如果修饰的是静态方法，则锁定的是 class 对象。</p>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/paddix/p/5367116.html">Synchronized及其实现原理</a></p>
</blockquote>
</details>

<h2 id="23、synchronized-锁持有的object-是Thread-对象"><a href="#23、synchronized-锁持有的object-是Thread-对象" class="headerlink" title="23、synchronized 锁持有的object 是Thread 对象"></a>23、synchronized 锁持有的object 是Thread 对象</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>看过上面synchronized原理，我们来看一段代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Thread threadTest = <span class="keyword">new</span> Thread() {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"执行线程中方法"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    threadTest.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (threadTest) {<span class="comment">//这里不明白可以想象单例的 synchronized 用法</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            threadTest.wait();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"执行到了这里"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们知道，wait 必须在同步块中执行，上述代码也是这样的；同时我们也知道，wait() 方法后，必须收到 notify/notifyAll 之后才能结束等待状态。但是上述代码首先输出 “执行线程中方法”  ，之后输出 “执行到了这里” ，明明没有notify ，怎么就能结束 wait 状态呢？其实这是因为synchronized 获得对象锁是 Thread 对象的锁时，当该线程执行完成后，会调用线程自身的 notifyAll() 方法，通知所有等待在该线程对象上的线程。所以，用这种方式能够实现 join 的功能，使得线程依次执行。</p>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/chenkaibsw/article/details/80912878">csdn上的博客</a></p>
</blockquote>
<details>

<h2 id="24、引申-理解Java-中的-join"><a href="#24、引申-理解Java-中的-join" class="headerlink" title="24、引申-理解Java 中的 join"></a>24、引申-理解Java 中的 join</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>如果要用join 方法实现上述功能，可以这样：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Thread threadTest = <span class="keyword">new</span> Thread() {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"执行线程中方法"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    threadTest.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        threadTest.join();</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    System.out.println(<span class="string">"执行到了这里"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>join 方法从字面上理解就是新线程加入进来，等新线程执行完后，老的线程才继续执行。我们日常使用 join 方法是通过 join(0) 来实现的，我们看它的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">       <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) {</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">if</span> (millis == <span class="number">0</span>) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//如果时执行的join(0)</span></span><br><span class="line">           <span class="keyword">while</span> (isAlive()) {        <span class="comment">//如果线程是运行状态，就会执行下面的等待</span></span><br><span class="line">               wait(<span class="number">0</span>);</span><br><span class="line">           }</span><br><span class="line">       } <span class="keyword">else</span> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//如果是执行的join(time)</span></span><br><span class="line">           <span class="keyword">while</span> (isAlive()) {               <span class="comment">//如果线程时运行状态</span></span><br><span class="line">               <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">               <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) {</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               }</span><br><span class="line">               wait(delay);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="comment">//等待delay时间后自动返回继续执行</span></span><br><span class="line">               now = System.currentTimeMillis() - base;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中 while (isAlive()) { wait(0) } ，我们日常调用的 wait() 方法就是调用的 wait(0) 实现，因此这里本质还是 执行了 wait 方法，就是让其一直等待。所以我们上述代码： threadTest.join() 本质是利用 threadTest 对象作为对象锁，当线程终止时，会调用线程自身的 notifyAll ，因此这个 wait 就解除了。</p>
<p>再说下 while (isAlive())，这是在判断线程是否线程是否已经执行了start() 方法，因此如果还没有start() 则不会执行wait() 方法。可以用如下代码验证：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"t1"</span>);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                t1.join();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"t2"</span>);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    t2.start();<span class="comment">//先启动t2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    t1.start();<span class="comment">//延迟2秒后启动t1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码看起来执行了 t1.join() ，应该要等t1执行完了才会执行t2，但是呢，这里最终输出： t2  t1 ，即 t2 还是会先执行。这是因为在执行 t1.join() 的时候，t1并没有执行 start() ，isAlive() 为false，因此不生效。</p>
<details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/chenkaibsw/article/details/80912878">csdn上的博客</a></p>
</blockquote>
<h2 id="25、wait-sleep-yield-join-方法"><a href="#25、wait-sleep-yield-join-方法" class="headerlink" title="25、wait/sleep/yield/join 方法"></a>25、wait/sleep/yield/join 方法</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>wait() 方法的作用是将当前线程挂起，让其进入阻塞状态，直到 notify/notifyAll 方法来唤醒线程，很容易理解，wait 是释放了锁资源的。</p>
<p>wait(long timeout)方法与 wait 相似，区别在于如果再指定时间内没有被notify/notifyAll ，则自动唤醒。</p>
<p>sleep方法只是暂时让出cpu执行权，并不释放锁，而 wait 是释放锁的。</p>
<p>yield 方法只是暂停当前线程，以便其他线程有机会运行，不过不能指定暂停时间，也不能保证当前线程立即停止。yield 方法只是将thread 的状态由 Running 转变为 Runable 状态。不过<strong>调度器可能会忽略这个方法，并且Java官方建议只用这个方法用于调试和测试。</strong></p>
<p>join 方法是父线程等待子线程执行完之后再执行。</p>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/paddix/p/5381958.html">cnblogs的博客</a></p>
</blockquote>
<details>

<h2 id="26、Java-中锁的种类"><a href="#26、Java-中锁的种类" class="headerlink" title="26、Java 中锁的种类"></a>26、Java 中锁的种类</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>大概可以分类为：</p>
<ul>
<li>乐观锁、悲观锁       </li>
<li>独享锁、共享锁          </li>
<li>公平锁、非公平锁           </li>
<li>互斥锁、读写锁             </li>
<li>可重入锁             </li>
<li>分段锁                 </li>
</ul>
<p>其中乐观锁认为线程基本上是没有竞争的，一般采用CAS机制实现，悲观锁认为一个线程获取数据时，一定会有其他数据对数据进行更改，它的实现就是加锁，比如 synchronize 关键字</p>
<p>至于独享锁：一次只能被一个线程拥有，ReentrantLock 这个可重入锁也是独享锁。而共享锁可以被多个线程持有，比如：ReentrantReadWrite 中的读锁ReadLock 是共享锁，写锁WriteLock 是独享锁。</p>
<p>互斥锁的具体实现就是 synchronized、ReentrantLock 等实现；读写锁具体实现就是 ReadWriteLock。</p>
<p>可重入锁：对于同一个线程，在外层方法获取锁的时候，在进入内层方法也会自动获取锁。</p>
<p>公平锁：多线程竞争时排队，按照申请顺序获取锁；非公平锁：竞争时，先尝试插队，失败再排队。</p>
<p>分段锁：并不是一种锁，只是细化锁的粒度。</p>
<details>

<p>以上内容参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112649693">知乎上的内容</a></p>
<h2 id="27、Java-中锁优化的方式"><a href="#27、Java-中锁优化的方式" class="headerlink" title="27、Java 中锁优化的方式"></a>27、Java 中锁优化的方式</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li><strong>自旋锁与自适应自旋</strong>(主要解决互斥同步挂起和恢复需要转入内核态的问题。引入的自适应自旋，意味着自旋时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定的，因为如果在同一个锁对象上，自旋等待刚获得过锁，并且持有锁的线程正在运行，那么虚拟机认为当前自旋也很有可能再次成功，进而允许自旋等待更长时间)       </li>
<li>锁消除（虚拟机对于检测到不可能存在共享的数据进行锁消除）            </li>
<li>锁消除(一般来说，加锁同步块区域尽量小，只锁真正共享的区域，以便在锁竞争的时候，能尽快释放。但是如果一系列的连续操作对同一个对象频繁反复加锁解锁，甚至是出现在循环体中，那就会导致不必要的性能损耗，典型的就是在 循环中执行StringBuilder 的append操作)</li>
<li>轻量级锁（如果同步对象没有被锁定，虚拟机首先将将在当前线程的栈帧中建立一个名为锁记录-Lock Record 的空间，用于存储锁对象目前的 Mark Word的拷贝，然后虚拟机使用CAS操作尝试把对象的Mark Word 更新为指向 Lock Record 的指针，如果更新成功了，则代表线程拥有了这个对象的锁，对象Mark Word的锁标志也会标记为 “00”，即轻量级锁状态。如果这个cas操作失败，则意味着至少存在一条线程竞争，此时检查Mark Word 是否指向当前线程的栈帧，如果是，则说明已经拥，有了，直接进入同步块即可。否则，如果有两条以上线程争用一个锁，则必须膨胀微重量级锁。轻量级锁的依据是，“对于绝大部分锁，在整个同步周期内是不存在竞争的”，如果没有竞争，则轻量级锁通过CAS操作避免了使用互斥量的开销；当然，如果存在竞争，除了互斥量本身之外，还发生了CAS开销，反而更慢了）    </li>
<li>偏向锁（它的目的是在无竞争的情况下消除CAS操作，进一步提升性能。当锁对象第一次被线程获取的时候，就将对象头中的偏向模式置为 “1”,即偏向模式，同时使用CAS操作把获取这个锁的线程的ID记录在Mark word 中，如果操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块都不需要进行同步操作，不过，一旦出现另外一个线程尝试去获取这个锁的情况，偏向模式马上结束。根据锁对象目前是否处于锁定状态来决定是否撤销偏向、恢复到未锁定或者轻量级锁定状态）</li>
</ul>
<blockquote>
<p>以上内容参考自《深入理解Java虚拟机-第三版》</p>
</blockquote>
<details></details></details></details></details></details></details></details></details></details></details></details></details></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/09/%E9%9D%A2-%E7%9F%A5%E8%AF%86/Java%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E9%9D%A2-%E7%9F%A5%E8%AF%86/Java%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">面试题-Java基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-09 21:25:00" itemprop="dateCreated datePublished" datetime="2019-11-09T21:25:00+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-25 11:10:38" itemprop="dateModified" datetime="2022-02-25T11:10:38+08:00">2022-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1、Java-多态"><a href="#1、Java-多态" class="headerlink" title="1、Java 多态"></a>1、Java 多态</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>多态存在的三个必要条件：一、要有继承关系  二、要重写方法 三、父类指向子类对象。</p>
<p>多态就是指允许不同类的对象(如：父类的多个子类)，对同一消息做出不同响应(同一个函数调用在不同子类中的行为不同)。</p>
<p>多态的实现：动态绑定(dynamic binding),即在执行期间判断所引用的对象的实际类型，根据实际类型再调用相应方法。</p>
<p>Java 中多态的表现：接口的实现、继承父类进行方法重写 以及 同一个类中进行方法重载。</p>
<blockquote>
<p>以上内容参考自： <a target="_blank" rel="noopener" href="http://www.jackywang.tech/AndroidInterview-Q-A/interview/java%E5%A4%9A%E6%80%81-%E4%B9%90%E8%A7%86.html">Java多态</a></p>
</blockquote>
</details>

<p><strong>Java集合</strong></p>
<h2 id="2、ArrayList-与-LinkedList的区别"><a href="#2、ArrayList-与-LinkedList的区别" class="headerlink" title="2、ArrayList 与 LinkedList的区别"></a>2、ArrayList 与 LinkedList的区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>ArrayList的特点：</p>
<ul>
<li>以数组实现，初始空间是10，节约空间    </li>
<li>有容量限制，当超出限制时，新增50%容量，即容量变为原来的1.5倍，如果还不够，则直接扩充为需求值，之后将原来数据拷贝到新的空间中，比较耗时        </li>
<li>按照数组下标访问元素——get(i)/set(i,e) 性能很高    </li>
<li>按照下标插入、删除元素，需要移动受影响的元素，性能就会变差(remove操作可以理解为删除index为0的节点，并将后面的元素移到0处)    </li>
</ul>
<p>LinkedList的特点：</p>
<ul>
<li>以双向链表实现，链表无容量限制，但是双向链表本身使用了更多空间    </li>
<li>按下标访问元素——get(i)/set(i,e)，要遍历链表将指针移动到位(如果i&gt;链表的一半，会从末尾开始移动)    </li>
<li>插入、删除元素时，只需要修改前后节点的指针即可。但如果是指定位置插入和删除，则还是需要遍历部分链表的指针才能移动到下标所指的位置。如果只是在链表两头的操作就能省掉指针的移动。 </li>
</ul>
<blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/arraylist.html">ArrayList</a>、<a target="_blank" rel="noopener" href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/linkedlist.html">LinkedList</a>) </p>
</blockquote>
</details>

<h2 id="3、HashMap"><a href="#3、HashMap" class="headerlink" title="3、HashMap"></a>3、HashMap</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>根据官方描述，HashMap 基于 Map 接口实现，<strong>允许null 键/值</strong>，非同步、不保证有序(比如插入顺序)、顺序可能会随时间变化。</p>
<h3 id="两个重要的参数"><a href="#两个重要的参数" class="headerlink" title="两个重要的参数"></a>两个重要的参数</h3><p>容量(Capacity)就是bucket大小，负载因子(Load factor)就是bucket填满程度的最大比例。若对迭代性能要求高，则capacity不宜设置过大，同时load factor也不宜设置过小；当buckets的数目大于 capacity * load factor 时，就需要调整buckets 的大小为当前的2倍。</p>
<h3 id="hashMap的put函数实现"><a href="#hashMap的put函数实现" class="headerlink" title="hashMap的put函数实现"></a>hashMap的put函数实现</h3><ol>
<li>对key的hashCode 做hash，然后计算index；    </li>
<li>如果没有碰撞直接放到bucket里；    </li>
<li>如果碰撞了，以链表的形式存在buckets 后；    </li>
<li>如果碰撞导致链表过长，<strong>达到某个阈值后，则把链表转换成红黑树</strong>；    </li>
<li>如果节点已经存在，就替换 old value (保证key的唯一性)；    </li>
<li>如果bucket满了，就要resize；    </li>
<li>注意，<strong>插入元素采用头插法，因为HashMap的发明者认为，后插入的Entry被查找的可能性更大</strong>。</li>
</ol>
<h3 id="get函数的实现"><a href="#get函数的实现" class="headerlink" title="get函数的实现"></a>get函数的实现</h3><ol>
<li>bucket里第一个节点，则直接命中；    </li>
<li>如果有冲突，则通过 key.equals(k) 方式去查找对应的 entry。    </li>
</ol>
<blockquote>
<p>若为树，则树中通过key.equals查找，时间复杂度为 O(logn);<br>若为链表，则链表中通过key.equals查找，时间复杂度为 O(n)。</p>
</blockquote>
<h3 id="hashmap细节"><a href="#hashmap细节" class="headerlink" title="hashmap细节"></a>hashmap细节</h3><ul>
<li>hashmap的初始长度是16，并且手动初始化或者每次自动扩展时，<strong>长度必须是2的幂</strong>。</li>
</ul>
<p>这里主要强调是2的幂，至于为什么是16，主要是为了让key到index的映射更加均匀。前面提到，index = Hash(key) ，如何实现一个尽量分布均匀地hash函数。有人说可以通过求余的方式： index = hashCode(key) % length ，不过求余的方式虽然简单，但是效率不高，Hashmap中采用了位运算方式，其公式为：</p>
<blockquote>
<p>index = hashCode(key) &amp; (length - 1)</p>
</blockquote>
<p>以具体例子来说，假如某个key 的 hashCode(二进制) = 101110001110101110 1001，hashmap的默认长度length = 16 ，则 length - 1 为15，二进制数据为 1111，把两个二进制数据做位与操作得到 1001,即十进制的 9 ，所以index = 9。<strong>所以这里，index的结果完全取决于hashCode的最后4位(当然，java8中，会将这个hashCode的高16位不变，低16位和高16位做异或操作作为低16位的值，之后才与 length -1 做位与，这样避免只有低4位是有效位，从而进一步降低碰撞，因为参与的位数多了)</strong>。</p>
<p>所谓为什么要是2的幂，也即如果不是2的幂会怎样？比如hashMap的长度是 10，还是以上面的例子：hashCode(二进制) = 101110001110101110 1001，length - 1 = 9 ，即 1001，则index 也还会是1001(因为hashCode的后4位也是1001)，单独看这里没什么问题，但是从此我们可以推断：如果hashCode的后 4 位是 1001、1101、1111，1101等等，它们的结果都会是 1001，<strong>因为相当于只有第1位和第4位在起作用，这不符合index均匀分布的要求。那如果是2的幂呢？则length - 1后，所有的位数都是1，则每位都会起作用</strong>。</p>
<p>Hashmap的容量是有限的，当容量达到一定的饱和度的时候，Key映射位置发生碰撞的概率会上升，这好理解，因为如果每个坑都差不多有entry在了，无论你index是多少，都会碰撞，所以元素越多，越容易发生碰撞。java中的条件是 : hashmap.size &gt;= capacity * load factor 的时候，就需要resize，需要经历两个步骤，1、扩容，创建一个新的Entry数组，长度是以前的2倍，2、ReHash，遍历原来的 Entry数组，把所有的Entry 重新hash到新的数组，<strong>因为数组长度变化了，hash的规则也会改变，所以需要rehash</strong>。这里不需要重新计算hash，只需要判断原来的hash值新增的那位是0 还是1，如果是0的话，索引还是没变化，如果是1，则索引变成 “原索引 + oldCapacity”。</p>
<p>举个例子拉说，如果以前的capacity 是 8，则resize后变成16，以前的length - 1 为 111 现在则变成了 1111，多了一个有效位，所以只要判断 hashCode 的对应新增的那位的值是0还是1了，0的话，整个index还是不变，1的话，就在index的基础上加上老的容量 8 即可。</p>
<ul>
<li><p>前面提到，key和value都可能为null，如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中。</p>
</li>
<li><p>Hashmap的线程不安全如何体现？</p>
</li>
</ul>
<ol>
<li>如果多个线程同时使用put添加元素，如果发生碰撞，最终只有一个线程值被保存，因为另一个的会被覆盖。    </li>
<li>由于resize操作存在，hashmap在多线程的情况下，可能会出现死循环，具体参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31614195">小灰的解释</a></li>
</ol>
</details>

<blockquote>
<p>参考链接： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31610616">知乎链接</a>、<a target="_blank" rel="noopener" href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/hashmap.html">hashmap介绍链接</a></p>
</blockquote>
<h2 id="4、HaShMap-链表元素到达8的时候转红黑树的若干问题"><a href="#4、HaShMap-链表元素到达8的时候转红黑树的若干问题" class="headerlink" title="4、HaShMap 链表元素到达8的时候转红黑树的若干问题"></a>4、HaShMap 链表元素到达8的时候转红黑树的若干问题</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先，得满足两个条件才会转红黑树：一个是链表长度到8,一个是数组长度到64  </p>
<p>为什么到8才转成红黑树？首先根据统计节点数&gt;=8概率是很小的(千分之一)，并且到8的时候，会引起性能下降，且因为转红黑树消耗性能，所以到 8 才转。  </p>
<p>会根据红黑树状态以及红黑树节点总数到6这个阈值来将红黑树退回链表，这主要是是因为 8 和 6 这两个数字相差2，不至于插入删除一个元素导致来回转换</p>
<p>为什么不一开始就采用红黑树？因为红黑树是有额外的空间开销的，并且红黑树涉及左旋右旋等操作(我自己臆测的，也没看到有好的说法)</p>
</details>

<blockquote>
<p>以上问题参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/g5zhu5896/article/details/82968287">hashmap转红黑树的两个条件
</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_37147070/article/details/98785367">HashMap的问题</a>、<a target="_blank" rel="noopener" href="https://www.cnblogs.com/misscai/p/13234177.html">cnblogs的博客</a>、</p>
</blockquote>
<h2 id="5、HashTable"><a href="#5、HashTable" class="headerlink" title="5、HashTable"></a>5、HashTable</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>HashTable 类似于HashMap ，它同样基于hash表实现，每个元素也是key-value 对，也是通过单链表解决冲突，容量不足时，也会resize，二者区别是：</p>
<ol>
<li>HashTable 的key和Value 都不能为null，而HashMap允许。    </li>
<li>HashTable 默认大小是 11，扩容方式是 old*2 + 1,而HashMap 默认大小是16，要求数组大小是2的幂，扩容时，直接扩为2倍。    </li>
<li>获取index的方式不一样，Hashtable 采用除余的方式，而HashMap采用 位与的方式，效率更高。    </li>
<li>HashTable 保证方法调用的线程安全，因为在每个方法前都有synchronize 关键字。而HashMap 没有，因此在线程安全条件下效率更高。</li>
</ol>
<blockquote>
<p>上文的<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24338517">参考链接</a></p>
</blockquote>
</details>

<h2 id="6、ConcurrentHashMap"><a href="#6、ConcurrentHashMap" class="headerlink" title="6、ConcurrentHashMap"></a>6、ConcurrentHashMap</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>想要避免HashMap 的线程安全问题有很多办法，比如采用 HashTable 或者 Collections.synchronizedMap ，<strong>但是这两者有共同的问题：性能，因为无论是读还是写操作，它们都会给整个集合加锁，导致同一时间的其他操作阻塞</strong>。如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E9%9B%86%E5%90%88/HashTable%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E8%AF%BB%E5%86%99.jpg" alt="阻塞其他操作"></p>
<p>此时，ConcurrentHashMap应运而生，理解 ConcurrentHashMap 关键要理解一个概念： Segment 。Segment 本身就相当于一个 HashMap 对象，Segment 包含一个HashEntry 数组，数组中每个 HashEntry 既是一个键值对，也是一个链表的头结点，如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E9%9B%86%E5%90%88/%E5%8D%95%E4%B8%80segment.jpg" alt="单一segment结构"></p>
<p>这样的Segment 在ConcurrentHashMap 中有2 的N 次方个，共同保存在一个名为 segments 的数组中。因此，整个 ConcurrentHashMap 的结构如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E9%9B%86%E5%90%88/ConcurrentHashMap%E7%BB%93%E6%9E%84.jpg" alt="ConcurrentHashMap结构"></p>
<p>这个二级结构，和数据库的水平拆分有些相似。采取这样的结构就是<strong>锁分段技术</strong>，每个segment 就好比一个自治区，读写操作互不影响。所以，ConcurrentHashMap 操作会有以下几种可能性：</p>
<ul>
<li>不同Segment 可以并发写入。    </li>
<li>同一 Segment 可以同时读和写。     </li>
<li>同一个 Segment 并发写入时，只有一个线程可以执行，其他的线程阻塞。因为 Segment 的写入会加锁。    </li>
</ul>
<p>通过以上分析我们知道，ConcurrentHashMap 中每个 Segment 各自持有一把锁。在保证线程安全的情况下，降低了锁的粒度，让并发操作效率更高。</p>
<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><ol>
<li>为输入的key做 Hash 运算，得到hash值。    </li>
<li>通过hash值，定位到对应的 Segment 对象。    </li>
<li>再次通过 hash 值，定位到 Segment 中数组的具体位置。    </li>
</ol>
<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><ol>
<li>为输入的key 做Hash 运算，得到hash 值。    </li>
<li>通过hash值，定位到 Segment 对象。    </li>
<li>获取可重入锁。     </li>
<li>再次通过 hash 值，定位到 Segment 当中的具体位置。    </li>
<li>插入或者覆盖 HashEntry 对象。    </li>
<li>释放锁。     </li>
</ol>
<h3 id="size-方法"><a href="#size-方法" class="headerlink" title="size 方法"></a>size 方法</h3><p>获取 ConcurrentHashMap 总元素数量，自然要把各个 Segment 的元素汇总起来，但是如果在统计过程中，已经统计过的 Segment 瞬间插入新的元素，这时候怎么办呢？其实，这个size调用过程的大体逻辑如下：</p>
<ol>
<li>遍历所有 Segment。    </li>
<li>把 Segment 的元素数量累加。    </li>
<li>把 Segment 的修改次数累加起来。    </li>
<li>判断所有Segment 的总修改次数是否大于上一次的修改次数，如果大于，说明统计过程中有修改，重新统计，同时尝试次数 +1；否则，说明没有修改，统计结束。     </li>
<li>如果尝试次数超过阈值，则对每一个Segment 加锁，再重新统计。    </li>
<li>此时，统计的结果肯定正确，统计结束，释放锁。   </li>
</ol>
<p>为了尽量不锁住所有的Segment ，首先乐观假设Size过程中不会有修改，当尝试一定次数后，才无奈转换为悲观锁。</p>
<blockquote>
<p>以上文章参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31614308">小灰的分析</a> </p>
</blockquote>
</details>

<h2 id="7、HashMap-、-HashTable-和-ConcurrentHashMap-的区别？"><a href="#7、HashMap-、-HashTable-和-ConcurrentHashMap-的区别？" class="headerlink" title="7、HashMap 、 HashTable 和 ConcurrentHashMap 的区别？"></a>7、HashMap 、 HashTable 和 ConcurrentHashMap 的区别？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<p>HashTable 是 HashMap 的线程安全实现，但是 HashTable在竞争激烈时效率低下，因为访问所有 HashTable 的线程都竞争同一把锁。ConcurrentHashMap 采用锁分段技术，将数据一段段存储，每段一把锁，当两个线程访问不同段数据时不受干扰，当然，contentValue和size等方法需要了解整体数据的情况下，还需要锁住整个表。</p>
</blockquote>
</details>

<h2 id="8、LinkedHashMap"><a href="#8、LinkedHashMap" class="headerlink" title="8、LinkedHashMap"></a>8、LinkedHashMap</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>LinkedHashMap 是Hash表和链表的实现，并且保存了记录的插入顺序。因为LinkedHashMap里面的Entry比HashMap多了两个字段：after和before，而以前的HashMap中的next 字段没有变化，从而额外构成一个双向链表，当然就可以在keySet()时按插入顺序输出，LinkedHashMap结构如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E9%9B%86%E5%90%88/LinkedHashMap%E5%8E%9F%E7%90%86.png" alt="LinkedHashMap原理"></p>
<p>与HashMap的区别：1、保存了记录的插入顺序，遍历的时候，首先打印最先插入的记录。2、遍历的时候比HashMap慢，因为LinkedHashMap 遍历链表，而HashMap可以说是根据capacity 遍历链表。不过如果HashMap容量很大并且实际数据比较少的情况下，遍历起来可能比LinkedHashMap慢。3、HashMap的遍历速度和容量有关，而LinkedHashMap 遍历速度只和实际数据有关。</p>
<blockquote>
<p>以上内容参考<a target="_blank" rel="noopener" href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/LinkedHashMap.html">这个链接</a>，从<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/278676747">知乎这个问题</a>得到了灵感，忽然想明白了这个结构。</p>
</blockquote>
</details>

<h2 id="9、WeakHashMap"><a href="#9、WeakHashMap" class="headerlink" title="9、WeakHashMap"></a>9、WeakHashMap</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>WeakHashMap，从名字可以看出它是某种 Map。它的特殊之处在于 WeakHashMap 里的entry可能会被GC自动删除，即使程序员没有调用remove()或者clear()方法。</p>
<p>更直观的说，当使用 WeakHashMap 时，即使没有显示的添加或删除任何元素，也可能发生如下情况：</p>
<blockquote>
<ul>
<li>调用两次size()方法返回不同的值；    </li>
</ul>
</blockquote>
<ul>
<li>两次调用isEmpty()方法，第一次返回false，第二次返回true；    </li>
<li>两次调用containsKey()方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；    </li>
<li>两次调用get()方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。    </li>
</ul>
<p>遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉？其实不然，WeekHashMap 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。</p>
<blockquote>
<p>以上内容参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24887482">知乎的大神</a></p>
</blockquote>
</details>

<h2 id="10、TreeMap"><a href="#10、TreeMap" class="headerlink" title="10、TreeMap"></a>10、TreeMap</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>HashMap不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了。从官方的描述来看：</p>
<blockquote>
<p>A Red-Black tree based {@link NavigableMap} implementation.The map is sorted according to the {@linkplain Comparable natural ordering} of its keys, or by a {@link Comparator} provided at map creation time, depending on which constructor is used.</p>
</blockquote>
<p>TreeMap 是一个红黑树结构，每个key-value都作为一个红黑树的节点。它根据 key 排序(Comparable自然排序)，但假如 key 没有实现 Comparable 接口，还可以通过构造函数中传入的 Comparator 来自定义比较。并且它还间接实现了 SortedMap 接口，因此它是有序的集合。</p>
<p>使用红黑树的好处是能够使得树具有不错的平衡性，这样操作的速度就可以达到log(n)的水平了。</p>
<p>关于<strong>根据 key 排序</strong>这个表述，可能直接看代码更容易懂：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) {</span><br><span class="line">    </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        cmp = cpr.compare(key, t.key);</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">            </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>省略了很多代码，如果有自定义的 comparator，则使用自定义的 comparator 比较；否则，将 Key 强转为 Comparable 类型，再做比较。当然，这个Key肯定不能为null，此外，官方也说明了，如果Key不是 Comparable 类型的，就会抛出 ClassCastException 异常。</p>
<blockquote>
<p>以上文章参考<a target="_blank" rel="noopener" href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/treemap.html">java集合-TreeMap</a>、<a target="_blank" rel="noopener" href="https://my.oschina.net/90888/blog/1626065">oschina链接</a> 还有<a target="_blank" rel="noopener" href="https://www.cnblogs.com/CarpenterLee/p/5503882.html">这个大牛</a></p>
</blockquote>
</details>

<h2 id="11、Java泛型"><a href="#11、Java泛型" class="headerlink" title="11、Java泛型"></a>11、Java泛型</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Java 泛型主要关注几点：</p>
<h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><p>顾名思义就是匹配任意类型。如如下写法：List&lt;?&gt; list  ;</p>
<h3 id="带限通配符"><a href="#带限通配符" class="headerlink" title="带限通配符"></a>带限通配符</h3><p><font color="ff0000">上限通配符：</font>使用extends 关键字指定这个类型必须继承某个类或者实现某个接口，也可以是该类(接口)本身。如： List&lt;? extends Shape&gt;  ，表示集合中所有元素都是Shape 类型或者它的子类。</p>
<p><font color="ff0000">下限通配符：</font>使用super 关键字指定这个类型必须是某个类的父类，或者某个接口的父接口，也可以是这个类本身。如：List&lt;? super Circle&gt; ，表示集合中所有元素都是Circle 类型或者是其父类。</p>
<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><blockquote>
<p>Class c1=new ArrayList<integer>().getClass();<br>Class c2=new ArrayList<string>().getClass();<br>System.out.println(c1==c2);</string></integer></p>
</blockquote>
<p>输出 true ，也就是说编译后的class文件中不会包含任何泛型信息，泛型信息不会进入到运行时阶段。</p>
<p>由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类</p>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/genericity.html">Java泛型</a></p>
</blockquote>
</details>

<h2 id="12、Java抽象类和接口的区别"><a href="#12、Java抽象类和接口的区别" class="headerlink" title="12、Java抽象类和接口的区别"></a>12、Java抽象类和接口的区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>abstract class和interface是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。 </p>
<p>abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于 abstract class和interface的选择显得比较随意。</p>
<p>但是，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。</p>
<p>总结：</p>
<ul>
<li>设计理念上，接口反映的是”like-a”关系，抽象类反映的是”is-a”关系，即接口表示这个对象能做什么，抽象类表示的是这个对象是什么(想象一下，人可以吃东西，狗也能吃东西，接口反映的是吃东西这个动作，而抽象类能反映的，可能就是人这个物种)。    </li>
<li>抽象类与接口都不能直接实例化。    </li>
<li>抽象类被子类继承，接口被子类实现。    </li>
<li>接口中定义的变量只能是公共的静态常量(即 public static final)，抽象类中是普通变量。    </li>
<li>抽象类中可以没有抽象方法，接口中可以没有方法，但是有方法一定要有抽象方法。    </li>
<li>接口可以被类多实现(类可以实现多个接口)，抽象类只能被单继承。    </li>
<li>接口中没有this 指针，没有构造函数，不能拥有实例变量或实例方法。   </li>
</ul>
<p>关于接口，再多啰嗦几句：</p>
<ul>
<li>接口用于描述系统对外提供的服务，因此接口中的成员变量和方法都必须公开(public)，确保所有使用者能访问。     </li>
<li>接口仅描述系统能做什么，但不指名如何做，因此所有方法都是抽象(abstract)方法。     </li>
<li>接口不涉及任何具体实例(this关键字)的相关细节，因此接口没有构造方法，没有实例变量，只有静态(static)变量。      </li>
<li>接口中的变量是所有实现类公有的，既然公有，肯定是不变的东西，所以变量是不可变(final)的。    </li>
</ul>
<p>通俗讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中。接口对修改关闭，对扩展开放，是开闭原则的体现。</p>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/abstract_interface.html">Java抽象类和接口的区别</a>、<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lanxuezaipiao/p/3371224.html">程序媛想事</a></p>
</blockquote>
</details>

<h2 id="13、Java-transient关键字"><a href="#13、Java-transient关键字" class="headerlink" title="13、Java transient关键字"></a>13、Java transient关键字</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Java序列化时，transient关键字用于属性前时，该属性就不会被序列化。它的使用可以总结为下面几点：</p>
<ul>
<li>变量被 transient 修饰时，变量将不会是对象持久化的一部分。    </li>
<li>transient 只能修饰变量而不能修饰方法和类，并且也不能修饰本地变量。    </li>
<li>静态变量不管是否被 transient 修饰，均不能被序列化。    </li>
</ul>
<p>附：父类实现了Serializable，子类没有，<br>父类有int a = 1、int b = 2、int c = 3<br>子类有int d = 4、int e = 5<br>序列化子类的时候，d和e会不会被序列化？（答案：会）</p>
<p>反过来父类未实现Serializable，子类实现了，序列化子类实例的时候，父类的属性是直接被跳过不保存，还是能保存但不能还原？（答案：值不保存）</p>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/transient.html">Java transient关键字</a></p>
</blockquote>
</details>

<h2 id="14、Java-finally与return执行顺序"><a href="#14、Java-finally与return执行顺序" class="headerlink" title="14、Java finally与return执行顺序"></a>14、Java finally与return执行顺序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先探讨下，try-catch-finally 块中的语句是否一定被执行？答案是否定的，原因有2个：</p>
<ul>
<li>如果try 语句没有被执行(比如在try 之前就return 了)，finally就不会执行。    </li>
<li>如果try 块中有 System.exit(0)这样的终止Java 虚拟机的语句的话，finally就不会执行。这可以理解，连JVM 都停止了，啥都没有了。</li>
</ul>
<p>关于finally 与return 的执行顺序，过程比较复杂，可以分为如下情况：</p>
<ul>
<li>正常情况下，finally 语句在return 语句执行之后，return 返回之前执行的。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(test11());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test11</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"try block"</span>);</span><br><span class="line">           <span class="keyword">return</span> test12();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">           System.out.println(<span class="string">"finally block"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test12</span><span class="params">()</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"return statement"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"after return"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>会输出：</p>
<blockquote>
<p>try block<br>return statement<br>finally block<br>after return     </p>
</blockquote>
<p>可以看出，try 中的return语句先执行了，但是值没有立即返回，等finally执行结束后再返回值。</p>
<ul>
<li>如果finnaly 块中有return 语句会覆盖 try 中的 return  返回。    </li>
<li>如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变(int 类型和 Map 类型)。     </li>
<li>try 块里的return 语句在异常情况下不会执行，怎么返回看情况。    </li>
</ul>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/finally-return.html">Java finally与return执行顺序</a></p>
</blockquote>
</details>

<h2 id="15、两个对象的-hashcode-相同，是否对象相同？equal-相同呢？"><a href="#15、两个对象的-hashcode-相同，是否对象相同？equal-相同呢？" class="headerlink" title="15、两个对象的 hashcode 相同，是否对象相同？equal() 相同呢？"></a>15、两个对象的 hashcode 相同，是否对象相同？equal() 相同呢？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<ol>
<li>hashCode是所有java对象的固有方法，默认返回的是该对象在jvm的堆上的内存地址，不同对象的内存地址肯定不同，所以这个hashCode也就肯定不同了。如果重载了的话，由于采用的算法的问题，有可能导致两个不同对象的hashCode相同。</li>
<li>hashCode和equals两个方法是有语义关联的，它们需要满足：<br>A.equals(B)==true –&gt; A.hashCode()==B.hashCode()，但是反之不能说hashcode相等就equals<br>因此重载其中一个方法时也需要将另一个也重载。</li>
<li>此外，请注意：hashCode的重载实现最好依赖于对象中的final属性，从而在对象初始化构造后就不再变化。一方面是jvm便于代码优化，可以缓存这个hashCode；另一方面，在使用hashMap或hashSet的场景中，如果使用的key的hashCode会变化，将会导致bug，比如放进去时key.hashCode()=1，等到要取出来时key.hashCode()=2，就取不出来数据了。<br>综上所述，hashCode相同或者equals相同并不能说明对象相同。</li>
</ol>
</blockquote>
</details>

<h2 id="16、延伸-Java-中-hashcode-的作用"><a href="#16、延伸-Java-中-hashcode-的作用" class="headerlink" title="16、延伸-Java 中 hashcode 的作用"></a>16、延伸-Java 中 hashcode 的作用</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>官方文档的定义就是：</p>
<blockquote>
<p>hashcode 方法返回对象的哈希码值，支持该方法主要是为了支持基于哈希机制的Java 集合类，如HashMap、HashSet、HashTable 等。</p>
</blockquote>
<p>hashcode的常规约定是：</p>
<blockquote>
<p>Java程序运行期间，同一个对象上多次调用 hashcode ，必须一致地返回相同的整数，而从某一应用程序的一次执行到同一程序的另一次执行，该整数无须保持一致。如果两个对象相等，那么两个对象中的每个对象上调用 hashcode 方法都必须生成相同的整数结果。</p>
</blockquote>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ouym/p/8963219.html">OUYM</a></p>
</blockquote>
</details>

<h2 id="17、延伸-为什么重写了equals-方法，要求必须重写hashcode-方法？"><a href="#17、延伸-为什么重写了equals-方法，要求必须重写hashcode-方法？" class="headerlink" title="17、延伸-为什么重写了equals 方法，要求必须重写hashcode 方法？"></a>17、延伸-为什么重写了equals 方法，要求必须重写hashcode 方法？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>根据前面的内容，总结就是：为了满足常规约定-如果两个equals 满足，就一定要求返回相同的 hashcode。举个例子，如果重写了 equals 方法，对象中 num 和data 参与了equals 比较，那么 num 和data 也要参与生成hashcode，这是为了遵守上述约定。</p>
</details>

<h2 id="18、生成hashcode-注意的事项"><a href="#18、生成hashcode-注意的事项" class="headerlink" title="18、生成hashcode 注意的事项"></a>18、生成hashcode 注意的事项</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>返回的hash值是int型，防止溢出    </li>
<li>不同对象返回的hash值尽量不同(为了hashmap 等集合减少碰撞)     </li>
<li>无论何时，对同一个对象调用hashcode()都应该产生同样的值     </li>
</ul>
<p><strong>最后一点是很重要的，也是容易出隐形bug的地方，如果将一个对象put() 到HashMap 时产生了一个 hashcode 值，而 get() 取出时却产生了另外一个hashcode，那么就无法获取该对象了。所以，如果hashcode() 方法依赖于对象中易变的数据，那就要当心了。</strong></p>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ouym/p/8963219.html">OUYM</a></p>
</blockquote>
</details>

<h2 id="19、下面代码输出的结果？"><a href="#19、下面代码输出的结果？" class="headerlink" title="19、下面代码输出的结果？"></a>19、下面代码输出的结果？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题目1</span></span><br><span class="line">String str1 = <span class="string">"hello"</span>;</span><br><span class="line">String str2 = <span class="string">"he"</span> + <span class="keyword">new</span> String(<span class="string">"llo"</span>);</span><br><span class="line">System.err.println(str1 == str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//答案是false，因为str2中的llo是新申请的内存块，而==判断的是对象的地址而非值，所以不一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//题目2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>{</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() {</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                pong();</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        t.run();</span><br><span class="line">        System.out.print(<span class="string">"ping"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pong</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.print(<span class="string">"pong"</span>);</span><br><span class="line">    }</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//输出 pongping ，这里调用的是Thread 的run 方法，与普通方法是一样的，失去线程的特性了。因此我们要启动新县城执行的时候，需要使用Thread 的 start() 方法。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//题目3，如下代码是否能正常运行？</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NULL</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"haha"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ((NULL)<span class="keyword">null</span>). test();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//能正常运行，输出 haha 。首先，null 值可以强转成任何 Java 类型，所以 (NULL)null 、(String)null 等都是合法的。其次，test 方法是static 方法，只和类名绑定，不借助对象进行访问。综上，能正常输出。反之，如果 test 非static ，就只能使用对象访问，这时候使用null对象肯定会报空指针。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//题目4，如何输出</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>{</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.print(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        System.out.print(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">People</span> </span>{</span><br><span class="line">    People father;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        System.out.print(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        father = <span class="keyword">new</span> People(name + <span class="string">":F"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.print(<span class="number">4</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//会输出132，在Java 中，子类的构造过程中必须调用其父类的构造函数，因为有继承关系存在，子类要把父类的内容继承下来。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//题目5，如何输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloA</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloA</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"HelloA"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    { </span><br><span class="line">        System.out.println(<span class="string">"I'm A class"</span>); </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> { System.out.println(<span class="string">"static A"</span>); }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloB</span> <span class="keyword">extends</span> <span class="title">HelloA</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloB</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"HelloB"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    { </span><br><span class="line">        System.out.println(<span class="string">"I'm B class"</span>); </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> { </span><br><span class="line">        System.out.println(<span class="string">"static B"</span>); </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------main start-------"</span>);</span><br><span class="line">        <span class="keyword">new</span> HelloB();</span><br><span class="line">        <span class="keyword">new</span> HelloB();</span><br><span class="line">        System.out.println(<span class="string">"-------main end-------"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//会输出如下结果：</span></span><br><span class="line"><span class="keyword">static</span> A</span><br><span class="line"><span class="keyword">static</span> B</span><br><span class="line">-------main start-------</span><br><span class="line">I<span class="string">'m A class</span></span><br><span class="line"><span class="string">HelloA</span></span><br><span class="line"><span class="string">I'</span>m B <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">HelloB</span></span></span><br><span class="line"><span class="class"><span class="title">I</span>'<span class="title">m</span> <span class="title">A</span> <span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">HelloA</span></span></span><br><span class="line"><span class="class"><span class="title">I</span>'<span class="title">m</span> <span class="title">B</span> <span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">HelloB</span></span></span><br><span class="line"><span class="class">-------<span class="title">main</span> <span class="title">end</span>-------</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">这个题目很好，考察静态语句块、构造语句块(就只有大括号的那块) 以及 构造函数执行顺序。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">对象初始化顺序：1. 类加载之后，从父类到子类执行被<span class="title">static</span> 修饰的语句； 2.<span class="title">static</span> 执行完毕后，再执行<span class="title">main</span> 方法；  3.如果有语句<span class="title">new</span>自身对象，将从父类到子类执行构造语句块、构造器。</span></span><br></pre></td></tr></tbody></table></figure>

</details>

<h2 id="20、延伸-类的初始化步骤"><a href="#20、延伸-类的初始化步骤" class="headerlink" title="20、延伸-类的初始化步骤"></a>20、延伸-类的初始化步骤</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><strong>没有父类的情况：</strong></p>
<ol>
<li>类的静态属性</li>
<li>类的静态代码块</li>
<li>类的非静态属性</li>
<li>类的非静态代码块</li>
<li>构造方法</li>
</ol>
<p><strong>有父类的情况:</strong></p>
<ol>
<li>父类的静态属性</li>
<li>父类的静态代码块</li>
<li>子类的静态属性</li>
<li>子类的静态代码块</li>
<li>父类的非静态属性</li>
<li>父类的非静态代码块</li>
<li>父类构造方法</li>
<li>子类非静态属性</li>
<li>子类非静态代码块</li>
<li>子类构造方法</li>
</ol>
<p>以题目深化理解：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>{</span><br><span class="line">        counter1 ++;</span><br><span class="line">        counter2 ++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleton</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Singleton singleton = Singleton.getSingleton();</span><br><span class="line">        System.out.println(<span class="string">"counter1 = "</span> + singleton.counter1);</span><br><span class="line">        System.out.println(<span class="string">"counter2 = "</span> + singleton.counter2);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码将输出：</p>
<blockquote>
<p>counter1 = 1<br>counter2 = 0   </p>
</blockquote>
<p>根据类初始化步骤，由于 Singleton 并没有被加载过，所以首先执行类加载步骤，在“准备”阶段，首先给静态变量赋初默认值：<br>singleton = null<br>counter1 = 0<br>counter2 = 0</p>
<p>加载和连接完毕，再进行初始化工作，依照代码写的顺序依次执行，首先执行 singleton = new Singleton();这样就会执行构造方法的内部逻辑，即此时 counter1 = 1; counter2 = 1;</p>
<p>接下来，由于counter1 只进行了定义，并没有初始化，所以counter1的值仍然为1 ；接下来，counter2 进行了定义并且赋值 0 ，则初始化阶段后，counter2 的值为0；</p>
<p>初始化完毕，要调用Singleton.getSingleton() ，由于singleton 的值已经初始化过，此时直接返回即可。因此输出 counter1 = 1，counter2 = 0。</p>
<p>反之，如果将静态变量初始化的顺序改变下：     </p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter1;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></tbody></table></figure>

<pre><code>则会输出 counter1 = 1，counter2 = 1 了，按照上述推理应该能够理解。</code></pre><blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483903&amp;idx=1&amp;sn=c20d3172052bd7db9a1ad6a95f112bc9&amp;chksm=96cda0b2a1ba29a4cc9912cb1bf8a955f97ee45a7b8db48e384f1694ddbabbd4d5e7fa90f880&amp;scene=21#wechat_redirect">码个蛋</a>，同时可以参考以前写的<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC7%E7%AB%A0/">虚拟机的相关文章</a></p>
</blockquote>
</details>

<h2 id="21、constructor-是否一定要与类名同名，方法名是否一定不能与类名同名？"><a href="#21、constructor-是否一定要与类名同名，方法名是否一定不能与类名同名？" class="headerlink" title="21、constructor 是否一定要与类名同名，方法名是否一定不能与类名同名？"></a>21、constructor 是否一定要与类名同名，方法名是否一定不能与类名同名？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>constructor 是一定要与类名同名的，但普通的类方法是可以和类名同名的，它与构造方法唯一的区别就是构造方法没有返回值。</p>
</details>

<h2 id="22、数据溢出与非法数据问题"><a href="#22、数据溢出与非法数据问题" class="headerlink" title="22、数据溢出与非法数据问题"></a>22、数据溢出与非法数据问题</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>存在使i + 1 &lt; i的数吗？答案是肯定的，比如i是int 类型，那么当i 是最大的整数时，i+1就溢出了，就可能&lt; i<br>。</p>
<p>是否存在 i&gt;j || i&lt;= j 不成立？答案是肯定的，比如：Double.NaN 或者 Float.NaN </p>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lanxuezaipiao/p/3371224.html">程序媛想事</a></p>
</blockquote>
</details>

<h2 id="23、Java-的参数传递"><a href="#23、Java-的参数传递" class="headerlink" title="23、Java 的参数传递"></a>23、Java 的参数传递</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>在讨论之前，首先看下如下代码的输出情况：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>{</span><br><span class="line"></span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">"good"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] ch = { <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> };</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>{</span><br><span class="line">        Example ex = <span class="keyword">new</span> Example();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.print(ex.str + <span class="string">" and "</span>);</span><br><span class="line">        System.out.print(ex.ch);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String paramA, <span class="keyword">char</span> paramB[])</span> </span>{</span><br><span class="line">        paramA = <span class="string">"test ok"</span>;</span><br><span class="line">        paramB[<span class="number">0</span>] = <span class="string">'g'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码输出good and gbc 。在Java 中没有引用传递，只有值传递，这个值指的是<strong>实参的地址的拷贝</strong>，得到这个值(地址拷贝)后，你<strong>可以通过它修改这个地址的内容，因为此时这个内容的地址和原地址是同一个地址，但是你不能改变这个地址本身使其重新引用到其他对象</strong>。以上的意思说明仅仅只是值传递。具体过程如果使用图示的话，如下所示：</p>
<p>str的传递：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%A0%E9%80%92.png" alt="字符串传递"></p>
<p>在change方法中重新为paramsA 赋值：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%94%B9%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80.png" alt="字符串传递"></p>
<p>ch的传递：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E4%BC%A0%E9%80%92.png" alt="数组传递"></p>
<p>在change方法中更改paramsB 的元素值：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E6%9B%B4%E6%94%B9%E5%80%BC.png" alt="数组更改值"></p>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lanxuezaipiao/p/3371224.html">程序媛想事</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35109096/article/details/81105320">RavenXRZ</a></p>
</blockquote>
</details>

<h2 id="24、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"><a href="#24、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？" class="headerlink" title="24、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"></a>24、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</h2><p>查看以前写的<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0/">这篇读书笔记</a>即可</p>
<h2 id="25、String、StringBuilder、StringBuffer、CharSequence-区别"><a href="#25、String、StringBuilder、StringBuffer、CharSequence-区别" class="headerlink" title="25、String、StringBuilder、StringBuffer、CharSequence 区别"></a>25、String、StringBuilder、StringBuffer、CharSequence 区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>CharSequence 是一个接口，String、StringBuilder、StringBuffer 都实现了这个接口，它们三个的本质都是通过<strong>字符数组</strong>实现的。</p>
<p>StringBuilder、StringBuffer 的char 数组开始的存储空间是16，如果append() 过程中超过这个容量，将会申请新的空间，并把老的数组一起复制过去。</p>
<p>StringBuffer 的每个处理方法都加上了 synchronized 关键字，因此可以说它是线程安全的。</p>
</details>

<h2 id="26、Java-中String-为毛要设计成不可变？"><a href="#26、Java-中String-为毛要设计成不可变？" class="headerlink" title="26、Java 中String 为毛要设计成不可变？"></a>26、Java 中String 为毛要设计成不可变？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="为什么说String-是不可变的"><a href="#为什么说String-是不可变的" class="headerlink" title="为什么说String 是不可变的"></a>为什么说String 是不可变的</h3><p>首先我们看源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>类使用final 修饰，说明不可继承；存放内容的 value 是个char[]数组，也是final修饰，创建以后就不可改变。说明一下，这个 value 是stack 上的一个引用，数据本身还是在heap堆上。final 修饰value ，只能是说stack 指向的引用地址是不可变的，但是堆里面的数据本身还是可变的！举例理解下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] value={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}</span><br><span class="line"><span class="keyword">int</span>[] another={<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>};</span><br><span class="line">value = another;<span class="comment">//编译器报错，final不可变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] value={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line">value[<span class="number">2</span>]=<span class="number">100</span>;<span class="comment">//这时候数组里已经是{1,2,100}</span></span><br></pre></td></tr></tbody></table></figure>

<p>通过以上代码相信就能理解上面描述的意思了。也许有人还认为String是可以变的，并且举例如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"abcd"</span>;</span><br><span class="line">a = <span class="string">"abcdef"</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>这其实不是String本身变化，只是变量a指向heap堆的指针发生了变化，而String本身并没有发生变化，示意图如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E5%9F%BA%E7%A1%80/String%E9%87%8D%E6%96%B0%E8%B5%8B%E5%80%BC.png" alt="String重新赋值示意图"></p>
<h3 id="为什么要设计成不可变"><a href="#为什么要设计成不可变" class="headerlink" title="为什么要设计成不可变"></a>为什么要设计成不可变</h3><p>首先，先得清楚 final 这个关键字。 final的出现就是为了为了不想改变，而不想改变的理由有两点：设计(安全)或者效率。</p>
<ul>
<li>字符串常量池的需要。String 带有字符串常量池的属性，如果两个字符串one和two都指向 “something” 赋值，它们其实都指向同一个内存地址。这样在大量使用字符串的情况下，可以节省内存空间，提高效率。之所以能实现这个特性，String 的不可变是必要的(如果可变，那么一个改了，所有引用常量池这个string值都会改变)。     </li>
<li>允许String对象缓存HashCode。String 对象的哈希码被频繁使用，比如在HashMap 中。     </li>
<li>其次，为了安全。多线程安全：多个线程同时读一个资源，不会引发竞态条件，但是对资源做写操作就会有危险，这样保证String使用线程安全。url、反射所需要的参数等都是String类型，如果允许改变，会引起安全隐患(比如非法访问：如果String可变，那么可以在安全检测后，修改String值，导致非法访问)。</li>
</ul>
<h3 id="一定是不可变的吗？"><a href="#一定是不可变的吗？" class="headerlink" title="一定是不可变的吗？"></a>一定是不可变的吗？</h3><p>由以上内容可知，String 是通过字符数组实现的，这个字符数组被final 修饰，因此不能重新指向其他内存区域，但是，我们可以针对这块内存区域改变值，即改变这个数组里面的内容，比如将 value[0] 的值由 ‘a’ 改成 ‘b’(当然这个过程要通过反射去实现)。</p>
<h3 id="可能令你疑惑的操作方式"><a href="#可能令你疑惑的操作方式" class="headerlink" title="可能令你疑惑的操作方式"></a>可能令你疑惑的操作方式</h3><p>我们平日开发通常情况下少量的字符串拼接其实没太必要担心，例如:</p>
<blockquote>
<p>String str = “aa”+”bb”+”cc”;</p>
</blockquote>
<p>像这种没有变量的字符串，<strong>编译阶段就直接合成”aabbcc”了，然后看字符串常量池（下面会说到常量池）里有没有，有也直接引用，没有就在常量池中生成</strong>，返回引用。</p>
<p>如果String a = “123”;这种写法是会将 “123” 放入常量池的，但是如果使用 String b = new String(“123”); 则会在堆上分配空间存放。</p>
<p>但是如果：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"aaa"</span>;</span><br><span class="line">String str2 = <span class="string">"bbb"</span>;</span><br><span class="line">String str = str1+str2;</span><br></pre></td></tr></tbody></table></figure>

<p>则在编译的时候会优化成： StringBuilder sb = StringBuilder(String.valueOf(str1))).append(str2)</p>
<p>如果：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line">sb.append(s);</span><br><span class="line">System.out.println(sb.length());</span><br></pre></td></tr></tbody></table></figure>

<p>则会输出4，因为如果是null的话，则会拼接 “null”。</p>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qingmengwuhen1/article/details/52175303?utm_source=distribute.pc_relevant.none-task">qingmengwuheng1</a> 以及 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lanzhi/p/6467072.html">岚之山</a></p>
</blockquote>
</details>

<h2 id="27、成员内部类、静态内部类、局部内部类和匿名内部类的理解"><a href="#27、成员内部类、静态内部类、局部内部类和匿名内部类的理解" class="headerlink" title="27、成员内部类、静态内部类、局部内部类和匿名内部类的理解"></a>27、成员内部类、静态内部类、局部内部类和匿名内部类的理解</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类定义在另一个类的内部，它是依赖外部类而存在的，<strong>也就是说如果要创建内部类的对象，前提是必须存在一个外部类的对象</strong>，以下是两种内部类使用情况：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">haha</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//典型用法：在当前外部内中直接使用内部类</span></span><br><span class="line">        InnerClass innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//非典型用法：使用某个类的内部类</span></span><br><span class="line">        OutBean outBean = <span class="keyword">new</span> OutBean();</span><br><span class="line">        OutBean.InnerBean = outBean.<span class="function">new <span class="title">InnerBean</span><span class="params">()</span></span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>{</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OutBean</span></span>{</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerBean</span></span>{</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意代码中典型用法和非典型用法成员内部类对象的创建，说明了内部类对象的创建是依赖于外部类对象的，尤其是： outBean.new InnerBean() 这种写法。</p>
<p>成员内部类可以用private、protected、public 及包访问权限修饰，如果成员内部类被private修饰，则只能在外部内的内部访问；如果使用public修饰，则任何地方都能访问；<strong>如果使用protected修饰，则只能在同一个包下，或者继承外部类的情况下访问</strong>；如果是默认访问权限，则只能在同一个包下访问。</p>
<p>成员内部类可以无条件访问外部类所有的成员属性和方法(包括private的和static的)，不过如果内部类和外部类有相同名称的变量或者方法时，优先访问内部类自己的，如果要访问外部类的可以如下写法：</p>
<blockquote>
<p>外部类.this.成员变量(方法)</p>
</blockquote>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于它的访问尽心阿玉方法内或者作用域内。由于类似于局部变量，所以并不能有 public、protected、private 或者 static 修饰符的。示例如如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>{<span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类我们使用很多，比如在实现点击监听的时候：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btnOk.setOnclickListener(<span class="keyword">new</span> OnclickListener(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span></span>{</span><br><span class="line">       </span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p><strong>匿名内部类是为一种没有构造器的类</strong>，大部分匿名内部类用于接口回调，一般来说，匿名内部类用于继承其他类或者接口，并不需要增加额外地方法，只是对继承方法的实现或者重写。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类定义在一个类里面，并且被static 修饰，并不需要依赖于外部类。这点和类的静态成员属性有点类似，并且它不能使用外部类的非static 成员变量或者方法。</p>
<h3 id="深入理解内部类"><a href="#深入理解内部类" class="headerlink" title="深入理解内部类"></a>深入理解内部类</h3><h4 id="1、为什么成员内部类可以无条件访问外部类成员？"><a href="#1、为什么成员内部类可以无条件访问外部类成员？" class="headerlink" title="1、为什么成员内部类可以无条件访问外部类成员？"></a>1、为什么成员内部类可以无条件访问外部类成员？</h4><p>因为编译器会默认为内部类构造器中添加一个参数，这个参数是外部类对象的一个引用，所以它能直接访问外部内的成员。这也从侧面说明成员内部类为什么要依赖于外部类的对象。</p>
<h4 id="2、为什么局部内部类和匿名内部类只能访问局部final-变量？"><a href="#2、为什么局部内部类和匿名内部类只能访问局部final-变量？" class="headerlink" title="2、为什么局部内部类和匿名内部类只能访问局部final 变量？"></a>2、为什么局部内部类和匿名内部类只能访问局部final 变量？</h4><p>我们首先看如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(){</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        }</span><br><span class="line">    }.start();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果把变量a或者b任意一个final 去掉，代码就编译不过。至于为什么，我们首先考虑一个问题：当test 方法执行完成后，变量a的生命周期结束了，而Thread对象的生命周期可能还没结束，那么在Thread的run方法中继续访问a就实现不了了，但是又要实现这样的效果，怎么办？Java中采用了 <font color="#ff0000">复制</font> 手段来解决，也就是将a复制到Thread对象中。</p>
<p><strong>也就是说，如果局部变量的值在编译期间就能确定，则直接在匿名内部类中创建一个拷贝；如果局部变量的值无法再编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值</strong></p>
<h3 id="内部类的场景和好处"><a href="#内部类的场景和好处" class="headerlink" title="内部类的场景和好处"></a>内部类的场景和好处</h3><ul>
<li>每个内部类都能独立继承一个接口实现，所以无论外部类是否已经继承了某个实现，对内部类都没有影响。<strong>内部类使得多继承的解决方案变得完整</strong>。    </li>
<li>方便将存在一定逻辑关系的类组织在一起，又可以对外隐藏     </li>
<li>方便编写事件驱动程序(如实现点击监听)     </li>
</ul>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3811445.html">Matrix海 子</a></p>
</blockquote>
</details>

<h2 id="28、多维数组在内存上是怎么存储的"><a href="#28、多维数组在内存上是怎么存储的" class="headerlink" title="28、多维数组在内存上是怎么存储的"></a>28、多维数组在内存上是怎么存储的</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Java 中的多维数组就是通过一维数组来实现的，只不过这个一维数组中的元素还是多维数组，比如如下声明：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>];  </span><br></pre></td></tr></tbody></table></figure>

<p>它实际上大致等同于如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][][];  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) {  </span><br><span class="line">  a[i] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length; j++) {  </span><br><span class="line">    a[i][j] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];  </span><br><span class="line">  }  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>



<p>如果要自己用一维数组去实现二维(或者更多维)的数组，可以使用类似规律： k = j*(j-1)/2 + i -1 来计算出在一维数组中的下标 k 值。</p>
</details>

<blockquote>
<p>以上代码参考自<a target="_blank" rel="noopener" href="https://www.iteye.com/blog/rednaxelafx-1050144">iteye中的博客</a></p>
</blockquote>
<h2 id="29、泛型"><a href="#29、泛型" class="headerlink" title="29、泛型"></a>29、泛型</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>一个很经典的例子，可以告诉我们为什么需要泛型：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"aaa"</span>);</span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt; list.size();i++) {</span><br><span class="line">    String item = (String)list.get(i);</span><br><span class="line">    Log.d(<span class="string">"Test"</span>, <span class="string">"item = "</span> + item);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述例子for语句上面的操作<strong>都是合法的</strong>，但是在for语句里面，执行到i==1的时候，会报错(<strong>运行的时候</strong>报错)：</p>
<blockquote>
<p>java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</p>
</blockquote>
<p>为了能够在编译期间就能发现这种问题，就可以使用泛型，如下所示：</p>
<blockquote>
<p>List<string> list = new ArrayList<string>();</string></string></p>
<p>list.add(100);//编译阶段就会报错</p>
</blockquote>
<p>所以，在被问到 <strong>”我初始化一个List，但是没有指定类型，那么，我是不是可以添加任何类型的值？“，那么，答案是肯定的，可以添加任何类型的值，只要你能正确取出(在取的时候，知道每个位置存储的元素的类型)</strong>，我自己写的例子如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"aaa"</span>);</span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt; list.size();i++) {</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) {</span><br><span class="line">        System.out.println((String)list.get(i));</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>) {</span><br><span class="line">        System.out.println((<span class="keyword">int</span>)list.get(i));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>泛型只在编译阶段有效，运行阶段会将特定类型擦除：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么strlist.getClass 与 integerList.getClass 的结果是一样的(equals比较)</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h3><p>泛型有三种使用方式，泛型类、泛型接口、泛型方法。一个普通的泛型类如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt;</span>{</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(T key)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>然后，我们日常的使用就是类似如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test&lt;String&gt; testString = <span class="keyword">new</span> Test&lt;String&gt;(<span class="string">"123"</span>);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Test&lt;Integer&gt; testInt = <span class="keyword">new</span> Test&lt;Integer&gt;(<span class="number">456</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>我们定义了泛型类，我们就一定要传入泛型类型的实参么？想想我们最开始的那个例子，很显然并不是这样的。<strong>在使用反省的时候如果传入泛型实参，则会根据传入的泛型实参做相应限制，此时泛型才会起到应有的作用；如果不传入泛型类型的实参，则可以为任何类型。</strong>看如下例子都是合法的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test test1 = <span class="keyword">new</span> Test(<span class="string">"111"</span>);</span><br><span class="line">Test test2 = <span class="keyword">new</span> Test(<span class="number">222</span>);</span><br><span class="line">Test test3 = <span class="keyword">new</span> Test(<span class="keyword">false</span>);</span><br></pre></td></tr></tbody></table></figure>



<p>这里要注意一点，泛型类型的参数只能是类类型，<strong>不能是简单类型</strong>。</p>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型的接口示例如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="comment">//当然，实现的时候，可以不传入泛型实参</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestImp</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt;</span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然，你也可以传入实参</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestImpl</span> <span class="keyword">implements</span> <span class="title">Test</span>&lt;<span class="title">String</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>通配符一般使用 ? 代替具体的类型实参，注意这个 ? 是类型实参，不是类型形参。再直白一点，此处的 ? 和 Number、String、Integer 是一样的，都是一种实际类型，具体代码表示如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue</span><span class="params">(Test&lt;?&gt; test)</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"key is :"</span> + test.getKey());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样可以解决当具体类型不知道的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，那么可以用 ? 来表示未知类型。</p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法的定义相对复杂，泛型方法是指在调用方法的时候指明泛型的具体类型，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">func</span><span class="params">(Class&lt;T&gt; tClass)</span> <span class="keyword">throws</span> InstantiationException </span>{</span><br><span class="line">    T instance = tClass.newInstance();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者 返回类型为 void</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t)</span> </span>{</span><br><span class="line">    System.out.println(t.toString());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然，方法的泛型可以和类的泛型不一样</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="comment">//E 可以是任意类型，可以与类型T相同，也可以不同</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(E t)</span></span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h3><p>静态方法有一种情况需要注意，那就是在类的静态方法中使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span>&lt;<span class="title">T</span>&gt;</span>{</span><br><span class="line">    <span class="comment">//如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明(将这个方法定义成泛型方法)，即使静态方法要使用的泛型已经在类中的泛型生命果也不行</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h3><p>List&lt;? extends Animal&gt;，?表示的类型可以是<strong>Animal类型本身</strong>和Animal的子类。可以把Animal称为这个通配符(?)的上限(upper bound)。</p>
<p>&lt;? super Type&gt; 通配符 ? 表示它必须是<strong>Type本身</strong>，或是Type的父类</p>
</details>

<blockquote>
<p>以上内容参考自 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/coprince/p/8603492.html">博客园上的博客</a>、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/00d50c1e46a9">简书上的博客</a></p>
</blockquote>
<h2 id="30、谈谈Java集合中那些线程安全的集合-amp-实现原理"><a href="#30、谈谈Java集合中那些线程安全的集合-amp-实现原理" class="headerlink" title="30、谈谈Java集合中那些线程安全的集合 &amp; 实现原理"></a>30、谈谈Java集合中那些线程安全的集合 &amp; 实现原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>



<p>暂无</p>
</details>



<h3 id="31、注解"><a href="#31、注解" class="headerlink" title="31、注解"></a>31、注解</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>在JAVASE中的注解有3个它们分别是：@Overried 重写，@Deprecated 不建议使用，@SupperssWarning 去除警告信息 。</p>
<p>注解格式如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称{</span><br><span class="line">    属性列表;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>如果说注释是写给人看的，那么注解就是写给程序看的。<strong>它更像一个标签，</strong>贴在一个类、一个方法或者字段上。它的目的是<strong>为当前读取该注解的程序提供判断依据及少量附加信息。</strong>比如程序只要读到加了@Test的方法，就知道该方法是待测试方法。</p>
<p>@interface和interface从名字上看非常相似，我猜注解的本质是一个接口（当然，这是瞎猜）。为了验证这个猜测，我们做个实验。先按上面的格式写一个注解（暂时不附加属性）：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3%E7%B1%BB.jpeg" alt="注解类"></p>
<p>之后，反编译：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E7%BC%96%E8%AF%91%E6%B3%A8%E8%A7%A3.jpeg" alt="注解类"></p>
<p><strong>我们发现，@interface变成了interface，而且自动继承了Annotation ！</strong></p>
<p>为了探究原理，首先我们看一下Overried 注解的底层实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>其中Overried注解的上面有两行代码其中一行的修饰符为@Target和@Retention这两个注解是元注解，元注解用来修饰注解，我们来看看这两个注解的底层实现:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation interface</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation interface</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>Target注解的类里面有一个属性名叫value，他是个数组类型，我们再看看Target注解的用法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target({ElementType.METHOD,ElementType.TYPE,ElementType.FIELD})</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> huhu {</span><br><span class="line">        </span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<p><strong>Target表示注解修饰的地方</strong>，常用的有3个分别是加载在类上，方法上或者属性上。分别为：ElementType.METHOD,ElementType.TYPE,ElementType.FIELD</p>
<p><strong>Retention表示什么时候读取到这个注解</strong>，RetentionPolicy.SOURCE代表源文件读取注解，RetentionPolicy.Class代表编译后读取注解，RetentionPolicy.RUNTIME 代表运行时读取到注解。</p>
<p>以下以一个完整例子展示如何使用注解：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMain</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">       <span class="comment">// 获取类上的注解</span></span><br><span class="line">        Class&lt;Demo&gt; clazz = Demo.class;</span><br><span class="line">        Huhu annotationOnClass = clazz.getAnnotation(Huhu.class);</span><br><span class="line">        System.out.println(annotationOnClass.getValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取成员变量上的注解</span></span><br><span class="line">        Field name = clazz.getField(<span class="string">"name"</span>);</span><br><span class="line">        Huhu annotationOnField = name.getAnnotation(Huhu.class);</span><br><span class="line">        System.out.println(annotationOnField.getValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取hello方法上的注解</span></span><br><span class="line">        Method hello = clazz.getMethod(<span class="string">"hello"</span>, (Class&lt;?&gt;[]) <span class="keyword">null</span>);</span><br><span class="line">        Huhu annotationOnMethod = hello.getAnnotation(Huhu.class);</span><br><span class="line">        System.out.println(annotationOnMethod.getValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取defaultMethod方法上的注解</span></span><br><span class="line">        Method defaultMethod = clazz.getMethod(<span class="string">"defaultMethod"</span>, (Class&lt;?&gt;[]) <span class="keyword">null</span>);</span><br><span class="line">        Huhu annotationOnDefaultMethod = defaultMethod.getAnnotation(Huhu.class);</span><br><span class="line">        System.out.println(annotationOnDefaultMethod.getValue());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Target({ElementType.METHOD,ElementType.FIELD,ElementType.TYPE})</span></span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> Huhu {</span><br><span class="line">        <span class="function">String <span class="title">getValue</span><span class="params">()</span> <span class="keyword">default</span> "no description"</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Huhu(getValue = "onClass")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>{</span><br><span class="line">        <span class="meta">@Huhu(getValue = "onFild")</span></span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Huhu(getValue = "onMethod")</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>{}</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Huhu()</span><span class="comment">//故意不指定，则会拿默认值</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span></span>{}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>根据反射，可以获得各个位置的值，Class、Method、Field对象都有个<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=getAnnotation()方法&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a1724982163}"="">getAnnotation()方法</a>，可以获取<strong>各自位置上</strong>的注解信息。</p>
</details>

<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24401191">知乎</a>、以及 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2f2460e6f8e7">简书上的博客</a></p>
<h3 id="32、序列化"><a href="#32、序列化" class="headerlink" title="32、序列化"></a>32、序列化</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h4 id="关于构造函数"><a href="#关于构造函数" class="headerlink" title="关于构造函数"></a>关于构造函数</h4><p>反序列化时，并没有通过 Person 类的构造函数，不管是有参的还是无参的，<strong>它是根据序列化的数据创建的</strong></p>
<h4 id="关于序列化的部分"><a href="#关于序列化的部分" class="headerlink" title="关于序列化的部分"></a>关于序列化的部分</h4><ul>
<li><p>被static和transient修饰成员无法按默认方式序列化。</p>
</li>
<li><p><strong>父类</strong>也需要实现Serializable接口才能把父类属性序列化。</p>
</li>
<li><p>父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象</p>
</li>
</ul>
<h4 id="关于同一对象多次序列化"><a href="#关于同一对象多次序列化" class="headerlink" title="关于同一对象多次序列化"></a>关于同一对象多次序列化</h4><p>如果执行2次  ObjectOutputStream..writeObject(obj); 则第二次写入对象时文件只增加了 5 字节，并且2次反序列化后两个对象是相等的，这是为什么呢？因为Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。</p>
<h4 id="自定义序列化过程"><a href="#自定义序列化过程" class="headerlink" title="自定义序列化过程"></a>自定义序列化过程</h4><p>虚拟机会试图调用对象类里的 writeObject ()和 readObject() 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject() 方法以及 ObjectInputStream() 的 defaultReadObject 方法。由于可以自定义，使用writeObject()和 readObject() 方法,可以序列化static和transient修饰的成员</p>
<p>Externalizable完全定制序列化</p>
</details>

<p>以上内容参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/gzj_vip/article/details/47295765">敲破苍穹的博客</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">161</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共338k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/11/',]
      });
      });
  </script>


</body>
</html>
