<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/4/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">38</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">218</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/14/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/07-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%80%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/14/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/07-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%80%E8%8A%82/" class="post-title-link" itemprop="url">07-网络编程-第一节</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-14 13:58:00" itemprop="dateCreated datePublished" datetime="2023-06-14T13:58:00+08:00">2023-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:41:51" itemprop="dateModified" datetime="2023-06-28T22:41:51+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>不知道咋地没内容，下次看</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/14/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%80%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/14/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%80%E8%8A%82/" class="post-title-link" itemprop="url">06-网络编程-第一节</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-14 09:36:00" itemprop="dateCreated datePublished" datetime="2023-06-14T09:36:00+08:00">2023-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:38:12" itemprop="dateModified" datetime="2023-06-28T22:38:12+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、计算机网络体系结构"><a href="#一、计算机网络体系结构" class="headerlink" title="一、计算机网络体系结构"></a>一、计算机网络体系结构</h2><p>因为最开始是为了在军事上防止一次打击就全部毁灭，所以TCP/IP 设计就是为了去中心化。</p>
<p>OSI 七层模型：应（用层）、表（示层）、会（话层）、传（输层）、网（络层）、数（据链路层）、物（理层）</p>
<p>TCP/IP 四层模型： （应用层）、（传输层）、（网络层）、（数据链路层）</p>
<h2 id="二、TCP-IP协议族（上）"><a href="#二、TCP-IP协议族（上）" class="headerlink" title="二、TCP/IP协议族（上）"></a>二、TCP/IP协议族（上）</h2><p>我们所说的 TCP/IP 其实是个协议族，并不单单说的 tcp 或者 ip 协议。覆盖最上层的 应用层（HTTP、DNS等）一直到 物理层。</p>
<p>严格来讲，3G、4G、5G 是哪一层？物理层</p>
<p>我们平时发送消息给对方整个过程可以用如下的图表示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="网络传输中的数据"></p>
<p>在应用层使用 UDP 自己实现连接和重传，可以加速网络速度，因为系统自带的 TCP 是很保守的。</p>
<h2 id="三、TCP-IP协议族（下）"><a href="#三、TCP-IP协议族（下）" class="headerlink" title="三、TCP/IP协议族（下）"></a>三、TCP/IP协议族（下）</h2><p>端口号是用于区分不同的应用的。属于传输层的东西。</p>
<p>TCP 可靠性是怎么保证的？超时重传，应答确认。正是因为设计之初为了保证若干物理线路被摧毁还能保证正常运行，所以相对而言还是挺复杂的。</p>
<p>流量控制：每次高速对方我最多能接收多少数据。</p>
<p>DNS 主要使用 UDP ，但是有时候也使用 TCP</p>
<h2 id="四、三次握手建立连接"><a href="#四、三次握手建立连接" class="headerlink" title="四、三次握手建立连接"></a>四、三次握手建立连接</h2><p>建立连接的三次握手：</p>
<ol>
<li><p>客户端发起连接，SYN = 1 ，seq = x ，之后进入 SYN_SENT 状态</p>
</li>
<li><p>服务端收到后，返回 SYN = 1，ACK = 1，ack = x +1， seq = y ，之后进入 SYN_RCVD 状态</p>
</li>
<li><p>客户端收到后，返回 ACK = 1，ack = y + 1，之后客户端进入 ESTABLISHED 状态；服务端收到之后，也进入 ESTABLISHED 状态</p>
</li>
</ol>
<blockquote>
<p>其中，大写的 比如 SYN 、ACK 等都表示标记位，小写的如 ack、seq 等表示值</p>
</blockquote>
<p>面试官：为什么是 3 次，不是 2 次或者 4 次？</p>
<p>首先回复三次握手的过程。之后，给出答案：通知对方序列号，并且确保对方已经收到。</p>
<p>SYN 洪泛攻击，虚假ip只发送第一次 syn 连接，由于服务器收到之后就进入到了 SYN_RCVD 状态，并且回复 ack 数据，但是永远得不到回复；所以解决的方案：1）无效连接的监控和释放  2） 防火墙处理，真正连接后才分配资源</p>
<p>抓包的原理： 操作系统允许你越过传输层和网络层，直接获取到 链路层 <strong>原始Socket</strong>的值</p>
<p>如果想了解更多 WebSocket 的内容《Html5 Websocket 权威指南》</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/13/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8810%EF%BC%892021.12.30-%E5%AE%9E%E6%88%98--MVx%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2(1)%20---Allen%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/13/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8810%EF%BC%892021.12.30-%E5%AE%9E%E6%88%98--MVx%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2(1)%20---Allen%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（10）2021.12.30-实战--MVx的演进史(1) ---Allen老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-13 15:19:00" itemprop="dateCreated datePublished" datetime="2023-06-13T15:19:00+08:00">2023-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:07:30" itemprop="dateModified" datetime="2023-06-28T22:07:30+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>大约 6次课。MVx 的演进史。</p>
<p>MVVM 系列的课程先不听了，先搞面试要紧的，后续听 10~14课</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/12/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8808%EF%BC%892021.12.26-PKMS%20Android11.0%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB---Derry%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/12/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8808%EF%BC%892021.12.26-PKMS%20Android11.0%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB---Derry%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（08）2021.12.26-PKMS Android11.0 源码阅读---Derry老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-12 17:59:00" itemprop="dateCreated datePublished" datetime="2023-06-12T17:59:00+08:00">2023-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:03:39" itemprop="dateModified" datetime="2023-06-28T22:03:39+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>大厂面试，我们主要是 AMS ，这个要理解透。</p>
<p>PKMS 是啥？ PackageManagerService。这里要区分 PMS （PowerManagerService）</p>
<p>Launcher查询PKMS 就能得到所有的安装应用。PKMS 的主要职责：</p>
<ul>
<li>解析 AndroidManifest.xml 文件，解析清单文件中的所有节点信息</li>
<li>扫描 apk 文件，安装系统应用，本地应用等</li>
<li>管理本地应用：包括安装、卸载、应用信息查询</li>
</ul>
<p>细节点：为什么大家看源码不使用 AS ，主要是因为使用 AS 看源码有很多文件是被阉割过的，比如你想找 PKMS 中 Binder 通信用到的 aidl 文件，是找不到的，必须要下载完整源码（10个多G），AS 上的源码是找不到的。</p>
<p>Android 三大命脉——AMS、BInder、Handler</p>
<p>现在的桌面一般都是 Launcher3 。面试题：桌面上的应用是怎么展示的？</p>
<p>Launcher3 是系统应用，在 packages/app/Launcher3.apk 路径下跨进程通信向 PKMS  请求获得</p>
<p>手机开机很慢，大概什么问题？</p>
<p>开机过程service 启动总共有7部曲：</p>
<p>startBootstrapService中做的事情：</p>
<ul>
<li>启动 installer 服务</li>
<li>获取设备是否加密</li>
<li>调用 PKMS.main 实例化 PKMS （启动 30s ，将近有20s都在这里）</li>
<li>设备的加密操作</li>
</ul>
<p>startOtherService中做的事情：</p>
<ul>
<li>dex 优化操作</li>
<li>磁盘优化维护操作</li>
<li>PKMS准备就绪</li>
</ul>
<p>上面总共 7 个步骤，7个步骤中PKMS 的构造函数很耗时，dex 优化很耗时，要着重关注。</p>
<p>ROM 开发代码改动很少的，可能看代码2周，改了1行代码。编译都要1晚上，所以我们一般不能用调试的方法去发现问题，需要认真看日志，会看日志，正确打印日志。</p>
<p>为什么PKMS源码？</p>
<p>ROM定制开发</p>
<p>Launcher 开发</p>
<p>PKMS 扫描所有的系统应用，接着扫描用户应用，将这些安装信息保存在内存中，PKMS 就会保存这些安装的应用。</p>
<p>Android 安装APK 的原理？</p>
<ul>
<li>第一步：Copy apk</li>
<li>第二步：扫描指定目录的 apk<blockquote>
<p>所以，每次系统启动，都会扫描所有应用，安装的应用越多，启动越慢</p>
</blockquote>
</li>
</ul>
<p>MainActivity 跳转 SecondActivity （在 AndroidManifest.xml 中指定了 Launchmode了），请问，是在哪里解析这个 launchMode 的？</p>
<p>答：在 PKMS 扫描APp 的时候，就已经解析出来了</p>
<p>为什么手机开机后，我能收到开机广播？</p>
<p>因为开机时，PKMS 构造函数中已经扫描了所有 APK清单文件了，<strong>（静态广播）已经注册了</strong>。</p>
<p>新应用安装时间很长，是为什么？</p>
<p>安装完成后需要 App 扫描，还有更耗时的 APK 优化</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/12/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8807%EF%BC%892021.12.23-WMS%E5%8A%9F%E8%83%BD%E8%AE%B2%E8%A7%A3---colin%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/12/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8807%EF%BC%892021.12.23-WMS%E5%8A%9F%E8%83%BD%E8%AE%B2%E8%A7%A3---colin%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（07）2021.12.23-WMS功能讲解---colin老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-12 16:26:00" itemprop="dateCreated datePublished" datetime="2023-06-12T16:26:00+08:00">2023-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:01:57" itemprop="dateModified" datetime="2023-06-28T22:01:57+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、MS启动和重要属性"><a href="#一、MS启动和重要属性" class="headerlink" title="一、MS启动和重要属性"></a>一、MS启动和重要属性</h2><p>WMS 的职责一览如下图所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/WMS%E8%81%8C%E8%B4%A3.png" alt="WMS职责"></p>
<p>形象的比喻就是，各个 ViewRoot 是演员的动作和表情，WMS 就是导演，负责舞台效果，演员站位，SurfaceFlinger 就是摄像机，捕捉当前画面，然后呈现给观众。</p>
<p>这里有个隐藏的彩蛋：Handler 的 runWithScissors 方法，这个方法是系统隐藏的，不让我们正常调用，这里可能引发出一个面试题：如何在子线程通过 Handler 向<strong>主线程</strong>发送一个任务，并等主线程<strong>处理完这个任务后</strong>，再继续执行子线程的后续内容？</p>
<blockquote>
<p>这时候就可以借助 runWithScissors() 方法。其原理也是 wait 和 notify 来实现</p>
</blockquote>
<h2 id="二、Surface创建过程"><a href="#二、Surface创建过程" class="headerlink" title="二、Surface创建过程"></a>二、Surface创建过程</h2><p>在 ViewRootImpl 创建时会 new 一个 Surface 。Android 中每个 Activity 都有一个画布（在应用端叫做 Surface ，在SurfaceFlinger 端叫做 Layer）</p>
<h2 id="三、Surface-写入数据"><a href="#三、Surface-写入数据" class="headerlink" title="三、Surface 写入数据"></a>三、Surface 写入数据</h2><p>略过，以及后面的《加窗口流程》、《件输入原理》都忽略，听着想睡觉，后续听</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/12/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8806%EF%BC%892021.12.21-WindowManager%E5%AF%B9%E7%AA%97%E5%8F%A3%E7%9A%84%E6%93%8D%E4%BD%9C---Colin%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/12/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8806%EF%BC%892021.12.21-WindowManager%E5%AF%B9%E7%AA%97%E5%8F%A3%E7%9A%84%E6%93%8D%E4%BD%9C---Colin%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（06）2021.12.21-WindowManager对窗口的操作---Colin老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-12 09:55:00" itemprop="dateCreated datePublished" datetime="2023-06-12T09:55:00+08:00">2023-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:59:33" itemprop="dateModified" datetime="2023-06-28T21:59:33+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、Window-总览"><a href="#一、Window-总览" class="headerlink" title="一、Window 总览"></a>一、Window 总览</h2><p>window 是屏幕上一块区域，但不是实实在在的，实际显示的是 View 。WMS、WindowManager 以及 Window 之间的关系如下：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/window%E7%9B%B8%E5%85%B3%E6%96%B9%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="Window相关方的关系"></p>
<ul>
<li><p>Window： 窗口的概念，Android 中所有的师徒都依赖于 Window 显示</p>
</li>
<li><p>WindowManager ： 管理 Window ，包括 增、删、更新 等操作，类似一个代理的概念，最终要丢给 WMS 去实际操作。</p>
</li>
<li><p>WMS ： Window 最终管理者，负责 window 的启动、添加、删除，Window 的大小和层级也是 WMS 管理的</p>
</li>
</ul>
<h3 id="1-1-Window-分类"><a href="#1-1-Window-分类" class="headerlink" title="1.1 Window 分类"></a>1.1 Window 分类</h3><p>Application Window</p>
<p>xxxx</p>
<p>statusBar 和 searchBar 等居然也都是 System Window 。</p>
<p>打电话时，脸靠近手机的时候，黑屏 以及 脸不能按屏幕上的按钮，这些都是 Window 的标记来实现的。</p>
<h2 id="二、WindowManager"><a href="#二、WindowManager" class="headerlink" title="二、WindowManager"></a>二、WindowManager</h2><p>WindowManager 在应用层。WindowManager 是继承了 ViewManager 的，这里发散以下， ViewGroup 也是实现了 ViewManager ，联动一下。</p>
<p>Activity 的 attach 方法里面，会创建 Window ，以及 绑定到 WindowManager 。</p>
<p>Activity 中 Window 下最直接管理的 View 是 DecorView ，示意图如下：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/DecorView.png" alt="DecorView"></p>
<p>注意，我们平时在代码中调用 setContentView 是我们上图蓝色部分的 ContentView 吗？答案不是的，我们 setContentView 的 View 到时候会作为上述 蓝色 ContentView 的子 View 。</p>
<p>我们都说onResume 的时候，是可见可操作的。这里其实应该是Activity 可见 ，就是 Activity 已经创建好了！但其实里面的元素还是不可见的，因为 performResume 之后，才会执行 window.addView 将 View 添加进去，所以，要注意区分。</p>
<p>WindowManagerGlobal 主要的职责是：</p>
<ul>
<li><p>设置view的参数（layoutparams）</p>
</li>
<li><p>创建 ViewRootImpl </p>
</li>
</ul>
<p>其中，WindowManagerGlobal 的 addView 方法中会创建 ViewRootImpl 的对象。</p>
<p>总结一下各方关系就是：每个 Activity 都有一个 PhoneWindow ，每个 PhoneWindow 中有个根 View——DecorView ，并且PhoneWindow 中有个 WindowManagerImpl 用于管理 Activity 中 VIew 的细节，然后 WindowManagerGlobal 用于全局管理所有的 WindowManagerImpl ，示意图如下所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/WindowManagerGlobal.png" alt="Window各方关系如下"></p>
<h2 id="三、绘制流程"><a href="#三、绘制流程" class="headerlink" title="三、绘制流程"></a>三、绘制流程</h2><p>在 ViewRootImpl 中，接收到同步信号的时候，就会触发 performTraversalses() 方法，在里面会执行 performMeasure、performLayout、performDraw 等，</p>
<h3 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h3><p>ViewRootImpl 的功能主要体现在如下几个方面：</p>
<ul>
<li><p>作为 View 树的树根（注意，它自己并不是View，只是树根的意思而已）并管理 View 树</p>
</li>
<li><p>触发 View的测量、布局和绘制</p>
</li>
<li><p>输入响应的中转站</p>
</li>
<li><p>负责与 WMS 进行进程间通信</p>
</li>
</ul>
<p>关于输入响应的中转站，我们可以看如下图：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B.png" alt="ViewRootImpl是输入的中转站"></p>
<p>事件产生后，会传递到 ViewRootImpl 中，之后被传递给 DecorView ，我们根据这个步骤可以看到，这里面传递很弯弯绕绕，DecorView 传递给Acitivty ，第 3 步的时候，又回到了 DecorView 中。</p>
<p>为什么要这么设计呢？省略中间商赚差价直接到 ViewGroup 行不行？答案是不行。因为诸如打电话脸贴到屏幕上时需要黑屏，点击操作不能响应等操作， View 和 ViewGroup 上面没有相关的处理机制的，都在 PhoneWindow 里面，所以必须经过 PhoneWindow 。</p>
<p>view 或者 Window 的刷新都依赖于 ViewRootImpl 中的 scheduleTraversals 方法。</p>
<h3 id="UI刷新"><a href="#UI刷新" class="headerlink" title="UI刷新"></a>UI刷新</h3><p>以 2 个问题开始：</p>
<ul>
<li><p>TextView 连续 2 次setTextView ，那么会触发几次重绘？</p>
</li>
<li><p>Android 为什么要求帧率是 60？</p>
</li>
</ul>
<p>答案：UI必须等待 16ms 的间隔才会绘制下一帧，所以连续2次 setTextView 只会触发一次重绘。同时必须每秒 60 帧（电影是 24 帧）用户才不会感觉卡顿，所以就 16ms 就要一帧。</p>
<p>关于刷新的整体流程我们可以参考如下图：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/UI%E5%88%B7%E6%96%B0.png" alt="刷新整体流程"></p>
<p>从图可以看出，setText 之后，就会触发 invalidate ，由于 View 自己不能刷新，需要向上请示老大，一直到 ViewRootImpl ，而 ViewRootImpl 自己也不能刷新，只能插入同步栅栏，等待下一次的 Vsync 信号（通过编舞者postcallback）来了之后再绘制。<strong>等到 Vsync 信号来了之后，我们会把同步栅栏给移除掉</strong>。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总结一下主要有几点需要注意：</p>
<ul>
<li><p>Android 一般是 60FPS ，是 VSYNC 决定的，每 16ms 最多一帧</p>
</li>
<li><p>VSYNC 要客户端主动申请，才又 VSYNC 到来才会刷新</p>
</li>
<li><p>UI没有更改的话，不会请求 VSYNC 也就不会有刷新</p>
</li>
<li><p>UI局部重绘其实只会去重绘有更新的 View</p>
</li>
</ul>
<h3 id="SurfaceFlinger"><a href="#SurfaceFlinger" class="headerlink" title="SurfaceFlinger"></a>SurfaceFlinger</h3><p>SurfaceFlinger 是整个 Android 系统渲染的核心进程，整个流程是这样的：每个 DecorView 对应一个 Surface ，每个 Surface 里面包含一个 canvas ，每个 surface 对应一个 layer（图层）， SurfaceFlinger 将各类的图层合成。</p>
<p>SurfaceFlinger 的整体流程如下图所示：</p>
<p><img src="" alt="SurfaceFlinger整体流程"></p>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>onResume 里面度量的宽高有效吗？</p>
<p>分情况。Activity 第一次调用 onResume 的时候是无效的，从 Activity A 跳转到 B 再返回来，这时候 A 的onResume 中是有效的。因为 onResume 的时候，还没有 执行 window.addView 呢。</p>
<p>Activity 、Window、view 三者的联系和区别。</p>
<p>先整体，再细节。所以先讲这3个是啥，Activity 是xxx，window 是xxx，View 是xxx。Activity 没有界面，委托给 Window 展示，</p>
<p>首次 View 的绘制流程是什么时候触发的？</p>
<p>WindowManagerImpl.addView -&gt; WindowManagerGlobal.addView</p>
<p>ViewRootImpl.setView -&gt; ViewRootImpl.requestLayout</p>
<p>ViewRootImpl.scheduleTraversals  </p>
<p>这时候就触发了首次绘制</p>
<p>我们调用 invalidate() 之后会马上进行屏幕刷新吗？</p>
<p>一定不。需要等到下一个 Vsync 信号来了才会</p>
<p>我们说丢帧是因为主线程做了耗时操作，为什么做了耗时操作就会引起丢帧？</p>
<p>一言以蔽之：主线程的耗时操作会影响下一帧的绘制。我们知道有以下信息：</p>
<ul>
<li><p>在 ViewRootImpl 的 scheduleTravesals 方法中会去发送同步屏障，接着发送异步 Message，用于处理 UI 更新</p>
</li>
<li><p>在Handler 机制中碰到 target == null 这种 Message 的时候，就知道这是同步屏障了，此后，就只执行异步 Message</p>
</li>
<li><p>我们知道主线程耗时操作的体现形式也是 Message</p>
</li>
<li><p>如果有耗时操作之前的消息有耗时操作，那么可能耗时导致推迟执行 同步屏障那个 Message ，也就推迟了后续的 异步 Message的执行，也就影响了下一帧的绘制</p>
</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8805%EF%BC%892021.12.19-%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%B3%A8%E5%86%8C%E7%9A%84Activity---leo%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8805%EF%BC%892021.12.19-%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%B3%A8%E5%86%8C%E7%9A%84Activity---leo%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（05）2021.12.19-如何启动一个没注册的Activity---leo老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-10 15:20:00" itemprop="dateCreated datePublished" datetime="2023-06-10T15:20:00+08:00">2023-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:52:52" itemprop="dateModified" datetime="2023-06-28T21:52:52+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、前情回顾"><a href="#一、前情回顾" class="headerlink" title="一、前情回顾"></a>一、前情回顾</h2><p>init 操作主要是解析 init.rc 文件，它是用户空间的鼻祖。</p>
<p>zygote 是 Java 进程的鼻祖，系统启动的过程在 zygote 之前都是运行在 c/c++ ，初始化运行环境  Android RunTime ，zygote 开始才进入 Java。</p>
<p>zygote 通过 fork 创建 SystemServer 进程，这里面有各种 Android 的服务，比如 AMS 等</p>
<p>Activity 启动通信过程中需要注意一点：Launcher 进程获取通信代理对象（下图第1步）在 10.0 之前  是 AMS ，在 10.0 之后获取到的是 ATMS ，老师说在面试的时候要说下，整个流程如下图所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Activity%E5%90%AF%E5%8A%A8%E5%9B%BE.jpg" alt="Activity启动通信图"></p>
<h3 id="1-1-Activity-的管理"><a href="#1-1-Activity-的管理" class="headerlink" title="1.1 Activity 的管理"></a>1.1 Activity 的管理</h3><p>在哪里对 Activity 的栈进行管理，Activity 信息的管理？</p>
<p>答案是在 ActivityStarter 这个类当中（com.android.server.wm 这个包名下的）。在 AMS里面会执行 ActivityStarter.execute() 方法，在 execute 方法里面，会调用 ActivityStarter 的内部类 Request 的 resolveActivity ，在这里面<strong>首先获取到 ResolveInfo 数据，之后根据 ResolveInfo 数据获取到 activityInfo 数据**</strong>，至此 Activity 信息就获取到了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activityInfo = supervisor.resolveActivity(intent, resolveInfo, startFlags, profilerInfo);</span><br></pre></td></tr></tbody></table></figure>

<p>App 层面的一个 Activity 对应在 AMS 中的 一个 ActivityRecord 对象。 还有个细节，在 ActivityStarter 类里面，会通过 <em>computeLaunchingTaskFlags</em> 方法计算 Activity 的启动模式。还有个关键点，ActivityStarter 中会通过 <em>recycleTask</em> 方法清除要启动的 Activity 上面的那些 Activity （比如 SingleTask 模式下）。</p>
<h3 id="1-2-任务栈"><a href="#1-2-任务栈" class="headerlink" title="1.2 任务栈"></a>1.2 任务栈</h3><p>如果你指定了 taskAffinity ，想让某个 Activity 运行在指定的任务栈，但是如果没有在 Intent 里面指定 FLAG_ACTIVITY_NEW_TASK 这个 flag 的话，还是会在默认的栈里面（与启动这个 Activity 的 Activity 是同一个栈），不会在指定的栈里面。其他的诸如两个 App 之间通过隐式启动另一个 App 中的 Activity 时，最好也使用 FLAG_ACTIVITY_NEW_TASK，不然还是在当前 App 的任务栈中。</p>
<blockquote>
<p>小知识，如果项目里面有多个任务栈，那么在按任务键 的时候，就能看到有多个缩略图（自己可以写demo试试），另外如果需要对比添加 FLAG_ACTIVITY_NEW_TASK 和不添加 FLAG_ACTIVITY_NEW_TASK 的情形的效果，需要卸载App 重新安装，课程里面就出现了这样的小插曲，不生效。</p>
</blockquote>
<p>单独任务栈有什么作用？就比如你的图库，需要在单独的任务栈中，这样与普通业务不影响，我个人理解的是在诸如 singleTask 等模式下，假如需要清理掉栈顶那些 Activity 时，不会被清除掉。</p>
<p>任务栈在数据层面表现就是 ActivityStack ，它管理 ActivityRecord 。</p>
<h3 id="1-3-FLAG-ACTIVITY-FORWARD-RESULT"><a href="#1-3-FLAG-ACTIVITY-FORWARD-RESULT" class="headerlink" title="1.3 FLAG_ACTIVITY_FORWARD_RESULT"></a>1.3 FLAG_ACTIVITY_FORWARD_RESULT</h3><p>FLAG_ACTIVITY_FORWARD_RESULT 的作用是当前 Activity 忽略 ActivityResult ，这样就会将结果传给上一级。举个例子，Activity  A启动 B ，B 启动 C ，我们想在 C 结束的时候，将结果跳过 B 传递给 A ，此时我们只需要在 B 启动 C 的时候，在intent 中添加这个flag 就行(表示忽略那个结果)：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(BBActivity.<span class="keyword">this</span>, CCActivity.class);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></tbody></table></figure>

<p>注意最后一行的 startActivity ，这里不能用 startActivityForResult 的，FLAG_ACTIVITY_FORWARD_RESULT 本来是忽略结果，startActivityForResult 是要结果，如果同时使用会报错。自己写的测试代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity A</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_a);</span><br><span class="line"></span><br><span class="line">    mButton = (Button) findViewById(R.id.btn);</span><br><span class="line">    mButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(AAActivity.<span class="keyword">this</span>, BBActivity.class);</span><br><span class="line">            startActivityForResult(intent, <span class="number">100</span>);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    Log.e(<span class="string">"forwardresult"</span>,<span class="string">"AAActivity requestCode:"</span> + requestCode + <span class="string">", resultCode:"</span> + resultCode + <span class="string">"data = "</span> + data.getStringExtra(<span class="string">"haha"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_b);</span><br><span class="line"></span><br><span class="line">    mButton = (Button) findViewById(R.id.btn);</span><br><span class="line">    mButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(BBActivity.<span class="keyword">this</span>, CCActivity.class);</span><br><span class="line">            intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_c);</span><br><span class="line"></span><br><span class="line">    mButton = findViewById(R.id.btn);</span><br><span class="line">    mButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">            intent.putExtra(<span class="string">"haha"</span>, <span class="string">"我是c的数据"</span>);</span><br><span class="line">            setResult(RESULT_OK, intent);</span><br><span class="line"></span><br><span class="line">            finish();</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样，当 Activity B 结束的时候，A 就能收到 C 关闭时候的数据 “我是c的数据” 了。注意：<strong>C 结束后，就显示出 B 了，只有手动关闭 B 页面后，数据才会传给 A 。</strong></p>
<p>关于这个标志位，更多内容可以参考 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f7d2a597536e">FLAG_ACTIVITY_FORWARD_RESULT的使用 - 简书 (jianshu.com)</a></p>
<h2 id="二、启动未注册的-Activity"><a href="#二、启动未注册的-Activity" class="headerlink" title="二、启动未注册的 Activity"></a>二、启动未注册的 Activity</h2><p>启动未注册的 Activity 会报错，那么这个报错是在哪个地方报出来的？我们看到 Instrumentation 这个类，看到其中的 execStartActivity 这个方法，在里面会有启动 Activity 并对启动结果进行检查的逻辑：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = ActivityTaskManager.getService().startActivity(whoThread,</span><br><span class="line">        who.getBasePackageName(), who.getAttributionTag(), intent,</span><br><span class="line">        intent.resolveTypeIfNeeded(who.getContentResolver()), token,</span><br><span class="line">        target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">checkStartActivityResult(result, intent);</span><br></pre></td></tr></tbody></table></figure>

<p>在 ActivityStarter 类中，执行 executeRequest 方法时，如果有错误，就会将错误结果体现到上述的 result 里面。最后，在 checkStartActivityResult 中通过 switch-case 去处理各种异常和正常结果。</p>
<p>Hook 目的就是为了改变原有流程。不管你是通过反射还是插桩都行。</p>
<h3 id="2-1-思路"><a href="#2-1-思路" class="headerlink" title="2.1 思路"></a>2.1 思路</h3><p>实现未注册的 Activity 的启动的思路如下图所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E5%90%AF%E5%8A%A8%E6%9C%AA%E6%B3%A8%E5%86%8CActivity%E6%80%9D%E8%B7%AF.png" alt="实现未注册的Activity 的启动思路"></p>
<p>找Hook点的原则（尽量）：</p>
<ul>
<li><p>找静态变量或者单例，这种可以直接用反射，还不轻易改变</p>
</li>
<li><p>public 修饰的，也不容易改变</p>
</li>
</ul>
<p>一个原则： 在 startActivity 之后，AMS 检测之前将 目标Activity 替换成占位 Activity。在 AMS 检测之后，Activity 创建出来之前（感觉老师说的Activity生命周期之前是有问题的），将占位 Activity 替换回 目标 Activity。</p>
<h3 id="2-2-实践"><a href="#2-2-实践" class="headerlink" title="2.2 实践"></a>2.2 实践</h3><p>通过 AMS 启动 Activity 的时候，getService 获取 AMS 的代理的时候，是静态的的，并且 IActivityManager 是一个接口，所以可以使用动态代理。</p>
<p>前面说的 10 之前是 AMS ，10之后是 ATMS ，所以要注意适配。</p>
<p>还有个点需要注意，使用动态代理的时候，需要传入 ClassLoader </p>
<p>，可以使用当前线程的 ClassLoader ：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></tbody></table></figure>

<p>ActivityThread 中 H 类handler 本身的 callback 是 null ，又 Handler 中 dispatchMessage 的时候，msg 的callback 存在的话，就执行 msg 的callback ，其他的就不执行了；如果 msg.callback 是空的话，则先执行 Handler 本身的 callback.handlerMessage (msg) ，只有当这个返回true 的时候，才不会执行我们自定义的 handleMessage；false 的话，还是会继续执行 handleMessage 的，所以我们可以强行new 出来一个 Handler 的 callback ，只不过 callbac.handleMessage 返回false 即可。之后将这个 callback 通过 Hook 设置给 H 类即可。</p>
<blockquote>
<p>这样 Hook 是没有风险的，因为流程并没有改变，，Handler 的callback 本身就是空的，我们 Hook 之后，handleMessage 还是会执行</p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8804%EF%BC%892021.12.16-AMS%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3--leo%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8804%EF%BC%892021.12.16-AMS%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3--leo%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（04）2021.12.16-AMS的核心原理讲解--leo老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-10 10:12:00" itemprop="dateCreated datePublished" datetime="2023-06-10T10:12:00+08:00">2023-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:48:04" itemprop="dateModified" datetime="2023-06-28T21:48:04+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>ZygoteInit.main 方法执行会进入 Java 层</p>
<p>forkSystemServer 方法：</p>
<p>在 fork 之前会给一些 args ，比如很有意思的一个名字 –nice-name ，就是指的进程名，这里的值时 ： system_server 。</p>
<p>Zygote.forkSystemServer 返回值问题：因为 fork 操作返回的就是 子进程的 pid ，所以，在父进程（Zygote 进程）中，返回的是 SystemServer 这个进程的 id ，假如是 6000 （反正肯定是 大于0的）；而在 SystemServer 中而言，由于它没有子进程，所以它返回的是 0 。</p>
<p>所以，在 Zygote 执行 Zygote.forkSystemServer 之后，需要判断 if (pid == 0) 去区分当前是 SystemServer 进程，然后才执行 handleSystemServer 这个方法，这里面会执行 SystemServer 进程的 main 方法。</p>
<blockquote>
<p>还记得前面说的，所有的进程开始执行的时候都是执行其 main 方法的</p>
</blockquote>
<p>handleSystemServer 最终会调用到 ZygoteInit.java 类中的 zygoteInit 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges, String[] argv, ClassLoader classLoader)</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>在这个方法里面会执行 ZygoteInit.nativeZygoteInit(); 方法去启动 Binder  线程池，在 native 层最终执行的代码是这样的：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc -&gt; startThreadPool();</span><br></pre></td></tr></tbody></table></figure>

<p>这也从侧面说明了， Zygote 进程 fork 出来的进程都会去创建 Binder 线程池。</p>
<p>获取到 SystemServer 的 Class ，然后通过反射调用其 main() 方法。这样就把 SystemServer 进程给启动起来了。</p>
<p>在 SystemServer 的 main 方法中，主要执行其 run 方法，主要操作是：</p>
<ul>
<li><p>创建 SystemServiceManager 对象</p>
</li>
<li><p>startBootstrapServices  //启动引导服务 —— AMS 等</p>
</li>
<li><p>startCoreService  //核心服务</p>
</li>
<li><p>startOtherService  //其他服务，如 WMS 等</p>
</li>
</ul>
<p>一个 App 可以有多个进程？那肯定可以，我们平时一个 App 就可以开启多个进程； 那么一个进程可以有多个 App 吗？ 答案当然也是可以！<strong>我们可以用 sharedId 去实现 。</strong></p>
<p>在 SystemServer 的 main 方法中，最终会创建 ActivityThread 对象，看到这里我蒙了。。。不是只有 App 的进程才会创建 ActivityThread 对象么？ 不过呢，我们能从 ActivityThread 的 attach 方法中看到端倪，在里面会判断是否是 system（也就是是否是系统），在 SystemServer.main 里面这种情况下，我们肯定是 system 的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!system) {</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//省略无关代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>SystemServer 的main 方法执行的时候，会有创建和创建 Application 的 Context 以及创建 ActivityThread 的操作，和我们的 App 进程创建有点类似，老师的解释是，SystemServer 进程中有 App ，至于这个 App 是什么 App ，老师也说不知道。</p>
<h2 id="SystemServerManager"><a href="#SystemServerManager" class="headerlink" title="SystemServerManager"></a>SystemServerManager</h2><p>startService </p>
<p>四大组件管理者以前说的都是 AMS ，但是 ANdroid 10 之后，这么说就不准确的，新增了一个 ATMS （ActivityTaskManagerService）， 其中 ATMS 专门管理 Activity ， AMS 管理其他三个以及其他的。 </p>
<p>这里要注意 2  个概念， SystemServerManager 和 ServiceManager 的区别：</p>
<ul>
<li><p>SystemServerManager ： 主要负责 Service 的生命周期，比如 Service 的 onCreate、onStart 等</p>
</li>
<li><p>ServiceManager ： 负责 Service 的管理，Service 创建后，要添加到 ServiceManager 中来，也就是注册。</p>
</li>
</ul>
<p>SystemServer 中 startOtherService 中有几个值得注意的：</p>
<ul>
<li><p>mActivityManagerService.systemReady 方法会启动 Launcher </p>
</li>
<li><p>startSystemUi 方法</p>
</li>
</ul>
<p>ActivityStater.execute 里面会执行到 executeRequest 方法，这些方法非常重要，我们说的是 Activity 的栈管理 就是在 ActivityStarter 这个类里面。启动 Activity 的时候，一般会有 2 个 AcitivityRecord ，一个是启动 Activity 的信息，另一个是待启动的 Activity 的信息，比如 Activity A 启动 Activity B 。</p>
<p>Activity 启动过程中，会经过 ActivityStackSupervisor.java  的 startSpecificActivity 方法，这个方法很关键，会在里面判断是否存在目标Activity 所在的进程，如果存在才执行 realStartActivityLocked ；否则，启动 App 的进程（AMS 通过 socket 通知 zygote 创建进程）。</p>
<p>有个 主 zygote 和 从 zygote 的概念，这个需要理解下，因为之前我们讲过系统启动的时候，有几种配置，是 32 位 或者 64位，还是说32_64 （先尝试32位不行再 64位），以及 64_32（先尝试64位不行再 32位）</p>
<p>启动 Launcher 的时候，会执行到 ActivityThread.main 方法（其实和普通的App一样，Launcher也是个 App），在 ActivityThread.main 方法中也会调用到 attachApplication 方法，这是<strong>将App 的句柄发送给AMS</strong>，方便后续 AMS 向 App 发送消息。这个句柄是 ApplicationThread ，他是个 Binder 。</p>
<p>一定要自己去看源码，画时序图和流程图：</p>
<ul>
<li><p>时序图，哪个类的方法到哪个类的方法</p>
</li>
<li><p>流程图： 整个过程做的重要事情</p>
</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/09/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8803%EF%BC%892021.12.14-Android%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B---Leo%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/09/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8803%EF%BC%892021.12.14-Android%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B---Leo%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（03）2021.12.14-Android的启动流程---Leo老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-09 15:11:00" itemprop="dateCreated datePublished" datetime="2023-06-09T15:11:00+08:00">2023-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:46:39" itemprop="dateModified" datetime="2023-06-28T21:46:39+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、粗略过一遍"><a href="#一、粗略过一遍" class="headerlink" title="一、粗略过一遍"></a>一、粗略过一遍</h2><p>在内核里面没有进程和线程的区分的。</p>
<p>init 是用户空间鼻祖。zygote 是Java 进程的鼻祖，此前一直在 native 层。</p>
<p>Systemserver 进程里面大约有 90 多个进程。</p>
<p>init 进程中，做挂载、创建文件夹之类的操作</p>
<p>SetupSelinux 里面实现了 linux 这块的安全策略，</p>
<p>native 层这些知识，比如 init.rc 的解析等，看刘望舒的书籍就可以了，所以这里大概略过，总结一下init处理的重要事情：</p>
<ol>
<li><p>挂载文件</p>
</li>
<li><p>设置 selinux –&gt; 安全策略</p>
</li>
<li><p>开启属性服务，注册到 epoll 机制</p>
</li>
<li><p>解析 init.rc 文件</p>
</li>
<li><p>循环处理脚本，启动zygote 进程</p>
</li>
<li><p>循环等待，主要就是接受子进程的 SIGCHLD 信号，防止子进程变为僵尸进程</p>
</li>
</ol>
<p>linux 中一切接文件，输入输出也是，在代码中写 system.out.println() 也是将内容写入到某个目录，然后再显示出来。</p>
<h2 id="二、Zygote"><a href="#二、Zygote" class="headerlink" title="二、Zygote"></a>二、Zygote</h2><p>Zygote 有一部分运行在 native 层，有一部分运行在 Java 层，从这里开始，我们后续的代码就进入了 java 层运行。</p>
<blockquote>
<p> adb shell</p>
</blockquote>
<blockquote>
<p>kill 9 6158</p>
</blockquote>
<p>上述命令就可以将 zygote 进程（其中6158是zygote 进程的进程号，需要确认下是不是这个）杀掉，然后 Android 就崩了。说明 Android 的关键进程是不能被结束的</p>
<p>每一个进程启动的时候，都是执行 main 方法</p>
<p>Android的运行环境（Android RunTime）是 zygote 给启动的，调用的是 runTime.start(xx,xx,xx) 方法，在 runtime.start()方法中，做了几件事情：</p>
<ul>
<li><p>通过 startVM 就是启动虚拟机</p>
</li>
<li><p>之后通过 startReg 来注册 JNI ，</p>
</li>
</ul>
<p>从上面看出来，我们在 zygote 进程中startVM 启动了虚拟机，虚拟机的作用： 进程管理。所以，直播课学员问的，先有进程还是先有VM 虚拟机，答案就明确了：先有进程，VM 只是进程里面的一段功能代码而已；如果从内核空间和用户空间来讲，<strong>VM 显然是在用户空间</strong>。</p>
<p>每个 App 的内核空间，在物理上都对应同一块地方。</p>
<h3 id="2-1-注册-JNI？"><a href="#2-1-注册-JNI？" class="headerlink" title="2.1 注册 JNI？"></a>2.1 注册 JNI？</h3><p>Java 与 Native 代码互相调用， 注册 JNI 就是将 Java 的本地方法和 native 方法关联起来。</p>
<p>进程是没有 Java进程 和 Native进程 的区分的，所以，zygote 执行的时候，不论是在 Native 层还是 Java 层，我们都说是在 Zygote 进程。看源码的时候，如何判断是否进入到了其他进程，就看是否 fork 了。</p>
<h3 id="2-2-zygoteServer"><a href="#2-2-zygoteServer" class="headerlink" title="2.2 zygoteServer"></a>2.2 zygoteServer</h3><p>它是一个 Socket ，为什么要用 Socket 而不用 Binder 进程间通信？</p>
<p>因为 Binder 是多线程的，fork 可能会导致死锁，所以这里用 Socket</p>
<p>Zygote 的 preload 加载资源啊（Android内部的资源com.android.internal.R.xx 之类的）、类啊（有个文件配置了需要预加载哪些类），这样在fork出来的 App 进程中不用去加载了，加快速度</p>
<p>关于预加载，老师的一张图很有说明性，复制下：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Android%E5%BA%94%E7%94%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%9B%BE.jpg" alt="Android应用进程共享内存图"></p>
<h3 id="2-3-总结：zygote-进程启动干了什么事情？"><a href="#2-3-总结：zygote-进程启动干了什么事情？" class="headerlink" title="2.3 总结：zygote 进程启动干了什么事情？"></a>2.3 总结：zygote 进程启动干了什么事情？</h3><h4 id="native-层面："><a href="#native-层面：" class="headerlink" title="native 层面："></a>native 层面：</h4><ul>
<li><p>初始化运行环境，创建vm</p>
</li>
<li><p>注册jni</p>
</li>
<li><p>调用 zygoteinit.main 进入 Java 环境</p>
</li>
</ul>
<h4 id="Java-层面"><a href="#Java-层面" class="headerlink" title="Java 层面"></a>Java 层面</h4><ul>
<li><p>预加载–加快APp进程启动</p>
</li>
<li><p>创建 server 类型的 socket 接收fork 新进程的信息</p>
</li>
<li><p>通过 fork 创建 SystemServer 进程</p>
</li>
<li><p>循环等待，等待 SystemServer 进程的 fork 其你去</p>
</li>
</ul>
<h2 id="三、fork-（老师发的资料里面的补充内容）"><a href="#三、fork-（老师发的资料里面的补充内容）" class="headerlink" title="三、fork （老师发的资料里面的补充内容）"></a>三、fork （老师发的资料里面的补充内容）</h2><h3 id="3-1-fork-如何导致死锁"><a href="#3-1-fork-如何导致死锁" class="headerlink" title="3.1 fork 如何导致死锁"></a>3.1 fork 如何导致死锁</h3><p>在 POSIX 标准中，fork 行为是这样的：复制整个用户空间的数据（通常使用 copy-on-write 策略）以及所有系统对象，然后<strong>仅仅复制当前线程到子进程</strong>，这就意味着，所有父进程中其他线程，到了子进程中都是突然政法掉了。</p>
<blockquote>
<p>所以，如果非当前线程获取到了锁，fork完成后，当前线程去获取锁，会发现一直占用，无法获取到</p>
</blockquote>
<h3 id="3-2-fork-返回值"><a href="#3-2-fork-返回值" class="headerlink" title="3.2 fork 返回值"></a>3.2 fork 返回值</h3><ul>
<li><p>返回 0 表示成功创建子进程，并且接下来进入子进程</p>
</li>
<li><p>返回 pid &gt; 0 ，表示成功创建子进程，并且继续执行父进程流程</p>
</li>
<li><p>返回 pid &lt; 0 创建子进程失败（可能内存不足等原因）</p>
</li>
</ul>
<h3 id="3-3-孤儿进程、僵尸进程"><a href="#3-3-孤儿进程、僵尸进程" class="headerlink" title="3.3 孤儿进程、僵尸进程"></a>3.3 孤儿进程、僵尸进程</h3><p>fork 调用后，父子进程交替执行，执行顺序不定：</p>
<ul>
<li><p>如果父进程先退出，子进程还没退出，则子进程的父进程会变为init进程（托孤，因为任何一个进程都必须有父进程）</p>
</li>
<li><p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕捉到了子进程的退出状态才真正结束，否则这个子进程会变为僵尸进程（只保留一些退出信息供父进程查询）</p>
</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/09/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8802%EF%BC%892021.12.12-Binder%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B2%E8%A7%A3---Leo%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/09/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8802%EF%BC%892021.12.12-Binder%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B2%E8%A7%A3---Leo%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（02）2021.12.12-Binder机制与常见面试题讲解---Leo老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-09 10:20:00" itemprop="dateCreated datePublished" datetime="2023-06-09T10:20:00+08:00">2023-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:42:22" itemprop="dateModified" datetime="2023-06-28T21:42:22+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、储备知识"><a href="#一、储备知识" class="headerlink" title="一、储备知识"></a>一、储备知识</h2><p>很多同学回答 Binder 是什么的时候，只会说 Binder 是一种进程间通信机制，这是不完善的，我们要说出以下 3 个点才算完整：</p>
<ul>
<li>机制：Binder 是一个进程间通信机制</li>
<li>驱动： Binder 是一个虚拟物理设备驱动</li>
<li>应用层：Binder 是一个能发起通信的 Java 类（Service里面就有用到Binder类）</li>
</ul>
<p>Linux 一切皆文件 </p>
<p>多进程的好处？</p>
<ul>
<li>突破内存限制，如图库内存占用过多</li>
<li>功能稳定性，比如长连接，独立进程</li>
<li>规避内存泄漏，比如 webview 正常使用会有内存泄漏</li>
<li>隔离风险： 不稳定的功能放入独立的进程，比如dump 内存</li>
</ul>
<p>为什么Android采用 Binder：</p>
<ul>
<li>性能： 只需要一次</li>
<li>特点：基于C/S，易用性高（如共享内存使用很复杂，参考多线程共享变量，涉及的线程安全加锁）</li>
<li>安全性，为每个App分配 UID，同时支持匿名和实名。公交车，只要能到那里，都能坐车；Binder 既有实名又有匿名，实名的服务是大家都可以访问，比如 AMS、WMS ，匿名服务，类似滴滴打车，你是不能直接联系到司机的，只能通过滴滴给你虚拟号。匿名服务只能通过代理去真正获取服务。（实名和匿名的区别在于是否注册）。</li>
</ul>
<blockquote>
<p>自己写的服务可以实名吗？是可以的，调用 API 即可</p>
</blockquote>
<p>一个进程会分为 用户空间和内核空间。如果是 32位系统（总共有 2^32 这么大，即 4G），那么用户空间一般 3G，内核空间 1G </p>
<p>所有进程的内核空间都是映射到物理内存上是同一块空间，</p>
<p>内核空间是地球仪，物理内存是地球；进程1的用户空间是 月球仪器，对应的物理内存是月球；进程2的用户空间是火星仪，对应的物理内存是火星。</p>
<p>我们平时说的拷贝次数，指的就是 copy_from_user 或者 copy_to_user 这种系统调用，每调用一次就是所说的类似 Binder 只用拷贝一次这种说法。</p>
<blockquote>
<p>为什么只关心这个系统的调用呢？这是因为在用户态和内核态切换非常耗时，它有上下文切换的，需要保存当前运行状态。</p>
</blockquote>
<p>传统的IPC就是 copy_from_user ，接着再 copy_to_user ，2次</p>
<p>服务端和内核端，google 已经实现了，所以开发者只要开发 客户端。降低 Binder 的使用难度</p>
<p>为什么不从两个应用之间映射？还需要经过内核？</p>
<p>老师说的是，如果直接2个应用之间，就变成了 内存共享，google 做 Binder 就是因为内存共享比较难控制，所以宁愿用 Binder 来浪费一次性能。感觉说服力不够，得自己想想。</p>
<h2 id="二、Binder"><a href="#二、Binder" class="headerlink" title="二、Binder"></a>二、Binder</h2><p>MMKV 也是使用 mmap 实现的。</p>
<h3 id="2-1-AIDL-生成的类细节"><a href="#2-1-AIDL-生成的类细节" class="headerlink" title="2.1 AIDL 生成的类细节"></a>2.1 AIDL 生成的类细节</h3><p>AIDL 类似黄牛，帮我们代办一些事情，降低办事的复杂度。帮我们生成 Java 代码。AIDL 生成的 Java 代码，我们自己去手写也是一样的。</p>
<p>Proxy 是给客户端使用的，Stub 服务端使用。asInterface 判断如果是跨进程，那么返回的是代理对象，否则，返回的是本身。Binder 通信会创建 2个 Parcel  ，一个是数据包，一个是结果包。</p>
<p>ServiceManager 也是个服务，它的 handle 句柄是固定的： 0 。Service 创建之后，可以去 ServiceManager 中注册，建立 Service 和 handle 句柄的映射关系。</p>
<p>客户端调用 transact 方法的时候，服务端那边就会响应 onTransact 方法。我们一般调用一个类的方法，可以写明全路径，比如一般是： com.xx.haha.Demo ，但是在 Binder 中，觉得传全路径过去占用的空间比较大，所以对方法做了精简，比如，用 1 代表 addPerson、2代表getPersonList 等，节约空间。这个体现在 Stub 中的那些静态常量。</p>
<p>onTransact 中，如果调用的方法没有返回值，则执行完就完了；否则，将执行结果写到 reply 中。 客户端调用服务端一般是同步的，所以计算过程客户端会挂起，所以一般要在子线程去做这种Binder 调用。<strong>如果要使用异步调用，就使用 oneWay</strong></p>
<h3 id="2-2-Intent-为什么不能传送大的数据"><a href="#2-2-Intent-为什么不能传送大的数据" class="headerlink" title="2.2 Intent 为什么不能传送大的数据"></a>2.2 Intent 为什么不能传送大的数据</h3><p>为什么只能 1M - 8k ？这是因为 Binder 是一个驱动，通过 mmap 创建的空间大小就是 1M - 8k （就是 1M - 2 * pageSize ，pageSize 是 4k），如果是异步的话 ，则是 (1M - 8k)/2 。</p>
<p>至于为什么是 1M - 8k ，那总得给个数字，不可能无限大。可能是为了充分利用存储空间。</p>
<p>mmp 最开始只会给 1 页，也就是 4k ，如果有需要才会扩充，最大就是上面说的 1M - 8k （oneWay 就减半）。</p>
<blockquote>
<p>其实还有一个打包需要占用空间，所以真正可用的空间还不到 1M - 8k</p>
</blockquote>
<p><font color="#ff0000">补充视频里面有代码的详细讲解，不过目前面试用不到，先不看</font></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">218</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共437.3k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/4/',]
      });
      });
  </script>


</body>
</html>
