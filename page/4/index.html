<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/4/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">35</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">208</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/09/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8803%EF%BC%892021.12.14-Android%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B---Leo%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/09/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8803%EF%BC%892021.12.14-Android%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B---Leo%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（03）2021.12.14-Android的启动流程---Leo老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-09 15:11:00" itemprop="dateCreated datePublished" datetime="2023-06-09T15:11:00+08:00">2023-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:46:39" itemprop="dateModified" datetime="2023-06-28T21:46:39+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、粗略过一遍"><a href="#一、粗略过一遍" class="headerlink" title="一、粗略过一遍"></a>一、粗略过一遍</h2><p>在内核里面没有进程和线程的区分的。</p>
<p>init 是用户空间鼻祖。zygote 是Java 进程的鼻祖，此前一直在 native 层。</p>
<p>Systemserver 进程里面大约有 90 多个进程。</p>
<p>init 进程中，做挂载、创建文件夹之类的操作</p>
<p>SetupSelinux 里面实现了 linux 这块的安全策略，</p>
<p>native 层这些知识，比如 init.rc 的解析等，看刘望舒的书籍就可以了，所以这里大概略过，总结一下init处理的重要事情：</p>
<ol>
<li><p>挂载文件</p>
</li>
<li><p>设置 selinux –&gt; 安全策略</p>
</li>
<li><p>开启属性服务，注册到 epoll 机制</p>
</li>
<li><p>解析 init.rc 文件</p>
</li>
<li><p>循环处理脚本，启动zygote 进程</p>
</li>
<li><p>循环等待，主要就是接受子进程的 SIGCHLD 信号，防止子进程变为僵尸进程</p>
</li>
</ol>
<p>linux 中一切接文件，输入输出也是，在代码中写 system.out.println() 也是将内容写入到某个目录，然后再显示出来。</p>
<h2 id="二、Zygote"><a href="#二、Zygote" class="headerlink" title="二、Zygote"></a>二、Zygote</h2><p>Zygote 有一部分运行在 native 层，有一部分运行在 Java 层，从这里开始，我们后续的代码就进入了 java 层运行。</p>
<blockquote>
<p> adb shell</p>
</blockquote>
<blockquote>
<p>kill 9 6158</p>
</blockquote>
<p>上述命令就可以将 zygote 进程（其中6158是zygote 进程的进程号，需要确认下是不是这个）杀掉，然后 Android 就崩了。说明 Android 的关键进程是不能被结束的</p>
<p>每一个进程启动的时候，都是执行 main 方法</p>
<p>Android的运行环境（Android RunTime）是 zygote 给启动的，调用的是 runTime.start(xx,xx,xx) 方法，在 runtime.start()方法中，做了几件事情：</p>
<ul>
<li><p>通过 startVM 就是启动虚拟机</p>
</li>
<li><p>之后通过 startReg 来注册 JNI ，</p>
</li>
</ul>
<p>从上面看出来，我们在 zygote 进程中startVM 启动了虚拟机，虚拟机的作用： 进程管理。所以，直播课学员问的，先有进程还是先有VM 虚拟机，答案就明确了：先有进程，VM 只是进程里面的一段功能代码而已；如果从内核空间和用户空间来讲，<strong>VM 显然是在用户空间</strong>。</p>
<p>每个 App 的内核空间，在物理上都对应同一块地方。</p>
<h3 id="2-1-注册-JNI？"><a href="#2-1-注册-JNI？" class="headerlink" title="2.1 注册 JNI？"></a>2.1 注册 JNI？</h3><p>Java 与 Native 代码互相调用， 注册 JNI 就是将 Java 的本地方法和 native 方法关联起来。</p>
<p>进程是没有 Java进程 和 Native进程 的区分的，所以，zygote 执行的时候，不论是在 Native 层还是 Java 层，我们都说是在 Zygote 进程。看源码的时候，如何判断是否进入到了其他进程，就看是否 fork 了。</p>
<h3 id="2-2-zygoteServer"><a href="#2-2-zygoteServer" class="headerlink" title="2.2 zygoteServer"></a>2.2 zygoteServer</h3><p>它是一个 Socket ，为什么要用 Socket 而不用 Binder 进程间通信？</p>
<p>因为 Binder 是多线程的，fork 可能会导致死锁，所以这里用 Socket</p>
<p>Zygote 的 preload 加载资源啊（Android内部的资源com.android.internal.R.xx 之类的）、类啊（有个文件配置了需要预加载哪些类），这样在fork出来的 App 进程中不用去加载了，加快速度</p>
<p>关于预加载，老师的一张图很有说明性，复制下：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Android%E5%BA%94%E7%94%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%9B%BE.jpg" alt="Android应用进程共享内存图"></p>
<h3 id="2-3-总结：zygote-进程启动干了什么事情？"><a href="#2-3-总结：zygote-进程启动干了什么事情？" class="headerlink" title="2.3 总结：zygote 进程启动干了什么事情？"></a>2.3 总结：zygote 进程启动干了什么事情？</h3><h4 id="native-层面："><a href="#native-层面：" class="headerlink" title="native 层面："></a>native 层面：</h4><ul>
<li><p>初始化运行环境，创建vm</p>
</li>
<li><p>注册jni</p>
</li>
<li><p>调用 zygoteinit.main 进入 Java 环境</p>
</li>
</ul>
<h4 id="Java-层面"><a href="#Java-层面" class="headerlink" title="Java 层面"></a>Java 层面</h4><ul>
<li><p>预加载–加快APp进程启动</p>
</li>
<li><p>创建 server 类型的 socket 接收fork 新进程的信息</p>
</li>
<li><p>通过 fork 创建 SystemServer 进程</p>
</li>
<li><p>循环等待，等待 SystemServer 进程的 fork 其你去</p>
</li>
</ul>
<h2 id="三、fork-（老师发的资料里面的补充内容）"><a href="#三、fork-（老师发的资料里面的补充内容）" class="headerlink" title="三、fork （老师发的资料里面的补充内容）"></a>三、fork （老师发的资料里面的补充内容）</h2><h3 id="3-1-fork-如何导致死锁"><a href="#3-1-fork-如何导致死锁" class="headerlink" title="3.1 fork 如何导致死锁"></a>3.1 fork 如何导致死锁</h3><p>在 POSIX 标准中，fork 行为是这样的：复制整个用户空间的数据（通常使用 copy-on-write 策略）以及所有系统对象，然后<strong>仅仅复制当前线程到子进程</strong>，这就意味着，所有父进程中其他线程，到了子进程中都是突然政法掉了。</p>
<blockquote>
<p>所以，如果非当前线程获取到了锁，fork完成后，当前线程去获取锁，会发现一直占用，无法获取到</p>
</blockquote>
<h3 id="3-2-fork-返回值"><a href="#3-2-fork-返回值" class="headerlink" title="3.2 fork 返回值"></a>3.2 fork 返回值</h3><ul>
<li><p>返回 0 表示成功创建子进程，并且接下来进入子进程</p>
</li>
<li><p>返回 pid &gt; 0 ，表示成功创建子进程，并且继续执行父进程流程</p>
</li>
<li><p>返回 pid &lt; 0 创建子进程失败（可能内存不足等原因）</p>
</li>
</ul>
<h3 id="3-3-孤儿进程、僵尸进程"><a href="#3-3-孤儿进程、僵尸进程" class="headerlink" title="3.3 孤儿进程、僵尸进程"></a>3.3 孤儿进程、僵尸进程</h3><p>fork 调用后，父子进程交替执行，执行顺序不定：</p>
<ul>
<li><p>如果父进程先退出，子进程还没退出，则子进程的父进程会变为init进程（托孤，因为任何一个进程都必须有父进程）</p>
</li>
<li><p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕捉到了子进程的退出状态才真正结束，否则这个子进程会变为僵尸进程（只保留一些退出信息供父进程查询）</p>
</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/09/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8802%EF%BC%892021.12.12-Binder%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B2%E8%A7%A3---Leo%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/09/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8802%EF%BC%892021.12.12-Binder%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B2%E8%A7%A3---Leo%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（02）2021.12.12-Binder机制与常见面试题讲解---Leo老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-09 10:20:00" itemprop="dateCreated datePublished" datetime="2023-06-09T10:20:00+08:00">2023-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:42:22" itemprop="dateModified" datetime="2023-06-28T21:42:22+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、储备知识"><a href="#一、储备知识" class="headerlink" title="一、储备知识"></a>一、储备知识</h2><p>很多同学回答 Binder 是什么的时候，只会说 Binder 是一种进程间通信机制，这是不完善的，我们要说出以下 3 个点才算完整：</p>
<ul>
<li>机制：Binder 是一个进程间通信机制</li>
<li>驱动： Binder 是一个虚拟物理设备驱动</li>
<li>应用层：Binder 是一个能发起通信的 Java 类（Service里面就有用到Binder类）</li>
</ul>
<p>Linux 一切皆文件 </p>
<p>多进程的好处？</p>
<ul>
<li>突破内存限制，如图库内存占用过多</li>
<li>功能稳定性，比如长连接，独立进程</li>
<li>规避内存泄漏，比如 webview 正常使用会有内存泄漏</li>
<li>隔离风险： 不稳定的功能放入独立的进程，比如dump 内存</li>
</ul>
<p>为什么Android采用 Binder：</p>
<ul>
<li>性能： 只需要一次</li>
<li>特点：基于C/S，易用性高（如共享内存使用很复杂，参考多线程共享变量，涉及的线程安全加锁）</li>
<li>安全性，为每个App分配 UID，同时支持匿名和实名。公交车，只要能到那里，都能坐车；Binder 既有实名又有匿名，实名的服务是大家都可以访问，比如 AMS、WMS ，匿名服务，类似滴滴打车，你是不能直接联系到司机的，只能通过滴滴给你虚拟号。匿名服务只能通过代理去真正获取服务。（实名和匿名的区别在于是否注册）。</li>
</ul>
<blockquote>
<p>自己写的服务可以实名吗？是可以的，调用 API 即可</p>
</blockquote>
<p>一个进程会分为 用户空间和内核空间。如果是 32位系统（总共有 2^32 这么大，即 4G），那么用户空间一般 3G，内核空间 1G </p>
<p>所有进程的内核空间都是映射到物理内存上是同一块空间，</p>
<p>内核空间是地球仪，物理内存是地球；进程1的用户空间是 月球仪器，对应的物理内存是月球；进程2的用户空间是火星仪，对应的物理内存是火星。</p>
<p>我们平时说的拷贝次数，指的就是 copy_from_user 或者 copy_to_user 这种系统调用，每调用一次就是所说的类似 Binder 只用拷贝一次这种说法。</p>
<blockquote>
<p>为什么只关心这个系统的调用呢？这是因为在用户态和内核态切换非常耗时，它有上下文切换的，需要保存当前运行状态。</p>
</blockquote>
<p>传统的IPC就是 copy_from_user ，接着再 copy_to_user ，2次</p>
<p>服务端和内核端，google 已经实现了，所以开发者只要开发 客户端。降低 Binder 的使用难度</p>
<p>为什么不从两个应用之间映射？还需要经过内核？</p>
<p>老师说的是，如果直接2个应用之间，就变成了 内存共享，google 做 Binder 就是因为内存共享比较难控制，所以宁愿用 Binder 来浪费一次性能。感觉说服力不够，得自己想想。</p>
<h2 id="二、Binder"><a href="#二、Binder" class="headerlink" title="二、Binder"></a>二、Binder</h2><p>MMKV 也是使用 mmap 实现的。</p>
<h3 id="2-1-AIDL-生成的类细节"><a href="#2-1-AIDL-生成的类细节" class="headerlink" title="2.1 AIDL 生成的类细节"></a>2.1 AIDL 生成的类细节</h3><p>AIDL 类似黄牛，帮我们代办一些事情，降低办事的复杂度。帮我们生成 Java 代码。AIDL 生成的 Java 代码，我们自己去手写也是一样的。</p>
<p>Proxy 是给客户端使用的，Stub 服务端使用。asInterface 判断如果是跨进程，那么返回的是代理对象，否则，返回的是本身。Binder 通信会创建 2个 Parcel  ，一个是数据包，一个是结果包。</p>
<p>ServiceManager 也是个服务，它的 handle 句柄是固定的： 0 。Service 创建之后，可以去 ServiceManager 中注册，建立 Service 和 handle 句柄的映射关系。</p>
<p>客户端调用 transact 方法的时候，服务端那边就会响应 onTransact 方法。我们一般调用一个类的方法，可以写明全路径，比如一般是： com.xx.haha.Demo ，但是在 Binder 中，觉得传全路径过去占用的空间比较大，所以对方法做了精简，比如，用 1 代表 addPerson、2代表getPersonList 等，节约空间。这个体现在 Stub 中的那些静态常量。</p>
<p>onTransact 中，如果调用的方法没有返回值，则执行完就完了；否则，将执行结果写到 reply 中。 客户端调用服务端一般是同步的，所以计算过程客户端会挂起，所以一般要在子线程去做这种Binder 调用。<strong>如果要使用异步调用，就使用 oneWay</strong></p>
<h3 id="2-2-Intent-为什么不能传送大的数据"><a href="#2-2-Intent-为什么不能传送大的数据" class="headerlink" title="2.2 Intent 为什么不能传送大的数据"></a>2.2 Intent 为什么不能传送大的数据</h3><p>为什么只能 1M - 8k ？这是因为 Binder 是一个驱动，通过 mmap 创建的空间大小就是 1M - 8k （就是 1M - 2 * pageSize ，pageSize 是 4k），如果是异步的话 ，则是 (1M - 8k)/2 。</p>
<p>至于为什么是 1M - 8k ，那总得给个数字，不可能无限大。可能是为了充分利用存储空间。</p>
<p>mmp 最开始只会给 1 页，也就是 4k ，如果有需要才会扩充，最大就是上面说的 1M - 8k （oneWay 就减半）。</p>
<blockquote>
<p>其实还有一个打包需要占用空间，所以真正可用的空间还不到 1M - 8k</p>
</blockquote>
<p><font color="#ff0000">补充视频里面有代码的详细讲解，不过目前面试用不到，先不看</font></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/08/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8801%EF%BC%892021.12.9-Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90---Alvin%E8%80%81%E5%B8%88%EF%BC%883%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/08/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8801%EF%BC%892021.12.9-Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90---Alvin%E8%80%81%E5%B8%88%EF%BC%883%EF%BC%89/" class="post-title-link" itemprop="url">（01）2021.12.9-Handler源码分析---Alvin老师（3）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-08 17:00:00" itemprop="dateCreated datePublished" datetime="2023-06-08T17:00:00+08:00">2023-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:39:59" itemprop="dateModified" datetime="2023-06-28T21:39:59+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>线程的跨越是怎么实现的？</p>
<p>内存是不分线程的，可以在子线程和主线程都使用。</p>
<p>在子线程里面执行某个函数（比如调用 Handler 的 sendMessage 方法），这个函数就在子线程里面</p>
<p>事件变为内存了，MessageQueue.enqueueMessage(msg) 将这一块内存放入了 MessageQueue 了。 </p>
<p>Looper.loop 是在主线程中，所以取出来的 Message 是通过 dispatchMessage 放在 主线程执行的</p>
<p>所以上述就是子线程切换到主线程的流程。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>有学员问存在以下几个条件：</p>
<ol>
<li><p>所有 Looper 对象（不论主线程还是子线程的）中放 Looper 对象的 ThreadLocal 都是同一个对象</p>
<blockquote>
<p>这个没问题，因为 Looper 类中的 用于存放Looper 对象的 ThreadLocal 是 static final 的，整个 App 只有一个</p>
</blockquote>
</li>
<li><p>那么看起来，所有线程也都公用同一个 Looper 对象了啊</p>
</li>
</ol>
<p>看下 Looper 的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></tbody></table></figure>

<p>所以学员说得没错， sThreadLocal 是整个 App 唯一的。但是，如果我们了解 ThreadLocal 的源码的话，就能得出如下的式子：</p>
<blockquote>
<p>Thread1 -&gt; 有自己的 ThreadLocalMap1 -&gt; 存储的键值对样式 &lt;sThreadLocal, Looper1&gt;</p>
</blockquote>
<blockquote>
<p>Thread2 -&gt; 有自己的 ThreadLocalMap2 -&gt; 存储的键值对样式&lt;sThreadLocal, Looper2&gt;</p>
</blockquote>
<p>能看到，在线程1中键值对存在ThreadLocalMap1 这个map 对象中， 样式是 &lt;sThreadLocal, Looper1&gt; ；线程2 中键值对存在 ThreadLocalMap2 这个 map 对象中，的样式是 &lt;sThreadLocal, Looper2&gt;</p>
<p>所以，根本原因在于： <strong>每个线程都有自己的 ThreadLocalMap</strong>，虽然所有的线程中的不一样的 Looper 对象都有同一个 ThreadLocal 对象，但是这些线程有不一样的 ThreadLocalMap ，所以用同一个 ThreadLocal 对象作为 key 在不同的 ThreadLocalMap 中取值，取到的肯定是不同的 Looper ，这下明白了。</p>
<h3 id="如何获取-Message"><a href="#如何获取-Message" class="headerlink" title="如何获取 Message"></a>如何获取 Message</h3><p>使用 Message.obtain() ，因为 Message 使用完成后，都会回收，所以我们可以一直使用，这是享元设计模式。这样就维持一个池子，避免内存抖动，防止 OOM。new 了必然会回收，回收了就可能有碎片。</p>
<p>在 Looper.loop 方法里面，msg.target.dispathcMessage(msg) 执行完后，在 for(; ;) 死循环最后一句的时候会调用 msg.recycleUnchecked(); 进行回收，将回收的msg 插入到池子的<strong>头部</strong>。</p>
<h3 id="Looper-死循环不会-ANR-？"><a href="#Looper-死循环不会-ANR-？" class="headerlink" title="Looper 死循环不会 ANR ？"></a>Looper 死循环不会 ANR ？</h3><p>不是同一个层面的东西。毫不相关的问题。点击 5秒没响应 ANR ，其实这个点击事件它也是一个 Message。</p>
<h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>HandlerThread 存在的意义：</p>
<ul>
<li><p>方便使用</p>
</li>
<li><p>线程安全，getLooper 的线程安全问题</p>
</li>
</ul>
<p>wait 会释放锁，这样其他的函数才能获取到锁执行 notify 操作。notify 不会释放锁， 要等 synchronized 代码全部执行完才释放锁（notify操作可能不在synchronized 代码块最后 ）。</p>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>处理后台耗时任务。一个任务分为多个子任务，子任务按照顺序执行完成后，任务才能算完成，这时候可以使用 IntentService ，这样可以保证所有的子任务在同一线程执行。关于要执行的多个任务，代码写法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求1</span></span><br><span class="line">Intent i = <span class="keyword">new</span> Intent(<span class="string">"cn.scu.finch"</span>);</span><br><span class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle.putString(<span class="string">"taskName"</span>, <span class="string">"task1"</span>);</span><br><span class="line">i.putExtras(bundle);</span><br><span class="line">startService(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求2</span></span><br><span class="line">Intent i2 = <span class="keyword">new</span> Intent(<span class="string">"cn.scu.finch"</span>);</span><br><span class="line">Bundle bundle2 = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle2.putString(<span class="string">"taskName"</span>, <span class="string">"task2"</span>);</span><br><span class="line">i2.putExtras(bundle2);</span><br><span class="line">startService(i2);</span><br><span class="line"></span><br><span class="line">startService(i);  <span class="comment">//多次启动</span></span><br></pre></td></tr></tbody></table></figure>

<p> 具体可以参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1963339">Android多线程：IntentService使用教程(含实例讲解)-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p>类似的思想也体现在 Fragment 的管理上，：</p>
<p>在 FragmentPagerAdapter 中，会有 instantiateItem 方法。里面会执行 mCurTrasaction.attach(fragment) ，去 attach fragment ，但是这个 attach 方法会立即执行么？ 不会的，这时候只会加入list 中，等 commit 的时候才会一起执行。</p>
<p>并且可以保证 attach 一定是在 detach 后面执行，也是用 msg 来实现</p>
<p><strong>具体得自己再去看下源码</strong>，老师讲得不详细。</p>
<h4 id="glide-中的巧妙使用"><a href="#glide-中的巧妙使用" class="headerlink" title="glide 中的巧妙使用"></a>glide 中的巧妙使用</h4><p>假设有这样一段代码：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">with</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">val</span> fragmentManager = supportFragmentManager</span><br><span class="line">    <span class="keyword">val</span> f: MyFragment? = fragmentManager.findFragmentByTag(<span class="string">"tag"</span>) <span class="keyword">as</span> MyFragment?</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>) {</span><br><span class="line">        fragmentManager.beginTransaction()</span><br><span class="line">            .add(MyFragment(), <span class="string">"tag"</span>)</span><br><span class="line">            .commitAllowingStateLoss()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过某种途径得到commit 时候用到的 handler </span></span><br><span class="line">        <span class="comment">//handler.sendMessage(removeFragmentMessage)</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果连续调用 2 次，会怎样？可能你会想，第一次已经创建了 MyFragment 实例了，第二次直接通过 findFragmentByTag 就能找出来了。但是不是的，可能会创建 2 次 MyFragment 。这是因为最后在 commitAllowingStateLoss 的时候，最终是将这个操作作为一个 msg 扔到 Handler 里面。所以，<strong>第二次调用 with 的时候，第一次不一定执行完</strong>!所以，可能执行 2 次。 这个在 glide 的源码中有体现：</p>
<ol>
<li><p>创建一个 HashMap ，以 tag 为key ，第一次的时候，首先从 hashmap中获取，如果没有，再从 fragmentManager 中获取，如果还没有，就创建一个，然后将其加入到 HashMap 中</p>
</li>
<li><p>第二次的时候，首先判断 HashMap 里面有没有，如果有的话，就忽略，因为这个 Fragment 最终肯定会被创建出来，此时应该是commit 的中提交到 handler 中的 msg 还没执行。</p>
</li>
<li><p>在上述代码的注释部分，可以看到最终通过handler 发送一个消息，这个消息用于将 fragment 从 HashMap 中移除 Fragment ，防止内存泄漏。</p>
</li>
</ol>
<blockquote>
<p>第三点为什么可以这么做呢？因为同一个handler ，commit 的时候发的消息，肯定在前面，后续用于移除 msg 的 msg 肯定在后面，这样很巧妙地保证了用完fragmengt 就从 HashMap 中移除。</p>
</blockquote>
<p>上述代码其实就是 glide 中的一段代码设计思想，具体可以参考 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/317b2d6bde1b">Glide生命周期管理 - 简书 (jianshu.com)</a>    中  2.0.1 <strong>创建RequestManagerFragment</strong>  这个章节。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/02/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8801%EF%BC%892021.12.9-Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90---Alvin%E8%80%81%E5%B8%88%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/02/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8801%EF%BC%892021.12.9-Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90---Alvin%E8%80%81%E5%B8%88%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">（01）2021.12.9-Handler源码分析---Alvin老师（2）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-02 18:24:00" itemprop="dateCreated datePublished" datetime="2023-06-02T18:24:00+08:00">2023-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:39:37" itemprop="dateModified" datetime="2023-06-28T21:39:37+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>避免内存抖动：共享内存池。</p>
<p>ActivityThread 的 main 函数不会退出，这是因为 Looper.loop </p>
<p>ActivityThread 扮演后台的角色，Looper.loop 扮演的是心跳的角色</p>
<p>Android 中 App 的所有事务都是 Message ，所以，当我们碰到异常的时候，看到的 Log 都是从 ActivityThread 中的 loop 处开始的</p>
<p>我们根据 Looper.loop 中打印日志的时间，来判断每个 Message 的执行耗时，这是 BlackCanary 的原理，能判断卡顿</p>
<p>没有 Msg 的时候，就休眠了，此时 ANR ？其实是混淆概念，这是2个事情， ANR 的含义是事务在定时范围内没有完成，执行事务前埋雷，执行完成后挖出雷，就不会爆炸；如果到了时间还没挖雷，雷就爆了。</p>
<p>什么是 epoll ？</p>
<p>上层有 n 个 I/O 事件，要如何才能去处理多个流。其实系统底层用一个线程死循环，去判断（多线程去判断更慢）。</p>
<p>epoll 与线程之间的数量没有对应关系，不用搞混。epoll 机制是需要注册的，要说明针对哪个事件去 阻塞和唤醒。</p>
<h2 id="同步屏障（消息屏障）"><a href="#同步屏障（消息屏障）" class="headerlink" title="同步屏障（消息屏障）"></a>同步屏障（消息屏障）</h2><p>屏障消息就是target 为 null 的消息。一般的消息都是通过 Handler 放到 MessageQuue 。消息有 3 种 ：</p>
<ul>
<li>同步消息</li>
<li>异步消息：async 标记为 true ，普通的同步msg 没人设置 async 标记</li>
<li>同步屏障消息</li>
</ul>
<p>如果打印出 skip 30 frames ，the Application may be doing too many work …. 之类的错误，那就说明在主线程阻塞了，某个 msg 耗时过长，导致里面 30 个异步消未能执行。</p>
<p>在 ViewRootImpl 类的 scheduleTraversals 方法中，执行了 mHandler.getQueue().postSyncBarrier() 方法，在 MessageQueue 中添加了同步屏障。接着，在这个方法里面最终会执行到 performMeasure 、performLayout 和 performDraw 方法，这就很熟悉了，就是平时说view 绘制的步骤，或者说自定义View 尤其要关注的回调。</p>
<p>post 同步屏障的时候，会把屏障消息放到 MessageQueue 的最前面吗？不是的，只是普通的以当前时刻放入</p>
<p>一个线程一个 Looper 是由 static final 的 ThreadLocal  保证的，并且prepare 只能搞一次，第二次判断有 looper 的时候就报错了，不能多次 prepare 。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/02/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8801%EF%BC%892021.12.9-Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90---Alvin%E8%80%81%E5%B8%88%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/02/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8801%EF%BC%892021.12.9-Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90---Alvin%E8%80%81%E5%B8%88%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">（01）2021.12.9-Handler源码分析---Alvin老师（1）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-02 09:15:00" itemprop="dateCreated datePublished" datetime="2023-06-02T09:15:00+08:00">2023-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:38:51" itemprop="dateModified" datetime="2023-06-28T21:38:51+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>每个安卓应用都有自己的 vm，所以，每个应用也都有自己的main函数，那么这个 main 函数在哪里呢？在 ActivityThread 里面（省略部分无关代码）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span> <span class="keyword">implements</span> <span class="title">ActivityThreadInternal</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//省略无关代码</span></span><br><span class="line">        <span class="comment">// Install selective syscall interception</span></span><br><span class="line">        AndroidOs.install();</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) {</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Looper.loop是个死循环，如何才能终止呢？通过MessageQueue.next获取到一个null类型的Message，就退出了​，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfsda</span><br></pre></td></tr></tbody></table></figure>

<p>messagequeue.quit 也可以达到退出 Looper.loop 死循环的效果。</p>
<p>Message 就是一块内存，内存不分线程（只区分进程吧），因此 Handler  这个过程可以看做是内存共享， 不同线程之间的共享 Msg 这块内存。因此某种程度上，可以</p>
<p>单链表实现的优先级队列</p>
<p>为什么要把 Looper 的初始化只能在 prepare() 方法中进行，而不能让人 new Looper() ？</p>
<p>为什么一个线程只能有一个 Looper ，因为 Looper 存储在 ThreadLocal 中，而我们知道key 是 ThreadLocal 的对象，是唯一的，所以 value 也是唯一的。并且，prepare 的时候，首先通过 threadLocal.get 去获取 Looper ，发现不空就报错，只能 Looper 为空的时候才能 prepare 。</p>
<p>Looper 维持一个 MessageQueue 。一个线程只能创建一个 Looper ，一个 Looper 创建一个 MessageQueue。</p>
<p>Handler 内存泄漏问题的原因？为什么其他内部类没有说有这个问题？比如说 RecyclerView 的 Adapter 里面一般会有一个 ViewHolder 内部类，它为什么不会内存泄漏？</p>
<p>内存泄漏的原因是生命周期不一致。</p>
<p>msg delay 了 20s 才执行，msg 持有的了handler ，handler 是非静态内部类，持有外部对象，所以可能导致内存泄漏。</p>
<p>子线程new handler 要做什么准备？</p>
<p>需要prepare ，有 Looper 才行。</p>
<p>子线程中维护 Looper，消息队列无消息的时候的处理方案是什么？有什么用？</p>
<p>需要调用 MessageQueue.quit， 这时候会将 mQuitting 标志位置为 true 。由于之前已经没有消息了，那么此时应该是处于 nativePollOnce 无限睡眠阶段，quit 方法同样会去调用 nativeWake 方法唤醒，这样就会继续 loope 方法，在里面判断到 mQuitting 为true ，于是return 了一个 null 类型的 Msg ，从而导致 Looper.loop 退出死循环</p>
<p>MessageQueue 为什么不设置容量上限？如果设置了，那么系统的消息都不能进去了，整个系统就死掉了。</p>
<p>两个方面的阻塞：</p>
<ul>
<li><p>Message 还不到时间，时间到了会自动唤醒</p>
</li>
<li><p>MessageQueue 为空，nextPollTimeoutMillis 值为 -1 ，就会进入 nativePollOnce 的无限睡眠了。在enqueueMessage （有新的 Msg 加入的时候）的时候，才会被唤醒（调用nativeWake）</p>
</li>
</ul>
<p>线程阻塞了，所以cpu 就不会来调度它了，节省了cpu 性能。</p>
<p>既然可以存在多个 Handler 往 MessageQueue 中添加数据（发消息的时候，各个Handler 可能在不同的线程），那么它的内部是如何保证线程安全的？</p>
<ul>
<li><p>首先，1个线程只有一个 MessageQueue </p>
</li>
<li><p>其次，MessageQueue 操作加锁了。在 MessageQueue 中，不论是 enqueue 方法，还是 next 方法，都会在里面锁代码块：</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>{</span><br><span class="line">     <span class="comment">//省略无关代码</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">         <span class="comment">//省略无关代码</span></span><br><span class="line">     }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">     <span class="comment">//省略无关代码</span></span><br><span class="line">     <span class="keyword">for</span> (;;) {</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">         <span class="comment">//省略无关代码</span></span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line">}        </span><br></pre></td></tr></tbody></table></figure>

<p>从代码可以看出，锁的是整个 MessageQueue 对象，所以，对于同一个 MessageQueue 来说，每次只能一个线程存/取。</p>
<p>为什么取的时候也要加锁？明明都是从头取？</p>
<p>这是因为你取的时候，我这边有线程正在加入新的 Msg ，此时就存在同步问题。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/24/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8807%EF%BC%892022.2.10-%E5%8D%A1%E9%A1%BF%E5%92%8C%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/24/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8807%EF%BC%892022.2.10-%E5%8D%A1%E9%A1%BF%E5%92%8C%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">性能优化-：（07）2022.2.10-卡顿和布局优化---路哥</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-24 19:00:00" itemprop="dateCreated datePublished" datetime="2023-05-24T19:00:00+08:00">2023-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-26 23:31:18" itemprop="dateModified" datetime="2023-05-26T23:31:18+08:00">2023-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>一、前情回顾</p>
<p>GC 的时候，Java 线程、Native 线程都会中断，中断就会卡顿，会影响性能。</p>
<p>上节课提到，执行一次 GC 后，间隔5s 或者 500ms 再次执行一下GC ，这样基本上能触发 GC ，这是什么原理呢？在 Android 5.0 以前，System.gc() 基本上就能触发 GC 行为，它的代码是这样的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates to the VM that it would be a good time to run the</span></span><br><span class="line"><span class="comment"> * garbage collector. Note that this is a hint only. There is no guarantee</span></span><br><span class="line"><span class="comment"> * that the garbage collector will actually be run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>{</span><br><span class="line">    Runtime.getRuntime().gc();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是在 5.0 及以后，调用 System.gc 或者 runTime.gc 不一定会触发 GC 了，这是因为在 5.0 及以后的 gc 方法里面会有标记判断：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates to the VM that it would be a good time to run the</span></span><br><span class="line"><span class="comment"> * garbage collector. Note that this is a hint only. There is no guarantee</span></span><br><span class="line"><span class="comment"> * that the garbage collector will actually be run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> shouldRunGC;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) {</span><br><span class="line">        shouldRunGC = justRanFinalization;</span><br><span class="line">        <span class="keyword">if</span> (shouldRunGC) {</span><br><span class="line">            justRanFinalization = <span class="keyword">false</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            runGC = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (shouldRunGC) {</span><br><span class="line">        Runtime.getRuntime().gc();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，是否执行 gc 还有赖于 justRanFinalization 变量，这个变量在哪里赋值为true 呢？是在 runFinalization 方法中：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provides a hint to the VM that it would be useful to attempt</span></span><br><span class="line"><span class="comment"> * to perform any outstanding object finalization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runFinalization</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> shouldRunGC;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) {</span><br><span class="line">        shouldRunGC = runGC;</span><br><span class="line">        runGC = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (shouldRunGC) {</span><br><span class="line">        Runtime.getRuntime().gc();</span><br><span class="line">    }</span><br><span class="line">    Runtime.getRuntime().runFinalization();</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) {</span><br><span class="line">        justRanFinalization = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从上述代码可以看出，我们直接调用 System.gc 并不会调用到 Runtime.getRunTime().gc() ，只是做了个标记将 runGc 设置为 true ，然后在下一次 GC 的时候，就能真正 GC 了。那为什么要间隔5s 或者 500ms 呢？这个跟线程调度、线程的中断状态有关。</p>
<p>所以，上一节课也提到，内存监控自己做 GC 的时候，也可以使用 runFinalization() + runTime.gc 的方式去GC，这样也是可以的。</p>
<p>由于路哥在课程里面对这个讲得不是太清晰，更详细的内容可以参考</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/225751">提升Android下内存的使用意识和排查能力-阿里云开发者社区 (aliyun.com)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/225755">再谈Finalizer对象–大型App中内存与性能的隐性杀手-阿里云开发者社区 (aliyun.com)</a></p>
</li>
</ul>
<h2 id="二、-Alpha-源码讲解"><a href="#二、-Alpha-源码讲解" class="headerlink" title="二、 Alpha 源码讲解"></a>二、 Alpha 源码讲解</h2><p>面试中怎么讲：</p>
<ul>
<li><p>Executor ：线程池，调用方可以自己实现，也可以使用默认的，参数怎么设置</p>
</li>
<li><p>Task ： 是个线程，有任务自己的状态、有自己的子任务</p>
</li>
<li><p>接口： 执行前、执行后、失败</p>
</li>
</ul>
<p>仿照 Alpha 的框架没有实现 DAG 算法，是个弊端</p>
<h3 id="1、主要要实现的功能"><a href="#1、主要要实现的功能" class="headerlink" title="1、主要要实现的功能"></a>1、主要要实现的功能</h3><p>线程池、线程等待、线程切换、主进程/子进程</p>
<h2 id="三、总结之前的启动框架"><a href="#三、总结之前的启动框架" class="headerlink" title="三、总结之前的启动框架"></a>三、总结之前的启动框架</h2><p>内存、ANR 、启动，这3个点，性能优化就能把握了</p>
<h2 id="四、卡顿"><a href="#四、卡顿" class="headerlink" title="四、卡顿"></a>四、卡顿</h2><p>根据前面说的，能够在 Activity 的 onWindowFocusChanged 方法中停止方法的采集，因为这个时候恰好是 window 切换，要么是新的 window 启动了，要么是关闭了某个 window，所以，如果我们要监测到第一个 Activity 的耗时，可以从Application 的 onCreate 中去start，在 MainActivity 中去 stop 这个 trace 去实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Application</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> : <span class="title">Application</span> </span>{</span><br><span class="line">    <span class="function">override fun <span class="title">onCreate</span><span class="params">(xx)</span> </span>{</span><br><span class="line">        Debug.startMethodTracingSampling(tracePath, bufferSize, untervalUs)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//MainActivity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="title">Activity</span> </span>{</span><br><span class="line">    <span class="function">override fun <span class="title">onWindowFocusChanged</span><span class="params">(hasFocus)</span> </span>{</span><br><span class="line">        Debug.stopMethodTracing()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你可以获取到更细粒度更精准的耗时，比如在 ListView 中 getView 方法，在方法调用前start ，在调用完成之后，调用 stop 。</p>
<p>根据上述获取的 trace 文件，拖到 AS 中就能看到方法的耗时，线程相关内容等。</p>
<p>systrace 比上面的方法更加精准。systrace 就是个 shell 脚本嘛，他需要使用 python 执行，比如定位到 SDK 目录下（platform-tools）的 systrace 时，调用 python systrace.py 即可。systrace 可以在 chrome 上打开，使用地址：</p>
<blockquote>
<p>chrome://tracing</p>
</blockquote>
<p>线上如何做卡顿。卡顿的原理。自己定义阈值，超过某个值就说是卡顿，比如 1000ms ，</p>
<p>CountDownLatch 实现让主线程等待所有的初始化完成才继续执行的。</p>
<p>第一个版本仿照 Alpha ，怎么保证顺序？</p>
<p>第二个版本 DAG （有向无环图）保证顺序</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/24/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8806%EF%BC%892022.1.25-%E5%9F%BA%E4%BA%8EAutoService%E5%92%8CCompose%E7%9A%84App%E5%90%AF%E5%8A%A8%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/24/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8806%EF%BC%892022.1.25-%E5%9F%BA%E4%BA%8EAutoService%E5%92%8CCompose%E7%9A%84App%E5%90%AF%E5%8A%A8%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">性能优化-：（06）2022.1.25-基于AutoService和Compose的App启动架构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-24 15:15:00 / 修改时间：23:09:21" itemprop="dateCreated datePublished" datetime="2023-05-24T15:15:00+08:00">2023-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>今天主要从<strong>组件化</strong> + <strong>责任链</strong> 的角度去讲启动。主要讲代码的可维护性、解耦，跟启动速度没什么关系</p>
<p>有些错误的做法是 在宿主的 Application 中初始化所有的组件。</p>
<p>app 启动包括三个部分： Application 过程、 Splash 过程、 Mainactivity 过程（第一个 Activity）</p>
<p>有可能在 Application 中用户同意了某些条款和不同意的情况下初始化还不一样。工信部要求App 这样。所以可能宿App 中定义一个 BaseApplication 接口，除了其他方法之外，在其中至少定义几个方法：</p>
<ul>
<li><p>不论同不同意用户协议都需要执行的方法</p>
</li>
<li><p>用户同意了协议才执行的方法</p>
</li>
<li><p>用户拒绝后执行的方法</p>
</li>
</ul>
<p>然后，让每个组件去实现这个接口，实现上述的方法，自己实现各自的逻辑。可以利用 autoService 将这些组件的 Application 注册到宿主中，并不需要自己去遍历添加到list 里面。这是在编译期间将这些组件的 Application 添加到宿主的list 中的，所以对于运行效率是没有影响的。</p>
<blockquote>
<p>在 autoService 的 gradle 中实现的，可以看看他的 gradle 文件</p>
</blockquote>
<p>compose 是一套新的 UI 体系，和以前的 View 和 ViewGroup 有啥区别？</p>
<blockquote>
<p>前者是声明式的，数据驱动的，后者是命令驱动的</p>
</blockquote>
<p>compose 和 databinding 的区别：</p>
<ul>
<li><p>databinding ： 只能绑定属性，只能绑定xml 属性中的值</p>
</li>
<li><p>compose 可以根据数据的变化改变视图的结构</p>
</li>
</ul>
<p>只有在主进程才需要执行我们的逻辑，有些SDK 可能会开启自己的进程，所以需要判断下。</p>
<p>老师说写 SplashActivity ，在 manifest 中给这个 SplashActivity 设置 theme ，在 theme 里面设置 background ，但是其实前面说启动优化的时候，给整个 App 设置 theme ，然后设置 android:windowSplashscreenContent 属性就好了，注意区分和甄别。</p>
<p>SplashActivity 启动 MainActivity ，那么 SplashActivity 在什么时候可以结束？我们知道，在启动过程肯定是 SplashActivity.onPause -&gt; MainActivity.onCreate -&gt; MainActivity.onResume -&gt; SplashActivity.onStop  这样的顺序执行的，当然，MainActivity的其他无关的回调省略了。所以，在 SplashActivity 的 onStop 的时候， SplashActivity 就没有什么意义了，所以可以在 SplashActivity 的 onStop 回调中执行 finish 结束。</p>
<blockquote>
<p>为什么这样做呢？因为如果在 SplashActivity 中 start MainActivity的时候直接 finish SplashActivity ，某种情况就可能会出现白屏，或者 MainActivity 崩溃了，就看不到我们 App 了</p>
</blockquote>
<p>讲到 1 小时40分钟的时候直接听不懂了，放弃，后续有时间看</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/24/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8805%EF%BC%892022.1.23-Android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%8C%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/24/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8805%EF%BC%892022.1.23-Android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%8C%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">性能优化-：（05）2022.1.23-Android启动优化，有向无环图任务管理分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-24 09:26:00" itemprop="dateCreated datePublished" datetime="2023-05-24T09:26:00+08:00">2023-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-26 23:34:05" itemprop="dateModified" datetime="2023-05-26T23:34:05+08:00">2023-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>启动优化已经有很多常规手段，如只加载必要模块，延迟加载等，能取得一些效果，为什么还需要启动框架呢？</p>
<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>比如在 Application 中存在很多 SDK，比如20 个，这些 SDK 存在先后顺序，如何保证按照依赖顺序并且高效地执行呢？比如下面的任务：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E4%BB%BB%E5%8A%A1.png" alt="有向无环图任务"></p>
<p>由图我们能看出相互之间的依赖：2 、3 依赖任务 1， 4 依赖任务 2 ，5 依赖 3 和 4。如果使用 Thread 去实现，会变得非常复杂。因此需要框架。</p>
<h2 id="二、有向无环图"><a href="#二、有向无环图" class="headerlink" title="二、有向无环图"></a>二、有向无环图</h2><p>如果任务执行有方向（有序），并且没有环。在凸轮中，这种一个有向图从所有顶点出发，无论经过哪些边都不会回到这些顶点，那么就是有向无环图，简称 DAG 图。在 DAG 中：</p>
<ul>
<li><p>顶点：图中的一个点，比如任务 1 ，任务 2</p>
</li>
<li><p>边：连接2个顶点的线段</p>
</li>
<li><p>入度：代表当前有多少边指向顶点（依赖多少任务）</p>
</li>
<li><p>出度：代表有多少边从顶点出发（被多少任务依赖）</p>
</li>
</ul>
<h2 id="三、拓扑排序"><a href="#三、拓扑排序" class="headerlink" title="三、拓扑排序"></a>三、拓扑排序</h2><p>将我们的启动任务生成 DAG 图后，就要对 DAG 图做 <strong>拓扑排序</strong>，即对我们的任务启动顺序进行排序。对于前面的有向无环图而言，我们只需要保证 2、3 在 1 之后执行5 在 3、4 之后执行即可，因此我们可以得到多种排序结果：</p>
<blockquote>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</p>
<p>1 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5</p>
<p>1 -&gt; 3 -&gt; 2 -&gt; 4 -&gt; 5</p>
</blockquote>
<p>也就是说，<strong>图的拓扑排序不是唯一的！</strong></p>
<p>对 DAG 拓扑排序可以选择 <strong>BFS（广度优先）算法</strong>或者<strong>DFS（深度优先）算法</strong>，BFS 算法排序的过程如下：</p>
<ol>
<li><p>找出图中入度为 0 的顶点</p>
</li>
<li><p>依次在图中删除这些顶点，删除后再找出入度为 0 的顶点</p>
</li>
<li><p>删除后再找出入度为 0 的顶点，重复执行第二步</p>
</li>
</ol>
<p>基于上面的例子的拓扑排序步骤如下：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/dag%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A41.jpg" alt="拓扑排序例子步骤"></p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/dag%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A42.jpg" alt="步骤2"></p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/dag%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A43.jpg" alt="DAG排序步骤3"></p>
<p>代码落地：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Startup</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Dispatcher</span> </span>{</span><br><span class="line">    <span class="comment">//执行初始化任务</span></span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">(Context context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本任务依赖的任务列表（入度）</span></span><br><span class="line">    List&lt;Class&lt;? extends Startup&lt;?&gt;&gt;&gt; dependence();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依赖任务的个数（入度个数）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDependenciesCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，所有的任务都实现 Startup 接口。</p>
<h2 id="四、线程管理"><a href="#四、线程管理" class="headerlink" title="四、线程管理"></a>四、线程管理</h2><p>有些项目写 ConcurrentHashMap 的时候，value 不是直接使用 Object 类型，而是会使用自定义的类似 Result 类型，把原始结果封装了一层。这是什么原因呢？这是因为 ConcurrentHashMap 的 value 不能为 null ，否则会报错。如果我封装一层就能保证 Result 对象是不空的。</p>
<p>CountDownLatch 如果在初始化的时候，传入 0 这个数字，在下面调用 CountDownLatch.await 将不会被阻塞。</p>
<p>SDK中的线程比较多，或者有自己的线程池，那么有几种方法：</p>
<ul>
<li><p>线程池设置成自己的线程池</p>
</li>
<li><p>反射改掉它的线程池</p>
</li>
<li><p>字节码增强技术，通过 gradle 插桩修改 SDK 的代码</p>
</li>
</ul>
<p>如果写的 Builder ，让使用者添加 Task ，这样子在 Task 很少的时候，是很方便的，如果有 20 个，100 个的时候就头大了。这时候有什么好的办法去做？有几个方案：</p>
<ul>
<li><p>使用注解，每个 Task 上都加上这个注解，然后在 </p>
</li>
<li><p>使用 ContentProvider ，在 xml 中把最后的任务写在 data 中</p>
</li>
</ul>
<p>视频中讲解的启动框架源码可以在[github开源项目中看到](<a target="_blank" rel="noopener" href="https://github.com/idisfkj/android-startup/blob/master/README-ch.md">android-startup/README-ch.md at master · idisfkj/android-startup · GitHub</a>)  ，这个项目比课程中的更加完善</p>
<h2 id="五、问题"><a href="#五、问题" class="headerlink" title="五、问题"></a>五、问题</h2><p>有个问题，为什么要先拓扑排序？</p>
<p>假如我们不拓扑排序，会发生什么？假如有task 5 和 6 ，都是在主线程运行，其中 6 是要等 5 结束后才能开始，假如我们不拓扑排序，此时 6 先执行，在这里阻塞了，由于阻塞，此时 5 也不能执行了，又由于在主线程，此时就 ANR 了。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/23/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8804%EF%BC%892022.1.20-Android%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87Application%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%80%97%E6%97%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/23/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8804%EF%BC%892022.1.20-Android%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87Application%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%80%97%E6%97%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">性能优化-：（04）2022.1.20-Android面试必备Application启动过程与耗时分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-23 09:13:00" itemprop="dateCreated datePublished" datetime="2023-05-23T09:13:00+08:00">2023-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-24 23:07:41" itemprop="dateModified" datetime="2023-05-24T23:07:41+08:00">2023-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>分为三个步骤：</p>
<ol>
<li><p>通过源码分析，知道启动流程（便于启动监控——哪些地方耗时）</p>
</li>
<li><p>阿里的启动优化方案</p>
</li>
<li><p>如何实现高效的 SplashActivity </p>
</li>
</ol>
<h2 id="二、启动流程"><a href="#二、启动流程" class="headerlink" title="二、启动流程"></a>二、启动流程</h2><p>分为三个流程，如下图所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%90%AF%E5%8A%A8%E4%B8%89%E6%B5%81%E7%A8%8B.png" alt="App启动的3个流程"></p>
<p>在第二个阶段中，Application 的启动很关键，其中 Application 中的 attachBaseContext 方法比较关键，很多时候我们会在里面做一些比较前置的任务，诸如：</p>
<ul>
<li><p>对于加固的 App ，这里会做解密的操作</p>
</li>
<li><p>对于热修复而言，第一时间将修复的 dex 给生效</p>
</li>
</ul>
<p>只需要在执行类之前，dex 中包括这个类。所以，理论上我们可以无需一次性将所有的 dex 文件在 attachBaseContext 的时候加载进去。第一个 Activity 启动之后，再将其他的 dex 加载进去。attachBaseContext 阶段可以使用字节的 BoostMultiDex 方案去优化。</p>
<p>只有 window 才能展示出来看到，而目前在 Android 里面就一个 PhoneWindow ，所以，我们看到的第一屏肯定只能是 第一个 Activity 的 PhoneWindow。</p>
<p>那么，在用户点击Launcher 到第一个 Activity 显示出来之前，我们要显示内容，显示什么内容呢？其实显示的是Application 的主题，这个主题里面有个属性：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/Theme.AndroidDemo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">".MainActivity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>application 的 theme 是 @style/Theme.AndroidDemo ，然后我们可以在theme 里面设置  android:windowSplashscreenContent 值：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Theme.AndroidDemo"</span> <span class="attr">parent</span>=<span class="string">"Theme.MaterialComponents.DayNight.DarkActionBar"</span>&gt;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSplashscreenContent"</span>&gt;</span>@drawable/ic_launcher_background<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>当然，以上操作要求 API 版本是 26 ，如果要兼容低的版本，就要设置 background 属性，但是这二者还是有区别的：</p>
<ul>
<li><p>background 只能是图片</p>
</li>
<li><p>windowSplashscreenContent 可以做动画</p>
</li>
</ul>
<p>这是怎么实现的呢？Application 里面压根就没有 Window 啊，其实在startActivity 的时候，Activity 真正启动之前，add 了一个 SplashWindow，WindowManager 通过 addView 的方式将 window 交给 WMS 去展示这个闪屏页了，这个闪屏window 会去解析 windowSplashscreenContent 字段。在第一个 Activity 初始化完，Activity 的 window 也通过 vm.addView 展示的时候，就会覆盖 SplashWindow 。</p>
<p>以上就是黑白屏优化，这其实就是欺骗用户，实际上也没加快启动速度。</p>
<p>所以，我们优化启动速度，优化在哪里呢？其实就是 vm.addView 添加 SplashWindow 和 vm.addView 第一个 Activity 的 window 之间的过程，将这个过程尽量缩短。并且，<strong>这个过程里面会执行 Application.onCreate()</strong>，所以我们需要减少 onCreate 的耗时。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>线程数，有些 SDK 会启动线程，你自己可能压根没创建线程。所以如何控制这个线程数呢？后续再讲，基本上可以通过阿里的 Alpha 。（老师说Android 的 startUp 比较垃圾），这就是 Application 的 onCreate 方法优化方法。</p>
<p>上述的过程还会经历第一个 Activity 的onCreate、onStart、onResume 这些流程</p>
<p>perfomStartActivity 的过程中， Activity.attach 的时候会为Activity创建 Context 、创建 window ，并未 window 设置 WindowManager。为什么这么设计？因为单一职责问题，Activity 是管理生命周期的，Window 是管理 View 的。</p>
<p>我们在 Activity 的 onCreate 中只应该去做 view 的操作，其他的诸如数据库初始化之类的应该放在子线程中异步操作。</p>
<blockquote>
<p>装饰模式是功能增强；代理模式只是代理，没有增强。</p>
</blockquote>
<p>有可能面试官会问，为什么采用 inflater 解析的view ，要比自定义的 view 效率低？这里我们可以看 setContentView 方法，最底层就是使用 inflater 实现的，如果能看到后面就会发现，大量使用反射创建出来 View 。而反射又是比较耗时的，所以总结如下：</p>
<ul>
<li><p>解析 xml 耗时</p>
</li>
<li><p>根据 xml 反射 view 的反射操作耗时</p>
</li>
</ul>
<p>所以，Activity 的 onCreate 怎么优化？如果采用的还是 xml 就没法优化；只能通过减少 xml 中的布局的层级，减少 view 个数，就减少时间；还有就是从上面的原理来说，可以自己去 new 这些view 。不过也可以用 compose ，它没有 xml 了，通过 new 之类的创建出来的。固定测量方式，避免过度渲染，多次测量问题。</p>
<p>onCreate 执行完成后，只是解析完成了 xml ，在 setContentView 的时候会创建 decorView，然后创建了 window ，但是还没有 显示出来，还要在 wm.addView() 才能显示在硬件上。而 handleResume 的时候，先执行了 onResume 回调之后，然后再执行Activity 的wm.addView() 。</p>
<p>所以，Activity 怎么优化，就得onResume() 以及之前的所有方法（onCreate、onStart） 。所以，在 onResume 这里面如果有耗时操作，就要上前面说的阿里的策略了（Alpha）。以及相应的<strong>懒加载</strong>思想（ViewStub、Viewpaget+fragment 等）。</p>
<p>层级，深度遍历，多一层 2的次幂</p>
<p>尽量使用 ConstraintLayout 而不是 Linelayout 这些，会增加嵌套。从观法的数据来看，其渲染速度比 RelativeLayout 要提升 40% 。</p>
<p>Activity 中所有的回调都是在 handler 里面执行的。handler 机制体系里面会有MessageQueue ，message 按照时间排序，如果最开始的那个msg 都要 10ms 后执行，那么线程就会通过 epoll 机制睡眠了。所以我们还是利用 IdelHandler 去让主线程空闲的时候去做。比如说，后台 Service 有些内容是没有必要那么及时的，可以考虑在IdleHandler 中执行。</p>
<blockquote>
<p>GC 会 STW ，所以，我们也能在 IdleHandler 中取做 GC ，这样就不会影响主线程，LeakCanary里面就是这么做的（老师展示的代码是这样的，AndroidWatchExecutor.waitForIdle()  方法。还需要自己确认下）。要注意一点，IdleHandler 中不要做耗时操作，因为它也是个 msg</p>
</blockquote>
<p>当 App 第一个 Activity 的 window 展示将 SplashWindow 覆盖的时候，是在 windowFocusChange 中实现切换的。所以我们一般用 windowFocusChange 来标记新的 window 启动。</p>
<p>每一个 Activity 都会有一个独一无二的 Window </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>启动优化分为几个点：</p>
<ul>
<li><p>黑白屏阶段，使用 manifest 中 theme 的 windowSplashscreenContent 属性</p>
</li>
<li><p>Application 的 attachBaseContext() 回调中，可以用 字节的 BoostMultiDex 方案</p>
</li>
<li><p>Application 的 onCreate 阶段，采用图论原理，将各个任务依次执行，例如阿里的 Alpha 框架</p>
</li>
<li><p>接着就到了Activity 阶段，由于要遭 onResume 之后才会执行 vm.addView 最终展示 window ，所以在 onCreate、onStart 、onResume 这些回调里面都不要执行耗时操作</p>
</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/22/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8803%EF%BC%892022.1.18-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%AF%BE%EF%BC%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%20%E5%86%85%E5%AD%98%E7%AF%87%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/22/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8803%EF%BC%892022.1.18-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%AF%BE%EF%BC%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%20%E5%86%85%E5%AD%98%E7%AF%87%EF%BC%89/" class="post-title-link" itemprop="url">性能优化-：（03）2022.1.18-性能优化第三次课（性能优化 内存篇）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-22 18:50:00" itemprop="dateCreated datePublished" datetime="2023-05-22T18:50:00+08:00">2023-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-24 23:09:16" itemprop="dateModified" datetime="2023-05-24T23:09:16+08:00">2023-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>USS 很重要，因为这是 Uniq 的，每个进程独占的。</p>
<p>USS、PSS、VSS 等波动用来监测内存抖动</p>
<p>oom_adj 相当于进程的优先级，数值越大越容易被回收</p>
<p>GC Roots 有：</p>
<ul>
<li><p>在线程栈中的局部变量（正在被调用的方法的参数和局部变量）</p>
</li>
<li><p>存活的线程对象</p>
</li>
<li><p>JNI引用</p>
</li>
<li><p>Class 对象（在 Android 中 Class 被加载后不会被卸载的）</p>
</li>
<li><p>引用类型的静态变量</p>
</li>
</ul>
<p>自动化监测流程目标</p>
<ul>
<li><p>自动且较为准确监测 Activity 泄漏</p>
</li>
<li><p>自动获取泄漏的 Actiivty 和 冗余Bitmap 对象的引用链</p>
</li>
<li><p>能灵活地扩展 Hprof 的分析逻辑，必要时允许提取 Hprof 文件人工分析</p>
</li>
</ul>
<p>在监测阶段，需要 2 个问题：</p>
<ul>
<li><p>activity 在执行销毁的时候，我们如何得知</p>
</li>
<li><p>如何判断一个 Activity 无法被 GC 机制回收</p>
</li>
</ul>
<blockquote>
<p>可以写自己写过 APM ，或者带几个人做过</p>
</blockquote>
<p>我们之前说在 Activity 的 destroy 时触发GC，但是这样不怎么好，我们需要手动触发 GC ，会导致卡顿。所以，一般不使用 registerActivityCallback ，而是通过 阈值触发（如 count 计数），达到阈值时就触发GC （Koom 就是这么做的）。</p>
<h2 id="常见内存泄漏原因"><a href="#常见内存泄漏原因" class="headerlink" title="常见内存泄漏原因"></a>常见内存泄漏原因</h2><ul>
<li><p>动画问题（在activity销毁时，调用动画的cancel 方法）</p>
</li>
<li><p>匿名内部类</p>
</li>
<li><p>InputStream/OutputStream 、cursor 等没有 close </p>
</li>
<li><p>xxx未完，后续看老师的笔记</p>
</li>
</ul>
<h2 id="Koom-的分析"><a href="#Koom-的分析" class="headerlink" title="Koom 的分析"></a>Koom 的分析</h2><p>如何将 APM 写入简历？</p>
<blockquote>
<p>如果自己做过 APM 就更好，如果没有做过就将 APM 接入自己的项目中，然后收集数据，记住那些数据就OK了——路哥</p>
</blockquote>
<h3 id="1、Native-Heap-泄漏监控："><a href="#1、Native-Heap-泄漏监控：" class="headerlink" title="1、Native Heap 泄漏监控："></a>1、Native Heap 泄漏监控：</h3><p>主要思路是借助 <strong>Tracing Garbage Collection</strong>（一种垃圾回收算法）来进行监控，GC 回收器的 G1 回收器就是基于这个理论。</p>
<p>google 提供了一个 libmemunreachable 库，我们可以把所有的代码拷贝到 NDK 里面，自己打包成 so 库，就能调用这个库发现 Native 的内存泄漏了。它会告知有哪些地址可达和不可达（reachable）。</p>
<p>Koom 的核心监控代码都在各种 monitor 中，比如 LeakMonitor.kt 等。</p>
<p>爱奇艺的 xHook 能够Hook Native 代码，hook 诸如 malloc 等方法，替换成自己的 malloc 函数，这样就能监测Native 的代码行为。一旦调用了 malloc 等函数，就回调出去。</p>
<p>ida 这个工具可以查看某个 so 里面有哪些 api，这样就能查看它所有的方法。 </p>
<p>koom Native 内存泄漏分析的思路：</p>
<ul>
<li><p>hook malloc/free 等内存分配器方法，用于记录 Native 内存分配元数据（大小、堆栈、地址等）</p>
</li>
<li><p>周期性地使用 mark and sweep 分析整个进程 Native Heap，获取不可达的内存块信息（地址、大小）</p>
</li>
<li><p>利用不可达的内存块地址、大小等，从我们之前记录的元数据中获取其分配堆栈，产出泄漏数据（不可达内存地址、分配堆栈、大小等）</p>
</li>
</ul>
<p>APM 在大厂都只会说原理，没法谈实战的。Android 只有APM 这个知识点可以这样。面试官问你 Koom Native层面 怎样 hook ，用 xhook，怎么知道内存泄漏的，google 官方提供的 libmemunreachable 库</p>
<p>profiler 里面也可以选择当前的进程，然后能看到 Leaks 就可以知道哪些泄漏的。</p>
<h3 id="2、Java-内存监测思路"><a href="#2、Java-内存监测思路" class="headerlink" title="2、Java 内存监测思路"></a>2、Java 内存监测思路</h3><p>LeakCanary 采用了弱引用的特性，为Activity 创建了弱引用，但是会在 Activity 的 onDestroy 之后连续触发 2 次 GC，并检查引用队列。但是 GC 会引起用户可感知的卡顿，所以 Koom 采用了<strong>无性能损耗的内存阈值监控</strong>来触发镜像采集。</p>
<p>Koom 的整体流程如下图所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Koom%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Koom整体流程"></p>
<h3 id="3、hprof-文件"><a href="#3、hprof-文件" class="headerlink" title="3、hprof 文件"></a>3、hprof 文件</h3><p>使用以下的命令可以导出 hprof 文件：</p>
<blockquote>
<p>adb shell am dumpheap <processname> <filename></filename></processname></p>
</blockquote>
<p>或者在Android 中采用如下代码（会暂时挂起所有线程）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug.dumpHprofData(fileName)</span><br></pre></td></tr></tbody></table></figure>

<p>由于会暂时挂起所有的线程，所以 LeakCanary 在这个时候会非常非常卡，这也是为什么不能用于线上的一个原因。这个时候面试官可能会问，那怎么解决这个问题呢？开子线程行不行？</p>
<blockquote>
<p>肯定是不行的，因为这时候挂起了所有线程，包括你的这个子线程。</p>
</blockquote>
<p>解决方案：</p>
<ul>
<li><p>fork 子进程去执行 dumpHprofData 方法</p>
</li>
<li><p>fork 进程采用的是 “copy On Write” 技术，只有在进行写入操作时，才会为子进程拷贝分配独立的内存空间。默认情况下，子进程可以和父进程共享同个内存空间。所以，当我们要执行dumpProfData 方法时，可以 fork 一个子进程，它拥有父进程的内存副本，然后在子进程中取执行 dumpProfData 方法，而父进程可以正常继续运行。</p>
</li>
</ul>
<p>这个过程的流程图如下所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/fork%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%8E%B7%E5%8F%96dump%E4%BF%A1%E6%81%AF.png" alt="fork子进程获取内存镜像"></p>
<p>hprof 文件很大，一般可达 1G 的规模，所以不可能直接丢给后台去分析，一般会做以下裁剪。这时候就看你具体要什么，可能不同的公司需要的不一样，但是大体上需要看 bitmap、byte 数组 byte[] 等。有个 shark 工具可以用来分析这个 hprof ，便于后续的裁剪。 我们关注的主要是 三类 信息：</p>
<ul>
<li><p>字符串信息，保存着所有的字符串，在解析时可以通过索引id引用</p>
</li>
<li><p>类的结构信息：包括类内部的变量布局、父类信息等</p>
</li>
<li><p>堆信息：内存占用与对象引用的详细信息</p>
</li>
</ul>
<p>裁剪的主要思路如下：</p>
<ol>
<li><p>读取 Hprof 文件</p>
</li>
<li><p>记录 Bitmap 和 String 类信息</p>
</li>
<li><p>移除 Bitmap buffer 和 String value 之外的基础类型数组</p>
</li>
<li><p>将同一个图片的 Bitmap buffer 指向同一个  buffer id，移除重复的 Bitmap buffer</p>
</li>
<li><p>其他数据原封不动地输出到新文件中</p>
</li>
</ol>
<p>性能优化里面最难的就是 内存，后续的 FPS 之类的就比较简单了。</p>
<h2 id="落脚点"><a href="#落脚点" class="headerlink" title="落脚点"></a>落脚点</h2><p>启动优化</p>
<p>apm 的 demo</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">208</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共389.9k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/4/',]
      });
      });
  </script>


</body>
</html>
