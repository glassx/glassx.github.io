<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.2">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.2" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.2">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="glassx的小黑屋,读书笔记">
<meta name="keywords" content="glassx,Android,android,读书笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https:&#x2F;&#x2F;glassx.gitee.io&#x2F;page&#x2F;4&#x2F;index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="glassx的小黑屋,读书笔记">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.gitee.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">57</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="glassx的小黑屋,读书笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Android 事件分发机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-02-25 22:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T22:00:00+08:00">2019-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-01 17:19:36" itemprop="dateModified" datetime="2019-05-01T17:19:36+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android-事件分发机制"><a href="#Android-事件分发机制" class="headerlink" title="Android 事件分发机制"></a>Android 事件分发机制</h1><p>Android 事件分发机制总体来说可以用几张图说明白，相比在代码中打印Log，这种方式更容易理解和记住。</p>
<h2 id="针对-ACTION-DOWN-事件"><a href="#针对-ACTION-DOWN-事件" class="headerlink" title="针对 ACTION_DOWN 事件"></a>针对 ACTION_DOWN 事件</h2><p>只针对 ACTION_DOWN 事件时，事件的完整流向是一个U形图，如下图所示：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/down-all.png" alt="只考虑ACTION_DOWN 事件时事件流向图"></p>
<p>如果没有中断事件，可能看起来更直观一些，Activity、ViewGroup、View的层次更加清晰：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/down-u.png" alt="不中断事件"></p>
<h2 id="针对-ACTION-MOVE-和-ACTION-UP"><a href="#针对-ACTION-MOVE-和-ACTION-UP" class="headerlink" title="针对 ACTION_MOVE 和 ACTION_UP"></a>针对 ACTION_MOVE 和 ACTION_UP</h2><p>上面讲解的都是针对ACTION_DOWN的事件传递，ACTION_MOVE和ACTION_UP在传递的过程中并不是和ACTION_DOWN 一样，你在执行ACTION_DOWN的时候返回了false，后面一系列其它的action就不会再得到执行了。简单的说，就是当dispatchTouchEvent在进行事件分发的时候，只有前一个事件（如ACTION_DOWN）返回true，才会收到ACTION_MOVE和ACTION_UP的事件。</p>
<h3 id="ViewGroup1-的dispatchTouchEvent-中返回true消费事件"><a href="#ViewGroup1-的dispatchTouchEvent-中返回true消费事件" class="headerlink" title="ViewGroup1 的dispatchTouchEvent 中返回true消费事件"></a>ViewGroup1 的dispatchTouchEvent 中返回true消费事件</h3><p>红色的箭头代表ACTION_DOWN 事件的流向，蓝色的箭头代表ACTION_MOVE 和 ACTION_UP 事件的流向：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-1.png" alt="viewgroup1消费"></p>
<h3 id="ViewGroup2-的dispatchTouchEvent-中返回true消费事件"><a href="#ViewGroup2-的dispatchTouchEvent-中返回true消费事件" class="headerlink" title="ViewGroup2 的dispatchTouchEvent 中返回true消费事件"></a>ViewGroup2 的dispatchTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-2.png" alt="viewgroup2消费"></p>
<blockquote>
<p>在View 的dispatchTouchEvent 返回true消费事件,就不画图了，效果和在ViewGroup2 的dispatchTouchEvent return true的差不多，同样的收到ACTION_DOWN 的dispatchTouchEvent函数都能收到 ACTION_MOVE和ACTION_UP。</p>
</blockquote>
<h3 id="在View-的onTouchEvent-中返回true消费事件"><a href="#在View-的onTouchEvent-中返回true消费事件" class="headerlink" title="在View 的onTouchEvent 中返回true消费事件"></a>在View 的onTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-3.png" alt="在View 的onTouchEvent 中返回true消费事件"></p>
<h3 id="在ViewGroup-2-的onTouchEvent-中返回true消费事件"><a href="#在ViewGroup-2-的onTouchEvent-中返回true消费事件" class="headerlink" title="在ViewGroup 2 的onTouchEvent 中返回true消费事件"></a>在ViewGroup 2 的onTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-4.png" alt="在ViewGroup 2 的onTouchEvent 中返回true消费事件"></p>
<h3 id="在ViewGroup-1-的onTouchEvent-中返回true消费事件"><a href="#在ViewGroup-1-的onTouchEvent-中返回true消费事件" class="headerlink" title="在ViewGroup 1 的onTouchEvent 中返回true消费事件"></a>在ViewGroup 1 的onTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-5.png" alt="在ViewGroup 1 的onTouchEvent 返回true消费这次事件"></p>
<h3 id="在View的dispatchTouchEvent-中返回false并且ViewGroup-1-的onTouchEvent-返回true消费事件"><a href="#在View的dispatchTouchEvent-中返回false并且ViewGroup-1-的onTouchEvent-返回true消费事件" class="headerlink" title="在View的dispatchTouchEvent 中返回false并且ViewGroup 1 的onTouchEvent 返回true消费事件"></a>在View的dispatchTouchEvent 中返回false并且ViewGroup 1 的onTouchEvent 返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-6.png" alt="在View的dispatchTouchEvent 返回false并且Activity 的onTouchEvent 返回true消费这次事件"></p>
<h3 id="在View的dispatchTouchEvent-中返回false并且Activity-的onTouchEvent-返回true消费事件"><a href="#在View的dispatchTouchEvent-中返回false并且Activity-的onTouchEvent-返回true消费事件" class="headerlink" title="在View的dispatchTouchEvent 中返回false并且Activity 的onTouchEvent 返回true消费事件"></a>在View的dispatchTouchEvent 中返回false并且Activity 的onTouchEvent 返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-7.png" alt="在View的dispatchTouchEvent 返回false并且Activity 的onTouchEvent 返回true消费这次事件"></p>
<p>经过这么多图能得出以下规律：</p>
<blockquote>
<p>ACTION_DOWN事件在哪个控件消费了（return true）， 那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。</p>
</blockquote>
<p>以上文章参考自 <a href="https://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="noopener">Kelin</a> ,这里图片形式贴出来仅仅只是个人做的笔记，方便记忆。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/02/16/%E9%BB%91%E8%8B%B9%E6%9E%9C%E6%8A%98%E8%85%BE%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="glassx的小黑屋,读书笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/16/%E9%BB%91%E8%8B%B9%E6%9E%9C%E6%8A%98%E8%85%BE%E8%AE%B0/" class="post-title-link" itemprop="url">黑苹果折腾记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-02-16 22:10:00" itemprop="dateCreated datePublished" datetime="2019-02-16T22:10:00+08:00">2019-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-14 08:48:26" itemprop="dateModified" datetime="2019-09-14T08:48:26+08:00">2019-09-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>过年在家没啥事干，折腾了下黑苹果，安装上了 OSX 10.14.3，整个过程还算顺利，最终除了睡眠和声卡之外，其他貌似ok，目前用来开发（Android studio 以及 XCode）没啥问题。此次记录主要是为了在以后还有闲心折腾黑苹果的时候，能拿出来参考，不至于从头开始爬帖。</p>
<p>首先，以一个过来人的身份告诉你，搞黑苹果如果不上 <a href="https://www.tonymacx86.com" target="_blank" rel="noopener">www.tonymacx86.com</a> 网站的话，等于白折腾，这上面有最简便的最新的折腾黑苹果的方法，在国内远景论坛、黑苹果社区等地方看到的清一色古老的安装方式，甚至还有变色龙安装法。不要害怕 English，对于搞黑苹果而言，只需要很简单的英语水平。我这次安装10.14.3参考的就是<a href="https://www.tonymacx86.com/threads/unibeast-install-macos-mojave-on-any-supported-intel-based-pc.259381/" target="_blank" rel="noopener">这个帖子</a>，只要一步步来，基本上是没什么问题的。</p>
<p>这个帖子主要条理清晰地通过5步，即完成了黑苹果的安装：<br>Step 1: Download macOS Mojave（第一步：下载系统）<br>Step 2: Create a Bootable USB with UniBeast（第二步：通过 UniBeast 制作 U盘启动盘）<br>Step 3: Recommended BIOS Settings（第三步：设置 BIOS ）<br>Step 4: Install macOS Mojave(第四步：安装系统)<br>Step 5: Post Installation with MultiBeast（第五步：二次安装）</p>
<p>在开始之前，首先申请 tonymacx86.com 的账号，然后 在从那里下载最新的 UniBeast 和 MultiBeast 工具，之后准备一个 32GB 的U盘吧，教程上面说 16G 以上就够了，但实际上是不够的。其中，UniBeast 的作用是 创建一个可以正常启动10.14.3 的 U盘启动盘。</p>
<h2 id="第一步-下载系统"><a href="#第一步-下载系统" class="headerlink" title="第一步 下载系统"></a>第一步 下载系统</h2><p>为了全新安装，首先可以从其他苹果系统里面下载系统，在苹果系统中：</p>
<blockquote>
<p>打开 App Store -&gt; 下载macos Mojave 更新，下载完成后，在 Applications(应用)里面能够找到它。</p>
</blockquote>
<h2 id="第二步-用-UniBeast-创建启动U盘"><a href="#第二步-用-UniBeast-创建启动U盘" class="headerlink" title="第二步 用 UniBeast 创建启动U盘"></a>第二步 用 UniBeast 创建启动U盘</h2><p>在第二步之前，首先备份好U盘的东西，因为制作启动盘会删除U盘中所有内容。</p>
<p>把U盘插到电脑上，打开：Application（应用）-&gt;Utilities（工具）-&gt; Disk Utility（磁盘工具）,从左边选中你的那个U盘，在Mojava或者更高版本中，可能你首先要设置 View(视图)-&gt;Show All Devices(显示所有设备)，才能看到你的U盘。之后执行</p>
<p>1、 点击 Erase（抹掉）按钮<br>2、填写名称，目前先命名为 USB<br>3、在Format（格式）的地方选择 Mac os Extended(Journaled)<br>4、最后，点击 Erase（抹掉） 按钮正式抹掉</p>
<p>接下来，安装你下载的 UniBeast （这里貌似要求语言是English，否则还装不上，如果有这个要求，改下系统语言就行了），只要一直continue 下去就行，之后同意协议，最后选择安装的 Destination（目的磁盘）的时候，选择刚才抹掉的 USB盘 即可；在 select os Installation （选择安装系统）界面时，选择 Mojave 就行，之后在 Bootloader Options 界面选择 UEFI Boot Mode（根据需要有可能要选择 Legacy Boot Mode）。最后 Graphics Configuration 是可选的，可以根据你的显卡来对应设置。最后确认你的安装选项，输入密码，然后 Install。这时候大概要等待个10分钟，系统会写完。</p>
<p>系统完全写入U盘之后，把下载的 MultiBeast 软件拖到 U 盘，因为安装好之后需要它。</p>
<h2 id="第三步-设置BIOS"><a href="#第三步-设置BIOS" class="headerlink" title="第三步 设置BIOS"></a>第三步 设置BIOS</h2><p>这里只针对UEFI 方式的BIOS 了（其他方式请参考原文了）。进入到 BIOS 设置中，如果CPU支持 VT-d，将其设置为 disable，CFG-Lock、Secure Boot Mode 、IO Serial Port 也 disable，设置 XHCI 为 Enable，设置 OS 为 Other OS。</p>
<h2 id="第四步-安装-macOS-Mojave"><a href="#第四步-安装-macOS-Mojave" class="headerlink" title="第四步 安装 macOS Mojave"></a>第四步 安装 macOS Mojave</h2><p>将U盘插在电脑的USB2.0口上，这点特别要注意，不然第二次安装的时候会提示找不到resource，我就在这里折腾了两回才知道。开机，选择从你的 USB 盘启动（不同的电脑主板不一样，网上搜下即可）。<br>在clover界面，通过键盘上的左右箭头（键盘右下角的上下左右箭头）选择 Boot OS X Install from macOS Mojave</p>
<p>在安装界面，首先选择顶部菜单栏的 Utilities（工具），再打开 Disk Utility（磁盘工具），在左边选中你想要安装系统的分区，之后像之前抹掉U盘那样抹掉这个分区，名字命名为 Mojave（之后你可以改这个名字），之后关闭Disk Utility（磁盘工具），即可继续安装。</p>
<p>安装的时候会提示安装到哪个盘，选择刚才抹掉的 Mojave 盘，之后会继续安装，待安装完成后会自动重启。</p>
<h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>在重启的时候要注意再次选择从U盘启动，之后在clover界面选择Mojave，之后就会自动安装，引导设置，完成。之后的事情就是安装驱动了，去论坛找各种kext即可，声卡可能就麻烦些，可能需要dsdt，这里就不细说。</p>
<h2 id="问题集锦"><a href="#问题集锦" class="headerlink" title="问题集锦"></a>问题集锦</h2><h3 id="休眠导致键盘不可用"><a href="#休眠导致键盘不可用" class="headerlink" title="休眠导致键盘不可用"></a>休眠导致键盘不可用</h3><p>如果是笔记本并且安装的是双系统（win + mac os），那么如果驱动对休眠的处理不好的话，在mac osx下发生休眠可能会导致系统重启，可能会重启进入windows系统，此时，你的键盘应该是不可用的。解决方案包括以下几个步骤：</p>
<ol>
<li>启动windows ，在登录界面使用 “轻松使用-屏幕键盘” 的方式输入密码。    </li>
<li>在windows 下使用 easyUefi 软件将 黑苹果的 efi 启动序列列为第一个，这样我们开机就会启动 clover。    </li>
<li>重启系统，进入clover，此时键盘应该是不可以使用的，左右光标也是没作用的。如果能够看到你要启动的分区，则用鼠标点击直接启动，进入mac os 后，正常关闭，键盘就能正常使用了。    </li>
<li>如果未能看到需要启动的分区，此时按字母 A 键，就会进入clover 的 “关于” 页面（这个我只在我电脑上试过，我在尝试按 A 或者 D 的时候发现的，对其他电脑的未做验证），此时，你的电脑键盘应该就可以使用了。这时候就可以退出“关于”页，之后进入黑苹果。     </li>
<li>以上操作的主要目的是要正常关闭mac os ，这样键盘才能使用（在 mac os 或者 windows 下）。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/12/10/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="glassx的小黑屋,读书笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/10/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">第五章——理解 RemoteViews</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-10 22:00:00" itemprop="dateCreated datePublished" datetime="2018-12-10T22:00:00+08:00">2018-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-01 17:48:00" itemprop="dateModified" datetime="2019-05-01T17:48:00+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从字面可以看出这应该是一种远程view，与远程service概念一样，RemoteViews表示的是一种view结构，这种view能够在其他进程显示。由于需要跨进程显示，RemoteViews结构提供了一组基础功能用于跨进程更新View。RemoteViews在Android中有2种应用场景：<strong>Notification</strong>以及<strong>桌面小部件</strong>。</p>
<h3 id="RemoteViews的应用"><a href="#RemoteViews的应用" class="headerlink" title="RemoteViews的应用"></a>RemoteViews的应用</h3><p>平时的开发过程中，Notifications主要通过NotificationManager的notify方法实现的，它除了默认效果外，还可以另外定义布局。使用RemoteViews实现通知栏时无法像Activity里面一样直接更新View，这是因为RemoteView界面运行在其他进程中，确切来说是系统的SystemServer进程。使用系统默认的样式弹出一个通知是很简单的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Notification notification = newNotification();</span><br><span class="line">notification.icon = R.drawable.icon;</span><br><span class="line">notification.tickerText = <span class="string">"hello world"</span>;</span><br><span class="line">notification.when = System.currentTimeMillis();</span><br><span class="line">notification.flags = Notification.FLAG_AUTO_CANCEL;</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,DemoActivity_1.class);</span><br><span class="line">PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,intent,PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用普通样式展示一个通知</span></span><br><span class="line">notification.setLatestEventInfo(<span class="keyword">this</span>,<span class="string">"chapter_5"</span>,<span class="string">"this is notification"</span>,pendingIntent);</span><br><span class="line">NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">manager.notify(<span class="number">1</span>,notification);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用RemoteViews的方式展示第一个通知</span></span><br><span class="line">RemoteViews remoteViews = <span class="keyword">new</span> RemoteViews(getPackageName(),R.layout.layout_notification);</span><br><span class="line">remoteViews.setTextViewText(R.id.msg,<span class="string">"chapter_5"</span>);</span><br><span class="line">remoteViews.setImageViewResource(R.id.icon,R.drawable.icon1);</span><br><span class="line">PendingIntent openActivity2PendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,<span class="keyword">new</span> Intent(<span class="keyword">this</span>,DemoActivity_2.class),PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">remoteViews.setOnclickPendingIntent(R.id.open_activity2,openActivity2PendingIntent);</span><br><span class="line">notification.contentView = remoteViews;</span><br><span class="line">notification.contentIntent = pendingIntent;</span><br><span class="line">NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">manager.notify(<span class="number">2</span>,notification);</span><br></pre></td></tr></table></figure>

<p>以上代码展示只要提供当前应用的包名以及布局文件的id即可创建一个RemoteViews对象，而更新RemoteViews，由于无法直接访问里面的view，因而只能通过RemoteViews提供的一系列方法来更新，比如设置文本，需要采用 remoteViews.setTextViewText(R.id.msg,”chapter_5”) ，而更新图片则采用 remoteViews.setImageViewResource(R.id.icon,R.drawable.icon1)，如果要给一个控件添加click事件，则要使用PendingIntent并且通过setOnclickPendingIntent。关于PendingIntent，它表示一种待定的Intent，这个Intent中所包含的意图必须由用户来出发。</p>
<p><strong>RemoteViews在桌面小部件上的应用、PendingIntent概述、RemoteViews的内部机制等内容 待后续有集中的时间再添加</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/10/17/%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6-%E7%AC%AC%E4%B9%9D%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="glassx的小黑屋,读书笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/17/%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6-%E7%AC%AC%E4%B9%9D%E7%AB%A0/" class="post-title-link" itemprop="url">第9章-单元测试</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-10-17 22:30:00 / Modified: 22:50:05" itemprop="dateCreated datePublished" datetime="2018-10-17T22:30:00+08:00">2018-10-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>照例，如果自学不需要看我这个博客的话，资料如下：<br><a href="https://developer.android.google.cn/studio/test/?hl=zh-cn" target="_blank" rel="noopener">官网关于Android Test的介绍的地址</a><br><a href="https://github.com/googlesamples/android-testing" target="_blank" rel="noopener">Android官方关于测试的例子</a> ，需要的自取</p>
<p>单元测试、集成测试、黑盒测试、白盒测试等，只有单元测试是我们开发人员需要自己完成的，其余都是由测试人员完成的。单元测试本质上也是代码，是验证代码正确性的代码。</p>
<h2 id="为什么要做单元测试"><a href="#为什么要做单元测试" class="headerlink" title="为什么要做单元测试"></a>为什么要做单元测试</h2><ul>
<li>便于后期重构。单元测试为后期测试提供了保障，在重构之后，只要单元测试还是全部通过，那么在很大程度上表示重构没有引入新的bug。</li>
<li>优化设计。编写单元测试将使开发者从调用者的角度观察和思考，这样迫使开发者把程序设计成易于调用和低耦合的易测试的形式。</li>
<li>避免代码出现回归。编写完成后，可以随时随地快速运行测试，而不是要求将代码部署到设备上，再手动执行覆盖各种路径。</li>
<li>文档记录。单元测试是极好的“官方文档”，它展示函数或者类如何使用。</li>
</ul>
<h2 id="Android-测试类型-选自官网"><a href="#Android-测试类型-选自官网" class="headerlink" title="Android 测试类型(选自官网)"></a>Android 测试类型(选自官网)</h2><p>测试代码的位置取决于您要编写的测试的类型。 Android Studio 为以下两种测试类型提供了源代码目录（源集）：</p>
<h3 id="本地单元测试"><a href="#本地单元测试" class="headerlink" title="本地单元测试"></a>本地单元测试</h3><p>位于 <strong>module-name/src/test/java/</strong>目录。</p>
<p>这些测试在计算机的本地 Java 虚拟机 (JVM) 上运行。 当您的测试没有 Android 框架依赖项或当您可以模拟 Android 框架依赖项时，可以利用这些测试来尽量缩短执行时间。</p>
<p>在运行时，这些测试的执行对象是去掉了所有 final 修饰符的修改版 android.jar。 这样一来，您就可以使用 Mockito 之类的常见模拟库。</p>
<h3 id="Instrumented测试（仪器测试）"><a href="#Instrumented测试（仪器测试）" class="headerlink" title="Instrumented测试（仪器测试）"></a>Instrumented测试（仪器测试）</h3><p>位于 module-name/src/androidTest/java/。</p>
<p>这些测试在硬件设备或模拟器上运行。 这些测试有权访问 Instrumentation API，让您可以获取某些信息（例如您要测试的应用的 Context）， 并且允许您通过测试代码来控制受测应用。 可以在编写集成和功能 UI 测试来自动化用户交互时，或者在测试具有模拟对象无法满足的 Android 依赖项时使用这些测试。</p>
<p>由于仪器测试内置于 APK 中（与您的应用 APK 分离），因此它们必须拥有自己的 AndroidManifest.xml 文件。 不过，由于 Gradle 会自动在构建时生成该文件，因此它在您的项目源集中不可见。 您可以在必要时（例如需要为 <code>minSdkVersion</code> 指定其他值或注册测试专用的运行侦听器时）添加自己的清单文件。 构建应用时，Gradle 会将多个清单文件合并成一个清单。</p>
<p>Gradle 构建解读这些测试源集的方式与其解读项目应用源集的方式相同，您可以利用这一点根据构建变体创建测试。</p>
<p>以下示意图诠释了两种测试的代码结构（图中1表示的是<strong>仪器测试</strong>的代码，2表示的是<strong>单元测试</strong>的代码结构）</p>
<p><img src="https://developer.android.google.cn/studio/images/test/project-window-tests_2-2_2x.png?hl=zh-cn" alt="单元测试与仪器测试示意图"></p>
<h2 id="Junit4"><a href="#Junit4" class="headerlink" title="Junit4"></a>Junit4</h2><p>在Android测试框架中，常用的有以下几个框架和工具类：JUnit4、AndroidJUnitRunner、Mockito、Espresso，其中主要的单元测试使用Junit4。Junit4是一套基于注解的单元测试框架，在Android studio中，编写在test目录下的测试类都是基于该框架实现，该目录下的代码直接运行在本地的JVM上，不需要Android真机或者模拟器支持。常用的注解如下(更多内容可以查看<a href="https://junit.org/junit4/" target="_blank" rel="noopener">Junit4官网</a>)：</p>
<ul>
<li>@BeforeClass 测试类里所有用例运行之前，运行一次这个方法。方法必须是public static void</li>
<li>@AfterClass 与BeforeClass对应</li>
<li>@Before 在每个用测试例运行之前都运行一次。</li>
<li>@After 与Before对应</li>
<li>@Test 指定该方法为测试方法，方法必须是public void</li>
<li>@RunWith 测试类名之前，用来确定这个类的测试运行器<br>以下用一个简单的测试类来展示测试类的大概形式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaculatUtilTest</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> CaculatUtil mCaculatUtil;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Before</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">		mCaculatUtil = <span class="keyword">new</span> CaculatUtil();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTwoNumbers</span><span class="params">()</span></span>&#123;</span><br><span class="line">		assertEquals(<span class="number">3</span>,mCaculatUtil.add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">		<span class="comment">//或者如果是静态方法，就类似于以下这种静态调用方法</span></span><br><span class="line">		assertEquals(<span class="number">3</span>,Caculator.add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Junit的断言和失败提示"><a href="#Junit的断言和失败提示" class="headerlink" title="Junit的断言和失败提示"></a>Junit的断言和失败提示</h2><p>Junit提供了多个以assert开头的函数，分别用来验证各类相等性质的问题，大致有如下几类：</p>
<ul>
<li><p>assertEquals</p>
<blockquote>
<p>assertEquals的作用是判断两个值或者对象是否相等。接受2个参数，参数1为预期值，参数2为计算得到的值。</p>
</blockquote>
</li>
<li><p>assertTrue 与 assertFalse</p>
<blockquote>
<p>assertTrue 与 assertFalse顾名思义就是分别验证真与假，只需要一个boolean类型的参数。例如 assertTrue(false)测试会失败， 而 assertTrue(true) 测试通过。</p>
</blockquote>
</li>
<li><p>assertNull 与 assertNotNull</p>
<blockquote>
<p>和assertTrue、assertFalse类似，只不过是用来判断空或者非空。例如：assertNull(null) 会测试失败，因为值为null；而assertNull(“hell”)就能测试通过。</p>
</blockquote>
</li>
<li><p>assertSame 与 assertNotSame</p>
<blockquote>
<p>assertSame用于判断两个对象是否是同一个对象，与assertEquals不同的是，assertSame强调的为同一个对象，而assertEquals只要两个对象相等即可（即调用equals函数时返回true）。</p>
</blockquote>
</li>
<li><p>failNotEquals</p>
<blockquote>
<p>函数有3个参数，参数1位失败时提示信息，参数2为期望值，参数3是实际值。当两个对象不相等时抛出参数1的错误信息。</p>
</blockquote>
</li>
<li><p>failSame与failNotSame</p>
<blockquote>
<p>failNotSame与failNotEquals类似，不是同一个对象时就抛出参数1的错误信息。</p>
</blockquote>
</li>
<li><p>fail(String) 与 fail()</p>
<blockquote>
<p>fail(String)直接抛出当前测试用例参数1中的错误信息，而fail()给出默认的错误信息。</p>
</blockquote>
</li>
</ul>
<h2 id="运行多个测试类——TestSuite"><a href="#运行多个测试类——TestSuite" class="headerlink" title="运行多个测试类——TestSuite"></a>运行多个测试类——TestSuite</h2><p>如果需要同时运行两个或多个Test类，JUnit提供了Suite注解，在对应的测试目录下创建一个空Test类：</p>
<ul>
<li>@RunWith(Suite.class)：配置Runner运行环境。</li>
<li>@Suite.SuiteClasses({A.class, B.class})：添加需要一起运行的测试类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(Suite.class)</span><br><span class="line"><span class="meta">@Suite</span>.SuiteClasses(&#123;CalculatorTest.class, CalculatorWithParameterizedTest.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitTestSuite</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，UnitTestSuite成了一个空类，测试类被添加到注解中了。<br>或者，如果不用注解，可以通过JUnit4TestAdapter包装测试类，并将JUnit4TestAdapter对象添加到TestSuit中，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathTestSuite</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">suite</span><span class="params">()</span></span>&#123;</span><br><span class="line">		TestSuite suite = <span class="keyword">new</span> TestSuite(<span class="string">"com.book.jtm"</span>);</span><br><span class="line">		<span class="comment">//添加测试用例</span></span><br><span class="line">		suite.addTest(<span class="keyword">new</span> JUnit4TestAdapter(AdderTest.class));</span><br><span class="line">		suite.addTest(<span class="keyword">new</span> JUnit4TestAdapter(DiverTest.class));</span><br><span class="line">		<span class="keyword">return</span> suite;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码有一个静态的suite函数，它返回一个Test对象，这个对象是TestSuite类型的。测试时，以Junit测试用例的形式运行这个MathTestSuite即可运行这两个测试类。</p>
<h2 id="多个参数输入测试"><a href="#多个参数输入测试" class="headerlink" title="多个参数输入测试"></a>多个参数输入测试</h2><p>当需要传入多个参数进行测试时，可以使用 @Parameters 来进行单个方法的多次不同参数的测试，对于测试类，使用该方法需要如下步骤：</p>
<ul>
<li>在测试类上添加@RunWith(Parameterized.class)注解</li>
<li>添加测试类的构造函数</li>
<li>添加获取参数集合的static方法，并在方法上添加@Parameters注解</li>
<li>在需要测试的方法中直接使用成员变量，该变量由JUnit通过构造方法生成</li>
</ul>
<p>直接上示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(Parameterized.class)<span class="comment">//为测试类添加注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaculatUtilTest</span></span>&#123;</span><br><span class="line">	<span class="comment">//两个传入的参数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> paramOne;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> paramTwo;</span><br><span class="line">	<span class="comment">//期望值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> expectResult;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> CaculatUtil mCaculatUtil;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CaculatUtilTest</span><span class="params">(<span class="keyword">int</span> paramOne,<span class="keyword">int</span> paramTwo,<span class="keyword">int</span> expectResult)</span></span>&#123;<span class="comment">//添加构造函数</span></span><br><span class="line">		<span class="keyword">this</span>.paramOne = paramOne;</span><br><span class="line">		<span class="keyword">this</span>.paramTwo = paramTwo;</span><br><span class="line">		<span class="keyword">this</span>.expectResult = expectResult;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加获取参数集合的static方法，并在方法上添加@Parameters注解</span></span><br><span class="line">	<span class="meta">@Parameters</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Object[]&gt; initTestData()&#123;</span><br><span class="line">		<span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Object[][]&#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Before</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">		mCaculatUtil = <span class="keyword">new</span> CaculatUtil();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTwoNumbers</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//测试的方法中直接使用成员变量</span></span><br><span class="line">		assertEquals(expectResult,mCaculatUtil.add(paramOne,paramTwo));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AndroidJUnitRunner"><a href="#AndroidJUnitRunner" class="headerlink" title="AndroidJUnitRunner"></a>AndroidJUnitRunner</h2><p>当单元测试中涉及Android系统库的调用时，可以通过AndroidJUnitRunner方案完成测试，这样就能在测试类中使用Context、parcelable、Shareprefrence等类。使用方法是在androidTest目录下创建测试类（因为这涉及到Instrumented测试的内容），在该类上添加@RunWith(AndroidJUnit4.class)注解。如以下代码示范了如何在测试类中使用SharedPrefrences：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(AndroidJUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedPreferencesHelperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST_NAME = <span class="string">"Test name"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST_EMAIL = <span class="string">"test@email.com"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Calendar TEST_DATE_OF_BIRTH = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SharedPreferenceEntry mSharedPreferenceEntry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SharedPreferencesHelper mSharedPreferencesHelper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SharedPreferences mSharePreferences;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 上下文 */</span></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    ……</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取application的context</span></span><br><span class="line">        mContext = InstrumentationRegistry.getTargetContext();</span><br><span class="line">        <span class="comment">//实例化SharedPreferences</span></span><br><span class="line">        mSharePreferences = PreferenceManager.getDefaultSharedPreferences(mContext);</span><br><span class="line"></span><br><span class="line">        mSharedPreferenceEntry = <span class="keyword">new</span> SharedPreferenceEntry(TEST_NAME, TEST_DATE_OF_BIRTH, TEST_EMAIL);</span><br><span class="line">        <span class="comment">//实例化SharedPreferencesHelper，依赖注入SharePreferences</span></span><br><span class="line">        mSharedPreferencesHelper = <span class="keyword">new</span> SharedPreferencesHelper(mSharePreferences);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以下是在mock的相关操作，模拟commit失败</span></span><br><span class="line">        mMockSharePreferences = Mockito.mock(SharedPreferences.class);</span><br><span class="line">        mMockBrokenEditor = Mockito.mock(SharedPreferences.Editor.class);</span><br><span class="line">        when(mMockSharePreferences.edit()).thenReturn(mMockBrokenEditor);</span><br><span class="line">        when(mMockBrokenEditor.commit()).thenReturn(<span class="keyword">false</span>);</span><br><span class="line">        mMockSharedPreferencesHelper = <span class="keyword">new</span> SharedPreferencesHelper(mMockSharePreferences);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试保存数据是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sharedPreferencesHelper_SavePersonalInformation</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        assertThat(mSharedPreferencesHelper.savePersonalInfo(mSharedPreferenceEntry), is(<span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试保存数据，然后获取数据是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sharedPreferencesHelper_SaveAndReadPersonalInformation</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mSharedPreferencesHelper.savePersonalInfo(mSharedPreferenceEntry);</span><br><span class="line">        SharedPreferenceEntry sharedPreferenceEntry = mSharedPreferencesHelper.getPersonalInfo();</span><br><span class="line">        assertThat(isEquals(mSharedPreferenceEntry, sharedPreferenceEntry), is(<span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="模拟所需要的模块"><a href="#模拟所需要的模块" class="headerlink" title="模拟所需要的模块"></a>模拟所需要的模块</h2><p>有时我们测试需要依赖于其他的功能模块，但是某些原因这个功能模块不能在测试时运用或未开发完，为了不阻塞测试，我们可以Mock对象来完成测试。还有一些场景，诸如对象很难被创建、真实对象运行缓慢、真实对象的错误很难出现等，也可以通过Mock对象来测试。</p>
<h3 id="手动Mock对象"><a href="#手动Mock对象" class="headerlink" title="手动Mock对象"></a>手动Mock对象</h3><p>举个例子，开发一款记事本软件，登录成功后才能写/存笔记，小明小刘分别负责登录和写/存笔记功能，存笔记的时候时候需要用户信息User的实例，而用户信息在登录成功后才能获得。可行的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存数据的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoteDAO</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> NoteDAO noteDAO;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveNote</span><span class="params">(User user,String note)</span></span>&#123;</span><br><span class="line">		Log.d(<span class="string">"NoteDAO"</span>,<span class="string">"存储笔记"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoteTest</span></span>&#123;</span><br><span class="line">	<span class="meta">@Before</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">		noteDAO = <span class="keyword">new</span> NoteDAO();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSaveNote</span><span class="params">()</span></span>&#123;</span><br><span class="line">		MockLoginImpl loginImpl = <span class="keyword">new</span> MockLoginImpl();</span><br><span class="line">		noteDAO.saveNote(loginImpl.login(<span class="string">"dd"</span>,<span class="string">"pwd"</span>),<span class="string">"note_content"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mock类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockLoginImpl</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String name,String pwd)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> User(name,<span class="string">"1234556"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用第三方工具Mockito"><a href="#使用第三方工具Mockito" class="headerlink" title="使用第三方工具Mockito"></a>使用第三方工具Mockito</h3><p>前面有例子已经涉及到Mockito的部分使用，可以在网上搜索相关使用，这里不再详细展开，如果需要，后面会专门介绍。</p>
<h2 id="运行单元测试"><a href="#运行单元测试" class="headerlink" title="运行单元测试"></a>运行单元测试</h2><ul>
<li>在Android studio中，对指定的测试类点击鼠标右键，选择对应的Run或者debug</li>
<li>在Terminal输入gradle testDebugUnitTest或gradle testReleaseUnitTest指令来分别运行debug和release版本的unittesting，在执行的结果可以在xxx\project\app\build\reports\tests\testReleaseUnitTest中查看</li>
</ul>
<p>声明：整篇文章有部分内容摘抄自博客：<a href="https://www.jianshu.com/p/925191464389" target="_blank" rel="noopener">https://www.jianshu.com/p/925191464389</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/10/11/%E7%AC%AC%E4%B8%80%E5%AD%A3kotlin%E5%B4%9B%E8%B5%B7-%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="glassx的小黑屋,读书笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/11/%E7%AC%AC%E4%B8%80%E5%AD%A3kotlin%E5%B4%9B%E8%B5%B7-%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">第5章： 函数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-11 22:00:00" itemprop="dateCreated datePublished" datetime="2018-10-11T22:00:00+08:00">2018-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-01 16:43:24" itemprop="dateModified" datetime="2019-05-01T16:43:24+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第五章：函数"><a href="#第五章：函数" class="headerlink" title="第五章：函数"></a>第五章：函数</h1><h2 id="函数的定义和使用"><a href="#函数的定义和使用" class="headerlink" title="函数的定义和使用"></a>函数的定义和使用</h2><p>Kotlin中典型的函数如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板，Unit代表无须返回，花括号里不用写return语句</span></span><br><span class="line"><span class="function"><span class="title">fun</span> <span class="params">(x: <span class="type">Any</span>, y: <span class="type">Any</span>)</span></span>: <span class="built_in">Unit</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">suare</span><span class="params">(r: <span class="type">Double</span>)</span></span> : <span class="built_in">Double</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Math.PI * r * r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上函数整体只有一条语句，只有一条语句的函数可以省略返回类型、花括号以及return关键字。从而简化成单行表达式函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">suare</span><span class="params">(r: <span class="type">Double</span>)</span></span> = Math.PI * r * r</span><br></pre></td></tr></table></figure>

<p>如果有个函数，需要接受若干个参数，参数个数不确定，那该如何定义？只需要在参数前加一个<strong>vararg</strong>修饰符就行，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可变参数修饰符vararg</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(<span class="keyword">vararg</span> x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span>(i <span class="keyword">in</span> x)&#123;</span><br><span class="line">		total += i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一旦定义成可变参数，调用时可以给一个对应类型的数组，数组名前加一个星号(*)</span></span><br><span class="line"><span class="keyword">val</span> a = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">println(sum(*a))</span><br></pre></td></tr></table></figure>

<p>上面的代码中，加在变量名前的星号是<strong>“展开操作符(Spread operator)”</strong>，指的是把数组a全部展开，此处星号紧跟在变量名前，所以是一元操作符，而乘法的星号是二元操作符。</p>
<h2 id="函数的作用范围"><a href="#函数的作用范围" class="headerlink" title="函数的作用范围"></a>函数的作用范围</h2><p>Kotlin中函数根据作用范围可以分为： 成员函数、本地函数、顶层函数</p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>跟java中一样，略过介绍。</p>
<h3 id="本地函数-Local-function"><a href="#本地函数-Local-function" class="headerlink" title="本地函数(Local function)"></a>本地函数(Local function)</h3><p>Kotlin可以允许把小函数声明在其它函数内部，这些小函数被称为<strong>本地函数</strong>或者<strong>嵌套函数（Nested）</strong>。甚至可以多层嵌套。这样的好处是，一个大的函数可以分为很多小的函数，可以做到每一个函数只做一件事。用法如以下例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printArea</span><span class="params">(w: <span class="type">Int</span>,h: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">(w: <span class="type">Int</span>,h: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> w * h;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//也能写成这样： fun area() = w * h</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> area = area(w,h)</span><br><span class="line">	println(<span class="string">"面积=<span class="variable">$area</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，以上方法也能简化写成这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printArea</span><span class="params">(w: <span class="type">Int</span>,h: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">(w: <span class="type">Int</span>,h: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> w * h;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//也能写成这样： fun area() = w * h</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> area = area(w,h)</span><br><span class="line">	println(<span class="string">"面积=<span class="variable">$area</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是看到的本地函数 area() 在 printArea()方法外部就无效了，它只服务于printArea()方法。这在实现一个大函数时隐藏实现的细节是非常有用的，虽然Kotlin中使用private声明也能达到同样的隐藏效果，但是本地函数还能直接访问主函数中的变量，减少变量传递，减少代码，如上面的例子还可以简化为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printArea</span><span class="params">(w: <span class="type">Int</span>,h: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span> = w * h</span><br><span class="line"></span><br><span class="line">	<span class="keyword">val</span> area = area()</span><br><span class="line">	print(<span class="string">"面积=<span class="variable">$area</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来一个例子，说明使用本地结合本地函数一步步精简代码（代码越少，出bug的几率就越低，这也是Kotlin奉行的准则）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般写法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkNumber</span><span class="params">(start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(number <span class="keyword">in</span> start..end)&#123;</span><br><span class="line">		<span class="keyword">if</span>(number % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			println(<span class="string">"<span class="variable">$number</span>被3整除"</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(number % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			println(<span class="string">"<span class="variable">$number</span>被5整除"</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(number % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; number % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			println(<span class="string">"<span class="variable">$number</span>既能被3整除，也能被5整除"</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			println(number)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的代码首先的问题是，“被3整除”这段代码重复了1次，这就意味着双倍bug的可能性（当然，例子太简单了，基本上不会出错）。现在声明本地函数，以便消除重复：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkNumber</span><span class="params">(start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">isThrees</span><span class="params">(x: <span class="type">Int</span>)</span></span> = (x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">isFives</span><span class="params">(x: <span class="type">Int</span>)</span></span> = (x % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(number <span class="keyword">in</span> start..end)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isThrees(number))&#123;</span><br><span class="line">			println(<span class="string">"<span class="variable">$number</span>被3整除"</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(isFives(number))&#123;</span><br><span class="line">			println(<span class="string">"<span class="variable">$number</span>被5整除"</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(isThrees(number) &amp;&amp; isFives(number))&#123;</span><br><span class="line">			println(<span class="string">"<span class="variable">$number</span>既能被3整除，也能被5整除"</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			println(number)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断条件都换成本地函数了，出错的概率降低了，但是貌似重复 <strong>传递number值</strong> 多次，能不能再精简？肯定如此，把本地函数放在for循环中，代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkNumber</span><span class="params">(start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(number <span class="keyword">in</span> start..end)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">fun</span> <span class="title">isThrees</span><span class="params">()</span></span> = (number % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">		<span class="function"><span class="keyword">fun</span> <span class="title">isFives</span><span class="params">()</span></span> = (number % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(isThrees())&#123;</span><br><span class="line">			println(<span class="string">"<span class="variable">$number</span>被3整除"</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(isFives())&#123;</span><br><span class="line">			println(<span class="string">"<span class="variable">$number</span>被5整除"</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(isThrees() &amp;&amp; isFives())&#123;</span><br><span class="line">			println(<span class="string">"<span class="variable">$number</span>既能被3整除，也能被5整除"</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			println(number)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是怎么还有如此多的if-else，还能精简么，当然，代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkNumber</span><span class="params">(start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(number <span class="keyword">in</span> start..end)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">fun</span> <span class="title">isThrees</span><span class="params">()</span></span> = (number % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">		<span class="function"><span class="keyword">fun</span> <span class="title">isFives</span><span class="params">()</span></span> = (number % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">when</span>&#123;</span><br><span class="line">			isThrees() -&gt; println(<span class="string">"<span class="variable">$number</span>被3整除"</span>)</span><br><span class="line">			isFives() -&gt; println(<span class="string">"<span class="variable">$number</span>被5整除"</span>)</span><br><span class="line">			isThrees() &amp;&amp; isFives() -&gt; println(<span class="string">"<span class="variable">$number</span>既能被3整除，也能被5整除"</span>)</span><br><span class="line">			<span class="keyword">else</span> -&gt; println(number)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顶层函数（Top-level-function）"><a href="#顶层函数（Top-level-function）" class="headerlink" title="顶层函数（Top-level function）"></a>顶层函数（Top-level function）</h3><p>书本上语焉不详，没咋看懂，后续专门了解</p>
<h2 id="命名参数和默认参数"><a href="#命名参数和默认参数" class="headerlink" title="命名参数和默认参数"></a>命名参数和默认参数</h2><h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>有如下函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> book = <span class="string">"基于kotlin的Android"</span></span><br><span class="line">printlin(book.regionMatches(<span class="number">9</span>,<span class="string">"深入Android"</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="literal">true</span>))</span><br></pre></td></tr></table></figure>

<p>这个函数参数非常多，初看很难理解各个参数的作用，很不直观。但是使用命名参数就可以很直观，调用时把参数名写出来：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">book.regionMatches(thisOffset = <span class="number">9</span>,</span><br><span class="line">             other = <span class="string">"深入Android"</span>,</span><br><span class="line">             length = <span class="number">2</span>,</span><br><span class="line">             otherOffset = <span class="number">7</span>,</span><br><span class="line">             ignoreCase = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>这种调用可读性就强太多了，虽然稍显啰嗦，不过这点代价是值得的。使用这种写法的时候，kotlin并不强制要求写出所有参数的命名参数，比如以下示例代码（但是有个不成文的规定，如果写了命名参数，就全部写上）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delFiles(<span class="string">"*.apk"</span>,ignoreCase = <span class="literal">true</span>,includeDirs = <span class="literal">false</span>,recursive = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>命名参数的另一个好处是可以更换参数的调用位置，如以下两种调用是等价的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">book.endsWith(suffix = <span class="string">"1"</span>,ignoreCase = <span class="literal">true</span>)</span><br><span class="line">book.endsWith(ignoreCase = <span class="literal">true</span>,suffix = <span class="string">"1"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注：命名参数仅适用于kotlin定义的函数，并不适用java定义的函数，因为java代码编译成字节码时并不总是保存参数名称</strong></p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>有时候需要给函数的某些参数提供默认值，当用户没有给这个参数值的时候，函数使用默认值，如String的endWith函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">book.endsWith(suffix = &quot;1&quot;,ignoreCase = false)</span><br><span class="line">book.endsWith(suffix = &quot;1&quot;)</span><br></pre></td></tr></table></figure>

<p>如果需要严格的后缀匹配，可以忽略掉ignoreCase参数的调用，因为ignoreCase的默认值是false。kotlin中可以定义一个或者多个默认参数，在被调用时如果不指定，则使用默认值。比如，可以将默认参数用到构造函数中，从而避免产生更多的二次构造函数(当然，使用在普通函数上的效果也一样)：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> isVip: <span class="built_in">Boolean</span>,credits: <span class="built_in">Int</span>)&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(name: String) : <span class="keyword">this</span>(name,<span class="literal">false</span>,<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">constructor</span>(name: String,isVip: <span class="built_in">Boolean</span>) : <span class="keyword">this</span>(name,isVip,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认参数写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> isVip: <span class="built_in">Boolean</span> = <span class="literal">false</span>, credits: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="函数操作符"><a href="#函数操作符" class="headerlink" title="函数操作符"></a>函数操作符</h2><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>使用操作符定义函数的能力称为操作符重载，kotlin让操作重载以一个可控的方式使用，有一组固定的操作符名单可以用作函数，但禁止组合使用，要创建这样一个函数，必须冠以<strong>operator</strong>关键字且必须有对应的英文单词做函数名。<strong>注意：操作符仅可定义为成员函数或者扩展函数</strong>，以矩阵相加的例子来说明：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span></span>(<span class="keyword">val</span> a: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Int</span>, <span class="keyword">val</span> c: <span class="built_in">Int</span>, <span class="keyword">val</span> d: <span class="built_in">Int</span>)&#123;</span><br><span class="line">	<span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(m: <span class="type">Matrix</span>)</span></span>: Matrix &#123;</span><br><span class="line">	    <span class="keyword">return</span> Matrix(a + m.a,b+m.b,c+m.c,d+m.d)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">val</span> m = Matrix(<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>)</span><br><span class="line"><span class="keyword">val</span> n = Matrix(<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>)</span><br><span class="line"><span class="keyword">val</span> mn = m.plus(n)</span><br></pre></td></tr></table></figure>

<p>操作符函数不限于相同的类，如我们定义一个Array类可以用”+”添加元素或者用”-“移除元素。<strong>这一节看得云里雾里，一知半解，应该不止这么简单的使用，需要另外查资料</strong>。</p>
<p><strong>这书看不下去了，不建议大家看了，接下来会直接看<a href="http://www.broadview.com.cn/book/4877" target="_blank" rel="noopener">《Kotlin实战》</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/07/27/%E7%AC%AC%E4%B8%80%E5%AD%A3kotlin%E5%B4%9B%E8%B5%B7-%E7%AC%AC3%E3%80%814%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="glassx的小黑屋,读书笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/27/%E7%AC%AC%E4%B8%80%E5%AD%A3kotlin%E5%B4%9B%E8%B5%B7-%E7%AC%AC3%E3%80%814%E7%AB%A0/" class="post-title-link" itemprop="url">第3、4章： 控制流和字符串</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-27 08:00:00" itemprop="dateCreated datePublished" datetime="2018-07-27T08:00:00+08:00">2018-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-01 16:43:16" itemprop="dateModified" datetime="2019-05-01T16:43:16+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第三章：控制流"><a href="#第三章：控制流" class="headerlink" title="第三章：控制流"></a>第三章：控制流</h1><h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><p>Kotlin中if-else可以做表达式的特性，甚至可以实现一个类型不定的变量(虽然官方不建议这么做)：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = <span class="keyword">if</span>(a &gt; b) <span class="string">"大于"</span> <span class="keyword">else</span> b - a</span><br></pre></td></tr></table></figure>

<h2 id="多元判断"><a href="#多元判断" class="headerlink" title="多元判断"></a>多元判断</h2><p>针对某个值可能的多种状况，可以使用when语句做一个比较细致的判断：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span>(result)&#123;</span><br><span class="line">	<span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> -&gt; &#123;</span><br><span class="line">		printlin(<span class="string">"在1到5之间"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">in</span> <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span> -&gt; &#123;</span><br><span class="line">		printlin(<span class="string">"是1或者3或者5"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	(<span class="number">9</span> - <span class="number">6</span>) -&gt; &#123;</span><br><span class="line">		printlin(<span class="string">"值是3"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">is</span> <span class="built_in">Int</span> -&gt; &#123;<span class="comment">//is用于判断是某种类型</span></span><br><span class="line">		printlin(<span class="string">"是整数"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">		printlin(<span class="string">"其他情况"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章——字符串和字符"><a href="#第四章——字符串和字符" class="headerlink" title="第四章——字符串和字符"></a>第四章——字符串和字符</h1><p> Kotlin中字符串和字符相关的方法非常丰富，字符串可以通过“+”连接，也可以往字符串中插入变量创建字符串“模板”。字符串还有常用的2个功能，判断字符串为空(isEmpty())和字符串中字符的数目(count()或者length)，字符串的一些例子如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">println(name.count())<span class="comment">//字符串中字符数目</span></span><br><span class="line">println(name.isEmpty())<span class="comment">//是否为空</span></span><br><span class="line">println(name.length)<span class="comment">//这个length不是方法，而是“成员”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下方法可以获取指定位置的字符</span></span><br><span class="line">println(name.<span class="keyword">get</span>(<span class="number">3</span>))</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">println(name[<span class="number">3</span>])</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">println(name.elementAt(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取头或者尾</span></span><br><span class="line">println(name.first())<span class="comment">//获取第一个字符</span></span><br><span class="line">println(name.last())<span class="comment">//获取最后一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//还有subString用法</span></span><br><span class="line">println(name.substring(<span class="number">3</span>))<span class="comment">//要注意，这是去掉字符串前面4个字符</span></span><br><span class="line"><span class="comment">//取字符串中间某一段</span></span><br><span class="line">println(name.substring(<span class="number">5</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//索引加substring使用</span></span><br><span class="line">println(name.substring(name.indexOf(<span class="string">"好"</span>))) <span class="comment">//去掉“好”字之前的字符</span></span><br><span class="line"><span class="comment">//截取 “好”以及其后面一个字符</span></span><br><span class="line">println(name.substring(name.indexOf(<span class="string">"好"</span>),<span class="number">2</span>))</span><br><span class="line"><span class="comment">//最后一个索引</span></span><br><span class="line">println(name.lastIndex(<span class="string">"好"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//indices显示索引范围</span></span><br><span class="line">println(name.indices)  <span class="comment">//获得索引区间，这是个属性，不用给任何参数，结果打印：  0..6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否包含某个字符或者子串</span></span><br><span class="line">println(name.contains(<span class="string">"google"</span>))  <span class="comment">//返回true或者false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符串内容是否相同，以下两种写法都可以</span></span><br><span class="line">println(name1 == name2)</span><br><span class="line">println(name1.contentEquals(name2))</span><br></pre></td></tr></table></figure>

<p>上述代码中，两个方法是带括号”()”的，而length不带括号。带括号的称为方法或者函数；不带括号的称为属性成员，是变量。关于字符串操作，还有专业的“舍弃”系列，一般以drop开头，用它去掉字符串中的子串，有时候比substring更方便，不用跟索引打交道，看看例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//舍弃前3个字符</span></span><br><span class="line">println(name.drop(<span class="number">3</span>))  </span><br><span class="line"><span class="comment">//舍弃后3个字符</span></span><br><span class="line">println(name.dropLast(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//有条件的舍弃，去掉字符串开头的空格，中间的不会被去掉</span></span><br><span class="line"><span class="keyword">val</span> name = <span class="string">"  我前面有空格 哈哈"</span></span><br><span class="line">println(name.dropWhile &#123;it.isWhitespace()&#125;)  <span class="comment">//结果：我前面有空格 哈哈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当然，还能接连操作</span></span><br><span class="line">println(title.dropWhile &#123;it.isWhitespace()&#125;.</span><br><span class="line">	dropLastWhile &#123;it = <span class="string">'哈'</span> || it.isWhitespace()&#125; <span class="comment">// 结果：我前面有空格</span></span><br></pre></td></tr></table></figure>

<p>上述看到，舍弃操作可以无限连接，因为drop系列完成后还是一个string，其中dropWhile 后面的 “{}” 里面的代码是判断条件，<strong>it是系统提供的变量，指的是字符串中单个的字符，”{}”本身做了一个循环，检查字符串中的每一个字符</strong>。”||”还是与Java中一样，是或操作。跟丢弃系列相对的是<strong>捡取系列</strong>，以take开头：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取前6个</span></span><br><span class="line">println(name.take(<span class="number">6</span>))</span><br><span class="line"><span class="comment">//取后7个</span></span><br><span class="line">println(name.takeLast(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺带提一下替换功能，跟Java一样</span></span><br><span class="line">println(name.replace(<span class="string">"哈哈"</span>,<span class="string">"嘎嘎"</span>))</span><br><span class="line"><span class="comment">//这里要注意下，单个字符用单引号包含</span></span><br><span class="line">println(name.replace(<span class="string">'哈'</span>,<span class="string">'嘎'</span><span class="string">'))</span></span><br></pre></td></tr></table></figure>

<p><strong>转义字符</strong>处理：Java中会对字符串中的“控制字符”进行特殊处理，这才有了转义字符，如 println(“\n\r\&quot;&#39;“) 只会打印出 &quot;‘ ，这样写起来比较麻烦，当然Kotlin保留了这个功能，并且创新地使用三个引号来解决这个问题：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name = <span class="string">"""\"'"""</span></span><br><span class="line">println(name)   <span class="comment">//会打印：\"'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顺便记下这种用法，为每个字符之间插入一个逗号</span></span><br><span class="line">name.toCharArray().forEach &#123;println(it + <span class="string">"，"</span>)&#125;  <span class="comment">//又用到 it</span></span><br></pre></td></tr></table></figure>

<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>字符可以判断是否是数字或者文字：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">println(five.isDigit())</span><br><span class="line">println(five.isLetter())</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符的上一个/下一个字符</span></span><br><span class="line">println(five - <span class="number">1</span>)</span><br><span class="line">println(five + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//转成编码</span></span><br><span class="line">println(five.toInt())</span><br><span class="line"></span><br><span class="line"><span class="comment">//“我”到“你”之间有多远</span></span><br><span class="line">println(<span class="string">'我'</span>.until(<span class="string">'你'</span>))  <span class="comment">//打印结果： 我..佟  ，即说明 '你'之前的那个字是 '佟'</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/07/22/%E7%AC%AC%E4%B8%80%E5%AD%A3kotlin%E5%B4%9B%E8%B5%B7-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="glassx的小黑屋,读书笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/22/%E7%AC%AC%E4%B8%80%E5%AD%A3kotlin%E5%B4%9B%E8%B5%B7-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第2章： kotlin基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-22 12:00:00" itemprop="dateCreated datePublished" datetime="2018-07-22T12:00:00+08:00">2018-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-01 16:39:23" itemprop="dateModified" datetime="2019-05-01T16:39:23+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Kotlin跟Java还是有很大区别的，看这一章的时候，时不时会带来惊喜： 还能有这操作 ？？？</p>
<h2 id="常量与变量写法（常量一旦赋值，就不能改变，不能二次赋值）："><a href="#常量与变量写法（常量一旦赋值，就不能改变，不能二次赋值）：" class="headerlink" title="常量与变量写法（常量一旦赋值，就不能改变，不能二次赋值）："></a>常量与变量写法（常量一旦赋值，就不能改变，不能二次赋值）：</h2><blockquote>
<p>常量： val constant = 123;   变量： var a = 3;</p>
</blockquote>
<h2 id="整数类型和推断类型"><a href="#整数类型和推断类型" class="headerlink" title="整数类型和推断类型"></a>整数类型和推断类型</h2><p>定义一个整数型变量的形式(注意是 Int ，首字母是大写的)：</p>
<blockquote>
<p>var num: Int = 3;</p>
</blockquote>
<p>但是Kotlin有优秀的推断系统，”:Int”可以省去不写，编译器就“知道”这是整数类型，这与C/C++/JAVA/C#等强制标明变量类型非常不同。这也是现代编程语言的一大进步，Swift等语言都吸收了这个优点，从而让语言本身变得非常简洁。定义其他类型的数字例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> 整数 = <span class="number">1237</span></span><br><span class="line"><span class="keyword">val</span> 长整数 = <span class="number">12666L</span></span><br><span class="line"><span class="keyword">val</span> 双精度浮点数 = <span class="number">22.64</span></span><br><span class="line"><span class="keyword">val</span> 单精度浮点数 = <span class="number">12.34F</span></span><br><span class="line"><span class="keyword">val</span> 八进制数 = <span class="number">0xACF</span></span><br><span class="line"><span class="keyword">val</span> 二进制数 = <span class="number">0b01010111</span></span><br></pre></td></tr></table></figure>

<p>注意长整数数字后有后缀L，单精度小数后缀是F，如果不写，默认整数类型是Int，小数类型是Double，八进制和二进制数字分别以前缀 0x和0b开头。</p>
<p><strong>字符串模板：</strong>就是指把一个变量插入到文本的技术，一般类似这样： “${}”，”${}”是一个变量的占位符，一个例子如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> run = <span class="number">5</span></span><br><span class="line">	run = <span class="number">6</span></span><br><span class="line">	print(<span class="string">"每天坚持跑<span class="subst">$&#123;run&#125;</span>公里"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Tips：如果整数位数太多，可以用下划线分割出千分位或者万分位，如： var 房贷 = 150_0000  //与 var 房贷 = 1500000等价</strong>。</p>
<p>Kotlin不支持自动扩展数字范围，转换必须手动进行，每一种数字都有一个转换成其他数字类型的函数，例如，把普通整数转换成长整数，可以用如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intNum = <span class="number">9999</span></span><br><span class="line"><span class="keyword">val</span> longNum = intNum.toLong();</span><br><span class="line"><span class="keyword">val</span> doubleNum = intNum.toDouble();</span><br></pre></td></tr></table></figure>

<p>上面提到了二进制数字，相关的位运算操作在Kotlin中也是支持的，例如左移右移、逻辑与/或运算、异或 和 取反运算，与Java不同的是，这些不是内建运算符，而是用中缀函数来代替的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> 左移二位 = <span class="number">1</span> shl <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> 右移三位 = <span class="number">1</span> shr <span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> 无符号右移二位 = <span class="number">1</span> ushr <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> 逻辑与 = <span class="number">1</span> and <span class="number">0x00001111</span></span><br><span class="line"><span class="keyword">val</span> 逻辑或 = <span class="number">1</span> or <span class="number">0x00001111</span></span><br><span class="line"><span class="keyword">val</span> 异或 = <span class="number">1</span> xor <span class="number">0x00001111</span></span><br><span class="line"><span class="keyword">val</span> 取反 = <span class="number">1</span>.inv()</span><br></pre></td></tr></table></figure>

<p>注意，取反不是中缀操作符，而是一个一元操作符。</p>
<h2 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h2><p>Kotlin中小数现在默认也是Double类型（双精度），而原先的Float类型处于兼容目的而保留，但官方不建议使用。<strong>可以用Double类型的toInt将小数截成整数，注意不是四舍五入，而是把小数部分完全砍掉，如 3.14进行toInt()的结果是 3</strong>。</p>
<h2 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h2><p>类型安全是指，变量一旦定义，其类型不可更改。了解C/Java语言的可能非常不适应，因为这些语言要求把类型写出来，而没有类型推断这个概念。JavaScript语言也是不写类型的，这是为了求快，语法并不严谨，而且它不但类型不用写，并且变量的类型可以任意改变，这留下了安全隐患（微软的TypeScript就是一种安全的JavaScript改进）。这个缺陷在Kotlin和Swift中得到了平衡，这两种语言同时引入了类型推断和类型安全的概念。如以下代码Kotlin会提示错误：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 电费 = <span class="number">3.6</span></span><br><span class="line">电费 = <span class="string">"五毛"</span></span><br></pre></td></tr></table></figure>

<h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>布尔型：Boolean。Kolin中布尔型只有2个值：true 和 false。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isVip = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isVip)&#123;</span><br><span class="line">	print(<span class="string">"欢迎vip会员！"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	print(<span class="string">"请考虑充值成为vip！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>通常情况下，变量只带一个值，但有时候为了处理更精致简单，必须把描述进行分割。例如，课程 《3天免费学会Kotlin》，这个标题可以分解成学时、动作、技术名、学费等，这时候元祖就可以派上用场了。<strong>元组(Tuple)，可以把多个值同时赋值给一个变量，或者叫给多个变量同时赋值。</strong>不过Kotlin中只有二元组(Pair)和三元组(Triple)，也就是最多一次容纳3个值。直接看个例子比较直观：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> 课程 = Triple(<span class="number">3</span>,<span class="string">"学会"</span>,<span class="string">"Kotlin"</span>)</span><br><span class="line"><span class="keyword">val</span> 费用 = Pair(<span class="string">"学费"</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"<span class="subst">$&#123;课程.first&#125;</span>天<span class="subst">$&#123;课程.second&#125;</span><span class="subst">$&#123;课程.third&#125;</span>"</span>)</span><br><span class="line">print(<span class="string">",<span class="subst">$&#123;费用.first&#125;</span><span class="subst">$&#123;费用.second&#125;</span>元！"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果是：3天学会Kotlin，学费0元！   </p>
<h2 id="可空类型——nullable"><a href="#可空类型——nullable" class="headerlink" title="可空类型——nullable"></a>可空类型——nullable</h2><p>所有“实体的”类型与空的组合，称为可空类型，写法上是在原类型名后紧跟一个问号:Int?、String?、Boolean?，这里”?”指空值null，表示什么也没有。用法示例如下（以个人资料为例）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addr: String? = <span class="string">"清华大学"</span></span><br><span class="line"><span class="keyword">var</span> sex: <span class="built_in">Boolean</span>?</span><br></pre></td></tr></table></figure>
<p>假设这是某人的淘宝账号个人资料一部分，addr是选填地址信息，虽然地址可以不填，但买东西的时候要填写；虽然性别sex是二选一的，但是对于业务不重要，所以也可以写成可空类型。定义好之后，使用场景可以用如下代码表示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sex = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span>(sex != <span class="literal">null</span> &amp;&amp; sex == <span class="literal">true</span>)&#123;<span class="comment">//还需要先判空</span></span><br><span class="line">	print(<span class="string">"先生，你好"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	print(<span class="string">"美女，全场八折"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有，如果导入多个不同包的同名类，可以给某些导入起一个别名，如下所示：</p>
<blockquote>
<p>import com.test.MyKotlinProject.Book<br>import com.myspace.Book as SpaceBook</p>
</blockquote>
<h2 id="异常处理和类初始化"><a href="#异常处理和类初始化" class="headerlink" title="异常处理和类初始化"></a>异常处理和类初始化</h2><p>Kotlin中异常处理与Java几乎一模一样，只有一条不同，即<strong>Kotlin中所有异常都不是必检的。</strong>所谓必检异常，是指必须定义成方法的一部分或者在方法内部处理，一个典型例子就是IOException。Kotlin中，因为所有异常都不是必检的，所以异常不必成为函数的组成部分。如果要捕捉异常，跟java一样，使用try-catch：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> byte = input.read();</span><br><span class="line">&#125;<span class="keyword">catch</span>(e: IOException)&#123;</span><br><span class="line">	println(<span class="string">"读取文件错误，因为：<span class="subst">$&#123;e.message&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于类初始化，Java语言一般会用一个new关键字来创建类的实例，Kotlin中移除了new，对待构造函数的调用和普通函数一样，这样就不需要new了，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> file = File(<span class="string">"/usr/bin/ruby"</span>)</span><br><span class="line"><span class="keyword">val</span> date = Date(<span class="number">20170702</span>)</span><br></pre></td></tr></table></figure>

<h2 id="引用相等和结构相等"><a href="#引用相等和结构相等" class="headerlink" title="引用相等和结构相等"></a>引用相等和结构相等</h2><p>要检查两个引用是否引用相等，用<strong>“===”(类似Java的 ==)</strong>，或者用<strong>“!==”</strong>来说明不等，用”==”来检查是否结构相等（类似于java中的equals方法）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> file1 = File(<span class="string">"/usr/bin/ruby"</span>)</span><br><span class="line"><span class="keyword">val</span> file2 = File(<span class="string">"/usr/bin/ruby"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sameRef = (file1 === file2)</span><br><span class="line">println(sameRef)<span class="comment">//打印false，因为 file1 与 file2 不是同一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sameStruct = (file1 == file2)</span><br><span class="line">println(sameRef) <span class="comment">//打印true，因为两个File对象的指定的文件路径是一样的</span></span><br></pre></td></tr></table></figure>

<h2 id="区间（Range）"><a href="#区间（Range）" class="headerlink" title="区间（Range）"></a>区间（Range）</h2><p>一个区间是有一个起始值和终止值得间隔。任意可以进行比较大小的类型都可以创建一个区间，使用”..”操作符，这里的区间是数学意义上的全闭区间，包括起始和终止边界的值。以下是例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a到z = <span class="string">"a"</span>..<span class="string">"z"</span></span><br><span class="line"><span class="keyword">val</span> 一到一百 = <span class="number">1</span>..<span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>一旦建好，就可以用in操作来测试指定的一个值是否包含在其中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> chars = <span class="string">"a"</span>..<span class="string">"z"</span></span><br><span class="line"><span class="keyword">val</span> d在其中 = <span class="string">"d"</span> <span class="keyword">in</span> chars</span><br></pre></td></tr></table></figure>

<p>围绕着区间还有更深入的函数可以用，如downTo()可以创建一个倒序排列的区间，rangeTo可以生成区间：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> 倒计时 = <span class="number">10</span>.downTo(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">val</span> 一到一百 = <span class="number">1</span>.rangeTo(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>区间创建后可以更改，更改后的区间生成一个新区间，还可以用reversed()函数进行翻转。还可以更改区间中的每一个单向前进的幅度，即步进（step）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> 一到一百 = <span class="number">1</span>.rangeTo(<span class="number">100</span>)</span><br><span class="line"><span class="comment">//一到一百.reversed()  如果添加这句代码，那么就是打印 99,98...1</span></span><br><span class="line"><span class="keyword">val</span> 一到一百奇数 = 一到一百.step(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> 一到一百奇数)&#123;</span><br><span class="line">	print(i)   <span class="comment">//会打印 1,3,5,7，...99</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="控制流作为表达式"><a href="#控制流作为表达式" class="headerlink" title="控制流作为表达式"></a>控制流作为表达式</h2><p>令常规编程语言程序员大跌眼镜的是，Kotlin中控制流语句可以做表达式，一般的语言 if-else 、try-catch等控制流表达式不会返回任何值，如java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">	isZero = <span class="keyword">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	isZero = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在Kotlin中，if-else 与try-catch 控制流本身就是表达式。这种变化可以可以省了很多重复的代码模板，省了一些变量的声明，来看看例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> isLarger = <span class="keyword">if</span>(a &gt; b) <span class="literal">true</span> <span class="keyword">else</span> <span class="literal">false</span>  <span class="comment">//用if语句做表达式的时候，必须包含else语句，否则编译器无从得知if为else的情况</span></span><br><span class="line">print(isLarger)  <span class="comment">//打印true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> readSuccess = <span class="keyword">try</span>&#123;</span><br><span class="line">	readFile(/usr/bin/ruby.md)</span><br><span class="line">	<span class="literal">true</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(e: IOException)&#123;</span><br><span class="line">	<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">print(readSuccess)   <span class="comment">//代码try中代码执行顺利打印true，</span></span><br></pre></td></tr></table></figure>

<p>Kotlin中的 <strong>when</strong>语句是Java中的switch语句的强力升级版：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span>(a)&#123;</span><br><span class="line">	<span class="number">0</span> -&gt; println(<span class="string">"a是0"</span>)</span><br><span class="line">	<span class="number">1</span> -&gt; println(<span class="string">"a是1"</span>)</span><br><span class="line">	<span class="keyword">else</span> -&gt; println(<span class="string">"a不是0或1"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>when 的最后一个分支else是所有其他情况外的处理，这样可以把a的所有情况进行列举处理。当然，when语句也是可以作为值赋予给变量的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isZero = <span class="keyword">when</span>(a)&#123;</span><br><span class="line">	<span class="number">0</span> -&gt; <span class="literal">true</span></span><br><span class="line">	<span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更进一步的用法，常量可以合并在同一条分支上：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isZeroOrOne = <span class="keyword">when</span>(a)&#123;</span><br><span class="line">	<span class="number">0</span>,<span class="number">1</span> -&gt; <span class="literal">true</span>   <span class="comment">//0 或者1 都返回true</span></span><br><span class="line">	<span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与switch不同的是，when不限于对常量的每一种情况判断，还可以加上函数，当函数被调用后满足分支条件，这个分支就被执行了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isPositive</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">when</span>(x)&#123;</span><br><span class="line">		Math.abs(x) -&gt; <span class="literal">true</span> </span><br><span class="line">		<span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(isPositive(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>Math.abs是数学库中的绝对值函数，这个方法用来判断一个数字是否是正数，如果输入的值与绝对值之后的值相等，说明是正数，返回true，否则返回false。当然，这段代码还可以简化：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isPositive</span><span class="params">(x: <span class="type">Int</span>)</span></span> = <span class="comment">//这里加个等号就没有返回值类型了</span></span><br><span class="line">	<span class="keyword">when</span>(x)&#123;</span><br><span class="line">		Math.abs(x) -&gt; <span class="literal">true</span> </span><br><span class="line">		<span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">println(isPositive(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>当然，这也适用于区间：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cardNum</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">when</span>(x)&#123;</span><br><span class="line">		<span class="keyword">in</span> -<span class="number">9</span>..<span class="number">9</span> -&gt; <span class="literal">true</span> </span><br><span class="line">		<span class="comment">//in arrayOf(1,2,3,4,5,6) -&gt; true  //或者这样</span></span><br><span class="line">		<span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(cardNum(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>最后，when还可以用智能转换类型，智能转换可以让编译器在运行时校验变量类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">preIsKotlin</span><span class="params">(any:<span class="type">Any</span>)</span></span>: <span class="built_in">Boolean</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">when</span>(any)&#123;</span><br><span class="line">		<span class="keyword">is</span> String -&gt; any.startWith(<span class="string">"Kotlin"</span>)</span><br><span class="line">		<span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的函数参数是Any类型，所有对其类型实际是无任何限制的，这样类型只能在运行时检测，如果遇到输入的是String类型（is String，is的用法感觉有点像Java中的 instanceOf ），则判断String是否以Kotlin开头，如果是就返回true，不满足以上条件的都返回false。</p>
<ul>
<li>无参数的when语句，类似多分支的if-else</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">noParamWhen</span><span class="params">(a: <span class="type">Int</span>,b: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">when</span>&#123;</span><br><span class="line">		a &lt; b -&gt; println(<span class="string">"a 小于b"</span>)</span><br><span class="line">		a &gt; b -&gt; println(<span class="string">"a 大于b"</span>)</span><br><span class="line">		<span class="keyword">else</span> -&gt; println(<span class="string">"a 等于b"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h2><p>Kotlin的函数返回前面已经演示过：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addNum</span><span class="params">(a: <span class="type">Int</span>,b: <span class="type">Int</span>)</span></span>: <span class="built_in">Double</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，return会从最近的嵌套函数或者匿名函数返回，所以，如果在一个嵌套函数内，return只会返回最内层的函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxNum</span><span class="params">(a: <span class="type">Int</span>,b: <span class="type">Int</span>,c: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">maxNum</span><span class="params">(a: <span class="type">Int</span>,b :<span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxNum(maxNum(a,b),maxNum(b,c))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个优点强行重名刻意为之的例子里，最后一个return调用的是最近的maxNumber()嵌套函数，如果最内层的函数是一个匿名函数，return在其中只会退出匿名函数而已：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lessThanNine</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">val</span> list = listOf(-<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">99</span>)</span><br><span class="line">	list.forEach(<span class="function"><span class="title">fun</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x &lt; <span class="number">9</span>) println(x)</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	println(<span class="string">"此行会继续执行"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型层级"><a href="#类型层级" class="headerlink" title="类型层级"></a>类型层级</h2><p>Kotlin中最上层的类型是Any，意为任意类型，是所有类型的父类，这与Java的Object类型相似。Any类型定义了众所周知的toString 、hashCode以及equals方法。Unit类型相当于Java中的void，但是二者间有微妙的区别，void不是一个类型，而是一个特殊的个例，Unit是一个合适的类型，如此一来，Kotlin中所有的函数都可以定义一个返回值了（至少是个Unit型）。<br>另一个显著区别于Java的地方是增加了一个最底层的类型——Nothing，它是所有类型的子类，后面可以详细了解这玩意儿。</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>Kotlin支持while和for循环。while循环和C语言一模一样。for循环用于迭代任何一个预定义或者扩展了iterator的函数。所有集合类型都提供了这个函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listOne = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)  <span class="comment">//链表</span></span><br><span class="line"><span class="keyword">val</span> setOne = setOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)   <span class="comment">//集合</span></span><br><span class="line"><span class="keyword">val</span> arrayOne = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)   <span class="comment">//数组</span></span><br><span class="line"><span class="keyword">val</span> oneToTen = <span class="number">1</span>..<span class="number">10</span>;<span class="comment">//区间</span></span><br><span class="line"><span class="keyword">val</span> slogan = <span class="string">"我爱Kotlin"</span> <span class="comment">//字符串，String中已经实现了iterator扩展函数，所以for循环可以迭代其中的单个字符</span></span><br><span class="line"><span class="keyword">for</span>(k <span class="keyword">in</span> listOne)&#123;</span><br><span class="line">	println(k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k <span class="keyword">in</span> setOne)&#123;</span><br><span class="line">	println(k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k <span class="keyword">in</span> arrayOne)&#123;</span><br><span class="line">	println(k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k <span class="keyword">in</span> oneToTen)&#123;</span><br><span class="line">	println(k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(char <span class="keyword">in</span> slogan)&#123;</span><br><span class="line">	println(char)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意循环中in操作符，经常用于for循环中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/07/15/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="glassx的小黑屋,读书笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/15/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/" class="post-title-link" itemprop="url">第13章： 继续进阶——你还应该掌握的高级技巧</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-15 18:00:00" itemprop="dateCreated datePublished" datetime="2018-07-15T18:00:00+08:00">2018-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-01 16:44:39" itemprop="dateModified" datetime="2019-05-01T16:44:39+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="全局获取Context技巧"><a href="#全局获取Context技巧" class="headerlink" title="全局获取Context技巧"></a>全局获取Context技巧</h2><p>主要就是自定义 Application ，在 Application 中实现全局获取Context，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Context mContext;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		mContext = getApplicationContext();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mContext;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="使用Intent传递对象"><a href="#使用Intent传递对象" class="headerlink" title="使用Intent传递对象"></a>使用Intent传递对象</h2><p>Intent的putExtra()方法传递数据的时候，支持的数据类型是有限的，虽然常用的一些数据类型它都支持，但是当你想传递一些自定义对象的时候，就会无从下手。其实使用Intent来传递对象通常有两种实现方式：Serializable和Parcelable。</p>
<h3 id="Serializable-方式"><a href="#Serializable-方式" class="headerlink" title="Serializable 方式"></a>Serializable 方式</h3><p>Serializable是序列化的意思，表示将一个对象转换成可存储或可传输的状态。至于序列化的方法也很简单，只需要实现<strong>Serializable</strong>这个接口就行，如以下的Person类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="comment">//TODO 这行在书中是没有的，实际上我们得加上，用于区分版本这个类的版本，不同的这个id不能反序列回来</span></span><br><span class="line">	<span class="comment">//如果不写，系统会自动生成，但是如果改动了里面的属性（增加或者减少或者更改了属性），系统生成的这个值会改变</span></span><br><span class="line">	<span class="comment">//（注意，如果没有实质改动（如只是改变属性的位置，或者在类中添加了空格）则值不会改变</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID =<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要在Activity之间传递的话，只需要简单的几行代码即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">"Tom"</span>);</span><br><span class="line">person.setAge(<span class="string">"20"</span>);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line">intent.putExtra(<span class="string">"person_data"</span>,person);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>可以看到我们穿件了Person实例，之后直接将它传入putExtra()方法中了，只是因为Person实现了Serializable接口，所以才可以这么写。接下来要在SecondActivity中获取这个对象也很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = (Person)getIntent().getSerializableExtra(<span class="string">"person_data"</span>);</span><br></pre></td></tr></table></figure>

<p>这里调用了getSerializableExtra方法来获取通过参数传递过来的序列化对象，接着再向下转型得到Person对象，就成功实现了Intent传递对象。</p>
<h3 id="Parcelable方式"><a href="#Parcelable方式" class="headerlink" title="Parcelable方式"></a>Parcelable方式</h3><p>除了Serializable之外，使用Parcelable也可以实现相同的效果，不过不同于将对象进行序列化，Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现了传递对象的功能了。下面修改下Person类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">	。。。</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest,<span class="keyword">int</span> flags)</span></span>&#123;</span><br><span class="line">		dest.writeString(name);<span class="comment">//写出name</span></span><br><span class="line">		dest.writeInt(age);<span class="comment">//写出age</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Person&gt;()&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Person <span class="title">createFromParcel</span><span class="params">(Parcel source)</span></span>&#123;</span><br><span class="line">			Person person = <span class="keyword">new</span> Person();</span><br><span class="line">			person.name = source.readString();<span class="comment">//读取name</span></span><br><span class="line">			person.age = source.readInt();</span><br><span class="line">			<span class="keyword">return</span> person;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Person[] newArray(<span class="keyword">int</span> size)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Person[size];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Parcelable 的实现方式要稍微复杂些，首先继承 Parcelable 接口，这样就必须重写 describeContents() 和 writeToParcel() 两个方法。 describeContents 中直接返回0即可，writeToParcel中需要将Person类中的字段一一写出。除此之外，还得再Person类中提供一个 CREATOR 常量。接下来，我们仍然可以通过前面相同的代码来传递Person对象，只不过在SecondActivity中获取对象的时候需要稍加改动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = (Person)getIntent().getParcelableExtra(<span class="string">"person_data"</span>);</span><br></pre></td></tr></table></figure>

<p>一般来说，Serializable方式比较简单，但是这会把整个对象序列化，因此效率比Parcelable低一些，所以更加推荐Parcelable方式。</p>
<h2 id="定制自己的日志工具"><a href="#定制自己的日志工具" class="headerlink" title="定制自己的日志工具"></a>定制自己的日志工具</h2><p>实用性不太强，公司项目有更强大的日志工具，因此  略</p>
<h2 id="调试Android程序"><a href="#调试Android程序" class="headerlink" title="调试Android程序"></a>调试Android程序</h2><p>已经掌握，略</p>
<h2 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h2><p>Android中的定时任务一般有两种实现方式：一是Java API中的Timer类，二是Android中的Alarm机制。但Timer类不太适用于哪些需要长期在后台运行的定时任务，因为为了能让电池更加耐用，每种手机都会有自己的休眠策略，Android手机会在长时间不操作的情况下自动让<strong>CPU进入睡眠状态</strong>，这可能导致Timer中的定时任务无法正常运行。而Alarm则具有唤醒CPU功能，可以保证大多数情况下需要执行定时任务的时候CPU都能正常工作。<strong>注意，这里唤醒CPU和唤醒屏幕完全不是一个概念，千万不要混淆</strong>。</p>
<h3 id="Alarm机制"><a href="#Alarm机制" class="headerlink" title="Alarm机制"></a>Alarm机制</h3><p>Alarm机制用法并不复杂，主要借助于AlarmManager实现，跟NotificationManager有点类似，获取实例的方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AlarmManager manager = (AlarmManager)getSystemService(Context.ALARM_SERVICE);</span><br></pre></td></tr></table></figure>

<p>接下来使用set()方法就可以设置一个定时任务了，比如想设定一个任务在10秒钟后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> triggerAtTime = SystemClock.elapsedRealtime() + <span class="number">10</span> * <span class="number">1000</span>;</span><br><span class="line">manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,triggerAtTime,pendingIntent);</span><br></pre></td></tr></table></figure>

<p>第一个参数是整型参数，用于指定AlarmManager的工作类型，有4种值可选：ELAPSED_REALTIME(让定时任务的触发时间从系统开机开始算，但不会唤醒CPU)、ELAPSED_REALTIME_WAKEUP（表示定时任务从系统开机开始算起，但会唤醒CPU）、RTC（让定时任务触发时间从1970年1月1日0点开始算起，但不会唤醒CPU）、RTC_WAKEUP(让定时任务触发时间从1970年1月1日0点开始算起，但会唤醒CPU)。可以使用<strong>SystemClock.elapsedRealtime()</strong>获取到系统开机至今所经历的时间的毫秒数。<strong>Systemt.currentTimeMillis()</strong>可以获取到1970年1月1日0点至今所经历的毫秒数。第二个参数就是定时任务触发的时间，如果第一个参数是ELAPSED_REALTIME或者ELAPSED_REALTIME_WAKEUP，则传入开机至今时间加上延迟执行的时间；如果是RTC或者RTC_WAKEUP，则传入1970年1月1日0点至今的时间再加上延迟执行的时间。第三个参数不多说。  </p>
<p>那么如果要实现一个长时间在后台定时运行的服务要如何做呢，其实只要建立一个普通服务，然后将触发定时任务的代码写到onStartCommand()方法中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongRuningService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onstartCommand</span><span class="params">(Intent intent,<span class="keyword">int</span> flags,<span class="keyword">int</span> startId)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//TODO 之所以要在子线程里面执行逻辑操作，是因为逻辑操作需要耗时，放在主线程中可能会对定时任务准确性产生轻微影响。</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="comment">//执行具体的逻辑操作</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		AlarmManager manager = (AlarmManager)getSystemService(ALARM_SERVICE);</span><br><span class="line">		<span class="keyword">int</span> anHour = <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;<span class="comment">//一小时</span></span><br><span class="line">		<span class="keyword">long</span> triggerAtTime = SystemClock.elapsedRealtime() + anHour;</span><br><span class="line">		Intent i = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,LongRunningService(<span class="keyword">this</span>,<span class="number">0</span>,i,<span class="number">0</span>));</span><br><span class="line">		<span class="comment">//TODO 注意，从4.4开始，Alarm任务的触发将会变得不准确，有可能会延迟一段时间后任务才能得到执行，这不是bug，</span></span><br><span class="line">		<span class="comment">//而是系统在耗电方面的优化，系统会自动检测目前有多少Alarm任务，然后将触发时间相近的几个任务放在一起执行，可以</span></span><br><span class="line">		<span class="comment">//大幅度减少CPU被唤醒的次数，从而延长电池使用。如果要求Alarm任务执行时间必须准确无误，则使用   setExact()方法替代</span></span><br><span class="line">		<span class="comment">//下面的set()方法。</span></span><br><span class="line">		manager.set(AlarmManager.ELAPSED_REALTIME_WEKEUP,triggerAtTime,pi);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent,flags,startId);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，一旦启动了LongRuningService，就会设定一个定时任务，一个小时后会再次启动LongRuningService，形成一个永久循环。</p>
<h3 id="Doze模式"><a href="#Doze模式" class="headerlink" title="Doze模式"></a>Doze模式</h3><p>在Android 6.0中，google加入了Doze模式，及大幅度延长电池使用寿命。主要表现为：如果设备未插电源，处于静止（7.0后删除这条件），并且屏幕关闭了一段时间之后，就会进入Doze模式，系统会对CPU、网络、Alarm等活动限制，当然，系统还会间歇性地退出Doze一小段时间，在这段时间，应用可以去完成他们的同步操作、Alarm任务等。如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-13/%E5%9B%BE1.png" alt="Doze模式示意图"></p>
<p>可以看到，随着设备进入Doze模式的时间越长，间歇性退出Doze模式的时间间隔也会越来越长，因为如果设备长时间不使用的话，没必要频繁退出Doze。以下列出Doze模式下有具体哪些功能会收到限制：</p>
<ul>
<li>网络访问被禁止</li>
<li>系统忽略唤醒CPU或者屏幕操作</li>
<li>系统不再执行WIFI扫描</li>
<li>系统不再执行同步服务</li>
<li>Alarm任务将会在下次退出Doze模式时候执行</li>
</ul>
<p>不过，如果你真有非常特殊需求，要求Alarm任务在Doze模式也必须正常执行，可以调用AlarmManager的setAndAllowWhileIdle()或setExactAcnAllowWhileIdle()方法就能让定时任务即使在Doze模式下也能正常执行了，这两个方法之间的区别和set()、setExact()方法之间的区别一样。</p>
<p>*** 多窗口模式</p>
<p>在一个屏幕上，同时显示两个app界面。切换到多窗口模式，Activity会经历重新创建的过程。其实这是正常现象，进入多窗口模式后，Activity的大小发生了比较大的变化，此时默认会重新创建活动的。除此之外，像横竖屏也会重新创建活动。如果此时去操作另一个窗口，则当前窗口会执行onPause，而另一个窗口会执行onResume，这很好理解，因为两个窗口都是可见的，所以只会执行到onPause即可。因此，在考虑多窗口模式下，用户仍然可以看到处于暂停状态的应用，那么像视频播放器之类的应用应该在此时能够继续播放视频才对，因此最好不要在Activity的onPause()方法中去处理播放器的暂停逻辑，而应该在onStop()方法中处理，并且在onStart()方法中恢复视频播放。<strong>另外，针对进入多窗口时活动会被重新重新创建，如果想改变这一默认行为，可以在AndroidManifest.xml中进行配置：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:name</span>=<span class="string">".MainActivity"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:configChanges</span>=<span class="string">"origintation|keyboardHidden|screenSize|screenLayout"</span></span></span><br></pre></td></tr></table></figure>

<p>这样不管进入多窗口模式还是横竖屏切换，Activity都不会被重新创建，而是会将屏幕发生变化的事件通知到Activity的onConfigurationChanged()方法中，因此，如果有这方面的需求，只需要重写onConfigurationChanged()即可。  </p>
<p><strong>当然，如果想禁用多窗口模式，只需要在 AndroidManifest.xml 中的 <application> 或者 <activity>标签中加入如下属性即可</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:resizeableActivity=["true" | "false"]</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是，这个属性只有在项目的targetSdkVersion指定成24或者更高的时候才会有用。不过Android规定，如果targetSdkVersion小于24,并且Activity不允许横竖屏切换，那么应用也将不支持多窗口模式，如果不允许应用横竖屏切换，只需要在AndroidManifest.xml中添加如下配置：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:screenOrientation=["portrait" | "landscape"]</span><br></pre></td></tr></table></figure>








      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/07/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%8D%81%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="glassx的小黑屋,读书笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%8D%81%E7%AB%A0/" class="post-title-link" itemprop="url">第10章： 后台默默的劳动者-探究服务</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-09 18:00:00" itemprop="dateCreated datePublished" datetime="2018-07-09T18:00:00+08:00">2018-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-01 16:44:48" itemprop="dateModified" datetime="2019-05-01T16:44:48+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>服务非常适合执行那些不需要和用户交互还要求长期运行的任务。要注意的是，服务并不是运行在一个独立的进程当中，而是依赖于创建服务时所在的应用程序进程，当应用程序被杀掉时，所有依赖该进程的服务也会停止。不要被服务的后台概念迷惑，实际上服务并不会自动开启子线程，所有的代码都是默认运行在<strong>主线程</strong>中。因此在使用服务时要注意主线程被阻塞的情况。</p>
<h2 id="服务的基本用法"><a href="#服务的基本用法" class="headerlink" title="服务的基本用法"></a>服务的基本用法</h2><p>新建类MyService继承Service，要求重写其唯一一个抽象方法  onBind 。一般又要重写onCreate（服务创建时调用）、onStartCommand（每次服务启动的时候调用）以及onDestroy（服务销毁时调用）方法，它们是服务中最常用的3个方法。如果我们希望服务已启动就立刻执行某个动作，就可以将逻辑写在onStartCommand方法里。另外，还需要在AndroidManifest文件中做如下声明（四大组件都得声明）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:name</span>=<span class="string">".MyService"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line">&lt;/service</span><br></pre></td></tr></table></figure>
<p>其中export属性表示是否允许除了当前程序之外的其他程序访问这个服务，enable表示是否启用这个服务。</p>
<h3 id="启动和停止服务"><a href="#启动和停止服务" class="headerlink" title="启动和停止服务"></a>启动和停止服务</h3><p>通过以下代码可以简单地实现启动和停止服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(v.getId())&#123;</span><br><span class="line">		<span class="keyword">case</span> R.id.start_service:</span><br><span class="line">			Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyService.class);</span><br><span class="line">			startService(startIntent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.stop_service:</span><br><span class="line">			Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyService.class);</span><br><span class="line">			stopService(startIntent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建出Intent对象，使用startService即可启动MyService，会依次执行onCreate-&gt;onStartCommand；同理，使用stopService即可停止，onDestroy就会执行。如果在service里面，那么使用stopSelf即可停止自己。由于刚才点击start的时候，onCreate和onStartCommand都执行了，也许你会疑惑，这两个方法到底有什么区别呢？其实onCreate方法在服务第一次创建时调用，而onStartCommand则在每次启动服务时调用，由于是第一次创建，所以两个方法都执行了，如果多次点击start service按钮，那就只有onStartCommand方法执行了。</p>
<h3 id="活动和服务通信"><a href="#活动和服务通信" class="headerlink" title="活动和服务通信"></a>活动和服务通信</h3><p>上一节虽然在活动中启动和停止了服务，但是启动服务之后，活动与服务基本上就没关系了，没法控制服务。如果希望控制服务执行，比如MyService提供下载功能，则希望可以决定什么时候开始下载，以及查看下载进度等，主要的思路是创建一个专门的Binder对象来对下载功能进行管理，然后通过ServiceConnection来实现通信。简易代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//service代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> DownloadBinder mBinder = <span class="keyword">new</span> DownloadBinder();</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">DownloadBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownload</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProgress</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mBinder;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity代码</span></span><br><span class="line"><span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span></span>&#123;<span class="comment">//解除绑定时调用</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name,Ibinder service)</span></span>&#123;<span class="comment">//绑定时调用</span></span><br><span class="line">		downloadBinder = (MyService.DownloadBinder)service;</span><br><span class="line">		downloadBinder.startDownload();</span><br><span class="line">		downloadBinder.getProgress();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(v.getId())&#123;</span><br><span class="line">		<span class="keyword">case</span> R.id.bind_service:</span><br><span class="line">			Intent bindIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyService.class);</span><br><span class="line">			bindService(bindIntent,connection,BIND_AUTO_CREATE);<span class="comment">//绑定服务</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.unbind_service:</span><br><span class="line">			unbindService(connection);<span class="comment">//解绑服务</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务生命周期"><a href="#服务生命周期" class="headerlink" title="服务生命周期"></a>服务生命周期</h3><p>一旦在任何位置调用了Context的startService方法，相应的服务就会启动，如果服务还没创建过，onCrete先执行，在执行onStartCommand，如果已经创建了，则只会执行onStartCommand了，启动后该服务一直运行，直到调用stopService或者stopSelf为止。虽然多次启动服务onStartCommand会被多次执行，但是服务只会存在一个实例。<br>另外，还可以调用Context的bindService来获取一个服务的持久连接，这时会回调服务的onBind方法，类似地，如果之前没创建过该服务，就会先执行onCreate在执行onBind，之后，调用方可以获取到onBind方法里返回的IBinder对象实例，就能自由和服务进行通信。调用unbind方法，也会执行Myservice的onDestroy方法，即销毁服务。</p>
<h2 id="服务的更多技巧"><a href="#服务的更多技巧" class="headerlink" title="服务的更多技巧"></a>服务的更多技巧</h2><h3 id="使用前台服务"><a href="#使用前台服务" class="headerlink" title="使用前台服务"></a>使用前台服务</h3><p>由于服务运行在后台，因此其系统优先级比较低，当出现内存不足的情况时，容易被回收，这就考虑使用前台服务。前台服务和普通服务最大的区别在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉可以看到更详细的信息，非常<strong>类似</strong>于通知效果。其主要实现方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate();</span><br><span class="line">		Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MainActivity.class);</span><br><span class="line">		PendingIntent pi = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,intent,<span class="number">0</span>);</span><br><span class="line">		Notification notification = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>)</span><br><span class="line">			.setContentTitle(<span class="string">"title"</span>)</span><br><span class="line">			.***<span class="comment">//其他配置省略了</span></span><br><span class="line">			.build();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//没有像普通Notification一样使用NotificationManager将通知展示出来，而是使用</span></span><br><span class="line">			<span class="comment">//startForeground方法</span></span><br><span class="line">		**startForeground(<span class="number">1</span>,notification);<span class="comment">//与普通Notification和普通的Service区别的关键在这里**</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用IntentService"><a href="#使用IntentService" class="headerlink" title="使用IntentService"></a>使用IntentService</h3><p>服务中的代码都是默认运行在主线程当中的，如果直接在服务里处理耗时操作，很容易出现ANR。当然，为了避免这种情况，你可以在onStartCommand方法中new 一个Thread来处理耗时逻辑，写法并不复杂，但是程序员容易忘记开启线程或者忘记调用stopSelf。为了简单地创建一个异步的、能够自动停止的服务，Android专门提供了IntentService，在继承Intentservice之后，你可以直接在它的 onHandleIntent方法中执行耗时操作（这是在新的线程里面，可以通过Thread.currentThread<br>().getId()方法查看线程ID，跟主线程不是同一个），在耗时操作执行完毕之后，这个IntentService会自动调用onDestroy停止。</p>
<h3 id="服务的最佳实践——完整版下载示例"><a href="#服务的最佳实践——完整版下载示例" class="headerlink" title="服务的最佳实践——完整版下载示例"></a>服务的最佳实践——完整版下载示例</h3><p>直接上代码吧，多说无益。用于执行异步任务的AsyncTask：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里AsyncTask传入3个参数类型，第一个泛型指定为String，表示在执行AsyncTask时需要传入一个</span></span><br><span class="line"><span class="comment">//字符串给后台任务，第二个指定为Integer，表示使用整型数据作为进度显示单位，第三个泛型Intege则表示使用整数型</span></span><br><span class="line"><span class="comment">//数据来反馈执行结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>,<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SUCCESS = <span class="number">1</span>;<span class="comment">//成功</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_FAILED = <span class="number">2</span>;<span class="comment">//失败</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_PAUSED = <span class="number">3</span>;<span class="comment">//暂停</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_CANCELED = <span class="number">4</span>;<span class="comment">//取消</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DownloadListener downloadListener = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPaused = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isCancled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lastProgress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadTask</span><span class="params">(DownloadListener listener)</span></span>&#123;</span><br><span class="line">        downloadListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;<span class="comment">//用于后台执行下载逻辑</span></span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        RandomAccessFile savedFile = <span class="keyword">null</span>;</span><br><span class="line">        File file = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">long</span> downloadedLength = <span class="number">0</span>;<span class="comment">//记录已经下载的文件长度</span></span><br><span class="line">            String downloadUrl = params[<span class="number">0</span>];</span><br><span class="line">            String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(<span class="string">"/"</span>));</span><br><span class="line">            <span class="comment">//SD卡的Download目录</span></span><br><span class="line">            String directory = Environment.getExternalStoragePublicDirectory(</span><br><span class="line">                    Environment.DIRECTORY_DOWNLOADS).getPath();</span><br><span class="line">            file = <span class="keyword">new</span> File(directory + fileName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果已经存在要下载的文件了，则读取已经下载的字节数，这样就可以在后面启动端点续传功能</span></span><br><span class="line">            <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">                downloadedLength = file.length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取文件总长</span></span><br><span class="line">            <span class="keyword">long</span> contentLength = getContentLength(downloadUrl);</span><br><span class="line">            <span class="keyword">if</span>(contentLength == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> TYPE_FAILED;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(contentLength == downloadedLength)&#123;</span><br><span class="line">                <span class="comment">//已下载的字节和总字节相等，说明已经下载完成</span></span><br><span class="line">                <span class="keyword">return</span> TYPE_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">            OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">            Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                    <span class="comment">//断点下载，指定从哪个字节开始下载</span></span><br><span class="line">                    .addHeader(<span class="string">"RANGE"</span>,<span class="string">"bytes="</span> + downloadedLength + <span class="string">"-"</span>)</span><br><span class="line">                    .url(downloadUrl)</span><br><span class="line">                    .build();</span><br><span class="line">            Response response = client.newCall(request).execute();</span><br><span class="line">            <span class="keyword">if</span>(response != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//以下读取服务器响应的数据，并使用Java文件流方式，不断从网络读取数据，不断写到本地，知道</span></span><br><span class="line">                <span class="comment">//文件全部下载完成为止</span></span><br><span class="line">                is = response.body().byteStream();</span><br><span class="line">                savedFile = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">                savedFile.seek(downloadedLength);<span class="comment">//跳过已下载的字节</span></span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> len;</span><br><span class="line">                <span class="keyword">while</span> ((len = is.read(b)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isCancled)&#123;</span><br><span class="line">                        <span class="keyword">return</span> TYPE_CANCELED;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isPaused)&#123;</span><br><span class="line">                        <span class="keyword">return</span> TYPE_PAUSED;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        total += len;</span><br><span class="line">                        savedFile.write(b,<span class="number">0</span>,len);</span><br><span class="line">                        <span class="comment">//计算已下载的百分比</span></span><br><span class="line">                        <span class="keyword">int</span> progress = (<span class="keyword">int</span>) ((total + downloadedLength) * <span class="number">100</span>/contentLength);</span><br><span class="line">                        publishProgress(progress);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                response.body().close();</span><br><span class="line">                <span class="keyword">return</span> TYPE_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (is != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (savedFile != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    savedFile.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isCancled &amp;&amp; file != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    file.delete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TYPE_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span> </span>&#123;<span class="comment">//用于在界面上更新当前的下载进度</span></span><br><span class="line">        <span class="keyword">int</span> progress = values[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (progress &gt; lastProgress)&#123;</span><br><span class="line">            downloadListener.onProgress(progress);</span><br><span class="line">            lastProgress = progress;</span><br><span class="line">            Log.e(<span class="string">"进度"</span>,progress+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Integer status)</span> </span>&#123;<span class="comment">//用于通知最终的下载结果</span></span><br><span class="line">        <span class="keyword">switch</span> (status)&#123;</span><br><span class="line">            <span class="keyword">case</span> TYPE_SUCCESS:</span><br><span class="line">                downloadListener.onSuccess();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TYPE_FAILED:</span><br><span class="line">                downloadListener.onFailed();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TYPE_PAUSED:</span><br><span class="line">                downloadListener.onPaused();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TYPE_CANCELED:</span><br><span class="line">                downloadListener.onCancled();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pauseDownload</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isPaused = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelDownload</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isCancled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取要下载的内容的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getContentLength</span><span class="params">(String downloadUrl)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(downloadUrl)</span><br><span class="line">                .build();</span><br><span class="line">        Response response = client.newCall(request).execute();</span><br><span class="line">        <span class="keyword">if</span>(response != <span class="keyword">null</span> &amp;&amp; response.isSuccessful())&#123;</span><br><span class="line">            <span class="keyword">long</span> contentLength = response.body().contentLength();</span><br><span class="line">            response.close();</span><br><span class="line">            <span class="keyword">return</span> contentLength;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于执行后台任务的Service</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DownloadTask downloadTask;</span><br><span class="line">    <span class="keyword">private</span> String downloadUrl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DownloadListener listener = <span class="keyword">new</span> DownloadListener()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgress</span><span class="params">(<span class="keyword">int</span> progress)</span> </span>&#123;</span><br><span class="line">            getNotificationManager().notify(<span class="number">1</span>,getNotification(<span class="string">"Downloading..."</span>,progress));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            downloadTask = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//下载成功时将前台服务通知关闭，并创建一个下载成功的通知</span></span><br><span class="line">            <span class="comment">//这句代码将服务创建成前台服务</span></span><br><span class="line">            stopForeground(<span class="keyword">true</span>);</span><br><span class="line">            getNotificationManager().notify(<span class="number">1</span>,getNotification(<span class="string">"Download Success"</span>,-<span class="number">1</span>));</span><br><span class="line">            Toast.makeText(DownloadService.<span class="keyword">this</span>,<span class="string">"Download success"</span>,Toast.LENGTH_LONG).show();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            downloadTask = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//下载失败将前台服务通知关闭，并创建一个下载失败的通知</span></span><br><span class="line">            stopForeground(<span class="keyword">true</span>);</span><br><span class="line">            getNotificationManager().notify(<span class="number">1</span>,getNotification(<span class="string">"Download Failed"</span>,-<span class="number">1</span>));</span><br><span class="line">            Toast.makeText(DownloadService.<span class="keyword">this</span>,<span class="string">"Download failed"</span>,Toast.LENGTH_LONG).show();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPaused</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            downloadTask = <span class="keyword">null</span>;</span><br><span class="line">            Toast.makeText(DownloadService.<span class="keyword">this</span>,<span class="string">"Paused"</span>,Toast.LENGTH_LONG).show();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            downloadTask = <span class="keyword">null</span>;</span><br><span class="line">            stopForeground(<span class="keyword">true</span>);</span><br><span class="line">            Toast.makeText(DownloadService.<span class="keyword">this</span>,<span class="string">"Canceled"</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了让service可以和Activity通信，创了这个binder</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownload</span><span class="params">(String url)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(downloadTask == <span class="keyword">null</span>)&#123;</span><br><span class="line">                downloadUrl = url;</span><br><span class="line">                downloadTask = <span class="keyword">new</span> DownloadTask(listener);</span><br><span class="line">                downloadTask.execute(downloadUrl);</span><br><span class="line">                startForeground(<span class="number">1</span>,getNotification(<span class="string">"Downloading..."</span>,<span class="number">0</span>));</span><br><span class="line">                Toast.makeText(DownloadService.<span class="keyword">this</span>,<span class="string">"Downloading..."</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pauseDownload</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (downloadTask != <span class="keyword">null</span>)&#123;</span><br><span class="line">                downloadTask.pauseDownload();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelDownload</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (downloadTask != <span class="keyword">null</span>)&#123;</span><br><span class="line">                downloadTask.cancelDownload();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (downloadUrl != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//取消下载时需要将文件删除，并将通知关闭</span></span><br><span class="line">                    String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(<span class="string">"/"</span>));</span><br><span class="line">                    String directory = Environment.getExternalStoragePublicDirectory(</span><br><span class="line">                            Environment.DIRECTORY_DOWNLOADS).getPath();</span><br><span class="line">                    File file = <span class="keyword">new</span> File(directory + fileName);</span><br><span class="line">                    <span class="keyword">if</span>(file.exists())&#123;<span class="comment">//如果已经存在要下载的文件了，则读取已经下载的字节数，这样就可以在后面启动端点续传功能</span></span><br><span class="line">                        file.delete();</span><br><span class="line">                    &#125;</span><br><span class="line">                    getNotificationManager().cancel(<span class="number">1</span>);</span><br><span class="line">                    stopForeground(<span class="keyword">true</span>);</span><br><span class="line">                    Toast.makeText(DownloadService.<span class="keyword">this</span>,<span class="string">"Canceled"</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DownloadBinder mBinder = <span class="keyword">new</span> DownloadBinder();</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> NotificationManager <span class="title">getNotificationManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Notification <span class="title">getNotification</span><span class="params">(String title,<span class="keyword">int</span> progress)</span></span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MainActivity.class);</span><br><span class="line">        PendingIntent pi = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,intent,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        NotificationCompat.Builder builder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO 注意这段代码，在8.0以后通知要求设置 NotificationChannel，否则会报错</span></span><br><span class="line">        <span class="comment">//TODO 在书本中的代码没有这一段</span></span><br><span class="line">        <span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O )&#123;</span><br><span class="line">            NotificationChannel channel = <span class="keyword">new</span> NotificationChannel(<span class="string">"im_channel_id"</span>,<span class="string">"System"</span>, NotificationManager.IMPORTANCE_LOW);</span><br><span class="line">            NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">            <span class="keyword">if</span>(manager != <span class="keyword">null</span>)&#123;</span><br><span class="line">                **manager.createNotificationChannel(channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//书上是 builder = new NotificationCompat.Builder(this);  ，但是这个方法现在已经废弃了</span></span><br><span class="line">        builder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>,<span class="string">"im_channel_id"</span>);</span><br><span class="line">        builder.setSmallIcon(R.mipmap.ic_launcher);</span><br><span class="line">        builder.setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher));</span><br><span class="line">        builder.setContentIntent(pi);</span><br><span class="line">        builder.setContentTitle(title);</span><br><span class="line">        <span class="keyword">if</span> (progress &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//当progress大于或者等于0才需显示下载进度</span></span><br><span class="line">            builder.setContentText(progress + <span class="string">"%"</span>);</span><br><span class="line">            builder.setProgress(<span class="number">100</span>,progress,<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Activity中的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DownloadService.DownloadBinder downloadBinder;</span><br><span class="line">    <span class="comment">//为了能够控制service的行为</span></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            downloadBinder = (DownloadService.DownloadBinder) service;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        findViewById(R.id.start).setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        findViewById(R.id.pause).setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        findViewById(R.id.cancel).setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,DownloadService.class);</span><br><span class="line">        startService(intent);</span><br><span class="line">        bindService(intent,connection,BIND_AUTO_CREATE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.0及以上要求动态申请权限，有权限才能使用这个下载功能</span></span><br><span class="line">        <span class="keyword">if</span>(ContextCompat.checkSelfPermission(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">                Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">            ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]</span><br><span class="line">                    &#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先判断downloadBinder是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (downloadBinder == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.start:</span><br><span class="line">                String url = <span class="string">"https://raw.githubusercontent.com/guolindev/eclipse/master/eclipse-inst-win64.exe"</span>;</span><br><span class="line">                downloadBinder.startDownload(url);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.pause:</span><br><span class="line">                downloadBinder.pauseDownload();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.cancel:</span><br><span class="line">                downloadBinder.cancelDownload();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, @NonNull String[] permissions, @NonNull <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">        <span class="keyword">switch</span> (requestCode)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (grantResults.length &gt; <span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">"拒绝权限无法使用程序"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">                    finish();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unbindService(connection);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>当然，还有要注意的是，要在AndroidManifest.xml中注册Service：</strong></p>
<blockquote>
<p>service android:name=”.DownloadService”</p>
</blockquote>
<p>还有，在AndroidManifest.xml中需要标明网络权限和存储权限：</p>
<blockquote>
<p>uses-permission android:name=”android.permission.INTERNET”<br>    uses-permission android:name=”android.permission.WRITE_EXTERNAL_STORAGE”</p>
</blockquote>
<p>最后，针对本例子，例子中使用了okhttp，需要在buildgradle中添加依赖：</p>
<blockquote>
<p>implementation ‘com.squareup.okhttp3:okhttp:3.9.0’</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/23/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B9%9D%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="glassx的小黑屋,读书笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/23/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B9%9D%E7%AB%A0/" class="post-title-link" itemprop="url">第9章： 看看精彩的世界-使用网络技术</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-23 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-23T08:00:00+08:00">2018-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-01 16:44:00" itemprop="dateModified" datetime="2019-05-01T16:44:00+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="webview的用法"><a href="#webview的用法" class="headerlink" title="webview的用法"></a>webview的用法</h2><p>这节描述得比较简单，因此记住以下内容就行：</p>
<blockquote>
<p>webview.setWebClient(new WebViewClient);</p>
</blockquote>
<p>为webview设置webViewClient，其主要作用是当需要从一个网页跳转到另一个网页时，我们希望目标网页仍然在当前WebView中显示，而不是打开系统浏览器。</p>
<h2 id="使用HTTP协议访问网络"><a href="#使用HTTP协议访问网络" class="headerlink" title="使用HTTP协议访问网络"></a>使用HTTP协议访问网络</h2><p>介绍了HttpURLConnection 使用方法，简单上个图：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-9/%E5%9B%BE0.png" alt="HttpURLConnection使用"></p>
<p>OkHttp的简单使用，并不复杂，略。</p>
<h2 id="解析XML格式数据"><a href="#解析XML格式数据" class="headerlink" title="解析XML格式数据"></a>解析XML格式数据</h2><p>在网络上传输数据时最常用的格式有两种，XML和JSON，首先学习解析XML。</p>
<h3 id="搭建简易服务器提供数据"><a href="#搭建简易服务器提供数据" class="headerlink" title="搭建简易服务器提供数据"></a>搭建简易服务器提供数据</h3><p>学习解析xml和json之前，先搭建一个简易服务器提供解析的数据，按照以下步骤即可：</p>
<ol>
<li><p>下载一个Apache服务器的安装包，官方下载地址<a href="http://httpd.apache.org/download.cgi" target="_blank" rel="noopener">http://httpd.apache.org/download.cgi</a></p>
</li>
<li><p>一路默认Next，域名随意填写如test.com，安装路径的话，可以选择安装在 C:\Apache 目录</p>
</li>
<li><p>为了验证安装是否成功，可以打开电脑的浏览器验证，输入 127.0.0.1 出现 It works 界面即可。</p>
</li>
</ol>
<p>接下来进入到安装目录的htdocs目录下，按照上述安装过程应该是C:\Apache\htdocs目录，新建get_data.xml文件，编辑，并加入内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">apps</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">app</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>google map<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">app</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>google map<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">app</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">apps</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打开浏览器访问 <a href="http://127.0.0.1/get_data.xml就会显示上述内容，同理，如果在其中新建" target="_blank" rel="noopener">http://127.0.0.1/get_data.xml就会显示上述内容，同理，如果在其中新建</a> get_data.json文件，并添加以下数据：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="attr">"id"</span>:<span class="string">"5"</span>,<span class="attr">"version"</span>:<span class="string">"5.5"</span>,<span class="attr">"name"</span>:<span class="string">"map"</span>&#125;,</span><br><span class="line">&#123;<span class="attr">"id"</span>:<span class="string">"6"</span>,<span class="attr">"version"</span>:<span class="string">"6.6"</span>,<span class="attr">"name"</span>:<span class="string">"boom"</span>&#125;,</span><br><span class="line">&#123;<span class="attr">"id"</span>:<span class="string">"7"</span>,<span class="attr">"version"</span>:<span class="string">"3.5"</span>,<span class="attr">"name"</span>:<span class="string">"clash"</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>打开浏览器访问 <a href="http://127.0.0.1/get_data.json" target="_blank" rel="noopener">http://127.0.0.1/get_data.json</a> 就会返回上述json。</p>
<h3 id="Pull解析方式"><a href="#Pull解析方式" class="headerlink" title="Pull解析方式"></a>Pull解析方式</h3><p>解析XML格式的数据有多重方式，主要是Pull和SAX两种方式。通过自己搭建的服务器拉取XML数据之后通过Pull解析的示例如下：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-9/%E5%9B%BE1.jpg" alt="pull解析方式代码"></p>
<h3 id="SAX解析"><a href="#SAX解析" class="headerlink" title="SAX解析"></a>SAX解析</h3><p>Pull解析方式虽然非常好用，它比XML解析方式要复杂一些，但是语义方面更清楚，通常情况下，我们都会新建一个雷继承自DefaultHandler，并重写父类的5个方法：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-9/%E5%9B%BE2.jpg" alt="继承DefaultHandler"></p>
<p>每当解析某个节点的时候，startElement方法就会得到调用，其中localName记录当前节点的名字。接下来的工作就非常简单了，修改MainActivity中的代码，如下所示：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-9/%E5%9B%BE3.jpg" alt="SAX解析"></p>
<h2 id="解析JSON格式数据"><a href="#解析JSON格式数据" class="headerlink" title="解析JSON格式数据"></a>解析JSON格式数据</h2><p>JSON相对XML而言优势在于它体积更小，在网络上传输的时候可以更省流量，但缺点是语义性较差。</p>
<h3 id="使用JSONObject"><a href="#使用JSONObject" class="headerlink" title="使用JSONObject"></a>使用JSONObject</h3><p>比较简单，直接上截图的例子：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-9/%E5%9B%BE4.png" alt="JSONObject解析"></p>
<h3 id="使用GSON"><a href="#使用GSON" class="headerlink" title="使用GSON"></a>使用GSON</h3><p>解析单个的对象比较简单，比如解析：</p>
<blockquote>
<p>{“name”:”Tom”,”age”:20}</p>
</blockquote>
<p>那只需要定义Person类，有String类型的name字段以及int类型的age字段，则可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">Person person = gson.fromJson(jsonData,Person.class);</span><br></pre></td></tr></table></figure>

<p>解析数组稍微麻烦点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; people = gson.fromJson(jsonData,<span class="keyword">new</span> TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;.getType());</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="glassx"
    src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">glassx的小黑屋,读书笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail &amp;rarr; mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo &amp;rarr; https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.2"></script><script src="/js/motion.js?v=7.4.2"></script>
<script src="/js/schemes/pisces.js?v=7.4.2"></script>
<script src="/js/next-boot.js?v=7.4.2"></script>



  


















  

  

  

</body>
</html>
