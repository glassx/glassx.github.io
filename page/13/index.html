<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/13/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">153</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/04/03/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/03/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：垃圾收集器与内存分配策略</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-03 21:10:00" itemprop="dateCreated datePublished" datetime="2019-04-03T21:10:00+08:00">2019-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:49:12" itemprop="dateModified" datetime="2019-11-17T21:49:12+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。客观地说，引用计数法的实现简单，但它很难解决对象之间相互循环引用的问题，所以，主流实现中，并不使用这种方式。</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>在主流实现中，都是通过可达性分析来判定对象是否存活。这个算法的基本思路就是通过<strong>一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到GC Roots 没有任何引用链相连时，则证明此对象是不可用的</strong>。在Java语言中，可以作为 GC Roots 的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。  </li>
<li>本地方法栈中JNI引用的对象。  </li>
<li>方法区中类静态属性引用的对象。  </li>
<li>方法区中常量引用的对象。  </li>
</ul>
<h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>JDK 1.2 以前，对象只有引用和被引用两种状态，未能描述那些“食之无味，弃之可惜”的对象，我们希望描述这样一类对象：当内存还足够时，则能保留在内存之中；如果内存空间在GC后还是非常紧张，则可以抛弃这些对象。因此，JDK 1.2以后对引用的概念进行扩充，分为：</p>
<ul>
<li><p>强引用。代码中普遍存在的，类似于 Object obj = new Object() ，只要强引用还在，垃圾收集器永远不会回收被引用的对象。</p>
</li>
<li><p>软引用。是用来描述一些还有用，但是并非必需的对象，在系统将要发生内存溢出的异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
</li>
<li><p>弱引用。是用来描述非必需对象的，但是强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次GC发生之前。当GC工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>
</li>
<li><p>虚引用。是最弱的一种引用关系，不会对对象的生存时间构成影响，也无法通过虚引用获得对象实例。为对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p>
</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使在可达性分析算法中不可达的对象，也并非“非死不可”的。要真正宣告一个对象的死亡，至少要经历两次标记过程：如果对象在可达性分析后发现没有与GC Roots 相连接的引用链，那么它会被第一次标记，并进行筛选，筛选的条件是此对象是否有必要执行 finalize() 方法，当对象没有覆写 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则都没有必要执行；</p>
<p>如果对象判定有必要执行 finalize() 方法，则对象会被放入F-Queue队列中，稍后由低优先级的线程去触发 执行finalize() 方法，但不会承诺等待它运行结束。这样做的原因是防止 finalize 方法过于缓慢或者死循环。finalize() 方法是对象套多死亡命运的最后一次机会，因为稍后GC将对F-Queue中的对象进行第二次标记，如果对象要在finalize 中拯救自己————只要重新与某个引用链上的任意一个对象关联即可，那么在第二次标记的时候它将被移除出“即将回收”的集合；如果这时候对象还没逃脱，那它就会真的被回收了。</p>
<p>说明这一过程的示例代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span></span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"yes,i am still alive"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> finalize（） <span class="keyword">throws</span> Throwable{</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed"</span>);</span><br><span class="line">        FinalizeEscapeGc. SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>{</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为finalize方法优先级很低，所以暂停0.5秒等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>){</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            System.out.println(<span class="string">"no,i am dead"</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为finalize方法优先级很低，所以暂停0.5秒等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>){</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            System.out.println(<span class="string">"no,i am dead"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<blockquote>
<p>finalize method executed<br>yes,i am still alive<br>no,i am dead  </p>
</blockquote>
<p>从结果可以看出，SAVE_HOOK 对象的 finalize 方法确实被GC收集器触发过，并且收集前成功逃脱。但两段完全一样的代码，第二次却被回收了，因为finalize 方法只会被自动调用一次，因此第二次不执行了，所以自救失败。</p>
<p>有些教材上认为 finalize 中适合做“关闭外部资源”之类的工作，在了解以上机制之后，可以认为这完全是一种自我安慰，finalize 能做的，try-finally 或其他方法能做得更好，更及时，所以完全可以忘记这个方法存在（它也仅仅只是Java诞生时讨好C/C++程序员的一个妥协）。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>最基础的收集算法是 标记-清除(Mark-Sweep) 算法，它分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，在标记完成后统一回收被标记的对象。它的主要不足有两个：一是效率问题，标记和清除效率都不高；二是清除后会产生大量不连续的内存碎片。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，复制算法出现了。它将可用内存分为大小相等的两块，每次只使用其中一块，当这块内存用完了，就将还存活的对象复制到另一块上，然后把当前内存空间一次清理掉。这样每次都是对整个半区回收，内存分配也不会存在碎片。缺点是可用内存缩小了一半，代价太高。</p>
<blockquote>
<p>现在商业虚拟机采用这种方式回收新生代。一般将内存分为较大的 Eden 和两块较小的 Survivor 空间（HotSpot中 Eden 与 Survivor大小比例为 8：1），每次使用Eden 和其中一块 Survivor，当内存回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor，最后清理Eden和刚才用过的Survivor空间，因此，每次只有10%的内存“被浪费”。当然这是基于统计新生代的对象生命周期都很短，差不多只有10%的对象会存活，此外，如果超出10%的存活对象，Survivor空间不够时，需要依赖老年代的空间提供担保（Survivor空间存不下的对象直接通过担保机制进入老年代），这是该分配方式能够运行下去的保障。</p>
</blockquote>
<p>复制收集算法在对象存活率较高时要进行较多的复制操作，效率将会变低，更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行担保，防止对象100%存活的极端情况。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>根据老年代特点，有人提出另外一种<strong>标记-整理(Mark-Compact)算法</strong>，标记过程仍与“标记-清除”算法一样，但后续不是直接清理可回收对象，而是所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。标记整理算法的示意图如下：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%89%88/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记-整理算法"></p>
<p>关于怎么个移动法，书上没有说明，这里个人做个推测：</p>
<blockquote>
<p>1、整个老年代的内存划分为 A 和 B 两个区域，区域 A 的大小是所有还存活对象的总大小，区域 B 大小是是剩余空间。<br>2、按顺序在 A 中找到第一个还存活对象，将它移动到 A 空间的最前端，接下来找第二个还存活的对象，将其移动到第一个对象的后面<br>3、以此类推，即使存活的对象在 B 中也一样顺序复制到A中，直至最后填满A空间，之后清除 B 空间。</p>
</blockquote>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>商业虚拟机都采用“分代收集”，根据各个年代的特点分别采用适当的收集算法：</p>
<ul>
<li>在新生代中，每次垃圾收集时都会发现有大批对象死去，只有少量存活（前面提到的统计数据，大部分时候只有 10% 存活），那就选用复制算法。  </li>
<li>而老年代中因对象存活率高，没有额外空间对它进行担保，就必须使用“标记-清理”或者“标记-整理”算法进行回收。</li>
</ul>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>这是自己添加的这个标题，书中的结构并不是如此，因为 Android ART 虚拟机使用的也是CMS收集方式，所以这里特意抽出来理解，方便理解Android的虚拟机。 CMS (Concurrent Mark Sweep) 收集器，并发的“标记-清除”方式实现的收集器。它是一种以获取最短回收停顿时间为目标的收集器。它的整个过程分为4个步骤：</p>
<ul>
<li>初始标记  </li>
<li>并发标记  </li>
<li>重新标记  </li>
<li>并发清除  </li>
</ul>
<p>其中，初始标记、重新标记 这两个步骤仍然需要“Stop The World”，初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快；并发标记就是进行 GC Roots Tracing 的过程（根据初始标记过程中标识出来的直接关联对象，并发标记存活的对象）；重新标记阶段则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录；</p>
<p>由于整个过程中好事最长的 <strong>并发标记 和 并发清除</strong> 过程收集器线程都可以与用户线程一起工作，所以，从总体上来讲，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>CMS 是优秀的收集器，但是它也有3个明显的缺点：</p>
<ul>
<li><p>CMS 收集器对 CPU 资源非常敏感。与其他并发设计的程序一样，CMS收集器对 CPU 同样敏感，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用变慢。 </p>
</li>
<li><p>CMS 无法处理浮动垃圾(Floating Garbage,个人认为简而言之就是GC过程中用户线程产生的垃圾，类比于你妈妈在打扫房间卫生的时候，你还在继续撕的纸)。  </p>
</li>
<li><p>还有最后一个缺点，就是CMS本质还是“标记-清除”算法实现的，这种收集方式在结束后会产生大量的碎片化的空间。</p>
</li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>以下是几条最普遍的内存分配规则，可以通过代码去验证这些规则：</p>
<h3 id="对象优先在-Eden-上分配"><a href="#对象优先在-Eden-上分配" class="headerlink" title="对象优先在 Eden 上分配"></a>对象优先在 Eden 上分配</h3><p>大多数情况下，对象在新生代 Eden 区中分配，当 Eden 区没有足够空间时，虚拟机将发起一次 Minor GC （新生代GC）。可以采用以下方式验证：</p>
<p>通过 -Xms20M、-Xmx20M、-Xmn10M 三个参数限制Java 虚拟机堆大小 20MB，不可扩展，并且其中 10M 分配给新生代，剩下的 10MB 分配给老年代，-XX:SurvivorRatio=8决定新生代中 Edun 区与 一个 Survivor区的比例是 8：1，即 Eden 大小 8192K，两个 survivor 空间分别 1024K，所以新生代总共可用空间是 9216K （Eden 区 + 1个Survivor区）。<br>执行 testAllocation()尝试分配 3个 2M 的大小和1个 4MB 大小的对象。<br>代码执行完成后，可以发现 新生代Eden区被占用了 4M，而老年代被占用了 6M。<br>解释：分配前3个对象时，没有压力，均分配在Eden区域，当分配第4个对象时，内存已经不够了（可用空间是 9216K，而 2M*3 + 4M = 10），因此触发一次Minor GC，此时发现这3个对象都存活，并且 survivor 区间不够容纳存活的对象，因此这3个对象被直接通过担保机制提前转移到老年代中；这次GC结束后，第4个对象就可以顺利分配到Eden空间中。</p>
<blockquote>
<p>新生代GC(Minor GC):发生在新生代的垃圾收集，因为Java对象大多朝生夕死，所以Minor GC非常频繁，一般回收速度也比较快<br>老年代GC(Major GC/Full GC)：指的是老年代的GC，对于许多收集器而言，这时候都会伴随至少一次的 Minor GC，老年代的GC一般会比 Minor GC 慢10倍以上。</p>
</blockquote>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓大对象是指需要大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组。当然，比大对象更糟糕的是遇到一群朝生夕死的“短命大对象”，这种应当避免。经常出现大对象容易导致内存还有不少空间就提前触发垃圾收集器以获得足够的<strong>连续空间</strong>来安置它们。</p>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>如果对象在Eden出生并经历过第一次Minor GC 后仍然存活并且能被 Survivor 容纳的话，将被移动到Survivor 中，并且年龄设置为 1，此后，每熬过一次 Minor GC ，对象的年龄就加1，当达到某个阈值（系统一般默认 15），就会被晋升到老年代中。</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>为了更好地适应不同程序内存状况，并不总是要求对象必须达到某个年龄才进入老年代。如果 Survivor 中同龄对象达到某个阈值（一般是一半）时，大于或者等于这个年龄的对象就会移动到老年代。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>发生Minor GC 前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，则 Minor GC 可以确保是安全的，如果不成立，则会判断是否允许担保失败，如果允许担保失败，则最终可能会触发一次Full GC。虽然绕了一圈还是有可能触发 Full GC，但是这种情况相对较少。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/04/02/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/02/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：Java内存区域与内存溢出异常</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-02 21:10:00" itemprop="dateCreated datePublished" datetime="2019-04-02T21:10:00+08:00">2019-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:49:05" itemprop="dateModified" datetime="2019-11-17T21:49:05+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>根据《Java虚拟机规范(java SE 7)》规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%89%88/java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="Java运行时数据区域"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器可以看做是当前线程执行的字节码的行号指示器，它是线程私有的。在虚拟机概念模型里（具体虚拟机可能有更高效实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖程序计数器来完成。如果线程在执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行Native方法，这个计数器值为Undefined。<strong>此内存区域是Java虚拟机规范中唯一一个没有规定任何 OutOfMemoryError情况的区域</strong>。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>Java虚拟机栈也是线程私有的。它描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，一个方法从调用至完成，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。<strong>这个区域被规定了两种异常状况：如果线程请求的栈深度大于虚拟机允许的深度，就抛出 StackOverflowError异常；如果该区域可以动态扩展，则在扩展时无法申请到足够内存，就会抛出OutOfMemoryError异常</strong>。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈类似，区别只不过是虚拟机栈为执行Java方法(即字节码)服务，而本地方法栈为Native方法服务，同样，<strong>本地方法栈也可能抛出StackOverflowError异常以及OutOfMemoryError异常</strong>.</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆是被所有线程共享的一块内存，虚拟机启动时创建。虚拟机规范描述是，所有对象的实例以及数组都要在堆上分配(当然，不同虚拟机实现不同)。<strong>如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常</strong>。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>与Java堆一样，方法区也是各个线程共享的内存区域。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<strong>当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常</strong>。</p>
<blockquote>
<p>提到方法区，不得不提<strong>运行时常量池</strong>，它是方法区的一个部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是信息常量池，用于存放编译期生成的各种字面量和符号引用（一般来说，翻译出来的直接引用也会存储在运行时常量池中）。</p>
</blockquote>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存(Direct Memory)不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在Java 1.4中新加入了NIO（New Input/Output）类，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectBuffer对象作为这块内存额引用进行操作，这样能在一些场景中显著提高性能，因为它避免在 Java 堆和 Native 堆中来回复制数据。<strong>当然，该区域空间在动态扩展时也可能出现OutOfMemoryError异常</strong>。</p>
<h2 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>虚拟机遇到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，则必须限制性相应的类加载过程。类加载完成后，便可完全确定对象所需的内存大小，接下来为新生的对象真正分配内存。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)、和对齐填充(Padding)。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的refrence数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针，其中前者通过句柄池间接指向堆中的对象，后者直接指向堆中的对象。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="OutOfMemoryError异常"><a href="#OutOfMemoryError异常" class="headerlink" title="OutOfMemoryError异常"></a>OutOfMemoryError异常</h3><p>Java虚拟机规范中，除了程序计数器之外，其他区域都可能发生 OutOfMemoryError异常。</p>
<h3 id="JAVA堆溢出"><a href="#JAVA堆溢出" class="headerlink" title="JAVA堆溢出"></a>JAVA堆溢出</h3><p>Java堆用于存储实例对象，只要不断地创建对象，并且保证GC root 到对象之间有可达路径来避免垃圾回收，那么就能产生OutOfMemoryError异常。</p>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>虚拟机栈和本地方法栈理论上分配不到足够的内存同样会报 OutOfMemoryError异常，但是一般情况下，首先会出现StackOverflowError，OutOfMemoryError很难出现。</p>
<h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><p>由于运行时常量池是方法区的一个部分，因此这两个区域的溢出测试放在一起进行。在此之前我们先了解下String.intern()方法：</p>
<blockquote>
<p>String.intern()是一个Native方法，它的作用是，如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并返回此String对象的引用。</p>
</blockquote>
<p>在JDK1.6及以前，通过设置永久代区域的大小可以间接限制方法区大小，但是从JDK 1.7以后就“去永久代”了，因此以下代码只在JDK 1.6 ，并且设置了 MaxPermSize 时有效：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">    <span class="comment">//使用List保持常量池的引用，避免full gc 回收常量池</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line">        list.add(String.valueOf(i++).intern());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同样的原因，还可以引申一个更有意思的影响，如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">    String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append（“软件”）.toString();</span><br><span class="line">    Systemt.out.println(str1.intern() == str1);</span><br><span class="line">    </span><br><span class="line">    String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">    Systemt.out.println(str2.intern() == str2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码在JDK 1.6 中运行，会得到两个false（intern 方法会把首次遇到的字符串实例复制到永久代中，而StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用）；而在JDK 1.7 中会得到一个true（intern 实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此，intern返回的引用和由StringBuilder创建的字符串实例是同一个实例）一个false（“java”字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现，而“计算机软件”这个字符串则是首次出现的—这个解释没看懂，需要再次理解）。</p>
<h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>直接或者间接地使用NIO，就可能出现本机直接内存溢出。虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但是抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配。因此可以通过以下代码手动抛出异常，真正抛出异常的地方是unsafe.allocateMemory()。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码能够抛出异常的前提是，设置虚拟机参数 -XX: MaxDirectMemorySize 的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">	Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">	unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">		unsafe.allocateMemory(_1MB);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/03/22/%E9%9D%A2-%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/22/%E9%9D%A2-%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">面试题-算法-基本查找</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-22 17:49:00" itemprop="dateCreated datePublished" datetime="2019-03-22T17:49:00+08:00">2019-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-11 21:06:49" itemprop="dateModified" datetime="2020-04-11T21:06:49+08:00">2020-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="704、二分查找，给定一个-n-个元素有序的（升序）整型数组-nums-和一个目标值-target-，写一个函数搜索-nums-中的-target，如果目标值存在返回下标，否则返回-1"><a href="#704、二分查找，给定一个-n-个元素有序的（升序）整型数组-nums-和一个目标值-target-，写一个函数搜索-nums-中的-target，如果目标值存在返回下标，否则返回-1" class="headerlink" title="704、二分查找，给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1"></a>704、二分查找，给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>还没写。。。。。</p>
<p>自己写的时候的问题：<strong>这题目自己写得还不错</strong></p>
</details>

<blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search/">LeetCode</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/03/09/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC4%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/09/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC4%E7%AB%A0/" class="post-title-link" itemprop="url">第4章：操作系统基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-09 21:10:00" itemprop="dateCreated datePublished" datetime="2019-03-09T21:10:00+08:00">2019-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:48:37" itemprop="dateModified" datetime="2019-11-17T21:48:37+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="进程间通信的经典实现"><a href="#进程间通信的经典实现" class="headerlink" title="进程间通信的经典实现"></a>进程间通信的经典实现</h2><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存的工作流程：</p>
<ol>
<li>创建共享区。进程1从内存中申请一块内存作为共享区域，并且将该区域与某个Key绑定  </li>
<li>映射共享区。创建共享区之后，需要将其映射到进程1的空间中才能操作。  </li>
<li>访问共享区。进程2利用第一步得到的Key，访问到共享区，之后将这块内存映射到进程2的空间中。  </li>
<li>进程间通信。各进程实现了对共享内存的映射后，便可以利用该区域进行信息交换。（注意：整个内存过程都没有实现同步机制，需要进程间自己实现）  </li>
</ol>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li>进程A和B分立管道两端，进行数据传输通信</li>
<li>管道是单向的，如果进程既要“读”也要“写”，就需要两根管道这点很像水管的特性  </li>
<li>管道同时具有“读取”(read end)端和“写入”(write end)端，比如进程A从 write end 写入，进程 B 就可以从 read end 端读取到数据  </li>
<li>管道容量有限制，当pipe满了后，写操作将阻塞；反之，pipe空了之后，读操作将会阻塞  </li>
<li>普通的管道是<strong>匿名的</strong>，这种匿名的管道只适合有斧子关系的进程通信，如果要实现没有任何关系的管道间的通信，就需要<strong>命名管道(Named pipe)</strong></li>
</ul>
<h3 id="UNIX-DOMAIN-SOCKET"><a href="#UNIX-DOMAIN-SOCKET" class="headerlink" title="UNIX DOMAIN SOCKET"></a>UNIX DOMAIN SOCKET</h3><ul>
<li>简称UDS,也可以说是IPC Socket，与普通的Socket不一样，专门针对单机进程间通信提出来的。  </li>
<li>大家熟知的 Network Socket 是以 TCP/IP 协议栈作为基础的，需要分包、重组 等一系列操作，而 UDS 因为是本机内的“安全可靠操作”，实现机制上并不依赖于这些协议。  </li>
<li>Android 中使用最多的一种IPC就是Binder，其次就是 UDS 。  </li>
</ul>
<h3 id="RPC（REMOTE-PROCEDURE-CALLS）"><a href="#RPC（REMOTE-PROCEDURE-CALLS）" class="headerlink" title="RPC（REMOTE PROCEDURE CALLS）"></a>RPC（REMOTE PROCEDURE CALLS）</h3><p>RPC 涉及通信双方通常运行于两台不同的机器中。</p>
<h2 id="同步机制的经典实现"><a href="#同步机制的经典实现" class="headerlink" title="同步机制的经典实现"></a>同步机制的经典实现</h2><p>###信号量（SEMAPHORE）</p>
<p>信号量与PV原语是分不开的，也是最为广泛的互斥方法之一，主要包括以下几个元素：</p>
<ul>
<li>Semaphore S（信号量，用于指示共享资源的可用数量）  </li>
<li>Operation P （可以减小S计数）  </li>
<li>Operation V （可以增加S计数）  </li>
</ul>
<blockquote>
<p>P执行：S = S -1，此时判断若 S&gt;=0 ，说明资源此时允许访问，开始操作共享资源；否则，加入等待队列，待别人释放资源后唤醒。<br>V执行：S=S+1，如果此时S&gt;0，说明当前没有希望访问资源的等待者；否则，唤醒等待队列中的相关对象。<br><strong>其中，PV源于都属于原子操作，意味着他们执行过程是不允许被中断的。</strong></p>
</blockquote>
<h3 id="互斥体（MUTEX）"><a href="#互斥体（MUTEX）" class="headerlink" title="互斥体（MUTEX）"></a>互斥体（MUTEX）</h3><p>Mutex 是 Mutual Exclusion 的缩写，释义为 互斥体。如果资源允许多个对象同时访问，成为 Counting Semaphores；而如果只允许取值0或1（lock/unlocked）的Semaphore，则叫做 Binary Semaphore。Binary Semaphore 与Mutex有相同性质，Mutex通常是对某一排他资源的共享控制——要么这个资源被占用（locked），要么是可以访问的（unlocked）。</p>
<h3 id="管程（MONITOR）"><a href="#管程（MONITOR）" class="headerlink" title="管程（MONITOR）"></a>管程（MONITOR）</h3><p>针对信号量机制的程序易读性较差，并且信号量管理分散在各个参与对象中，很难维护等缺点，管程被提出来了。管程是可以被多个进程/线程安全访问的对象或者模块，管程中的方法在同一时刻只允许一个范文这使用它们（方法受 mutual exclusion 保护的）。</p>
<h2 id="操作系统内存基础"><a href="#操作系统内存基础" class="headerlink" title="操作系统内存基础"></a>操作系统内存基础</h2><p>操作系统中任何操作都与内存息息相关，内存管理的底层原理主要注意几个核心：</p>
<ul>
<li>虚拟内存</li>
</ul>
<blockquote>
<p>内存总是“不够大”的，随着应用的增加，总会填满，虚拟内存为运行更多的程序提供了可能，其基本思想是：1.将硬盘上一部分空间作为内存的扩展；2.出现资源不足时，按照一定算法挑出优先级较低的数据块移动到第1步划出的空间；3.需要用到硬盘中的数据块时，系统将产生“缺页”，之后把硬盘中的数据交换回内存中。</p>
</blockquote>
<ul>
<li>内存分配与回收</li>
</ul>
<blockquote>
<p>分配、native层回收，java层回收</p>
</blockquote>
<ul>
<li>内存保护</li>
</ul>
<blockquote>
<p>内存分页或者分段式管理。进程的逻辑地址不是直接对应物理地址的，因此没办法访问它范围外的内存空间。</p>
</blockquote>
<p><strong>顺带一提，mmap函数（Memory Map）正如其名，可以将某个设备或者文件映射到应用进程的内存空间中，这样访问这块内存就相当于对设备/文件进行读写；可见，理论上mmap可以用于进程间通信，即通过映射同一块物理内存来共享内存，这种方式因为减少了复制次数，在一定程度上提高了进程间通信效率。</strong></p>
<h2 id="Android-匿名共享内存（Ashmem）"><a href="#Android-匿名共享内存（Ashmem）" class="headerlink" title="Android 匿名共享内存（Ashmem）"></a>Android 匿名共享内存（Ashmem）</h2><p>Ashmem 全称 Anony Shared Memory，是Android 特有的内存共享机制，它可以将指定的物理内存分别映射到各个进程的地址空间，从而便捷地实现进程间的内存共享。Ashmem 是一个 misc 设备，其实现依托于 /dev/ashmem 。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/03/08/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E9%92%88%E5%AF%B9%E7%AE%80%E5%8E%86%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/08/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E9%92%88%E5%AF%B9%E7%AE%80%E5%8E%86%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">针对简历的问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-08 21:10:00" itemprop="dateCreated datePublished" datetime="2019-03-08T21:10:00+08:00">2019-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 17:12:10" itemprop="dateModified" datetime="2021-05-02T17:12:10+08:00">2021-05-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p><font color="ff0000">根据技术栈可能的提问</font></p>
<h2 id="1、聊聊-java-中-static-关键字"><a href="#1、聊聊-java-中-static-关键字" class="headerlink" title="1、聊聊 java 中 static 关键字"></a>1、聊聊 java 中 static 关键字</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>一旦什么东西设置为 static ，数据或者方法就不会同那个类的任何对象实例有联系。例如以下类：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>尽管我们可以给StaticTest 类new 出 2个对象来，但是 StaticTest.i 仍然只有一个存储空间，即两个对象共享同样的i，此时，其中一个对象执行 ++i 后，另一个对象的 i值 也会变为 48。</p>
<p>静态的变量或者方法，可以通过对象引用，也可以直接通过类引用，如以上的i，可以使用如下两种方式引用：</p>
<blockquote>
<p>假设st 是 StaticTest 类的对象： st.i = 4   或者  StaticTest.i = 4</p>
</blockquote>
</details>

<h2 id="2、Kotlin-相关"><a href="#2、Kotlin-相关" class="headerlink" title="2、Kotlin 相关"></a>2、Kotlin 相关</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="Kotlin-中的协程用过吗？聊聊？"><a href="#Kotlin-中的协程用过吗？聊聊？" class="headerlink" title="Kotlin 中的协程用过吗？聊聊？"></a>Kotlin 中的协程用过吗？聊聊？</h3><p>简单使用过，但是仅仅用于线程切换，对协程有一些简单的了解：</p>
<ul>
<li>协程是编译器级别的，进程和线程是操作系统级的</li>
<li>线程根据os的调度算法，当分配的时间片用完后，保存当前上下文，之后被强制挂起，开发者无法精确控制它们</li>
<li>协程可以看做是轻量级的用户态线程</li>
<li>协程实现的是<strong>非抢占式</strong>的调度，由当前协程控制什么时候切换到其他协程</li>
<li>每个协程池里都有一个调度器，这个<strong>调度器是被动调度的</strong>，即当前协程主动让出cpu时调度</li>
<li>目前的协程框架一般设计成 1:N 的模式，即一个线程作为容器，里面包含多个协程</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>协程轻量，创建成本小，内存消耗小    </p>
</li>
<li><p>协作式的用户态调度器，cpu上下文切换开销少    </p>
<blockquote>
<p>进程/线程 切换需要在内核完成，而协程通过用户态栈实现，速度更快，但协程也放弃了线程中优先级的概念</p>
</blockquote>
</li>
<li><p>减少同步加锁，整体性能提高    </p>
<blockquote>
<p>协程基于事件循环，减少同步加锁的频率。但若存在竞争，该上锁的地方仍需要加上协程锁    </p>
</blockquote>
</li>
<li><p>可以按照同步思维写异步代码，即用同步的逻辑，写由协程调度的回调</p>
<blockquote>
<p>协程可以减少callback 的使用，但是不能完全替代callback，基于事件驱动的变成用callback更合适</p>
</blockquote>
</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>协程中不能有阻塞操作，否则整个线程被阻塞(协程是语言级别，线程是操作系统级别)      </li>
<li>需要特别关注全部变量、对象引用的使用    </li>
<li>协程擅长处理IO密集型程序效率问题，但处理cpu密集型不是它的长处    <blockquote>
<p>假设线程中有个协程是cpu密集型，但是没有io操作，也就是一时半会不会主动触发调度器调度，从而其他协程得不到执行      </p>
</blockquote>
</li>
</ul>
<h4 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h4><ol>
<li>高性能计算，牺牲公平性换区吞吐量；          </li>
<li>在 IO 密集型程序中。由于io密集型的程序中往往需要 CPU 频繁切换线程，带来大量性能浪费。但是协程可以很好地解决这个问题：比如把一个IO操作写成一个协程，当触发IO操作时就自动让出cpu给其他协程，协程间的切换是很轻的。      </li>
<li>流式计算。消除Callback Hell。    </li>
</ol>
<h3 id="Kotlin-优势"><a href="#Kotlin-优势" class="headerlink" title="Kotlin 优势"></a>Kotlin 优势</h3><p>按照官网上的说法：</p>
<ul>
<li>简洁。语法简单，代码很少。判空、getter、setter 方法、命名传参(动态改变参数)无需重载，可能结合anko 之类的更加简单    </li>
<li>安全，减少空指针等错误、类型判断过后，自动类型转换      </li>
<li>兼容java，可以混编</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>lateinit，也容易引起空指针，即还未初始化    </li>
<li>直接使用 ArrayList 之类的list 是不能直接添加元素的，得使用 MutableList 才行     </li>
<li>引入了kotlin 支持库，apk包体积增加     </li>
<li>如果某个变量设置为可空的，那么即使你在初始化后，已经不空了，你也只能使用 ? 或者  !! 操作来使用它，感觉会有点乱     </li>
</ul>
<h3 id="kotlin如何实现空安全"><a href="#kotlin如何实现空安全" class="headerlink" title="kotlin如何实现空安全"></a>kotlin如何实现空安全</h3><ul>
<li>可空类型和不可空类型     </li>
<li>使用 ? 进行安全调用      </li>
<li>入参可以指定可空和非空类型     </li>
<li>安全的类型转换，如 a as? Int      </li>
<li>可以方便过滤非空元素，如： val intList: List<int> = nullableList.filterNotNull()      </int></li>
</ul>
<p>一定能避免空指针问题吗？我认为是不能，因为有 lateInit 变量存在，有可能这个变量还没初始化，就会导致是空的</p>
</details>

<h2 id="3、有自定义view的经验，那如何理解-MeasureSpec？"><a href="#3、有自定义view的经验，那如何理解-MeasureSpec？" class="headerlink" title="3、有自定义view的经验，那如何理解 MeasureSpec？"></a>3、有自定义view的经验，那如何理解 MeasureSpec？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>MeasureSpec 的含义是：父View传递给当前 View 的一个建议值。MeasureSpec 是个int 类型的数字，转换成二进制后，前2位代表模式(mode)，后30位代表数值(size)。模式总共分为3种：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/MeasureSpec%E6%B5%8B%E9%87%8F%E6%A8%A1%E5%BC%8F.jpg" alt="MeasureSpec测量模式"></p>
<p><strong>measureSpec &amp; MODE_MASK 即可获得mode的值；而 measureSpec &amp; ~MODE_MASK 即可获得数值</strong>。</p>
<p>那么，measureSpec 的值到底是如何计算得到的？view的 measureSpec 根据view 的布局参数(LayoutParams) 和 父容器的 MeasureSpec 值计算得到的，计算方法如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/view%E7%9A%84measureSpec%E5%80%BC.jpg" alt="view的measureSpec值"></p>
<p>由于UNSPECIFIED模式用于系统内部多次measure 的情况(如listview、gridview 等)，很少用到自定义view上，因此我们很少讨论。以下总结的规律也不讨论：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/measureSpec%E8%A7%84%E5%BE%8B.jpg" alt="measureSpec规律"></p>
<p>以上总结中，父容器的剩余空间指的是父容器除了padding之外的所剩余的空间，至于<font color="ff0000">父容器的剩余空间与大小不超过父容器的剩余空间，看代码和看图都没能理解，后续再理解吧</font></p>
<p><strong>以上内容部分<a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/94545178">参考自这个链接</a></strong></p>
</details>

<h2 id="4、聊聊-Android-中事件分发机制？"><a href="#4、聊聊-Android-中事件分发机制？" class="headerlink" title="4、聊聊 Android 中事件分发机制？"></a>4、聊聊 Android 中事件分发机制？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/">参考以前写的这篇文章</a></p>
<p>上面的文章中已经写得很明白了，但是需要重点再提一下的是，如果在 onTouchEvent 中不消耗事件，则在同一个事件序列中，当前View无法再次接到事件。</p>
</details>

<h2 id="5、如何处理手势冲突？"><a href="#5、如何处理手势冲突？" class="headerlink" title="5、如何处理手势冲突？"></a>5、如何处理手势冲突？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>有外部和内部两种方式处理手势冲突。</p>
<p><strong>外部拦截</strong>：由上面的事件分配可知，点击事件都会经过父容器拦截处理，如果父容器需要此事件就拦截，否则此事件就不拦截，这样就可以解决事件冲突。外部拦截法需要重写父容器的onInterceptTouchEvent，比较符合事件分发机制。      </p>
<blockquote>
<p>这里要注意的是，还是上面的原则，在 onInterceptTouchEvent 中，首先是ACTION_DOWN 这个事件，父容器必须返回false，即不拦截，因为一旦拦截了 ACTION_DOWN ,后续的 ACTION_MOVE 和 ACTION_UP 都没法再传递给子view了； <font color="ff0000">接下来的内容辩证看待：ACTION_MOVE根据需要是否拦截；ACTION_UP 必须返回false，因为如果返回true，那么子view 是接受不到 ACTION_UP 事件，onClick 事件就无法响应。</font></p>
</blockquote>
<p><strong>内部拦截法</strong>：</p>
<p>可以利用view事件分发的原则，在适当的地方拦截就行。</p>
<p>当然，也可以让父空间不拦截，如果是ViewGroup的话，可以在 onInterceptTouchEvent 方法中请求忽略外层容器拦截事件：getParent().requestDisallowInterceptTouchEvent(true) 。如果是View的话，那么把getParent().requestDisallowInterceptTouchEvent(true) 写在setOnTouchListener 方法中可能更合适。</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/u014628886/article/details/52222115">一骑绝尘</a>  和 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4f3e7a057cd6">前行的乌龟</a></p>
</blockquote>
<h2 id="6、如何优化App性能？"><a href="#6、如何优化App性能？" class="headerlink" title="6、如何优化App性能？"></a>6、如何优化App性能？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><strong>一、精简资源</strong>     </p>
<ul>
<li>lint检测，删除无用的资源           </li>
</ul>
<p><strong>二、减轻Application的负担</strong></p>
<ul>
<li>将非紧急操作，放在子线程中处理     </li>
<li>只在主进程中初始化app内容(因为接了百度地图等，会开启多个进程)    </li>
</ul>
<p><strong>三、UI绘制优化</strong></p>
<ul>
<li>布局优化，尽量使用 ConstraintLayout 减少布局层次(因为深度遍历)     </li>
<li>布局复用，比如底部的布局大体相似，都使用同一个 layout     </li>
<li>避免过度绘制。排查移除叠加的背景      </li>
<li>减少资源数目，因为shape很难复用，故shape换成 固定的控件： ShapedTextView、ShapedConstrainLayout 等      </li>
<li>提高显示速度</li>
</ul>
<blockquote>
<p>使用 viewstub 延后显示。         </p>
</blockquote>
<p><strong>四、内存相关优化</strong>      </p>
<blockquote>
<p>一言以蔽之： 开源节流</p>
</blockquote>
<ul>
<li>webview 新进程          </li>
<li>检查内存泄漏(LeakCanery)    </li>
<li>正确地使用引用，尤其Activity的context(尽量替换成Application 的context，Activity 的Context 一律弱引用)，以及强引用、弱引用、软引用的正确使用。       </li>
<li>使用正确的容器，比如避免自动装箱(使用SparseArray等)、避免hashmap内存浪费(使用ArrayMap等)       </li>
<li>枚举替换成注解。</li>
</ul>
<p><strong>五、cpu 相关优化</strong>   </p>
<ul>
<li>解析缓存数据一律放在子线程处理    </li>
<li>SharedPreference 存储json改动    </li>
<li>webview预加载</li>
</ul>
<p><strong>六、网络优化</strong>   </p>
<ul>
<li>域名替换成ip(选取响应速度最快的ip)，避免劫持同时提升响应速度，webview 中的网络请求由网络框架接管。    </li>
</ul>
<p><strong>七、结构</strong></p>
<ul>
<li>mvp</li>
</ul>
<p><strong>八、避开高峰</strong></p>
<ul>
<li>不要同时，充分利用IdleHandler，快速滑动的时候不加载图片</li>
</ul>
<p>具体优化方式：</p>
<blockquote>
<p>1、内存从经常性的 380M 左右降低到 330M 的水平(adb shell dumpsys com.esun.ui，现在可以使用profile)<br>2、页面秒开(talkingdata数据显示，优化前88%左右,93%的收集数据显示1秒以内打开，从onCreate 到onResume)<br>3、过度绘制(优化前几乎所有主要页面都是红色-蓝、绿、粉、红 分别代表过度绘制 1,2,3,4 次，优化后基本上都是蓝绿，粉色的比较少，红色的可能只有极少数小块)<br>4、App启动速度加快，冷启动，从3.5秒左右降低到1秒左右(录屏，记录从启动到展示flash页面，多次时间取平均值)<br>5、网络连接，网络的错误率4%(按次数统计出的)左右，dns加速后，网络错误率基本上保持，主要集中在网络超时、网络无连接两种异常，其中网络超时占了40%左右                 </p>
</blockquote>
</details>

<h2 id="引申-adb-shell-dumpsys-meminfo-com-esun-ui-中各数据含义"><a href="#引申-adb-shell-dumpsys-meminfo-com-esun-ui-中各数据含义" class="headerlink" title="引申-adb shell dumpsys meminfo com.esun.ui 中各数据含义"></a>引申-adb shell dumpsys meminfo com.esun.ui 中各数据含义</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Native Heap：  Native对象malloc得到的内存<br>Dalvik Heap：  Java对象new得到的内存<br>Dalvik Other： 类数据结构和索引占据的内存<br>Stack：        栈占用的内存(栈空间使用，如函数调用、局部变量等)<br>Pss Total：    在硬盘上实际占用的空间大小<br>Heap Size：   Heap总共内存大小 = Heap Alloc + Heap Free, HeapSize 有限制，超出阈值就oom<br>Heap Alloc：  应用所有实例分配的内存，包括应用从Zygote 共享分享的内存(只是分配的虚拟空间，并没有实际占用，比如：new long[1024*1024]，此时alloc就会新增了8M，但是由于没赋值，所以物理内存上并没有占用，如果针对每个元素赋值，则pss total 就会增加8M)<br>Heap Free：   堆空闲的大小<br>Objects： 统计App内部组件对象的个数，其中Views、ViewRootImpl以及Activities个数，在Activity的onDestroy之后应该都会清零，如果未清零，就可能发生了内存泄露</p>
<p>Private Dirty： 私有的脏内存页(还在使用中)<br>Private Clean： 私有的干净内存页(现在未使用了)<br>Private Dirty + Private Clean 便是应用曾经申请过的内存空间大小</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/37539308ff32">简书上的博客</a></p>
</blockquote>
<h2 id="7、引申-ArrayMap的原理、SparseArray原理"><a href="#7、引申-ArrayMap的原理、SparseArray原理" class="headerlink" title="7、引申-ArrayMap的原理、SparseArray原理"></a>7、引申-ArrayMap的原理、SparseArray原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h3><p>ArrayMap 相对HashMap 而言是以时间换空间。它使用两个数组，一个整数型数组存储 key 的 hashCode，另一个Object[] 类型的数组存储 key-value键值对，如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/ArrayMap%E5%8E%9F%E7%90%86.png" alt="ArrayMap原理"></p>
<p>这样的结构避免了为每个key创建额外的对象，也即避免了自动装箱(如需要将int包装成 Integer) ，每次put新元素时，key的hashcode 在hashCode的数组中按照顺序存储，object数组中存储key和value。查询元素时，首先获取key的hashCode，然后用二分法查找该hashCode 在第一个数组中的index，则在object 数组中，key的位置在 index&lt;&lt;1 处，而value在 index&lt;&lt;1 + 1 处，如果此时的key并不是当前的key，则认为发生了冲突，此时以该key为中心点，分别上下匹配，直到匹配到为止。</p>
<p>在插入删除元素时，由于是数组组织形式，因此需要移动相关的元素，因此效率并不高；但是在数据量相对较少的情况下(有些博客说是1000条数据以下)，ArrayMap 带来的时间开销并不明显，但是节省的内存却十分可观。</p>
<h3 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h3><p>SparseArray 用于key为int类型，value 为 Object 的情形，与HashMap 相比，它避免了Integer 自动装箱，并且没有依赖entry 数据结构，因此更高效。它的结构如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/SparseArray%E5%8E%9F%E7%90%86.png" alt="SparseArray原理"></p>
<p>因为key是int类型，所以也就不需要什么hash值来计算index了，只要int值相等，就是同一个对象。插入和查找也是二分法，所以原理与ArrayMap 基本上一致，所以不多说。为了提升性能，删除元素时，并不需要马上将元素置为空，而是先将其标记为一个需要删除的元素，等真正需要删除时，才清空处理。即如果要插入新数据，如果数组已经填满了，则尝试垃圾回收一下，把标记为DELETE 的对象回收，然后重新寻找key值对应的索引，并插入。</p>
<p>** 除了SparseArray 可以替代 HashMap&lt;Integer,V&gt;外，还有 SparseIntArray替换HashMap&lt;Integer,Integer&gt;、SparseLongArray替换HashMap&lt;Integer,Long&gt;、LongSparseArray 替换 HashMap&lt;Long,V&gt; **</p>
</details>

<blockquote>
<p>以上内容<a target="_blank" rel="noopener" href="https://blog.csdn.net/chewbee/article/details/72998423">可以参考这个链接</a></p>
</blockquote>
<h2 id="8、描述http-三次握手？为什么3次，2次或者4次不行？"><a href="#8、描述http-三次握手？为什么3次，2次或者4次不行？" class="headerlink" title="8、描述http 三次握手？为什么3次，2次或者4次不行？"></a>8、描述http 三次握手？为什么3次，2次或者4次不行？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先，准确地说是TCP/IP三次握手。因为http本身是应用层协议，只是因为目前http的传输层确实是TCP/IP，所以可以这么说。但是http并不依赖于tcp/ip。</p>
<p>TCP发起连接的一方A，会随机生成一个32位的序列号，比如是1000，以该序列号为原点，对自己每个将要发送的数据进行编号，连接的另一方B会对A的每次数据进行确认，如果A收到B的确认编号是2001，则意味着 1001~2000 编号已经安全到达B。握手的示意图如下所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="tcp三次握手示意图"></p>
<p>所以我们可以总结，<strong>TCP 连接握手，握的是啥？其实就是告知双方数据原点的序列号</strong>。那为什么是3次握手呢？个人认为有两个原因：</p>
<ul>
<li>确认通信双方的 接收/发送 能力是正常的。第一次握手，B可以知道自己的接收能力、A的发送能力是正常的；第二次握手，A可以知道双方的收/发能力是正常的；第三次握手，B知道双方的收/发能力都正常。       </li>
<li>节省资源。我们知道，等3次握手结束后，服务端才给这条链接分配必要端口、缓存等资源。如果是2次握手，那么在收到客户端的请求后服务端就得分配资源了，如果第2次握手由于超时丢失，那么客户端会认为服务器还未响应，可能造成两端都在等。或者客户端等到放弃这次请求，而服务端之前分配的资源会被浪费。    </li>
</ul>
<p>因此，3次握手是必需的，更多的请求次数可以，但是浪费资源，没必要。</p>
</details>

<blockquote>
<p>以上内容有部分是<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/67772889">参考知乎中的内容</a></p>
</blockquote>
<h2 id="9、延伸-http-使用80端口，如果客户端一个tcp-ip在连接，那么就无法建立其他tcp-ip连接，因为80端口在占用？"><a href="#9、延伸-http-使用80端口，如果客户端一个tcp-ip在连接，那么就无法建立其他tcp-ip连接，因为80端口在占用？" class="headerlink" title="9、延伸-http 使用80端口，如果客户端一个tcp/ip在连接，那么就无法建立其他tcp/ip连接，因为80端口在占用？"></a>9、延伸-http 使用80端口，如果客户端一个tcp/ip在连接，那么就无法建立其他tcp/ip连接，因为80端口在占用？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>不是的，80端口一般只是http应用的默认监听端口，就是说新的连接都是发送到80端口的。但是监听80端口的程序会给新建立的连接分配一个可用的端口，所以实际的这条连接可能是机那里在服务端的 10010端口，客户端的8888端口上的。而80端口会继续监听是否有新的连接到来。</p>
</details>

<h2 id="10、描述4次挥手，3次行不行？为什么？"><a href="#10、描述4次挥手，3次行不行？为什么？" class="headerlink" title="10、描述4次挥手，3次行不行？为什么？"></a>10、描述4次挥手，3次行不行？为什么？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>tcp/ip 是全双工的，client 端在没有数据需要发送给server的时候，就发送FIN 信号告知Server ，然后终止对server 的数据传输，但是server 可以继续对client 发送数据包，这时候就是4次来终止连接，过程如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/tcp%E7%9A%844%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="tcp的4次挥手"></p>
<p>但是，<strong>如果Server 收到client 的FIN 包之后，再也没有数据要发给Client 了，那么对Client 的ack 包和 Server 自己的FIN 包就能合并成一个包发送出去，4次挥手就能变成3次挥手。</strong></p>
<p>关于图中的 time_await ，它的作用主要是1、为实现TCP全双工连接的可靠释放；2、为使旧的数据包在网络因过期而消失。更详细的解释可以<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2018/05/21/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0/">参考以前的这篇文章</a></p>
</details>

<h2 id="11、了解哪些设计模式？写个单例模式？"><a href="#11、了解哪些设计模式？写个单例模式？" class="headerlink" title="11、了解哪些设计模式？写个单例模式？"></a>11、了解哪些设计模式？写个单例模式？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>单例模式         </li>
<li>建造者模式       </li>
<li>工厂模式        </li>
<li>适配器模式       </li>
<li>装饰模式        </li>
<li>观察者模式         </li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程安全的单例模式代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>{</span><br><span class="line">    <span class="comment">//注意 volatitle 关键字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> volatitle Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造函数私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>{</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class){</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>){</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
</details>

<p><font color="ff0000">以下针对项目可能的提问</font></p>
<h2 id="12、了解多线程使用，聊聊锁可以分为哪些种类"><a href="#12、了解多线程使用，聊聊锁可以分为哪些种类" class="headerlink" title="12、了解多线程使用，聊聊锁可以分为哪些种类"></a>12、了解多线程使用，聊聊锁可以分为哪些种类</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>大体可以分为，这不全部指锁的状态，有的指锁的特性，有的指锁的设计：</p>
<ul>
<li>乐观锁/悲观锁    </li>
<li>公平锁/非公平锁     </li>
<li>偏向锁    </li>
<li>轻量级锁    </li>
<li>自旋锁      </li>
<li>可重入锁    </li>
</ul>
</details>

<blockquote>
<p>具体可以<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/09/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC13%E7%AB%A0/">参考以前写的这篇博客</a></p>
</blockquote>
<h2 id="13、引申-聊聊-HandlerThread"><a href="#13、引申-聊聊-HandlerThread" class="headerlink" title="13、引申-聊聊 HandlerThread"></a>13、引申-聊聊 HandlerThread</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>HandlerThread 继承了 Thread ，所以本质上是个workThread，只不过它带了个Looper，无需开发者自己去做Looper.prepare() 操作，可以看下其关键源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        }</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>所以我们在使用的时候，首先new 出一个对象来，接着就要执行其start() 方法，以便完成 Looper 的初始化，其中，notifyAll() 主要用于方法 getLooper() 中通知 Looper 已经准备好，唤醒wait：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    wait();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>在使用完成之后，需要手动退出Thread：mHandlerThread.quit();  ，其原理不用写也知道：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>{</span><br><span class="line">    Looper looper = getLooper();</span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="keyword">null</span>) {</span><br><span class="line">        looper.quit();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从以上原理我们可以知道，HandlerThread 的使用场景就是：需要在子线程执行耗时的，并且可能有多个任务的操作(每个任务都开线程导致线程太多啊)，比如多个下载任务(非同一个任务多线程下载)，还有一个典型例子就是IntentService。</p>
</details>

<h2 id="14、延伸-IntentService"><a href="#14、延伸-IntentService" class="headerlink" title="14、延伸-IntentService"></a>14、延伸-IntentService</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>我们知道，IntentService 使用非常简单，不需要自己建立线程，执行完毕后也无需我们自己关闭Service，只需要专心在 onHandleIntent(Intent intent) 方法中实现逻辑即可。IntentService 使用<strong>工作线程</strong><font color="ff0000">逐一</font>处理所有启动请求，如果不需要在Service中执行并发任务，IntentService 是最好的选择。至于如何做到的，我们只要看关键源码即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(<span class="meta">@Nullable</span> Intent intent, <span class="keyword">int</span> startId)</span> </span>{</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>IntentService onCreate 中创建了 HandlerThread 实例，mServiceHandler 创建时使用了 HandlerThread 的 Looper，这决定了最终业务是在HandlerThread 中的子线程中执行的，在 handleMessage 方法中看到了熟悉的 onHandleIntent 方法调用，待 onHandleIntent 执行完毕后，马上执行Service 的 stopSelf(msg.arg1) 关闭自己。</p>
<p>这里使用 stopSelf(msg.arg1) 而不是 stopSelf()，而msg.arg1 即 startId，而这个 startId 就是 onStartCommand(Intent intent,int flags,int startId) 的最后一个参数。我们知道多次调用startService 来启动同一个Service ，只有第一次会执行 onCreate ，但是会多次调用onStartCommand，以及onStart(所以IntentService 中，在onStart方法里面发送Message到Handler)，并且每次 startId 并不相同，且都大于0。而stopSelf() 最终会调用 stopSelf(-1)<br>。</p>
<p>stopSelf(int startId) 中的startId 与 onStartCommand 的startId 是一一对应的关系，所以，<strong>当我们调用stopSelf(int startId)时，系统会检测是否还有其它startId 存在，有的话就不销毁当前service，没有的话则销毁。</strong></p>
<p>所以，为什么是调用stopSelf 而不是调用 stopSelf(int startId)，从上面的比较我们得出：这是为了提高 IntentService 的利用率，如果在 onHandleIntent 方法执行完毕前，又调用了startService 启动了同一个 IntentService ，那么我们就没必要销毁当前service了，直接继续使用当前service 对象执行任务即可，这样有利于减少对象的销毁及创建。再提及一句，由于是使用HandlerThread ，所以多个任务只能是串行方式依次执行。</p>
</details>

<blockquote>
<p>以上内容<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bed2efd303fe">参考俗人浮生</a> 的博客，以及 IntentService 官方源码</p>
</blockquote>
<h2 id="15、volatile-关键字有了解吗？"><a href="#15、volatile-关键字有了解吗？" class="headerlink" title="15、volatile 关键字有了解吗？"></a>15、volatile 关键字有了解吗？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>讲解之前，首先了解 原子性、可见性 以及 有序性 的基本概念：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/%E5%8E%9F%E5%AD%90%E6%80%A7-%E5%8F%AF%E8%A7%81%E6%80%A7-%E6%9C%89%E5%BA%8F%E6%80%A7%E6%A6%82%E5%BF%B5.jpg" alt="原子性-可见性-有序性概念"></p>
<p>一言以蔽之，volatile 保证可见性、有序性，但是不保证原子性。</p>
<p><strong>保证可见性：</strong>多个线程共享一个volatile变量k，如果一个线程在工作内存中修改k的值会立即刷新到主存，同时将其他线程中的该值设置成已过期，其他线程在下次使用k值时，需要从主内存刷新获取。<strong>在k值更改前就已经在使用的情形，比如k值在做加法的途中，如果k值改变，则是不受影响的，必须是下一次再次使用k的时候，才会从主存去刷新</strong>。还有要注意的是，子线程使用成员变量都会将变量从主存中拷贝一份，而不是直接使用。</p>
<p><strong>保证有序性：</strong>我们知道为了提高性能，cpu或者编译器会对代码重排序，代码的执行顺序不一定和我们写的顺序是一致的，它们只保证最终结果一致。volatile 保证读/写volatile 属性时，其前面的代码必须已经执行完成，它后面的代码也不能排到前面来执行。</p>
<p><strong>不保证原子性：</strong>也即前面提到的，比如在做加法途中，这个k值改变了，是无法改变正在做的加法中的k值的。这也是volatile 修饰变量并不是线程安全的原因。</p>
</details>

<blockquote>
<p>如果还不太了解，可以<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/09/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC12%E7%AB%A0/">参考以前写的这篇读书笔记</a>、还可以<a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/83780349">参考这篇文章，讲得很透彻</a></p>
</blockquote>
<h2 id="16、什么是大接口？"><a href="#16、什么是大接口？" class="headerlink" title="16、什么是大接口？"></a>16、什么是大接口？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>大接口就是所看到的整个页面，都是由一个接口数据决定的。当时基于的背景有几个：      </p>
<ul>
<li>这个行业决定，如果有需求，可能会要求某个版本不让用户使用了。    </li>
<li>还是行业决定，页面要求能灵活变动，随时可能某个模块没有了，或者某个tab没有了。    </li>
<li>减少接口数量，减轻后台压力，我们知道，频繁的、少量数据的接口请求对后台不友好，可能握手、header 等就能占用很大一部分资源。           </li>
</ul>
<p>怎么做的：     </p>
<p>本地有若干指定的view映射，根据后台返回，可以动态添加这些view。一般view都是占满一行，左右两边的边距确定。</p>
</details>

<h2 id="17、怎么防止劫持？"><a href="#17、怎么防止劫持？" class="headerlink" title="17、怎么防止劫持？"></a>17、怎么防止劫持？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>背景：当时有用户反馈，我们的 webview 打开慢，并且有时候弹出广告，可我们自己并没有添加广告，因此初步认定可能是运营商劫持，事实上我们在百度上搜索一下运营商劫持，就有一大把的搜索结果，看来并非我们一家。在这个基础上，分析应该是通过<strong>dns 污染导致的</strong>。</p>
<p>所以解决方案就是不使用运营商的dns，而使用119(腾讯的 119.29.29.29) 和 114(114.114.114.114) 的dns，参考网上的方案，自己写了个实现。在获取到的ip 中，随机选中一个缓存起来，缓存有效时间为15分钟。</p>
<p>在 API 的http 请求中，拦截请求，查询是否缓存该host的ip，如果有，判断是否过期。如果没有缓存或者过期，则会通过上面步骤获取ip，并把host 换成ip直连。</p>
<p>针对webview的http 类型的get请求，在WebviewClient 的 shouldInterceptRequest 回调中(执行在子线程)，使用自定义构建的网络请求(根据WebResourceRequest 的 url 以及 headers 构建 okhttp 的 okHttpRequest，其中headers也加入okHttpRequest 的headers 中)。该请求会在可能的情况下，将url替换成ip直连，获取结果后，自行重新组装 WebResourceResponse 对象return。</p>
</details>

<blockquote>
<p>https的ip直连会碰到一些问题，具体可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/leelit/article/details/77829196">别人的博客</a></p>
</blockquote>
<h2 id="18、一般走查哪些代码？"><a href="#18、一般走查哪些代码？" class="headerlink" title="18、一般走查哪些代码？"></a>18、一般走查哪些代码？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>关键代码，比如容易出现死循环的重试机制、错误上报机制、安全检测机制    </p>
</details>

<h2 id="19、如何文档归档"><a href="#19、如何文档归档" class="headerlink" title="19、如何文档归档"></a>19、如何文档归档</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>使用wiki，wiki内容包括：</p>
<ul>
<li>后端接口以及参数说明    </li>
<li>前端支持的协议以及支持的格式     </li>
<li>关键逻辑的边界和参数，如自动登录尝试的次数，防止出现死循环；网络超时时长    </li>
</ul>
<p>其他部门做业务的时候只需要看wiki就行，不用找具体的技术人员查看客户端代码     </p>
</details>

<h2 id="20、聊聊这个内部sdk的设计？"><a href="#20、聊聊这个内部sdk的设计？" class="headerlink" title="20、聊聊这个内部sdk的设计？"></a>20、聊聊这个内部sdk的设计？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>以前没有做过sdk，貌似也没地方可以参考，还有时间也很紧急，所以在技术上直接采用500里面的技术，并没有什么新意，做完之后，有小需求做的同时慢慢重构，自己得出一些经验吧：</p>
<ul>
<li>控制调用权限。只暴露几个类给用户即可，其余的类不允许用户调用。         </li>
<li>确定回调方式。1、调用接口中需要传递 activity，业务中使用用户的activity 执行activityForResult 接受业务返回数据。  2、如果使用广播，则使用本地广播                     </li>
<li>防止资源名称和宿主app冲突，资源名称添加特定前缀           </li>
<li>传入的参数各种各样，需要注意判空、检验数据格式合法性等     </li>
<li>尽量不使用第三方的类库，目前sdk中使用第三方类库，接sdk的时候要求用户添加依赖      </li>
</ul>
</details> 

<h2 id="21、最有成就感的项目？最棘手的问题？"><a href="#21、最有成就感的项目？最棘手的问题？" class="headerlink" title="21、最有成就感的项目？最棘手的问题？"></a>21、最有成就感的项目？最棘手的问题？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>最有成就感的可能就是xx app吧，接触得比较多，虽然目前的流畅度还是一般般，但是做了比较多的努力：</p>
<ul>
<li>性能优化       </li>
<li>大接口试验      </li>
<li>在以前的基础上动过网络框架和图片框架      </li>
<li>在安全上也做了一些努力     </li>
</ul>
</details> 

<h2 id="22、引申-如何重新设计网络框架？"><a href="#22、引申-如何重新设计网络框架？" class="headerlink" title="22、引申-如何重新设计网络框架？"></a>22、引申-如何重新设计网络框架？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>   

<ul>
<li>调用方式改变，不需要传递2次的 responseClass    </li>
<li>采用kotlin 的线程调度(GlobalScope.launch()) 而不是rxjava 进行线程间的切换     </li>
</ul>
</details> 

<h2 id="23、引申-安全做了哪些努力"><a href="#23、引申-安全做了哪些努力" class="headerlink" title="23、引申-安全做了哪些努力"></a>23、引申-安全做了哪些努力</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>   

<ul>
<li>在native层做app签名校验  </li>
<li>广播统一改为本地广播  </li>
<li>LeakCanary防止内存泄漏  </li>
<li>SharedPreference加密  </li>
<li>allowBackUp = false  </li>
<li>某些key生成在native代码中做  </li>
<li>https证书本地验证。</li>
</ul>
</details> 

<h2 id="24、讲一讲你看过的第三方框架的源码？"><a href="#24、讲一讲你看过的第三方框架的源码？" class="headerlink" title="24、讲一讲你看过的第三方框架的源码？"></a>24、讲一讲你看过的第三方框架的源码？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary> 

<p>可以讲讲 LeakCanary 和 阿里的框架 alpha</p>
</details>

<h2 id="25、逛哪些论坛？"><a href="#25、逛哪些论坛？" class="headerlink" title="25、逛哪些论坛？"></a>25、逛哪些论坛？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>   

<p>有逛csdn，gank.io(不过gank.io有时候更新得比较慢)，apkbus，androidweekly.cn 啊 等等。</p>
</details> 

<h2 id="26、平时关注什么技术？"><a href="#26、平时关注什么技术？" class="headerlink" title="26、平时关注什么技术？"></a>26、平时关注什么技术？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>   

<p>目前关注的就是 flutter 了</p>
</details> 

<h2 id="27、有什么想问我的"><a href="#27、有什么想问我的" class="headerlink" title="27、有什么想问我的"></a>27、有什么想问我的</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><strong>如果是hr初面：</strong>       </p>
<blockquote>
<p>这个岗位是新开设的还是原岗位人离职了？<br>这个岗位可以为公司带来什么价值？<br>想了解以下公司的培训机制和学习机制     </p>
</blockquote>
<p><strong>如果是技术人员：</strong>      </p>
<blockquote>
<p>你觉得我能胜任这个职位吗(看这一关是否通过了)？<br>感觉不好，就问：你觉得我还有哪些不足？</p>
</blockquote>
<p><strong>终面的话：</strong>     </p>
<blockquote>
<p>如果顺利，问下部门、公司的发展啦<br>如果觉得基本上没戏了，就问下自己的缺陷在哪<br>如果模棱两可，问下一步流程是怎么样的    </p>
</blockquote>
</details>   

</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/03/04/%E9%9D%A2-%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/04/%E9%9D%A2-%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">面试题-算法-基础排序</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-04 21:10:00" itemprop="dateCreated datePublished" datetime="2019-03-04T21:10:00+08:00">2019-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-22 17:22:06" itemprop="dateModified" datetime="2020-03-22T17:22:06+08:00">2020-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>思路：冒泡排序基于交换排序思想。依次比较相邻的两个数，将小数放在前面，大数放在后面。</p>
<p>即第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。之后便是重复第一趟步骤，直至全部排序完成(或者说直到某一趟没有发生交换的时候)。每一趟完成后，最后一个数肯定是最大的那个数，所以一次for循环后，会有 len – 操作，即每趟都比上一趟少比较一次。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort1</span><span class="params">(<span class="keyword">int</span>[] ints)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> len = ints.length;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag) {</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">            <span class="keyword">if</span> (ints[i - <span class="number">1</span>] &gt; ints[i]) {</span><br><span class="line">                <span class="keyword">int</span> temp = ints[i];</span><br><span class="line">                ints[i] = ints[i-<span class="number">1</span>];</span><br><span class="line">                ints[i-<span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        len -- ;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>冒泡排序在数据有序的情况下，只需要一趟即可，时间复杂度是 O(n)，在最差的情况下，每趟都有比较，时间复杂度是 O(n^2) ，平均复杂度是 O(n^2)，适合数据量较小的情况,它是稳定的排序方法，</p>
</details>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>选择排序的基本思想：每次从待排序的数据元素中选出最小(大)的一个元素，放在序列的起始位置。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; a.length - <span class="number">1</span>; i++){</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> index = i;<span class="comment">//当前趟最小的数所在index</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j &lt; a.length; j++){</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[index]){</span><br><span class="line">                index = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (index != i){</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[index];</span><br><span class="line">            a[index] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>它的时间复杂度是O(n^2)，因为它总是要循环那么多次，并且每次都是从待排序的数据中挑选最小的，因此它是不稳定的排序算法。</p>
</details>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>
插入排序的原理类似于打牌的时候抓牌，每次抓牌上来，都按照顺序将其插入到之前排好序的牌堆中。

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doInsertSort</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">1</span>; index&lt;length; index++){<span class="comment">//外层向右的index，即作为比较对象的数据的index</span></span><br><span class="line">        <span class="keyword">int</span> temp = array[index];<span class="comment">//用作比较的数据</span></span><br><span class="line">        <span class="keyword">int</span> leftindex = index-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(leftindex&gt;=<span class="number">0</span> &amp;&amp; array[leftindex]&gt;temp){<span class="comment">//当比到最左边或者遇到比temp小的数据时，结束循环</span></span><br><span class="line">            array[leftindex+<span class="number">1</span>] = array[leftindex];</span><br><span class="line">            leftindex--;</span><br><span class="line">        }</span><br><span class="line">        array[leftindex+<span class="number">1</span>] = temp;<span class="comment">//把temp放到空位上</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>时间复杂度是O(n^2)，适用于数据量较少的情况，是稳定的排序。</p>
</details>

<h2 id="shell排序"><a href="#shell排序" class="headerlink" title="shell排序"></a>shell排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>
原理： 严格来说是基于插入排序的思想，shell排序有点不大好理解，后续再看看

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路：三层循环</span></span><br><span class="line"><span class="comment"> * 第一层循环：控制增量-增量随着程序的进行依次递减一半</span></span><br><span class="line"><span class="comment"> * 第二层循环：遍历数组</span></span><br><span class="line"><span class="comment"> * 第三层循环：比较元素，交换元素。</span></span><br><span class="line"><span class="comment"> * 这里需要注意的是：比较的两个元素和交换的两个元素是不同的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> div = data.length/<span class="number">2</span>; div&gt;<span class="number">0</span>; div/=<span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = div; j &lt; data.length; j++) {</span><br><span class="line">            <span class="keyword">int</span> temp = data[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=j; k&gt;=div &amp;&amp; temp&lt;data[k-div] ; k-=div) {</span><br><span class="line">                data[k] = data[k-div];</span><br><span class="line">            }</span><br><span class="line">            data[k] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>shell排序最差的时间复杂度是 O(n^2)，平均复杂度是 O(nlogn)，是不稳定的排序</p>
</details>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>快速排序的思想是<strong>分治思想</strong>。假设我们现在对“6 1 2 7 9 3 4 5 10 8”这10个数进行排序。首先在这个序列中随便找一个数作为基准数，为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边。得到一个一个以6为中心的序列，再以6为界限，将左右两边都看成数组，分别按照刚才的方法排序。上个图会比较直观：</p>
<p><img src="/assets/%E8%B6%A3%E5%91%B3/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" alt="快速排序"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j,temp,t;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    i=low;</span><br><span class="line">    j=high;</span><br><span class="line">    <span class="comment">//temp就是基准位</span></span><br><span class="line">    temp = arr[low];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (i&lt;j) {</span><br><span class="line">        <span class="comment">//先看右边，依次往左递减</span></span><br><span class="line">        <span class="keyword">while</span> (temp&lt;=arr[j]&amp;&amp;i&lt;j) {</span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//再看左边，依次往右递增</span></span><br><span class="line">        <span class="keyword">while</span> (temp&gt;=arr[i]&amp;&amp;i&lt;j) {</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//如果满足条件则交换</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;j) {</span><br><span class="line">            t = arr[j];</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">            arr[i] = t;</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//最后将基准为与i和j相等位置的数字交换</span></span><br><span class="line">     arr[low] = arr[i];</span><br><span class="line">     arr[i] = temp;</span><br><span class="line">    <span class="comment">//递归调用左半数组</span></span><br><span class="line">    quickSort(arr, low, j-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//递归调用右半数组</span></span><br><span class="line">    quickSort(arr, j+<span class="number">1</span>, high);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>快排的平均时间复杂度是 O(nlogn) ，最坏情况下为 O(n^2)，这种交换方式导致它是不稳定的排序。</p>
</details>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>堆排序是一种<strong>选择排序</strong>。</p>
<p>堆排序时，先构建堆(假设大顶堆)，将数组转换成堆，数据在堆中是按层编号的，所以数组中一个编号为 i 的结点的子结点在 2i + 1 和 2i + 2 的位置。开始构建时，首先从最后一个非叶子结点开始(叶子结点不用调，叶子结点只是非叶子结点比较时被动移动)，最后一个非叶子节点的位置在 n/2-1。 </p>
<p>构建了大顶堆后，堆顶元素与末尾元素交换，将大元素“沉”到末尾，将除尾部以外的元素再构建大顶堆，如此循环，每次找到最大的下沉的后面。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> arrLen = arr.length;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//建立大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLen/<span class="number">2</span> -<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">        <span class="comment">//从第一个非叶子结点(在 arrLen/2 -1 处)从下至上，从右至左调整结构</span></span><br><span class="line">        adjustHeap(arr,i,arrLen);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = arrLen -<span class="number">1</span>;j &gt;= <span class="number">0</span>;j--){</span><br><span class="line">        <span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">        temp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重新对堆进行调整</span></span><br><span class="line">        adjustHeap(arr,<span class="number">0</span>,j);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>{</span><br><span class="line">    <span class="comment">//先取出当前元素i</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[start];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>*start + <span class="number">1</span>;k &lt; end;k = <span class="number">2</span>*k + <span class="number">1</span>){<span class="comment">//从i结点的左子结点(2i+1处)开始</span></span><br><span class="line">        <span class="keyword">if</span> (k + <span class="number">1</span> &lt; end &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]){<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">            k ++;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">        <span class="keyword">if</span> (arr[k] &gt; temp) {</span><br><span class="line">            arr[start] = arr[k];</span><br><span class="line">            start = k;</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    arr[start] = temp;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<p>它的最坏，最好以及平均复杂度都是 O(nlogn)，它是不稳定排序。</p>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6129630.html">他人的博客</a></p>
</details>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>归并排序是基于 分治法 实现的。目前还看不大懂，后续再理解</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//非递归算法实现二路归并排序，length代表数组长度，即数组最大下标是 legth - 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> List[],<span class="keyword">int</span> length)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> low;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> high;</span><br><span class="line">    <span class="comment">//size 是标记当前各个归并序列的high-low，从1，2，4，8，……，2*size</span></span><br><span class="line">    <span class="keyword">while</span>(size &lt;= length - <span class="number">1</span>){</span><br><span class="line">        <span class="comment">//从第一个元素开始扫描，low代表第一个分割的序列的第一个元素</span></span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前的归并算法结束的条件</span></span><br><span class="line">        <span class="keyword">while</span>(low + size &lt;= length - <span class="number">1</span>){</span><br><span class="line">            <span class="comment">//mid代表第一个分割的序列的最后一个元素</span></span><br><span class="line">            mid = low + size - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//high 代表第二个分割的序列的最后一个元素</span></span><br><span class="line">            high = mid + size;</span><br><span class="line">            <span class="comment">//判断一下：如果第二个序列个数不足size个</span></span><br><span class="line">            <span class="keyword">if</span>(high &gt; length - <span class="number">1</span>){</span><br><span class="line">                <span class="comment">//调整 high 为最后一个元素的下标即可</span></span><br><span class="line">                high = length - <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//调用归并函数，进行分割的序列的分段排序</span></span><br><span class="line">            merge(List, low, mid, high);</span><br><span class="line">            <span class="comment">//打印出每次归并的区间</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"low:"</span> &lt;&lt; low &lt;&lt; <span class="string">" mid:"</span> &lt;&lt; mid &lt;&lt; <span class="string">" high:"</span> &lt;&lt; high &lt;&lt; endl;</span><br><span class="line">            <span class="comment">//下一次归并时第一序列的第一个元素位置</span></span><br><span class="line">            low = high + <span class="number">1</span>;</span><br><span class="line">        }<span class="comment">// end of while</span></span><br><span class="line">        <span class="comment">//范围扩大一倍，二路归并的过程</span></span><br><span class="line">        size *= <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>归并的思想主要用于外部排序：<br>外部排序可分两步<br>①待排序记录分批读入内存，用某种方法在内存排序，组成有序的子文件，再按某种策略存入外存。<br>②子文件多路归并，成为较长有序子文件，再记入外存，如此反复，直到整个待排序文件有序。</p>
</blockquote>
</details>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述排序，稳定的排序有：冒泡、插入、合并 ，不稳定排序：选择、shell、快排、堆排</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/03/03/%E9%9D%A2-%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/03/%E9%9D%A2-%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">面试题-算法-二叉树遍历</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-03 20:10:00" itemprop="dateCreated datePublished" datetime="2019-03-03T20:10:00+08:00">2019-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-22 17:48:50" itemprop="dateModified" datetime="2020-03-22T17:48:50+08:00">2020-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p><img src="/assets/%E8%B6%A3%E5%91%B3/%E7%AE%97%E6%B3%95/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="先序遍历"></p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>递归方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(BTreeNode treeNode)</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(treeNode != <span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//显示节点数据</span></span><br><span class="line">        showNodeValue(treeNode);</span><br><span class="line">        <span class="comment">//先序遍历左子树</span></span><br><span class="line">        pre(treeNode.left);</span><br><span class="line">        <span class="comment">//先序遍历右子树</span></span><br><span class="line">        pre(treeNode.right)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>非递归方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归，手算的思想，先变访问边找，找到最左下方的，然后向上再向访问右边的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePreOrder</span><span class="params">(TreeNode p)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty() || p != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) {</span><br><span class="line">            visit(p);</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        }</span><br><span class="line">        p = stack.pop();</span><br><span class="line">        p = p.right;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的思想，按层次倒着进栈，利用后进先出解决顺序问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePreOrder_2</span><span class="params">(TreeNode p)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    stack.push(p);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) {</span><br><span class="line">        p = stack.pop();</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) stack.push(p.right);</span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) stack.push(p.left);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p><img src="/assets/%E8%B6%A3%E5%91%B3/%E7%AE%97%E6%B3%95/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="中序遍历"></p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>递归方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">middle</span><span class="params">(BTreeNode treeNode)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(treeNode != <span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//中序遍历左子树</span></span><br><span class="line">        middle(treeNode.left);</span><br><span class="line">        <span class="comment">//显示节点数据</span></span><br><span class="line">        showNodeValue(treeNode);</span><br><span class="line">        <span class="comment">//中序遍历右子树</span></span><br><span class="line">        middle(treeNode.right);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>非递归方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeInOrder</span><span class="params">(TreeNode p)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty() || p != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        }</span><br><span class="line">        p = stack.pop();</span><br><span class="line">        visit(p);</span><br><span class="line">        p = p.right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><img src="/assets/%E8%B6%A3%E5%91%B3/%E7%AE%97%E6%B3%95/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="后序遍历"></p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>
递归方法：

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">behind</span><span class="params">(BTreeNode treeNode)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(treeNode != <span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//后序遍历左子树</span></span><br><span class="line">        behind(treeNode.left);</span><br><span class="line">        <span class="comment">//后序遍历右子树</span></span><br><span class="line">        behind(treeNode.right);</span><br><span class="line">        <span class="comment">//显示节点数据</span></span><br><span class="line">        showNodeValue(treeNode);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>非递归方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双栈法，易于理解</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePostOrder_3</span><span class="params">(TreeNode p)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; result = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty() || p != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            result.push(p);</span><br><span class="line">            p = p.right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty()) p = stack.pop().left;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (!result.empty()) {</span><br><span class="line">        p = result.pop();</span><br><span class="line">        visit(p);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>

<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeLevelOrder</span><span class="params">(TreeNode p)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.offer(p);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        p = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) queue.offer(p.left);</span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) queue.offer(p.right);</span><br><span class="line">        visit(p);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>

<p>以上内容可以<a target="_blank" rel="noopener" href="https://www.cnblogs.com/songwenjie/p/8955856.html">参考这篇博客</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/03/02/%E9%9D%A2-%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/02/%E9%9D%A2-%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" class="post-title-link" itemprop="url">面试题-算法-经典问题解决</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-02 20:10:00" itemprop="dateCreated datePublished" datetime="2019-03-02T20:10:00+08:00">2019-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-08 12:56:35" itemprop="dateModified" datetime="2020-03-08T12:56:35+08:00">2020-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="扑克洗牌算法"><a href="#扑克洗牌算法" class="headerlink" title="扑克洗牌算法"></a>扑克洗牌算法</h2><p>打乱一个已有顺序有多种实现方式，但是要高效地实现，还需要斟酌，以下是目前能想到的最有的解决方案：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成一副牌</span></span><br><span class="line">Card[<span class="number">52</span>] oneCard = generateOneCard;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序与 随机位置交换</span></span><br><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oneCard.size(); i ++){</span><br><span class="line">    <span class="keyword">int</span> j = r.nextInt(<span class="number">52</span>);</span><br><span class="line">    Card tempCard = oneCard[i];</span><br><span class="line">    oneCard[i] = onCard[j];</span><br><span class="line">    onCard[j] = tempCard;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="判断链表中是否有环"><a href="#判断链表中是否有环" class="headerlink" title="判断链表中是否有环"></a>判断链表中是否有环</h2><p><strong>快慢指针法：</strong>创建两个指针1和2同时指向这个链表的头节点，然后两个指针分别向后移动，其中指针1每次向后移动一个节点，指针2每次向后移动两个节点，每移动一次就比较两个指针指向的节点是否相同，如果相同说明出链表有环；如果不同，则继续循环，直到有环结束或者到达尾部结束。</p>
<blockquote>
<p>原理：两个人在环形跑道上同一位置开始跑，一人速度快，一人速度慢，如此持续跑一段时间，速度快的那个肯定会从速度慢的身后再次追上以及超越，这中间必然有个交汇点。如果是跑直线的话，到终点就结束了，不会再碰面。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否有环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isLoopList</span><span class="params">(ListNode&lt;T&gt; head)</span></span>{</span><br><span class="line">    ListNode&lt;T&gt; slowPointer, fastPointer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用快慢指针，慢指针每次向前一步，快指针每次两步</span></span><br><span class="line">    slowPointer = fastPointer = head;</span><br><span class="line">    <span class="keyword">while</span>(fastPointer != <span class="keyword">null</span> &amp;&amp; fastPointer.next != <span class="keyword">null</span>){</span><br><span class="line">        slowPointer = slowPointer.next;</span><br><span class="line">        fastPointer = fastPointer.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两指针相遇则有环</span></span><br><span class="line">        <span class="keyword">if</span>(slowPointer == fastPointer){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="引申：如何判断环的入口"><a href="#引申：如何判断环的入口" class="headerlink" title="引申：如何判断环的入口"></a>引申：如何判断环的入口</h2><p>我们假定链表头到环入口的距离是len，环入口到slow和fast交汇点的距离为x，环的长度为R。slow和fast第一次交汇时，设slow走的长度为：d = len + x，而fast走的长度为：2d = len + nR + x，(n &gt;= 1)，从而我们可以得知：2len + 2x = len + nR + x，即len = nR - x，(n &gt;= 1)。所以，要找出环入口，也要两个指针，一个指针A指向相遇时候的节点，一个指针B指向链表头，两个指针每次都走一步，A指针在遍历过程中可能多次(n &gt;= 1)经过环入口节点，但当B指针第一次达到入口节点时，A指针此时必然也指向入口节点。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否有环，有环就返回入口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ListNode&lt;T&gt; <span class="title">findEntranceInLoopList</span><span class="params">(ListNode&lt;T&gt; head)</span></span>{</span><br><span class="line">    ListNode&lt;T&gt; slowPointer, fastPointer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用快慢指针，慢指针每次向前一步，快指针每次两步</span></span><br><span class="line">    <span class="keyword">boolean</span> isLoop = <span class="keyword">false</span>;</span><br><span class="line">    slowPointer = fastPointer = head;</span><br><span class="line">    <span class="keyword">while</span>(fastPointer != <span class="keyword">null</span> &amp;&amp; fastPointer.next != <span class="keyword">null</span>){</span><br><span class="line">        slowPointer = slowPointer.next;</span><br><span class="line">        fastPointer = fastPointer.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两指针相遇则有环</span></span><br><span class="line">        <span class="keyword">if</span>(slowPointer == fastPointer){</span><br><span class="line">            isLoop = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个指针从链表头开始，一个从相遇点开始，每次一步，再次相遇的点即是入口节点</span></span><br><span class="line">    <span class="keyword">if</span>(isLoop){</span><br><span class="line">        slowPointer = head;</span><br><span class="line">        <span class="keyword">while</span>(fastPointer != <span class="keyword">null</span> &amp;&amp; fastPointer.next != <span class="keyword">null</span>){</span><br><span class="line">            <span class="comment">//两指针相遇的点即是入口节点</span></span><br><span class="line">            <span class="keyword">if</span>(slowPointer == fastPointer){</span><br><span class="line">                <span class="keyword">return</span> slowPointer;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            slowPointer = slowPointer.next;</span><br><span class="line">            fastPointer = fastPointer.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="再引申，两个单链表是否相交"><a href="#再引申，两个单链表是否相交" class="headerlink" title="再引申，两个单链表是否相交"></a>再引申，两个单链表是否相交</h2><p>两个<strong>没有环的链表</strong>在某一节点相交，那么在这个节点之后的所有结点都是两个链表所共有的。如果它们相交，则最后一个结点一定是共有的，因此问题转化为：两个链表最后一个结点是否相同（时间复杂度为O(len1+len2)）。要找出相交的第一个结点，可以首先获得两个链表的长度，然后获得两个链表长度差值 K，之后长的链表指向第K个结点，短的链表从头开始，每次向后移动一个结点，再比较当前结点是否相等，第一次相等的那个结点点就是相交节点。</p>
<blockquote>
<p>代码略</p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/03/01/%E9%9D%A2-%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E7%B1%BB%E4%BC%BC%E8%A1%8C%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/01/%E9%9D%A2-%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E7%B1%BB%E4%BC%BC%E8%A1%8C%E6%B5%8B/" class="post-title-link" itemprop="url">面试题-算法-类似行测</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-01 20:10:00" itemprop="dateCreated datePublished" datetime="2019-03-01T20:10:00+08:00">2019-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-08 15:17:57" itemprop="dateModified" datetime="2020-03-08T15:17:57+08:00">2020-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p><strong>1、给100盏灯编号 1~100，开始时所有灯都是关着的<br>第1次：把所有编号是1的倍数的灯的开关状态改变一次；<br>第2次：把所有编号是2的倍数的灯的开关状态改变一次；<br>第3次，把所有编号是3的倍数的灯的开关状态改变一次；<br>…<br>第100次，把所有编号是100的倍数的灯的开关状态改变一次；<br>问：最后开着的灯的编号是哪些？</strong></p>
<blockquote>
<p>分析：最开始灯是灭的，因此只有经过<strong>奇数</strong>次开关状态改变，灯才会是亮的。从题意可知一个数字有多少约数就会状态改变多少次，因此这道题可以转换为：<strong>1~100数字中约数个数是奇数的有哪些</strong>。并且我们知道约数是成对出现的，如8的约数：（1，8）、（2，4），因此如果要出现约数的个数是奇数个，除非它是个平方数，如36的约数：（1，36）、（2，18）、（3，12）、（4，9）、（6），因此，这题又可以转换为<strong>1~100数字中的平方数有哪些</strong>，这操作。。。。666吧，这就是分析问题的乐趣吧</p>
</blockquote>
<p><strong>2、烧一根不均匀的绳子，从头烧到尾总共需要1小时，现在有若干条这样的绳子，问如何用烧绳子的方法来计时1小时15分钟呢</strong></p>
<blockquote>
<p>从题目知道，绳子不均匀，不能根据燃烧半根来计量半小时。但是还可以推断，从两头烧，只要半小时。因此可以使用3根绳子来计时：1）第1根绳子点燃两端，第2根绳子点燃一端，第三根绳子先不点燃； 2）第1根绳子烧完计时30分钟，接着第2根绳子另一端也点燃 3）第2根绳子烧完计时15分钟，此时已经计时45分钟了，剩下的半小时只需要将第3条绳子两端点燃就能计算出。</p>
</blockquote>
<p><strong>3、有12个外观一样的小球，但有一个与其他小球重量略微不同，用手感觉不出来，用一个天平，能称3次就能找到那个小球吗</strong></p>
<blockquote>
<p>把小球编号 1<del>12，然后分为3组（想想为什么是3组）：1</del>4分为A组，5<del>8分为B组，9</del>12分为C组。首先A组和B组称量比较：<br>1、天平平衡。则目标小球在C组。将C分为两组：9、10、11分为一组C1，12分为一组C2，再从B中随意拿出3个球分组为B1，C1和B1比较：<br>    1）若平衡，则12号球就是目标球。<br>    2）若不平衡，则目标球在C1内，并且根据天平倾斜，可以判断目标球比普通球重还是轻（若是天平显示B1重，则目标球比较轻；反之目标球比较重），此时随意取 C1 中的2个球放在天平上即可知道结果（如果平衡，则目标球是另一个，如果不平衡，根据轻重可知目标球）。<br>2、天平不平衡。则目标球在A或者B中。<br>    1）若A &gt; B,取（1，2，3，5）为一组X,(4,9,10,11)为一组Y，（6，7，8）为一组Z，比较X和Y，若X&gt;Y，可知不同小球在1，2，3中，且目标球重于普通球，此时再将编号 1，2，3 任取2个放上天平即可知道目标球。若X&lt;Y,则说明4号是目标球；若X=Y，则目标球在Z中（6，7，8），并且目标球轻于普通球，此时只需要将编号 其中任意两个球放上天平即可找出目标球。<br>    2）若 A &lt; B，同样按照上述分为X、Y、Z三组，同理，若X&lt;Y，则目标球在1，2，3中，且目标球轻于普通球，此时再将编号 1，2，3 任取2个放上天平即可知道目标球；若X&gt;Y,说明4号为目标球，若X=Y，则目标球在Z中（6，7，8），并且目标球重于普通球，此时再将编号 6，7，8 任取2个放上天平即可知道目标球。</p>
</blockquote>
<p><strong>3、一笔画出经过9个点的4条直线</strong></p>
<blockquote>
<p>主要是要突破点，不要局限于点上，不说了，直接上图：<br>9点4线</p>
</blockquote>
<p><img src="/assets/%E8%B6%A3%E5%91%B3/9point-4line.png" alt="9点4线"></p>
<p><strong>4、有1块钱1瓶的契税，喝完后2个空瓶换一瓶汽水，问有20块钱，可以喝几瓶汽水？</strong></p>
<blockquote>
<p>总共40瓶（不要浪费最后那个空瓶，找老板借1个，凑2瓶子再喝一瓶，最后这空瓶还给老板。。。）</p>
</blockquote>
<p><strong>5、时针分针秒针重合的次数</strong></p>
<blockquote>
<p>只有2次，一次是 00:00:00 一次是 12：00：00</p>
</blockquote>
<p><strong>假设排列100个球，两个人轮流一拿球装入口袋，能拿到第100个球为胜，条件是每次拿球至少拿1个，最多拿5个，加入你是最先拿球的人，你该拿几个，以后怎么保证拿到最后一个球？</strong></p>
<blockquote>
<p>怎样保证拿到最后一个球呢？最简单的方法是最后剩下6个，并且轮到对方来拿，这样无论对方拿几个，都能保证自己拿到最后一个。<br>（1）首先，要控制每一轮拿出的个数，但是对方拿的个数是不受控制的，假设对方拿n个，自己就拿6-n个（为什么是控制总数是6个，是因为对手最多拿5个，自己最少能拿1个，和值就是6，自己不能把和值控制得更低；而对手至少拿1个，自己最多拿5个，同样自己不能把和值控制得更高。因此只有6才是一个可控的值）。<br>（2）其次，假设第一次拿x个球，以后每次自己和对方拿的和是6，最多可以拿到15轮（除去第一轮的x个，最后留这肯定少于10个了），还剩 10-x个，为了达到之前定的目标最后留6个，所以x应该是4.<br>（3）总结而言就是第一次拿4个，以后每次对方拿了n个后，自己拿 6-n 个。</p>
</blockquote>
<h3 id="如何确定用户异地登陆。"><a href="#如何确定用户异地登陆。" class="headerlink" title="如何确定用户异地登陆。"></a>如何确定用户异地登陆。</h3></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/02/25/%E9%9D%A2-%E7%9F%A5%E8%AF%86/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/25/%E9%9D%A2-%E7%9F%A5%E8%AF%86/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Android 事件分发机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-25 22:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T22:00:00+08:00">2019-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-22 16:43:26" itemprop="dateModified" datetime="2021-02-22T16:43:26+08:00">2021-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%93%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">专题</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h1 id="Android-事件分发机制"><a href="#Android-事件分发机制" class="headerlink" title="Android 事件分发机制"></a>Android 事件分发机制</h1><p>当我们点击屏幕时，事件最先传递给Activity ，在 Activity 的dispatchTouchEvent() 回调中，默认首先调用 getWindow().superDispatchTouchEvent(ev) 将事件交给window 处理，如果window 返回true之后，则直接return true。在 getWindow().superDispatchTouchEvent(ev) 调用的时候，我们能发现事件一步步传递：</p>
<p>1、PhoneWindow.superDispatchTouchEvent<br>2、DecorView.dispatchTouchEvent()<br>3、ViewGroup. dispatchTouchEvent()     </p>
<p>之后，就进入了ViewGroup的事件分发流程。用一张图(这张图转载自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/38015afcdb58">Carson_Ho</a>)来描绘下整体的过程：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/Activity%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B.webp" alt="Activity事件分发"></p>
<p>接下来主要关注的是 Android 中 ViewGroup 事件分发机制。它总体来说可以用几张图说明白，相比在代码中打印Log，这种方式更容易理解和记住。</p>
<h2 id="针对-ACTION-DOWN-事件"><a href="#针对-ACTION-DOWN-事件" class="headerlink" title="针对 ACTION_DOWN 事件"></a>针对 ACTION_DOWN 事件</h2><p>只针对 ACTION_DOWN 事件时，事件的完整流向是一个U形图，如下图所示：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/down-all.png" alt="只考虑ACTION_DOWN 事件时事件流向图"></p>
<p>如果没有中断事件，可能看起来更直观一些，Activity、ViewGroup、View的层次更加清晰：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/down-u.png" alt="不中断事件"></p>
<h2 id="针对-ACTION-MOVE-和-ACTION-UP"><a href="#针对-ACTION-MOVE-和-ACTION-UP" class="headerlink" title="针对 ACTION_MOVE 和 ACTION_UP"></a>针对 ACTION_MOVE 和 ACTION_UP</h2><p>上面讲解的都是针对ACTION_DOWN的事件传递，ACTION_MOVE和ACTION_UP在传递的过程中并不是和ACTION_DOWN 一样，你在执行ACTION_DOWN的时候返回了false，后面一系列其它的action就不会再得到执行了。简单的说，就是当dispatchTouchEvent在进行事件分发的时候，只有前一个事件（如ACTION_DOWN）返回true，才会收到ACTION_MOVE和ACTION_UP的事件。</p>
<h3 id="ViewGroup1-的dispatchTouchEvent-中返回true消费事件"><a href="#ViewGroup1-的dispatchTouchEvent-中返回true消费事件" class="headerlink" title="ViewGroup1 的dispatchTouchEvent 中返回true消费事件"></a>ViewGroup1 的dispatchTouchEvent 中返回true消费事件</h3><p>红色的箭头代表ACTION_DOWN 事件的流向，蓝色的箭头代表ACTION_MOVE 和 ACTION_UP 事件的流向：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-1.png" alt="viewgroup1消费"></p>
<h3 id="ViewGroup2-的dispatchTouchEvent-中返回true消费事件"><a href="#ViewGroup2-的dispatchTouchEvent-中返回true消费事件" class="headerlink" title="ViewGroup2 的dispatchTouchEvent 中返回true消费事件"></a>ViewGroup2 的dispatchTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-2.png" alt="viewgroup2消费"></p>
<blockquote>
<p>在View 的dispatchTouchEvent 返回true消费事件,就不画图了，效果和在ViewGroup2 的dispatchTouchEvent return true的差不多，同样的收到ACTION_DOWN 的dispatchTouchEvent函数都能收到 ACTION_MOVE和ACTION_UP。</p>
</blockquote>
<h3 id="在View-的onTouchEvent-中返回true消费事件"><a href="#在View-的onTouchEvent-中返回true消费事件" class="headerlink" title="在View 的onTouchEvent 中返回true消费事件"></a>在View 的onTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-3.png" alt="在View 的onTouchEvent 中返回true消费事件"></p>
<h3 id="在ViewGroup-2-的onTouchEvent-中返回true消费事件"><a href="#在ViewGroup-2-的onTouchEvent-中返回true消费事件" class="headerlink" title="在ViewGroup 2 的onTouchEvent 中返回true消费事件"></a>在ViewGroup 2 的onTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-4.png" alt="在ViewGroup 2 的onTouchEvent 中返回true消费事件"></p>
<h3 id="在ViewGroup-1-的onTouchEvent-中返回true消费事件"><a href="#在ViewGroup-1-的onTouchEvent-中返回true消费事件" class="headerlink" title="在ViewGroup 1 的onTouchEvent 中返回true消费事件"></a>在ViewGroup 1 的onTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-5.png" alt="在ViewGroup 1 的onTouchEvent 返回true消费这次事件"></p>
<h3 id="在View的dispatchTouchEvent-中返回false并且ViewGroup-1-的onTouchEvent-返回true消费事件"><a href="#在View的dispatchTouchEvent-中返回false并且ViewGroup-1-的onTouchEvent-返回true消费事件" class="headerlink" title="在View的dispatchTouchEvent 中返回false并且ViewGroup 1 的onTouchEvent 返回true消费事件"></a>在View的dispatchTouchEvent 中返回false并且ViewGroup 1 的onTouchEvent 返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-6.png" alt="在View的dispatchTouchEvent 返回false并且Activity 的onTouchEvent 返回true消费这次事件"></p>
<h3 id="在View的dispatchTouchEvent-中返回false并且Activity-的onTouchEvent-返回true消费事件"><a href="#在View的dispatchTouchEvent-中返回false并且Activity-的onTouchEvent-返回true消费事件" class="headerlink" title="在View的dispatchTouchEvent 中返回false并且Activity 的onTouchEvent 返回true消费事件"></a>在View的dispatchTouchEvent 中返回false并且Activity 的onTouchEvent 返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-7.png" alt="在View的dispatchTouchEvent 返回false并且Activity 的onTouchEvent 返回true消费这次事件"></p>
<p>经过这么多图能得出以下规律：</p>
<blockquote>
<p>ACTION_DOWN事件在哪个控件消费了（return true）， 那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。</p>
</blockquote>
<p>以上文章参考自 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e99b5e8bd67b">Kelin</a> ,这里图片形式贴出来仅仅只是个人做的笔记，方便记忆。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">153</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共347.2k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/13/',]
      });
      });
  </script>


</body>
</html>
