<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/9/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">38</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">218</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/22/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC6%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/22/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC6%E7%AB%A0/" class="post-title-link" itemprop="url">第6章：AQS 抽象同步器的核心原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-22 22:24:00 / 修改时间：22:30:29" itemprop="dateCreated datePublished" datetime="2023-02-22T22:24:00+08:00">2023-02-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>前面介绍在激烈争用的情况下，CAS 自旋实现的轻量级锁会有<strong>两大问题：</strong></p>
<ul>
<li>CAS 恶性空自旋会浪费大量 CPU 资源</li>
<li>某些架构 CPU 上可能会导致 “总线风暴“</li>
</ul>
<p>解决这些问题的常见方案有 2 种： </p>
<ul>
<li>分散操作热点</li>
<li>使用队列削峰</li>
</ul>
<p>JUC 使用队列削峰方案解决 CAS 性能问题，提供了一个<strong>基于双向队列的削峰基类——抽象基础类 AbstractQueuedSynchronizer（抽象同步器类，简称 AQS）</strong> 。JUC 中许多类都是基于AQS构建：例如ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock、FutureTask等。</p>
<h2 id="6-1-锁与队列的关系"><a href="#6-1-锁与队列的关系" class="headerlink" title="6.1 锁与队列的关系"></a>6.1 锁与队列的关系</h2><p>第5章介绍了 CLH ，它用了FIFO的单项队列；AQS 是 CLH 的一个变种，主要原理差不多，用的是 FIFO 的双向链表，<strong>这样做的好处就是可以从任意一个节点开始很方便地访问前驱和后继节点</strong>。</p>
<h2 id="6-2-AQS-的核心成员"><a href="#6-2-AQS-的核心成员" class="headerlink" title="6.2 AQS 的核心成员"></a>6.2 AQS 的核心成员</h2><h3 id="6-2-1-状态标志位"><a href="#6-2-1-状态标志位" class="headerlink" title="6.2.1 状态标志位"></a>6.2.1 状态标志位</h3><p>AQS 中维持了一个单一的 volatile 修饰 int 类型的状态信息 state ，它标记了锁的状态，默认初始状态 0 为未锁定状态。同时，提供了 <strong>compareAndSetState</strong> 原子设置方法来设置 state 的值。</p>
<p>当线程 A 通过 tryAcquire() 获取到独占锁并将 state 加一后，其他线程通过 tryAcquire 获取锁就会失败(执行compareAndSet(0,1)会失败)，直到 A 释放了锁为止，其他线程才能获取锁。</p>
<p>AQS 继承了 AbstractOwnableSynchronizer ，父类中有个当前占用该锁的线程的变量  exclusiveOwnerThread：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示当前占用该锁的线程</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-2-2-队列节点类-Node"><a href="#6-2-2-队列节点类-Node" class="headerlink" title="6.2.2 队列节点类 Node"></a>6.2.2 队列节点类 Node</h3><p>AQS 是一个虚拟队列，不存在队列实例，仅存在节点之间的前后关系，Node 的主要成员如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点状态：值为SIGNAL、CANCELLED、CONDITION、PROPAGATE、0 </span></span><br><span class="line">    <span class="comment">//普通的同步节点的初始值为0，条件等待节点的初始值为CONDITION（-2）</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点所对应的线程，为抢锁线程或者条件等待线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前驱节点，当前节点会在前驱节点上自旋，循环检查前驱节点的waitStatus状态</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若当前Node不是普通节点而是条件等待节点，则节点处于某个条件的等待队列上</span></span><br><span class="line">    <span class="comment">//此属性指向下一个条件等待节点，即其条件队列上的后继节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>解释一下 waitStatus 变量中的几个值：</p>
<ul>
<li>CONDITION ：waitStatus 取这个值时，表示该线程（调用了Condition 的 awati 方法后）在条件队列中阻塞(Condition 有使用)，当持有锁的线程调用了 Condition 的 signal() 方法后，节点会从该 Condition 的等待队列转移到该锁的同步队（也就是AQS的FIFO双向队列）列中去竞争锁。</li>
<li>PROPAGATE：waitStatus 取这个值时，表示下一个线程获取共享锁后，自己的共享状态会被无条件传播下去，因为共享锁可能出现有N个锁可用，这时直接让后面 N 个节点都来工作。这种状态在 CountDownLatch 中用到了</li>
</ul>
<h3 id="6-3-1-模板模式"><a href="#6-3-1-模板模式" class="headerlink" title="6.3.1 模板模式"></a>6.3.1 模板模式</h3><p>这种模式值得看下，AQS 也使用这种模式</p>
<h2 id="6-4-通过-AQS-实现一把简单的独占锁"><a href="#6-4-通过-AQS-实现一把简单的独占锁" class="headerlink" title="6.4 通过 AQS 实现一把简单的独占锁"></a>6.4 通过 AQS 实现一把简单的独占锁</h2><p>基于 AQS 实现一个简单的<strong>非公平的独占锁</strong> SimpleMockLock：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMockLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>{</span><br><span class="line">    <span class="comment">//同步器实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的内部类：同步器</span></span><br><span class="line">    <span class="comment">// 直接使用 AbstractQueuedSynchronizer.state 值表示锁的状态</span></span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.state=1 表示锁没有被占用</span></span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.state=0 表示锁没已经被占用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>{</span><br><span class="line">        <span class="comment">//钩子方法</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">            <span class="comment">//CAS更新状态值为1</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//钩子方法</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">            <span class="comment">//如果当前线程不是占用锁的线程</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) {</span><br><span class="line">                <span class="comment">//抛出非法状态的异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果锁的状态为没有占用</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">//抛出非法状态的异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//接下来不需要使用CAS操作，因为下面的操作不存在并发场景</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//设置状态</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式锁的抢占方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="comment">//委托给同步器的acquire()抢占方法</span></span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式锁的释放方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="comment">//委托给同步器的release()释放方法</span></span><br><span class="line">            sync.release(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 省略其他未实现的方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="6-5-AQS-锁抢占的原理"><a href="#6-5-AQS-锁抢占的原理" class="headerlink" title="6.5 AQS 锁抢占的原理"></a>6.5 AQS 锁抢占的原理</h2><p>文中前面讲了一大堆，实在没法梳理各个章节的联系，云里雾里的，直到用 ReentrantLock 来讲这个过程，就清晰了，所以前面一些内容略过。</p>
<p>直接以 ReentrantLock 抢锁来说明整个抢锁流程，ReentrantLock 有2种模式：公平锁 和 非公平锁。</p>
<h3 id="6-8-1-ReentrantLock-非公平锁的抢占流程"><a href="#6-8-1-ReentrantLock-非公平锁的抢占流程" class="headerlink" title="6.8.1 ReentrantLock 非公平锁的抢占流程"></a>6.8.1 ReentrantLock 非公平锁的抢占流程</h3><p>ReentrantLock 为非公平所实现了一个内部的同步器——NonfairSync ，其显式锁获取方法 lock() 源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平抢占</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>非公平性就体现在这里：<strong>如果占用锁的线程刚释放锁，state 为 0，而队列中排队等待锁的线程还未唤醒，新来的线程就直接抢占了该锁，那么就插队了</strong>。举个例子：假设 A、B 线程在排队等锁，但是此时不在队列中的 C 直接进行 CAS 操作成功了，拿到锁开开心心返回了，那么 A、 B 只能乖乖看着。</p>
<h3 id="6-8-4-ReentrantLock-公平锁的抢占流程"><a href="#6-8-4-ReentrantLock-公平锁的抢占流程" class="headerlink" title="6.8.4 ReentrantLock 公平锁的抢占流程"></a>6.8.4 ReentrantLock 公平锁的抢占流程</h3><p>ReentrantLock 为公平所实现了一个内部的同步器——FairSync ，其显式锁获取方法 lock() 源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其核心思想是通过 AQS 模板方法 acquire 进行队列入队操作。</p>
<h3 id="6-8-5-AQS模板方法-acquire-arg"><a href="#6-8-5-AQS模板方法-acquire-arg" class="headerlink" title="6.8.5 AQS模板方法 acquire(arg)"></a>6.8.5 AQS模板方法 acquire(arg)</h3><p>自己调整的章节，本来这节在前面，但是放前面又看不懂，用意也不太明确。</p>
<p>acquire(arg) 方法是 AQS 提供的<strong>利用独占的方式获取资源的方法</strong>，源码实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>它的含义是：<strong>如果通过 tryAcquire(arg)方法尝试成功，则直接返回，表示已经抢到锁；否则，将线程加入等待队列。</strong></p>
<h3 id="6-8-6-AQS模板方法-tryAcquire-arg"><a href="#6-8-6-AQS模板方法-tryAcquire-arg" class="headerlink" title="6.8.6 AQS模板方法 tryAcquire(arg)"></a>6.8.6 AQS模板方法 tryAcquire(arg)</h3><p>在 ReentrantLock 中，在公平锁状态和非公平锁状态下， tryAcquire 的实现是不一样的。</p>
<ul>
<li>公平锁状态下会判断是否是队头，是队头就允许CAS获取锁；如果不是就判断是否是重入，重入允许进入；否则就返回了false了（自己看代码总结的）；</li>
<li>非公平状态下还是会直接 CAS 抢锁了，不管队头这些了，这也是非公平锁的行为体现</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/18/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/18/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">第5章：JUC显式锁的原理与实战</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-18 15:54:00" itemprop="dateCreated datePublished" datetime="2023-02-18T15:54:00+08:00">2023-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-22 22:36:01" itemprop="dateModified" datetime="2023-02-22T22:36:01+08:00">2023-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="5-1-显式锁"><a href="#5-1-显式锁" class="headerlink" title="5.1 显式锁"></a>5.1 显式锁</h2><p>使用 Java内置锁 时，无需通过 Java 代码显式地对同步对象的监视器进行抢占和释放，使用起来非常方便。但是不具备一些比较高级的锁功能：</p>
<ul>
<li><p>限时抢锁：设置超时时长，不至于无限等下去</p>
</li>
<li><p>可中断抢锁：抢锁时，外部线程给抢锁线程发一个中断信号，就能唤起等待锁的线程，并终止抢占过程</p>
</li>
<li><p>多个等待队列：为锁维持多个等待队列，以提高锁的效率。比如生产者-消费者模式中，生产者和消费者公用一把锁，锁上维持2个队列：一个生产队列和一个消费者队列</p>
</li>
</ul>
<h3 id="5-1-3-使用显式锁的模板代码"><a href="#5-1-3-使用显式锁的模板代码" class="headerlink" title="5.1.3 使用显式锁的模板代码"></a>5.1.3 使用显式锁的模板代码</h3><p>因为 JUC 中的显式锁都实现了 Lock 接口，所以不同类型的显式锁对象使用的方法都是模板化的、套路化的，模板代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建锁对象，SomeLock 为 Lock 的某个实现类，如 ReentrantLock</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> SomeLock();</span><br><span class="line"><span class="comment">//step 1： 抢占锁</span></span><br><span class="line">lock.lock;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//step2 ： 抢锁成功，执行临界区代码</span></span><br><span class="line">    doSomething();</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    lock.unlock(); <span class="comment">//step3： 释放锁</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>模板代码有几个需要注意的点：</p>
<ul>
<li><p>释放锁操作 unlock 必须在 try-catch 的finally 中执行，否则如果临界区代码抛出异常，锁就可能永远也得不到释放了</p>
</li>
<li><p>抢占锁的操作<strong>lock 必须在 try 语句之外</strong>，原因：lock 方法不一定能够抢锁成功（我猜测作者是想说 tryLock() 之类的方法不一定会获取成功），如果没有抢占到锁，也肯定不需要释放锁，<strong>在没有占有锁的情况下释放锁可能导致异常</strong>。</p>
</li>
<li><p>在抢占锁操作 lock 和 try 语句之间不要插入任何代码，避免抛出异常而无法执行到 try，进而无法释放锁。</p>
</li>
</ul>
<h3 id="5-1-4-基于显式锁进行“等待-通知”方式的线程间通信"><a href="#5-1-4-基于显式锁进行“等待-通知”方式的线程间通信" class="headerlink" title="5.1.4 基于显式锁进行“等待-通知”方式的线程间通信"></a>5.1.4 基于显式锁进行“等待-通知”方式的线程间通信</h3><p>Java 内置锁可以通过 Object 的 wait 和 notify 方法来实现简单的线程间通信，与此类似的是，基于 Lock 显式锁，JUC 也提供了一个用于线程间通信的接口 Condition</p>
<p>Condition 接口有2类主要方法：</p>
<ul>
<li>await() ： 在功能上与 Object.wait() 语意等效，线程会加入 await() 等待队列，<strong>并释放当前锁</strong></li>
<li>signal() ： 在功能上与 Object.notify() 语意等效，唤醒 await() 等待队列中的线程</li>
</ul>
<blockquote>
<p>为了避免与 Object 中的 wait/notify 2类方法在使用时发生混淆，JUC 对 Condition 接口方法改了名称，成为了 await/signal。Condition 对象的 signal 和<strong>同一个对象的 await 是一一配对使用的</strong>。</p>
</blockquote>
<p><strong>Condition 对象是基于显式锁的，所以不能独立创建 Condition 对象，可以通过 lock.newCondition() 方法获取</strong>一个与当前显式锁绑定的 Condition 对象。用法举例如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitTarget</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        lock.lock();<span class="comment">//抢锁</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            print(<span class="string">"开始等待"</span>);</span><br><span class="line">            condition.await();<span class="comment">//开始等待，并且释放锁</span></span><br><span class="line">            print(<span class="string">"收到通知，开始继续执行"</span>);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用 await 方法前必须要先获取锁，await 方法会让当前线程加入 Condition 的等待队列，同理， signal 方法也要在获取锁之后才能调用，调用 signal 之后一定要释放锁，只有这样被唤醒的等待线程才能抢锁。</p>
<h3 id="5-1-5-LockSupport"><a href="#5-1-5-LockSupport" class="headerlink" title="5.1.5 LockSupport"></a>5.1.5 LockSupport</h3><p>LockSupport 是JUC 提供的一个 <strong>线程阻塞与唤醒的工具类</strong>。大体有2类方法(阻塞和唤醒)：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无限期阻塞当前线程</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span></span>; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 唤醒某个被阻塞的线程</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>一个简单的演示的实例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitTarget</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            print(<span class="string">"即将进入阻塞"</span>);</span><br><span class="line">            LockSupport.park();<span class="comment">//阻塞当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) {</span><br><span class="line">                print(<span class="string">"被中断了"</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                print(<span class="string">"被重新唤醒"</span>);</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-1-5-1-LockSupport-park-的对比（自己改的标题）"><a href="#5-1-5-1-LockSupport-park-的对比（自己改的标题）" class="headerlink" title="5.1.5.1 LockSupport.park() 的对比（自己改的标题）"></a>5.1.5.1 LockSupport.park() 的对比（自己改的标题）</h4><p>1、与 Thread.sleep() 的区别</p>
<ul>
<li>Thread.sleep() 只能自己醒来，没法外部唤醒；LockSupport.park() 可以通过 unpark 唤醒</li>
<li>Thread.sleep() 声明了中断异常(InterruptedException) ，而LockSupport.park() 没有</li>
<li>被中断的时候，虽然线程都会被设置中断标记，但是线程表现不同：sleep 会抛异常，park 不会</li>
</ul>
<p>2、与 Object.wait() 的区别</p>
<ul>
<li>wait 需要在同步块中执行，park 可以在任意地方执行</li>
<li>当阻塞线程被中断时，wait 方法抛出中断异常；而park 不会抛出异常</li>
<li>如果没有调用过 wait 而直接执行 notify 会导致 IllegalMonitorStateException异常；而未做park 直接做 unpark 不会有任何异常</li>
</ul>
<blockquote>
<p>自己看了下 LockSupport 的源码，发现 park 和 unpark 都是 native 方法，所以在代码层面就没对比了</p>
</blockquote>
<h3 id="5-1-6-显式锁分类"><a href="#5-1-6-显式锁分类" class="headerlink" title="5.1.6 显式锁分类"></a>5.1.6 显式锁分类</h3><p>从多个维度分类： 可重入、悲观/乐观、公平、共享/独占、可中断/不可中断</p>
<h3 id="5-2-2-通过-CAS-实现乐观锁"><a href="#5-2-2-通过-CAS-实现乐观锁" class="headerlink" title="5.2.2 通过 CAS 实现乐观锁"></a>5.2.2 通过 CAS 实现乐观锁</h3><p>乐观锁通过 CAS 实现主要就是两个步骤：</p>
<ol>
<li>冲突检测 （CAS 检测内存位置 V 的值是否为 A）</li>
<li>数据更新 (CAS 上述检测如果是，则将位置 V 更新为 B 值，否则不更改)</li>
</ol>
<p>在实际使用中，仅仅进行一次 CAS 是不够的，一般情况下需要不断循环重试直到CAS 操作成功，也即<strong>自旋</strong></p>
<blockquote>
<p>乐观锁是一种思想，CAS 是这种思想的一种实现</p>
</blockquote>
<p>作为演示，这里设计一个简单版本的不可重入（如果需要重入就count计数，这里不贴例子了）的自旋锁：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前锁的拥有者</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//书中的例子这里是写错了，它写成 while(owner.compareAndSet(null, t))</span></span><br><span class="line">        <span class="keyword">while</span>(!owner.compareAndSet(<span class="keyword">null</span>, t)) {<span class="comment">//循环竞争锁</span></span><br><span class="line">            <span class="comment">//没获取到锁，让出cpu</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span>(t == owner.get()) {</span><br><span class="line">            owner.set(<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-2-5-CAS-可能导致“总线风暴”"><a href="#5-2-5-CAS-可能导致“总线风暴”" class="headerlink" title="5.2.5 CAS 可能导致“总线风暴”"></a>5.2.5 CAS 可能导致“总线风暴”</h3><p>为了保障“缓存一致性”，不同的内核需要通过总线来回通信，使用 lock 前缀（用于内存屏障）指令的 Java 操作（比如CAS、volatile）会产生缓存一致性流量，很多线程同时执行lock前缀操作时，会在总线上产生过多的流量，也就是 “总线风暴”。</p>
<p>那么，基于 JUC 实现的轻量级锁怎么避免总线风暴？答案是：使用队列对抢锁线程进行排队。</p>
<h3 id="5-2-6-CLH自旋锁"><a href="#5-2-6-CLH自旋锁" class="headerlink" title="5.2.6 CLH自旋锁"></a>5.2.6 CLH自旋锁</h3><p>CLH锁就是一种基于队列排队的自旋锁（由3个发明人的名字命名的），AQS 也是基于这种原理，为了说明其原理，这里实现一个 CLH 锁的学习版本，并不是真正的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点的线程本地变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Node&gt; curNodeLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CLHLock队列的尾部指针，使用AtomicReference，方便进行</span></span><br><span class="line"><span class="comment">     * CAS操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Node&gt; tail = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CLHLock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//设置尾部节点</span></span><br><span class="line">        tail.getAndSet(Node.EMPTY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁操作：将节点添加到等待队列的尾部</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        Node curNode = <span class="keyword">new</span> Node(<span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node preNode = tail.get();</span><br><span class="line">        <span class="comment">//CAS自旋：将当前节点插入队列的尾部</span></span><br><span class="line">        <span class="keyword">while</span> (!tail.compareAndSet(preNode, curNode)) {</span><br><span class="line">            preNode = tail.get();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//设置前驱节点</span></span><br><span class="line">        curNode.setPrevNode(preNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自旋，监听前驱节点的locked变量，直到其值为false</span></span><br><span class="line">        <span class="comment">// 若前驱节点的locked状态为true，则表示前一个线程还在抢占或者占有锁</span></span><br><span class="line">        <span class="keyword">while</span> (curNode.getPrevNode().isLocked()) {</span><br><span class="line">            <span class="comment">//让出CPU时间片，提高性能</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 能执行到这里，说明当前线程获取到了锁</span></span><br><span class="line">        <span class="comment">// Print.tcfo("获取到了锁！！！");</span></span><br><span class="line">        <span class="comment">//将当前节点缓存在线程本地变量中，释放锁会用到</span></span><br><span class="line">        curNodeLocal.set(curNode);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">        Node curNode = curNodeLocal.get();</span><br><span class="line">        curNode.setLocked(<span class="keyword">false</span>);</span><br><span class="line">        curNode.setPrevNode(<span class="keyword">null</span>); <span class="comment">//help for GC</span></span><br><span class="line">        curNodeLocal.set(<span class="keyword">null</span>); <span class="comment">//方便下一次抢锁</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虚拟等待队列的节点</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> locked, Node prevNode)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.locked = locked;</span><br><span class="line">            <span class="keyword">this</span>.prevNode = prevNode;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// true：当前线程正在抢占锁，或者已经占有锁</span></span><br><span class="line">        <span class="comment">// false：当前线程已经释放锁，下一个线程可以占有锁了</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">boolean</span> locked;</span><br><span class="line">        <span class="comment">// 前一个节点，需要监听其locked字段</span></span><br><span class="line">        Node prevNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Node EMPTY = <span class="keyword">new</span> Node(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>CLH 算法的几个要点就是（我理解的是，这种步骤就是公平锁环境下弄的，非公平锁不会每次头节点获得锁）：</p>
<ol>
<li>初始状态队列尾部(tail)指向一个 EMPTY节点，tail 节点使用 AtomicReference 类型是为了让多线程并发操作时安全</li>
<li>Thread 在抢锁时会创建一个 Node 加入等待队列尾部（默认lock 属性为true），同时自己作为新的尾部，这些操作通过 CAS 自旋操作</li>
<li>Node 加入之后，会循环判断前去节点的 lock 属性是否为false，如果为false，即前驱节点释放了锁，当前节点获得了锁</li>
<li>当前node 获得锁之后，将locked 属性设置为true</li>
<li>临界区代码执行完毕后，当前节点的 locked 置为 false，方便后续节点获取锁</li>
</ol>
<h3 id="5-4-2-死锁的监测与中断"><a href="#5-4-2-死锁的监测与中断" class="headerlink" title="5.4.2 死锁的监测与中断"></a>5.4.2 死锁的监测与中断</h3><p>JDK 8 中包含一个 ThreadMXBean 接口，提供多种监视线程的方法：</p>
<ul>
<li>findDeadlockedThreads ：用于检测由于抢占JUC显式锁、Java内置锁引起死锁的线程。</li>
<li>findMonitorDeadlockedThreads：仅仅用于检测由于抢占Java内置锁引起死锁的线程。</li>
</ul>
<h2 id="5-5-共享锁与独占锁"><a href="#5-5-共享锁与独占锁" class="headerlink" title="5.5 共享锁与独占锁"></a>5.5 共享锁与独占锁</h2><p>JUC 中的共享锁包括 Semaphore（信号量）、ReadLock（读写锁中的读锁）、CountDownLatch 倒数闩</p>
<h3 id="5-5-2-共享锁-Semaphore"><a href="#5-5-2-共享锁-Semaphore" class="headerlink" title="5.5.2 共享锁 Semaphore"></a>5.5.2 共享锁 Semaphore</h3><p>Semaphore 可以用来控制在同一时刻共享资源的线程数量，维护了一组虚拟许可。<strong>将 Semaphore 称为一个许可管理器 更形象。</strong></p>
<h4 id="5-5-2-1-Semaphore-使用示例"><a href="#5-5-2-1-Semaphore-使用示例" class="headerlink" title="5.5.2.1 Semaphore 使用示例"></a>5.5.2.1 Semaphore 使用示例</h4><p>Semaphore 使用一个很形象的场景是银行排队办理业务，只有 N 个窗口，M 个人在排队，那么其实相当于有 N 个许可：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(N);</span><br><span class="line"></span><br><span class="line">Runnable r = () -&gt; {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//阻塞开始获取许可</span></span><br><span class="line">        semaphore.acquire(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//获取了一个许可</span></span><br><span class="line">        print(<span class="string">"业务办理中"</span>);</span><br><span class="line">        <span class="comment">//模拟业务操作: 处理排队业务</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//用完了释放许可</span></span><br><span class="line">        semaphore.release(<span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">catch</span>(Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-5-3-共享锁-CountDownLatch"><a href="#5-5-3-共享锁-CountDownLatch" class="headerlink" title="5.5.3 共享锁 CountDownLatch"></a>5.5.3 共享锁 CountDownLatch</h3><p>CountDownLatch 功能相当于一个多线程环境下的倒数门闩，它可以指定一个计数值，在并发环境下由线程进行减1操作，当计数变为 0 之后，被 await 阻塞的线程将会唤醒。</p>
<p>它的一个经典示例就是，司机开车之前需要每个人报数，报数到 100 后说明人到齐发车：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) {<span class="comment">// 启动报数任务</span></span><br><span class="line">    threadPoll.execute(<span class="keyword">new</span> Runable() {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            print(<span class="string">"第"</span> + i + <span class="string">"个人已到"</span>);</span><br><span class="line">            <span class="comment">//倒数闩减1</span></span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"> doneSignal.await(); <span class="comment">//step2：等待报数完成，倒数闩计数值为0</span></span><br><span class="line"> print(<span class="string">"人到齐，开车"</span>); </span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-6-读写锁"><a href="#5-6-读写锁" class="headerlink" title="5.6 读写锁"></a>5.6 读写锁</h2><p>读写锁的读和写操作的互斥原则如下：</p>
<ul>
<li>读读能共存</li>
<li>读写不能共存</li>
<li>写写不能共存</li>
</ul>
<p>JUC 包中的读写锁接口为 ReadWriteLock ，主要有2个方法： </p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>{</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回读锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回写锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其主要实现类为 ReentrantReadWriteLock ，与 ReentrantLock 相比，<strong>前者更适合 读多写少 的场景，而 ReentrantLock 适合 读写比例相差不大 的场景</strong>。</p>
<h3 id="5-6-3-StampedLock-印戳锁"><a href="#5-6-3-StampedLock-印戳锁" class="headerlink" title="5.6.3 StampedLock 印戳锁"></a>5.6.3 StampedLock 印戳锁</h3><p>StampedLock 是对 ReentrantReadWriteLock 读写所的一种改进，主要改进为： 在没有写只有读的场景，<strong>StampedLock 支持不用加读锁而是直接进行读操作，最大限度提升读的效率，只有发生过写操作后，再加读锁才能进行读操作。</strong></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/17/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC4%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/17/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC4%E7%AB%A0/" class="post-title-link" itemprop="url">第4章：可见性与有序性的原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-17 14:20:00" itemprop="dateCreated datePublished" datetime="2023-02-17T14:20:00+08:00">2023-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-18 15:53:19" itemprop="dateModified" datetime="2023-02-18T15:53:19+08:00">2023-02-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="4-1-CPU物理缓存结构"><a href="#4-1-CPU物理缓存结构" class="headerlink" title="4.1 CPU物理缓存结构"></a>4.1 CPU物理缓存结构</h2><p>L1缓存离 CPU 最近也最快，一般就 32k/64k水平；L2 缓存速度次之，容量一般比L1大；L3级缓存最大，比前面二者都大，速度也最慢，大小可能 12M 的水平。</p>
<h2 id="4-2-并发编程的三大问题"><a href="#4-2-并发编程的三大问题" class="headerlink" title="4.2 并发编程的三大问题"></a>4.2 并发编程的三大问题</h2><p>三大问题分别是： 原子性、可见性、有序性 问题。必须要保证这 3 个，只要有一个没保证，在多线程情况下就可能不正确。</p>
<p>后续的略。</p>
<h2 id="4-3-硬件层的MESI协议原理"><a href="#4-3-硬件层的MESI协议原理" class="headerlink" title="4.3 硬件层的MESI协议原理"></a>4.3 硬件层的MESI协议原理</h2><p>为了缓解内存速度和CPU速度差问题，现在计算机都会为CPU添加高速缓存，每个CPU内核都有自己的一级、二级高速缓存，同一个CPU多个内核之间共享一个三级高速缓存。</p>
<h3 id="4-3-1-总线锁和缓存锁"><a href="#4-3-1-总线锁和缓存锁" class="headerlink" title="4.3.1 总线锁和缓存锁"></a>4.3.1 总线锁和缓存锁</h3><p>CPU的处理流程为：现将计算需要用到的数据缓存到CPU的高速缓存中，CPU计算时，直接从高速缓存获取数据并在计算完成后写会高速缓存，整个运算完成后再把高速缓存的数据同步回主存。由于每个线程可能运行在不同的CPU内核中，因此<strong>同一份数据可能被缓存到多个CPU内核中，就会发生内存可见性问题</strong>。</p>
<p>后续的略。</p>
<h3 id="4-4-1-重排序"><a href="#4-4-1-重排序" class="headerlink" title="4.4.1 重排序"></a>4.4.1 重排序</h3><p><strong>编译器</strong>为什么要重排序？其目的为： <strong>与其等待阻塞指令（如等待缓存刷入），不如先去执行其他指令。</strong>另外，CPU层面也有重排序。</p>
<h2 id="4-5-JMM-详解"><a href="#4-5-JMM-详解" class="headerlink" title="4.5 JMM 详解"></a>4.5 JMM 详解</h2><p>JMM (Java Memory Model ，Java 内存模型) 并不像JVM 内存结构一样是真实存在的运行实体，更多体现为一种规范和规则。</p>
<p>JMM 定义了一组规则或规范，该规范定义了<strong>一个线程对共享变量写入时，如何确保对另一个线程是可见的</strong>，实际上 JMM 提供了合理的禁用缓存以及禁止重排序的方法，所以其核心价值在于<strong>解决可见性和有序性</strong>。它的另一大价值在于：<strong>屏蔽各大硬件和操作系统差异，保证 Java 程序在各大平台堆内存访问是一致的。</strong></p>
<p>JMM 规定所有的变量都存储在主存（类似于物理内存，但是有区别）中，每个 Java 线程都有自己的工作内存（类似于CPU高速缓存，但有区别）。</p>
<p>JMM 提供了一套自己的方案解决可见性和有序性问题，包括 volatile、synchronized、final 等。</p>
<h2 id="4-7-volatile-不具备原子性"><a href="#4-7-volatile-不具备原子性" class="headerlink" title="4.7 volatile 不具备原子性"></a>4.7 volatile 不具备原子性</h2><p>对于关键字 volatile 修饰的内存可见变量而言，具有2个重要的语义：</p>
<ul>
<li><p>使用 volatile 修饰的变量在变量的值发生改变时，会立刻同步到主存，并使其他线程的变量副本失效</p>
</li>
<li><p>禁止指令重排序</p>
</li>
</ul>
<p>使用++操作说明volatile不具备重排序功能：</p>
<ol>
<li><p>A、B线程分别运行在Core1 和 Core2 核上，假设此时共享value 的值为 0，现在线程 A、B 都读取value值到自己的工作内存上</p>
</li>
<li><p>线程 A 将 value 的值变为 1，完成了 assign、store 操作，假设在执行 write 指令前 A 的时间片用完，线程 A 被空闲但是 write 操作还没达到主存，但是呢， store 操作触发了写的信号，导致了 B 缓存过期</p>
</li>
<li><p>B重新从主存读到 value，可想而知这时候还是 0</p>
</li>
<li><p>线程 B 执行完所有操作，将 value 值变成 1 写入主存</p>
</li>
<li><p>线程 A 重新拿到时间片，将过期了的 1 写入主存</p>
</li>
</ol>
<p>所以，<strong>对于复合操作，volatile无法保障原子性，如果要保证复合操作的原子性，就需要用到锁</strong>。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/16/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：CAS原理与JUC原子类</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 14:50:00" itemprop="dateCreated datePublished" datetime="2023-02-16T14:50:00+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-22 22:22:30" itemprop="dateModified" datetime="2023-02-22T22:22:30+08:00">2023-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>JVM 的Synchrod 轻量级锁使用 CAS 进行自旋抢锁，并且处于用户态下，所以轻量级锁开销较小。</p>
<h2 id="3-1-什么是-CAS"><a href="#3-1-什么是-CAS" class="headerlink" title="3.1 什么是 CAS"></a>3.1 什么是 CAS</h2><p>JDK 5 增加的 JUC (java.util.concurrent) 并发包对操作系统的底层 CAS 原子操作进行了封装，为上层提供了 CAS 操作的 API 。</p>
<h3 id="3-1-1-Unsafe-类中的-CAS-方法"><a href="#3-1-1-Unsafe-类中的-CAS-方法" class="headerlink" title="3.1.1 Unsafe 类中的 CAS 方法"></a>3.1.1 Unsafe 类中的 CAS 方法</h3><p>Unsafe 是位于 sun.misc 包下的一个类，主要提供一些用于执行低级别、不安全的底层操作，如直接访问系统内存资源、自主管理内存资源等。从名字都可以看出这个类对普通程序员来说是“危险”的，官方也不建议直接在程序中使用这些类。</p>
<h5 id="获取-Unsafe-实例"><a href="#获取-Unsafe-实例" class="headerlink" title="获取 Unsafe 实例"></a>获取 Unsafe 实例</h5><p>Unsafe 类时一个final 修饰的不允许继承的类，并且构造函数是 private 类型，源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        Reflection.registerMethodsToFilter(Unsafe.class, Set.of(<span class="string">"getUnsafe"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe = <span class="keyword">new</span> Unsafe();</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所以我们无法在外部对 Unsafe 实例化，那么应该怎么获取呢？可以通过反射方式获取 theUnsafe 实例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmUtil</span> </span>{</span><br><span class="line">    <span class="comment">//自定义地获取Unsafe实例的辅助方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 省略不相干代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="Unsafe提供的-CAS-方法"><a href="#Unsafe提供的-CAS-方法" class="headerlink" title="Unsafe提供的 CAS 方法"></a>Unsafe提供的 CAS 方法</h5><p>总共提供了如下3种方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object expected,Object x)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,  <span class="keyword">int</span> expected,  <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">long</span> expected, <span class="keyword">long</span> x)</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>这些方法首先将内存位置的值与预期值比较，如果相匹配，那么CPU 会自动将该内存位置的值更新为新值，并返回true；否则，CPU不做任何操作，并返回false。</p>
<h3 id="3-1-2-使用-CAS-进行无锁编程"><a href="#3-1-2-使用-CAS-进行无锁编程" class="headerlink" title="3.1.2 使用 CAS 进行无锁编程"></a>3.1.2 使用 CAS 进行无锁编程</h3><p>CAS 是一种无锁算法，底层CPU 利用原子操作判断 <strong>内存值与期望值是否相等，如果相等就给内存地址赋新值，否则不做任何操作。</strong>使用 CAS 进行无锁编程的步骤大概如下：</p>
<ol>
<li><p>获得字段的期望值(oldValue)</p>
</li>
<li><p>计算出需要替换的新值(newValue)</p>
</li>
<li><p>通过 CAS 将 newValue 放在字段的内存地址上，如果 CAS 失败就重复从第1步开始，直到 CAS 成功。<strong>这种重复俗称“自旋”</strong></p>
</li>
</ol>
<p>举例： 假如 2 个线程 A 和B 对一个共享变量做 +1 操作，用 CAS 去做这个操作。但是线程是并发进行的，假如 A 和 B 都读到旧值是 1 ，然后并发通过 CAS 操作，都是 CAS(1, 2)  ，但是CAS 是原子操作，同一个内存地址的 CAS 在同一个时刻只能执行一个，因此，假设 A 先执行，A 的 CAS(1, 2) 因为期望值是1，内存值也是1，操作成功，返回true；接下来 B 执行 CAS(1, 2) 肯定会失败了，因为内存值目前已经是 2 了，而期望值是 1 ，所以只得重新获取得到期望值 2，计算出新的值 3， 最后通过 CAS(2, 3) 才能成功。</p>
<h2 id="3-2-JUC原子类"><a href="#3-2-JUC原子类" class="headerlink" title="3.2 JUC原子类"></a>3.2 JUC原子类</h2><p>并发执行时，诸如 ++ 或者 – 类的运算不具备原子性，大家可能会用 synchronized 方法做同步，但效率肯定会影响的。JDK 为这些类型不安全的操作提供了一些原子类，与 synchronized 相比效率会更高。</p>
<h3 id="3-2-1-JUC中的Atomic-原子操作包"><a href="#3-2-1-JUC中的Atomic-原子操作包" class="headerlink" title="3.2.1 JUC中的Atomic 原子操作包"></a>3.2.1 JUC中的Atomic 原子操作包</h3><p>只需要知道有： </p>
<ul>
<li><p>基本原子类：AtomicInteger、AtomicLong、AtomicBoolean</p>
</li>
<li><p>数组原子类：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p>
</li>
<li><p>引用原子类：AtomicReference、AtomicMarkableReference、AtomicStampedReference</p>
</li>
</ul>
<p>等等一些常见的即可。</p>
<h2 id="3-4-ABA问题"><a href="#3-4-ABA问题" class="headerlink" title="3.4 ABA问题"></a>3.4 ABA问题</h2><p>什么是 ABA 问题，举个例子：比如线程 A 从内存位置 M 取出 V1，另一个线程 B 也取出 V1 ，假设 B 进行了一些操作后将 M 位置的数据 V1 变成了 V2，然后又在一些操作之后将 V2 变成了 V1，然后线程 A 通过 CAS 操作时发现条件满足，CAS 操作成功。</p>
<p>但是这个过程是有问题的，A 操作的时候 V1 已经不是以前的 V1 了，这就是 ABA 问题。</p>
<h3 id="3-4-2-ABA问题的解决方案"><a href="#3-4-2-ABA问题的解决方案" class="headerlink" title="3.4.2 ABA问题的解决方案"></a>3.4.2 ABA问题的解决方案</h3><p>很多乐观锁的实现版本是： <strong>使用版本号(Version)方式来解决ABA问题。</strong> 每次在执行数据的修改操作时<strong>都会带上一个版本号</strong>，版本号和数据的版本号一致就可以执行修改操作，否则执行失败。因为操作的版本号只会增加，不会减少。</p>
<p>当然，参考乐观锁的版本号实现， JDK 提供了一个 AtomicStampedReference 类来解决 ABA 问题，AtomicStampedReference 在 CAS 的基础上增加了一个 Stamp（印戳或标记）来察觉数据是否发生了变化。</p>
<p>当然，还可以使用 AtomicMarkableReference 解决。它是 AtomicStampedReference 的简化版，不关心修改过几次，只关心是否修改过。</p>
<h2 id="3-5-提升高并发场景下-CAS-操作的性能"><a href="#3-5-提升高并发场景下-CAS-操作的性能" class="headerlink" title="3.5 提升高并发场景下 CAS 操作的性能"></a>3.5 提升高并发场景下 CAS 操作的性能</h2><p>在竞争激烈的场景下，会导致大量的 CAS 自旋，比如大量线程同时并发修改一个 AtomicInteger 是，很多线程可能不停地自旋， 这浪费了大量的 CPU。</p>
<h3 id="3-5-1-以空间换时间：LongAdder"><a href="#3-5-1-以空间换时间：LongAdder" class="headerlink" title="3.5.1 以空间换时间：LongAdder"></a>3.5.1 以空间换时间：LongAdder</h3><p>AtomicLong 使用内部变量 value 保存着实际的 long 值，所有操作都是针对该 value 的，也就是说，当高并发的情况下，value 变量其实是一个热点，N 个线程竞争这一个热点，重试的线程越多，意味着 CAS 失败的概率越高。</p>
<p>LongAdder 的核心思想是热点分离，与 ConcurrentHashMap 的设计思想类似：将 value 值分离成一个数组，当多线程访问时，通过 Hash 算法将线程映射到数组的一个元素进行操作；而获取最终value 结果时，则将数组的元素求和。</p>
<p>具体一点：LongAdder 将 value 值分散到一个数组中，不同的线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行 CAS 操作，这样热点就被分散了，这样，即使线程数再多也不担心，各个线程分配到多个元素更新。<strong>如果要获取完整的 LongAdder 存储的值，只要将各个槽中的变量值累加即可</strong></p>
<blockquote>
<p>在 CAS 竞争非常激烈的场景， LongAdder 的性能可达到 AtomicLong 的 8 倍。</p>
</blockquote>
<h2 id="3-6-CAS在JDK中的广泛应用"><a href="#3-6-CAS在JDK中的广泛应用" class="headerlink" title="3.6 CAS在JDK中的广泛应用"></a>3.6 CAS在JDK中的广泛应用</h2><h3 id="3-6-1-CAS操作的弊端和规避措施"><a href="#3-6-1-CAS操作的弊端和规避措施" class="headerlink" title="3.6.1 CAS操作的弊端和规避措施"></a>3.6.1 CAS操作的弊端和规避措施</h3><p>CAS 操作弊端主要有下面 3 点：</p>
<ul>
<li><p>ABA问题，<strong>解决思路</strong>： 添加版本号、使用 AtomicStampedReference、AtomicMarkableReference，其中前者比较常用</p>
</li>
<li><p>只能保证一个共享变量的原子操作。<strong>解决思路</strong>：将多个共享变量合并成一个共享变量来操作</p>
</li>
<li><p>开销问题。<strong>解决思路</strong>：分散操作热点(如 LongAdder)、使用队列削峰(将 发生 CAS 争用的线程加入一个队列中排队，降低 CAS 争用的激烈程度，JUC 中非常重要的基础类 AQS 就是这么做的！)</p>
</li>
</ul>
<h3 id="3-6-2-CAS-在JDK中的应用"><a href="#3-6-2-CAS-在JDK中的应用" class="headerlink" title="3.6.2 CAS 在JDK中的应用"></a>3.6.2 CAS 在JDK中的应用</h3><p>CAS 在 在java.util.concurrent.atomic包中的原子类、Java AQS 以及 显式锁、ConcurrentHashMap 等重要并发容器中都有非常广泛的应用</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/16/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：Java内置锁的核心原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 10:10:00" itemprop="dateCreated datePublished" datetime="2023-02-16T10:10:00+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-23 23:13:31" itemprop="dateModified" datetime="2023-02-23T23:13:31+08:00">2023-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="2-2-synchronized-关键字"><a href="#2-2-synchronized-关键字" class="headerlink" title="2.2 synchronized 关键字"></a>2.2 synchronized 关键字</h2><p>synchronized 方法和 synchronized 同步块有什么区别呢？总体来说 synchronized 代码块是一种细粒度的并发控制，处于块之外的代码可以被多个线程并发访问。而如下代码本质上都是一样的，都是锁住当前对象：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">plus</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>){ <span class="comment">//对方法内部全部代码进行保护</span></span><br><span class="line">        amount++; </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">plus</span><span class="params">()</span> </span>{</span><br><span class="line">    amount++; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-3-静态的同步方法"><a href="#2-2-3-静态的同步方法" class="headerlink" title="2.2.3 静态的同步方法"></a>2.2.3 静态的同步方法</h3><p>Class 没有公共的构造方法，Class 对象是在类加载的时候由 Java 虚拟机调用类加载器中的 defineClass 方法自动构造的，<strong>因此不能显式地声明一个 Class 对象。</strong></p>
<p>普通的 synchronized 实例方法，其同步锁是当前对象 this 的监视锁，如果某个 synchronized 方法是static 方法，其同步锁又是什么呢？答案是：<strong>类对应的 Class 对象的监视锁。</strong></p>
<p>在代码执行完毕或者程序出现异常，synchronized 持有的监视锁都会正常释放，所以无需手动释放。</p>
<h2 id="2-4-Java对象结构与内置锁"><a href="#2-4-Java对象结构与内置锁" class="headerlink" title="2.4 Java对象结构与内置锁"></a>2.4 Java对象结构与内置锁</h2><p>Java 内置锁很多重要信息都存放在对象结构中。</p>
<h3 id="2-4-1-Java-对象结构"><a href="#2-4-1-Java-对象结构" class="headerlink" title="2.4.1 Java 对象结构"></a>2.4.1 Java 对象结构</h3><p>Java 对象结构包括三部分：</p>
<ul>
<li>对象头：包括3个字段：Mark Word（存储GC标记位、锁状态）、类对象指针（存放方法区Class对象的地址，能确定该对象是哪个类的实例）、Array Length（如果对象是Java 数组，那么就是数组长度；如果不是数组，就不存在这字段）</li>
<li>对象体：包括成员属性，包括父类的成员属性</li>
<li>对齐字节：填充对齐，用来保证对象所占内存字节数为8的倍数</li>
</ul>
<h3 id="2-4-2-Mark-Word-的结构信息"><a href="#2-4-2-Mark-Word-的结构信息" class="headerlink" title="2.4.2 Mark Word 的结构信息"></a>2.4.2 Mark Word 的结构信息</h3><p>从Mark Word 锁标志位的状态来看，内置锁的状态就有了 4 种： 无锁、偏向锁、轻量级锁、重量级锁，<strong>这4种状态会随着竞争的激烈程度逐渐升级，并且是不可逆的过程，即不可降级。</strong></p>
<h3 id="2-4-3-使用-JOL-工具查看对象的布局"><a href="#2-4-3-使用-JOL-工具查看对象的布局" class="headerlink" title="2.4.3 使用 JOL 工具查看对象的布局"></a>2.4.3 使用 JOL 工具查看对象的布局</h3><p>知道有 JOL 工具即可，略。</p>
<h3 id="2-4-5-无锁、偏向锁、轻量级锁和重量级锁"><a href="#2-4-5-无锁、偏向锁、轻量级锁和重量级锁" class="headerlink" title="2.4.5 无锁、偏向锁、轻量级锁和重量级锁"></a>2.4.5 无锁、偏向锁、轻量级锁和重量级锁</h3><p>JDK 1.6 以前，所有内置锁都是重量级锁，所以会在用户态和核心态之间频繁切换，所以代价很高。后续引入了 偏向锁和 轻量级锁，所以一共就有 4 种状态：无锁、偏向锁、轻量级锁、重量级锁。<strong>内置锁可以升级但是不能降级</strong>。</p>
<h2 id="2-5-偏向锁的原理与实战"><a href="#2-5-偏向锁的原理与实战" class="headerlink" title="2.5 偏向锁的原理与实战"></a>2.5 偏向锁的原理与实战</h2><p>原理：如果不存在线程竞争，那么线程获得锁之后就进入偏向状态：偏向锁标志位为 1，锁状态为 01。以后该线程获取锁时判断一下线程 ID 和标志位，就可以直接进入同步块，连 CAS 都不需要，从而提升性能。</p>
<p>但是，<strong>一旦有第二条线程需要竞争锁，偏向模式就立即结束，进入轻量级锁状态。</strong>这里需要好好理解下，感觉这句话不一定对，书中更准确的表述是：<strong>线程获取锁时，判断该偏向状态的锁的 ID 是不是自己的，如果是自己的，则直接进入同步块；否则，采用 CAS 操作将 Mark Word 中的偏向锁 ID 换成自己的，如果 CAS 操作成功，就获取偏向锁成功，执行同步块代码；如果 CAS 操作不成功，表示有竞争，抢锁线程被挂起，撤销占锁线程的偏向锁，然后将偏向锁膨胀为轻量级锁。</strong>。</p>
<h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><ol>
<li>在一个安全点停止拥有锁的线程</li>
<li>遍历线程栈帧，找到并删除栈帧，使其变为无锁状态，修复锁指向的 Mark Word ，并清除锁 Mark Word 中的线程 ID</li>
<li>将当前锁升级为轻量级锁</li>
<li>唤醒当前线程</li>
</ol>
<h2 id="2-6-轻量级锁的原理与实战"><a href="#2-6-轻量级锁的原理与实战" class="headerlink" title="2.6 轻量级锁的原理与实战"></a>2.6 轻量级锁的原理与实战</h2><p>轻量级锁是<strong>一种自旋锁，希望在应用层面通过自旋解决线程同步问题。</strong>轻量级锁的执行过程：</p>
<p>抢锁线程进入临界区之前，如果内置锁没有被锁定，JVM 首先将在抢锁线程的栈帧中创建一个锁记录(Lock Record)，<strong>用于存储对象目前的 Mark Word 的拷贝</strong>。</p>
<p>然后抢锁线程将使用 CAS 自旋操作，尝试<strong>将内置锁对象头的 Mark Word 的ptr_to_lock_record（锁记录指针）更新为抢锁线程栈帧中拷贝的 Mark Word ，如果这个更新执行成功，线程就拥有了这个对象锁，之后会改掉 Mark Word 中的lock 标记为 00,即轻量级锁</strong>。</p>
<blockquote>
<p>为什么要拷贝呢？因为内置锁对象的 Mark Word 结构会有所变化，而不再存着无锁状态下的一些信息，所以要拷贝。</p>
</blockquote>
<h3 id="2-6-3-轻量级锁的分类"><a href="#2-6-3-轻量级锁的分类" class="headerlink" title="2.6.3 轻量级锁的分类"></a>2.6.3 轻量级锁的分类</h3><p>轻量级锁分为 2 种： </p>
<ul>
<li>普通自旋锁： 抢锁线程一直在自旋，而不是被阻塞，直到占有锁的线程释放之后抢锁线程才能获取到锁</li>
<li>自适应自旋锁：自旋次数不是固定的，而是根据系统以前的经验来的。解决的是<strong>锁竞争时间不确定的问题</strong>。</li>
</ul>
<h2 id="2-7-重量级锁的原理与实战"><a href="#2-7-重量级锁的原理与实战" class="headerlink" title="2.7 重量级锁的原理与实战"></a>2.7 重量级锁的原理与实战</h2><p>在 JVM 中，<strong>每个对象都关联一个监视器，这里的对象包括 Object 实例和 Class 实例</strong>。监视器是一个同步工具，相当于一个许可证：拿到许可证的线程可以进入临界区执行，没有拿到的则需要阻塞等待。</p>
<h3 id="2-7-1-重量级锁的核心原理"><a href="#2-7-1-重量级锁的核心原理" class="headerlink" title="2.7.1 重量级锁的核心原理"></a>2.7.1 重量级锁的核心原理</h3><p>HotSpot 虚拟机中，监视器是由 C++ 类 ObjectMonitor 实现的，它有以下几个比较关键的属性：</p>
<p>Owner、WaitSet、Cxq、EntryList ，其中 Owner 所指向的线程为获得锁的线程，WaitSet、Cxq、EntryList 是 3 个队列，用于存放抢夺重量级锁的线程：</p>
<ul>
<li>Cxq：竞争队列(Contention Queue)，所有请求锁的线程首先被放在这个竞争队列中（不是真正的队列，只是由Node及其 next 指针逻辑构成，每次都通过 CAS 操作在头部新增节点，取元素从尾获取，因为只有 Owner 线程才能从队尾获取节点，所以，Cxq 出队无争用操作，是无锁结构）</li>
<li>EntryList： Cxq 中那些有资格成为候选资源的线程被移动到 EntryList。Cxq 会被线程并发访问，为了降低对 Cxq 的争用而建立了 EntryList。在 Owner 线程释放锁时，JVM 会从 Cxq 中迁移线程到 EntryList，并会指定 EntryList 中的某个线程(一般为 Head) 为 Ready Thread。 EntryList 作为候选竞争线程而存在（自己加的：但由于是非公平锁，所以这个 Ready Thread 不一定能得以执行，后续的说明非公平性会提及）。</li>
<li>WaitSet： 某个拥有锁的线程在调用 Object.wait() 方法之后将被阻塞，然后线程将被放置在 WaitSet 链表中。等到执行 Object.notify/notifyAll 唤醒之后，该线程又会<strong>回到 EntryList 中</strong>(注意不是 Cxq 中)。</li>
</ul>
<blockquote>
<p>Synchronized 的不公平性：在线程进入 Cxq 前，抢锁线程会先尝试通过 CAS 自旋获取锁，如果获取到就直接用了；获取不到，才进入 Cxq 队列，这对于已经进入 Cxq 队列的线程是不公平的。但是这由于避免了 Cxq 队列中线程唤醒——内核态到用户态的过程，节省了时间，提升了吞吐率</p>
</blockquote>
<h3 id="2-7-2-重量级锁开销"><a href="#2-7-2-重量级锁开销" class="headerlink" title="2.7.2 重量级锁开销"></a>2.7.2 重量级锁开销</h3><p>处于 Cxq、EntryList 以及 WaitSet 中的线程都处于阻塞状态，<strong>线程的阻塞或者唤醒都需要操作系统来帮忙，需要通过系统调用实现</strong>，进城需要从用户态切换到内核态，这种切换需要消耗很多时间，有可能比用户执行代码的时间还要长。</p>
<p><strong>由于轻量级锁使用 CAS 进行自旋抢锁，而 CAS 操作都处于用户态下，不存在用户态和内核态的切换，因此轻量级锁的开销比较小。</strong></p>
<h2 id="2-8-偏向锁、轻量级锁与重量级锁的对比"><a href="#2-8-偏向锁、轻量级锁与重量级锁的对比" class="headerlink" title="2.8 偏向锁、轻量级锁与重量级锁的对比"></a>2.8 偏向锁、轻量级锁与重量级锁的对比</h2><p>总结一下，synchronized 的执行过程大致如下：</p>
<ol>
<li>线程抢锁时，JVM 首先检测内置锁对象 Mark Word 的biased_lock(偏向锁标识)是否为1，lock (锁标志位)是否为01，如果都满足，说明内置锁对象为可偏向状态</li>
<li>如果内置锁对象为可偏向状态，JVM 检查 Mark Word 中线程 ID 是否为当前抢锁线程的 ID，如果是，标识抢锁线程处于偏向所状态，快速获得锁，开始执行临界区代码</li>
<li>如果Mark Word 中的线程 ID 不是当前抢锁线程，就通过 CAS 竞争锁。如果竞争成功，就将 Mark Word 中的线程 ID 设置为抢锁线程的 ID ，偏向锁标志设为 1 ，锁标志位设为 01,此时内置锁对象处于偏向锁状态，然后开始执行临界区代码</li>
<li>如果 CAS 竞争失败，说明发生了竞争，撤销偏向锁，进而升级为轻量级锁</li>
<li>JVM 使用 CAS 将锁对象的 Mark Word 替换为抢锁线程的锁记录指针，如果成功，抢锁线程就获得锁；如果替换失败，就表示其他线程在竞争锁。那么 JVM 尝试使用 CAS 自旋替换抢锁线程的锁记录指针，如果自旋成功（抢锁成功），那么锁对象依旧处于轻量级锁状态。</li>
<li>如果JVM的CAS 替换锁记录指针自旋失败，轻量级锁就膨胀为重量级锁，后面等待锁的线程也要进入阻塞状态</li>
</ol>
<p>3种锁的优缺点对比和适用场景如下表所示：</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加解锁不需要额外消耗，和执行非同步方法仅存在纳秒级差距</td>
<td>如果线程间存在锁竞争，会带来额外的撤销锁操作</td>
<td>适用于只有一个线程访问的临界区场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>抢不到锁的竞争线程会CAS自旋，消耗CPU</td>
<td>锁占用时间短，吞吐量低</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争无需自旋，不消耗CPU</td>
<td>线程阻塞，响应时间慢</td>
<td>锁占用时间长，吞吐量高</td>
</tr>
</tbody></table>
<h2 id="2-9-线程间通信"><a href="#2-9-线程间通信" class="headerlink" title="2.9 线程间通信"></a>2.9 线程间通信</h2><p>多个线程共同操作共享的资源时，线程间通过某种方法互相告知自己的状态，以避免无效的资源争夺。<strong>线程间通信的方式可以有很多种：等待-通知、共享内存、管道流。</strong></p>
<h3 id="2-9-2-低效的线程轮询"><a href="#2-9-2-低效的线程轮询" class="headerlink" title="2.9.2 低效的线程轮询"></a>2.9.2 低效的线程轮询</h3><p>轮询版本的生产者-消费者模型中，消费者每一轮消费，无论数据区是否为空，都需要进行数据区的询问和判断：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> IGoods <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    IGoods goods = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (amount &lt;= <span class="number">0</span>) {</span><br><span class="line">        Print.tcfo(<span class="string">"队列已经空了！"</span>);</span><br><span class="line">        <span class="comment">//数据区为空，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当数据区为空(amount &lt;= 0)时，消费者无法取出数据，但是仍然做无用的询问工作，浪费了CPU的时间片。同理，对于生产者也会存在这样的问题：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T element)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (amount.get() &gt; MAX_AMOUNT) {</span><br><span class="line">        Print.tcfo(<span class="string">"队列已经满了！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当数据区满时，生产者无法加入数据，这时执行add方法也浪费CPU的时间片。<strong>使用“等待-通知”方式进行生产者与消费者之间的线程通信可以避免这种浪费。</strong></p>
<p>具体方法是：<strong>当数据区满时，给让生产者等待，当可以添加数据时，给生产者发通知，让生产者唤醒；消费者同理。</strong>具体操作为：消费者取出一个数据后，由消费者去唤醒等待的生产者；生产者加入一个数据后，由生产者唤醒等待的消费者。</p>
<h3 id="2-9-3-wait-、notify-方法的原理"><a href="#2-9-3-wait-、notify-方法的原理" class="headerlink" title="2.9.3 wait 、notify 方法的原理"></a>2.9.3 wait 、notify 方法的原理</h3><h5 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait 方法"></a>wait 方法</h5><p>对象的 wait 方法作用就是<strong>让当前线程阻塞并等待被唤醒，wait 方法与对象监视器密切相关，使用时一定要放在同步块中：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(locko) {</span><br><span class="line">    ...</span><br><span class="line">    locko.wait();</span><br><span class="line">    ....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其原理大致如下：</p>
<ul>
<li><p>线程调用了 locko 的wait 方法后，JVM 会将当前线程假如 locko 监视器的 WaitSet(等待集) 中，等待被其他线程唤醒</p>
</li>
<li><p>当前线程会释放 locko 对象监视器 的 Owner 权利，让其他线程可以抢夺 locko 对象的监视器</p>
</li>
<li><p>让当前线程等待，其状态变为 WAITING</p>
</li>
</ul>
<h5 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify 方法"></a>notify 方法</h5><p>notify 方法也需要放在同步块中执行，它有2个版本：</p>
<ul>
<li><p>notify ： 唤醒 locko 监视器等待集中的第一条等待线程，被唤醒的线程进入 EntryList ，状态从 WAITING 变为 BLOCKED</p>
</li>
<li><p>notifyAll： 唤醒 locko 监视器等待集中全部等待线程，所有线程进入 EntryList ，状态从 WAITING 变为 BLOCKED</p>
</li>
</ul>
<p>notify 核心原理如下：</p>
<ul>
<li><p>当线程调用了 locko 的 notify 方法后，JVM 会唤醒 locko 监视器等待集中的第一条等待线程（如果是 notifyAll 则是所有线程），被唤醒的线程进入 EntryList ，状态从 WAITING 变为 BLOCKED，<strong>具备了排队抢夺监视器 Owner权利的资格</strong></p>
</li>
<li><p>EntryList 中的线程抢夺到监视器的 Owner 权利后，线程的状态从 BLOCKED 变成 RUNNABLE，具备重新执行的资格</p>
</li>
</ul>
<h3 id="2-9-5-生产者-消费者之间的线程间通信"><a href="#2-9-5-生产者-消费者之间的线程间通信" class="headerlink" title="2.9.5 生产者-消费者之间的线程间通信"></a>2.9.5 生产者-消费者之间的线程间通信</h3><p>此实现版本大致需要定义以下3个同步对象：</p>
<ul>
<li><p>LOCK_OBJECT：用于临界区同步，临界区资源为数据缓冲区的 dataList 变量和 amount 变量</p>
</li>
<li><p>NOT_FULL：用于数据缓冲区的未满条件等待和通知，生产者在添加元素时需要判定是否已满，如果已满，则进入 NOT_FULL 的同步去等待，只要消费者耗费一个元素，就会通过 NOT_FULL 发送通知。</p>
</li>
<li><p>NOT_EMPTY：同理，这是用于数据缓冲区的非空条件的等待和通知。消费者在消费前需要判断数据区是否空，如果是，消费者就进入 NOT_EMPTY 的同步区等待被通知，只要生产者添加一个元素，生产者就会通过 NOT_EMPTY 发送通知</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommunicatePetStore</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AMOUNT = <span class="number">10</span>; <span class="comment">//数据缓冲区最大长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据缓冲区，类定义</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBuffer</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">        <span class="comment">//保存数据</span></span><br><span class="line">        <span class="keyword">private</span> List&lt;T&gt; dataList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//数据缓冲区长度</span></span><br><span class="line">        <span class="keyword">private</span> Integer amount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object LOCK_OBJECT = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object NOT_FULL = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object NOT_EMPTY = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向数据区增加一个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T element)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">while</span> (amount &gt; MAX_AMOUNT) {</span><br><span class="line">                <span class="keyword">synchronized</span> (NOT_FULL) {</span><br><span class="line">                    Print.tcfo(<span class="string">"队列已经满了！"</span>);</span><br><span class="line">                    <span class="comment">//等待未满通知</span></span><br><span class="line">                    NOT_FULL.wait();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK_OBJECT) {</span><br><span class="line">                dataList.add(element);</span><br><span class="line">                amount++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">synchronized</span> (NOT_EMPTY) {</span><br><span class="line">                <span class="comment">//发送未空通知</span></span><br><span class="line">                NOT_EMPTY.notify();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从数据区取出一个商品</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">while</span> (amount &lt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">synchronized</span> (NOT_EMPTY) {</span><br><span class="line">                    Print.tcfo(<span class="string">"队列已经空了！"</span>);</span><br><span class="line">                    <span class="comment">//等待未空通知</span></span><br><span class="line">                    NOT_EMPTY.wait();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            T element = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK_OBJECT) {</span><br><span class="line">                element = dataList.remove(<span class="number">0</span>);</span><br><span class="line">                amount--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (NOT_FULL) {</span><br><span class="line">                <span class="comment">//发送未满通知</span></span><br><span class="line">                NOT_FULL.notify();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">            InterruptedException </span>{</span><br><span class="line">        Print.cfo(<span class="string">"当前进程的ID是"</span> + JvmUtil.getProcessID());</span><br><span class="line">        System.setErr(System.out);</span><br><span class="line">        <span class="comment">//共享数据区，实例对象</span></span><br><span class="line">        DataBuffer&lt;IGoods&gt; dataBuffer = <span class="keyword">new</span> DataBuffer&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产者执行的动作</span></span><br><span class="line">        Callable&lt;IGoods&gt; produceAction = () -&gt; {</span><br><span class="line">            <span class="comment">//首先生成一个随机的商品</span></span><br><span class="line">            IGoods goods = Goods.produceOne();</span><br><span class="line">            <span class="comment">//将商品加上共享数据区</span></span><br><span class="line">            dataBuffer.add(goods);</span><br><span class="line">            <span class="keyword">return</span> goods;</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//消费者执行的动作</span></span><br><span class="line">        Callable&lt;IGoods&gt; consumerAction = () -&gt; {</span><br><span class="line">            <span class="comment">// 从PetStore获取商品</span></span><br><span class="line">            IGoods goods = <span class="keyword">null</span>;</span><br><span class="line">            goods = dataBuffer.fetch();</span><br><span class="line">            <span class="keyword">return</span> goods;</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> THREAD_TOTAL = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">//线程池，用于多线程模拟测试</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_TOTAL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//假定共11个线程，其中有10个消费者，但是只有1个生产者</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> CONSUMER_TOTAL = <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PRODUCE_TOTAL = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PRODUCE_TOTAL; i++) {</span><br><span class="line">            <span class="comment">//生产者线程每生产一个商品，间隔50毫秒</span></span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> Producer(produceAction, <span class="number">50</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONSUMER_TOTAL; i++) {</span><br><span class="line">            <span class="comment">//消费者线程每消费一个商品，间隔100毫秒</span></span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> Consumer(consumerAction, <span class="number">100</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="2-9-6-需要在synchronized-同步块的内部使用-wait-和notify"><a href="#2-9-6-需要在synchronized-同步块的内部使用-wait-和notify" class="headerlink" title="2.9.6 需要在synchronized 同步块的内部使用 wait 和notify"></a>2.9.6 需要在synchronized 同步块的内部使用 wait 和notify</h3><p>调用 wait 和 notify 方法时，<strong>“当前线程”必须拥有该对象的同步锁，也即wait 和notiry 方法必须在同步块中使用，否则JVM 就会抛出 IllegalMonitorStateException 异常。</strong></p>
<p>这是为什么呢？还得从这 2 个方法的原理说起：</p>
<ul>
<li><p>调用 wait ：JVM 会释放当前线程的对象监视器的 Owner 资格，还会将当前线程移入监视器的 WaitSet 队列，这些操作都是和对象监视器锁相关的，所以，当前线程执行 wait 方法前，必须通过 synchronized 方法称为对象锁的 Owner，要在同步块内调用</p>
</li>
<li><p>同理， 调用 notify 时，JVM 从对象锁的监视器 WaitSet 队列移动线程到其 EntryList 队列，这些操作都与对象锁的监视器有关，所以，也必须先成为对象锁监视器的 Owner，然后在同步块内调用</p>
</li>
</ul>
<h3 id="2-9-7-调用wait、notify方法进行线程间通信的要点（自己加的章节）"><a href="#2-9-7-调用wait、notify方法进行线程间通信的要点（自己加的章节）" class="headerlink" title="2.9.7 调用wait、notify方法进行线程间通信的要点（自己加的章节）"></a>2.9.7 调用wait、notify方法进行线程间通信的要点（自己加的章节）</h3><p>有了以上的知识储备，来说下wait 和 notify 方法进行线程间通信的要点：</p>
<ul>
<li><p>调用某个同步对象 locko 的 wait 和 notify 类型方法前，必须要获得这个锁对象的监视器锁，这2个类型的方法必须放在同步块中执行，否则报错</p>
</li>
<li><p>调用<strong>wait方法是使用while进行条件判断，如果是在某种条件下进行等待，对条件的判断就不能使用if语句做一次性判断，而是使用while 循环进行反复判断</strong>，只有这样才能在线程被唤醒后继续检查wait 条件，并在条件没有满足的情况下继续等待。</p>
</li>
</ul>
<p>正确的条件判断代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">while</span> (amount &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">synchronized</span> (NOT_EMPTY) {</span><br><span class="line">            <span class="comment">//队列空了</span></span><br><span class="line">            NOT_EMPTY.wait();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>错误地使用 if 条件判断：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (amount &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">synchronized</span> (NOT_EMPTY) {</span><br><span class="line">            <span class="comment">//队列空了</span></span><br><span class="line">            NOT_EMPTY.wait();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至于为什么要这样，从之前说的原理我们知道，wait 方法会释放锁。我们考虑这么一种场景：</p>
<ul>
<li><p>假如有 2 个消费者 consumerOne 和 consumerTwo </p>
</li>
<li><p>consumerOne 在判定是空的时候，wait 了，这时候会释放锁；由于释放了锁，consumerTwo 自然就能获取到这个锁，然后发现也是空的，自然也 wait 了</p>
</li>
<li><p>也就是说 consumerOne 和 consumerTwo 都在wait 等待了，这是问题关键</p>
</li>
<li><p>此时，生产者放入一个元素，完了调用 notifyAll ，consumerOne 和 consumerTwo 都被唤醒了，他们会竞争锁</p>
</li>
<li><p>假如 consumerOne 拿到锁了，consumerTwo 还在锁池中继续阻塞，consumerOne 执行wait 后面的代码消费了，接着又会变为空</p>
</li>
<li><p>consumerOne 执行完成后，consumerTwo 拿到锁也接着执行 wait 后面的代码，由于被 consumerOne 消费变为空了之后，consumerTwo 后续的执行以不空作为条件的执行会出现问题</p>
</li>
</ul>
<p>如果不太明白，还可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37430539/article/details/100005522">为什么生产者消费者中模式中要用while作临界判断？_xuwen_chen的博客-CSDN博客</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/14/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC1%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/14/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC1%E7%AB%A0/" class="post-title-link" itemprop="url">第1章：多线程原理与实战</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-14 15:10:00 / 修改时间：21:52:21" itemprop="dateCreated datePublished" datetime="2023-02-14T15:10:00+08:00">2023-02-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程是操作系统资源分配的最小单位，线程是 CPU 调度的最小单位。</p>
<p>一个标准的线程主要由<strong>3部分构成：线程描述信息(线程ID、线程名称、线程状态、线程优先级、其他)、程序计数器 和 栈内存。</strong>其中，程序计数器它记录着线程下一条指令的代码段内存地址；每个线程在创建的时候默认被分配 1M 大小的栈内存大小，<strong>和堆内存不同，栈内存不受垃圾回收器管理</strong>。</p>
<p>当线程执行流程进入方法时，JVM 就会为方法分配一个对应的栈帧压入栈内存；当线程流程跳出方法时，JVM 就从栈内存弹出该方法的栈帧，此时方法帧的局部变量的内存空间就会被回收。</p>
<h2 id="创建线程的4种方法"><a href="#创建线程的4种方法" class="headerlink" title="创建线程的4种方法"></a>创建线程的4种方法</h2><p>Thread 类中有个属性， private boolean deamon = false; 该属性保存 Thread 线程实例的守护状态，默认为false ，表示普通用户线程，而不是<strong>守护线程。</strong> 守护线程是在进程运行提供某种后台服务的线程，比如GC 线程。</p>
<ul>
<li><p>继承Thead 类创建线程类（Thread 本身就实现了 Runnable ）</p>
</li>
<li><p>实现 Runnable 接口创建线程目标类(传入 Thread 中时，Thread将其以 target 字段保存)</p>
</li>
<li><p>使用 Callable 和 FutureTask 创建线程</p>
</li>
<li><p>通过线程池创建</p>
</li>
</ul>
<p>前面2种创建方法有一个共同的缺陷：不能获取异步执行的结果。在此基础上，才有了使用 Callable 和 FutureTask 创建线程的方法。</p>
<h4 id="Callable-接口"><a href="#Callable-接口" class="headerlink" title="Callable 接口"></a>Callable 接口</h4><p>Callable 是个泛型接口，它的源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Callable 接口类似与 Runnable ，不同的是 Runnable 的run 方法没有返回值，也没有接收异常的异常声明，因此，感觉 Callable 更强大一些，只是 Callable 暂时还没能和 Thread 产生关系。不过，一个在 Callable 接口与 Thread 线程之间搭桥的重要接口 RunnableFuture 接口就要登场了。 </p>
<h4 id="RunnableFuture-接口"><a href="#RunnableFuture-接口" class="headerlink" title="RunnableFuture 接口"></a>RunnableFuture 接口</h4><p>RunnableFuture 接口与 Runnable 接口、Thread 类紧密相关，源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出，它继承了 Runnable 接口，从而可以作为 Thread 的 target ，同时还继承了 Future 接口，保证了可以获取未来的异步执行结果。</p>
<h4 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a>Future 接口</h4><p>Future 接口至少提供了三大功能：</p>
<ul>
<li><p>能够取消异步执行中的任务</p>
</li>
<li><p>判断异步任务是否执行完成</p>
</li>
<li><p>获取有任务完成后的执行结果</p>
</li>
</ul>
<p>它的源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>虽然它提供了这么多功能，但它终归只是个接口，通过它没法直接完成对异步任务的操作，为此，JDK 提供了一个默认实现类： FutureTask 。</p>
<h4 id="FutureTask-类"><a href="#FutureTask-类" class="headerlink" title="FutureTask 类"></a>FutureTask 类</h4><p>FutureTask类实现了RunnableFuture接口，相当于既实现了 Runnable 接口，又实现了 Future 接口。所以FutureTask既能作为一个 Runnable 类型的 target 被Thread执行，又能作为Future异步任务来获取Callable的计算结果。</p>
<h4 id="使用Callable和FutureTask创建线程的步骤"><a href="#使用Callable和FutureTask创建线程的步骤" class="headerlink" title="使用Callable和FutureTask创建线程的步骤"></a>使用Callable和FutureTask创建线程的步骤</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>{</span><br><span class="line">    FutureTask&lt;Long&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Long&gt;(<span class="keyword">new</span> Callable&lt;Long&gt;() {</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(futureTask, <span class="string">"returnableThread"</span>);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    System.out.println(thread.getName() + <span class="string">"线程占用时间："</span> + futureTask.get());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>returnableThread线程首先执行 thread.run() 方法，然后在其中执行其target（futureTask任务）的run()方法；接着在futureTask.run()方法中会执行 callable 成员的 call()方法。Callable的call()方法执行完成后，会将结果保存在FutureTask内部的outcome实例属性中。这里有两种情况：</p>
<ul>
<li><p>futureTask的结果outcome不为空，callable.call()执行完成，futureTast.get会直接取回outcome结果返回给结果获取线程。</p>
</li>
<li><p>futureTask的结果outcome为空，callable.call()还没有执行完。则结果获取线程会被<strong>阻塞</strong>住直到callable.call()执行完成。当执行完后，最终结果会保存到outcome中，futureTask会唤醒结果获取线程。</p>
</li>
</ul>
<h2 id="1-4-线程的核心原理"><a href="#1-4-线程的核心原理" class="headerlink" title="1.4 线程的核心原理"></a>1.4 线程的核心原理</h2><h3 id="1-4-1-线程的调度与时间片"><a href="#1-4-1-线程的调度与时间片" class="headerlink" title="1.4.1 线程的调度与时间片"></a>1.4.1 线程的调度与时间片</h3><p>在不同的操作系统、不同的CPU上，线程的 CPU 时间片长度都不同，windows xp 的时间片长度为 20 毫秒，线程调度模型主要分为 2 种：</p>
<ul>
<li><p>分时调度。系统平均分配 CPU 的时间片，人人平等</p>
</li>
<li><p>抢占式调度。按照线程的优先级分配时间片，如果大家优先级都相同，就随机选择一个，目前大部分操作系统选择的是这种调度方式</p>
</li>
</ul>
<h3 id="1-4-2-线程优先级"><a href="#1-4-2-线程优先级" class="headerlink" title="1.4.2 线程优先级"></a>1.4.2 线程优先级</h3><p>对于优先级，有以下结论：</p>
<ul>
<li><p>整体而言，高优先级的线程获得的执行机会更多</p>
</li>
<li><p>执行机会的获取具有随机性，优先级高的不一定获得机会多（文中的例子10级的优先级比9级的优先级获得的机会还少，个人认为可能的一个因素是：Java的线程映射到系统线程时，10级与 9 级并没有区分）</p>
</li>
</ul>
<h3 id="1-4-3-线程的生命周期"><a href="#1-4-3-线程的生命周期" class="headerlink" title="1.4.3 线程的生命周期"></a>1.4.3 线程的生命周期</h3><p>Java 的线程有6种状态：</p>
<ul>
<li><p>NEW： 新建，创建成功，但是没有调用 start() 方法</p>
</li>
<li><p>RUNNABLE：可执行，包含操作系统的就绪、运行2种状态</p>
</li>
<li><p>BLOCKED：阻塞</p>
</li>
<li><p>WAITTING：等待</p>
</li>
<li><p>TIMED_WAITTING：限时等待，包括Thread.sleep(n)、Object.wait(n)、Thread.join(n)、LockSupport.parkNanos(n)、LockSupport.parkUntil(n) 等</p>
</li>
<li><p>TERMINATED：终止。线程的 run 方法执行完毕（或者执行run方法被异常终止）</p>
</li>
</ul>
<h3 id="1-4-5-使用-Jstack-工具查看线程状态"><a href="#1-4-5-使用-Jstack-工具查看线程状态" class="headerlink" title="1.4.5 使用 Jstack 工具查看线程状态"></a>1.4.5 使用 Jstack 工具查看线程状态</h3><p>Jstack 是Java 虚拟机自带的 <strong>堆栈跟踪工具</strong>，用于生成或者导出（Dump）JVM 运行实例当前时刻的线程快照。命令的语法格式如下：</p>
<blockquote>
<p>jstack <pid>   //pid表示 Java 进程的 id，可以用 jps 命令查看</pid></p>
</blockquote>
<h2 id="1-5-线程的基本操作"><a href="#1-5-线程的基本操作" class="headerlink" title="1.5 线程的基本操作"></a>1.5 线程的基本操作</h2><h3 id="1-5-2-线程的sleep-操作"><a href="#1-5-2-线程的sleep-操作" class="headerlink" title="1.5.2 线程的sleep 操作"></a>1.5.2 线程的sleep 操作</h3><p>sleep 的作用是让线程休眠，让 CPU 执行其他的任务，从状态来讲就是<strong>从执行状态变成限时阻塞状态</strong>。当睡眠时间满后，线程不一定立即得到执行，因为此时CPU可能正在执行其他任务，所以还需要等待分配时间片。</p>
<h3 id="1-5-3-线程的-interrupt-操作"><a href="#1-5-3-线程的-interrupt-操作" class="headerlink" title="1.5.3 线程的 interrupt 操作"></a>1.5.3 线程的 interrupt 操作</h3><p>Java 语言提供了 stop()  方法终止正在运行的方法，但后来不建议使用了，因为这像突然关闭计算机电源一样，无法知道这个线程在处于什么状态，它可能持有某把锁，强行停止可能会导致锁无法释放；或者可能正在操作数据库，强行停止导致数据不一致。</p>
<p>一个线程什么时候可以退出只有线程自己直到，所以，<strong>这里介绍的 interrupt 方法本质不是用来中断一个线程，而是将线程设置为中断状态。</strong>当我们调用线程的 interrupt 方法时，它有2个作用：</p>
<ul>
<li><p>如果此线程处于阻塞状态，就会立马退出阻塞，并抛出 InterruptedException 异常，线程可以通过捕获 InterruptedException 异常来做一定处理，从而提早终结被阻塞状态。</p>
</li>
<li><p>如果线程正在运行，就不受任何影响，仅仅只是中断标记被置为 true 了。</p>
</li>
</ul>
<blockquote>
<p>如果 interrupt()方法先被调用，然后线程开始调用阻塞方</p>
<p>法进入阻塞状态，InterruptedException异常依旧会抛出；如果线程</p>
<p>捕获InterruptedException异常后，继续调用阻塞方法，将不再触发</p>
<p>InterruptedException异常。</p>
</blockquote>
<h3 id="1-5-4-线程的join操作"><a href="#1-5-4-线程的join操作" class="headerlink" title="1.5.4 线程的join操作"></a>1.5.4 线程的join操作</h3><p>也就是线程的合并操作，可以用一个例子来说明： 假设线程 A 和 B，现在 A 执行过程中对 B 的执行有依赖：A 需要将 B 的执行流程合并到自己执行的流程中，这就是线程合并，伪代码大概如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread threadb = <span class="keyword">new</span> Thread(<span class="string">"thread-b"</span>);</span><br><span class="line">        threadb.join();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码中，执行 threadb.join() 这行代码的当前线程为合并线程（线程 A）会进入 TIMED_WAITING 等待状态，让出 CPU。所以上述过程应该是<strong>等 B线程执行完成之后，A 线程再继续执行</strong></p>
<h3 id="1-5-5-线程的-yield-操作"><a href="#1-5-5-线程的-yield-操作" class="headerlink" title="1.5.5 线程的 yield 操作"></a>1.5.5 线程的 yield 操作</h3><p>线程的 yield（让步）操作的作用是让目前正在执行的线程放弃当前的执行，让出 CPU执行权限，之后变为 RUNNABLE 状态，从操作系统层面来讲就是进入了就绪状态（而不是阻塞）。在线程 yield 时，线程放弃和重占 CPU 的时间是不确定的，可能刚放弃了 CPU ，马上又获得了 CPU 的执行权限，接着开始执行了。</p>
<h3 id="1-5-6-线程的daemon操作"><a href="#1-5-6-线程的daemon操作" class="headerlink" title="1.5.6 线程的daemon操作"></a>1.5.6 线程的daemon操作</h3><p>守护线程也称为后台线程，专门指在程序进程运行过程中，在后台提供某种通用服务的线程。比如，每启动一个JVM进程，都会在后台运行一系列的 GC 线程，这些 GC 线程就是守护线程。</p>
<p>只要 JVM 中尚存任何一个用户线程没有结束，守护线程就能执行自己的工作，只有当最后一个用户线程结束，守护线程随同 JVM 一同结束工作。</p>
<h4 id="守护线程的要点"><a href="#守护线程的要点" class="headerlink" title="守护线程的要点"></a>守护线程的要点</h4><p>使用守护线程时，有几点需要特别注意：</p>
<ul>
<li><p>线程必须在start() 方法调用前设置其为守护线程(即调用setDaemon(true)方法) ，否则会抛出 InterruptedException异常</p>
</li>
<li><p>在守护线程中创建的线程，新的线程都是守护线程。如果要创建用户线程，需要显式调用 setDaemon(false)</p>
</li>
</ul>
<h2 id="1-6-线程池原理与实战"><a href="#1-6-线程池原理与实战" class="headerlink" title="1.6 线程池原理与实战"></a>1.6 线程池原理与实战</h2><p>Java 线程的创建非常昂贵，需要 JVM 和 OS 配合完成大量工作：</p>
<ul>
<li>为线程堆栈分配大量内存快，包括至少 1M 的栈内存</li>
<li>需要进行系统调用，以便在OS中创建和注册本地线程</li>
</ul>
<p>而线程池的出现主要解决了以下问题：</p>
<ul>
<li><p>提升性能：最大限度地复用已经创建的线程，避免创建和销毁，提升性能</p>
</li>
<li><p>线程管理：线程池可以保持对线程的统计信息，例如完成任务数量、空闲时间等，能对异步任务进行高效调度（<strong>我个人觉得还有可能根据cpu的核心数之类的确定线程数量</strong>）。</p>
</li>
</ul>
<h3 id="1-6-1-JUC-的线程池架构"><a href="#1-6-1-JUC-的线程池架构" class="headerlink" title="1.6.1 JUC 的线程池架构"></a>1.6.1 JUC 的线程池架构</h3><p>JUC 是 java.util.concrrent 工具包的简称，是用于完成高并发、处理多线程的一个工具包。其中的线程池类与接口的架构图大致如下：</p>
<p><img src="/assets/Book-Notes/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%8D%B72/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%8D%B72-%E7%AC%AC1%E7%AB%A0-JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="线程池类与接口的架构图"></p>
<h3 id="1-6-2-Executors-的4种快捷创建线程池的方法"><a href="#1-6-2-Executors-的4种快捷创建线程池的方法" class="headerlink" title="1.6.2 Executors 的4种快捷创建线程池的方法"></a>1.6.2 Executors 的4种快捷创建线程池的方法</h3><p>Java 通过 Excutors 工厂类提供了4种快捷创建线程池的方法，如下表所示：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能简介</th>
</tr>
</thead>
<tbody><tr>
<td>newSingleThreadExcutor</td>
<td>创建只有一个线程的线程池</td>
</tr>
<tr>
<td>newFixedThreadPool</td>
<td>创建固定大小的线程池</td>
</tr>
<tr>
<td>newCachedThreadPool</td>
<td>创建一个不限制线程数量的线程池，任何提交的任务都立即执行，但是空闲线程会得到及时回收</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>创建一个可定期或者延时执行的任务的线程池</td>
</tr>
</tbody></table>
<p>总的来说，newSingleThreadExcutor 线程池有以下特点：</p>
<ul>
<li><p>线程池中的任务是按照提交的顺序执行的</p>
</li>
<li><p>池中的唯一线程的存活时间是无限的</p>
</li>
<li><p>当池中唯一线程繁忙时，<strong>新提交的任务会进入内部的阻塞队列，这个队列是无界队列</strong></p>
</li>
</ul>
<p>线程池使用完后，要调用 shutDown 来关闭线程池，此时线程池将变为 SHUTDOWN 状态，将拒绝新任务，添加新任务会抛出 RejectedExecutionException 异常，此时，线程池不会立刻退出，直到线程池中的任务都执行完成。还有另一个方法 shutdownNow ，执行之后线程状态会立刻变成 STOP ，并且不再处理了还在阻塞队列中等待的任务，会返回哪些未执行的任务。</p>
<p>newFixedThreadPool用于创建一个“固定数量的线程池”，它的特点如下：</p>
<ul>
<li>提交任务时，如果显成熟没有达到固定数量，线程池内就会创建一个新线程，直到达到固定数量</li>
<li>提交新任务时，如果所有的线程都在繁忙，则新任务会进入阻塞队列，该队列是<strong>无界的阻塞队列</strong></li>
</ul>
<p>“固定数量的线程池”适合场景： 需要任务长期执行的场景，比如处理CPU密集型任务。线程数能够比较稳定地维持在某个数量，避免频繁回收和创建线程。</p>
<p>newCachedThreadPool 创建“可缓存线程池”，如果线程池内某些线程成为空闲线程，“可缓存线程池”能灵活回收这些线程。它的特点大致如下：</p>
<ul>
<li>接收新任务时，如果池内所有线程繁忙，则添加新线程来处理</li>
<li>对线程池大小没有限制，完全依赖于JVM能够创建的最大线程大小</li>
<li>如果线程空闲（60s不执行任务），就会回收</li>
</ul>
<p>它的适合场景：需要快速处理突发性强，耗时短的任务场景，如 Netty 的 NIO 处理场景、REST API 接口瞬时削峰场景。</p>
<p>newScheduledThreadPool 创建“可调度线程池”，它提供一个“延时”和“周期性”任务调度功能的ScheduledExecutorService类型的线程池。使用方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduled = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 参数中：0表示首次执行任务的延迟时间，500表示每次执行任务的间隔时间</span></span><br><span class="line">scheduled.scheduleAtFixedRate(<span class="keyword">new</span> TargetTask(), <span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></tbody></table></figure>

<p>“可调度线程池”的适用场景：周期性地执行任务的场景。</p>
<h3 id="1-6-3-线程池的标准创建方式"><a href="#1-6-3-线程池的标准创建方式" class="headerlink" title="1.6.3 线程池的标准创建方式"></a>1.6.3 线程池的标准创建方式</h3><p>大部分企业的开发规范会禁止时候用上述Java 提供的4种创建线程池的方式。，要求通过标准创建方式自行创建。标准创建的一个构造方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用标准构造器构造一个普通的线程池</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">int</span> corePoolSize, // 核心线程数，即使线程空闲（Idle），也不会回收</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">int</span> maximumPoolSize, // 线程数的上限</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">long</span> keepAliveTime, TimeUnit unit, // 线程最大空闲（Idle）时长</span></span></span><br><span class="line"><span class="params"><span class="function"> BlockingQueue&lt;Runnable&gt; workQueue, // 任务的排队队列</span></span></span><br><span class="line"><span class="params"><span class="function"> ThreadFactory threadFactory, // 新线程的产生方式</span></span></span><br><span class="line"><span class="params"><span class="function"> RejectedExecutionHandler handler)</span> <span class="comment">// 拒绝策略</span></span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="corePoolSize-与-maximumPoolSize"><a href="#corePoolSize-与-maximumPoolSize" class="headerlink" title="corePoolSize 与 maximumPoolSize"></a>corePoolSize 与 maximumPoolSize</h5><p>corePoolSize 与 maximumPoolSize 自动维护线程池中的工作线程，规则如下：</p>
<ul>
<li>收到新任务，并且当前线程数少于 corePoolSize，即使其他线程处于空闲状态，也会创建新线程来处理该请求</li>
<li>核心线程不会被回收，但是如果设置了 allowCoreThreadTimeOut 的话，则会例外，这时候是可以被回收的</li>
<li>如果当前线程数大于 corePoolSize ，但是小于 maximumPoolSize ，那么仅当任务排队队列已满才会创建新线程。</li>
<li>当 maximumPoolSize 被设置为无界值（如Integer.MAX_VALUE，因为这是int的最大值了）时，线程池可以接受任意数量的并发任务</li>
<li>corePoolSize 与 maximumPoolSize 的值可以动态更改</li>
</ul>
<blockquote>
<p>根据上述规则可知，<strong>给 corePoolSize 和 maximumPoolSize 设置相同的值可以创建一个固定大小的线程池。</strong></p>
</blockquote>
<h5 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h5><p>BlockingQueue 也就是阻塞队列，如果线程池的核心线程都在忙，则收到的任务都缓存在阻塞队列中</p>
<h5 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h5><p>用于设置线程的最大 Idle 市场，如果非 Core 线程（默认情况下只针对非Core线程，但如果allowCoreThreadTimeOut 设置为true，则也会应用于Core线程）空闲超过这个时常，就会被回收。<strong>如果要防止 Idle 线程被回收，可以将 keepAliveTime 设置为 Long.MAX_VALUE</strong>。当然，这个值也是能动态调整的。</p>
<h3 id="1-6-4-向线程池提交任务的2种方式"><a href="#1-6-4-向线程池提交任务的2种方式" class="headerlink" title="1.6.4 向线程池提交任务的2种方式"></a>1.6.4 向线程池提交任务的2种方式</h3><p>有 submit 和 execute 两种方式，这二者的区别：</p>
<ul>
<li>submit 有返回值 Future ，execute 没有</li>
<li>由于 submit 有返回值Future ，所以可以方便对当前任务处理 Exception</li>
<li>入参不同，submit 可以接收 Callable、Runnable 两种，execute 只能接收 Runnable</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//submit 结果获取和异常处理</span></span><br><span class="line"><span class="keyword">try</span>{</span><br><span class="line">    Future&lt;Integer&gt; future = pool.submit(callable);</span><br><span class="line">    Interger result = future.get();</span><br><span class="line">} <span class="keyword">catch</span>(Exception e) {</span><br><span class="line">    e.printStack();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-6-5-线程池任务调度流程"><a href="#1-6-5-线程池任务调度流程" class="headerlink" title="1.6.5 线程池任务调度流程"></a>1.6.5 线程池任务调度流程</h3><p>任务调度流程大致如下：</p>
<ol>
<li>接收任务时，如果当前线程数量小于核心线程数，则创建线程（哪怕其他线程空闲），然后执行任务</li>
<li>如果线程池中的线程大于核心线程数量，新任务将被加入阻塞队列，直到阻塞队列满了</li>
<li>完成一个任务后，优先从阻塞队列中获取下一个任务，直到阻塞队列为空</li>
<li>当核心线程繁忙，并且阻塞队列也已经满了，如果再接收到新任务，将会为新任务创建一个（非核心）线程，并立即开始执行<strong>新任务</strong>。</li>
<li>当核心线程繁忙，阻塞队列满的情况下，来新任务会一直创建线程，当线程总数超过 maximumPoolSize 时就会执行拒绝策略。</li>
</ol>
<h3 id="1-6-6-ThreadFactory-（线程工厂）"><a href="#1-6-6-ThreadFactory-（线程工厂）" class="headerlink" title="1.6.6 ThreadFactory （线程工厂）"></a>1.6.6 ThreadFactory （线程工厂）</h3><p>略</p>
<h3 id="1-6-7-BlockingQueue（任务阻塞队列）"><a href="#1-6-7-BlockingQueue（任务阻塞队列）" class="headerlink" title="1.6.7 BlockingQueue（任务阻塞队列）"></a>1.6.7 BlockingQueue（任务阻塞队列）</h3><p>阻塞队列与普通队列相比有一个重要的特点: <strong>一个线程从一个空的阻塞队列获取元素时会被阻塞(怎么实现的？)，直到队列中有了元素；当队列中有了元素，被阻塞的线程会被自动唤醒。</strong>比较常用的实现类有以下几种：</p>
<ul>
<li>ArrayBlockingQueue：数组实现的<strong>有界阻塞队列</strong>，队列中元素按照 FIFO 排序。</li>
<li>LinkedBlockingQueue：基于链表实现的阻塞队列，按照 FIFO 排序，<strong>可以设置容量(有界队列)，不设置容量则默认使用 Integer.Max_VALUE 作为容量（即无界队列）</strong>。</li>
<li>PriorityBlockingQueue： 具有优先级的<strong>无界队列</strong></li>
<li>DelayQueue：<strong>无界阻塞延迟队列</strong>，底层基于 PriorityBlockingQueue，队列中每个元素都有过期时间，当从队列获取元素时，<strong>只有已经过期的元素才会出队，队列头部是做早过期的元素</strong></li>
<li>SynchronousQueue ：同步队列，不存储元素的阻塞队列，<strong>每个插入操作必须等到另一个线程的调用移除操作，否则插入一直处于阻塞状态。</strong></li>
</ul>
<blockquote>
<p>Excutors.newScheduledThreadPool所创建的线程池就是使用 DelayQueue<br>而，Executors.newCachedThreadPool 所创建的线程池使用的是 SynchronousQueue</p>
</blockquote>
<h3 id="1-6-8-调度器钩子方法"><a href="#1-6-8-调度器钩子方法" class="headerlink" title="1.6.8 调度器钩子方法"></a>1.6.8 调度器钩子方法</h3><ul>
<li>beforeExecute： 执行目标实例前在工作线程异步执行该方法</li>
<li>afterExecute： 执行目标实例后在工作线程异步执行该方法</li>
<li>terminated： 线程池终止时的钩子方法</li>
</ul>
<h3 id="1-6-9-线程池的拒绝策略"><a href="#1-6-9-线程池的拒绝策略" class="headerlink" title="1.6.9 线程池的拒绝策略"></a>1.6.9 线程池的拒绝策略</h3><p>当出现如下情况时，新提交的任务会被拒绝：</p>
<ol>
<li>线程池已经被关闭</li>
<li>所有线程繁忙，并且线程数已经达到了 maximunPoolSize</li>
</ol>
<p>当拒绝的时候，会调用 RejectedExecutionHandler 实例的 rejectedExecution 方法，JUC 提供了以下几种实现：</p>
<ul>
<li>AbortPolicy ： 新任务丢掉同时抛出 RejectedExecutionException 异常，这是线程池默认策略</li>
<li>DiscardPolicy： 新任务直接丢掉，并且不会抛出异常</li>
<li>DiscardOldestPolicy： 抛弃最早的任务，然后让新任务入队</li>
<li>CallerRunsPolicy： 调用者执行策略，提交任务线程会自己执行该任务</li>
<li>自定义策略</li>
</ul>
<h3 id="1-6-10-线程池的优雅关闭"><a href="#1-6-10-线程池的优雅关闭" class="headerlink" title="1.6.10 线程池的优雅关闭"></a>1.6.10 线程池的优雅关闭</h3><p>优雅地关闭线程池主要涉及的方法有 3 个：</p>
<ul>
<li>shutDown： 这是有序关闭线程池的方法，调用之后当前线程会立即返回，不会等待线程池关闭完成。<strong>会等待当前工作队列中剩余的任务全部执行完毕，才关闭线程池</strong>。只要调用了这个方法，线程池会转为 SHUTDOWN 状态，不会再接收任务</li>
<li>shutDownNow ：立即关闭线程池，调用之后当前线程会立即返回，不会等待线程池关闭完成。</li>
<li>awaitTermination： shutDown与shutDownNow调用后会立即返回，不管线程池的关闭。而这个方法就是用于等待线程池完成关闭。</li>
</ul>
<p>优雅关闭线程池的方法：</p>
<ol>
<li>调用 shutDown 方法，拒绝新任务提交</li>
<li>调用 awaitTermination(long timeOut) 指定超时时间，判断是否已经关闭</li>
<li>如果 awaitTermination 超时，就可以进入循环关闭，循环一定次数(比如1000次)，不断关闭线程池，直到关闭或者结束</li>
<li>如果 awaitTermination 返回false 或者 被中断，调用 shutDownNow 立即关闭</li>
</ol>
<h3 id="1-6-11-Executors-快捷创建线程池的潜在问题-系统默认提供的4种方法"><a href="#1-6-11-Executors-快捷创建线程池的潜在问题-系统默认提供的4种方法" class="headerlink" title="1.6.11 Executors 快捷创建线程池的潜在问题(系统默认提供的4种方法)"></a>1.6.11 Executors 快捷创建线程池的潜在问题(系统默认提供的4种方法)</h3><ul>
<li>newFixedThreadPool创建的固定大小线程池：它的阻塞队列是 LinkedBlockingQueue 类型的无界队列，可能导致大量的任务等待，队列太大还可能导致 OOM </li>
<li>单线程的线程池也是无界队列，可能导致OOM</li>
<li>newCachedThreadPool 创建可缓存线程池：因为核心线程数 0 ，最大线程数为 Integer.MAX_VALUE，阻塞队列为 SynchronousQueue<runnable> 同步队列，不缓存任务，所以理论上任务数量不受限制，相当于来一个任务首先寻找可用线程，没有的话，就创建一个新的。会导致创建的线程过多，可能造成 OOM ，甚至把 CPU资源耗尽</runnable></li>
<li>newScheduledThreadPool 创建可调度线程池，其最大问题是线程数量不设上限，可能导致CPU资源耗尽</li>
</ul>
<h2 id="1-7-确定线程池的线程数"><a href="#1-7-确定线程池的线程数" class="headerlink" title="1.7 确定线程池的线程数"></a>1.7 确定线程池的线程数</h2><h3 id="1-7-1-按照任务类型分类"><a href="#1-7-1-按照任务类型分类" class="headerlink" title="1.7.1 按照任务类型分类"></a>1.7.1 按照任务类型分类</h3><ul>
<li>IO 密集型： IO任务操作时间长，导致 CPU 利用率不高，常处于空闲状态。线程数确定：设置allowCoreThreadTimeOut为true、使用有界队列、corePollSize 和 maximunPoolSize 保持一致，使得接收新任务而没有空闲线程时，直接创建新线程执行，而不是在阻塞队列中等待。</li>
<li>CPU 密集型： 主要是计算任务，CPU一直在运行，利用率很高。线程数确定：CPU密集型任务虽然可以并行完成，但是并行任务越多，花在任务切换的时间也越多，效率也就越低。<strong>CPU密集型任务并行执行的数量应当等于CPU的核心数</strong>。</li>
<li>混合性任务：既要逻辑计算，又要IO。线程数确定：业界有一个公式</li>
</ul>
<h2 id="1-8-ThreadLocal-原理与实战"><a href="#1-8-ThreadLocal-原理与实战" class="headerlink" title="1.8 ThreadLocal 原理与实战"></a>1.8 ThreadLocal 原理与实战</h2><p>ThreadLoacal 的应用场景大致有 2 类：</p>
<ul>
<li>线程隔离</li>
<li>跨函数传递数据</li>
</ul>
<p>原理：每一个线程在获取本地值时，都会将 ThreadLocal 实例作为 Key 从自己拥有的 ThreadLocalMap 中获取值，别的线程无法访问自己的 ThreadLocalMap ，自己也无法访问别人的。并且，由于 ThreadLocalMap 是线程私有的，当线程销毁时 ThreadLocalMap 也随之销毁，在一定程度上减少内存的消耗。</p>
<h3 id="1-8-8-ThreadLocal-综合使用案例"><a href="#1-8-8-ThreadLocal-综合使用案例" class="headerlink" title="1.8.8 ThreadLocal 综合使用案例"></a>1.8.8 ThreadLocal 综合使用案例</h3><p>ThreadLocal 使用不当会造成严重的内存泄露，为了避免这种情况，使用时应遵守以下原则：</p>
<ul>
<li>尽量使用 private static final 修饰ThreadLocal ，final为了避免他人修改、变更 ThreadLocal 变量的引用，使用static 为了确保全局唯一</li>
<li>ThreadLocal 使用完后务必调用 remove 方法，这是简单有效避免引发内存泄露问题的方法</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/06/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/%E7%AC%AC6%E7%AB%A0-%E5%85%B6%E4%BB%96%E4%BC%98%E7%A7%80%E7%9A%84%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/06/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/%E7%AC%AC6%E7%AB%A0-%E5%85%B6%E4%BB%96%E4%BC%98%E7%A7%80%E7%9A%84%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">第6章-其他优秀的热修复方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-06 18:30:00" itemprop="dateCreated datePublished" datetime="2023-02-06T18:30:00+08:00">2023-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-05 22:01:57" itemprop="dateModified" datetime="2023-02-05T22:01:57+08:00">2023-02-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Dexposed浅析"><a href="#Dexposed浅析" class="headerlink" title="Dexposed浅析"></a>Dexposed浅析</h2><p>Dexposed 对于某个函数而言，有3个hook点可供选择：函数执行前注入（before），函数执行后注入（after），替换函数执行的代码段（replace），由此衍生了很多典型应用场景：</p>
<ul>
<li><p>AOP 编程</p>
</li>
<li><p>插桩（例如测试，性能监控等）</p>
</li>
<li><p>在线热更新</p>
</li>
<li><p>SDK hooking 以提供更好的开发体验</p>
</li>
</ul>
<h3 id="AndFix"><a href="#AndFix" class="headerlink" title="AndFix"></a>AndFix</h3><p>略</p>
<h3 id="腾讯系热修复方案简介"><a href="#腾讯系热修复方案简介" class="headerlink" title="腾讯系热修复方案简介"></a>腾讯系热修复方案简介</h3><p>略</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/05/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/%E7%AC%AC5%E7%AB%A0-so%E5%BA%93%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/05/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/%E7%AC%AC5%E7%AB%A0-so%E5%BA%93%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">第5章-so库热修复技术</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-05 21:30:00 / 修改时间：21:53:09" itemprop="dateCreated datePublished" datetime="2023-02-05T21:30:00+08:00">2023-02-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="so库加载原理"><a href="#so库加载原理" class="headerlink" title="so库加载原理"></a>so库加载原理</h2><p>Java API 提供 2 个接口加载一个 so 库：</p>
<ul>
<li><p>System.loadLibrary(String libName): 传进去 so 库名称，位于APK压缩文件的 libs 目录，最后复制到 APK 安装目录下</p>
</li>
<li><p>System.load(String pathName)：传进去的是so库在磁盘的完整路径，加载自定义的外部so</p>
</li>
</ul>
<p>以上2中方式最后都调用到 nativeLoad 这个 Native 方法。</p>
<p><strong>so 库实时生效方案，对于静态注册的 native 方法有一定的局限性，不能满足一般的通用性，所以放弃了 so 库实时生效需求，转而求其次，实现 so 库修复的冷部署重启生效方案。</strong></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/04/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/%E7%AC%AC4%E7%AB%A0-%E8%B5%84%E6%BA%90%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/04/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/%E7%AC%AC4%E7%AB%A0-%E8%B5%84%E6%BA%90%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">第4章-资源热修复技术</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-04 17:00:00" itemprop="dateCreated datePublished" datetime="2023-02-04T17:00:00+08:00">2023-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-05 21:43:28" itemprop="dateModified" datetime="2023-02-05T21:43:28+08:00">2023-02-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="普遍的实现方式"><a href="#普遍的实现方式" class="headerlink" title="普遍的实现方式"></a>普遍的实现方式</h2><p>目前市面上很多资源热修复都参考了 Instant Run 的实现，首先看下 Instant Run 是怎么做到资源热修复的：</p>
<ol>
<li><p>创建一个新的 AssetManager (AssetManager.class.getConstructor().newInstance())，并通过反射调用 addAssetPath 添加 sdcard 上的新资源包</p>
</li>
<li><p>反射所有 Activity 中 AssetManager 的引用处，全部换成刚才新建的 newAssetManager</p>
</li>
<li><p>得到 Resource 的弱引用集合，把它们的 AssetManager 成员替换成 newAssetManager</p>
</li>
</ol>
<p>总体来说就是2步：构造一个新的 AssetManager ，并通过反射调用 addAssetPath ，这样就得到一个含有所有新资源的 AssetManager；找到所有引用到原有 AssetManager 的地方，通过反射把引用处替换成 newAssetManager 。</p>
<h3 id="资源文件的格式"><a href="#资源文件的格式" class="headerlink" title="资源文件的格式"></a>资源文件的格式</h3><p>我们随便找个带资源的APK，用 AAPT 解析以下，可以看到内容大概是这样的：</p>
<blockquote>
<p>aapt d resources App-debug.apk</p>
<p>…</p>
<p>spec resource 0x7f040019 com.taobao.demo:layout/activity_main:flags=0x00000000</p>
</blockquote>
<p>这就表示，activity_main.xml 这个资源编号是 0x7f040019， 其中packageid 是 0x7f ， 资源类型id 是 0x04 ，在Type String Pool 中对应的正是 layout 类型，而 0x04 类型的 第 0x0019 个资源就是 activity_main 这个资源。</p>
<h3 id="运行时资源的解析"><a href="#运行时资源的解析" class="headerlink" title="运行时资源的解析"></a>运行时资源的解析</h3><p>默认由 Android SDK 编出来的 APK 是由 AAPT 工具打包的，其资源包的 package id 就是 0x7f 。<strong>在走到 App第一行代码之前，系统就已经帮我们构建好一个已经添加了安装包资源的 AssetManager 了，即包含了 package id 为0x01 的 framework-res.jar 中资源和 package id 为 0x7f 的 App 安装包资源</strong>。</p>
<p>如果补丁包中资源的 package id 也是 0x7f ，就会使得同一个 package id 的包被加载2次，怎么解决呢？</p>
<blockquote>
<p>在Android L 之后这是没问题的，因为它会默默把后来的包添加到之前的包的同一个 PackageGroup 下面，仍旧会加入到该类型的 TypeList 中，只是会打出一个 warning log。但是，使用时获取某个 Type 资源时，会从前往后遍历，也就是说先得到原有安装包里的资源，补丁包中的资源永远无法生效了。<strong>所以，在Android L 以上的版本，在原有的 AssetManager 上加入补丁包，是没有任何作用的。</strong></p>
<p>而在 Android 4.4 以下版本，addAssetPath 只是把补丁包的路径添加到了 mAssetPath 中，这时候早已经错过真正解析资源包时间了。</p>
</blockquote>
<p><strong>以上解释了为什么像 Instant Run 这种方案，一定需要一个全新的 AssetManager ，然后再加入完整的新资源包，替换原有的 AssetManager。</strong></p>
<h4 id="另辟蹊径的资源修复方案"><a href="#另辟蹊径的资源修复方案" class="headerlink" title="另辟蹊径的资源修复方案"></a>另辟蹊径的资源修复方案</h4><p>一个好的资源修复方案，首先补丁包要足够小，直接下发完整的补丁包肯定是不行的。目前主要有以下方案：</p>
<ul>
<li><p>对资源包做差量处理，在运行时合成完整包，虽然减少了包体积，但是运行时的合成操作耗费了运行事件和内存。</p>
</li>
<li><p>自己修改 AAPT ，在打补丁包时对资源重新编号，这样会涉及修改 Android SDK 工具包，不利于集成，也无法很好地对将来的 AAPT 升级。</p>
</li>
</ul>
<p>我们的方案：构造一个package id 为 id 0x66 的资源包，它只包含改变了的资源项，直接在原有 AssetManager 中 addAssetPath 这个包即可。补丁包的资源，只包含原有包没有而新报里面有的<strong>新增资源</strong>，以及<strong>发生了改变的资源</strong>。对于增加、减少、修改这3种情况，我们要如何处理呢？</p>
<ul>
<li><p>新增资源直接假如补丁包</p>
</li>
<li><p>减少资源，只要不使用这个资源就好了</p>
</li>
<li><p>修改资源，比如替换了一张图片，那么将其视为新增资源，在打入补丁包的时候，代码引用处也做相应修改，把原来使用的旧资源id的地方变为新的 id</p>
</li>
</ul>
<p>一张图说明下这些情况(绿线表示新增资源，红线表示发生修改的资源，黑线表示内容没有变化，但是id发生了变化的，x表示删除了的资源)：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-2-%E8%B5%84%E6%BA%90%E8%A1%A5%E4%B8%81%E5%8C%85%E6%9E%84%E5%BB%BA.png" alt="资源补丁包构建"></p>
<h4 id="新增的资源及其导致的id偏移"><a href="#新增的资源及其导致的id偏移" class="headerlink" title="新增的资源及其导致的id偏移"></a>新增的资源及其导致的id偏移</h4><p><strong>新资源插入的位置是随机的，这与每次 AAPT 打包时解析 XML 的顺序有关。</strong></p>
<p>所以，新增的资源导致它们所属的 type 中跟在它们之后的资源 id 发生了位移，<strong>发生位移的资源不会加入补丁包中，但是在补丁包的代码中会调整 id 的引用处，</strong>如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageView.setImageResource(R.drawable.holo)</span><br></pre></td></tr></tbody></table></figure>

<p>R.drawable.holo 是一个int 值，它的值是 AAPT 指定的，可以用反编译工具可以看到它的真实值：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageView.setImageResource(<span class="number">0x7f020002</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>打出一个新包时，对于开发者而言，holo 的图片内容没变，代码引用处也没变，但是在新包里面，同样这句话，由于新资源插入导致 id 改变，所以引用实际变成了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageView.setImageResource(<span class="number">0x7f020003</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>但这种情况不属于资源改变，更不属于代码改变，所以，我们在对比新旧代码之前，会把新包里面的这行代码修正为原来的id：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageView.setImageResource(<span class="number">0x7f020002</span>)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="内容发生改变的资源"><a href="#内容发生改变的资源" class="headerlink" title="内容发生改变的资源"></a>内容发生改变的资源</h4><p>内容发生改变，比如 activity_main.xml 文件内容改变了，也可能我们修改了string 类型的值，他们都会加入到补丁包中，并重新编号，相应代码也会改变：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setContentView(R.layout.activity_main)</span><br></pre></td></tr></tbody></table></figure>

<p>实际上就是：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setContentView(<span class="number">0x7f030000</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>在生成新旧代码对比之前，我们会把新包里面的这行代码改为：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setContentView(<span class="number">0x66020000</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这样，新旧代码对比时，会检测到这行代码发生了改变，于是相应的代码修复会在运行时发生，这样就得到了正确的新内容资源。</strong></p>
<h4 id="删除了的资源"><a href="#删除了的资源" class="headerlink" title="删除了的资源"></a>删除了的资源</h4><p>不影响补丁包，就不多言</p>
<h4 id="对于type的影响"><a href="#对于type的影响" class="headerlink" title="对于type的影响"></a>对于type的影响</h4><p>上面说的所谓简单，值得是运行时应用补丁变得简单了。真正复杂的地方在于构造补丁。</p>
<h3 id="更优雅地替换-AssetManager"><a href="#更优雅地替换-AssetManager" class="headerlink" title="更优雅地替换 AssetManager"></a>更优雅地替换 AssetManager</h3><p>分2种情况：</p>
<ul>
<li><p>对于 Android L 以后的版本，直接在原有 AssetManager 上应用补丁就行了，并且由于是应用原来的 AssetManager ，与 Instant Run 方案比，省略了大量的反射和替换操作，提升了加载补丁的效率</p>
</li>
<li><p>之前提过，在Android KK 和以下版本，addAssetPath 是不会加载资源的。<strong>我们对原有的 AssetManager 先进行析构，再重构的时候将补丁包资源也加入，用的还是原来的 AssetManager，同样避免了反射和替换操作</strong>（Instant Run  方案还是必须重新构造一个新的 AssetManager 并加入补丁包，再替换原来的）</p>
</li>
</ul>
<h3 id="意料之外的资源问题"><a href="#意料之外的资源问题" class="headerlink" title="意料之外的资源问题"></a>意料之外的资源问题</h3><p>在加载完补丁之后，如果做了 new WebView() 操作，就会发现找不到新资源的问题，这是因为 WebView 初始化时可能会构造新的 ResourceImpl ，替换掉了原先的 ResourceImpl ，从而把补丁资源给一起丢掉了。其他的就不展开。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>对比市面上的方案，我们的方案优势：</p>
<ul>
<li><p>不侵入打包，直接对比新旧资源即可产生补丁资源（对比修改 AAPT）</p>
</li>
<li><p>不必下发完整包，补丁中只有变动的资源（对比 Instant Run、Amigo等方式）</p>
</li>
<li><p>不需要在运行时合成完整包，不占用运行时的计算和内存资源（对比Tinker）</p>
</li>
</ul>
<p>唯一需要注意的是，<strong>因为对新资源的引用是在新代码中，所有资源修复需要代码修复的支持的</strong></p>
<p>可能的问题：查找旧 id 的时候，是直接对 int 值替换，所以会找到 0x7f?????? ，如果开发者也使用了 0x7f?????? 这样的数字，就会导致数字会被错误地转换。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/03/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9D%A2-%E7%9C%9F%E9%A2%98/%E8%87%AA%E6%88%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/03/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9D%A2-%E7%9C%9F%E9%A2%98/%E8%87%AA%E6%88%91/" class="post-title-link" itemprop="url">自我经验</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-03 22:18:00" itemprop="dateCreated datePublished" datetime="2023-02-03T22:18:00+08:00">2023-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-14 22:44:06" itemprop="dateModified" datetime="2023-04-14T22:44:06+08:00">2023-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>1、内存泄漏怎么检测？LeakCanary 原理</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>
[参考以前的源码解析第10点](https://glassx.gitee.io/2019/11/20/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/)
</details>

<p>2、HashMap 源码？为什么要将链表转成红黑树？红黑树特点？</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>
[参考java基础中的第3点](https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/)

</details>

<p>3、消息循环源码、如何做到任务切换线程？想要提交一个任务有几种方式？</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>关于源码，可以从postDelay、IdleHandler、插队的msg 几个角度来讲。其中源码可以查看<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础中的3、4题</a>，后面两个可以参考<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础的32、33题</a></p>
</details>

<p>4、多个Fragment在销毁后重建之后重叠怎么办</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="产生重叠的原因"><a href="#产生重叠的原因" class="headerlink" title="产生重叠的原因"></a>产生重叠的原因</h3><p>一般是由于我们采用show 和 hide 的方式( 而不是replace )来控制Fragment 的显示和隐藏，当Activity 由于内存不足被回收之后再恢复的时候，如果不做处理，那就会把这些fragment new 出来添加到Activity 中，由于是刚new出来的，并没有以前的show/hide 状态，因此就造成重叠。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在第一次进入Activity 初始化Fragment的时候，为添加的fragment 设置tag ，并且 tag 为fragment的全限定名，将这些tag以列表形式tags保存。在 onSaveInstanceState 回调的时候，保存tags。</p>
<p>在恢复的时候，首先恢复出来tags，再依次遍历tags中的tag，使用FragmentManager.findFragmentByTag 查找fragment。如果查找出来的 fragment 不空，则直接使用，否则的话，就使用 savedInstanceState?.classLoader.loadClass(tag) 来反射新建这个fragment (因为我们的tag就是fragment 的全限定名嘛)。</p>
<h3 id="replace-方式切换fragment-与-show-hide-方式切换fragment"><a href="#replace-方式切换fragment-与-show-hide-方式切换fragment" class="headerlink" title="replace 方式切换fragment 与 show/hide 方式切换fragment"></a>replace 方式切换fragment 与 show/hide 方式切换fragment</h3><p>replace 固然可以避免很多不必要的问题，但是它不能保存页面状态，对用户体验不友好，频繁切换还会导致卡顿。show/hide 方式只会控制隐藏/展示，所以效率上会好一些。</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d2b088e7b6c0">简书上的博客</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27258799/article/details/80489722">披萨大叔</a></p>
</blockquote>
<p>5、设计一个图片缓存框架，缓存算法用什么</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>缓存算法使用 LRUCache，其原理可以参考<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础-LruCache原理</a></p>
</details>

<p>6、有个ListView快速滑动 如何优化Bitmap的显示</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>监听列表的 onScrollChangeListener ，在快速滑动的时候， Fresco.getImagePipeline().pause() ,停下之后又 resume() 操作。</p>
</details>

<blockquote>
<p>以上内容可以参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ldq2016/p/6646761.html">cnblogs上的博客</a></p>
</blockquote>
<p>7、Bitmap的复用听过没有</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Bitmap 复用可以参考 <a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础的58知识点</a></p>
<p>大图加载可以参考<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础38知识点</a></p>
</details>

<p>kotlin 协程原理？怎么切换线程的？Kotlin 优点和缺点？</p>
<p>调优、怎么瘦身，打包流程，模块化</p>
<p>开发者模式中，GPUInfo 中柱状图颜色代表的含义；命令dumpsys meminfo中VSS、PSS、GSS、USS代表什么意思</p>
<p>Android绘制三部曲、Canvas是怎么最终显示在屏幕中的、是以什么样子的数据结构传输的</p>
<p>物理内存与虚拟内存的关系、Android Heap的结构是怎么样的、如果要进行垃圾回收，会收集那些区域</p>
<p>binder源码、其原理是什么，发起一次请求的过程，如何根据文件描述符找到对应的binder实体</p>
<p>如何进行内存优化 减少内存消耗</p>
<h2 id="虾"><a href="#虾" class="headerlink" title="虾"></a>虾</h2><p>1、try catch finally关于return的执行结果</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>参考<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">java基础-Java finally与return执行顺序</a></p>
</details>

<p>2、treemap如何对两个元素进行比较? 非compareble对象比较?</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>如果是非 compareble 对象，则通过构造函数传入自定义的 Comparetor 比较器。</p>
<p>参考<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">java基础第10个知识点</a></p>
</details>

<p>3、object有什么方法</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>clone、equals、finalize、getClass、hashCode、identityHashCode、identityHashCodeNative、internalClone、notify、notifyAll、toString、wait</p>
</details>

<blockquote>
<p>以上内容参考自系统源码</p>
</blockquote>
<p>4、讲讲Android存在的设计模式</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>Context 的装饰器模式       </li>
<li>AlertDialog 使用了建造者模式     </li>
<li>BitmapFactory 的工厂模式    </li>
<li>View 的layout、measure、draw 就是 责任链模式</li>
<li>aidl 代理模式     </li>
<li>ListView、Gridview 等 使用的适配器模式      </li>
</ul>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1a9f571ad7c0">简书上的文章</a></p>
</blockquote>
<p>5、android的事件分发</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>可以参考<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/">以前写的专题</a></p>
</details>

<p>6、android的消息机制</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础的第4点</a></p>
</details>

<p>7、LeakCanary</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/20/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/">参考以前的源码解析第10点</a></p>
</details>

<p>8、讲个android的源码 自选</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>讲讲Handler，在<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础的第4点</a>的基础上完善下表述。</p>
</details>

<p>9、hashcode 与 equals理解</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>可以看看<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">Java基础的15~18知识点</a></p>
</details>

<p>10、设计模式讲讲有什么认识的，代理模式优缺点</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>代理模式优点：</p>
<ul>
<li>协调调用者和被调用者，降低耦合度    </li>
<li>增强被调用者的功能。增加和更换代理无需修改被调用者源码，如何开闭原则，具有良好的可扩展性。      </li>
<li>保护目标对象      </li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了类         </li>
<li>速度可能慢。在调用者和被调用者之间增加了代理对象，因此请求处理的速度可能会变慢    </li>
<li>增加系统复杂度。实现代理模式需要额外的工作，有些可能还比较复杂，比如远程代理。      </li>
</ul>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6991491be81a">简书上的博客</a></p>
</blockquote>
<p>图片 缓存机制</p>
<p>首屏调优 内存调优</p>
<h2 id="lazada"><a href="#lazada" class="headerlink" title="lazada"></a>lazada</h2><p>1、自我介绍一下    </p>
<p>2、app网络防劫持 介绍下，出现劫持，解决方案呢？拦截了webview 网络请求后，用什么请求 </p>
<p>3、性能优化，做了哪些工作</p>
<p>4、强引用、弱引用和软引用。弱引用和软引用的区别。    </p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>参考以前的<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/">读书笔记</a></p>
</details>

<p>5、MVC 和 MVP 的区别。他们各个层次之间交互有什么区别 </p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>以前写的关于<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/23/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式的内容</a> 第1题 </p>
</details>

<p>6、SharedPreference 是线程/进程 安全的吗？apply 和 commit 有什么区别？(提交到哪？是本地的xml 还是 内存的xml？)，有什么坑？ </p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>查看<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础</a> 第20题即可     </p>
</details>

<p>7、Handler 机制说一下？ 消息延迟是怎么做到的？我有个新消息，在已有的消息队列中我想让他先执行，可以吗。</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>查看<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础</a> 第4题即可     </p>
</details>

<p>8、最有挑战的项目？你负责做了什么？给公司带来什么价值？，这个sdk给你们的产品带来什么价值？如何判断你这个sdk是否好用？你们的业务成功率是多少，有统计吗？如果要设计这个监控这个sdk？你们有相关的埋点吗？感觉面试官隐约对app的监控感兴趣。</p>
<p>9、http 和 http2 有什么区别。</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>查看<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">网络知识</a> 第15题即可     </p>
</details>

<p>10、http 和 https 有什么区别。告诉我它是怎么做到安全的呢？</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>查看<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">网络知识</a> 第9、10题即可     </p>
</details>

<p>11、kotlin 语言与java 语言相比有什么优点吗？</p>
<p>12、kotlin 的协程了解吗？它的原理？协程相比线程创建的开销小一些？主线程使用协程是不是不会阻塞？假设我在主线程里面使用协程执行非常耗时的操作，我的主线程会ANR吗？为什么在io操作比较多的时候对协程有利呢？协程有自己的栈空间吗？  </p>
<h2 id="BD"><a href="#BD" class="headerlink" title="BD"></a>BD</h2><p>线程同步方法（关键字，并发包）</p>
<p>wait/notify,notify方法和notifyAll方法区别，notifyAll方法唤醒的线程，怎么决定哪一个线程得到运行</p>
<p>HashMap(要很熟悉)，put过程，get过程</p>
<p>现在key为double类型，需要将key的整数部分当成同一个key应该怎么做（提示：重写方法）</p>
<p>内存泄露分析</p>
<p>进程间通信方式(别忘了BroadcastReceiver)</p>
<p>A跳转到B的生命周期调用，如果A的onStop方法方法发生在B的onResume方法之前会发生什么现象，如果B是singleTask又是什么情况？会调用B的哪些方法</p>
<p>service运行在什么线程</p>
<p>Handler内存泄露原理(message.target = handler，所以真正原因是由于message造成的)，解决方法，一个线程可以有多个Handler吗。</p>
<p>handler的sendMessage方法和postRunable方法区别</p>
<p>HandlerThread</p>
<p>设计一个图片加载框架，LRUCache原理</p>
<p>看过第三方库的源码吗</p>
<p>排序算法，时间复杂度，快排为什么是NlogN</p>
<p>完全二叉树高度</p>
<p>弱引用和软引用</p>
<p>今天面到的题目新的部分有几个  1include merge viewstub区别  2二叉树第n层节点个数  3touchdelegate </p>
<h2 id="BD-1"><a href="#BD-1" class="headerlink" title="BD"></a>BD</h2><p>1、http状态码</p>
<p><a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">网络知识</a>第16题</p>
<p>onTouch、onTouchEvent、onClick 执行顺序</p>
<p>onclick 不响应，如何排查    </p>
<p>设计一个下载框架(考虑多线程)。</p>
<p>单进程中，一个线程下载和用两个线程下载哪个更快？</p>
<p>在主线程要优先执行一个任务咋办？除了消息栅栏外还有其他方法吗？<br>Thread.join，还有吗？如何发送消息栅栏，这是hide方法，自己如何发送异步消息。</p>
<p>空闲的时候执行某个任务有什么方法？IdleHandler，还有其他方式吗</p>
<p>IntentService 与 Service 区别，啥时候用IntentService  </p>
<p>synchronized 锁优化策略</p>
<p>线程安全的集合有哪些？CopyOnWriteList 在什么时候使用？HashTable 与 ConcurrentHashMap 的区别？</p>
<p>线程池的拒绝策略有哪些？</p>
<p>什么情况下singleTask 在一个进程中会有两个实例？ NEW_TASK A启动B，B启动C，C启动D，现在从D启动A，并且启动完成后只保留A，如何做？</p>
<p>Okhttp 的 addInteceptor 与 addNetWorkInterceptor 的区别 </p>
<p>如何保证dns的安全？自己建立dns服务器，httpdns</p>
<p>做sdk的话，如何在接入的时候管理第三方依赖</p>
<p>设计模式，整体和部分</p>
<p>Okhttp 多个host，如何配置</p>
<h2 id="TX"><a href="#TX" class="headerlink" title="TX"></a>TX</h2><p>了解插件化吗？有哪些第三方开源的方案？Tinker的原理</p>
<p>行业内性能优化的方案有了解吗？页面如何秒开？</p>
<p>串行GC的时候，会锁住堆挂起线程，那么无论线程处于什么状态都能挂起吗？</p>
<p>多线程中的同步队列与等待队列(可能问的是 同步队列和条件队列)</p>
<p>CAS是啥？AQS是啥<a target="_blank" rel="noopener" href="https://ddnd.cn/2019/03/15/java-abstractqueuedsynchronizer/">可以参考这里</a>？RetraintLock的原理</p>
<p>锁的种类，什么是可重入锁</p>
<p>如何让多个线程同时启动</p>
<p>Java内存空间怎么划分</p>
<p>有哪些GC算法，哪些对象可以作为GC Root</p>
<p>JNI 中，Env是啥，它能干什么</p>
<p>什么情况下本地方法栈会引用Java对象</p>
<p>HashMap原理</p>
<p>Android系统的启动流程，应用为什么用zygote来fork，有什么好处</p>
<p>Apk的签名原理，v1和v2</p>
<p>https相比http的优势是什么？除了安全之外呢？证书如何校验</p>
<p>Java的堆与栈的区别，除了存储的对象不一样之外，还有其他不一样么？</p>
<p>进程间通信为什么用Binder，Binder的原理？空间大小限制（貌似是4M）?</p>
<p>可重入锁是什么？悲观锁和乐观锁的区别？</p>
<p>什么时候用到TCP，什么时候用到UDP？举例</p>
<p>https的攻击手段，https的证书是如何发送给客户端的？</p>
<p>RecyclerView和ListView的区别</p>
<h2 id="TX-1"><a href="#TX-1" class="headerlink" title="TX"></a>TX</h2><p>http状态码</p>
<p>ontouch  ontouchEvent  onClick  执行顺序</p>
<p>onClick不响应，应该怎么排查</p>
<p>设计一个下载框架（还要考虑多线程），单进程中，一个线程下载和用两个线程下载谁快？（要充分利用cpu）</p>
<p>在主线程我要优先执行一个任务咋办？消息栅栏，除了这种方法之外呢？如何发送消息栅栏？这是hide方法</p>
<p>空闲的时候执行某个任务有什么方法？IdleHandler，thread. join，还有啥方法吗</p>
<p>IntentService 与service区别？啥时候用IntentService </p>
<p>synchronize锁优化策略</p>
<p>线程安全集合有哪些？HashTable与ConcurrentHashMap 的区别？Copy onWrite List在啥时候用？</p>
<p>线程池的拒绝策略有哪些</p>
<p>什么情况下singleTask在一个进程中会有两个实例</p>
<p>a启动b，b启动c，c再启动d，这时候直接回到a页面，并且只保留a页面，有啥方法？</p>
<p>okhttp的addIntercept 与 add Network Interceptor 方法区别？</p>
<p>dns安全，httpdns 方案</p>
<p>做sdk管理第三方依赖</p>
<p>设计模式，整体和部分</p>
<p>自己发送异步消息</p>
<p>okhttp多个host，多重配置</p>
<p>异步创建view的原理</p>
<p>如何插桩</p>
<p>哪些地方匿名共享内存：堆，contentprovider，显示的时候</p>
<p>sp原理</p>
<p>事件分发</p>
<p>hashtable concurrentHashMap</p>
<h2 id="BD-2"><a href="#BD-2" class="headerlink" title="BD"></a>BD</h2><p>handler，IdleHandler原理，使用</p>
<p>组件化，插件化，热修复</p>
<p>断点续传</p>
<p>用过哪些开源库？retrofit的原理</p>
<p>反转二叉树</p>
<p>做了哪些优化？gpu优化？</p>
<p>hashmap原理，如何hash？为什么8个的时候要红黑树？</p>
<p>a启动b生命周期怎么走</p>
<p>gc算法，哪些可以作为gc root，分代算法是怎样的？</p>
<p>volatile关键字作用？能保证原子性吗？</p>
<p>webview内存泄露的原理，handler内存泄露原理</p>
<p>如何发现内存泄露？LeakCanary的原理是什么？</p>
<p>Activity的启动模式</p>
<p>taskaffinity的作用？</p>
<p>进程间通信方式有哪些？AIDL能传递的数据类型有哪些？AIDL怎么使用？AIDL的方法参数能传接口吗？都跨进程干什么</p>
<p>app崩溃率多少？怎么统计的？能捕捉所有异常吗？如何捕捉native的崩溃？</p>
<p>动态代理</p>
<h2 id="TX-2"><a href="#TX-2" class="headerlink" title="TX"></a>TX</h2><p>relativelayout与constrantlayout（可以参考链接：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/gGR2itbY7hh9fo61SxaMQQ）">https://mp.weixin.qq.com/s/gGR2itbY7hh9fo61SxaMQQ）</a></p>
<p>如何查看cursor之类的导致内存泄露问题</p>
<p>onclick，onTouch执行顺序</p>
<p>算法：链表的中间元素，判断链表是否有环，快排最好最差时间复杂度，快排是怎么操作的</p>
<h2 id="TX3-面试"><a href="#TX3-面试" class="headerlink" title="TX3 面试"></a>TX3 面试</h2><p>近期有做什么优化或者重大技术？<br>DNS污染是怎么回事<br>https的证书是怎么起作用的？<br>用什么检测内存泄漏-LeakCanary<br>扫码登录是怎么做到的<br>多线程用过吗，乐观锁与悲观锁说下    </p>
<h2 id="TX1"><a href="#TX1" class="headerlink" title="TX1"></a>TX1</h2><p>String可以继承吗？为什么？为什么设计成不可变？<br>快排原理<br>二分查找原理<br>Activity的几种启动方式，Service中怎么启动Activity（参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fang323619/article/details/74388804），从源码角度来说，ActivityManager">https://blog.csdn.net/fang323619/article/details/74388804），从源码角度来说，ActivityManager</a> 为什么会对4种tag做处理</p>
<p>事件传递的机制(触摸事件)？Activity 的顶级响应视图是啥？onTouchListener 与onClickListener 哪个先执行(onTouchListener)？onTouchListener 返回true 之后，onClickListener 还会执行吗(不会)？onTouchListener 和 onLongClick 哪个先执行？</p>
<p>View的绘制流程？从掉帧的角度来说下 View 的绘制流程？<br>ScrollView 嵌套滑动冲突怎么去解决？在父view的up里面return 了true，子view会收到down事件吗？<br>tcp与udp区别，tcp三次握手做了什么<br>单例模式怎么写，为什么<br>大图一般是怎么优化的？fresco的源码有看过吗，它有什么缺点？有没有用过其他的图片框架？<br>Activitymanagerservice 源码<br>知道哪些app性能优化</p>
<h2 id="lazada-1"><a href="#lazada-1" class="headerlink" title="lazada"></a>lazada</h2><p>自我介绍<br>性能优化做了哪些工作<br>四种引用的含义<br>mvp 与 mvc 区别<br>Handler 机制，如何实现消息延迟<br>最有挑战的项目，负责做了什么<br>业务监控怎么设计<br>http与http2的区别<br>http与https的区别<br>kotlin语言与java的区别，优点<br>kotlin的协程原理，有自己的栈空间吗，与线程区别</p>
<p>英语自我介绍下？–妥妥挂了。。</p>
<h2 id="猫总"><a href="#猫总" class="headerlink" title="猫总"></a>猫总</h2><p>为什么不用URLConnection而用OKHttp不了解</p>
<h2 id="qq的music"><a href="#qq的music" class="headerlink" title="qq的music"></a>qq的music</h2><p>自我介绍下<br>性能优化的经验<br>如何设计措施，防止以后新人在主线程添加太多的任务<br>了解过启动框架吗<br>如何分阶段启动相关任务，这些任务有相互依赖，或者有向无关图<br>能达到什么效果，量化下<br>内存优化的内容<br>webp 占用内存小一些还是尺寸小一些？<br>图片框架本来就会做这些裁剪之类的功能，这样自己做是否就重复了<br>其它内存优化的点(我觉得可以说说大图加载，只加载一部分)<br>了解ashmem 吗，除了这个作用还能有其他作用吗<br>优化app的整体内存占用<br>第一步得分析吧。profile 工具<br>第二步、分析问题在哪，native 和 Java 层 的内存占用，如果native 和 Java 中图片占用都比较大，如何分析<br>第三步、是内存泄漏导致的、还是大数组、大对象</p>
<p>用LRU 的话，一般不会引起内存很大占用，所以如果内存大，一般是内存泄漏导致的</p>
<p>Talkingdata 统计些什么     </p>
<p>监控dns的成功率，即用户使用你的ip直接请求的成功率了，以前系统直接解析，现在是用户直接打不开         </p>
<p>尝试使用https 去解决吗</p>
<p>网络成功率怎么优化      </p>
<p>dark 和 art 的 gc 过程有了解吗        </p>
<p>非并行 GC 的过程</p>
<p>分配内存，不够，然后做什么操作，最后就会分配成功。分配不够的话，系统会扩容，扩容发生在什么时机           </p>
<p>常用设计模式，单例模式怎么写      </p>
<p>volatile ：</p>
<p>性能优化了解不太多，尤其内存优化总结不多，数据量化</p>
<h2 id="BD-3"><a href="#BD-3" class="headerlink" title="BD"></a>BD</h2><p>Fresco 架构上说下，MVC模式，说说 Fresco加载gift的流程和原理<br>4. 一个大的ViewGroup，上面显示两个不一样大小的图片，内容一样，怎么做（利用Fresco的缓存）<br>5. 一个图片是50 * 50，一个图片是100 * 100，内存大小是怎样的，比如 50<em>50的内存大小是1，100</em>100的内存大小是多少？  两张图片，内存变大了还是不变，内存副本有几份？<br>6. RecyclerView 滑动的时候，缓存机制<br>7. RecyclerView 下面一个子item，我手指按在RecylerView上，然后滑动，说出滑动过程<br>8. 海量数据中找出TOP N（堆）<br>9. 自定义帧动画机制，一边解压一边加载，用完之后回收，inBitmap进行内存复用。用了哪些数据结构，如何保证按顺序执行。<br>10. bitmap drawable 区别(互相转化，drawable包含bitmap)Bitmap是Drawable . Drawable不一定是Bitmap Drawable在内存占用和绘制速度这两个非常关键的点上胜过Bitmap</p>
<p>1、   jni 方法调用是怎么实现之类的<br>2、   java  string 和 c++ string 有什么区之类的<br>3、   自己做的项目上遇到的技术难题和解决方案<br>4、   消息队列</p>
<h2 id="看点1"><a href="#看点1" class="headerlink" title="看点1"></a>看点1</h2><p>React Native了解它的实现原理吗？除了组件映射，还有更深的理解吗？<br>Android哪一块比较熟比较擅长，聊聊？<br>可以给子线程创建消息队列吗？看过消息队列的底层原理吗？对，Native层的代码<br>Android里面什么是ANR？遇到ANR怎么排查？<br>硬件加速和非硬件加速有什么区别？<br>HARDWARE_LAYER 与 SOFT_LAYER 分别代表什么意思？<br>UI性能相关性能的优化有没有做过？比如一个列表滑动很卡顿，怎么优化？如何查看占用内存和cpu？GC怎么会影响性能？有什么手段可以降低布局层级？<br>Recyclerview与Listview的缓存原理？不同类型的item他们怎样缓存？<br>Android内存怎么优化？什么是内存泄漏？什么情况会出现内存泄漏？实际中举个例子？Handler为什么会泄漏Activity？<br>图片展示比较多的App，怎么解决内存占用问题？用了什么图片框架？为什么Fresco 在5.0以下具有优势？Fresco的实现原理，大概流程是怎样的？</p>
<p>内存中未解码图片是啥样？<br>怎样为图片框架设置内存缓存策略？怎么决定淘汰哪些内存？<br>还有没有了解其他图片框架吗？<br>怎样尽量降低位图占用的空间大小？<br>图片列表，怎么优化性能？<br>视频播放相关的经验有吗？播放器用的是什么？videoView用的是哪个？TextureView 和 SurfaceView 有什么区别？哪个性能更好？为什么？这两个view和Android中普通的view有什么区别？使用方式有什么区别？</p>
<blockquote>
<h1 id="SurfaceTexture，TextureView区别"><a href="#SurfaceTexture，TextureView区别" class="headerlink" title="SurfaceTexture，TextureView区别"></a>SurfaceTexture，TextureView区别</h1><p>我们知道，一般Activity 包含多个View，他们组成树状结构，但是只有顶层的 DecorView 才是对 WMS 可见的，它在 WMS 中有一个对应的 WindowState ，相应地，在 SF中对应 Layer。</p>
<p>而SurfaceView 继承自 View，因此本质上是个View，但是它有自己的Surface，这个 Surface 在 WMS 中有对应自己的 WindowState ，在 SF 中也会有自己的 Layer。如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20150304164219975?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamluemh1b2p1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="SurfaceView示意"></p>
<p>这样，虽然SurfaceView 仍然在 View 目录树中，但是其实它与主窗口是分离的，这个的好处就是<strong>这个surface的渲染可以放到单独的线程去做，渲染时，而已有自己的GL context</strong>，这对于游戏、视频等性能相关的应用非常有益，因为<strong>它不会影响主线程的响应</strong>。但是同样也有缺点：因为它有自己的Surface ，所以它不受<strong>view的属性控制，因此不能进行平移、缩放等变换以及动画</strong>。</p>
<p>而 TextureView 在View 也继承自View，在目录树中以普通的View存在，因此支持旋转、缩放 以及动画，但是 TextureView  必须只能在<strong>支持硬件</strong>加速 的窗口中，它对draw方法进行了重载，<strong>把收到的数据作为纹理更新到对应的HardwareLayer 中</strong>。</p>
<blockquote>
<p>看不大懂，参考资料<a target="_blank" rel="noopener" href="https://blog.csdn.net/jinzhuojun/article/details/44062175">CSDN</a></p>
</blockquote>
</blockquote>
<p>你觉得视频播放怎么优化视频首帧加载速度？有看过Exoplayer的实现吗？它的解码过程和原理？<br>FFmpeg有了解过吗？<br>有做过C/C++之类的开发吗？大概是个多大的代码量？<br>有用过OpenGL吗？<br>对Android的组件化有了解多少？了解Android的热修复吗？热修复的原理是什么？<br>https怎么实现安全的？https的握手比http的握手多了几个RTT ？<br>http 1.0 、2.0、3.0 之间的区别？http3.0 最大的优势？<br>其他看过的第三方开源的框架？</p>
<h2 id="TX-MUSIC"><a href="#TX-MUSIC" class="headerlink" title="TX MUSIC"></a>TX MUSIC</h2><p>单例怎么写呢？volatile关键字在这里面的作用。如果我不需要懒加载，什么时候不需要做懒加载？</p>
<blockquote>
<p>关于单例的饿汉和懒汉加载模式，目前知道的一个答案就是：<strong>类中还有其他静态方法或变量时，饿汉模式才有优势，此时可以通过访问任一静态成员来实例化对象，这缘于首次访问静态成员会引发类的加载，而类加载时会初始化静态变量</strong>，具体可以参考<a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/394314888?list=lz">别人的提问</a></p>
</blockquote>
<p>用过反射吗？App发布的时候，需要混淆的，混淆对反射有什么影响？有没有用过Gson，有什么功能？知道它的工作原理吗？怎么知道类的成员变量的名字？我是一个泛型，我是一个List，类型是String，反射能不能拿到泛型的数据？泛型你知道有上界和下界这个东西？他们有什么用？</p>
<p>sharedpreference 的apply 和commit有什么区别？apply什么时候同步到磁盘上去(pause和广播，跟广播有啥关系？)？apply是异步的对吧？</p>
<p>有接触过插件化？插件化的原理是什么？怎么欺骗系统。</p>
<p>handler的工作原理？如何移除消息屏障？handler怎么导致的内存泄漏？</p>
<p>防止二次打包，是怎么做的？现在拿到一个包，想二次打包，而如果他做了二次打包的验证，你怎么绕过？我拿了别人的库，别人会校验签名，如果我想用这个库，怎么弄？你们的签名验证怎么做的？</p>
<p>kotlin印象深刻的特性，举例一下？异步的代码写成同步，怎么写？怎么做到异步能写成同步的？正常来讲，我们是从上往下执行的，为毛它可以在中途切线程？怎么做到让出线程使用权限呢？但是如果是使用Java的wait、notify会阻塞，但是kotlin不会啊，咋做的？用kotlin从子线程切换到主线程，怎么做？GlobalScop 有什么不好的点吗？kotlin的空安全了解么？在定义变量的时候，就指定是否可以为空，你觉得这样好不好？lateinit的作用是啥？什么情况比较适合使用 lateinit？</p>
<blockquote>
<p>如果 lateinit 和 lazy 对比，lateinit <strong>只用于变量var</strong>，而 layzy <strong>只用于常量val</strong>，一般用于单例在变量第一次调用时才执行。其次，基于我个人的理解，lateinit 适用的场景是<strong>你不想指定一个变量为可空类型，但是又得在稍后(或者得等到满足某个参数时，假如RecyclerView的Adapter对象，可能得等到某个callback 初始化之后，才能作为参数来new 这个Adapter)才能初始化的那种变量</strong>。以上参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5fe384a2575b">简书的博客</a></p>
</blockquote>
<p>https怎么做到安全？https的流程？怎么校验证书？你是说自己也计算一遍对吧？服务端发证书给你，中途被我换了，客户端能不能发现被换了？用我自己的私钥签名了，客户端如何发现的？证书链怎么验证？我做了个代理，做了个中间人攻击，一般我能听别人https的内容，为什么我能做到呢？你们本地https的证书校验的证书从哪里来？那你获取证书这部分我是不是可以中间人攻击，你们发的是tcp包还是http包？http包那你们也还是会有明文，就会有漏洞。对称加密的密钥是怎么生成的？为什么需要客户端和服务端一起作用来生成？为什么后面需要使用对称加密来做？</p>
<p>知道DNS会有劫持吗？你们的情况不一定是dns劫持，可能是别人直接把你们的Http包给替换了？httpDNS 有什么好处？-更科学地翻译成ip，深圳访问不会被分配到北京。</p>
<p>数组，找到数组里面第一个重复的数字，怎么做？HashSet去做时间复杂度多少？意思是遍历一次就行了是吧？</p>
<p>如果App出现了频繁的GC，怎么排查？怎么排查有没有内存泄漏的？-leakcanary ，如果在IDE里面使用工具呢？如果我想看哪些对象被频繁申请，怎么搞？</p>
<blockquote>
<p>看起来面试官想要说出MAT，可以参考下<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1596318542314042563&amp;wfr=spider&amp;for=pc">别人的博客</a>。但是其实目前已经无需MAT就能直接在AS里面操作了</p>
</blockquote>
<h2 id="BD-4"><a href="#BD-4" class="headerlink" title="BD"></a>BD</h2><p>挑一个比较有价值的项目聊聊？500彩票，那聊一聊做了哪些事情？模块化和mvp讲讲，mvp有什么优缺点？-MVP类增加了，寻找逻辑没那么直接。有没有做成组件化的形式吗，打包成aar之类的发布？</p>
<p>插件化讲一讲？打包怎么办？插件用到宿主的资源咋办？怎么识别类，是将dex添加到dexlist中还是自定义 ClassLoader ？启动service、广播、ContentProvider？Activity去hook它的mCallback，但是假如高版本的时候不让你去反射咋办？宿主里面的类更新了，插件版本没有更新，这情况咋办？</p>
<p>讲一下handler吧？</p>
<p>用过哪些第三方组件，开源库？网络库用的啥？用过github上哪些轮子啊？okhttp源码有看过吗？他有很多拦截器，他是怎么弄的输入输出？</p>
<p>注解有用过吗？除了用来替代枚举外还在哪里用过吗？</p>
<p>写个算法题：单向链表，自己去定义结点，他有个值，还有个next指向下一个。我们输入两个这种链表，找到他们第一个公共节点返回，没有的话，返回null  。</p>
<h2 id="BD二"><a href="#BD二" class="headerlink" title="BD二"></a>BD二</h2><p>做了哪些非业务的工作？所理解的网络劫持是什么样的？怎么发现网络劫持和预防？https可以解决DNS劫持问题吗？如果要篡改http可以在哪些环节篡改？你觉得谁会来篡改你们的App网络报文？https为什么可以保证不被篡改？介绍下Https的流程？我们要分析https的请求的话，可以怎么做吗？App又怎么去防这种事情呢？服务端拉取证书怎么保证安全呢？-ip直连去拉取证书。量很大的情况下，都通过ip去获取证书的话，服务端会不会扛不住？如果ip挂了，或者运营商给你封了，那你怎么办？-内置证书，防止重打包 。做了一些安全方面的事情，是哪些？为什么App签名本地校验是防君子不能防小人？</p>
<p>sp做加密，出于什么目的？别人怎么读到你的sp存储的内容？哪些存储的内容需要加密？sp写的时候加密以及读的时候需要解密，这个性能会有影响吗？业界有没有好的方案来解决Sp吗？-替代方案是MMKV  。MMKV 是如何解决跨进程问题？为什么SP跨进程是不好的？</p>
<p>性能上做了一些优化，做了哪些事情？App启动优化做了哪些事情？内存优化主要做了什么？hashmap 换成arrayMap 等会有多大的收益？这个内存收益怎么衡量？-启动App进入到彩票购彩页面。防止内存泄漏怎么去做的？线上如果要做一些这样的监控怎么做？-talkingdata 。 它的原理有去了解吗？内存泄漏经常会OOM，这种OOM怎么在线上怎么监控？-发生的时候，dump内存信息上传分析。更详细的没有去了解是吧？</p>
<p>算法题目：给定一个字符串S，返回 反转后的 字符串。反转的规则：其中不是字母的字符都保留在原地，而所有字母的位置发生反转。</p>
<p>例如：        输入：”ab-cd”        输出：”dc-ba”<br>输入：”a-bC-dEf-ghIj”        输出：”j-Ih-gfE-dCba”</p>
<h2 id="BD-5"><a href="#BD-5" class="headerlink" title="BD"></a>BD</h2><p>视频播放采用什么播放器？视频播放首帧优化？有其他方式来优化视频播放，比如卡顿等体验？视频播放碰到过什么问题？</p>
<p>选择SurfaceView还是TextureView ？视频有做过加密吗？视频地址是固定的吗？</p>
<p>视频格式了解吗？分辨率、帧率、码率 都是什么含义？</p>
<p>git 的merge  和 rebase 有什么区别？代码从本地到远端是怎么流转的，比如我新建一个文件，怎么到远端的？</p>
<p>性能优化做了哪些内容？</p>
<p>json解析耗时几百毫秒，是怎么统计到的？systrace 用过吗？</p>
<p>不重要的任务是怎么去初始化的？</p>
<p>用过线程池吗？对线程的管控怎么搞？如果有人在代码中直接去new  Thread，这个怎么管控？</p>
<p>RxJava里面线程池的线程有限制吗？RxJava的原理有多少？RxJava的线程切换怎么实现的？RxJava是怎么切换的线程，比如他observeOn 和 subScribeOn 这两个操作符？这两个操作符有什么区别？多次调用他们会多次生效吗？为什么不能多次生效？</p>
<p>协程的原理？同样作为操作线程的工具，它和RxJava的本质区别是什么？与RxJava比较还有没有别的优势？kotlin的作用域函数apply、also等，怎么确定什么时候用什么？</p>
<p>图片规范的方式去使用，怎么规范？</p>
<p>fresco 有几级缓存？</p>
<p>组件化怎么弄的？组件化做到什么程度？</p>
<p>module之间怎么通信？除了基础module，其他的module  A 想要和 module B 通信，A启动B里面的一个页面？</p>
<p>为什么选择MVP？P层可能会无线膨胀，有没有什么解决办法</p>
<p>最近jetpack的组件有没有了解？</p>
<p>如何设计一个组件化的app<br>View的绘制流程<br>activity的启动模式<br>如何监控启动就crash的问题<br>如何独立编译单独的组件<br>对比一下图片加载模块，Glide 和Fresco , AsyncImageView</p>
<p>主要还是通过项目发散开的问题：<br>1，android开发中常见的两种序列化，serializeble 和 parcelable 的区别<br>2，recyleview中的常见卡顿问题是如何解决的，如何监控到用户的卡顿（监控UI线程的message 处理逻辑，超过60ms）<br>3，项目比较大，编译比较慢的解决办法（插件化，组件化）<br>4，项目中遇到的一个小问题，是如何解决的<br>5，OOM类型的问题如何解决<br>6，内存泄漏如何监</p>
<p>Android so如何减包<br>Android Camera采集渲染流程<br>如何排序一个比内存大的文件</p>
<p>C++ 父类析构函数的virtual作用，怎么实现防止内存泄漏的<br>C++ 虚函数表是什么<br>JNI的attachCurrentThread作用是什么<br>JNI的LocalRef和GlobalRef new了是否要delete，可以不delete么？<br>简单介绍下libuv</p>
<h2 id="BD3"><a href="#BD3" class="headerlink" title="BD3"></a>BD3</h2><p>http与https的差异有多少？https这个安全层是怎么做的，怎么保证安全的？非对称加密是在哪里使用？数字证书除了公钥之外还有其他的吗？数字证书和数字签名有什么关系？验证双方身份的时候，用了个什么结构，比如说，我发了个信息给你，怎么验证是我发给你的？是在https建立后，使用对称加密之后，如何验证双方的身份？</p>
<blockquote>
<p>http与https的区别，参考自己<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">以前写的博客</a>-<font color="#ff0000">（要记得同步回博客中）</font>：</p>
<ul>
<li>scheme不一样，一个是http，一个是https</li>
<li>Https是ssl加密传输，Http是明文传输     </li>
<li>Https是使用端口443，而Http使用80     </li>
<li>HttpsSSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比Http协议安全      </li>
<li>Https协议需要到CA申请证书</li>
</ul>
</blockquote>
<p>列举下自己所知道的http的状态码？</p>
<blockquote>
<p>1开头表示临时响应，还需要继续操作    </p>
<p>2开头表示成功    </p>
<p>3开头表示重定向，301表示永久移动，302表示临时移动</p>
<p>4开头表示请求错误，比如：400表示服务器不理解请求语法，403表示禁止访问，404未找到  </p>
<p>5表示服务端错误，比如：500服务器内部错误、502错误网关、503表示 服务不可用，维护或者超载了  </p>
</blockquote>
<p>get和post方法之间有多少差异？get不会对后台数据进行修改，post会修改？</p>
<blockquote>
<p>按照REST规范来说的话，get就是获取资源，不会有副作用，也就是这个操作是幂等的；post就是创建资源的意思，这个就不是幂等的。此外，put的含义就是replace，就是用来修改元素；delete就是用来删除。</p>
<p>但是如果，纯粹说http的话，这个就很宽泛了，我们说get不能有body、get是幂等、post有body、post不是幂等，这些规则都是可以被打破的，比如，post的参数可以放在queryString里、header里，当然也能放在body里，当然也可以每个部分放一点；get也能做成等非幂等的，甚至于，我们在日常使用的时候，post都能做成幂等，这就要求后台判断重复订单了。</p>
<p>以上文章参考自<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28586791">知乎上的文章</a>，<font color="#ff0000">（要记得同步回博客中）</font></p>
</blockquote>
<p>TCP 下的流量控制的核心内容？-本质是不要把对方buffer打爆  。 对方已经很拥堵了，怎么控制呢？</p>
<p>java中静态方法能调用非静态方法吗？我从类对象角度讲的，但面试官感觉是要求从类加载的角度讲。</p>
<blockquote>
<p>因为静态方法属于类，在类加载的时候，就被加载到方法区了，因此在类没有创建对象的时候后也是可以调用的。而非静态方法则得在类创建对象之后才存在。因此并不能这样调用。内容可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44325444/article/details/109273226">csdn的博客</a></p>
</blockquote>
<p>Java中，有多层for循环，有个场景需要在最里面的for循环中跳出多个for循环继续执行下面的代码，怎么搞？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较简单的解决方案是：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    loop: <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt; <span class="number">5</span>;i++) {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++) {</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">break</span> loop;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以参考[博客园](https://www.cnblogs.com/fastfn/p/9777067.html)</span></span><br></pre></td></tr></tbody></table></figure>

<p>创建fragment的时候，为什么官方不推荐构造方法，而要通过setArguments的方式？-为了考虑恢复。  了解到什么时候会有这种恢复的场景？-从前一个Activity返回到当前Activity。  Fragment 的两个adapter， 一个是 fragmentpageAdapter ，一个是 fragmentpageStateAdapter，他俩有什么区别？</p>
<blockquote>
<p>FragmentPagerAdapter与FragmentStatePagerAdapter的区别：<br>FragmentPagerAdapter拥有自己的缓存策略，当和ViewPager配合使用的时候，会缓存当前Fragment以及左边一个、右边一个，一共三个Fragment对象；<strong>在每次切换页面的时候，是将fragment进行分离(transaction.detach)，适合页面较少的fragment使用以保存一些内存，对系统内存不会有多大影响</strong>。</p>
<p>FragmentStatePagerAdapter是PagerAdapter的子类，这个适配器对实现多个Fragment界面的滑动是非常有用的。<strong>当Fragment对用户不可见的时候，整个Fragment会被销毁(transaction.remove)，只会保存Fragment的保存状态</strong>。</p>
<p>参考<a target="_blank" rel="noopener" href="https://liuqiang.blog.csdn.net/article/details/79793168">刘强的博客</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaokaiqiang1992/article/details/40342411">赵凯强的博客</a></p>
</blockquote>
<p>MeasureSpac 里面有三种模式，解释下？</p>
<blockquote>
<p>参考以前写的<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/03/08/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%92%88%E5%AF%B9%E7%AE%80%E5%8E%86%E7%9A%84%E9%97%AE%E9%A2%98/">面试题目第3题</a></p>
</blockquote>
<p>handler的post和sendMessage有什么区别？-post是runnable，send是message，post的runnable最终会封装成 message，并且what默认为1,——面试官看起来不满足这个解释。</p>
<blockquote>
<p>使用send时，由于是我们自己创建的Message，所以我们最终在handleMessage 方法中switch-case来处理Message。</p>
<p>使用post的方式时，我们post过去的是一个runnable，在post方法中，会创建一个 Message，并且将这个runnable赋值给Message的callback字段。之后通过 sendMessageDelay(msg,0) 来实现。</p>
<p>而我们知道，在Handler的dispatchMessage方法中，会首先判断msg.callback == null，如果不为null的话，就直接执行 msg.callback.run() 了；如果为null，则会判断 handler的mCallback字段是否为null，不null的话，直接调用 mCallback.handleMessage(msg) 将当前msg给处理了，并且直接return回去了；如果以上条件都不满足，则会调用我们通常覆写的  handleMessage() 方法，交由我们自己处理。</p>
</blockquote>
<p>上面内容主要是看系统源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(<span class="meta">@NonNull</span> Runnable r)</span> </span>{</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>{</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) {</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>算法：</p>
<p>给出两个有序的整数数组 <img src="https://www.nowcoder.com/equation?tex=A%20%5C" alt="img">和 <img src="https://www.nowcoder.com/equation?tex=B%5C" alt="img">，请将数组 <img src="https://www.nowcoder.com/equation?tex=B%5C" alt="img">合并到数组 <img src="https://www.nowcoder.com/equation?tex=A%5C" alt="img">中，变成一个有序的数组<br>注意：<br>可以假设 <img src="https://www.nowcoder.com/equation?tex=A%5C" alt="img">数组有足够的空间存放 <img src="https://www.nowcoder.com/equation?tex=B%5C" alt="img">数组的元素， <img src="https://www.nowcoder.com/equation?tex=A%5C" alt="img">和 <img src="https://www.nowcoder.com/equation?tex=B%5C" alt="img">中初始的元素数目分别为 <img src="https://www.nowcoder.com/equation?tex=m%5C" alt="img">和 <img src="https://www.nowcoder.com/equation?tex=n%5C" alt="img"></p>
<h3 id="TX1-1"><a href="#TX1-1" class="headerlink" title="TX1"></a>TX1</h3><p>全程参与的项目有哪几个？</p>
<p>项目里面哪个对你成长帮助比较大，收获比较大？</p>
<p>遇到什么问题？为什么想着优化H5？如何优化H5页面的打开速度？是预创建 WebView 是吧？</p>
<p>项目中碰到什么难点，以及是怎么去攻克它的？</p>
<p>如果插件化要做好兼容性，应该怎么做？</p>
<p>如何保证App的安全？</p>
<p>有用 Service 开发吗？</p>
<p>你们的跨进程通信用的什么方式？你知道有哪些跨进程通信方式？这些跨进程通信方式各有什么优势或者特点，他们之间的差异是什么？</p>
<p>介绍下APK的启动过程——描述下进程启动、应用启动？启动过程哪些过程可能产生ANR ？</p>
<p>Apk 中有一些第三方的包 Jar，在应用启动过程中，这些 Jar 是怎么链接起来的 ？——Android会把这些 jar 打包成 dex ， 那么这些 dex 是什么时候加载呢？</p>
<p>类似抖音功能遇到了什么难点？怎么解决的？——播放错乱，咋解决？</p>
<p>Android的源码看过多少？有编译过Android的源码吗？</p>
<p>adb命令会吗？我想查看手机的剩余电量，怎么拿？ Linux的一些命令呢？root 和 Hook 了解多少？</p>
<p>NDK 开发有吗？</p>
<p>主要开发语言，Java 、Kotlin ？</p>
<p>ART 知道吗？与 Dalvik 的区别？GC有什么不同？</p>
<p>如果让你一个人开发App，能 Cover 住吗？</p>
<p>有做单元测试吗？</p>
<h3 id="ALi"><a href="#ALi" class="headerlink" title="ALi"></a>ALi</h3><p>Java集合类有哪些？有什么特点？ ArrayList、LinkedList、HashMap？</p>
<p>ConcurrentHashMap是线程安全？它是怎么实现线程安全的？</p>
<p>Java的线程有哪些状态？创建线程，调用它的start() 方法，这时候它处于什么状态？</p>
<p>Java 中处理多线程并发的方法有哪些？Synchronize 在底层是怎么保证加锁成功？Volatile 主要用在什么场景？</p>
<p>是否有用过 ThreadLocal ？看 Handler 源码时看过</p>
<p>线程的集中管理会用到线程池，有哪些比较关键的参数？</p>
<p>Activity声明周期？Activity A 到 Activity B ，二者经历的生命周期是怎样的？启动模式介绍下？日常开发时，有没有碰到要用某种启动模式的？</p>
<p>是否有多进程的场景？——做小程序的时候</p>
<p>Handler 的机制简单说一下？子线程发送消息，如何流转到主线程的？</p>
<p>讲下 View 的主要绘制流程？多层 View 和 Layout，怎么把这些操作传递下去吗？ViewRootImpl 有了解吗？</p>
<p>涉及到多进程的话，如何进行多进程间的通信？Messager 主要用在什么场景？ AIDL 主要用在什么场景？Binder 的基本原理？为什么要引入Binder ，不用 Linux 的？</p>
<p>性能优化，页面秒开是从哪些方面做的？发现性能会有问题才做性能优化吧？是怎么分析性能？怎么检测内存泄漏？LeakCanary的原理？后来有没有思考有没有哪些内容可以做得更好？最耗时的点是啥，怎么去优化的？</p>
<p>做过小程序的开发，你们的小程序是自研的吗？有哪些权限限制？</p>
<p>RN的了解？</p>
<h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><p>其实证书的本地校验还有一个步骤就是，将获取的新证书与老证书对比下，对比新旧证书</p>
<p>在kotlin中各个部分的执行顺序：</p>
<p>companion &gt; init &gt; constructor</p>
<p>自己写代码如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinTest</span> </span>{</span><br><span class="line">    <span class="keyword">init</span> {</span><br><span class="line">        println(<span class="string">"init"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(){</span><br><span class="line">        println(<span class="string">"constructor init"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> {</span><br><span class="line">        <span class="keyword">init</span>{</span><br><span class="line">            println(<span class="string">"companion init"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>会输出：</p>
<blockquote>
<p>companion init    </p>
<p>init    </p>
<p>constructor init</p>
</blockquote>
<p>对称加密哪些</p>
<p>三次、四次握手</p>
<p>注意postInvalidate的使用</p>
<h2 id="关于如何排查ANR"><a href="#关于如何排查ANR" class="headerlink" title="关于如何排查ANR"></a>关于如何排查ANR</h2><h3 id="获取日志文件"><a href="#获取日志文件" class="headerlink" title="获取日志文件"></a>获取日志文件</h3><p>首先，获取日志文件：</p>
<blockquote>
<p>adb bugreport buglog</p>
</blockquote>
<p>之后，就会显示进度生成，有个时候会生成不成功，没关系，再来一次</p>
<p>生成之后，这个文件被导入到当前项目的路径下，解压这个 buglog.zip 文件即可，打开 [机型]xxx.txt 查看里面的日志。</p>
<h3 id="ANR类型和日志关键字"><a href="#ANR类型和日志关键字" class="headerlink" title="ANR类型和日志关键字"></a>ANR类型和日志关键字</h3><p>KeyDispatchTimeout-主要类型按键或触摸事件,input事件在5S内没有处理完成发生ANR</p>
<p>日志关键字：Reason: Input dispatching timed out xxxx</p>
<p>ServiceTimeout-bind，create，start，unbind等在主线程处理耗时，前台Service在20s内，后台Service在200s内没有处理完成发生ANR</p>
<p>日志关键字：Timeout executing <a href="https://links.jianshu.com/go?to=http%3A%2F%2Fservice%2Fexecuting%2520service" target="_blank">service:/executing service</a> XXX</p>
<p>3）BroadcastTimeout- BroadcastReceiver onReceiver处理事务时前台广播在10S内，后台广播在60s内没有处理完成发生ANR</p>
<p>日志关键字：Timeout of broadcast XXX/Receiver during timeout:XXX/Broadcast of XXX</p>
<p>4）ProcessContentProviderPublishTimedOutLocked-ContentProvider publish在10s内没有处理完成发生ANR<br>日志关键字：timeout publishing content providers</p>
<h3 id="造成ANR的常见原因"><a href="#造成ANR的常见原因" class="headerlink" title="造成ANR的常见原因"></a>造成ANR的常见原因</h3><ul>
<li>主线程耗时操作，如复杂的layout，庞大的for循环，IO等。    </li>
<li>主线程被子线程同步锁block    </li>
<li>主线程被Binder 对端block    </li>
<li>Binder被占满导致主线程无法和SystemServer通信    </li>
<li>得不到系统资源（CPU/Memory/IO）</li>
</ul>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/33d5e48e4a13">简书上的博客</a>、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/082045769443">简书博客二</a></p>
</blockquote>
<h3 id="dayuwuxian"><a href="#dayuwuxian" class="headerlink" title="dayuwuxian"></a>dayuwuxian</h3><p>在目前所在公司主要负责什么？</p>
<p>为什么要重构网络框架？重构后有什么亮点？</p>
<blockquote>
<p>网关不让用。并发token设计、数据解析 adapter 设计、日志系统设计。</p>
</blockquote>
<p>OkHttp 里面有哪些比较关键的设计让你觉得挺好的？线程池为什么要这样设计？它有哪些 intercetor ，分别是什么含义 ？这些 interceptor 执行的顺序是什么？</p>
<p>网络防劫持是怎么做的？</p>
<p>设计一个类，有add、remove、dispatch 这 3 个方法，其中add 表示将 listener 添加进来， remove 表示将 listener 移除，dispatch 方法表示遍历目前的listener ，然后调用每个 listener 的 invoke 方法，请问这个类怎么设计？</p>
<p>设计的APM上线了吗，完成度怎么样？为什么要设计这么个APM ？怎么收集卡顿、ANR 呢？</p>
<p>有用kotlin吗？kotlin的 lazy 是怎么实现的？-有很多中模式。这些模式的原理是什么，比如Synchronize 模式的原理是什么？用过协程吗？</p>
<p>有用过 JetPack 吗？用过哪些？</p>
<p>https证书防抓包的原理是什么？证书是双向验证还是单向验证？破解包了替换掉证书还能不能行？怎么更新从后台下载来的证书？怎么做的？</p>
<p>https的请求过程是什么样的，与http有什么区别？</p>
<p>一大堆无序的数字，取出前k个最小的数字</p>
<h2 id="频繁GC、OOM-的排查"><a href="#频繁GC、OOM-的排查" class="headerlink" title="频繁GC、OOM 的排查"></a>频繁GC、OOM 的排查</h2><p>Android 的profile 功能-&gt;memory -&gt; dump ，得到 hprof 文件</p>
<p>AS 现在直接能看到各个对象了，或者按照以前的，将 hprof 文件转一道，使用 MAT 打开</p>
<h2 id="两个人轮流抛硬币，正面朝上的赢，正反面概率一样，你应该先抛还是后抛"><a href="#两个人轮流抛硬币，正面朝上的赢，正反面概率一样，你应该先抛还是后抛" class="headerlink" title="两个人轮流抛硬币，正面朝上的赢，正反面概率一样，你应该先抛还是后抛"></a>两个人轮流抛硬币，正面朝上的赢，正反面概率一样，你应该先抛还是后抛</h2><p>设先抛先吃的概率为p1， 后抛先吃的概率为p2</p>
<p>那么有：</p>
<p>p1 = 1/2 + 1/2 * p2</p>
<p>p1 + p2 = 1</p>
<p>解方程可得，</p>
<p>p1 = 2/3</p>
<blockquote>
<p>参考自<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/6f11c63cb97a4e0884bb40985cf95393?toCommentId=474963">牛客网</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">218</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共437.3k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/9/',]
      });
      });
  </script>


</body>
</html>
