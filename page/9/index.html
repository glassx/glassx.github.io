<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.gitee.io/page/9/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.gitee.io/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">111</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/03/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">面试题-算法-基本查找</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-22 17:49:00" itemprop="dateCreated datePublished" datetime="2019-03-22T17:49:00+08:00">2019-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-11 21:06:49" itemprop="dateModified" datetime="2020-04-11T21:06:49+08:00">2020-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="704、二分查找，给定一个-n-个元素有序的（升序）整型数组-nums-和一个目标值-target-，写一个函数搜索-nums-中的-target，如果目标值存在返回下标，否则返回-1"><a href="#704、二分查找，给定一个-n-个元素有序的（升序）整型数组-nums-和一个目标值-target-，写一个函数搜索-nums-中的-target，如果目标值存在返回下标，否则返回-1" class="headerlink" title="704、二分查找，给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1"></a>704、二分查找，给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>还没写。。。。。</p>
<p>自己写的时候的问题：<strong>这题目自己写得还不错</strong></p>
</details>

<blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search/">LeetCode</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/03/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC4%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC4%E7%AB%A0/" class="post-title-link" itemprop="url">第4章：操作系统基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-09 21:10:00" itemprop="dateCreated datePublished" datetime="2019-03-09T21:10:00+08:00">2019-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:48:37" itemprop="dateModified" datetime="2019-11-17T21:48:37+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="进程间通信的经典实现"><a href="#进程间通信的经典实现" class="headerlink" title="进程间通信的经典实现"></a>进程间通信的经典实现</h2><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存的工作流程：</p>
<ol>
<li>创建共享区。进程1从内存中申请一块内存作为共享区域，并且将该区域与某个Key绑定  </li>
<li>映射共享区。创建共享区之后，需要将其映射到进程1的空间中才能操作。  </li>
<li>访问共享区。进程2利用第一步得到的Key，访问到共享区，之后将这块内存映射到进程2的空间中。  </li>
<li>进程间通信。各进程实现了对共享内存的映射后，便可以利用该区域进行信息交换。（注意：整个内存过程都没有实现同步机制，需要进程间自己实现）  </li>
</ol>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li>进程A和B分立管道两端，进行数据传输通信</li>
<li>管道是单向的，如果进程既要“读”也要“写”，就需要两根管道这点很像水管的特性  </li>
<li>管道同时具有“读取”(read end)端和“写入”(write end)端，比如进程A从 write end 写入，进程 B 就可以从 read end 端读取到数据  </li>
<li>管道容量有限制，当pipe满了后，写操作将阻塞；反之，pipe空了之后，读操作将会阻塞  </li>
<li>普通的管道是<strong>匿名的</strong>，这种匿名的管道只适合有斧子关系的进程通信，如果要实现没有任何关系的管道间的通信，就需要<strong>命名管道(Named pipe)</strong></li>
</ul>
<h3 id="UNIX-DOMAIN-SOCKET"><a href="#UNIX-DOMAIN-SOCKET" class="headerlink" title="UNIX DOMAIN SOCKET"></a>UNIX DOMAIN SOCKET</h3><ul>
<li>简称UDS,也可以说是IPC Socket，与普通的Socket不一样，专门针对单机进程间通信提出来的。  </li>
<li>大家熟知的 Network Socket 是以 TCP/IP 协议栈作为基础的，需要分包、重组 等一系列操作，而 UDS 因为是本机内的“安全可靠操作”，实现机制上并不依赖于这些协议。  </li>
<li>Android 中使用最多的一种IPC就是Binder，其次就是 UDS 。  </li>
</ul>
<h3 id="RPC（REMOTE-PROCEDURE-CALLS）"><a href="#RPC（REMOTE-PROCEDURE-CALLS）" class="headerlink" title="RPC（REMOTE PROCEDURE CALLS）"></a>RPC（REMOTE PROCEDURE CALLS）</h3><p>RPC 涉及通信双方通常运行于两台不同的机器中。</p>
<h2 id="同步机制的经典实现"><a href="#同步机制的经典实现" class="headerlink" title="同步机制的经典实现"></a>同步机制的经典实现</h2><p>###信号量（SEMAPHORE）</p>
<p>信号量与PV原语是分不开的，也是最为广泛的互斥方法之一，主要包括以下几个元素：</p>
<ul>
<li>Semaphore S（信号量，用于指示共享资源的可用数量）  </li>
<li>Operation P （可以减小S计数）  </li>
<li>Operation V （可以增加S计数）  </li>
</ul>
<blockquote>
<p>P执行：S = S -1，此时判断若 S&gt;=0 ，说明资源此时允许访问，开始操作共享资源；否则，加入等待队列，待别人释放资源后唤醒。<br>V执行：S=S+1，如果此时S&gt;0，说明当前没有希望访问资源的等待者；否则，唤醒等待队列中的相关对象。<br><strong>其中，PV源于都属于原子操作，意味着他们执行过程是不允许被中断的。</strong></p>
</blockquote>
<h3 id="互斥体（MUTEX）"><a href="#互斥体（MUTEX）" class="headerlink" title="互斥体（MUTEX）"></a>互斥体（MUTEX）</h3><p>Mutex 是 Mutual Exclusion 的缩写，释义为 互斥体。如果资源允许多个对象同时访问，成为 Counting Semaphores；而如果只允许取值0或1（lock/unlocked）的Semaphore，则叫做 Binary Semaphore。Binary Semaphore 与Mutex有相同性质，Mutex通常是对某一排他资源的共享控制——要么这个资源被占用（locked），要么是可以访问的（unlocked）。</p>
<h3 id="管程（MONITOR）"><a href="#管程（MONITOR）" class="headerlink" title="管程（MONITOR）"></a>管程（MONITOR）</h3><p>针对信号量机制的程序易读性较差，并且信号量管理分散在各个参与对象中，很难维护等缺点，管程被提出来了。管程是可以被多个进程/线程安全访问的对象或者模块，管程中的方法在同一时刻只允许一个范文这使用它们（方法受 mutual exclusion 保护的）。</p>
<h2 id="操作系统内存基础"><a href="#操作系统内存基础" class="headerlink" title="操作系统内存基础"></a>操作系统内存基础</h2><p>操作系统中任何操作都与内存息息相关，内存管理的底层原理主要注意几个核心：</p>
<ul>
<li>虚拟内存</li>
</ul>
<blockquote>
<p>内存总是“不够大”的，随着应用的增加，总会填满，虚拟内存为运行更多的程序提供了可能，其基本思想是：1.将硬盘上一部分空间作为内存的扩展；2.出现资源不足时，按照一定算法挑出优先级较低的数据块移动到第1步划出的空间；3.需要用到硬盘中的数据块时，系统将产生“缺页”，之后把硬盘中的数据交换回内存中。</p>
</blockquote>
<ul>
<li>内存分配与回收</li>
</ul>
<blockquote>
<p>分配、native层回收，java层回收</p>
</blockquote>
<ul>
<li>内存保护</li>
</ul>
<blockquote>
<p>内存分页或者分段式管理。进程的逻辑地址不是直接对应物理地址的，因此没办法访问它范围外的内存空间。</p>
</blockquote>
<p><strong>顺带一提，mmap函数（Memory Map）正如其名，可以将某个设备或者文件映射到应用进程的内存空间中，这样访问这块内存就相当于对设备/文件进行读写；可见，理论上mmap可以用于进程间通信，即通过映射同一块物理内存来共享内存，这种方式因为减少了复制次数，在一定程度上提高了进程间通信效率。</strong></p>
<h2 id="Android-匿名共享内存（Ashmem）"><a href="#Android-匿名共享内存（Ashmem）" class="headerlink" title="Android 匿名共享内存（Ashmem）"></a>Android 匿名共享内存（Ashmem）</h2><p>Ashmem 全称 Anony Shared Memory，是Android 特有的内存共享机制，它可以将指定的物理内存分别映射到各个进程的地址空间，从而便捷地实现进程间的内存共享。Ashmem 是一个 misc 设备，其实现依托于 /dev/ashmem 。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/03/08/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%92%88%E5%AF%B9%E7%AE%80%E5%8E%86%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/08/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%92%88%E5%AF%B9%E7%AE%80%E5%8E%86%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">针对简历的问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-08 21:10:00" itemprop="dateCreated datePublished" datetime="2019-03-08T21:10:00+08:00">2019-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 17:12:10" itemprop="dateModified" datetime="2021-05-02T17:12:10+08:00">2021-05-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p><font color="ff0000">根据技术栈可能的提问</font></p>
<h2 id="1、聊聊-java-中-static-关键字"><a href="#1、聊聊-java-中-static-关键字" class="headerlink" title="1、聊聊 java 中 static 关键字"></a>1、聊聊 java 中 static 关键字</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>一旦什么东西设置为 static ，数据或者方法就不会同那个类的任何对象实例有联系。例如以下类：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>尽管我们可以给StaticTest 类new 出 2个对象来，但是 StaticTest.i 仍然只有一个存储空间，即两个对象共享同样的i，此时，其中一个对象执行 ++i 后，另一个对象的 i值 也会变为 48。</p>
<p>静态的变量或者方法，可以通过对象引用，也可以直接通过类引用，如以上的i，可以使用如下两种方式引用：</p>
<blockquote>
<p>假设st 是 StaticTest 类的对象： st.i = 4   或者  StaticTest.i = 4</p>
</blockquote>
</details>

<h2 id="2、Kotlin-相关"><a href="#2、Kotlin-相关" class="headerlink" title="2、Kotlin 相关"></a>2、Kotlin 相关</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="Kotlin-中的协程用过吗？聊聊？"><a href="#Kotlin-中的协程用过吗？聊聊？" class="headerlink" title="Kotlin 中的协程用过吗？聊聊？"></a>Kotlin 中的协程用过吗？聊聊？</h3><p>简单使用过，但是仅仅用于线程切换，对协程有一些简单的了解：</p>
<ul>
<li>协程是编译器级别的，进程和线程是操作系统级的</li>
<li>线程根据os的调度算法，当分配的时间片用完后，保存当前上下文，之后被强制挂起，开发者无法精确控制它们</li>
<li>协程可以看做是轻量级的用户态线程</li>
<li>协程实现的是<strong>非抢占式</strong>的调度，由当前协程控制什么时候切换到其他协程</li>
<li>每个协程池里都有一个调度器，这个<strong>调度器是被动调度的</strong>，即当前协程主动让出cpu时调度</li>
<li>目前的协程框架一般设计成 1:N 的模式，即一个线程作为容器，里面包含多个协程</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>协程轻量，创建成本小，内存消耗小    </p>
</li>
<li><p>协作式的用户态调度器，cpu上下文切换开销少    </p>
<blockquote>
<p>进程/线程 切换需要在内核完成，而协程通过用户态栈实现，速度更快，但协程也放弃了线程中优先级的概念</p>
</blockquote>
</li>
<li><p>减少同步加锁，整体性能提高    </p>
<blockquote>
<p>协程基于事件循环，减少同步加锁的频率。但若存在竞争，该上锁的地方仍需要加上协程锁    </p>
</blockquote>
</li>
<li><p>可以按照同步思维写异步代码，即用同步的逻辑，写由协程调度的回调</p>
<blockquote>
<p>协程可以减少callback 的使用，但是不能完全替代callback，基于事件驱动的变成用callback更合适</p>
</blockquote>
</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>协程中不能有阻塞操作，否则整个线程被阻塞(协程是语言级别，线程是操作系统级别)      </li>
<li>需要特别关注全部变量、对象引用的使用    </li>
<li>协程擅长处理IO密集型程序效率问题，但处理cpu密集型不是它的长处    <blockquote>
<p>假设线程中有个协程是cpu密集型，但是没有io操作，也就是一时半会不会主动触发调度器调度，从而其他协程得不到执行      </p>
</blockquote>
</li>
</ul>
<h4 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h4><ol>
<li>高性能计算，牺牲公平性换区吞吐量；          </li>
<li>在 IO 密集型程序中。由于io密集型的程序中往往需要 CPU 频繁切换线程，带来大量性能浪费。但是协程可以很好地解决这个问题：比如把一个IO操作写成一个协程，当触发IO操作时就自动让出cpu给其他协程，协程间的切换是很轻的。      </li>
<li>流式计算。消除Callback Hell。    </li>
</ol>
<h3 id="Kotlin-优势"><a href="#Kotlin-优势" class="headerlink" title="Kotlin 优势"></a>Kotlin 优势</h3><p>按照官网上的说法：</p>
<ul>
<li>简洁。语法简单，代码很少。判空、getter、setter 方法、命名传参(动态改变参数)无需重载，可能结合anko 之类的更加简单    </li>
<li>安全，减少空指针等错误、类型判断过后，自动类型转换      </li>
<li>兼容java，可以混编</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>lateinit，也容易引起空指针，即还未初始化    </li>
<li>直接使用 ArrayList 之类的list 是不能直接添加元素的，得使用 MutableList 才行     </li>
<li>引入了kotlin 支持库，apk包体积增加     </li>
<li>如果某个变量设置为可空的，那么即使你在初始化后，已经不空了，你也只能使用 ? 或者  !! 操作来使用它，感觉会有点乱     </li>
</ul>
<h3 id="kotlin如何实现空安全"><a href="#kotlin如何实现空安全" class="headerlink" title="kotlin如何实现空安全"></a>kotlin如何实现空安全</h3><ul>
<li>可空类型和不可空类型     </li>
<li>使用 ? 进行安全调用      </li>
<li>入参可以指定可空和非空类型     </li>
<li>安全的类型转换，如 a as? Int      </li>
<li>可以方便过滤非空元素，如： val intList: List<int> = nullableList.filterNotNull()      </int></li>
</ul>
<p>一定能避免空指针问题吗？我认为是不能，因为有 lateInit 变量存在，有可能这个变量还没初始化，就会导致是空的</p>
</details>

<h2 id="3、有自定义view的经验，那如何理解-MeasureSpec？"><a href="#3、有自定义view的经验，那如何理解-MeasureSpec？" class="headerlink" title="3、有自定义view的经验，那如何理解 MeasureSpec？"></a>3、有自定义view的经验，那如何理解 MeasureSpec？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>MeasureSpec 的含义是：父View传递给当前 View 的一个建议值。MeasureSpec 是个int 类型的数字，转换成二进制后，前2位代表模式(mode)，后30位代表数值(size)。模式总共分为3种：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/MeasureSpec%E6%B5%8B%E9%87%8F%E6%A8%A1%E5%BC%8F.jpg" alt="MeasureSpec测量模式"></p>
<p><strong>measureSpec &amp; MODE_MASK 即可获得mode的值；而 measureSpec &amp; ~MODE_MASK 即可获得数值</strong>。</p>
<p>那么，measureSpec 的值到底是如何计算得到的？view的 measureSpec 根据view 的布局参数(LayoutParams) 和 父容器的 MeasureSpec 值计算得到的，计算方法如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/view%E7%9A%84measureSpec%E5%80%BC.jpg" alt="view的measureSpec值"></p>
<p>由于UNSPECIFIED模式用于系统内部多次measure 的情况(如listview、gridview 等)，很少用到自定义view上，因此我们很少讨论。以下总结的规律也不讨论：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/measureSpec%E8%A7%84%E5%BE%8B.jpg" alt="measureSpec规律"></p>
<p>以上总结中，父容器的剩余空间指的是父容器除了padding之外的所剩余的空间，至于<font color="ff0000">父容器的剩余空间与大小不超过父容器的剩余空间，看代码和看图都没能理解，后续再理解吧</font></p>
<p><strong>以上内容部分<a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/94545178">参考自这个链接</a></strong></p>
</details>

<h2 id="4、聊聊-Android-中事件分发机制？"><a href="#4、聊聊-Android-中事件分发机制？" class="headerlink" title="4、聊聊 Android 中事件分发机制？"></a>4、聊聊 Android 中事件分发机制？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><a href="https://glassx.gitee.io/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/">参考以前写的这篇文章</a></p>
<p>上面的文章中已经写得很明白了，但是需要重点再提一下的是，如果在 onTouchEvent 中不消耗事件，则在同一个事件序列中，当前View无法再次接到事件。</p>
</details>

<h2 id="5、如何处理手势冲突？"><a href="#5、如何处理手势冲突？" class="headerlink" title="5、如何处理手势冲突？"></a>5、如何处理手势冲突？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>有外部和内部两种方式处理手势冲突。</p>
<p><strong>外部拦截</strong>：由上面的事件分配可知，点击事件都会经过父容器拦截处理，如果父容器需要此事件就拦截，否则此事件就不拦截，这样就可以解决事件冲突。外部拦截法需要重写父容器的onInterceptTouchEvent，比较符合事件分发机制。      </p>
<blockquote>
<p>这里要注意的是，还是上面的原则，在 onInterceptTouchEvent 中，首先是ACTION_DOWN 这个事件，父容器必须返回false，即不拦截，因为一旦拦截了 ACTION_DOWN ,后续的 ACTION_MOVE 和 ACTION_UP 都没法再传递给子view了； <font color="ff0000">接下来的内容辩证看待：ACTION_MOVE根据需要是否拦截；ACTION_UP 必须返回false，因为如果返回true，那么子view 是接受不到 ACTION_UP 事件，onClick 事件就无法响应。</font></p>
</blockquote>
<p><strong>内部拦截法</strong>：</p>
<p>可以利用view事件分发的原则，在适当的地方拦截就行。</p>
<p>当然，也可以让父空间不拦截，如果是ViewGroup的话，可以在 onInterceptTouchEvent 方法中请求忽略外层容器拦截事件：getParent().requestDisallowInterceptTouchEvent(true) 。如果是View的话，那么把getParent().requestDisallowInterceptTouchEvent(true) 写在setOnTouchListener 方法中可能更合适。</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/u014628886/article/details/52222115">一骑绝尘</a>  和 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4f3e7a057cd6">前行的乌龟</a></p>
</blockquote>
<h2 id="6、如何优化App性能？"><a href="#6、如何优化App性能？" class="headerlink" title="6、如何优化App性能？"></a>6、如何优化App性能？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><strong>一、精简资源</strong>     </p>
<ul>
<li>lint检测，删除无用的资源           </li>
</ul>
<p><strong>二、减轻Application的负担</strong></p>
<ul>
<li>将非紧急操作，放在子线程中处理     </li>
<li>只在主进程中初始化app内容(因为接了百度地图等，会开启多个进程)    </li>
</ul>
<p><strong>三、UI绘制优化</strong></p>
<ul>
<li>布局优化，尽量使用 ConstraintLayout 减少布局层次(因为深度遍历)     </li>
<li>布局复用，比如底部的布局大体相似，都使用同一个 layout     </li>
<li>避免过度绘制。排查移除叠加的背景      </li>
<li>减少资源数目，因为shape很难复用，故shape换成 固定的控件： ShapedTextView、ShapedConstrainLayout 等      </li>
<li>提高显示速度</li>
</ul>
<blockquote>
<p>使用 viewstub 延后显示。         </p>
</blockquote>
<p><strong>四、内存相关优化</strong>      </p>
<blockquote>
<p>一言以蔽之： 开源节流</p>
</blockquote>
<ul>
<li>webview 新进程          </li>
<li>检查内存泄漏(LeakCanery)    </li>
<li>正确地使用引用，尤其Activity的context(尽量替换成Application 的context，Activity 的Context 一律弱引用)，以及强引用、弱引用、软引用的正确使用。       </li>
<li>使用正确的容器，比如避免自动装箱(使用SparseArray等)、避免hashmap内存浪费(使用ArrayMap等)       </li>
<li>枚举替换成注解。</li>
</ul>
<p><strong>五、cpu 相关优化</strong>   </p>
<ul>
<li>解析缓存数据一律放在子线程处理    </li>
<li>SharedPreference 存储json改动    </li>
<li>webview预加载</li>
</ul>
<p><strong>六、网络优化</strong>   </p>
<ul>
<li>域名替换成ip(选取响应速度最快的ip)，避免劫持同时提升响应速度，webview 中的网络请求由网络框架接管。    </li>
</ul>
<p><strong>七、结构</strong></p>
<ul>
<li>mvp</li>
</ul>
<p><strong>八、避开高峰</strong></p>
<ul>
<li>不要同时，充分利用IdleHandler，快速滑动的时候不加载图片</li>
</ul>
<p>具体优化方式：</p>
<blockquote>
<p>1、内存从经常性的 380M 左右降低到 330M 的水平(adb shell dumpsys com.esun.ui，现在可以使用profile)<br>2、页面秒开(talkingdata数据显示，优化前88%左右,93%的收集数据显示1秒以内打开，从onCreate 到onResume)<br>3、过度绘制(优化前几乎所有主要页面都是红色-蓝、绿、粉、红 分别代表过度绘制 1,2,3,4 次，优化后基本上都是蓝绿，粉色的比较少，红色的可能只有极少数小块)<br>4、App启动速度加快，冷启动，从3.5秒左右降低到1秒左右(录屏，记录从启动到展示flash页面，多次时间取平均值)<br>5、网络连接，网络的错误率4%(按次数统计出的)左右，dns加速后，网络错误率基本上保持，主要集中在网络超时、网络无连接两种异常，其中网络超时占了40%左右                 </p>
</blockquote>
</details>

<h2 id="引申-adb-shell-dumpsys-meminfo-com-esun-ui-中各数据含义"><a href="#引申-adb-shell-dumpsys-meminfo-com-esun-ui-中各数据含义" class="headerlink" title="引申-adb shell dumpsys meminfo com.esun.ui 中各数据含义"></a>引申-adb shell dumpsys meminfo com.esun.ui 中各数据含义</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Native Heap：  Native对象malloc得到的内存<br>Dalvik Heap：  Java对象new得到的内存<br>Dalvik Other： 类数据结构和索引占据的内存<br>Stack：        栈占用的内存(栈空间使用，如函数调用、局部变量等)<br>Pss Total：    在硬盘上实际占用的空间大小<br>Heap Size：   Heap总共内存大小 = Heap Alloc + Heap Free, HeapSize 有限制，超出阈值就oom<br>Heap Alloc：  应用所有实例分配的内存，包括应用从Zygote 共享分享的内存(只是分配的虚拟空间，并没有实际占用，比如：new long[1024*1024]，此时alloc就会新增了8M，但是由于没赋值，所以物理内存上并没有占用，如果针对每个元素赋值，则pss total 就会增加8M)<br>Heap Free：   堆空闲的大小<br>Objects： 统计App内部组件对象的个数，其中Views、ViewRootImpl以及Activities个数，在Activity的onDestroy之后应该都会清零，如果未清零，就可能发生了内存泄露</p>
<p>Private Dirty： 私有的脏内存页(还在使用中)<br>Private Clean： 私有的干净内存页(现在未使用了)<br>Private Dirty + Private Clean 便是应用曾经申请过的内存空间大小</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/37539308ff32">简书上的博客</a></p>
</blockquote>
<h2 id="7、引申-ArrayMap的原理、SparseArray原理"><a href="#7、引申-ArrayMap的原理、SparseArray原理" class="headerlink" title="7、引申-ArrayMap的原理、SparseArray原理"></a>7、引申-ArrayMap的原理、SparseArray原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h3><p>ArrayMap 相对HashMap 而言是以时间换空间。它使用两个数组，一个整数型数组存储 key 的 hashCode，另一个Object[] 类型的数组存储 key-value键值对，如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/ArrayMap%E5%8E%9F%E7%90%86.png" alt="ArrayMap原理"></p>
<p>这样的结构避免了为每个key创建额外的对象，也即避免了自动装箱(如需要将int包装成 Integer) ，每次put新元素时，key的hashcode 在hashCode的数组中按照顺序存储，object数组中存储key和value。查询元素时，首先获取key的hashCode，然后用二分法查找该hashCode 在第一个数组中的index，则在object 数组中，key的位置在 index&lt;&lt;1 处，而value在 index&lt;&lt;1 + 1 处，如果此时的key并不是当前的key，则认为发生了冲突，此时以该key为中心点，分别上下匹配，直到匹配到为止。</p>
<p>在插入删除元素时，由于是数组组织形式，因此需要移动相关的元素，因此效率并不高；但是在数据量相对较少的情况下(有些博客说是1000条数据以下)，ArrayMap 带来的时间开销并不明显，但是节省的内存却十分可观。</p>
<h3 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h3><p>SparseArray 用于key为int类型，value 为 Object 的情形，与HashMap 相比，它避免了Integer 自动装箱，并且没有依赖entry 数据结构，因此更高效。它的结构如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/SparseArray%E5%8E%9F%E7%90%86.png" alt="SparseArray原理"></p>
<p>因为key是int类型，所以也就不需要什么hash值来计算index了，只要int值相等，就是同一个对象。插入和查找也是二分法，所以原理与ArrayMap 基本上一致，所以不多说。为了提升性能，删除元素时，并不需要马上将元素置为空，而是先将其标记为一个需要删除的元素，等真正需要删除时，才清空处理。即如果要插入新数据，如果数组已经填满了，则尝试垃圾回收一下，把标记为DELETE 的对象回收，然后重新寻找key值对应的索引，并插入。</p>
<p>** 除了SparseArray 可以替代 HashMap&lt;Integer,V&gt;外，还有 SparseIntArray替换HashMap&lt;Integer,Integer&gt;、SparseLongArray替换HashMap&lt;Integer,Long&gt;、LongSparseArray 替换 HashMap&lt;Long,V&gt; **</p>
</details>

<blockquote>
<p>以上内容<a target="_blank" rel="noopener" href="https://blog.csdn.net/chewbee/article/details/72998423">可以参考这个链接</a></p>
</blockquote>
<h2 id="8、描述http-三次握手？为什么3次，2次或者4次不行？"><a href="#8、描述http-三次握手？为什么3次，2次或者4次不行？" class="headerlink" title="8、描述http 三次握手？为什么3次，2次或者4次不行？"></a>8、描述http 三次握手？为什么3次，2次或者4次不行？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先，准确地说是TCP/IP三次握手。因为http本身是应用层协议，只是因为目前http的传输层确实是TCP/IP，所以可以这么说。但是http并不依赖于tcp/ip。</p>
<p>TCP发起连接的一方A，会随机生成一个32位的序列号，比如是1000，以该序列号为原点，对自己每个将要发送的数据进行编号，连接的另一方B会对A的每次数据进行确认，如果A收到B的确认编号是2001，则意味着 1001~2000 编号已经安全到达B。握手的示意图如下所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="tcp三次握手示意图"></p>
<p>所以我们可以总结，<strong>TCP 连接握手，握的是啥？其实就是告知双方数据原点的序列号</strong>。那为什么是3次握手呢？个人认为有两个原因：</p>
<ul>
<li>确认通信双方的 接收/发送 能力是正常的。第一次握手，B可以知道自己的接收能力、A的发送能力是正常的；第二次握手，A可以知道双方的收/发能力是正常的；第三次握手，B知道双方的收/发能力都正常。       </li>
<li>节省资源。我们知道，等3次握手结束后，服务端才给这条链接分配必要端口、缓存等资源。如果是2次握手，那么在收到客户端的请求后服务端就得分配资源了，如果第2次握手由于超时丢失，那么客户端会认为服务器还未响应，可能造成两端都在等。或者客户端等到放弃这次请求，而服务端之前分配的资源会被浪费。    </li>
</ul>
<p>因此，3次握手是必需的，更多的请求次数可以，但是浪费资源，没必要。</p>
</details>

<blockquote>
<p>以上内容有部分是<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/67772889">参考知乎中的内容</a></p>
</blockquote>
<h2 id="9、延伸-http-使用80端口，如果客户端一个tcp-ip在连接，那么就无法建立其他tcp-ip连接，因为80端口在占用？"><a href="#9、延伸-http-使用80端口，如果客户端一个tcp-ip在连接，那么就无法建立其他tcp-ip连接，因为80端口在占用？" class="headerlink" title="9、延伸-http 使用80端口，如果客户端一个tcp/ip在连接，那么就无法建立其他tcp/ip连接，因为80端口在占用？"></a>9、延伸-http 使用80端口，如果客户端一个tcp/ip在连接，那么就无法建立其他tcp/ip连接，因为80端口在占用？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>不是的，80端口一般只是http应用的默认监听端口，就是说新的连接都是发送到80端口的。但是监听80端口的程序会给新建立的连接分配一个可用的端口，所以实际的这条连接可能是机那里在服务端的 10010端口，客户端的8888端口上的。而80端口会继续监听是否有新的连接到来。</p>
</details>

<h2 id="10、描述4次挥手，3次行不行？为什么？"><a href="#10、描述4次挥手，3次行不行？为什么？" class="headerlink" title="10、描述4次挥手，3次行不行？为什么？"></a>10、描述4次挥手，3次行不行？为什么？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>tcp/ip 是全双工的，client 端在没有数据需要发送给server的时候，就发送FIN 信号告知Server ，然后终止对server 的数据传输，但是server 可以继续对client 发送数据包，这时候就是4次来终止连接，过程如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/tcp%E7%9A%844%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="tcp的4次挥手"></p>
<p>但是，<strong>如果Server 收到client 的FIN 包之后，再也没有数据要发给Client 了，那么对Client 的ack 包和 Server 自己的FIN 包就能合并成一个包发送出去，4次挥手就能变成3次挥手。</strong></p>
<p>关于图中的 time_await ，它的作用主要是1、为实现TCP全双工连接的可靠释放；2、为使旧的数据包在网络因过期而消失。更详细的解释可以<a href="https://glassx.gitee.io/2018/05/21/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0/">参考以前的这篇文章</a></p>
</details>

<h2 id="11、了解哪些设计模式？写个单例模式？"><a href="#11、了解哪些设计模式？写个单例模式？" class="headerlink" title="11、了解哪些设计模式？写个单例模式？"></a>11、了解哪些设计模式？写个单例模式？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>单例模式         </li>
<li>建造者模式       </li>
<li>工厂模式        </li>
<li>适配器模式       </li>
<li>装饰模式        </li>
<li>观察者模式         </li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程安全的单例模式代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>{</span><br><span class="line">    <span class="comment">//注意 volatitle 关键字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> volatitle Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造函数私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>{</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class){</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>){</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
</details>

<p><font color="ff0000">以下针对项目可能的提问</font></p>
<h2 id="12、了解多线程使用，聊聊锁可以分为哪些种类"><a href="#12、了解多线程使用，聊聊锁可以分为哪些种类" class="headerlink" title="12、了解多线程使用，聊聊锁可以分为哪些种类"></a>12、了解多线程使用，聊聊锁可以分为哪些种类</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>大体可以分为，这不全部指锁的状态，有的指锁的特性，有的指锁的设计：</p>
<ul>
<li>乐观锁/悲观锁    </li>
<li>公平锁/非公平锁     </li>
<li>偏向锁    </li>
<li>轻量级锁    </li>
<li>自旋锁      </li>
<li>可重入锁    </li>
</ul>
</details>

<blockquote>
<p>具体可以<a href="https://glassx.gitee.io/2019/09/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC13%E7%AB%A0/">参考以前写的这篇博客</a></p>
</blockquote>
<h2 id="13、引申-聊聊-HandlerThread"><a href="#13、引申-聊聊-HandlerThread" class="headerlink" title="13、引申-聊聊 HandlerThread"></a>13、引申-聊聊 HandlerThread</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>HandlerThread 继承了 Thread ，所以本质上是个workThread，只不过它带了个Looper，无需开发者自己去做Looper.prepare() 操作，可以看下其关键源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        }</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>所以我们在使用的时候，首先new 出一个对象来，接着就要执行其start() 方法，以便完成 Looper 的初始化，其中，notifyAll() 主要用于方法 getLooper() 中通知 Looper 已经准备好，唤醒wait：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    wait();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>在使用完成之后，需要手动退出Thread：mHandlerThread.quit();  ，其原理不用写也知道：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>{</span><br><span class="line">    Looper looper = getLooper();</span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="keyword">null</span>) {</span><br><span class="line">        looper.quit();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从以上原理我们可以知道，HandlerThread 的使用场景就是：需要在子线程执行耗时的，并且可能有多个任务的操作(每个任务都开线程导致线程太多啊)，比如多个下载任务(非同一个任务多线程下载)，还有一个典型例子就是IntentService。</p>
</details>

<h2 id="14、延伸-IntentService"><a href="#14、延伸-IntentService" class="headerlink" title="14、延伸-IntentService"></a>14、延伸-IntentService</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>我们知道，IntentService 使用非常简单，不需要自己建立线程，执行完毕后也无需我们自己关闭Service，只需要专心在 onHandleIntent(Intent intent) 方法中实现逻辑即可。IntentService 使用<strong>工作线程</strong><font color="ff0000">逐一</font>处理所有启动请求，如果不需要在Service中执行并发任务，IntentService 是最好的选择。至于如何做到的，我们只要看关键源码即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(<span class="meta">@Nullable</span> Intent intent, <span class="keyword">int</span> startId)</span> </span>{</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>IntentService onCreate 中创建了 HandlerThread 实例，mServiceHandler 创建时使用了 HandlerThread 的 Looper，这决定了最终业务是在HandlerThread 中的子线程中执行的，在 handleMessage 方法中看到了熟悉的 onHandleIntent 方法调用，待 onHandleIntent 执行完毕后，马上执行Service 的 stopSelf(msg.arg1) 关闭自己。</p>
<p>这里使用 stopSelf(msg.arg1) 而不是 stopSelf()，而msg.arg1 即 startId，而这个 startId 就是 onStartCommand(Intent intent,int flags,int startId) 的最后一个参数。我们知道多次调用startService 来启动同一个Service ，只有第一次会执行 onCreate ，但是会多次调用onStartCommand，以及onStart(所以IntentService 中，在onStart方法里面发送Message到Handler)，并且每次 startId 并不相同，且都大于0。而stopSelf() 最终会调用 stopSelf(-1)<br>。</p>
<p>stopSelf(int startId) 中的startId 与 onStartCommand 的startId 是一一对应的关系，所以，<strong>当我们调用stopSelf(int startId)时，系统会检测是否还有其它startId 存在，有的话就不销毁当前service，没有的话则销毁。</strong></p>
<p>所以，为什么是调用stopSelf 而不是调用 stopSelf(int startId)，从上面的比较我们得出：这是为了提高 IntentService 的利用率，如果在 onHandleIntent 方法执行完毕前，又调用了startService 启动了同一个 IntentService ，那么我们就没必要销毁当前service了，直接继续使用当前service 对象执行任务即可，这样有利于减少对象的销毁及创建。再提及一句，由于是使用HandlerThread ，所以多个任务只能是串行方式依次执行。</p>
</details>

<blockquote>
<p>以上内容<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bed2efd303fe">参考俗人浮生</a> 的博客，以及 IntentService 官方源码</p>
</blockquote>
<h2 id="15、volatile-关键字有了解吗？"><a href="#15、volatile-关键字有了解吗？" class="headerlink" title="15、volatile 关键字有了解吗？"></a>15、volatile 关键字有了解吗？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>讲解之前，首先了解 原子性、可见性 以及 有序性 的基本概念：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/%E5%8E%9F%E5%AD%90%E6%80%A7-%E5%8F%AF%E8%A7%81%E6%80%A7-%E6%9C%89%E5%BA%8F%E6%80%A7%E6%A6%82%E5%BF%B5.jpg" alt="原子性-可见性-有序性概念"></p>
<p>一言以蔽之，volatile 保证可见性、有序性，但是不保证原子性。</p>
<p><strong>保证可见性：</strong>多个线程共享一个volatile变量k，如果一个线程在工作内存中修改k的值会立即刷新到主存，同时将其他线程中的该值设置成已过期，其他线程在下次使用k值时，需要从主内存刷新获取。<strong>在k值更改前就已经在使用的情形，比如k值在做加法的途中，如果k值改变，则是不受影响的，必须是下一次再次使用k的时候，才会从主存去刷新</strong>。还有要注意的是，子线程使用成员变量都会将变量从主存中拷贝一份，而不是直接使用。</p>
<p><strong>保证有序性：</strong>我们知道为了提高性能，cpu或者编译器会对代码重排序，代码的执行顺序不一定和我们写的顺序是一致的，它们只保证最终结果一致。volatile 保证读/写volatile 属性时，其前面的代码必须已经执行完成，它后面的代码也不能排到前面来执行。</p>
<p><strong>不保证原子性：</strong>也即前面提到的，比如在做加法途中，这个k值改变了，是无法改变正在做的加法中的k值的。这也是volatile 修饰变量并不是线程安全的原因。</p>
</details>

<blockquote>
<p>如果还不太了解，可以<a href="https://glassx.gitee.io/2019/09/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC12%E7%AB%A0/">参考以前写的这篇读书笔记</a>、还可以<a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/83780349">参考这篇文章，讲得很透彻</a></p>
</blockquote>
<h2 id="16、什么是大接口？"><a href="#16、什么是大接口？" class="headerlink" title="16、什么是大接口？"></a>16、什么是大接口？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>大接口就是所看到的整个页面，都是由一个接口数据决定的。当时基于的背景有几个：      </p>
<ul>
<li>这个行业决定，如果有需求，可能会要求某个版本不让用户使用了。    </li>
<li>还是行业决定，页面要求能灵活变动，随时可能某个模块没有了，或者某个tab没有了。    </li>
<li>减少接口数量，减轻后台压力，我们知道，频繁的、少量数据的接口请求对后台不友好，可能握手、header 等就能占用很大一部分资源。           </li>
</ul>
<p>怎么做的：     </p>
<p>本地有若干指定的view映射，根据后台返回，可以动态添加这些view。一般view都是占满一行，左右两边的边距确定。</p>
</details>

<h2 id="17、怎么防止劫持？"><a href="#17、怎么防止劫持？" class="headerlink" title="17、怎么防止劫持？"></a>17、怎么防止劫持？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>背景：当时有用户反馈，我们的 webview 打开慢，并且有时候弹出广告，可我们自己并没有添加广告，因此初步认定可能是运营商劫持，事实上我们在百度上搜索一下运营商劫持，就有一大把的搜索结果，看来并非我们一家。在这个基础上，分析应该是通过<strong>dns 污染导致的</strong>。</p>
<p>所以解决方案就是不使用运营商的dns，而使用119(腾讯的 119.29.29.29) 和 114(114.114.114.114) 的dns，参考网上的方案，自己写了个实现。在获取到的ip 中，随机选中一个缓存起来，缓存有效时间为15分钟。</p>
<p>在 API 的http 请求中，拦截请求，查询是否缓存该host的ip，如果有，判断是否过期。如果没有缓存或者过期，则会通过上面步骤获取ip，并把host 换成ip直连。</p>
<p>针对webview的http 类型的get请求，在WebviewClient 的 shouldInterceptRequest 回调中(执行在子线程)，使用自定义构建的网络请求(根据WebResourceRequest 的 url 以及 headers 构建 okhttp 的 okHttpRequest，其中headers也加入okHttpRequest 的headers 中)。该请求会在可能的情况下，将url替换成ip直连，获取结果后，自行重新组装 WebResourceResponse 对象return。</p>
</details>

<blockquote>
<p>https的ip直连会碰到一些问题，具体可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/leelit/article/details/77829196">别人的博客</a></p>
</blockquote>
<h2 id="18、一般走查哪些代码？"><a href="#18、一般走查哪些代码？" class="headerlink" title="18、一般走查哪些代码？"></a>18、一般走查哪些代码？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>关键代码，比如容易出现死循环的重试机制、错误上报机制、安全检测机制    </p>
</details>

<h2 id="19、如何文档归档"><a href="#19、如何文档归档" class="headerlink" title="19、如何文档归档"></a>19、如何文档归档</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>使用wiki，wiki内容包括：</p>
<ul>
<li>后端接口以及参数说明    </li>
<li>前端支持的协议以及支持的格式     </li>
<li>关键逻辑的边界和参数，如自动登录尝试的次数，防止出现死循环；网络超时时长    </li>
</ul>
<p>其他部门做业务的时候只需要看wiki就行，不用找具体的技术人员查看客户端代码     </p>
</details>

<h2 id="20、聊聊这个内部sdk的设计？"><a href="#20、聊聊这个内部sdk的设计？" class="headerlink" title="20、聊聊这个内部sdk的设计？"></a>20、聊聊这个内部sdk的设计？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>以前没有做过sdk，貌似也没地方可以参考，还有时间也很紧急，所以在技术上直接采用500里面的技术，并没有什么新意，做完之后，有小需求做的同时慢慢重构，自己得出一些经验吧：</p>
<ul>
<li>控制调用权限。只暴露几个类给用户即可，其余的类不允许用户调用。         </li>
<li>确定回调方式。1、调用接口中需要传递 activity，业务中使用用户的activity 执行activityForResult 接受业务返回数据。  2、如果使用广播，则使用本地广播                     </li>
<li>防止资源名称和宿主app冲突，资源名称添加特定前缀           </li>
<li>传入的参数各种各样，需要注意判空、检验数据格式合法性等     </li>
<li>尽量不使用第三方的类库，目前sdk中使用第三方类库，接sdk的时候要求用户添加依赖      </li>
</ul>
</details> 

<h2 id="21、最有成就感的项目？最棘手的问题？"><a href="#21、最有成就感的项目？最棘手的问题？" class="headerlink" title="21、最有成就感的项目？最棘手的问题？"></a>21、最有成就感的项目？最棘手的问题？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>最有成就感的可能就是xx app吧，接触得比较多，虽然目前的流畅度还是一般般，但是做了比较多的努力：</p>
<ul>
<li>性能优化       </li>
<li>大接口试验      </li>
<li>在以前的基础上动过网络框架和图片框架      </li>
<li>在安全上也做了一些努力     </li>
</ul>
</details> 

<h2 id="22、引申-如何重新设计网络框架？"><a href="#22、引申-如何重新设计网络框架？" class="headerlink" title="22、引申-如何重新设计网络框架？"></a>22、引申-如何重新设计网络框架？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>   

<ul>
<li>调用方式改变，不需要传递2次的 responseClass    </li>
<li>采用kotlin 的线程调度(GlobalScope.launch()) 而不是rxjava 进行线程间的切换     </li>
</ul>
</details> 

<h2 id="23、引申-安全做了哪些努力"><a href="#23、引申-安全做了哪些努力" class="headerlink" title="23、引申-安全做了哪些努力"></a>23、引申-安全做了哪些努力</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>   

<ul>
<li>在native层做app签名校验  </li>
<li>广播统一改为本地广播  </li>
<li>LeakCanary防止内存泄漏  </li>
<li>SharedPreference加密  </li>
<li>allowBackUp = false  </li>
<li>某些key生成在native代码中做  </li>
<li>https证书本地验证。</li>
</ul>
</details> 

<h2 id="24、讲一讲你看过的第三方框架的源码？"><a href="#24、讲一讲你看过的第三方框架的源码？" class="headerlink" title="24、讲一讲你看过的第三方框架的源码？"></a>24、讲一讲你看过的第三方框架的源码？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary> 

<p>可以讲讲 LeakCanary 和 阿里的框架 alpha</p>
</details>

<h2 id="25、逛哪些论坛？"><a href="#25、逛哪些论坛？" class="headerlink" title="25、逛哪些论坛？"></a>25、逛哪些论坛？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>   

<p>有逛csdn，gank.io(不过gank.io有时候更新得比较慢)，apkbus，androidweekly.cn 啊 等等。</p>
</details> 

<h2 id="26、平时关注什么技术？"><a href="#26、平时关注什么技术？" class="headerlink" title="26、平时关注什么技术？"></a>26、平时关注什么技术？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>   

<p>目前关注的就是 flutter 了</p>
</details> 

<h2 id="27、有什么想问我的"><a href="#27、有什么想问我的" class="headerlink" title="27、有什么想问我的"></a>27、有什么想问我的</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><strong>如果是hr初面：</strong>       </p>
<blockquote>
<p>这个岗位是新开设的还是原岗位人离职了？<br>这个岗位可以为公司带来什么价值？<br>想了解以下公司的培训机制和学习机制     </p>
</blockquote>
<p><strong>如果是技术人员：</strong>      </p>
<blockquote>
<p>你觉得我能胜任这个职位吗(看这一关是否通过了)？<br>感觉不好，就问：你觉得我还有哪些不足？</p>
</blockquote>
<p><strong>终面的话：</strong>     </p>
<blockquote>
<p>如果顺利，问下部门、公司的发展啦<br>如果觉得基本上没戏了，就问下自己的缺陷在哪<br>如果模棱两可，问下一步流程是怎么样的    </p>
</blockquote>
</details>   

</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">面试题-算法-基础排序</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-04 21:10:00" itemprop="dateCreated datePublished" datetime="2019-03-04T21:10:00+08:00">2019-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-22 17:22:06" itemprop="dateModified" datetime="2020-03-22T17:22:06+08:00">2020-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>思路：冒泡排序基于交换排序思想。依次比较相邻的两个数，将小数放在前面，大数放在后面。</p>
<p>即第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。之后便是重复第一趟步骤，直至全部排序完成(或者说直到某一趟没有发生交换的时候)。每一趟完成后，最后一个数肯定是最大的那个数，所以一次for循环后，会有 len – 操作，即每趟都比上一趟少比较一次。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort1</span><span class="params">(<span class="keyword">int</span>[] ints)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> len = ints.length;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag) {</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) {</span><br><span class="line">            <span class="keyword">if</span> (ints[i - <span class="number">1</span>] &gt; ints[i]) {</span><br><span class="line">                <span class="keyword">int</span> temp = ints[i];</span><br><span class="line">                ints[i] = ints[i-<span class="number">1</span>];</span><br><span class="line">                ints[i-<span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        len -- ;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>冒泡排序在数据有序的情况下，只需要一趟即可，时间复杂度是 O(n)，在最差的情况下，每趟都有比较，时间复杂度是 O(n^2) ，平均复杂度是 O(n^2)，适合数据量较小的情况,它是稳定的排序方法，</p>
</details>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>选择排序的基本思想：每次从待排序的数据元素中选出最小(大)的一个元素，放在序列的起始位置。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; a.length - <span class="number">1</span>; i++){</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> index = i;<span class="comment">//当前趟最小的数所在index</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j &lt; a.length; j++){</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[index]){</span><br><span class="line">                index = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (index != i){</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[index];</span><br><span class="line">            a[index] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>它的时间复杂度是O(n^2)，因为它总是要循环那么多次，并且每次都是从待排序的数据中挑选最小的，因此它是不稳定的排序算法。</p>
</details>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>
插入排序的原理类似于打牌的时候抓牌，每次抓牌上来，都按照顺序将其插入到之前排好序的牌堆中。

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doInsertSort</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">1</span>; index&lt;length; index++){<span class="comment">//外层向右的index，即作为比较对象的数据的index</span></span><br><span class="line">        <span class="keyword">int</span> temp = array[index];<span class="comment">//用作比较的数据</span></span><br><span class="line">        <span class="keyword">int</span> leftindex = index-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(leftindex&gt;=<span class="number">0</span> &amp;&amp; array[leftindex]&gt;temp){<span class="comment">//当比到最左边或者遇到比temp小的数据时，结束循环</span></span><br><span class="line">            array[leftindex+<span class="number">1</span>] = array[leftindex];</span><br><span class="line">            leftindex--;</span><br><span class="line">        }</span><br><span class="line">        array[leftindex+<span class="number">1</span>] = temp;<span class="comment">//把temp放到空位上</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>时间复杂度是O(n^2)，适用于数据量较少的情况，是稳定的排序。</p>
</details>

<h2 id="shell排序"><a href="#shell排序" class="headerlink" title="shell排序"></a>shell排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>
原理： 严格来说是基于插入排序的思想，shell排序有点不大好理解，后续再看看

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路：三层循环</span></span><br><span class="line"><span class="comment"> * 第一层循环：控制增量-增量随着程序的进行依次递减一半</span></span><br><span class="line"><span class="comment"> * 第二层循环：遍历数组</span></span><br><span class="line"><span class="comment"> * 第三层循环：比较元素，交换元素。</span></span><br><span class="line"><span class="comment"> * 这里需要注意的是：比较的两个元素和交换的两个元素是不同的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> div = data.length/<span class="number">2</span>; div&gt;<span class="number">0</span>; div/=<span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = div; j &lt; data.length; j++) {</span><br><span class="line">            <span class="keyword">int</span> temp = data[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=j; k&gt;=div &amp;&amp; temp&lt;data[k-div] ; k-=div) {</span><br><span class="line">                data[k] = data[k-div];</span><br><span class="line">            }</span><br><span class="line">            data[k] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>shell排序最差的时间复杂度是 O(n^2)，平均复杂度是 O(nlogn)，是不稳定的排序</p>
</details>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>快速排序的思想是<strong>分治思想</strong>。假设我们现在对“6 1 2 7 9 3 4 5 10 8”这10个数进行排序。首先在这个序列中随便找一个数作为基准数，为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边。得到一个一个以6为中心的序列，再以6为界限，将左右两边都看成数组，分别按照刚才的方法排序。上个图会比较直观：</p>
<p><img src="/assets/%E8%B6%A3%E5%91%B3/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" alt="快速排序"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> i,j,temp,t;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    i=low;</span><br><span class="line">    j=high;</span><br><span class="line">    <span class="comment">//temp就是基准位</span></span><br><span class="line">    temp = arr[low];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (i&lt;j) {</span><br><span class="line">        <span class="comment">//先看右边，依次往左递减</span></span><br><span class="line">        <span class="keyword">while</span> (temp&lt;=arr[j]&amp;&amp;i&lt;j) {</span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//再看左边，依次往右递增</span></span><br><span class="line">        <span class="keyword">while</span> (temp&gt;=arr[i]&amp;&amp;i&lt;j) {</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//如果满足条件则交换</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;j) {</span><br><span class="line">            t = arr[j];</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">            arr[i] = t;</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//最后将基准为与i和j相等位置的数字交换</span></span><br><span class="line">     arr[low] = arr[i];</span><br><span class="line">     arr[i] = temp;</span><br><span class="line">    <span class="comment">//递归调用左半数组</span></span><br><span class="line">    quickSort(arr, low, j-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//递归调用右半数组</span></span><br><span class="line">    quickSort(arr, j+<span class="number">1</span>, high);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>快排的平均时间复杂度是 O(nlogn) ，最坏情况下为 O(n^2)，这种交换方式导致它是不稳定的排序。</p>
</details>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>堆排序是一种<strong>选择排序</strong>。</p>
<p>堆排序时，先构建堆(假设大顶堆)，将数组转换成堆，数据在堆中是按层编号的，所以数组中一个编号为 i 的结点的子结点在 2i + 1 和 2i + 2 的位置。开始构建时，首先从最后一个非叶子结点开始(叶子结点不用调，叶子结点只是非叶子结点比较时被动移动)，最后一个非叶子节点的位置在 n/2-1。 </p>
<p>构建了大顶堆后，堆顶元素与末尾元素交换，将大元素“沉”到末尾，将除尾部以外的元素再构建大顶堆，如此循环，每次找到最大的下沉的后面。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> arrLen = arr.length;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//建立大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLen/<span class="number">2</span> -<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">        <span class="comment">//从第一个非叶子结点(在 arrLen/2 -1 处)从下至上，从右至左调整结构</span></span><br><span class="line">        adjustHeap(arr,i,arrLen);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = arrLen -<span class="number">1</span>;j &gt;= <span class="number">0</span>;j--){</span><br><span class="line">        <span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">        temp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重新对堆进行调整</span></span><br><span class="line">        adjustHeap(arr,<span class="number">0</span>,j);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>{</span><br><span class="line">    <span class="comment">//先取出当前元素i</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[start];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>*start + <span class="number">1</span>;k &lt; end;k = <span class="number">2</span>*k + <span class="number">1</span>){<span class="comment">//从i结点的左子结点(2i+1处)开始</span></span><br><span class="line">        <span class="keyword">if</span> (k + <span class="number">1</span> &lt; end &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]){<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">            k ++;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">        <span class="keyword">if</span> (arr[k] &gt; temp) {</span><br><span class="line">            arr[start] = arr[k];</span><br><span class="line">            start = k;</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    arr[start] = temp;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<p>它的最坏，最好以及平均复杂度都是 O(nlogn)，它是不稳定排序。</p>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6129630.html">他人的博客</a></p>
</details>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>归并排序是基于 分治法 实现的。目前还看不大懂，后续再理解</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//非递归算法实现二路归并排序，length代表数组长度，即数组最大下标是 legth - 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> List[],<span class="keyword">int</span> length)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> low;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> high;</span><br><span class="line">    <span class="comment">//size 是标记当前各个归并序列的high-low，从1，2，4，8，……，2*size</span></span><br><span class="line">    <span class="keyword">while</span>(size &lt;= length - <span class="number">1</span>){</span><br><span class="line">        <span class="comment">//从第一个元素开始扫描，low代表第一个分割的序列的第一个元素</span></span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前的归并算法结束的条件</span></span><br><span class="line">        <span class="keyword">while</span>(low + size &lt;= length - <span class="number">1</span>){</span><br><span class="line">            <span class="comment">//mid代表第一个分割的序列的最后一个元素</span></span><br><span class="line">            mid = low + size - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//high 代表第二个分割的序列的最后一个元素</span></span><br><span class="line">            high = mid + size;</span><br><span class="line">            <span class="comment">//判断一下：如果第二个序列个数不足size个</span></span><br><span class="line">            <span class="keyword">if</span>(high &gt; length - <span class="number">1</span>){</span><br><span class="line">                <span class="comment">//调整 high 为最后一个元素的下标即可</span></span><br><span class="line">                high = length - <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//调用归并函数，进行分割的序列的分段排序</span></span><br><span class="line">            merge(List, low, mid, high);</span><br><span class="line">            <span class="comment">//打印出每次归并的区间</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"low:"</span> &lt;&lt; low &lt;&lt; <span class="string">" mid:"</span> &lt;&lt; mid &lt;&lt; <span class="string">" high:"</span> &lt;&lt; high &lt;&lt; endl;</span><br><span class="line">            <span class="comment">//下一次归并时第一序列的第一个元素位置</span></span><br><span class="line">            low = high + <span class="number">1</span>;</span><br><span class="line">        }<span class="comment">// end of while</span></span><br><span class="line">        <span class="comment">//范围扩大一倍，二路归并的过程</span></span><br><span class="line">        size *= <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>归并的思想主要用于外部排序：<br>外部排序可分两步<br>①待排序记录分批读入内存，用某种方法在内存排序，组成有序的子文件，再按某种策略存入外存。<br>②子文件多路归并，成为较长有序子文件，再记入外存，如此反复，直到整个待排序文件有序。</p>
</blockquote>
</details>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述排序，稳定的排序有：冒泡、插入、合并 ，不稳定排序：选择、shell、快排、堆排</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">面试题-算法-二叉树遍历</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-03 20:10:00" itemprop="dateCreated datePublished" datetime="2019-03-03T20:10:00+08:00">2019-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-22 17:48:50" itemprop="dateModified" datetime="2020-03-22T17:48:50+08:00">2020-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p><img src="/assets/%E8%B6%A3%E5%91%B3/%E7%AE%97%E6%B3%95/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="先序遍历"></p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>递归方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(BTreeNode treeNode)</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(treeNode != <span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//显示节点数据</span></span><br><span class="line">        showNodeValue(treeNode);</span><br><span class="line">        <span class="comment">//先序遍历左子树</span></span><br><span class="line">        pre(treeNode.left);</span><br><span class="line">        <span class="comment">//先序遍历右子树</span></span><br><span class="line">        pre(treeNode.right)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>非递归方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归，手算的思想，先变访问边找，找到最左下方的，然后向上再向访问右边的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePreOrder</span><span class="params">(TreeNode p)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty() || p != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) {</span><br><span class="line">            visit(p);</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        }</span><br><span class="line">        p = stack.pop();</span><br><span class="line">        p = p.right;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的思想，按层次倒着进栈，利用后进先出解决顺序问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePreOrder_2</span><span class="params">(TreeNode p)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    stack.push(p);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) {</span><br><span class="line">        p = stack.pop();</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) stack.push(p.right);</span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) stack.push(p.left);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p><img src="/assets/%E8%B6%A3%E5%91%B3/%E7%AE%97%E6%B3%95/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="中序遍历"></p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>递归方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">middle</span><span class="params">(BTreeNode treeNode)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(treeNode != <span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//中序遍历左子树</span></span><br><span class="line">        middle(treeNode.left);</span><br><span class="line">        <span class="comment">//显示节点数据</span></span><br><span class="line">        showNodeValue(treeNode);</span><br><span class="line">        <span class="comment">//中序遍历右子树</span></span><br><span class="line">        middle(treeNode.right);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>非递归方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeInOrder</span><span class="params">(TreeNode p)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty() || p != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        }</span><br><span class="line">        p = stack.pop();</span><br><span class="line">        visit(p);</span><br><span class="line">        p = p.right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><img src="/assets/%E8%B6%A3%E5%91%B3/%E7%AE%97%E6%B3%95/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="后序遍历"></p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>
递归方法：

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">behind</span><span class="params">(BTreeNode treeNode)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(treeNode != <span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//后序遍历左子树</span></span><br><span class="line">        behind(treeNode.left);</span><br><span class="line">        <span class="comment">//后序遍历右子树</span></span><br><span class="line">        behind(treeNode.right);</span><br><span class="line">        <span class="comment">//显示节点数据</span></span><br><span class="line">        showNodeValue(treeNode);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>非递归方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双栈法，易于理解</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePostOrder_3</span><span class="params">(TreeNode p)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; result = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty() || p != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            result.push(p);</span><br><span class="line">            p = p.right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty()) p = stack.pop().left;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (!result.empty()) {</span><br><span class="line">        p = result.pop();</span><br><span class="line">        visit(p);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>

<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeLevelOrder</span><span class="params">(TreeNode p)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.offer(p);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        p = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) queue.offer(p.left);</span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) queue.offer(p.right);</span><br><span class="line">        visit(p);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</details>

<p>以上内容可以<a target="_blank" rel="noopener" href="https://www.cnblogs.com/songwenjie/p/8955856.html">参考这篇博客</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/03/02/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/02/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" class="post-title-link" itemprop="url">面试题-算法-经典问题解决</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-02 20:10:00" itemprop="dateCreated datePublished" datetime="2019-03-02T20:10:00+08:00">2019-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-08 12:56:35" itemprop="dateModified" datetime="2020-03-08T12:56:35+08:00">2020-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="扑克洗牌算法"><a href="#扑克洗牌算法" class="headerlink" title="扑克洗牌算法"></a>扑克洗牌算法</h2><p>打乱一个已有顺序有多种实现方式，但是要高效地实现，还需要斟酌，以下是目前能想到的最有的解决方案：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成一副牌</span></span><br><span class="line">Card[<span class="number">52</span>] oneCard = generateOneCard;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序与 随机位置交换</span></span><br><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oneCard.size(); i ++){</span><br><span class="line">    <span class="keyword">int</span> j = r.nextInt(<span class="number">52</span>);</span><br><span class="line">    Card tempCard = oneCard[i];</span><br><span class="line">    oneCard[i] = onCard[j];</span><br><span class="line">    onCard[j] = tempCard;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="判断链表中是否有环"><a href="#判断链表中是否有环" class="headerlink" title="判断链表中是否有环"></a>判断链表中是否有环</h2><p><strong>快慢指针法：</strong>创建两个指针1和2同时指向这个链表的头节点，然后两个指针分别向后移动，其中指针1每次向后移动一个节点，指针2每次向后移动两个节点，每移动一次就比较两个指针指向的节点是否相同，如果相同说明出链表有环；如果不同，则继续循环，直到有环结束或者到达尾部结束。</p>
<blockquote>
<p>原理：两个人在环形跑道上同一位置开始跑，一人速度快，一人速度慢，如此持续跑一段时间，速度快的那个肯定会从速度慢的身后再次追上以及超越，这中间必然有个交汇点。如果是跑直线的话，到终点就结束了，不会再碰面。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否有环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isLoopList</span><span class="params">(ListNode&lt;T&gt; head)</span></span>{</span><br><span class="line">    ListNode&lt;T&gt; slowPointer, fastPointer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用快慢指针，慢指针每次向前一步，快指针每次两步</span></span><br><span class="line">    slowPointer = fastPointer = head;</span><br><span class="line">    <span class="keyword">while</span>(fastPointer != <span class="keyword">null</span> &amp;&amp; fastPointer.next != <span class="keyword">null</span>){</span><br><span class="line">        slowPointer = slowPointer.next;</span><br><span class="line">        fastPointer = fastPointer.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两指针相遇则有环</span></span><br><span class="line">        <span class="keyword">if</span>(slowPointer == fastPointer){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="引申：如何判断环的入口"><a href="#引申：如何判断环的入口" class="headerlink" title="引申：如何判断环的入口"></a>引申：如何判断环的入口</h2><p>我们假定链表头到环入口的距离是len，环入口到slow和fast交汇点的距离为x，环的长度为R。slow和fast第一次交汇时，设slow走的长度为：d = len + x，而fast走的长度为：2d = len + nR + x，(n &gt;= 1)，从而我们可以得知：2len + 2x = len + nR + x，即len = nR - x，(n &gt;= 1)。所以，要找出环入口，也要两个指针，一个指针A指向相遇时候的节点，一个指针B指向链表头，两个指针每次都走一步，A指针在遍历过程中可能多次(n &gt;= 1)经过环入口节点，但当B指针第一次达到入口节点时，A指针此时必然也指向入口节点。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否有环，有环就返回入口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ListNode&lt;T&gt; <span class="title">findEntranceInLoopList</span><span class="params">(ListNode&lt;T&gt; head)</span></span>{</span><br><span class="line">    ListNode&lt;T&gt; slowPointer, fastPointer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用快慢指针，慢指针每次向前一步，快指针每次两步</span></span><br><span class="line">    <span class="keyword">boolean</span> isLoop = <span class="keyword">false</span>;</span><br><span class="line">    slowPointer = fastPointer = head;</span><br><span class="line">    <span class="keyword">while</span>(fastPointer != <span class="keyword">null</span> &amp;&amp; fastPointer.next != <span class="keyword">null</span>){</span><br><span class="line">        slowPointer = slowPointer.next;</span><br><span class="line">        fastPointer = fastPointer.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两指针相遇则有环</span></span><br><span class="line">        <span class="keyword">if</span>(slowPointer == fastPointer){</span><br><span class="line">            isLoop = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个指针从链表头开始，一个从相遇点开始，每次一步，再次相遇的点即是入口节点</span></span><br><span class="line">    <span class="keyword">if</span>(isLoop){</span><br><span class="line">        slowPointer = head;</span><br><span class="line">        <span class="keyword">while</span>(fastPointer != <span class="keyword">null</span> &amp;&amp; fastPointer.next != <span class="keyword">null</span>){</span><br><span class="line">            <span class="comment">//两指针相遇的点即是入口节点</span></span><br><span class="line">            <span class="keyword">if</span>(slowPointer == fastPointer){</span><br><span class="line">                <span class="keyword">return</span> slowPointer;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            slowPointer = slowPointer.next;</span><br><span class="line">            fastPointer = fastPointer.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="再引申，两个单链表是否相交"><a href="#再引申，两个单链表是否相交" class="headerlink" title="再引申，两个单链表是否相交"></a>再引申，两个单链表是否相交</h2><p>两个<strong>没有环的链表</strong>在某一节点相交，那么在这个节点之后的所有结点都是两个链表所共有的。如果它们相交，则最后一个结点一定是共有的，因此问题转化为：两个链表最后一个结点是否相同（时间复杂度为O(len1+len2)）。要找出相交的第一个结点，可以首先获得两个链表的长度，然后获得两个链表长度差值 K，之后长的链表指向第K个结点，短的链表从头开始，每次向后移动一个结点，再比较当前结点是否相等，第一次相等的那个结点点就是相交节点。</p>
<blockquote>
<p>代码略</p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E7%B1%BB%E4%BC%BC%E8%A1%8C%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E7%B1%BB%E4%BC%BC%E8%A1%8C%E6%B5%8B/" class="post-title-link" itemprop="url">面试题-算法-类似行测</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-01 20:10:00" itemprop="dateCreated datePublished" datetime="2019-03-01T20:10:00+08:00">2019-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-08 15:17:57" itemprop="dateModified" datetime="2020-03-08T15:17:57+08:00">2020-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p><strong>1、给100盏灯编号 1~100，开始时所有灯都是关着的<br>第1次：把所有编号是1的倍数的灯的开关状态改变一次；<br>第2次：把所有编号是2的倍数的灯的开关状态改变一次；<br>第3次，把所有编号是3的倍数的灯的开关状态改变一次；<br>…<br>第100次，把所有编号是100的倍数的灯的开关状态改变一次；<br>问：最后开着的灯的编号是哪些？</strong></p>
<blockquote>
<p>分析：最开始灯是灭的，因此只有经过<strong>奇数</strong>次开关状态改变，灯才会是亮的。从题意可知一个数字有多少约数就会状态改变多少次，因此这道题可以转换为：<strong>1~100数字中约数个数是奇数的有哪些</strong>。并且我们知道约数是成对出现的，如8的约数：（1，8）、（2，4），因此如果要出现约数的个数是奇数个，除非它是个平方数，如36的约数：（1，36）、（2，18）、（3，12）、（4，9）、（6），因此，这题又可以转换为<strong>1~100数字中的平方数有哪些</strong>，这操作。。。。666吧，这就是分析问题的乐趣吧</p>
</blockquote>
<p><strong>2、烧一根不均匀的绳子，从头烧到尾总共需要1小时，现在有若干条这样的绳子，问如何用烧绳子的方法来计时1小时15分钟呢</strong></p>
<blockquote>
<p>从题目知道，绳子不均匀，不能根据燃烧半根来计量半小时。但是还可以推断，从两头烧，只要半小时。因此可以使用3根绳子来计时：1）第1根绳子点燃两端，第2根绳子点燃一端，第三根绳子先不点燃； 2）第1根绳子烧完计时30分钟，接着第2根绳子另一端也点燃 3）第2根绳子烧完计时15分钟，此时已经计时45分钟了，剩下的半小时只需要将第3条绳子两端点燃就能计算出。</p>
</blockquote>
<p><strong>3、有12个外观一样的小球，但有一个与其他小球重量略微不同，用手感觉不出来，用一个天平，能称3次就能找到那个小球吗</strong></p>
<blockquote>
<p>把小球编号 1<del>12，然后分为3组（想想为什么是3组）：1</del>4分为A组，5<del>8分为B组，9</del>12分为C组。首先A组和B组称量比较：<br>1、天平平衡。则目标小球在C组。将C分为两组：9、10、11分为一组C1，12分为一组C2，再从B中随意拿出3个球分组为B1，C1和B1比较：<br>    1）若平衡，则12号球就是目标球。<br>    2）若不平衡，则目标球在C1内，并且根据天平倾斜，可以判断目标球比普通球重还是轻（若是天平显示B1重，则目标球比较轻；反之目标球比较重），此时随意取 C1 中的2个球放在天平上即可知道结果（如果平衡，则目标球是另一个，如果不平衡，根据轻重可知目标球）。<br>2、天平不平衡。则目标球在A或者B中。<br>    1）若A &gt; B,取（1，2，3，5）为一组X,(4,9,10,11)为一组Y，（6，7，8）为一组Z，比较X和Y，若X&gt;Y，可知不同小球在1，2，3中，且目标球重于普通球，此时再将编号 1，2，3 任取2个放上天平即可知道目标球。若X&lt;Y,则说明4号是目标球；若X=Y，则目标球在Z中（6，7，8），并且目标球轻于普通球，此时只需要将编号 其中任意两个球放上天平即可找出目标球。<br>    2）若 A &lt; B，同样按照上述分为X、Y、Z三组，同理，若X&lt;Y，则目标球在1，2，3中，且目标球轻于普通球，此时再将编号 1，2，3 任取2个放上天平即可知道目标球；若X&gt;Y,说明4号为目标球，若X=Y，则目标球在Z中（6，7，8），并且目标球重于普通球，此时再将编号 6，7，8 任取2个放上天平即可知道目标球。</p>
</blockquote>
<p><strong>3、一笔画出经过9个点的4条直线</strong></p>
<blockquote>
<p>主要是要突破点，不要局限于点上，不说了，直接上图：<br>9点4线</p>
</blockquote>
<p><img src="/assets/%E8%B6%A3%E5%91%B3/9point-4line.png" alt="9点4线"></p>
<p><strong>4、有1块钱1瓶的契税，喝完后2个空瓶换一瓶汽水，问有20块钱，可以喝几瓶汽水？</strong></p>
<blockquote>
<p>总共40瓶（不要浪费最后那个空瓶，找老板借1个，凑2瓶子再喝一瓶，最后这空瓶还给老板。。。）</p>
</blockquote>
<p><strong>5、时针分针秒针重合的次数</strong></p>
<blockquote>
<p>只有2次，一次是 00:00:00 一次是 12：00：00</p>
</blockquote>
<p><strong>假设排列100个球，两个人轮流一拿球装入口袋，能拿到第100个球为胜，条件是每次拿球至少拿1个，最多拿5个，加入你是最先拿球的人，你该拿几个，以后怎么保证拿到最后一个球？</strong></p>
<blockquote>
<p>怎样保证拿到最后一个球呢？最简单的方法是最后剩下6个，并且轮到对方来拿，这样无论对方拿几个，都能保证自己拿到最后一个。<br>（1）首先，要控制每一轮拿出的个数，但是对方拿的个数是不受控制的，假设对方拿n个，自己就拿6-n个（为什么是控制总数是6个，是因为对手最多拿5个，自己最少能拿1个，和值就是6，自己不能把和值控制得更低；而对手至少拿1个，自己最多拿5个，同样自己不能把和值控制得更高。因此只有6才是一个可控的值）。<br>（2）其次，假设第一次拿x个球，以后每次自己和对方拿的和是6，最多可以拿到15轮（除去第一轮的x个，最后留这肯定少于10个了），还剩 10-x个，为了达到之前定的目标最后留6个，所以x应该是4.<br>（3）总结而言就是第一次拿4个，以后每次对方拿了n个后，自己拿 6-n 个。</p>
</blockquote>
<h3 id="如何确定用户异地登陆。"><a href="#如何确定用户异地登陆。" class="headerlink" title="如何确定用户异地登陆。"></a>如何确定用户异地登陆。</h3></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Android 事件分发机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-25 22:00:00" itemprop="dateCreated datePublished" datetime="2019-02-25T22:00:00+08:00">2019-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-22 16:43:26" itemprop="dateModified" datetime="2021-02-22T16:43:26+08:00">2021-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%93%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">专题</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h1 id="Android-事件分发机制"><a href="#Android-事件分发机制" class="headerlink" title="Android 事件分发机制"></a>Android 事件分发机制</h1><p>当我们点击屏幕时，事件最先传递给Activity ，在 Activity 的dispatchTouchEvent() 回调中，默认首先调用 getWindow().superDispatchTouchEvent(ev) 将事件交给window 处理，如果window 返回true之后，则直接return true。在 getWindow().superDispatchTouchEvent(ev) 调用的时候，我们能发现事件一步步传递：</p>
<p>1、PhoneWindow.superDispatchTouchEvent<br>2、DecorView.dispatchTouchEvent()<br>3、ViewGroup. dispatchTouchEvent()     </p>
<p>之后，就进入了ViewGroup的事件分发流程。用一张图(这张图转载自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/38015afcdb58">Carson_Ho</a>)来描绘下整体的过程：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/Activity%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B.webp" alt="Activity事件分发"></p>
<p>接下来主要关注的是 Android 中 ViewGroup 事件分发机制。它总体来说可以用几张图说明白，相比在代码中打印Log，这种方式更容易理解和记住。</p>
<h2 id="针对-ACTION-DOWN-事件"><a href="#针对-ACTION-DOWN-事件" class="headerlink" title="针对 ACTION_DOWN 事件"></a>针对 ACTION_DOWN 事件</h2><p>只针对 ACTION_DOWN 事件时，事件的完整流向是一个U形图，如下图所示：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/down-all.png" alt="只考虑ACTION_DOWN 事件时事件流向图"></p>
<p>如果没有中断事件，可能看起来更直观一些，Activity、ViewGroup、View的层次更加清晰：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/down-u.png" alt="不中断事件"></p>
<h2 id="针对-ACTION-MOVE-和-ACTION-UP"><a href="#针对-ACTION-MOVE-和-ACTION-UP" class="headerlink" title="针对 ACTION_MOVE 和 ACTION_UP"></a>针对 ACTION_MOVE 和 ACTION_UP</h2><p>上面讲解的都是针对ACTION_DOWN的事件传递，ACTION_MOVE和ACTION_UP在传递的过程中并不是和ACTION_DOWN 一样，你在执行ACTION_DOWN的时候返回了false，后面一系列其它的action就不会再得到执行了。简单的说，就是当dispatchTouchEvent在进行事件分发的时候，只有前一个事件（如ACTION_DOWN）返回true，才会收到ACTION_MOVE和ACTION_UP的事件。</p>
<h3 id="ViewGroup1-的dispatchTouchEvent-中返回true消费事件"><a href="#ViewGroup1-的dispatchTouchEvent-中返回true消费事件" class="headerlink" title="ViewGroup1 的dispatchTouchEvent 中返回true消费事件"></a>ViewGroup1 的dispatchTouchEvent 中返回true消费事件</h3><p>红色的箭头代表ACTION_DOWN 事件的流向，蓝色的箭头代表ACTION_MOVE 和 ACTION_UP 事件的流向：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-1.png" alt="viewgroup1消费"></p>
<h3 id="ViewGroup2-的dispatchTouchEvent-中返回true消费事件"><a href="#ViewGroup2-的dispatchTouchEvent-中返回true消费事件" class="headerlink" title="ViewGroup2 的dispatchTouchEvent 中返回true消费事件"></a>ViewGroup2 的dispatchTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-2.png" alt="viewgroup2消费"></p>
<blockquote>
<p>在View 的dispatchTouchEvent 返回true消费事件,就不画图了，效果和在ViewGroup2 的dispatchTouchEvent return true的差不多，同样的收到ACTION_DOWN 的dispatchTouchEvent函数都能收到 ACTION_MOVE和ACTION_UP。</p>
</blockquote>
<h3 id="在View-的onTouchEvent-中返回true消费事件"><a href="#在View-的onTouchEvent-中返回true消费事件" class="headerlink" title="在View 的onTouchEvent 中返回true消费事件"></a>在View 的onTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-3.png" alt="在View 的onTouchEvent 中返回true消费事件"></p>
<h3 id="在ViewGroup-2-的onTouchEvent-中返回true消费事件"><a href="#在ViewGroup-2-的onTouchEvent-中返回true消费事件" class="headerlink" title="在ViewGroup 2 的onTouchEvent 中返回true消费事件"></a>在ViewGroup 2 的onTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-4.png" alt="在ViewGroup 2 的onTouchEvent 中返回true消费事件"></p>
<h3 id="在ViewGroup-1-的onTouchEvent-中返回true消费事件"><a href="#在ViewGroup-1-的onTouchEvent-中返回true消费事件" class="headerlink" title="在ViewGroup 1 的onTouchEvent 中返回true消费事件"></a>在ViewGroup 1 的onTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-5.png" alt="在ViewGroup 1 的onTouchEvent 返回true消费这次事件"></p>
<h3 id="在View的dispatchTouchEvent-中返回false并且ViewGroup-1-的onTouchEvent-返回true消费事件"><a href="#在View的dispatchTouchEvent-中返回false并且ViewGroup-1-的onTouchEvent-返回true消费事件" class="headerlink" title="在View的dispatchTouchEvent 中返回false并且ViewGroup 1 的onTouchEvent 返回true消费事件"></a>在View的dispatchTouchEvent 中返回false并且ViewGroup 1 的onTouchEvent 返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-6.png" alt="在View的dispatchTouchEvent 返回false并且Activity 的onTouchEvent 返回true消费这次事件"></p>
<h3 id="在View的dispatchTouchEvent-中返回false并且Activity-的onTouchEvent-返回true消费事件"><a href="#在View的dispatchTouchEvent-中返回false并且Activity-的onTouchEvent-返回true消费事件" class="headerlink" title="在View的dispatchTouchEvent 中返回false并且Activity 的onTouchEvent 返回true消费事件"></a>在View的dispatchTouchEvent 中返回false并且Activity 的onTouchEvent 返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-7.png" alt="在View的dispatchTouchEvent 返回false并且Activity 的onTouchEvent 返回true消费这次事件"></p>
<p>经过这么多图能得出以下规律：</p>
<blockquote>
<p>ACTION_DOWN事件在哪个控件消费了（return true）， 那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。</p>
</blockquote>
<p>以上文章参考自 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e99b5e8bd67b">Kelin</a> ,这里图片形式贴出来仅仅只是个人做的笔记，方便记忆。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/02/16/%E9%BB%91%E8%8B%B9%E6%9E%9C%E6%8A%98%E8%85%BE%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/16/%E9%BB%91%E8%8B%B9%E6%9E%9C%E6%8A%98%E8%85%BE%E8%AE%B0/" class="post-title-link" itemprop="url">黑苹果折腾记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-16 22:10:00" itemprop="dateCreated datePublished" datetime="2019-02-16T22:10:00+08:00">2019-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-08 16:00:37" itemprop="dateModified" datetime="2021-08-08T16:00:37+08:00">2021-08-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>过年在家没啥事干，折腾了下黑苹果，安装上了 OSX 10.14.3，整个过程还算顺利，最终除了睡眠和声卡之外，其他貌似ok，目前用来开发（Android studio 以及 XCode）没啥问题。此次记录主要是为了在以后还有闲心折腾黑苹果的时候，能拿出来参考，不至于从头开始爬帖。</p>
<p>首先，以一个过来人的身份告诉你，搞黑苹果如果不上 <a target="_blank" rel="noopener" href="https://www.tonymacx86.com">www.tonymacx86.com</a> 网站的话，等于白折腾，这上面有最简便的最新的折腾黑苹果的方法，在国内远景论坛、黑苹果社区等地方看到的清一色古老的安装方式，甚至还有变色龙安装法。不要害怕 English，对于搞黑苹果而言，只需要很简单的英语水平。我这次安装10.14.3参考的就是<a target="_blank" rel="noopener" href="https://www.tonymacx86.com/threads/unibeast-install-macos-mojave-on-any-supported-intel-based-pc.259381/">这个帖子</a>，只要一步步来，基本上是没什么问题的。</p>
<p>这个帖子主要条理清晰地通过5步，即完成了黑苹果的安装：<br>Step 1: Download macOS Mojave（第一步：下载系统）<br>Step 2: Create a Bootable USB with UniBeast（第二步：通过 UniBeast 制作 U盘启动盘）<br>Step 3: Recommended BIOS Settings（第三步：设置 BIOS ）<br>Step 4: Install macOS Mojave(第四步：安装系统)<br>Step 5: Post Installation with MultiBeast（第五步：二次安装）</p>
<p>在开始之前，首先申请 tonymacx86.com 的账号，然后 在从那里下载最新的 UniBeast 和 MultiBeast 工具，之后准备一个 32GB 的U盘吧，教程上面说 16G 以上就够了，但实际上是不够的。其中，UniBeast 的作用是 创建一个可以正常启动10.14.3 的 U盘启动盘。</p>
<h2 id="第一步-下载系统"><a href="#第一步-下载系统" class="headerlink" title="第一步 下载系统"></a>第一步 下载系统</h2><p>为了全新安装，首先可以从其他苹果系统里面下载系统，在苹果系统中：</p>
<blockquote>
<p>打开 App Store -&gt; 下载macos Mojave 更新，下载完成后，在 Applications(应用)里面能够找到它。</p>
</blockquote>
<h2 id="第二步-用-UniBeast-创建启动U盘"><a href="#第二步-用-UniBeast-创建启动U盘" class="headerlink" title="第二步 用 UniBeast 创建启动U盘"></a>第二步 用 UniBeast 创建启动U盘</h2><p>在第二步之前，首先备份好U盘的东西，因为制作启动盘会删除U盘中所有内容。</p>
<p>把U盘插到电脑上，打开：Application（应用）-&gt;Utilities（工具）-&gt; Disk Utility（磁盘工具）,从左边选中你的那个U盘，在Mojava或者更高版本中，可能你首先要设置 View(视图)-&gt;Show All Devices(显示所有设备)，才能看到你的U盘。之后执行</p>
<p>1、 点击 Erase（抹掉）按钮<br>2、填写名称，目前先命名为 USB<br>3、在Format（格式）的地方选择 Mac os Extended(Journaled)<br>4、最后，点击 Erase（抹掉） 按钮正式抹掉</p>
<p>接下来，安装你下载的 UniBeast （这里貌似要求语言是English，否则还装不上，如果有这个要求，改下系统语言就行了），只要一直continue 下去就行，之后同意协议，最后选择安装的 Destination（目的磁盘）的时候，选择刚才抹掉的 USB盘 即可；在 select os Installation （选择安装系统）界面时，选择 Mojave 就行，之后在 Bootloader Options 界面选择 UEFI Boot Mode（根据需要有可能要选择 Legacy Boot Mode）。最后 Graphics Configuration 是可选的，可以根据你的显卡来对应设置。最后确认你的安装选项，输入密码，然后 Install。这时候大概要等待个10分钟，系统会写完。</p>
<p>系统完全写入U盘之后，把下载的 MultiBeast 软件拖到 U 盘，因为安装好之后需要它。</p>
<h2 id="第三步-设置BIOS"><a href="#第三步-设置BIOS" class="headerlink" title="第三步 设置BIOS"></a>第三步 设置BIOS</h2><p>这里只针对UEFI 方式的BIOS 了（其他方式请参考原文了）。进入到 BIOS 设置中，如果CPU支持 VT-d，将其设置为 disable，CFG-Lock、Secure Boot Mode 、IO Serial Port 也 disable，设置 XHCI 为 Enable，设置 OS 为 Other OS。</p>
<h2 id="第四步-安装-macOS-Mojave"><a href="#第四步-安装-macOS-Mojave" class="headerlink" title="第四步 安装 macOS Mojave"></a>第四步 安装 macOS Mojave</h2><p>将U盘插在电脑的USB2.0口上，这点特别要注意，不然第二次安装的时候会提示找不到resource，我就在这里折腾了两回才知道。开机，选择从你的 USB 盘启动（不同的电脑主板不一样，网上搜下即可）。<br>在clover界面，通过键盘上的左右箭头（键盘右下角的上下左右箭头）选择 Boot OS X Install from macOS Mojave</p>
<p>在安装界面，首先选择顶部菜单栏的 Utilities（工具），再打开 Disk Utility（磁盘工具），在左边选中你想要安装系统的分区，之后像之前抹掉U盘那样抹掉这个分区，名字命名为 Mojave（之后你可以改这个名字），之后关闭Disk Utility（磁盘工具），即可继续安装。</p>
<p>安装的时候会提示安装到哪个盘，选择刚才抹掉的 Mojave 盘，之后会继续安装，待安装完成后会自动重启。</p>
<h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>在重启的时候要注意再次选择从U盘启动，之后在clover界面选择Mojave，之后就会自动安装，引导设置，完成。之后的事情就是安装驱动了，去论坛找各种kext即可，声卡可能就麻烦些，可能需要dsdt，这里就不细说。</p>
<h2 id="问题集锦"><a href="#问题集锦" class="headerlink" title="问题集锦"></a>问题集锦</h2><h3 id="提示已损坏，不能安装"><a href="#提示已损坏，不能安装" class="headerlink" title="提示已损坏，不能安装"></a>提示已损坏，不能安装</h3><p>如果安装过程中提示：</p>
<blockquote>
<p>安装 macOS xxx”应用程序副本已损坏，不能用来安装macOS</p>
</blockquote>
<p>则并不是镜像本身有问题，而是由于镜像的证书过期，并且苹果没有更新证书日期导致的。解决办法就是： 1、断开网络  2、在中断输入命令修改时间：</p>
<blockquote>
<p>date 0201010116</p>
</blockquote>
<p>之后，关闭终端再安装即可</p>
<h3 id="休眠导致键盘不可用"><a href="#休眠导致键盘不可用" class="headerlink" title="休眠导致键盘不可用"></a>休眠导致键盘不可用</h3><p>如果是笔记本并且安装的是双系统（win + mac os），那么如果驱动对休眠的处理不好的话，在mac osx下发生休眠可能会导致系统重启，可能会重启进入windows系统，此时，你的键盘应该是不可用的。解决方案包括以下几个步骤：</p>
<ol>
<li>启动windows ，在登录界面使用 “轻松使用-屏幕键盘” 的方式输入密码。    </li>
<li>在windows 下使用 easyUefi 软件将 黑苹果的 efi 启动序列列为第一个，这样我们开机就会启动 clover。    </li>
<li>重启系统，进入clover，此时键盘应该是不可以使用的，左右光标也是没作用的。如果能够看到你要启动的分区，则用鼠标点击直接启动，进入mac os 后，正常关闭，键盘就能正常使用了。    </li>
<li>如果未能看到需要启动的分区，此时按字母 A 键，就会进入clover 的 “关于” 页面（这个我只在我电脑上试过，我在尝试按 A 或者 D 的时候发现的，对其他电脑的未做验证），此时，你的电脑键盘应该就可以使用了。这时候就可以退出“关于”页，之后进入黑苹果。     </li>
<li>以上操作的主要目的是要正常关闭mac os ，这样键盘才能使用（在 mac os 或者 windows 下）。</li>
</ol>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/12/10/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/10/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">第五章——理解 RemoteViews</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-10 22:00:00" itemprop="dateCreated datePublished" datetime="2018-12-10T22:00:00+08:00">2018-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:43:49" itemprop="dateModified" datetime="2019-11-17T21:43:49+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>从字面可以看出这应该是一种远程view，与远程service概念一样，RemoteViews表示的是一种view结构，这种view能够在其他进程显示。由于需要跨进程显示，RemoteViews结构提供了一组基础功能用于跨进程更新View。RemoteViews在Android中有2种应用场景：<strong>Notification</strong>以及<strong>桌面小部件</strong>。</p>
<h3 id="RemoteViews的应用"><a href="#RemoteViews的应用" class="headerlink" title="RemoteViews的应用"></a>RemoteViews的应用</h3><p>平时的开发过程中，Notifications主要通过NotificationManager的notify方法实现的，它除了默认效果外，还可以另外定义布局。使用RemoteViews实现通知栏时无法像Activity里面一样直接更新View，这是因为RemoteView界面运行在其他进程中，确切来说是系统的SystemServer进程。使用系统默认的样式弹出一个通知是很简单的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Notification notification = newNotification();</span><br><span class="line">notification.icon = R.drawable.icon;</span><br><span class="line">notification.tickerText = <span class="string">"hello world"</span>;</span><br><span class="line">notification.when = System.currentTimeMillis();</span><br><span class="line">notification.flags = Notification.FLAG_AUTO_CANCEL;</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,DemoActivity_1.class);</span><br><span class="line">PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,intent,PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用普通样式展示一个通知</span></span><br><span class="line">notification.setLatestEventInfo(<span class="keyword">this</span>,<span class="string">"chapter_5"</span>,<span class="string">"this is notification"</span>,pendingIntent);</span><br><span class="line">NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">manager.notify(<span class="number">1</span>,notification);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用RemoteViews的方式展示第一个通知</span></span><br><span class="line">RemoteViews remoteViews = <span class="keyword">new</span> RemoteViews(getPackageName(),R.layout.layout_notification);</span><br><span class="line">remoteViews.setTextViewText(R.id.msg,<span class="string">"chapter_5"</span>);</span><br><span class="line">remoteViews.setImageViewResource(R.id.icon,R.drawable.icon1);</span><br><span class="line">PendingIntent openActivity2PendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,<span class="keyword">new</span> Intent(<span class="keyword">this</span>,DemoActivity_2.class),PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">remoteViews.setOnclickPendingIntent(R.id.open_activity2,openActivity2PendingIntent);</span><br><span class="line">notification.contentView = remoteViews;</span><br><span class="line">notification.contentIntent = pendingIntent;</span><br><span class="line">NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">manager.notify(<span class="number">2</span>,notification);</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码展示只要提供当前应用的包名以及布局文件的id即可创建一个RemoteViews对象，而更新RemoteViews，由于无法直接访问里面的view，因而只能通过RemoteViews提供的一系列方法来更新，比如设置文本，需要采用 remoteViews.setTextViewText(R.id.msg,”chapter_5”) ，而更新图片则采用 remoteViews.setImageViewResource(R.id.icon,R.drawable.icon1)，如果要给一个控件添加click事件，则要使用PendingIntent并且通过setOnclickPendingIntent。关于PendingIntent，它表示一种待定的Intent，这个Intent中所包含的意图必须由用户来出发。</p>
<p><strong>RemoteViews在桌面小部件上的应用、PendingIntent概述、RemoteViews的内部机制等内容 待后续有集中的时间再添加</strong></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">111</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共261.3k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.gitee.io/page/9/',]
      });
      });
  </script>


</body>
</html>
