<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/6/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">152</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/05/05/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%95%AA%E5%A4%96%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/05/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%95%AA%E5%A4%96%E7%AF%87/" class="post-title-link" itemprop="url">番外篇：Activity LaunchMode原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-05 16:13:00 / 修改时间：16:48:52" itemprop="dateCreated datePublished" datetime="2021-05-05T16:13:00+08:00">2021-05-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>番外篇主要是看到<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/09365022adac">一篇简书上的博客</a>后，对LauncherMode的一点补充。本文只是复制这篇博客的内容，防止这篇文章被简书屏蔽(因为他有一篇文章就已经是一直审核状态了)。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道Activity的start是走到Instrumentation的execStartActivity方法中，而这里是调用了ActivityManagerNative的getDefault方法 来获得一个ActivityManagerService(以下简称AMS)的远程代理对象，要走到AMS的startActivity方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br></pre></td></tr></tbody></table></figure>

<p>这里先解释一下startActivity方法里的一些参数:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>whoThread    IApplicationThread的binder对象</td>
<td>用于AMS进行进程间通信</td>
</tr>
<tr>
<td>who    上下文对象</td>
<td>其实就是Activity</td>
</tr>
<tr>
<td>intent</td>
<td>目标intent</td>
</tr>
<tr>
<td>intent.resolveTypeIfneed</td>
<td>若没有在Manifest文件里面注明Activity的mime类型，返回null</td>
</tr>
<tr>
<td>token    Binder对象</td>
<td>通过它可以获得Activity的相关信息 后边会保存到sourceRecord这个对象里面</td>
</tr>
<tr>
<td>target</td>
<td>我们调用的Activity</td>
</tr>
<tr>
<td>requestCode</td>
<td>若没有设置结果就是小于0</td>
</tr>
<tr>
<td>0</td>
<td>flags</td>
</tr>
<tr>
<td>ProfilerInfo</td>
<td>null</td>
</tr>
<tr>
<td>options</td>
<td>是一个bunder对象，记录用intent传递的信息</td>
</tr>
</tbody></table>
<p>这里对应着AMS 中startactivity的参数</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="params"><span class="function">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">        resultWho, requestCode, startFlags, profilerInfo, options,</span><br><span class="line">        UserHandle.getCallingUserId());</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="params"><span class="function">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options, <span class="keyword">int</span> userId)</span> </span>{</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line">    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</span><br><span class="line">            <span class="keyword">false</span>, ALLOW_FULL_ONLY, <span class="string">"startActivity"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">    <span class="keyword">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent,</span><br><span class="line">            resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">            profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, options, userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后会调用ActivityStackSupervisor的startActivityMayWait方法，而ActivityStackSupervisor 就是专门管理activity的堆栈的类</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-d2e1e1e2859b5c86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/726/format/webp" alt="startActivityMayWait方法"></p>
<p>这里会先解析我们的intent来获取信息，通过调用函数resoleActivity方法获取ActivityInfo，这里主要是activity在AndroidManifest.xml里的信息</p>
<p>再往下看，进入到startActivityLocked 方法中</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-e50075b5c4539486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/777/format/webp" alt="startActivityMayWait方法"></p>
<blockquote>
<p>另提一下activity 在 AMS 中的形式是 ActivityRecord,task 在 AMS 中的形式为TaskRecord,进程在 AMS 中的管理形式为 ProcessRecord</p>
</blockquote>
<p> 我们发现这里有两个ActivityRecord对象 有sourceRecord 和resultRecord</p>
<blockquote>
<p>sourceRecord 代表的是最开始的activity<br>这就是通过resultTo这个binder对象获得Mainactivity的相关信息然后保存到这个对象中<br>resultRecord 代表的是接受启动结果的Activity<br>因为requestcode==-1 所以这里resultRecord==null</p>
</blockquote>
<p>final int launchFlags = intent.getFlags();<br>这里获取Intent的启动Flag 就是我们在Intent.setFlag里面设置的标志<br>这个函数的主要作用就是处理sourceRecord和resultRecord两个对象<br>在这里sourceRecord和resultRecord指向的应该是同一个activity</p>
<p>然后调用startActivityUncheckedLocked来处理本次的启动Activity的请求</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-59cc775b23e884c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-39391603929ddcc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p>从这里我们可以看到 获取了activity的launchModel ，也就是对launchModel的判断处理应该是在这里<br>这里先判断是否FLAG_ACTIVITY_NEW_DOCUMENT，这个平时用的比较少，在android5.0上主要是决定你的task和activity是如何展现在overview screen 中的，详细请看Android 5.0 Overview Screen–总览画面<br>再往下看</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-056e3a3f60d6acbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p>startFlags == 0 所以此时不会进入这个判断，没有设置这个FLAG_ACTIVITY_PREVIOUS_IS_TOP，所以我们的notTop==null<br>接着 系统默认addingToTask= false 默认是开启新的Task，从后面的判断也可以看出来</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-1c643a3c8fae5e94.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p>之前说过 sourceRecord就是最开始的activity 所以它不会为null，这样就到了else 中 inTask = null；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-2419c6b8b3f4c7e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/755/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p> 在这里判断了启动模式，判断当前activity的启动模式和要启动的activity的启动模式，根据相应的启动模式设置launchFlags</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-888c5f5346d10e05.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-c6f1382d01eeca2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p>这里目的是判断启动的activity是否在堆栈里存在，如果存在就直接在进行相应的操作<br>在文章开头 resultRecord 默认为null而且requestCode假如没有设置的话，requestCode小于0，所以resultRecord没有被赋值，所以我们构造ActivityRecord 时传入的是null，也就是可以进入这个if判断里<br>再往里看</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-2eb788c2a9a3dd9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/577/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p>这里会判断启动的activity是否是SingleInstance，根据此进入不同的方法，目的是找到activity，如果有就返回，如果没有就返回null，先来看findTaskLocked方法</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-ea3170a8c0b3a0b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="findTaskLocked方法"></p>
<p>stack里的findTaskLocked方法比较长，顶部activity，如果没有就返回null，从注释上来看就是返回堆栈里的activity,简单说一下就是返回发起请求的activity，也是这个函数返回的activity</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the top activity in any existing task matching the given</span></span><br><span class="line"><span class="comment">     * Intent.  Returns null if no such task is found.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ActivityRecord <span class="title">findTaskLocked</span><span class="params">(ActivityRecord target)</span> </span>{</span><br><span class="line">        Intent intent = target.intent;</span><br><span class="line">        ActivityInfo info = target.info;</span><br><span class="line">        ComponentName cls = intent.getComponent();</span><br><span class="line">        <span class="keyword">if</span> (info.targetActivity != <span class="keyword">null</span>) {</span><br><span class="line">            cls = <span class="keyword">new</span> ComponentName(info.packageName, info.targetActivity);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(info.applicationInfo.uid);</span><br><span class="line">        <span class="keyword">boolean</span> isDocument = intent != <span class="keyword">null</span> &amp; intent.isDocument();</span><br><span class="line">        <span class="comment">// If documentData is non-null then it must match the existing task data.</span></span><br><span class="line">        Uri documentData = isDocument ? intent.getData() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Looking for task of "</span> + target + <span class="string">" in "</span> + <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> taskNdx = mTaskHistory.size() - <span class="number">1</span>; taskNdx &gt;= <span class="number">0</span>; --taskNdx) {</span><br><span class="line">            <span class="keyword">final</span> TaskRecord task = mTaskHistory.get(taskNdx);</span><br><span class="line">            <span class="keyword">if</span> (task.voiceSession != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// We never match voice sessions; those always run independently.</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Skipping "</span> + task + <span class="string">": voice session"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (task.userId != userId) {</span><br><span class="line">                <span class="comment">// Looking for a different task.</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Skipping "</span> + task + <span class="string">": different user"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">final</span> ActivityRecord r = task.getTopActivity();</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span> || r.finishing || r.userId != userId ||</span><br><span class="line">                    r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Skipping "</span> + task + <span class="string">": mismatch root "</span> + r);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Intent taskIntent = task.intent;</span><br><span class="line">            <span class="keyword">final</span> Intent affinityIntent = task.affinityIntent;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> taskIsDocument;</span><br><span class="line">            <span class="keyword">final</span> Uri taskDocumentData;</span><br><span class="line">            <span class="keyword">if</span> (taskIntent != <span class="keyword">null</span> &amp;&amp; taskIntent.isDocument()) {</span><br><span class="line">                taskIsDocument = <span class="keyword">true</span>;</span><br><span class="line">                taskDocumentData = taskIntent.getData();</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (affinityIntent != <span class="keyword">null</span> &amp;&amp; affinityIntent.isDocument()) {</span><br><span class="line">                taskIsDocument = <span class="keyword">true</span>;</span><br><span class="line">                taskDocumentData = affinityIntent.getData();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                taskIsDocument = <span class="keyword">false</span>;</span><br><span class="line">                taskDocumentData = <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Comparing existing cls="</span></span><br><span class="line">                    + taskIntent.getComponent().flattenToShortString()</span><br><span class="line">                    + <span class="string">"/aff="</span> + r.task.rootAffinity + <span class="string">" to new cls="</span></span><br><span class="line">                    + intent.getComponent().flattenToShortString() + <span class="string">"/aff="</span> + info.taskAffinity);</span><br><span class="line">            <span class="keyword">if</span> (!isDocument &amp;&amp; !taskIsDocument &amp;&amp; task.rootAffinity != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (task.rootAffinity.equals(target.taskAffinity)) {</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Found matching affinity!"</span>);</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (taskIntent != <span class="keyword">null</span> &amp;&amp; taskIntent.getComponent() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    taskIntent.getComponent().compareTo(cls) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    Objects.equals(documentData, taskDocumentData)) {</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Found matching class!"</span>);</span><br><span class="line">                <span class="comment">//dump();</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"For Intent "</span> + intent + <span class="string">" bringing to top: "</span></span><br><span class="line">                        + r.intent);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (affinityIntent != <span class="keyword">null</span> &amp;&amp; affinityIntent.getComponent() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    affinityIntent.getComponent().compareTo(cls) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    Objects.equals(documentData, taskDocumentData)) {</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Found matching class!"</span>);</span><br><span class="line">                <span class="comment">//dump();</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"For Intent "</span> + intent + <span class="string">" bringing to top: "</span></span><br><span class="line">                        + r.intent);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_TASKS) {</span><br><span class="line">                Slog.d(TAG, <span class="string">"Not a match: "</span> + task);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里简单说一下，先是从mTaskHistory中遍历得到一个任务Task，并根据userid找到当前的task ，找到这个任务的顶部activity，并且保证它启动模式不是singleInstance，都满足了返回以下条件的activity</p>
<p>再回到刚才的方法往下看</p>
<p>这里先去activitystack里的moveToFront()方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the caller has requested that the target task be</span></span><br><span class="line"><span class="comment">// reset, then do so.</span></span><br><span class="line"><span class="keyword">if</span> ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != <span class="number">0</span>) {</span><br><span class="line">    intentActivity = targetStack.resetTaskIfNeededLocked(intentActivity, r);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">// We don't need to start a new activity, and</span></span><br><span class="line">    <span class="comment">// the client said not to do anything if that</span></span><br><span class="line">    <span class="comment">// is the case, so this is it!  And for paranoia, make</span></span><br><span class="line">    <span class="comment">// sure we have correctly resumed the top activity.</span></span><br><span class="line">    <span class="keyword">if</span> (doResume) {</span><br><span class="line">        resumeTopActivitiesLocked(targetStack, <span class="keyword">null</span>, options);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        ActivityOptions.abort(options);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ActivityManager.START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> ((launchFlags &amp;</span><br><span class="line">        (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK))</span><br><span class="line">        == (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK)) {</span><br><span class="line">    <span class="comment">// The caller has requested to completely replace any</span></span><br><span class="line">    <span class="comment">// existing task with its new activity.  Well that should</span></span><br><span class="line">    <span class="comment">// not be too hard...</span></span><br><span class="line">    reuseTask = intentActivity.task;</span><br><span class="line">    reuseTask.performClearTaskLocked();</span><br><span class="line">    reuseTask.setIntent(r);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> ((launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != <span class="number">0</span></span><br><span class="line">        || launchSingleInstance || launchSingleTask) {</span><br><span class="line">    <span class="comment">// In this situation we want to remove all activities</span></span><br><span class="line">    <span class="comment">// from the task up to the one being started.  In most</span></span><br><span class="line">    <span class="comment">// cases this means we are resetting the task to its</span></span><br><span class="line">    <span class="comment">// initial state.</span></span><br><span class="line">    ActivityRecord top =</span><br><span class="line">            intentActivity.task.performClearTaskLocked(r, launchFlags);</span><br><span class="line">    <span class="keyword">if</span> (top != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (top.frontOfTask) {</span><br><span class="line">            <span class="comment">// Activity aliases may mean we use different</span></span><br><span class="line">            <span class="comment">// intents for the top activity, so make sure</span></span><br><span class="line">            <span class="comment">// the task now has the identity of the new</span></span><br><span class="line">            <span class="comment">// intent.</span></span><br><span class="line">            top.task.setIntent(r);</span><br><span class="line">        }</span><br><span class="line">        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,</span><br><span class="line">                r, top.task);</span><br><span class="line">        top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// A special case: we need to</span></span><br><span class="line">        <span class="comment">// start the activity because it is not currently</span></span><br><span class="line">        <span class="comment">// running, and the caller has asked to clear the</span></span><br><span class="line">        <span class="comment">// current task to have this activity at the top.</span></span><br><span class="line">        addingToTask = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// Now pretend like this activity is being started</span></span><br><span class="line">        <span class="comment">// by the top of its task, so it is put in the</span></span><br><span class="line">        <span class="comment">// right place.</span></span><br><span class="line">        sourceRecord = intentActivity;</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (r.realActivity.equals(intentActivity.task.realActivity)) {</span><br><span class="line">    <span class="comment">// In this case the top activity on the task is the</span></span><br><span class="line">    <span class="comment">// same as the one being launched, so we take that</span></span><br><span class="line">    <span class="comment">// as a request to bring the task to the foreground.</span></span><br><span class="line">    <span class="comment">// If the top activity in the task is the root</span></span><br><span class="line">    <span class="comment">// activity, deliver this new intent to it if it</span></span><br><span class="line">    <span class="comment">// desires.</span></span><br><span class="line">    <span class="keyword">if</span> (((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span> || launchSingleTop)</span><br><span class="line">            &amp;&amp; intentActivity.realActivity.equals(r.realActivity)) {</span><br><span class="line">        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r,</span><br><span class="line">                intentActivity.task);</span><br><span class="line">        <span class="keyword">if</span> (intentActivity.frontOfTask) {</span><br><span class="line">            intentActivity.task.setIntent(r);</span><br><span class="line">        }</span><br><span class="line">        intentActivity.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!r.intent.filterEquals(intentActivity.task.intent)) {</span><br><span class="line">        <span class="comment">// In this case we are launching the root activity</span></span><br><span class="line">        <span class="comment">// of the task, but with a different intent.  We</span></span><br><span class="line">        <span class="comment">// should start a new instance on top.</span></span><br><span class="line">        addingToTask = <span class="keyword">true</span>;</span><br><span class="line">        sourceRecord = intentActivity;</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">// In this case an activity is being launched in to an</span></span><br><span class="line">    <span class="comment">// existing task, without resetting that task.  This</span></span><br><span class="line">    <span class="comment">// is typically the situation of launching an activity</span></span><br><span class="line">    <span class="comment">// from a notification or shortcut.  We want to place</span></span><br><span class="line">    <span class="comment">// the new activity on top of the current task.</span></span><br><span class="line">    addingToTask = <span class="keyword">true</span>;</span><br><span class="line">    sourceRecord = intentActivity;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (!intentActivity.task.rootWasReset) {</span><br><span class="line">    <span class="comment">// In this case we are launching in to an existing task</span></span><br><span class="line">    <span class="comment">// that has not yet been started from its front door.</span></span><br><span class="line">    <span class="comment">// The current task has been brought to the front.</span></span><br><span class="line">    <span class="comment">// Ideally, we'd probably like to place this new task</span></span><br><span class="line">    <span class="comment">// at the bottom of its stack, but that's a little hard</span></span><br><span class="line">    <span class="comment">// to do with the current organization of the code so</span></span><br><span class="line">    <span class="comment">// for now we'll just drop it.</span></span><br><span class="line">    intentActivity.task.setIntent(r);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!addingToTask &amp;&amp; reuseTask == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="comment">// We didn't do anything...  but it was needed (a.k.a., client</span></span><br><span class="line">    <span class="comment">// don't use that intent!)  And for paranoia, make</span></span><br><span class="line">    <span class="comment">// sure we have correctly resumed the top activity.</span></span><br><span class="line">    <span class="keyword">if</span> (doResume) {</span><br><span class="line">        targetStack.resumeTopActivityLocked(<span class="keyword">null</span>, options);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        ActivityOptions.abort(options);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ActivityManager.START_TASK_TO_FRONT;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里主要看</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-89af170c52d6ebd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/612/format/webp" alt="代码片段"></p>
<p>这里走到了ActivityStack的performClearTaskLocked方法里</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Perform clear operation as requested by</span></span><br><span class="line"><span class="comment">    * {<span class="doctag">@link</span> Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the</span></span><br><span class="line"><span class="comment">    * stack to the given task, then look for</span></span><br><span class="line"><span class="comment">    * an instance of that activity in the stack and, if found, finish all</span></span><br><span class="line"><span class="comment">    * activities on top of it and return the instance.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> newR Description of the new activity being started.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> Returns the old activity that should be continued to be used,</span></span><br><span class="line"><span class="comment">    * or null if none was found.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> ActivityRecord <span class="title">performClearTaskLocked</span><span class="params">(ActivityRecord newR, <span class="keyword">int</span> launchFlags)</span> </span>{</span><br><span class="line">       <span class="keyword">int</span> numActivities = mActivities.size();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> activityNdx = numActivities - <span class="number">1</span>; activityNdx &gt;= <span class="number">0</span>; --activityNdx) {</span><br><span class="line">           ActivityRecord r = mActivities.get(activityNdx);</span><br><span class="line">           <span class="keyword">if</span> (r.finishing) {</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">if</span> (r.realActivity.equals(newR.realActivity)) {</span><br><span class="line">               <span class="comment">// Here it is!  Now finish everything in front...</span></span><br><span class="line">               <span class="keyword">final</span> ActivityRecord ret = r;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> (++activityNdx; activityNdx &lt; numActivities; ++activityNdx) {</span><br><span class="line">                   r = mActivities.get(activityNdx);</span><br><span class="line">                   <span class="keyword">if</span> (r.finishing) {</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   }</span><br><span class="line">                   ActivityOptions opts = r.takeOptionsLocked();</span><br><span class="line">                   <span class="keyword">if</span> (opts != <span class="keyword">null</span>) {</span><br><span class="line">                       ret.updateOptionsLocked(opts);</span><br><span class="line">                   }</span><br><span class="line">                   <span class="keyword">if</span> (stack.finishActivityLocked(r, Activity.RESULT_CANCELED, <span class="keyword">null</span>, <span class="string">"clear"</span>,</span><br><span class="line">                           <span class="keyword">false</span>)) {</span><br><span class="line">                       --activityNdx;</span><br><span class="line">                       --numActivities;</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Finally, if this is a normal launch mode (that is, not</span></span><br><span class="line">               <span class="comment">// expecting onNewIntent()), then we will finish the current</span></span><br><span class="line">               <span class="comment">// instance of the activity so a new fresh one can be started.</span></span><br><span class="line">               <span class="keyword">if</span> (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE</span><br><span class="line">                       &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) == <span class="number">0</span>) {</span><br><span class="line">                   <span class="keyword">if</span> (!ret.finishing) {</span><br><span class="line">                       stack.finishActivityLocked(ret, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                               <span class="string">"clear"</span>, <span class="keyword">false</span>);</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> ret;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<p>这里就是根据ID找到等于参数taskId的任务，然后在这个任务中查找是否已经存在即将要启动的Activity的实例，如果存在，就会把这个Actvity实例上面直到任务堆栈顶端的Activity通过调用finishActivityLocked函数将它们结束掉。</p>
<blockquote>
<p>在这里便引出了manifest文件中<activity>的一个重要属性，taskAffinity。在官方文档中可以得到关于taskAffinity的以下信息</activity></p>
</blockquote>
<ul>
<li>taskAffinity表示当前activity具有亲和力的一个任务（原句为The task that the activity has an affinity for.），大致可以这样理解，这个 taskAffinity表示一个任务，这个任务就是当前activity所在的任务。     </li>
</ul>
<blockquote>
<p>在概念上，具有相同的affinity的activity（即设置了相同taskAffinity属性的activity）属于同一个任务。    </p>
</blockquote>
<ul>
<li>一个任务的affinity决定于这个任务的根activity（root activity）的taskAffinity。     </li>
<li>这个属性决定两件事：当activity被re-parent时，它可以被re-paren哪个任务中；当activity以FLAG_ACTIVITY_NEW_TASK标志启动时，它会被启动到哪个任务中。（这个比较 难以理解，请结合<activity>中的属性allowTaskReparenting和Intent中的标志 FLAG_ACTIVITY_NEW_TASK加以理解）</activity></li>
<li>默认情况下，一个应用中的所有activity具有相同的taskAffinity，即应用程序的包名。我们可以通过设置不同的taskAffinity属性给应用中的activity分组，也可以把不同的 应用中的activity的taskAffinity设置成相同的值。<br>为一个activity的taskAffinity设置一个空字符串，表明这个activity不属于任何task。<br>回到前面的startActivityUncheckedLocked函数中，这里的变量top就为null了，于是执行下面的else语句</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-0cc6029d58f8217d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/538/format/webp" alt="代码片段"></p>
<p>所以 此时将addintToTask=true 并且sourceRecord = 我们的activity，再往下看</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r.packageName != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="comment">// If the activity being launched is the same as the one currently</span></span><br><span class="line">    <span class="comment">// at the top, then we need to check if it should only be launched</span></span><br><span class="line">    <span class="comment">// once.</span></span><br><span class="line">    ActivityStack topStack = getFocusedStack();</span><br><span class="line">    ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(notTop);</span><br><span class="line">    <span class="keyword">if</span> (top != <span class="keyword">null</span> &amp;&amp; r.resultTo == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) {</span><br><span class="line">            <span class="keyword">if</span> (top.app != <span class="keyword">null</span> &amp;&amp; top.app.thread != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span></span><br><span class="line">                    || launchSingleTop || launchSingleTask) {</span><br><span class="line">                    ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, top,</span><br><span class="line">                            top.task);</span><br><span class="line">                    <span class="comment">// For paranoia, make sure we have correctly</span></span><br><span class="line">                    <span class="comment">// resumed the top activity.</span></span><br><span class="line">                    topStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (doResume) {</span><br><span class="line">                        resumeTopActivitiesLocked();</span><br><span class="line">                    }</span><br><span class="line">                    ActivityOptions.abort(options);</span><br><span class="line">                    <span class="keyword">if</span> ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) {</span><br><span class="line">                        <span class="comment">// We don't need to start a new activity, and</span></span><br><span class="line">                        <span class="comment">// the client said not to do anything if that</span></span><br><span class="line">                        <span class="comment">// is the case, so this is it!</span></span><br><span class="line">                        <span class="keyword">return</span> ActivityManager.START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">                    }</span><br><span class="line">                    top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                    <span class="keyword">return</span> ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">if</span> (r.resultTo != <span class="keyword">null</span>) {</span><br><span class="line">        r.resultTo.task.stack.sendActivityResultLocked(-<span class="number">1</span>, r.resultTo, r.resultWho,</span><br><span class="line">                r.requestCode, Activity.RESULT_CANCELED, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    ActivityOptions.abort(options);</span><br><span class="line">    <span class="keyword">return</span> ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>根据注释我们能看出这个方法是检查当前任务的顶端是否是我们要启动的activity，接着往下看，便是启动activity</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">boolean</span> newTask = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> keepCurTransition = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    TaskRecord taskToAffiliate = launchTaskBehind &amp;&amp; sourceRecord != <span class="keyword">null</span> ?</span><br><span class="line">            sourceRecord.task : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Should this be considered a new task?</span></span><br><span class="line">    <span class="keyword">if</span> (r.resultTo == <span class="keyword">null</span> &amp;&amp; inTask == <span class="keyword">null</span> &amp;&amp; !addingToTask</span><br><span class="line">            &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (isLockTaskModeViolation(reuseTask)) {</span><br><span class="line">            Slog.e(TAG, <span class="string">"Attempted Lock Task Mode violation r="</span> + r);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">        }</span><br><span class="line">        newTask = <span class="keyword">true</span>;</span><br><span class="line">        targetStack = adjustStackFocus(r, newTask);</span><br><span class="line">        <span class="keyword">if</span> (!launchTaskBehind) {</span><br><span class="line">            targetStack.moveToFront();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (reuseTask == <span class="keyword">null</span>) {</span><br><span class="line">            r.setTask(targetStack.createTaskRecord(getNextTaskId(),</span><br><span class="line">                    newTaskInfo != <span class="keyword">null</span> ? newTaskInfo : r.info,</span><br><span class="line">                    newTaskIntent != <span class="keyword">null</span> ? newTaskIntent : intent,</span><br><span class="line">                    voiceSession, voiceInteractor, !launchTaskBehind <span class="comment">/* toTop */</span>),</span><br><span class="line">                    taskToAffiliate);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_TASKS) Slog.v(TAG, <span class="string">"Starting new activity "</span> + r + <span class="string">" in new task "</span> +</span><br><span class="line">                    r.task);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            r.setTask(reuseTask, taskToAffiliate);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!movedHome) {</span><br><span class="line">            <span class="keyword">if</span> ((launchFlags &amp;</span><br><span class="line">                    (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_TASK_ON_HOME))</span><br><span class="line">                    == (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {</span><br><span class="line">                <span class="comment">// Caller wants to appear on home activity, so before starting</span></span><br><span class="line">                <span class="comment">// their own activity we will bring home to the front.</span></span><br><span class="line">                r.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">final</span> TaskRecord sourceTask = sourceRecord.task;</span><br><span class="line">        <span class="keyword">if</span> (isLockTaskModeViolation(sourceTask)) {</span><br><span class="line">            Slog.e(TAG, <span class="string">"Attempted Lock Task Mode violation r="</span> + r);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">        }</span><br><span class="line">        targetStack = sourceTask.stack;</span><br><span class="line">        targetStack.moveToFront();</span><br><span class="line">        <span class="keyword">final</span> TaskRecord topTask = targetStack.topTask();</span><br><span class="line">        <span class="keyword">if</span> (topTask != sourceTask) {</span><br><span class="line">            targetStack.moveTaskToFrontLocked(sourceTask, r, options);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            mWindowManager.moveTaskToTop(topTask.taskId);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// In this case, we are adding the activity to an existing</span></span><br><span class="line">            <span class="comment">// task, but the caller has asked to clear that task if the</span></span><br><span class="line">            <span class="comment">// activity is already running.</span></span><br><span class="line">            ActivityRecord top = sourceTask.performClearTaskLocked(r, launchFlags);</span><br><span class="line">            keepCurTransition = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (top != <span class="keyword">null</span>) {</span><br><span class="line">                ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);</span><br><span class="line">                top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                <span class="comment">// For paranoia, make sure we have correctly</span></span><br><span class="line">                <span class="comment">// resumed the top activity.</span></span><br><span class="line">                targetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (doResume) {</span><br><span class="line">                    targetStack.resumeTopActivityLocked(<span class="keyword">null</span>);</span><br><span class="line">                }</span><br><span class="line">                ActivityOptions.abort(options);</span><br><span class="line">                <span class="keyword">return</span> ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!addingToTask &amp;&amp;</span><br><span class="line">                (launchFlags&amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// In this case, we are launching an activity in our own task</span></span><br><span class="line">            <span class="comment">// that may already be running somewhere in the history, and</span></span><br><span class="line">            <span class="comment">// we want to shuffle it to the front of the stack if so.</span></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord top = sourceTask.findActivityInHistoryLocked(r);</span><br><span class="line">            <span class="keyword">if</span> (top != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">final</span> TaskRecord task = top.task;</span><br><span class="line">                task.moveActivityToFrontLocked(top);</span><br><span class="line">                ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, task);</span><br><span class="line">                top.updateOptionsLocked(options);</span><br><span class="line">                top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                targetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (doResume) {</span><br><span class="line">                    targetStack.resumeTopActivityLocked(<span class="keyword">null</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// An existing activity is starting this new activity, so we want</span></span><br><span class="line">        <span class="comment">// to keep the new one in the same task as the one that is starting</span></span><br><span class="line">        <span class="comment">// it.</span></span><br><span class="line">        r.setTask(sourceTask, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_TASKS) Slog.v(TAG, <span class="string">"Starting new activity "</span> + r</span><br><span class="line">                + <span class="string">" in existing task "</span> + r.task + <span class="string">" from source "</span> + sourceRecord);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (inTask != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// The calling is asking that the new activity be started in an explicit</span></span><br><span class="line">        <span class="comment">// task it has provided to us.</span></span><br><span class="line">        <span class="keyword">if</span> (isLockTaskModeViolation(inTask)) {</span><br><span class="line">            Slog.e(TAG, <span class="string">"Attempted Lock Task Mode violation r="</span> + r);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">        }</span><br><span class="line">        targetStack = inTask.stack;</span><br><span class="line">        targetStack.moveTaskToFrontLocked(inTask, r, options);</span><br><span class="line">        targetStack.moveToFront();</span><br><span class="line">        mWindowManager.moveTaskToTop(inTask.taskId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check whether we should actually launch the new activity in to the task,</span></span><br><span class="line">        <span class="comment">// or just reuse the current activity on top.</span></span><br><span class="line">        ActivityRecord top = inTask.getTopActivity();</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="keyword">null</span> &amp;&amp; top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) {</span><br><span class="line">            <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span></span><br><span class="line">                    || launchSingleTop || launchSingleTask) {</span><br><span class="line">                ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task);</span><br><span class="line">                <span class="keyword">if</span> ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// We don't need to start a new activity, and</span></span><br><span class="line">                    <span class="comment">// the client said not to do anything if that</span></span><br><span class="line">                    <span class="comment">// is the case, so this is it!</span></span><br><span class="line">                    <span class="keyword">return</span> ActivityManager.START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">                }</span><br><span class="line">                top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                <span class="keyword">return</span> ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!addingToTask) {</span><br><span class="line">            <span class="comment">// We don't actually want to have this activity added to the task, so just</span></span><br><span class="line">            <span class="comment">// stop here but still tell the caller that we consumed the intent.</span></span><br><span class="line">            ActivityOptions.abort(options);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_TASK_TO_FRONT;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        r.setTask(inTask, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_TASKS) Slog.v(TAG, <span class="string">"Starting new activity "</span> + r</span><br><span class="line">                + <span class="string">" in explicit task "</span> + r.task);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// This not being started from an existing activity, and not part</span></span><br><span class="line">        <span class="comment">// of a new task...  just put it in the top task, though these days</span></span><br><span class="line">        <span class="comment">// this case should never happen.</span></span><br><span class="line">        targetStack = adjustStackFocus(r, newTask);</span><br><span class="line">        targetStack.moveToFront();</span><br><span class="line">        ActivityRecord prev = targetStack.topActivity();</span><br><span class="line">        r.setTask(prev != <span class="keyword">null</span> ? prev.task : targetStack.createTaskRecord(getNextTaskId(),</span><br><span class="line">                        r.info, intent, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">true</span>), <span class="keyword">null</span>);</span><br><span class="line">        mWindowManager.moveTaskToTop(r.task.taskId);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_TASKS) Slog.v(TAG, <span class="string">"Starting new activity "</span> + r</span><br><span class="line">                + <span class="string">" in new guessed "</span> + r.task);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName,</span><br><span class="line">            intent, r.getUriPermissionsLocked(), r.userId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span> &amp;&amp; sourceRecord.isRecentsActivity()) {</span><br><span class="line">        r.task.setTaskToReturnTo(RECENTS_ACTIVITY_TYPE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (newTask) {</span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, r.userId, r.task.taskId);</span><br><span class="line">    }</span><br><span class="line">    ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task);</span><br><span class="line">    targetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">    targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</span><br><span class="line">    <span class="keyword">if</span> (!launchTaskBehind) {</span><br><span class="line">        <span class="comment">// Don't set focus on an activity that's going to the back.</span></span><br><span class="line">        mService.setFocusedActivityLocked(r);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ActivityManager.START_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先将newTask变量初始化为false，表示不要在新的任务中启动Activity。由于前面的已经把addingToTask设置为true，因此，这里会执行中间的else if语句，即这里会把r.task设置为sourceRecord.task，即把即将启动的Activity放在原Activity所在的任务中启动。最后，就是调用startActivityLocked函数继续进行启动Activity的操作了</p>
<p>声明： 以上内容拷贝自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/09365022adac">简书作者jiantao的文章，供自己学习使用</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/04/06/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC22%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/06/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC22%E7%AB%A0/" class="post-title-link" itemprop="url">第22章：插件化技术总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-06 21:52:00" itemprop="dateCreated datePublished" datetime="2021-04-06T21:52:00+08:00">2021-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 10:13:41" itemprop="dateModified" datetime="2022-06-08T10:13:41+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>这章是重新梳理插件化技术的整体思路</p>
<h2 id="插件的工程化"><a href="#插件的工程化" class="headerlink" title="插件的工程化"></a>插件的工程化</h2><p>插件化技术分为宿主App 和 插件Plugin1这两个 apk，有时候还有 MyPluginLibrary ，宿主和插件都要引用它。</p>
<h2 id="加载插件中的类"><a href="#加载插件中的类" class="headerlink" title="加载插件中的类"></a>加载插件中的类</h2><p>宿主App 想要使用 Plugin1 中的类，还使用 宿主App 中的 ClassLoder 是不行的，由此缠身很多种解决方案：</p>
<ul>
<li>最直接的就是，在反射插件中的类时，使用 Plugin1.apk 对应的 ClassLoader (参考第6章)    </li>
<li>无论是宿主还是插件，他们各自的 ClassLoader 都对应一个 dex 数组，把这些插件的dex数组都合并到宿主的 dex 数组中，那么，宿主App就可以加载任何类(参考9.3节)。     </li>
<li>自定义一个ClassLoader，取代原先宿主的ClassLoader 。同时在自定义的 ClassLoader 中放一个集合，承载所有插件的 ClassLoader 。那么自定义的 ClassLoader 在加载任何一个类的时候，无论是插件还是宿主的类，都会现在宿主中找，如果没有，再遍历 ClassLoader 集合，看哪个 ClassLoader 能加载这个类(参考9.36节)。    </li>
</ul>
<h2 id="哪些地方可以Hook"><a href="#哪些地方可以Hook" class="headerlink" title="哪些地方可以Hook"></a>哪些地方可以Hook</h2><p>关于Hook 的技术可以参考第4章，Hook可以分为三类：</p>
<ul>
<li>在 App 中使用的类，可以Hook。Android 系统源码中被标记为hide的方法和类，<strong>我们可以通过反射使用它们，但是不能Hook</strong>。还有一些类，比如 Instrumentation 和 Callback ，在App中也能用，因此可以Hook替换。             </li>
<li>实现了接口的类，可以Hook。虽然大部分类和方法都标记为hide，但是<strong>只要合格类实现了一个接口，我们就可以借助 Proxy.newProxyInstance 方法去截获它的方法</strong>，比较典型的是 IActivityManager 接口，以及实现这个接口的 AMN 。    </li>
<li>集合。 没办法Hook一个标记为hide 的类，但是如果Android源码中某个类<strong>拥有集合变量的时候，我们可以反射构造出一个对象，然后还是通过反射添加到这个集合中</strong>。典型的是，穿件一个 LoadedApk ，把它事先放在 mPackages 缓存中，这样就能直接命中缓存(参考9.2节)。</li>
</ul>
<h2 id="Activity-的插件化解决方案"><a href="#Activity-的插件化解决方案" class="headerlink" title="Activity 的插件化解决方案"></a>Activity 的插件化解决方案</h2><p>从大方向来讲，分为动态替换和静态代理两种：</p>
<ul>
<li>动态替换：这是“占位”思想。宿主App中声明一个用于占位的 StubActivity ，启动插件中的ActivityA，但是告诉AMS启动的是 StubActivity ，欺骗成功之后，在即将启动Activity时，再把 StubActivity 换回 ActivityA(参考第9章)。      </li>
<li>静态代理。这是一种牵线木偶的思想，在宿主App中设计一个 ProxyActivity ，由他来决定启动插件中的哪个 Activity。<strong>插件中的Activity都是没有生命的，得在ProxyActivity 生命周期中，调用插件Activity 的生命周期函数</strong>(参考9.5节)。</li>
</ul>
<p>此外，还需要解决 LaunchMode 问题，解决方案参考 9.5 节。</p>
<h2 id="资源的解决方案"><a href="#资源的解决方案" class="headerlink" title="资源的解决方案"></a>资源的解决方案</h2><p>资源主要为Activity 服务。主要有两种解决方案：</p>
<ul>
<li>进入Plugin1 ，则加载Plugin1的资源，反射调用 AssetManager 的 addAssetPath 方法，参数是 Plugin1.apk 的路径。每次进入或者离开插件，都要切换资源。这是一件很繁琐的事情(参考第7章)。      </li>
<li>事先把 宿主App的资源以及所有插件的资源都通过 AssetManager 的 addAssetPath 方法添加到一个全局变量中。这样，在插件 Activity 的基类中，重写 Activity 的 getResource 方法，从这个全局变量中提取资源。</li>
</ul>
<p>针对方案2，由于资源合并到一起，就可能发生资源id冲突，由此产生多种解决方案：</p>
<ol>
<li>修改aapt，更改id的前缀(参考15.2节)    </li>
<li>修改resources.arsc，在 aapt 执行完成后，修改生成的文件(参考21章)    </li>
<li>通过 public.xml 固定 plugin1 中所有的资源。这种方案不现实，针对固定一个资源的id还是很好的解决方案。</li>
</ol>
<h2 id="Fragment是哪个门派"><a href="#Fragment是哪个门派" class="headerlink" title="Fragment是哪个门派"></a>Fragment是哪个门派</h2><p>Fragment 与Activity 的最大区别，就是后者的一举一动需要和 AMS 交互，而Fragment不用。这种方案整个应用只有一个Activity ，Fragment 可以在 宿主App 中或者 插件中，只要使用合适的 ClassLoader 加载插件中的类，使用合适的 AssetManager 加载插件中的资源，就是一个完美的解决方案。可以参考 16 章。</p>
<h2 id="Service、ContentProvider-和-BroadcastReceiver-插件化通用方案"><a href="#Service、ContentProvider-和-BroadcastReceiver-插件化通用方案" class="headerlink" title="Service、ContentProvider 和 BroadcastReceiver 插件化通用方案"></a>Service、ContentProvider 和 BroadcastReceiver 插件化通用方案</h2><p>因为这三者的数量并不多，插件化中也不会动态新增一个组件，所以最简单的方案是：在 宿主App 的 AndroidManifest 文件中事先声明这些组件。缺点是不能动态新增一个组件。参考 8.1节。</p>
<h2 id="特定于Service-的插件化解决方案"><a href="#特定于Service-的插件化解决方案" class="headerlink" title="特定于Service 的插件化解决方案"></a>特定于Service 的插件化解决方案</h2><p>如果不事先在宿主App中声明插件的Service，那么Service 也有自己的解决方案：</p>
<ul>
<li>动态代理。也是欺上瞒下的思路。Service 不同于 Activity ，一个StubActivity 可以对应多个插件Activity，但是StubService 和插件Service 只能一一对应，所以应该在 宿主App 中声明多个 StubService。参考第10章。</li>
<li>静态代理，牵线木偶思想。创建一个ProxyService，由 ProxyService 来启动插件中的Service，缺点是插件中有几个Service，宿主App 中就要有相同数量的 ProxyService。，参见 14.1和 14.2.</li>
<li>结合前两种，能否在 宿主App中只声明一个Stubservice。参考 14.4</li>
</ul>
<h2 id="特定于BroadcastReceiver-的插件化解决方案"><a href="#特定于BroadcastReceiver-的插件化解决方案" class="headerlink" title="特定于BroadcastReceiver 的插件化解决方案"></a>特定于BroadcastReceiver 的插件化解决方案</h2><p>它的插件化解决方案是把静态的Receiver 转换为动态的Receiver。</p>
<h2 id="特定于ContentProvider-的插件化解决方案"><a href="#特定于ContentProvider-的插件化解决方案" class="headerlink" title="特定于ContentProvider 的插件化解决方案"></a>特定于ContentProvider 的插件化解决方案</h2><p>占位思想。宿主App 中由 StubContentProvider 来欺骗 AMS，而实际执行的是 插件中的 ContentProvider 。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/04/06/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC15%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/06/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC15%E7%AB%A0/" class="post-title-link" itemprop="url">第15章：再谈资源</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-06 21:29:00 / 修改时间：22:05:51" itemprop="dateCreated datePublished" datetime="2021-04-06T21:29:00+08:00">2021-04-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Android-App-打包流程"><a href="#Android-App-打包流程" class="headerlink" title="Android App 打包流程"></a>Android App 打包流程</h2><p>早期Android打包都是基于Ant来做，为此我们需要熟悉Android App 打包的每一个过程。随着Gradle的问世，打包简化为几行配置代码。一套完整的Android App 打包流程如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8C%87%E5%8D%97/%E7%AC%AC15%E7%AB%A0/Android%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B.png" alt="Android打包流程图"></p>
<p>介绍下各部分的作用：</p>
<ul>
<li>aapt： 为res目录下的资源生成 R.java 文件，<strong>同时为AndroidManifest生成Manifest.java文件</strong>     </li>
<li>aidl： 把项目中自定义的aidl文件生成相应的java代码文件    </li>
<li>javac： 把项目中所有的Java 代码编译成 class 文件。包括3部分： 自己写的代码；aapt生成的代码；aidl生成的Java文件    </li>
<li>proguard： 混淆的同时生成proguardMapping.txt，这个步骤是可选的    </li>
<li>dex： 把所有的class文件(包括第三方库的class 文件)转换为dex文件      </li>
<li>aapt： 这里还是使用aapt，这里是它的另一个功能：打包。即将res目录下的资源、assets下的文件，打包成一个 .ap_ 文件     </li>
<li>apkbuilder：将所有的dex、ap_文件、AndroidManifest.xml 打包为.apk文件，此时未签名       </li>
<li>jarsigner： 签名    </li>
<li>zipalign： 对齐，以便运行时节省内存           </li>
</ul>
<h2 id="资源冲突解决方案一：修改AAPT"><a href="#资源冲突解决方案一：修改AAPT" class="headerlink" title="资源冲突解决方案一：修改AAPT"></a>资源冲突解决方案一：修改AAPT</h2><p>插件中的资源id可能会和宿主资源id是同一个值，为了解决资源id冲突，有3中解决方案：</p>
<ul>
<li>修改打包流程中的aapt命令，为插件资源id指定 0x71 之类的前缀，就可以避免冲突     </li>
<li>仍然是将插件资源的id前缀改为 0x71，但是在Android打包生成 resources.arsc 文件后，对这个文件进行修改(具体可见21.2节)       </li>
<li>进入到哪个插件，就为这个插件生成新的 AssetManager 和 Resources 对象，使用这两个新对象加载资源，就只能是插件中的资源，永远不会和宿主中冲突(详见 7.2)</li>
</ul>
<h3 id="修改并生成新的aapt命令"><a href="#修改并生成新的aapt命令" class="headerlink" title="修改并生成新的aapt命令"></a>修改并生成新的aapt命令</h3><p>R文件中有十六进制整数变量，内容如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码</span></span><br></pre></td></tr></tbody></table></figure>

<p>这些十六进制的变量，由三部分组成： packageId(apk包id，默认 0x7f) + typeId(资源类型，如attr=0x01，drawable=0x02，还有layout、string等) + entryId(typeId下的资源编码，从0开始递增)。以 0x7f0b006d 为例，packageId 为 0x7f，typeId为 0b，entryId 为 006d。</p>
<p>插件中为防止资源冲突，会为每个插件设置不同的packageId，比如游戏大厅中，斗地主插件可能是 0x71开头，斗牛可能是 0x72。为asset 生成 R 文件 是通过 aapt 完成的，为了实现上述目的，我们要修改 aapt 源码，定位到 Android SDK，找到 aapt 目录，里面有一堆 C 代码， 命令行工具就是用这些代码编译成的，可以在这个目录直接搜索 0x7f，在 ResourcesTable.cpp 中可以找到如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br></pre></td></tr></tbody></table></figure>

<p>在 ResourcesTable 的构造函数中，有一个 Bundle 类型的参数，其次，判断 mPackageType 如果是 App，则都是 0x7f，此外 0x01 和 0x00 都被系统占用了，所以我们不要将这两个值设置为插件的 id前缀(事实上，有些手机厂商会占用其他的一些值，为了保险，我们一般只使用 0x71~0xff 作为插件的前缀)。修改 AAPT 的代码，基本思路如下：</p>
<ol>
<li>在 aapt 的命令行参数中传递打包时的前缀   </li>
<li>把这个值设置给 Bundle 实体的 mApkModule 字段，作为 ResourcesTable 的构造函数参数传入        </li>
<li>在 ResourcesTable 构造函数读取 mApkModule 值，也就是前缀值，设置给 packageId    </li>
</ol>
<p>实现代码： 略</p>
<h3 id="在插件化项目中使用新的aapt命令"><a href="#在插件化项目中使用新的aapt命令" class="headerlink" title="在插件化项目中使用新的aapt命令"></a>在插件化项目中使用新的aapt命令</h3><p>现在，可以用我们修改的aapt文件替换sdk下的aapt 命令，但是如果这么做，每当Android系统更新，我们都要替换一次aapt命令。一种可行的做法是，我们把这个新的 aapt 工具命名为 aapt_mac ，放到项目的根目录下：</p>
<p><img src="" alt="自定义的aapt放置"></p>
<p>之后，修改项目中 gradle 文件：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>上述脚本通过反射，<strong>把aapt的路径临时修改为指向当前App根目录下的aapt_mac</strong>。此外，我们将App的资源前缀设置为 0x71 ，这样在打包后，R文件中的资源就以 0x71 作为前缀了。</p>
<h2 id="public-xml-固定资源id值"><a href="#public-xml-固定资源id值" class="headerlink" title="public.xml 固定资源id值"></a>public.xml 固定资源id值</h2><p>如下场景：多个插件都需要<strong>同一个</strong>自定义控件，于是我们把这个自定义控件卸载宿主 App，插件调用宿主的Java 代码，使用宿主的资源(有控件肯定有资源)。考虑到App在每次打包后，随着资源的增减，同一个资源id的值可能会发生变化。为避免这种情况，我们可以<strong>把公用的资源id值固定写死</strong>，如下public.xml文件所示（注意，type和id后面的空格不可省略）：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"&gt;</span></span><br><span class="line"><span class="meta">&lt;resources&gt;</span></span><br><span class="line"><span class="meta">    &lt;public type="string" name="string1" id="0x7f050024"/&gt;</span></span><br><span class="line"><span class="meta">&lt;/resources&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>之后，把public.xml放到 res/values 目录下，R.string.string1 这个资源就会固定成 0x7f050024。当然，还可以指定资源值的一个区间,将上述代码中间那行改成如下代码即可：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">public-padding</span> <span class="attr">name</span>=<span class="string">"my_"</span> <span class="attr">end</span>=<span class="string">"0x7f02000f"</span> <span class="attr">start</span>=<span class="string">"0x7f020001"</span> <span class="attr">type</span>=<span class="string">"drawable"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是从gradle 1.3开始，就忽略 public.xml了，因此需要我们自己使用gradle 脚本来实现，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>之后，打包宿主 ActivityHost1 ，使用Jadx-GUI 查看资源id，可以看到 R.string.string1 的值永远是 2131034148(也即十六进制0x7f050024)。</p>
<h2 id="插件使用宿主的资源"><a href="#插件使用宿主的资源" class="headerlink" title="插件使用宿主的资源"></a>插件使用宿主的资源</h2><p>宿主资源值固定了，但是插件怎么访问宿主中的资源呢？如果插件内部能保持一个对宿主项目的引用，那就可以随便访问宿主的任何资源了。<strong>我们需要编写gradle脚本，把宿主打包成 jar 包。之后设置插件的gradle文件，通过provided来引用这个jar包</strong>。之前介绍过，provided方式引用只在编码时候有用，正式打包的时候不会被引用进去。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章给出插件化中资源id冲突的解决方案：</p>
<ul>
<li>把宿主和插件的资源都合并到一起，通过AssetManager的addAssetPath 来实现。只不过，<strong>这种方案会产生资源id冲突的问题</strong>      </li>
<li>如果不事先合并资源，那就为每个插件创建一个 AssetManager，每个 AssetManager 都是通过反射调用 addAssetPath 方法，把插件资源加进去。当宿主进入一个插件时，就把 AssetManager 切换为 插件的AssetManager ；反之，当从插件回到宿主的时候，再把 AssetManager 切换回宿主的 AssetManager(详见第5章的loadResource方法)。</li>
</ul>
<p>第一种方案，主要缺陷是资源冲突，并且资源id的前缀是有限的，也就256个值，如果超过256个插件，就要使用方案2了。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/03/28/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC12%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/28/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC12%E7%AB%A0/" class="post-title-link" itemprop="url">第12章：ContentProvider的插件化解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-28 17:29:00 / 修改时间：17:43:57" itemprop="dateCreated datePublished" datetime="2021-03-28T17:29:00+08:00">2021-03-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="ContentProvider基本概念"><a href="#ContentProvider基本概念" class="headerlink" title="ContentProvider基本概念"></a>ContentProvider基本概念</h2><p>ContentProvider 就是一个SQLite 数据库，数据提供方A和数据使用方B是通过<strong>匿名共享内存</strong>来传输数据的。B告诉A，“你把数据写在这个内存地址上”；B准备好数据，写到A要求的内存地址上，A就可以直接使用这些数据了。当数据量非常大的时候，这个数据传递速度是非常快的。</p>
<p>并不是所有数据传递都需要ContentProvider，比如，Activity 跳转时，数据的传递就用的 Binder，一般来说，传输的数据量不超过 1 M 时，使用Binder；否则，此时需要ContentProvider 。</p>
<h2 id="ContentProvider-插件化"><a href="#ContentProvider-插件化" class="headerlink" title="ContentProvider 插件化"></a>ContentProvider 插件化</h2><p>前面介绍了 BroadCastReceiver 的插件化解决方案，即把插件中的静态广播都转换为动态广播，然后手动注册到宿主App的广播中。</p>
<p>其实，ContentProvider 也能这么做，这时候不叫“注册”，而叫“安装”。安装当前Apk中所有的ContentProvider 的方法位于 ActivityThread 的 installContentProviders方法中：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码略</span></span><br></pre></td></tr></tbody></table></figure>

<p>我么你只需要手动执行这个方法，把插件中的ContentProvider 集合作为第二个参数填进去即可。如此一来，我们得到了ContentProvider 插件化的解决方案：</p>
<ol>
<li>沿用Activity插件化的第二种方案，将宿主App和插件App的dex合并到一起     </li>
<li>借助PackageParse的parsePackage方法，读取插件中的ContentProvider信息，然后把得到的Package对象转换为我们需要的 ProviderInfo类型对象     </li>
<li>将ContentProvider 的packageName 设置为当前apk的packageName，之后把插件中的 ContentProvider 放入宿主中     </li>
<li>通过反射执行 ActivityThread 的 installContentProviders 方法，把ContentProvider 作为插件的参数，相当于把插件 ContentProvider “安装” 到宿主App中     </li>
</ol>
<h2 id="执行这段Hook代码的时机"><a href="#执行这段Hook代码的时机" class="headerlink" title="执行这段Hook代码的时机"></a>执行这段Hook代码的时机</h2><p>ContentProvider 这个组件，往往是提供给外界使用的，如果插件中的ContentProvider 还没安装到宿主App中，第三方就来调用了，那就要等很久了，所以安装插件 ContentProvider 的过程越早越好。<strong>App安装自身的 ContentProvider 是在ActivityThread 执行 installContentProviders 方法中，这个方法比Application 的onCreate 要早，但是会晚于 Application 的 attachBaseContent 方法，所以，我们可以在 attachBaseContent 方法中，手动执行 ActivityThread 的 installContentProviders</strong> 。</p>
<h2 id="ContentProvider-的转发机制"><a href="#ContentProvider-的转发机制" class="headerlink" title="ContentProvider 的转发机制"></a>ContentProvider 的转发机制</h2><p>让外界App直接调用当前App的插件里定义的ContentProvider ，并不是理想的解决方案。最好的是在宿主App中定义一个 StubContentProvider 作为中转，让外界调用当前App的 StubContentProvider ，然后在 StubContentProvider 中再调用插件里的 ContentProvider：</p>
<p><img src="/assets/Book-Notes/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8C%87%E5%8D%97/%E7%AC%AC12%E7%AB%A0/ContentProvider%E6%8F%92%E4%BB%B6%E5%8C%96%E5%88%86%E5%8F%91%E6%80%9D%E6%83%B3.png" alt="ContentProvider插件化分发思想"></p>
<p>ContentProvider 插件化的精髓在于分发，外界使用 App 提供的 ContentProviderA 时，只知道发送给一个宿主AndroidManifest 中声明锅的 ContentProviderA，而受到请求后，再做二次转发。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/03/28/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC11%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/28/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC11%E7%AB%A0/" class="post-title-link" itemprop="url">第11章：BroadcastReceiver的插件化解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-28 11:41:00 / 修改时间：17:03:38" itemprop="dateCreated datePublished" datetime="2021-03-28T11:41:00+08:00">2021-03-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Receiver概述"><a href="#Receiver概述" class="headerlink" title="Receiver概述"></a>Receiver概述</h2><p>Receiver分为动态和静态两种，简单讨论下区别：</p>
<ul>
<li>静态广播在 AndroidManifest 中注册，因为Android系统重启时，PMS都会解析App中的AndroidManifest，所以<strong>静态广播都存在于 PMS 中</strong>      </li>
<li>动态广播通过 Context 的registerReceiver 方法最终调用 AMN.getDefault().registerReceiver 方法，所以，<strong>动态广播的注册信息存在于 AMS 中</strong>       </li>
</ul>
<p>除了注册方式不一样，后续发送和接收的过程就一样了。整个过程简单如下：1、Context 发送广播，最终通过 AMN.getDefault().broadcastIntent，把要发送的广播告诉AMS。2、AMS收到消息后，根据intent-filter 筛选 PMS 和 AMS (即静态广播和动态广播)中符合条件的接收器，通知App进程启动这些广播(调用这些广播的 onReceive)。</p>
<h2 id="动态广播的插件化解决方案"><a href="#动态广播的插件化解决方案" class="headerlink" title="动态广播的插件化解决方案"></a>动态广播的插件化解决方案</h2><p>对于动态广播，我们只需要确保宿主App能加载插件中的这个动态广播类就行(因为这里并不需要直接与AMS打交道，只是个类而已)。通过9.3节的dex合并技术，就能做到了。</p>
<h2 id="静态广播解决方案"><a href="#静态广播解决方案" class="headerlink" title="静态广播解决方案"></a>静态广播解决方案</h2><p>静态广播无法像Activity那样，即使没在AndroidManifest 中注册也能生效，因为无论是注册还是发送广播，都必须有 IntentFilter，其中的action是可以随意设置的，所以我们对于 Receiver 压根就不能通过类似 Activity 的插桩方式。只有另辟蹊径。</p>
<h3 id="静态广播当做动态广播处理"><a href="#静态广播当做动态广播处理" class="headerlink" title="静态广播当做动态广播处理"></a>静态广播当做动态广播处理</h3><p>具体分为两步：</p>
<ol>
<li>PMS 只能读取宿主 App 的AndroidManifest 文件，读取其中的静态广播并注册。我们可以反射，手动控制PMS读取插件AndroidManifest 中声明的静态广播列表。     </li>
<li>遍历这个静态广播列表，使用 classLoader 加载列表中每个广播类，实例化成一个对象，<strong>然后作为动态广播注册到AMS中</strong>           </li>
</ol>
<h3 id="静态广播的插件化终极解决方案"><a href="#静态广播的插件化终极解决方案" class="headerlink" title="静态广播的插件化终极解决方案"></a>静态广播的插件化终极解决方案</h3><p>上述静态广播当做动态广播的方案，这丧失了静态广播的特性——不需要启动App就可以启动一个静态广播。所以我们仍要探寻如何不启动App也能和插件中的静态广播通信。</p>
<p>回忆一下前面介绍的Activity 和 Service 插件化的占位思想：</p>
<ul>
<li>Activity 只需要一个占位 StubActivity 就能面对大部分插件Activity了，对于LaunchMode 的其他三种形式，则需要更多的占位 StubActivity 应对     </li>
<li>Service 也需要占位 StubService ，但是一个 StubService 只能对应一个插件中的Service，所以我们需要在宿主App中占位多个 StubService，通过json来配置映射关系。    </li>
</ul>
<p>如果也用占位的思想，每个静态广播需要携带一个或者多个Action，StubReceiver 也不例外，如果 StubReceiver 和插件中的静态广播是一对多的关系，那么从外界发送一个广播到App，<strong>就会触发插件中的所有静态广播</strong>。由此得出：<strong>StubReceiver 和插件中的广播只能是一对一的关系</strong>。</p>
<p>不过，我们可以为一个广播设置多个Action，这样我们就不需要预先创建很多个StubReceiver用来面对插件中的静态广播了，只需要一个 StubReceiver ，为它配置很多个 action 即可。这样，插件中的静态广播就要和这些 action 建立一对一的关系，还是以前的思路，使用<strong>Json配置映射关系就行</strong>。</p>
<p>还有，AndroidManifest 中<strong>支持为每个组件配置 metadata</strong>，利用这个特性，为插件中每个静态广播配置对应的 StubReceiver 中的 action ，如下所示：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyReceiver"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">baobao/</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"oldAction"</span> <span class="attr">android:value</span>=<span class="string">"jianqiang1"</span>&gt;</span><span class="tag">&lt;/<span class="name">meta-data</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyReceiver2"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span> &gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"baobao2"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"oldAction"</span> <span class="attr">android:value</span>=<span class="string">"jianqiang2"</span>&gt;</span>&lt;/meta-data&gt; </span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>解析插件中的 AndroidManifest 文件，可以借助11.3章节介绍的ReceiverHelper 类的 preLoadReceiver 方法，在遍历插件中的每个静态的 Receiver 时，去除Receiver 的metadata 数据，根据oldAction值，对应到Receiver，比如 MyReceiver 对应 jianqiang1，MyReceiver2 对应 jianqiang2 。</p>
<p>之后，把插件中的Receiver 手动注册为动态广播。宿主中定义的<strong>StubReceiver占位广播的作用是分发</strong>。</p>
<p>这就解决了静态广播的问题，<strong>我们可以在App没启动的时候，就启动插件中的静态广播</strong>(我其实还是没看懂怎么在没有启动App的情况，就能启动这个静态广播，后续长丝下)。美中不足的是，这个StubReceiver 需要配置很多个 Action 。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/03/27/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC10%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC10%E7%AB%A0/" class="post-title-link" itemprop="url">第10章：Service的插件化解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-27 21:29:00" itemprop="dateCreated datePublished" datetime="2021-03-27T21:29:00+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 22:16:28" itemprop="dateModified" datetime="2021-03-29T22:16:28+08:00">2021-03-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Android界的荀彧和荀攸：Service和Activity"><a href="#Android界的荀彧和荀攸：Service和Activity" class="headerlink" title="Android界的荀彧和荀攸：Service和Activity"></a>Android界的荀彧和荀攸：Service和Activity</h2><p>根据Context的族谱，Service 是 Activity 的叔叔，结合作用来看，二者有太多相似，但是备份不同，类似三国时期的荀彧和荀攸。不过，二者的区别也挺明显：</p>
<ul>
<li>Activity 是面向用户的，有大量的用户交互的方法，而Service 是后台运行的，生命周期函数很少    </li>
<li>Activity 中有LaunchMode 的概念，每个Activity启动时都会放在栈顶，根据不同的 LaunchMode 可能会有复用以前的实例或者不复用以前的实例。但是Service不同，<strong>同一个 Service 调用多次startService并不会启动多个实例，只会有一个实例</strong>，所以，只用一个StubActivity 是应付不了多个插件的Service 的     </li>
<li>ActivityThread 最终通过Instrumentation 启动一个Activity。而ActivityThread 启动Service 并不借助于 Instrumentation ，而是直接把Service 反射出来就启动了    </li>
</ul>
<p>注意一点，Service 有两种形式： 由 startService 启动的服务；由 bindService 绑定的服务。二者的区别在于：startService 以及对应的 stopService ，就是简单地启动和停止 Service ；bindService 执行时会传递一个 ServiceConnection 对象给 AMS ，接下来 Service 在执行 onBind 时，可以把生成的 binder 对象返回给 App 调用端，这个值存于 ServiceConnection 对象的 onServiceConnected 回调函数的第二个参数中。       </p>
<h2 id="预先占位"><a href="#预先占位" class="headerlink" title="预先占位"></a>预先占位</h2><p>前面说过，Service 与 Activity 不一样，它只会存在一个实例，所以只用一个StubService 是应付不了多个插件Service 的。考虑到在绝大部分App中Service 数据不会超过10个，所以我们完全可以在宿主App 中创建 10 个 StubService ，StubService1，StubService2…StubService10 ，每个 StubService 只对应插件中的一个Service，如下图：</p>
<p><img src="/assets/Book-Notes/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8C%87%E5%8D%97/%E7%AC%AC10%E7%AB%A0/StubService%E5%8D%A0%E4%BD%8D%E7%A4%BA%E6%84%8F.png" alt="StubService占位示意"></p>
<p>接下来就是让每个插件Service匹配一个宿主中的 StubService 了，有两种匹配方式：</p>
<ul>
<li>服务器下发一个 JSON 字符串，给出二者的一一对应关系     </li>
<li>在每个插件 App 的 assets 目录中，创建一个 plugin_config 配置文件，把这个 JSON 字符串放进去</li>
</ul>
<p>第2种做法更自然，不需要和服务器交互，json文件解析类似如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String strJson = Utils.readZipFileString(dexFile.getAbsolutePath(), <span class="string">"assets/plugin_config.json"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strJson == <span class="keyword">null</span> || TextUtils.isEmpty(strJson)) {</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">JSONObject jobject = <span class="keyword">new</span> JSONObject(strJson.replaceAll(<span class="string">"\r|\n"</span>, <span class="string">""</span>));</span><br><span class="line">JSONArray jsonArray = jobject.getJSONArray(<span class="string">"plugins"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; jsonArray.length(); i++) {</span><br><span class="line">    JSONObject jsonObject = (JSONObject) jsonArray.get(i);</span><br><span class="line">    UPFApplication.pluginServices.put(</span><br><span class="line">        jsonObject.optString(<span class="string">"PluginService"</span>),</span><br><span class="line">        jsonObject.optString(<span class="string">"StubService"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们将 JSON 转化为一个 HashMap ，<strong>以插件的类名作为key，以宿主的替身作为value</strong>，这个HashMap 存放在宿主App 的 UPFApplication 的 plutinServices 中，是一个全局变量。</p>
<h2 id="startService-的解决方案"><a href="#startService-的解决方案" class="headerlink" title="startService 的解决方案"></a>startService 的解决方案</h2><p>Service 的插件化机制和Activity 很像，因为它们是亲戚。我们首先从简单的startService 和 stopService 的插件化做起。</p>
<p>首先，把插件和宿主的dex合并，之前有封装过 BaseDexClassLoaderHookHelper 类，合并后才能随心所欲加载类；其次，采用“欺骗AMS”方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即 Hook AMN 的 gDefault，它是一个Singleton 对象，之后创建它的代理对象 MockClass1 ，然后替换这个字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//之后，再Hook 到 Handler 类型的 H 类的 mCallback 字段，替换为 MockClass2</span></span><br></pre></td></tr></tbody></table></figure>

<p>主要流程分析一下：</p>
<ol>
<li><p>Hook AMN，让 AMS 启动 StubService，这次要拦截的是 startServcie 和 stopService 这两个方法(也即在AMN中就拦截这两个方法，将要操作的目标Service替换成相应的StubService)。不过，这次不再需要把 Intent 缓存了，因为有了 UPFApplication 中的 plutinServices ，我们可以根据插件 Service 找到对应的 StubService，也可以根据 StubService 反向找到 Service</p>
</li>
<li><p>AMS 被“欺骗”之后，它原本会通知App启动StubService，而我们要Hook掉ActivityThread 的 mH 对象的 mCallback 对象，仍然截获它的 handleMessage 方法，只不过这次截获的是 “CREATE_SERVICE” 分支，这个分支执行 ActivityThread 的 handleCreateService 方法。在 handleCreateService 中，并不能获取到 App 发送给 AMS 的 Intent，AMS 要启动那个Service ，这个信息是存在 handleCreateService 方法的 dat 参数中，是 CreateServiceData 类型的。Android系统的实现如下：   </p>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span> <span class="params">(CreateServiceData data)</span> </span>{ </span><br><span class="line">    LoadedApk packageinfo = getPackageinfoNoCheck(data.info.applicationinfo, data.compatInfo);</span><br><span class="line">    Service service = <span class="keyword">null</span>; </span><br><span class="line">    java.lang.ClassLoader cl= packageinfo.getClassLoader(); </span><br><span class="line">    service = (Service) cl.loadClass(data.info.name).newinstance(); </span><br><span class="line">    <span class="comment">//省略无关代码</span></span><br><span class="line">    service . onCreate ();</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码中，data.info.name 就是Service 的名称，<strong>所以我们只需要将这个值 Hook 为插件的Service即可</strong>。至此，一个支持 startService 的插件化框架就完成了。</p>
<h2 id="bindService-的解决方案"><a href="#bindService-的解决方案" class="headerlink" title="bindService 的解决方案"></a>bindService 的解决方案</h2><p>有了前面的基础，Service 的 bind 与 unbind 就非常简单了，只要在 AMN 的Hook 中添加一个分支，在 “bindService” 的时候 “欺骗AMS” 就行：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (”bindService”.equals(method . getName())) { </span><br><span class="line">    <span class="comment">//找到参数里面的第一个 Intent 对象</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (inti= <span class="number">0</span>; i &lt; args . length ; i++) { </span><br><span class="line">        <span class="keyword">if</span> (args [i) <span class="keyword">instanceof</span> Intent) { </span><br><span class="line">            index = i ; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Intent rawintent = (Intent) args[index); </span><br><span class="line">    String rawServiceName = rawintent.getComponent().getClassName(); </span><br><span class="line">    String stubServiceName = UPFApplication.pluginServces.get(rawServiceName)</span><br><span class="line">    <span class="comment">//替换 Plugin Service of StubService </span></span><br><span class="line">    ComponentName componentName =<span class="keyword">new</span> ComponentName(stubPackage, stubServiceName); </span><br><span class="line">    Intent newintent = <span class="keyword">new</span> Intent(); </span><br><span class="line">    newintent.setComponet(componentName);</span><br><span class="line">    <span class="comment">//替换 Intent ，欺骗 AMS</span></span><br><span class="line">    args[index] = newintent ; </span><br><span class="line">    Log.d(TAG, ” hook success <span class="string">"); </span></span><br><span class="line"><span class="string">    return method.invoke(mBase , args);</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个过程就完成了，接下来就是使用：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unbind</span></span><br><span class="line">btnBind.setOnClickListener(<span class="keyword">new</span> View.OnclickListener(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> Intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"jianqiang.com.testservice1"</span>), <span class="string">"jianqiang.com.testservice1.MyService2"</span>);</span><br><span class="line">        bindService(intent, conn, Service.BIND_AUTO_CREATE);</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">//unbind</span></span><br><span class="line">btnUnbind.setOnClickListener(<span class="keyword">new</span> View.OnclickListener(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{</span><br><span class="line">        unbindService(conn);</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>看了上面的使用方法，可能会有疑惑了：</p>
<ul>
<li>上半场，对于unbind行为，为什么不像bind一样在 unbind 的时候做“欺骗AMS”？    </li>
<li>下半场，为什么不用在MockClass2中写代码，把StubService2 换回 MyService2？        </li>
</ul>
<p>关于第一个问题，因为我们 unbind 的语法是这样的 <em>unbindService(conn)</em> ，只需要一个 ServiceConnection 类型的参数 conn 即可，这个 conn 在前面的bindService 时用到了，<strong>AMS 会根据这个conn 来找到对应的Service，所以并不需要在unbind的时候去做欺骗</strong>。</p>
<p>第二个问题，这要从Android 系统源码说起，bindService 过程在 AMS通知 App 下半场的流程图如下所示：</p>
<p><img src="/assets/Book-Notes/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8C%87%E5%8D%97/%E7%AC%AC10%E7%AB%A0/bindService%E8%BF%87%E7%A8%8BAMS%E9%80%9A%E7%9F%A5App%E8%BF%99%E4%B8%8B%E5%8D%8A%E5%9C%BA.png" alt="bindService过程AMS通知App这下半场"></p>
<p>也就是说，bindService 先走114(handleCreateSrvice)分支，再走 121 (handleBindService) ，在 handleCreateSrvice 中已经把我们要启动的 MyService2 放到了 mService 这个集合中了，那么，在 handleBindService 和 handleUnbindService 中，都会从 mService 集合中找到 Service2 。在之前章节，为了解决 createService ，已经拦截了 114 分支把 StubService2 换回了 MyService2 了，所以我们不需要要拦截 121 和 122 了， 无需再MockClass2 添加额外代码。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里给出Service第一种解决方案——预先占位，在宿主中预先声明若干个StubService。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/03/27/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC9%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC9%E7%AB%A0/" class="post-title-link" itemprop="url">第9章：Activity的插件化解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-27 20:05:00" itemprop="dateCreated datePublished" datetime="2021-03-27T20:05:00+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 22:17:24" itemprop="dateModified" datetime="2021-03-29T22:17:24+08:00">2021-03-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>Activity的插件化需要解决3方面的技术问题：</p>
<ul>
<li>宿主App可以加载插件App中的类         </li>
<li>宿主App可以加载插件中的App资源           </li>
<li>宿主App可以加载插件中的Activity          </li>
</ul>
<h2 id="启动没有在AndroidManifest中声明的插件Activity"><a href="#启动没有在AndroidManifest中声明的插件Activity" class="headerlink" title="启动没有在AndroidManifest中声明的插件Activity"></a>启动没有在AndroidManifest中声明的插件Activity</h2><p>在5.4节介绍了启动没有在AndroidManifest 中声明的 Activity，借助宿主App中的StubActivity ，在 AMN 中欺骗，在ActivityThread 中欺骗。这种方式的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码可以参见： https://github.com/BaoBaoJianqiang/ActivityHook1</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="基于动态替换的Activity插件化解决方案"><a href="#基于动态替换的Activity插件化解决方案" class="headerlink" title="基于动态替换的Activity插件化解决方案"></a>基于动态替换的Activity插件化解决方案</h2><p>这章节好混乱，压根就没说这里解决的是什么问题</p>
<h2 id="加载插件中类的方案2：-合并多个dex"><a href="#加载插件中类的方案2：-合并多个dex" class="headerlink" title="加载插件中类的方案2： 合并多个dex"></a>加载插件中类的方案2： 合并多个dex</h2><h2 id="对LaunchMode的支持"><a href="#对LaunchMode的支持" class="headerlink" title="对LaunchMode的支持"></a>对LaunchMode的支持</h2><p>前面介绍的 Activity 插件化技术，对于LaunchMode 都是standard的情况是完全适用的。对于 SingleTop、SingleTask 和 SingleInstance 需要重新考虑。</p>
<p>解决LaunchMode 的问题，适用的还是 <strong>占位Activity</strong> 的思想，即实现为这3种 LaunchMode 创建很多StubActivity，如下图所示：</p>
<p><img src="" alt="占位思想解决LaunchMode问题"></p>
<p>我们可以从服务端下载一个Json，指定插件中的Activity 对应哪种 StubActivity ，写Demo的时候，可以直接在本地 Mock 这些数据，保存在 MyApplication 中，然后再 Mock1Class 接货 startActivity 的时候，如果发现要启动的Activity 在 MyApplication 的 pluginActivities 集合中，那就使用这个插件 Activity 对应的占位 StubActivity，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码参见： https://github.com/BaoBaoJianqiang/ZeusStudy1.3</span></span><br></pre></td></tr></tbody></table></figure>

<p>接下来可以测试下。这里有个小bug，无论singleTop还是singleTask，再回到这个Activity时，并不会触发它的onCreate，而是会触发它的onNewIntent(其实这里说的bug我并没有明白，等测试后再说)。为此，我们需要在MockClass2 中，拦截onNewIntent方法，把占位 StubActivity 替换回插件Activity，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码可以参考上面的链接</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="加载插件中类的方案3：修改App原生的ClassLoader"><a href="#加载插件中类的方案3：修改App原生的ClassLoader" class="headerlink" title="加载插件中类的方案3：修改App原生的ClassLoader"></a>加载插件中类的方案3：修改App原生的ClassLoader</h2><p>..</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/03/26/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC8%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC8%E7%AB%A0/" class="post-title-link" itemprop="url">第8章：最简单的插件化解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-26 21:02:00" itemprop="dateCreated datePublished" datetime="2021-03-26T21:02:00+08:00">2021-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 22:03:10" itemprop="dateModified" datetime="2021-03-29T22:03:10+08:00">2021-03-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>本章介绍一种最简单的插件化方案，适用于四大组件，技术涉及以下3个方面：</p>
<ul>
<li>合并所有的插件dex，用以解决插件类的加载问题             </li>
<li>在宿主AndroidManifest中预先声明插件中的四大组件(插件中的Activity如果很多就很麻烦)      </li>
<li>把插件中的所有资源一次性合并到宿主资源中(可能会导致资源id冲突)     </li>
</ul>
<h2 id="在AndroidManifest-中声明插件中的组件"><a href="#在AndroidManifest-中声明插件中的组件" class="headerlink" title="在AndroidManifest 中声明插件中的组件"></a>在AndroidManifest 中声明插件中的组件</h2><p>在插件中有啥，在宿主中声明啥就行     </p>
<h2 id="宿主App加载插件中的类"><a href="#宿主App加载插件中的类" class="headerlink" title="宿主App加载插件中的类"></a>宿主App加载插件中的类</h2><p>把插件dex都合并到宿主的dex中，那么宿主App对应的ClassLoader 就可以加载插件中任意类：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码参考： https://github.com/BaoBaoJianqiang/ZeusStudy1.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoaderHookHelper</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">patchClassLoder</span><span class="params">(ClassLoader cl,File apkFile,File optDexFile)</span></span>{</span><br><span class="line">        <span class="comment">//获取BaseDexClassLoder: pathList</span></span><br><span class="line">        Object pathListObj = RefInvoke.getFiledObject(DexClassLoader.class.getSuperclass(), cl, <span class="string">"pathList"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取PathList: Element[] dexElements</span></span><br><span class="line">        Object[] dexElements = (Object[])RefInvoke.getFieldObject(pathListObj.getClass(), pathListObj, <span class="string">"dexElements"</span>);</span><br><span class="line"></span><br><span class="line">        ...<span class="comment">//手敲太难了，到时候复制下</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="启动插件Service"><a href="#启动插件Service" class="headerlink" title="启动插件Service"></a>启动插件Service</h2><p>根据前面两章，素组App就能启动一个插件中的Service了，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">String serviceName = <span class="string">"jianqiang.com.plugin1.TestService1"</span>;</span><br><span class="line">intent.setClassName(<span class="keyword">this</span>, serviceName);</span><br><span class="line">startService(intent);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="加载插件中的资源"><a href="#加载插件中的资源" class="headerlink" title="加载插件中的资源"></a>加载插件中的资源</h2><p>四大组件都可以这样实现插件化方案，Service 、ContentProvider 和 Receiver 都只要合并dex就够了，他们没有资源的概念。Activity严重依赖资源，所以必须解决插件中的资源问题。前面章节介绍了AssetManager 和 Resources ，AssetManager 有个 addAssetPath 方法，可以一次性把插件的路径都“灌进去”，然后根据这个“超级” AssetManager 生成一个“超级” Resources ，以后无论是查找插件还是宿主的资源，都能通过这个“超级”Resources 找到了。上述实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码参考：  https://github.com/BaoBaoJianqiang/ZeusStudy1.1</span></span><br></pre></td></tr></tbody></table></figure>
<p>至此，Activity 的“傻瓜式”插件化解决方案就完成了，我们甚至可以从插件Activity跳转到宿主中的Activity，但是这个方案有以下两个问题：</p>
<ul>
<li>插件的四大组件都必需先在宿主中声明，不能新增      </li>
<li>插件和宿主的资源都合并到一起，资源id可能会有冲突     </li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/03/25/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC7%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/25/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC7%E7%AB%A0/" class="post-title-link" itemprop="url">第7章：资源初探</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-25 20:00:00" itemprop="dateCreated datePublished" datetime="2021-03-25T20:00:00+08:00">2021-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 21:54:18" itemprop="dateModified" datetime="2021-03-29T21:54:18+08:00">2021-03-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>Activity 与资源是一对孪生兄弟，想彻底解决Activity 插件化，就要面对如何使用插件中资源的问题。</p>
<h2 id="资源加载机制"><a href="#资源加载机制" class="headerlink" title="资源加载机制"></a>资源加载机制</h2><h3 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h3><p>Android资源分为两类：</p>
<ul>
<li>第一类是res目录下存放的可编译资源文件，编译时，系统会自动在R.java中生成资源文件的十进制值，这种访问比较简单，只需要获取Resources对象，进而通过Resources的getxxx即可得到资源        </li>
<li>第二类是assets目录下存放的原始资源文件，因为apk在编译的时候不会编译它们，所以我们也不能通过 R.xx 来访问，通过绝对路径呢？也不行，因为apk不会解压到本地，所以我们无法直接获取，只能通过AssetManager类的open方法去获取，类似如下代码：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resources resources = getResources();</span><br><span class="line">AssetManager am = getResources().getAssets();</span><br><span class="line">InputStream is = getResources().getAssets().open(<span class="string">"filename"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>由此可见啊，Resources 就能搞定一切！</p>
<h3 id="剪不断理还乱：Resources-和-AssetManager"><a href="#剪不断理还乱：Resources-和-AssetManager" class="headerlink" title="剪不断理还乱：Resources 和 AssetManager"></a>剪不断理还乱：Resources 和 AssetManager</h3><p>AssetManager 中有一个 addAssetPath(String path) 方法，App启动时，会把当前的Apk路径穿进去，接下来AssetManager 和 Resources 就能访问当前apk的所有资源了。addAssetPath 方法是不对外的，不过我们可以通过反射的方式，把插件apk的路径传入这个方法，就把插件资源添加到一个资源池了，当然，当前App的资源早已经在这个池子中了。App有几个插件，就调用几次addAssetPath ，把插件资源都塞到池子里。</p>
<blockquote>
<p>apk打包时，每个资源都会在R文件中有一个十六进制值，并且会生成一个 resources.arsc 文件，它是一个 Hash 表，存放着每个十六进制值和资源的对应关系，这样在运行时，就能知道十六进制值对应res目录下哪个目录哪个资源。</p>
</blockquote>
<h2 id="资源插件化解决方案"><a href="#资源插件化解决方案" class="headerlink" title="资源插件化解决方案"></a>资源插件化解决方案</h2><p>以 在宿主App 中读取插件里面的字符串资源 为例，说明这个解决方案，总共会分为 4 个步骤：</p>
<ol>
<li>loadResources 。通过反射，创建 AssetManager 对象，调用 addAssetPath 方法，把插件 Plugin1 的路径添加到 AssetManager 对象中，从此，这个AssetManager 就只为这个插件 Plugin1 服务了。在这个 AssetManager 基础上，创建相应的 Resources 和 Theme 对象。    </li>
<li>重写 Activity 的getAsset ，getResources 和 getTheme 方法，它们的思路都是一样的，如果插件的对象中相应的对象为空，则使用默认的，即类似： if(mAssetManager == null) { return super.getAssets(); }     </li>
<li>加载外部的插件，生成这个插件的对应的 ClassLoader：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File extractFile = <span class="keyword">this</span>.getFileStreamPath(apkName);</span><br><span class="line">dexPath = extractFile.getPath();</span><br><span class="line"></span><br><span class="line">fileRelease = getDir(<span class="string">"dex"</span>, <span class="number">0</span>);<span class="comment">//0代表Context.MODE_PRIVATE</span></span><br><span class="line">classLoder = newDexClassLoader(dexPath, fileRelease.getAbsolutePath(), <span class="keyword">null</span>, getClassLoder());</span><br></pre></td></tr></tbody></table></figure>
<ol start="4">
<li>通过反射，获取插件中的类，构造出插件类的对象 dynamicObject ，然后就可以让插件中的类读取插件中的资源了。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整个章节的示例代码可以参考： https://github.com/BaoBaoJianqiang/Dynamic2</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="换肤"><a href="#换肤" class="headerlink" title="换肤"></a>换肤</h2><p>在学习了插件化编程后，换肤其实是可以把图片放到插件App中，然后生成R文件来动态读取这些资源：</p>
<p>因为前面已经讲过原理，所以这里暂且不表</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码可以参考： https://github.com/BaoBaoJianqiang/Dynamic3.2</span></span><br></pre></td></tr></tbody></table></figure>




























</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/03/21/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC6%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/21/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC6%E7%AB%A0/" class="post-title-link" itemprop="url">第6章：插件化技术基础知识</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-21 22:37:00 / 修改时间：22:37:56" itemprop="dateCreated datePublished" datetime="2021-03-21T22:37:00+08:00">2021-03-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>这是第二部分【解决方案】的第一章</p>
<h2 id="加载外部dex"><a href="#加载外部dex" class="headerlink" title="加载外部dex"></a>加载外部dex</h2><p>加载外部dex主要有3个步骤：</p>
<ol>
<li>从服务器下载插件 apk到手机 sdcard(需要sdcard权限)    </li>
<li>读取插件apk中的dex，生成对应的 DexClassLoader    </li>
<li>使用DexClassLoader 的loadClass 方法读取插件 dex 中的任何一个类   </li>
</ol>
<p>在理解原理的时候，可以把插件App放在主App的 assets 目录中，用于替代从服务器下载插件。</p>
<p>接下来的部分是例子演示，这里不表。</p>
<h2 id="插件的瘦身"><a href="#插件的瘦身" class="headerlink" title="插件的瘦身"></a>插件的瘦身</h2><p>在插件化编程过程中会出现某个moudule在测试的时候需要，但是在正式环境中不需要，因此，可以把这个module打包成jar包，之后使用provided引用：</p>
<blockquote>
<p>provided files(“lib/classes.jar”)</p>
</blockquote>
<p>因为关键字provided只支持jar包，而不支持module</p>
<h2 id="Application-的插件化解决方案"><a href="#Application-的插件化解决方案" class="headerlink" title="Application 的插件化解决方案"></a>Application 的插件化解决方案</h2><p>在插件中可能自定义Application，插件会在这个自定义的Application的onCreate中做一些初始化工作，但我们知道<strong>插件的Application是没机会执行的</strong>，此时，我们可以<strong>在宿主的自定义的Application的onCreate方法中，手动把这些插件Application都反射出来，执行他们的onCreate</strong>，不过这样一来，插件Application就是没有生命周期的，它彻底沦为一个普通类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//示例代码参见： https://github.com/BaoBaoJianqiang/ZeusStudy1.8</span></span><br></pre></td></tr></tbody></table></figure>





























</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">152</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共320.3k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/6/',]
      });
      });
  </script>


</body>
</html>
