<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.gitee.io/page/6/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.gitee.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">116</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/24/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/24/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：应用程序进程启动过程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-24 10:22:00" itemprop="dateCreated datePublished" datetime="2019-11-24T10:22:00+08:00">2019-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-03 21:29:50" itemprop="dateModified" datetime="2019-12-03T21:29:50+08:00">2019-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>AMS启动一个应用程序首先要保证该应用程序的进程已经启动，如果应用程序进程还不存在，则请求 Zygote 进程启动进程。</p>
<p>从前一章内容可知，在Zygote 的Java 框架层会创建Server 端的Socket，用于等待AMS 请求Zygote 创建新的应用程序进程。Zygote 通过fork自身即可创建应用程序进程，这个进程会包含虚拟机实例，并且会创建Binder线程池和消息循环。</p>
<p>本章学习应用程序进程的启动，注意，是应用程序进程而不是应用程序的启动过程。</p>
<h2 id="应用程序进程启动过程介绍"><a href="#应用程序进程启动过程介绍" class="headerlink" title="应用程序进程启动过程介绍"></a>应用程序进程启动过程介绍</h2><p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC3%E7%AB%A0/AMS%E5%8F%91%E9%80%81%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.jpeg" alt="AMS发送启动应用程序进程请求过程的时序图"></p>
<p>AMS 通过调用  startProcessLocked 向 Zygote 进程发送请求， 主要代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="params"><span class="function">String hostingNameStr, String abiOverride ,String entryPoint ,String [] entryPointArgs)</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取要创建的应用程序进程的用户 ID</span></span><br><span class="line">    <span class="keyword">int</span> uid = app.uid; <span class="comment">//1 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> [] gids = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">if</span> (!app.isolated) { </span><br><span class="line">        <span class="comment">//2  gids创建和赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="function">ArrayUtils <span class="title">isEmpty</span><span class="params">(permGids)</span>)</span>{</span><br><span class="line">            gids =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; </span><br><span class="line">        }<span class="keyword">else</span> { </span><br><span class="line">            gids = <span class="keyword">new</span> <span class="keyword">int</span>[permGids.leng + <span class="number">3</span>] ; </span><br><span class="line">            System.arraycopy(permGids, <span class="number">0</span>, gids, <span class="number">3</span>, permGids.length) ; </span><br><span class="line">            gids[O] = UserHandle.getSharedAppGid(UserHandle.getAppid(uid)); </span><br><span class="line">            gids[<span class="number">1</span>] = UserHandle.getCacheAppGid(UserHandle .getAppid(uid)) ; </span><br><span class="line">            gids[<span class="number">2</span>] = UserHandle.getUserGid{UserHandle.getUserid(uid)); </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (entryPoint = <span class="keyword">null</span>) entryPoint = <span class="string">"android.app.ActivityThread"</span>;<span class="comment">//3</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//启动应用程序进程,这里省略不重要的参数</span></span><br><span class="line">    startResult = Process.start(entryPoint,xxx,uid, xxx,gids,xxx,xxx);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>上述代码<strong>首先得到应用程序进程的用户ID</strong>，之后创建用户组ID 并且赋值，在注释3处判断 entryPoint 为null就赋值 “android.app.ActivityThread”，<font color="#008000">这个值就是应用程序进程主线程的类名</font>。在最终调用 Process.start 创建进程时，会将进程的用户ID和用户组ID传入。</p>
<p>Process.start会将实现交给 ZygoteProcess(<strong>ZygoteProcess用于保持与Zygote进程的通信状态</strong>)的start 方法处理，其中首先会执行 openZygoteSocketifNeeded  方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed ()) { </span><br><span class="line"><span class="keyword">try</span> { </span><br><span class="line">    <span class="comment">//与 Zygote 进程建立 Socket 连接</span></span><br><span class="line">    primaryZygoteState = ZygoteState.connect(mSocket);<span class="comment">//1</span></span><br><span class="line">} <span class="keyword">catch</span> (IOException ioe} { </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx (<span class="string">"Error connecting to primary zygote"</span>， ioe)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//连接 Zygote 主模式返回的 ZygoteState 是否与启动应用程序进程所需要的ABI匹配</span></span><br><span class="line"><span class="keyword">if</span> (primaryZygotestate.matches (abi)) {<span class="comment">//2 </span></span><br><span class="line">    <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">／／如果不匹配，则尝试连接 Zygote 辅模式</span><br><span class="line"><span class="keyword">if</span> (secondaryZygoteState ==<span class="keyword">null</span> || secondaryZygoteState.isClosed()) { </span><br><span class="line"><span class="keyword">try</span> { </span><br><span class="line">    secondaryZygoteState = ZygoteState.connect(mSecondarySocket);<span class="comment">//3</span></span><br><span class="line">} <span class="keyword">catch</span> (IOException ioe) { </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx (<span class="string">"Error connecting to secondary zygote"</span>, ioe) ; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">／／连接 Zygote 辅模式返回的 ZygoteState 是否与启动应用程序进程所需要的 ABI 匹配</span><br><span class="line"><span class="keyword">if</span> (secondaryZygoteState.matches(abi)) {<span class="comment">//4 </span></span><br><span class="line">    <span class="keyword">return</span> secondaryZygoteState; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx (<span class="string">"Unsupported zygote ABI :"</span> + abi); </span><br></pre></td></tr></tbody></table></figure>

<p>前面章节提到Zygote的main方法中会创建name为 “zygote” 的server端Socket，注释1就是与Zygote进程建立Socket 连接(name为”zygote”)，并得到 ZygoteState 对象primaryZygoteState；注释2处如果primaryZygoteState 与启动应用程序所需要的 ABI 不匹配，则在注释3处连接name为 “zygote_secondary” 的Socket。如果辅模式返回的 ZygoteState 与进程所需的ABI也不匹配，就抛出异常。</p>
<p>通过 openZygoteSocketifNeeded 获取ZygoteState后，将其作为参数调用 ZygoteProcess的  ZygoteSendArgsAndGetResult 方法 获取Process.ProcessStartResult。</p>
<h3 id="Zygote-接收请求并创建应用程序进程"><a href="#Zygote-接收请求并创建应用程序进程" class="headerlink" title="Zygote 接收请求并创建应用程序进程"></a>Zygote 接收请求并创建应用程序进程</h3><p>执行完以上步骤后，继续执行 argsForZygote 方法即可让Zygote 收到创建新的应用程序进程的请求。Zygote 接收请求并创建应用程序进程的时序图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC3%E7%AB%A0/Zygote%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Zygote接收请求并创建应用程序进程的时序图"></p>
<p>由前面章节我们知道，Zygote 中的Server Socket 的runSelectLoop 方法一直在等待 AMS请求创建新的应用程序进程，runSelectLoop 中是通过 runOnce 来创建进程的，runOnce最终调用到 Zygote 的 forkAndSpecialize 方法创建应用程序进程，并返回pid。forkAndSpecialize 通过fork 当前进程来创建一个子进程。此后，便会在应用程序进程中创建 Binder 线程池，*<em>进一步通过反射 ActivityThread 类的main方法调用，令应用程序进程进入了ActivityThread 的main方法中。此时，应用程序进程创建完毕，并且运行了主线程管理类 ActivityThread *</em>。</p>
<blockquote>
<p>如果pid为0，说明当前代码运行在新创建的子进程中。</p>
</blockquote>
<h3 id="Binder-线程池启动过程"><a href="#Binder-线程池启动过程" class="headerlink" title="Binder 线程池启动过程"></a>Binder 线程池启动过程</h3><p>程序中会检查代码，确保Binder线程池只会被启动一次。</p>
<h3 id="消息循环创建过程"><a href="#消息循环创建过程" class="headerlink" title="消息循环创建过程"></a>消息循环创建过程</h3><p>通过反射方式 invok 执行 ActivityThread 的main方法时，会执行一系列主线程的工作，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{ </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建主线程 Looper</span></span><br><span class="line">    Looper.prepareMainLooper(); <span class="comment">//1 </span></span><br><span class="line">    ActivityThread thread= <span class="keyword">new</span> ActivityThread(); <span class="comment">//2 </span></span><br><span class="line">    thread.attach(<span class="keyword">false</span>) ; </span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span> ) {<span class="comment">//3 </span></span><br><span class="line">    <span class="comment">//创建主线程 H 类</span></span><br><span class="line">    sMainThreadHandler = thread . getHandler ();<span class="comment">//4 </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) { </span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span> LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>）；</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER) ; </span><br><span class="line">    <span class="comment">//Looper 开始工作</span></span><br><span class="line">    Looper.loop (); <span class="comment">//5 </span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ActivityThread类用于管理当前应用程序进程的主线程，上述代码中创建了主线程的消息循环Looper，其中的内部类 H 继承 Handler，在注释 5 处调用Looper.loop ，即使得Looper 开始处理消息，可见，系统在应用程序进程启动完成后，就会创建消息循环。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/23/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/23/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="post-title-link" itemprop="url">面试题-虚拟机知识</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-23 21:40:00" itemprop="dateCreated datePublished" datetime="2019-11-23T21:40:00+08:00">2019-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-12 09:50:33" itemprop="dateModified" datetime="2020-07-12T09:50:33+08:00">2020-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1、对象的内存布局"><a href="#1、对象的内存布局" class="headerlink" title="1、对象的内存布局"></a>1、对象的内存布局</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>分为3个区域：对象头、实例数据 以及 对齐填充</p>
<p><strong>对象头：</strong>包括两部分信息，第一部分：对象自身运行时数据，如hashcode、GC年龄分代、锁状态标志位，官方称为”Mark Word”。第二部分：类型指针，虚拟机通过这个指针确定对象是哪个类的实例。</p>
<p><strong>实例数据：</strong>对象真正存储的有效信息。</p>
<p><strong>对齐填充：</strong>比如HotSpot vm 要求对象起始地址必须是8的整数倍。对齐填充不是必需的。</p>
<p>以下是句柄访问 时，内存布局关系图：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="内存布局关系图"></p>
<blockquote>
<p>以上内容参考自： <a target="_blank" rel="noopener" href="http://www.androidos.net.cn/book/android-road/java/virtual-machine/object.html">对象创建与定位</a></p>
</blockquote>
</details>

<h2 id="2、垃圾收集算法"><a href="#2、垃圾收集算法" class="headerlink" title="2、垃圾收集算法"></a>2、垃圾收集算法</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>标记-清除 算法。不足：1、标记清除效率不高。2、产生内存碎片。    </li>
<li>复制算法。为了解决标记清除的效率问题，将内存划分为大小相等的两块，每次使用一块。不足：可用内存缩小为原来一半。    </li>
<li>标记-整理。不足：复制存货对象耗时过多。    </li>
<li>分代收集算法。 新生代使用复制算法；老年代采用“标记-清除” 或者 “标记-整理”算法。</li>
</ul>
</details>

<blockquote>
<p>以上内容参考自： <a target="_blank" rel="noopener" href="http://www.androidos.net.cn/book/android-road/java/virtual-machine/Garbage-Collector.html">垃圾回收算法</a></p>
</blockquote>
<h2 id="3、说说四大引用？强，软，弱，虚，并说明下合适GC"><a href="#3、说说四大引用？强，软，弱，虚，并说明下合适GC" class="headerlink" title="3、说说四大引用？强，软，弱，虚，并说明下合适GC"></a>3、说说四大引用？强，软，弱，虚，并说明下合适GC</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。</p>
</blockquote>
<blockquote>
<p>软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，只有在内存不足的时候 JVM 才会回收该对象。这一点可以很好地用来解决 OOM 的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>
</blockquote>
<blockquote>
<p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p>
</blockquote>
<blockquote>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。要注意的是，虚引用必须和引用队列关联使用.</p>
</blockquote>
</details>

<h2 id="4、Android中内存分配的执行流程"><a href="#4、Android中内存分配的执行流程" class="headerlink" title="4、Android中内存分配的执行流程"></a>4、Android中内存分配的执行流程</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="铺垫"><a href="#铺垫" class="headerlink" title="铺垫"></a>铺垫</h3><p>Dalvik 虚拟机的Java堆的底层实现是一块共享匿名内存(Ashmem)，并且将其抽象为C库的一个 mspace ，于是，Dalvik 虚拟机就可以利用 C 库里面的 dlmalloc 内存分配器来解决内存碎片问题(这是个成熟的内存分配器，<strong>可以很好地解决内存碎片的问题</strong>)</p>
<h3 id="Android中内存分配的执行流程："><a href="#Android中内存分配的执行流程：" class="headerlink" title="Android中内存分配的执行流程："></a>Android中内存分配的执行流程：</h3><p>流程图如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B.png" alt="dalvik虚拟机内存分配流程"></p>
<ol>
<li>尝试在Java堆上分配指定大小的内存，如果内存充足，就直接分配成功。(不改变java堆当前大小的前提下进行内存分配，属于轻量级的内存分配)      </li>
<li>如果分配失败，就执行一次GC(如果此时有GC在运行，则等待这次GC执行完成)，GC 时设置参数false标记<strong>不要</strong>回收软引用的对象。        </li>
<li>GC 完成后，再次尝试轻量级内存分配操作，如果内存充足，就分配成功了               </li>
<li>如果上一步内存分配失败，就考虑将Java堆的当前大小设置为Dalvik 虚拟机启动时指定的Java堆最大值，再进行内存分配         </li>
<li>如果内存充足，就完成内存的分配       </li>
<li>如果上一步还是分配失败，就再次调用GC，并将参数标记为true，<strong>表示要回收软引用的对象</strong>           </li>
<li>GC完毕后，再次尝试分配，成功就返回；不成功也就抛出OOM了       </li>
</ol>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/luoshengyang/article/details/41688319">老罗的博客</a></p>
</blockquote>
</details>

<h2 id="5、Android-GC-流程"><a href="#5、Android-GC-流程" class="headerlink" title="5、Android GC 流程"></a>5、Android GC 流程</h2><h3 id="Art-虚拟机GC过程"><a href="#Art-虚拟机GC过程" class="headerlink" title="Art 虚拟机GC过程"></a>Art 虚拟机GC过程</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E8%99%9A%E6%8B%9F%E6%9C%BA/Art%E7%9A%84gc%E6%B5%81%E7%A8%8B.jpg" alt="Art的gc流程"></p>
<p>由图可知，非并行GC的过程如下所示：</p>
<ol>
<li>挂起所有的ART运行时线程。      </li>
<li>调用子类实现的成员函数MarkingPhase执行GC标记阶段。          </li>
<li>调用子类实现的成员函数ReclaimPhase执行GC回收阶段。       </li>
<li>恢复第2步挂起的ART运行时线程。          </li>
</ol>
<p>并行GC的过程如下所示：</p>
<ol>
<li>获取用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数MarkingPhase执行GC并行标记阶段。</li>
<li>释放用于访问Java堆的锁。</li>
<li>挂起所有的ART运行时线程。</li>
<li>调用子类实现的成员函数HandleDirtyObjectsPhase处理在GC并行标记阶段被修改的对象。。</li>
<li>恢复第4步挂起的ART运行时线程。</li>
<li>重复第5到第7步，直到所有在GC并行阶段被修改的对象都处理完成。</li>
<li>获取用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数ReclaimPhase执行GC回收阶段。</li>
<li>释放用于访问Java堆的锁。</li>
</ol>
<p>从上面的分析就可以看出，并行GC和非并行GC的区别在于：</p>
<ol>
<li>非并行GC的标记阶段和回收阶段是在挂住所有的ART运行时线程的前提下进行的，因此，只需要执行一次标记。         </li>
<li>并行GC的标记阶段只锁住了Java堆，因此它不能阻止那些不是正在分配对象的ART运行时线程同时运行，而这些同进运行的ART运行时线程可能会引用了一些在之前的标记阶段没有被标记的对象。如果不对这些对象进行重新标记的话，那么就会导致它们被GC回收，造成错误。因此，与非并行GC相比，并行GC多了一个处理脏对象的阶段。所谓的脏对象就是我们前面说的在GC标记阶段同时运行的ART运行时线程访问或者修改过的对象。        </li>
<li>并行GC并不是自始至终都是并行的，例如，处理脏对象的阶段就是需要挂起除GC线程以外的其它ART运行时线程，这样才可以保证标记阶段可以结束。         </li>
</ol>
</details>


<h3 id="Dalvik-虚拟机垃圾收集过程"><a href="#Dalvik-虚拟机垃圾收集过程" class="headerlink" title="Dalvik 虚拟机垃圾收集过程"></a>Dalvik 虚拟机垃圾收集过程</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Dalvik 虚拟机使用 Mark-Sweep 算法来进行垃圾收集<br>Dalvik 执行GC 时会有一些选项：</p>
<ul>
<li>isPartial，为true 时，表示仅仅回收Active 堆的垃圾；为false时，表示同时回收Active 堆和Zygote 堆的垃圾    </li>
<li>isConcurrent：为true时，表示执行并行GC，false时，表示非并行GC    </li>
<li>doPreserve：为true的时候，表示不回收软引用的对象；false的时候，表示回收软引用对象<br>Dalvik在如下几种情况会触发GC：</li>
<li>分配对象时，内存不足触发GC    </li>
<li>已经分配的内存达到一定阈值时触发GC    </li>
<li>调用 System.gc 、VMRuntime.gc 或者收到信号触发 GC    </li>
<li>准备抛出 OOM 前而最后进行的 GC<br>GC线程在空闲达到一定时间后，会调用函数对Java堆进行裁剪，将一些没有用到的内存交还给内核。<br>dalvik 的GC 流程(并行和非并行情况)如下图所示：<br><img src="/assets/%E9%9D%A2%E8%AF%95/java%E8%99%9A%E6%8B%9F%E6%9C%BA/dalvik%E7%9A%84gc%E6%B5%81%E7%A8%8B.jpg" alt="dalvik虚拟机gc流程"></li>
</ul>
<h3 id="哪些对象可以做-GC-Root"><a href="#哪些对象可以做-GC-Root" class="headerlink" title="哪些对象可以做 GC Root"></a>哪些对象可以做 GC Root</h3><ul>
<li>虚拟机栈引用的对象    </li>
<li>本地方法栈引用的对象     </li>
<li>方法区中类静态属性引用的对象     </li>
<li>方法区中常量引用的对象        </li>
<li>Dalvik 虚拟机内部创建的部分异常对象      </li>
<li>Dalvik 虚拟机内部创建的原子类     </li>
<li>注册在调试器的对象</li>
</ul>
</details>

<blockquote>
<p>以上内容参考自以上内容参考自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Luoshengyang/article/details/41822747?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158968621519724843340084%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=158968621519724843340084&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v25-6-41822747.nonecase&amp;utm_term=dalvik">罗升阳的博客</a>  、 <a target="_blank" rel="noopener" href="https://blog.csdn.net/luoshengyang/article/details/42555483">老罗的博客</a></p>
</blockquote>
<h2 id="6、如何理解Java类加载机制"><a href="#6、如何理解Java类加载机制" class="headerlink" title="6、如何理解Java类加载机制"></a>6、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483903&amp;idx=1&amp;sn=c20d3172052bd7db9a1ad6a95f112bc9&amp;chksm=96cda0b2a1ba29a4cc9912cb1bf8a955f97ee45a7b8db48e384f1694ddbabbd4d5e7fa90f880&amp;scene=21#wechat_redirect">如何理解Java类加载机制</a></h2></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/23/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/23/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">面试题-设计模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-23 21:40:00" itemprop="dateCreated datePublished" datetime="2019-11-23T21:40:00+08:00">2019-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-14 16:28:00" itemprop="dateModified" datetime="2021-03-14T16:28:00+08:00">2021-03-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1、mvc、mvp、mvvm"><a href="#1、mvc、mvp、mvvm" class="headerlink" title="1、mvc、mvp、mvvm"></a>1、mvc、mvp、mvvm</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="mvc"><a href="#mvc" class="headerlink" title="mvc"></a>mvc</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvc.png" alt="mvc示意图"></p>
<p><strong>特征：</strong></p>
<ul>
<li>view 接收用户的输入，并且可以通知Controller 更改Model 层数据，如果没有涉及逻辑，还可以直接通知Model 更改数据。    </li>
<li>需要ui变化，但是没有涉及业务数据，直接调用controller 即可(比如用户选择使用用户名/手机号登录)    </li>
<li>model 数据变化时，若需要修改ui，需要通过Controller 来通知更新。</li>
</ul>
<p><strong>在Android中存在问题：</strong></p>
<ul>
<li>Activity 的职责不明，并且臃肿。Activity 除了要展示view (加载view，接收用户操作)，还要承担部分逻辑处理(比如生命周期回调)    </li>
</ul>
<h3 id="mvp"><a href="#mvp" class="headerlink" title="mvp"></a>mvp</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvp.png" alt="mvp示意图"></p>
<p><strong>特点</strong>:</p>
<ul>
<li>View 层接收输入</li>
<li>Presenter 处理业务逻辑，View 与 Model 之间必须经过 Presenter</li>
</ul>
<p><strong>优点(相对MVC)：</strong></p>
<ul>
<li>避免了View、Model 直接联系，更加解耦，通过Presenter 实现两者之间的沟通    </li>
<li>Activity 更加简明，仅仅负责UI上的工作    </li>
</ul>
<h3 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvvm.png" alt="mvvm示意图"></p>
<p>可能主要关注view 通过databinding 与 viewmodel 相互绑定。</p>
<h3 id="mvc-与-mvp-的区别"><a href="#mvc-与-mvp-的区别" class="headerlink" title="mvc 与 mvp 的区别"></a>mvc 与 mvp 的区别</h3><ul>
<li>在mvc 中 Activity 具有 view 的功能，并且兼任部分 controller 功能，而mvp 中Activity 是纯粹的view    </li>
<li>mvc 中view 和model 可以直接沟通(没有逻辑情况下，view直接更改model，当然，有逻辑改动的情况下经过controller)，而mvp中二者沟通必须经过presenter。    </li>
</ul>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/100070713">carson_ho的博客</a></p>
</blockquote>
<h3 id="2、实现一个线程安全的单例模式"><a href="#2、实现一个线程安全的单例模式" class="headerlink" title="2、实现一个线程安全的单例模式"></a>2、实现一个线程安全的单例模式</h3><h3 id="3、观察者模式和回调有什么区别？"><a href="#3、观察者模式和回调有什么区别？" class="headerlink" title="3、观察者模式和回调有什么区别？"></a>3、观察者模式和回调有什么区别？</h3></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/23/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC11%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/23/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC11%E7%AB%A0/" class="post-title-link" itemprop="url">第11章：Dalvik 和 ART</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-23 10:30:00 / 修改时间：11:00:25" itemprop="dateCreated datePublished" datetime="2019-11-23T10:30:00+08:00">2019-11-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Dalvik虚拟机"><a href="#Dalvik虚拟机" class="headerlink" title="Dalvik虚拟机"></a>Dalvik虚拟机</h2><p>Dalvik虚拟机 简称 DVM，第10章提到，它不是一个 jvm，主要原因是它没有遵循jvm规范实现，二者的主要区别有：</p>
<ul>
<li>基于的架构不同</li>
</ul>
<blockquote>
<p>JVM 基于栈，DVM 基于寄存器。基于栈意味着需要去栈中读写数据，所需要的指令更多，并且速度更慢，对于性能优先的移动设备，显然是不合适的。</p>
</blockquote>
<ul>
<li>执行的字节码不同</li>
</ul>
<blockquote>
<p>在Java SE 程序中，Java 类被编译成一个或者多个.class 文件，并被打包成 jar 文件，之后JVM 会通过相应的 .class 和 jar 文件获取相应的字节码；而DVM 会用dx工具将所有的 .class 文件转换为一个 .dex 文件，然后DVM 从该 .dex 文件中读取指令和数据。<br>.jar文件里面包含多个.class 文件，每个.class文件包含了该类的常量池、类信息、属性等，当JVM 加载.jar文件的时候，会加载里面所有的.class文件，JVM 这种加载方式很慢(首先就是很多io操作)，对于内存有限的移动设备并不合适；而.dex文件将所有的.class里面所包含的信息全部整合到一块了，这样再加载就减少了I/O操作，加快查找速度；并且，相对Android而言，.class中有许多冗余信息，dex工具会去掉冗余信息。</p>
</blockquote>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC11%E7%AB%A0/dalvik%E4%B8%8Ejvm%E6%89%A7%E8%A1%8C%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="DVM与JVM执行的字节码不同"></p>
<ul>
<li>DVM 允许在有限的内存中同时运行多个进程</li>
</ul>
<blockquote>
<p>在Android中，每个应用都运行在一个DVM中，每个DVM 实例都运行在一个独立的进程中，这样，某一个虚拟机崩溃的时候不会导致其他app也关闭。</p>
</blockquote>
<ul>
<li>DVM 由Zygote创建和初始化</li>
</ul>
<blockquote>
<p>在第2章有介绍<strong>Zygote，它是一个DVM进程</strong>，当系统需要创建一个应用程序时，Zygote就会fork自身，快速地创建和初始化一个DVM实例。对于一些只读的库，所有的DVM实例都会和Zygote共享一块内存区域，节省内存开销。</p>
</blockquote>
<ul>
<li>DVM 有共享机制</li>
</ul>
<blockquote>
<p>DVM 的共享机制可以使<strong>不同应用之间在运行时可以共享相同的类</strong>，这带来更高的效率；而JVM不具有这种机制，不同的程序，打包以后的程序都是彼此独立的，即便它们在包里使用了同样的类，运行时也是单独加载和运行的。</p>
</blockquote>
<h3 id="DVM-运行时堆"><a href="#DVM-运行时堆" class="headerlink" title="DVM 运行时堆"></a>DVM 运行时堆</h3><p>DVM运行时堆使用标记-清除算法进行GC，它由两个Space以及多个辅助数据结构组成，两个Space分别是：Zygote Space(Zygote Heap) 和 Allocation Space(Active Heap)，前者用于管理Zygote进程在启动过程中预加载和创建的对象，并且Zygote Space不会触发GC，Zygote 进程和应用进程之间会共享Zygote Space。在Zygote 进程fork第一个子进程前，会把Zygote Space 分为两部分，原来已经被使用的部分对仍旧叫做Zygote Space，而未使用的那部分堆叫做 Allocation Space ，以后的对象都会在 Allocation Space上进行分配和释放。</p>
<h2 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h2><p>Android 4.4 的时候发布了ART虚拟机，但是4.4版本默认还是使用DVM，Android 5.0 及以后版本默认采用ART，从此，DVM退出历史舞台。</p>
<h3 id="ART-与-Dalvik-区别"><a href="#ART-与-Dalvik-区别" class="headerlink" title="ART 与 Dalvik 区别"></a>ART 与 Dalvik 区别</h3><p>ART 与 Dalvik 的区别主要有4点：</p>
<ul>
<li>DVM 是为32位CPU涉及的，而ART支持64位并且兼容32位 CPU。    </li>
<li>ART 对垃圾回收机制进行了改进，将 GC 暂停由2次减少为1次，并且频繁执行并行垃圾收集。    </li>
<li>ART 的运行时堆空间划分和DVM不同。    </li>
<li>DVM中应用每次运行时，字节码通过 JIT 编译器编译为机器码，使得应用程序运行效率低下；而在ART中，系统在安装应用程序时会进行一次AOT(ahead of time compilation,预编译)，将字节码预先编译成机器码并存储在本地，这样应用程序每次运行时就不需要执行编译了。</li>
</ul>
<blockquote>
<p>ART也有两个主要缺点：一是AOT使应用安装时间变长，二是预编译的机器码占用的存储空间比较大。为了解决上面的缺点，Android 7.0 版本在ART中加入了JIT编译器，作为AOT的补充：在安装应用时不会将字节码全部编译成机器码，而是在运行中将热点代码编译器机器码，以达到缩短应用安装时间并节省存储空间。</p>
</blockquote>
<p>更详细的内容，可以参考<a target="_blank" rel="noopener" href="https://source.android.google.cn/devices/tech/dalvik/gc-debug">官网上的描述</a></p>
<h3 id="ART-运行时堆"><a href="#ART-运行时堆" class="headerlink" title="ART 运行时堆"></a>ART 运行时堆</h3><p>与DVM 的GC不同的是，ART采用多种垃圾收集方案，每个方案会运行不同的垃圾收集器，默认是采用 CMS(Concurrent Mark-Sweep)方案，主要有sticky-CMS 和 partial-CMS，不同的CMS方案，ART运行时堆得空间划分也不同，默认由4个Space和多个辅助结构组成，采用标记-清除算法时，两种虚拟机运行时堆对比图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC11%E7%AB%A0/dalvik%E4%B8%8Eart%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4.png" alt="两种虚拟机运行时堆对比"></p>
<p>由图可以看到ART的4个Space，其中，Zygote Space 、Allocation Space 和 DVM 中的作用一样，ImageSpace 用来存放一些预加载类，Large Object Space 用来分配一些大对象。其中Zygote Space 与 Image Space 是进程共享的。</p>
<h3 id="ART-的GC-日志"><a href="#ART-的GC-日志" class="headerlink" title="ART 的GC 日志"></a>ART 的GC 日志</h3><ol>
<li>GC Reason<br>ART 虚拟机GC日志中会包含产生这次GC原因，主要会有：</li>
</ol>
<ul>
<li>Concurrent: 并发GC，在后台线程运行GC，不会使App的线程暂停，不会阻止内存分配。    </li>
<li>Alloc： 当堆内存已满，App尝试分配内存而引起的GC，<strong>这个GC发生在正在分配内存的线程中。</strong>    </li>
<li>Explicit： App显式请求垃圾收集，比如 System.gc()。    </li>
<li>NativeAlloc： Native 内存分配时触发的GC。    </li>
</ul>
<ol start="2">
<li>垃圾收集器名称<br>ART 虚拟机GC日志中会包含所使用的收集器名称，主要会有：</li>
</ol>
<ul>
<li>Concurrent Mark Sweep(CMS)： 它是以最短收集暂停时间为目标的收集器，采用标记-清除算法，<strong>能释放除了Image Space外的所有空间</strong>    </li>
<li>Concurrent Partial Mark Sweep： 能释放除了Image Space 和 Zygote space 意外的所有空间    </li>
<li>Concurrent Sticky Mark Sweep： 粘性收集器，<strong>基于分代的垃圾收集思想</strong>，只能释放自上次GC以来分配的对象，这个收集器扫描比较频繁，因为它很快并有很短的暂停时间。    </li>
<li>Marksweep + Semispace：非并发GC，复制GC用于堆转换以及堆碎片整理。    </li>
</ul>
<h2 id="DVM-和-ART-的诞生"><a href="#DVM-和-ART-的诞生" class="headerlink" title="DVM 和 ART 的诞生"></a>DVM 和 ART 的诞生</h2><p>它们是从Zygote进程诞生的，这样，Zygote进程就持有了DVM或者ART的实例，此后，Zygote进程每次fork自身创建新的应用进程时，应用程序进程也就得到了 DVM 或者ART 的实例，即每个应用进程都有一个单独的虚拟机实例。<strong>这样做的好处是，无需在每次启动应用程序进程时都要创建DVM或者ART，从而加快了应用程序进程的启动速度</strong>。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/22/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/22/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：Android系统启动</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-22 15:10:00" itemprop="dateCreated datePublished" datetime="2019-11-22T15:10:00+08:00">2019-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-03 21:22:20" itemprop="dateModified" datetime="2019-12-03T21:22:20+08:00">2019-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="init-进程启动过程"><a href="#init-进程启动过程" class="headerlink" title="init 进程启动过程"></a>init 进程启动过程</h2><p>init进程是Android系统中<strong>用户空间的第一个进程</strong>，进程号为1，它被赋予了很多重要职责，比如创建 Zygote 和属性服务等。</p>
<h3 id="引入init进程"><a href="#引入init进程" class="headerlink" title="引入init进程"></a>引入init进程</h3><p>了解Android系统启动流程的前几步，可以有助于引入init进程：</p>
<ol>
<li>启动电源以及系统启动。当电源按下时，引导芯片代码从预定义的地方(固化在ROM中)开始执行，<strong>加载引导程序到RAM中</strong>，然后执行。    </li>
<li>引导程序BootLoader。它是Android操作系统开始运行前的一个小程序，主要作用是把系统OS拉起来。    </li>
<li>Linux 内核启动。linux内核启动完成系统设置后，<strong>它首先在系统文件中寻找init.rc，并启动init进程。</strong>     </li>
<li>init进程启动。init进程的工作比较多，主要用于初始化、启动属性服务 以及 启动Zygote进程。</li>
</ol>
<h3 id="init进程入口"><a href="#init进程入口" class="headerlink" title="init进程入口"></a>init进程入口</h3><p>在Linux内核加载完成后，首先在系统文件中查找init.rc，并启动init进程。init的main函数中做了很多事情，我们主要了解以下几点：</p>
<ul>
<li>调用property_init 函数对属性初始化，调用 start_property_service函数启动属性服务。    </li>
<li>调用 signal_handler_init <strong>设置子进程信号处理函数，主要用于防止init进程的子进程成为僵尸进程。</strong>为了防止僵尸进程的出现，系统会在子进程暂停和终止的时候发出 SIGCHLD信号，signal_handler_init就是用来接收这个信号的。</li>
</ul>
<blockquote>
<p>僵尸进程：在linux中，父进程使用fork创建子线程，在子线程终止后，如果父进程并不知道子线程终止了，那么还会在系统进程表为它保留一定的信息。僵尸进程主要危害就是占用系统进程表，可能导致系统进程表被耗尽而无法创建新的进程。假设init的子进程Zygote终止了，signal_handler_init 函数会找到Zygote进程并移除所有Zygote进程信息，再重启Zygote。</p>
</blockquote>
<h3 id="解析-init-rc"><a href="#解析-init-rc" class="headerlink" title="解析 init.rc"></a>解析 init.rc</h3><p>init.rc 是一个配置文，是由Android 初始化语言编写的脚本，为了分析如何创建Zygote，我们主要查看其中的Service类型语句，在Android 8.0 及以后，每个Service 都对应一个rc 文件。init.rc 中定义Service 的格式如下：</p>
<blockquote>
<p>service <name> <pathname> [ <argument> ] * //&lt;service 的名字〉〈执行程序路径〉〈传递参数〉</argument></pathname></name></p>
</blockquote>
<p>举个栗子，zygote的Service配置文件就是：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin -- zygote --startsystem- server </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">main</span> </span></span><br><span class="line"><span class="class"><span class="title">priority</span> -20 </span></span><br><span class="line"><span class="class"><span class="title">user</span> <span class="title">root</span> </span></span><br><span class="line"><span class="class"><span class="title">group</span> <span class="title">root</span> <span class="title">readproc</span> </span></span><br></pre></td></tr></tbody></table></figure>

<p>来大概分析代码意思，Service用于通知 init 进程创建名为 zygote 的进程，这个进程执行程序的路径为 /system/bin/app_process64，其中 <font color="#008000">class main</font>指的是Zygote 的classname 为 main。<strong>后面的代码是要传给 app_process64的参数。</strong></p>
<h3 id="解析Service类型语句"><a href="#解析Service类型语句" class="headerlink" title="解析Service类型语句"></a>解析Service类型语句</h3><p>init.rc中Service类型语句使用ServiceParser类来解析，它将init.rc中的service解析生成的Service对象加入到 Service 链表中。</p>
<h3 id="init-启动Zygote"><a href="#init-启动Zygote" class="headerlink" title="init 启动Zygote"></a>init 启动Zygote</h3><p>我们来了解init是如何启动Service的，这里主要讲解 Zygote这个Service。前面提到，在Zygote的启动脚本中描述Zygote的classname为<font color="#008000">main</font>，在init.rc中会遍历 解析Service类型语句 过程生成的Service链表，找到 classname 为main的Zygote，如果Zygote Service 已经运行，则不再启动，否则就调用fork函数创建子进程，并在子进程中调用Service的main函数，Zygote的main函数代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main （<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv []) </span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (zygote) { </span><br><span class="line">        runtime.start （<span class="string">"com.android.internal.os.Zygoteinit”， args, zygote) ; //1</span></span><br><span class="line"><span class="string">    } else if (className) { </span></span><br><span class="line"><span class="string">        runtime .start （” com android nternal.os.Runtimeinit ”， args zygote) ; </span></span><br><span class="line"><span class="string">    } else{</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></tbody></table></figure>

<p>从注释1处可以看到调用runtime的start函数启动了 Zygote 。</p>
<h3 id="属性服务"><a href="#属性服务" class="headerlink" title="属性服务"></a>属性服务</h3><p>Windows上有注册表管理器以键值对的形式记录用户软件的一些使用信息，即使系统或者软件重启，其还是能够根据之前注册表中的记录进行相应初始化工作。Android中也提供了类似机制，叫做<strong>属性服务</strong>。init 进程启动时会启动属性服务，并为其分配内存存储这些属性，如果需要这些属性直接读取即可。启动属性服务的主要代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">property_set_fd =create_socket(PROP_SERVICE_NAME ,SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,<span class="number">0666</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>); <span class="comment">//1</span></span><br><span class="line">...</span><br><span class="line">listen(property_set_fd, <span class="number">8</span>); <span class="comment">//2  </span></span><br><span class="line">register_epoll_handler(property_set_fd , handle_property_set_fd) ; <span class="comment">//3 </span></span><br></pre></td></tr></tbody></table></figure>

<p>由代码可知，首先创建非阻塞的Socket，并对property_set_fd 监听，这样创建的Socket 就成为server，也就是属性服务；listener的参数意味着可以同时为8个试图设置属性的用户服务。最后使用epoll 来监听property_set_fd ：<strong>当property_set_fd中有数据到来时，init进程将调用handle_property_set_fd函数处理。</strong></p>
<blockquote>
<p>epoll是linux下多路复用I/O接口，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU的利用率。</p>
</blockquote>
<p>对属性进行修改时，首先判断属性的合法性，之后查找属性，如果属性存在就更新属性值，否则添加属性。</p>
<h3 id="init进程启动总结"><a href="#init进程启动总结" class="headerlink" title="init进程启动总结"></a>init进程启动总结</h3><p>主要做了3件事：1、创建和挂载启动所需文件目录  2、启动服务属性  3、解析init.rc ，并启动 Zygote 进程。</p>
<h2 id="Zygote进程启动过程"><a href="#Zygote进程启动过程" class="headerlink" title="Zygote进程启动过程"></a>Zygote进程启动过程</h2><p>在Android系统中，DVM(或者ART)、应用程序进程、SystemServer进程等都是由Zygote进程创建的。由于Zygote在启动时会创建 DVM(或者ART)，因此其fork的应用程序进程和SystemServer进程可以在内部获取一个 DVM 或者 ART。</p>
<p>在Zygote 中通过 JNI 调用 ZygoteInit(<font color="#008000">ZygoteInit是由Java编写的</font>)的 main 方法后，Zygote 便进入了Java 框架层，<strong>此前没有任何代码进入Java框架层的。</strong>即Zygote开创了Java框架层。</p>
<p>ZygoteInit的main方法中主要代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/com/android/internal/os/Zygotelnit.java </span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//创建一个 Server 端的 Socket socketName 的值为"zygote"</span></span><br><span class="line">zygoteServer.registerServerSocket(socketName);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//预加载类和资源</span></span><br><span class="line">preload(b otT U.ngsTraceLog);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (startSystemServer) { </span><br><span class="line">    <span class="comment">//启动 SystemServer 进程</span></span><br><span class="line">    startSystermServer(abiList, socketName, zygoteServer);</span><br><span class="line">}</span><br><span class="line">／／等待 AMS 请求</span><br><span class="line">zygoteServer.runSelectLoop(abiList);</span><br></pre></td></tr></tbody></table></figure>

<p>由代码可知，通过 registerServerSocket 方法创建一个Server端的Socket ，<strong><font color="#008000">这个名为 “zygote” 的Socket 用于等待 ActivityManagerService 请求 Zygote 来创建新的应用程序进程</font></strong>。总结一下，ZygoteInit 的main方法总共做了4件事：</p>
<ol>
<li>创建一个Server端的Socket    </li>
<li>预加载类和资源    </li>
<li>启动 SystemServer 进程    </li>
<li>等待 AMS 请求创建新的应用程序进程    </li>
</ol>
<h3 id="Zygote-进程启动总结"><a href="#Zygote-进程启动总结" class="headerlink" title="Zygote 进程启动总结"></a>Zygote 进程启动总结</h3><p>Zygote进程启动共做了以下几件事：</p>
<ol>
<li>创建AppRuntime ，并调用其start方法，启动Zygote 进程    </li>
<li>创建java虚拟机并未Java虚拟机注册 JNI 方法    </li>
<li>通过 JNI 调用ZygoteInit 的main函数进入Zygote 的Java 框架层    </li>
<li>通过 registerServerSocket 创建服务端 Socket ，循环等待AMS 请求来创建新的应用程序进程。    </li>
<li>启动 SystemServer    </li>
</ol>
<h2 id="SystemServer-处理过程"><a href="#SystemServer-处理过程" class="headerlink" title="SystemServer 处理过程"></a>SystemServer 处理过程</h2><p>SystemServer 进程主要用于创建系统服务，如 AMS、WMS、PMS 。在 ZygoteInit.java 中启动了 SystemServer，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span> <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException｛</span></span><br><span class="line"><span class="function">    <span class="comment">//当前运行在 SystemServer 进程中</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(p == <span class="number">0</span>)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) {</span><br><span class="line">            waitForSecondaryZygote (socketName ); </span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//关闭 Zygote 进程创建的 Socket</span></span><br><span class="line">        zygoteServer . closeServerSocket() ; <span class="comment">//1 </span></span><br><span class="line">        handleSystemServerProcess(parsedArgs) ; <span class="comment">//2 </span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>由以上代码可知，SystemServer 进程复制了 Zygote 进程的地址空间，因此也会得到Zygote 创建的 server Socket，这个socket对SystemServer 没有用处，因此在代码 1处将其关闭，之后通过 handleSystemServerProcess 方法启动 SystemServer 进程。接下来，在ZygoteInit中<strong>创建了 PathClassLoader</strong>，并且通过native 方法 ZygoteInit.nativeZygotelnit <strong>启动了Binder线程池</strong>，之后进入 SystemServer 的main 方法。</p>
<p>SystemServer 的run 方法中用  SystemServiceManager 启动了  ActivityManagerService、 PackageManagerService 等服务。在PackageManagerService 创建完成后，将其注册到 ServiceManager 中，<font color="#008000">ServiceManager 用于管理系统中各种Service，用于系统C/S 架构中的Binder 通信机制：Client端要使用某个Service，需要先到 ServiceManager 中查询Service 的相关信息，然后与Service 所在的Server 进程建立通信通路，这样Client就可以使用Service 了</font>。</p>
<h3 id="SystemServer-进程总结"><a href="#SystemServer-进程总结" class="headerlink" title="SystemServer 进程总结"></a>SystemServer 进程总结</h3><p>SystemServer 进程被创建后，主要工作：</p>
<ol>
<li>启动Binder 线程池，这样可以与其他进程通信。    </li>
<li>创建 SystemServiceManager，创建和管理系统服务    </li>
<li>启动各种服务    </li>
</ol>
<h2 id="Launcher-启动过程"><a href="#Launcher-启动过程" class="headerlink" title="Launcher 启动过程"></a>Launcher 启动过程</h2><p>系统启动的最后一步是启动一个应用程序来显示系统中已经安装的应用程序，即 Launcher。Launcher 在启动过程中请求 PackageManagerService 获取系统中已经安装的应用程序信息，并且将信息封装成一个个快捷图标列表显示在系统屏幕上，用户就可以通过点击图标来启动相应的应用程序了。Launcher 的启动过程时序图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC2%E7%AB%A0/Launcher%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE.jpeg" alt="Launcher的启动过程时序图"></p>
<p>启动Launcher的入口方法为AMS 的systemReady 方法，该方法在SystemServer 的startOtherService中被调用，之后调用 ActivityStack 的resumeTopActivityUncheckedLocked 方法，ActivityStack 用于描述Activity 栈的。最终调用到 AMS 的 startHomeActivityLocked 方法，在该方法中，创建了 Launcher 启动所需的 Intent，并且在一系列判断后，将该Intent 的 Action 设置为 Intent.ACTION_MAIN 、Category 为 Intent.CATEGORY_HOME，并且在 Launcher 的AndroidManifest 中也是这么配置的。</p>
<p>经过以上操作，com.android.launcher3.Launcher 的Activity 就成为了主 Activity，此时，如果Launcher 还未启动，AMS 就会调用 ActivityStarter 的 startHomeActivityLocked 来启动 Launcher 。</p>
<h2 id="Android系统启动流程"><a href="#Android系统启动流程" class="headerlink" title="Android系统启动流程"></a>Android系统启动流程</h2><p>结合前面几节内容，可以总结出Android系统启动流程：</p>
<ol>
<li><p>启动电源以及系统启动     </p>
<blockquote>
<p>按下电源键，从预定义地方开始执行，加载BootLoader 到RAM。</p>
</blockquote>
</li>
<li><p>引导程序BootLoader     </p>
<blockquote>
<p>主要作用是拉起系统OS。</p>
</blockquote>
</li>
<li><p>Linux 内核启动      </p>
<blockquote>
<p>内核启动，设置缓存、计划表、加载驱动等，之后寻找 init.rc 文件，并启动init 进程。</p>
</blockquote>
</li>
<li><p>init 进程启动      </p>
<blockquote>
<p>初始化和启动属性服务，并启动 Zygote 进程。</p>
</blockquote>
</li>
<li><p>Zygote进程启动     </p>
<blockquote>
<p>创建Java虚拟机，并未Java虚拟机注册 JNI 方法，创建服务端 Socket 循环等待AMS 请求来创建新的应用程序进程</p>
</blockquote>
</li>
<li><p>SystemServer 进程启动     </p>
<blockquote>
<p>启动Binder 线程池 和 SystemServiceManager ，并启动各种服务。</p>
</blockquote>
</li>
<li><p>Launcher启动   </p>
<blockquote>
<p>SystemServer 进程启动的 AMS 会启动 Launcher，Launcher 会将已安装的应用显示到界面上。</p>
</blockquote>
</li>
</ol>
<p>用图表示就是：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC2%E7%AB%A0/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.jpeg" alt="Android系统启动流程图"></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/22/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E7%BD%91%E4%B8%8A%E6%90%9C%E9%9B%86%E7%9A%84%E9%A2%98%E7%9B%AE(%E4%B8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/22/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E7%BD%91%E4%B8%8A%E6%90%9C%E9%9B%86%E7%9A%84%E9%A2%98%E7%9B%AE(%E4%B8%80)/" class="post-title-link" itemprop="url">面试题-网上搜集的题目(一)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-22 15:00:00" itemprop="dateCreated datePublished" datetime="2019-11-22T15:00:00+08:00">2019-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-24 22:43:59" itemprop="dateModified" datetime="2020-03-24T22:43:59+08:00">2020-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="谈谈对this和super的认识"><a href="#谈谈对this和super的认识" class="headerlink" title="谈谈对this和super的认识"></a>谈谈对this和super的认识</h2><h2 id="闭包和内部类的区别"><a href="#闭包和内部类的区别" class="headerlink" title="闭包和内部类的区别"></a>闭包和内部类的区别</h2><h2 id="Java-多态实现的机制是什么"><a href="#Java-多态实现的机制是什么" class="headerlink" title="Java 多态实现的机制是什么"></a>Java 多态实现的机制是什么</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>重写和重载</p>
</details>

<h2 id="final-关键字的作用"><a href="#final-关键字的作用" class="headerlink" title="final 关键字的作用"></a>final 关键字的作用</h2><h2 id="多维数组在内存上是怎么存储的"><a href="#多维数组在内存上是怎么存储的" class="headerlink" title="多维数组在内存上是怎么存储的"></a>多维数组在内存上是怎么存储的</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Java 中的多维数组就是通过一维数组来实现的，只不过这个一维数组中的元素还是多维数组，比如如下声明：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>];  </span><br></pre></td></tr></tbody></table></figure>

<p>它实际上大致等同于如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][][];  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) {  </span><br><span class="line">  a[i] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length; j++) {  </span><br><span class="line">    a[i][j] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];  </span><br><span class="line">  }  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<p>以上代码参考自<a target="_blank" rel="noopener" href="https://www.iteye.com/blog/rednaxelafx-1050144">iteye中的博客</a></p>
<p>如果要自己用一维数组去实现二维(或者更多维)的数组，可以使用类似规律： k = j*(j-1)/2 + i -1 来计算出在一维数组中的下标 k 值。</p>
</details>

<h2 id="Java-的异常体系的理解"><a href="#Java-的异常体系的理解" class="headerlink" title="Java 的异常体系的理解"></a>Java 的异常体系的理解</h2><h2 id="运行时异常-与-非运行时异常"><a href="#运行时异常-与-非运行时异常" class="headerlink" title="运行时异常 与 非运行时异常"></a>运行时异常 与 非运行时异常</h2><h2 id="NIO-BIO-AIO"><a href="#NIO-BIO-AIO" class="headerlink" title="NIO/BIO/AIO"></a>NIO/BIO/AIO</h2><h2 id="Collection-与-Map-的区别"><a href="#Collection-与-Map-的区别" class="headerlink" title="Collection 与 Map 的区别"></a>Collection 与 Map 的区别</h2><h2 id="如何深拷贝List-集合"><a href="#如何深拷贝List-集合" class="headerlink" title="如何深拷贝List 集合"></a>如何深拷贝List 集合</h2><h2 id="Set-如何保证唯一性的"><a href="#Set-如何保证唯一性的" class="headerlink" title="Set 如何保证唯一性的"></a>Set 如何保证唯一性的</h2><h2 id="谈谈Java集合中那些线程安全的集合-amp-实现原理"><a href="#谈谈Java集合中那些线程安全的集合-amp-实现原理" class="headerlink" title="谈谈Java集合中那些线程安全的集合 &amp; 实现原理"></a>谈谈Java集合中那些线程安全的集合 &amp; 实现原理</h2><h2 id="Collection-和-Collections-的区别"><a href="#Collection-和-Collections-的区别" class="headerlink" title="Collection 和 Collections 的区别"></a>Collection 和 Collections 的区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Collection是接口，Collections 是帮助类，能实现排序(Collections.sort() )等功能</p>
</details>

<blockquote>
<p>以上题目参考自<a target="_blank" rel="noopener" href="https://gitee.com/ClAndEllen/AndroidFaceInterview?_from=gitee_search">gitee上博客</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/22/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/22/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">面试题-网络知识</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-22 15:00:00" itemprop="dateCreated datePublished" datetime="2019-11-22T15:00:00+08:00">2019-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-14 16:50:18" itemprop="dateModified" datetime="2021-03-14T16:50:18+08:00">2021-03-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1、TCP-IP-三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）"><a href="#1、TCP-IP-三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）" class="headerlink" title="1、TCP/IP 三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）"></a>1、TCP/IP 三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）</h2><p><strong>首先要会画 三次握手和四次挥手 的图。很重要，画了两次错了</strong></p>
<h3 id="3次握手的示意图如下："><a href="#3次握手的示意图如下：" class="headerlink" title="3次握手的示意图如下："></a>3次握手的示意图如下：</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p>
<p>三次握手过程：TCP发起的一方A，由操作系统生成一个序列号 n，以这个n为原点，对自己每个将要发送的数据进行编号，连接的另一方 B 会对A每次发送的数据进行确认，如果A收到B的确认编号2001，则可以认为 n~2000编号已经全部到达B。</p>
<h3 id="为什么三次握手"><a href="#为什么三次握手" class="headerlink" title="为什么三次握手"></a>为什么三次握手</h3><ol>
<li>首先，三次握手证明双方收发能力正常    </li>
<li>其次，如果只需要两次握手，那第二次(从server发到client端)之后server就分配资源了，但是如果第二次丢失了，那就造成资源浪费    </li>
<li>还有，如果client没有收到确认，就会再次发送握手连接，如果服务端先接到了第二个消息，然后发送返回确认，双方通信完毕，关闭。这时候第一个请求到了服务端，服务端确认，然而客户端已经关闭了，不理睬，这时候服务端只能一直等。    </li>
<li>还有，握手就确认了双方的序列号规则    </li>
</ol>
<h3 id="可以不握手吗？"><a href="#可以不握手吗？" class="headerlink" title="可以不握手吗？"></a>可以不握手吗？</h3><p>tcp实现可靠通信与 报文序号和确认号(ack) 是分不开的，我们知道握手是干的啥，其中就有告知初始序号的功能，所以不能不握手。</p>
<h3 id="4次挥手示意图："><a href="#4次挥手示意图：" class="headerlink" title="4次挥手示意图："></a>4次挥手示意图：</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p>
<p>由上图看出，由client端发起挥手，server给client的2次回复中，一次是确认信息ack，一次是数据的传送，那可不可以只要3次挥手呢？答案是可能的，TCP是全双工的，Client在没有数据需要发送给Server后，就发送FIN告知server，然后终止对server发送消息，但这个时候server还以发送数据给client，这时候需要4次；但是如果server收到client的FIN后再也没有数据要发给client了，那么 对client的ack包和server自己的FIN包就能合并成一个包发送过去，四次挥手变成3次。</p>
<p>了解完挥手完成后，可能还想更深入了解 TIME_WAIT，可以查看<a target="_blank" rel="noopener" href="https://glassx.github.io/2018/05/21/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0/">之前写的这篇</a>。</p>
<h2 id="2、延伸-握手可能有什么安全问题"><a href="#2、延伸-握手可能有什么安全问题" class="headerlink" title="2、延伸-握手可能有什么安全问题"></a>2、延伸-握手可能有什么安全问题</h2><p>首先，发起请求时候的序列是随机的，为什么是随机的呢？想想如果是固定的从0开始，那么客户端发送多次握手(重传)，那么，当新连接建立之后，如果上一次的请求再过来了，序列还是 0 ，那就乱了。相反，如果序列不固定，那么上一次的过来，我只要和新连接这里对比下 序列号 就知道是否合法了。</p>
<ul>
<li>client第一个 SYN 包丢失，这个无所谓，后续触发重传机制，隔5s，24s等     </li>
<li>server 收到 SYN ，但是回复的 SYN，ACK 丢失，也会触发重传，可能依次隔 3s,6s,12s 等    </li>
<li>client 最后依次发送的 ACK 丢了，server 因为没收到 ACK 而实现重传，但是client 已经进入 ESTABLISHED 状态了。因为多数情况下，client 发送完最后的 ACK之后，就认为连接建立，开始发送数据。现实中的情况是，在这种情况下 server 收到 client 的数据会进入 ESTABLISH 状态，并会认为数据有效。     </li>
<li>如果client 故意不发最后一次 ACK，那么服务端处于<strong>半连接状态</strong>，如果这种半连接很多的话，server 端很有压力，因为需要一直重传</li>
</ul>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102197175">知乎上的文章</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/85557012">知乎上的文章1</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/53658729/answer/498879547">知乎-泪花的回答</a>     </p>
</blockquote>
<h2 id="3、延伸-三次握手可以携带数据吗？"><a href="#3、延伸-三次握手可以携带数据吗？" class="headerlink" title="3、延伸-三次握手可以携带数据吗？"></a>3、延伸-三次握手可以携带数据吗？</h2><p>第一次、第二次不可以，第三次可以。想想为什么？</p>
<ul>
<li>假如第一次允许带数据，那么攻击者只需要在第一次SYN中放入大量数据，根本不考虑服务器接收能力，这会让server 花费很长时间和很多空间来处理这些报文       </li>
<li>并且，第一次不知道server 是否有接收能力；如果放第二次，server 也不知道clien 是否有接收能力。    </li>
</ul>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102197175">知乎上的文章</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/85557012">知乎上的文章1</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/53658729/answer/498879547">知乎-泪花的回答</a></p>
</blockquote>
<h2 id="4、引申——为什么要等待2MSL？"><a href="#4、引申——为什么要等待2MSL？" class="headerlink" title="4、引申——为什么要等待2MSL？"></a>4、引申——为什么要等待2MSL？</h2><p>原因有二：<strong>保证TCP协议的全双工连接能够可靠关闭</strong> 以及 <strong>保证这次连接的重复数据段从网络中消失</strong></p>
<p>第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p>
<p>第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p>
<h2 id="5、IP地址分类（A-B-C-D类）"><a href="#5、IP地址分类（A-B-C-D类）" class="headerlink" title="5、IP地址分类（A/B/C/D类）"></a>5、IP地址分类（A/B/C/D类）</h2><p>IP地址由四段组成，每个字段是一个字节，即4个字节、 每个字节有8位，最大值是255，IP地址 = 网络号+主机号。分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/ip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" alt="ip地址分类"></p>
<p>由图可知：</p>
<blockquote>
<p>A类：前1个字节(8位)为网络号，后3个字节(24位)为主机号。A类第1位必须是0<br>B类：前2个字节(16位)为网络号，后2个字节(16位)为主机号。B类前两位固定为10<br>C类：前3个字节(24位)为网络号，后1个字节(8位)为主机号。C类前3位固定为110<br>D类： 是多播地址，一般用于多路广播用户。该类IP地址的最前面为1110<br>E类： 是保留地址。该类IP地址的最前面为1111</p>
</blockquote>
<h2 id="6、TCP与UDP区别"><a href="#6、TCP与UDP区别" class="headerlink" title="6、TCP与UDP区别"></a>6、TCP与UDP区别</h2><ol>
<li>UDP发送数据前无需建立连接，TCP需要握手建立连接。    </li>
<li>UDP尽最大努力交付,不保证可靠交付；TCP提供可靠交付。    </li>
<li>UDP面向报文，对应用程序交下来的报文，在添加首部之后就交付给Ip层，不会对报文拆分；TCP面向字节流，会对应用程序的报文进行拆分。    </li>
<li>UDP支持一对一、一对多、多对一和多对一的通信；TCP全双工通信，并且只能点对点通信，允许通信双方在任何时候均能通信。    </li>
<li>UDP首部开销小，TCP开销大（UDP 8个字节，TCP20个字节）。    </li>
<li>UDP没有拥塞控制，在网络条件差的情况下发送端也不会降低发送速率；TCP有拥塞控制，慢开始避免拥塞，快重传、快恢复。  </li>
<li>TCP 通过滑动窗口实现流量控制，UDP 无。  </li>
</ol>
<p>需要参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/108822858">知乎上的讲解</a>)重写一下</p>
<h2 id="7、引申-TCP流量控制"><a href="#7、引申-TCP流量控制" class="headerlink" title="7、引申-TCP流量控制"></a>7、引申-TCP流量控制</h2><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p>
<p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.jpg" alt="tcp流量控制"></p>
<p>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。</p>
<p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p>
<h2 id="8、引申-快重传和快恢复"><a href="#8、引申-快重传和快恢复" class="headerlink" title="8、引申-快重传和快恢复"></a>8、引申-快重传和快恢复</h2><ul>
<li>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</li>
</ul>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E5%BF%AB%E9%87%8D%E4%BC%A0.webp" alt="快重传"></p>
<ul>
<li>快恢复：当发送方连续收到三个重复确认，就开始执行拥塞避免算法，缩小拥塞窗口，随后再使拥塞窗口缓慢地线性增大。</li>
</ul>
<h2 id="9、Http和Https的区别？"><a href="#9、Http和Https的区别？" class="headerlink" title="9、Http和Https的区别？"></a>9、Http和Https的区别？</h2><blockquote>
<p>Https是ssl加密传输，Http是明文传输<br>Https是使用端口443，而Http使用80<br>HttpsSSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比Http协议安全<br>Https协议需要到CA申请证书</p>
</blockquote>
<h2 id="10、中间人攻击"><a href="#10、中间人攻击" class="headerlink" title="10、中间人攻击"></a>10、中间人攻击</h2><p>带着下列问题去了解Https 安全性：</p>
<ul>
<li>为什么用了https 就是安全的？用了https就一定安全吗？    </li>
<li>https 的底层原理如何？    </li>
</ul>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="https的原理"><a href="#https的原理" class="headerlink" title="https的原理"></a>https的原理</h3><p>https的整体过程分为证书验证和数据传输阶段，具体交互如下图：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/https%E6%95%B4%E4%BD%93%E8%BF%87%E7%A8%8B.jpg" alt="https整体过程"></p>
<p>所以证书验证阶段流程就是：</p>
<ol>
<li>客户端发起https 请求     </li>
<li>服务端返回https 证书      </li>
<li>客户端验证证书是否合法</li>
</ol>
<p>数据传输阶段流程就是：</p>
<ol>
<li>证书合法后，在本地生成随机数    </li>
<li>通过公钥加密随机数，并把加密后的随机数传输给服务端    </li>
<li>服务端通过私钥对随机数解密     </li>
<li>服务端<strong>通过客户端传入的随机数构造对称加密算法</strong>，对返回结果内容进行加密后传输</li>
</ol>
<p>那我们再引申一下，为什么后来要使用对称加密传输数据。这是因为：</p>
<ul>
<li>非对称加密的效率低    </li>
<li>https 上述场景中，只有服务端保存了私钥，一对公私钥只能单向加解密，而对称加密可以实现双向的加解密</li>
</ul>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>了解以上原理之后，中间人攻击的具体流程如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="中间人攻击流程图"></p>
<p>主要包括以下步骤：</p>
<ol>
<li>本地请求被劫持(如dns劫持等)，所有请求均发送到中间人的服务器    </li>
<li>中间人<strong>返回自己自己的证书</strong>    </li>
<li>客户端创建随机数并通过中间人的证书公钥加密，之后凭随机数构造对称加密对传输内容加密    </li>
<li>中间人用私钥解密随机数，此时中间人拥有客户端的随机数，所以可以通过对称加密算法解密内容    </li>
<li>中间人再以客户端的请求内容向正规服务器发送请求，此时中间人发起的请求就是正规请求了，数据也是正规数据，所以合法，正规服务器会通过建立的安全通道返回加密数据      </li>
<li>此后流程都是合法化的了，中间人只是做了个转发而已     </li>
</ol>
<p>以上，就是中间人攻击的流程，我们日常使用的fiddler 代理，其实就很好地模拟了中间人攻击。因为我们使用fiddler 代理https 的时候，需要本地信任fiddler 的证书，其实就是中间人返回自己的证书过程，中间人攻击关键也是这一步。</p>
<p>一般客户端会验证证书的合法性，所以中间人的证书没有这么容易被信任，中间人攻击的难点也在这。</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/95293098">知乎-Java面试那些事儿</a></p>
</blockquote>
<h2 id="11、TCP-IP-流量控制，拥塞避免，可以结合这篇文章"><a href="#11、TCP-IP-流量控制，拥塞避免，可以结合这篇文章" class="headerlink" title="11、TCP/IP 流量控制，拥塞避免，可以结合这篇文章"></a>11、TCP/IP 流量控制，拥塞避免，可以结合<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486825&amp;idx=1&amp;sn=db596ed4b69bd9220f6a8ad79ef308db">这篇文章</a></h2><h2 id="12、Session-和-Cookie-的区别？"><a href="#12、Session-和-Cookie-的区别？" class="headerlink" title="12、Session 和 Cookie 的区别？"></a>12、Session 和 Cookie 的区别？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<p>HTTP是一种无状态的协议，为了分辨链接是谁发起的，Session和Cookie就是为解决这个问题而提出来的两个机制。<br><strong>Cookies是服务器下发，存储到本地机器上的一段文本，并随每一个请求发回服务器，是在客户端保持状态的方案。</strong><br>浏览器第一次发送请求时，服务器自动生成了一HashTable和一个Session ID来唯一标识这个HashTable，并将其通过响应发送回浏览器。Session的实现方式和Cookie有一定关系，一般会把session id存在Cookie中（<strong>也可以依赖于url重写</strong>），每次访问的时候将Session id带过去，服务器就根据id查找hashtable就可以识别当前用户状态了。<br>所以可以总结，cookie存在本地，session存在服务器；父路径不能享用子路径的cookies，而同一个session的窗口可以共享session；cookie没有session可靠。</p>
</blockquote>
</details>


<h2 id="13、在浏览器中输入www-baidu-com后执行的全部过程"><a href="#13、在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="13、在浏览器中输入www.baidu.com后执行的全部过程"></a>13、在浏览器中输入<a target="_blank" rel="noopener" href="http://www.baidu.com后执行的全部过程">www.baidu.com后执行的全部过程</a></h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ol>
<li><p>客户端浏览器通过DNS解析到<a target="_blank" rel="noopener" href="http://www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></p>
</li>
<li><p>在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</p>
</li>
<li><p>客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
</li>
<li><p>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p>
</li>
</ol>
</details>

<h2 id="14、HTTP中，POST与GET的区别"><a href="#14、HTTP中，POST与GET的区别" class="headerlink" title="14、HTTP中，POST与GET的区别"></a>14、HTTP中，POST与GET的区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ol>
<li><p>Get是从服务器上获取数据，Post是向服务器传送数据。</p>
</li>
<li><p>Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中科院看到。</p>
</li>
<li><p>Get传送的数据量小，不能大于2KB；post传送的数据量较大，一般被默认为不受限制。</p>
</li>
<li><p>根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p>
</li>
</ol>
</details>

<h2 id="15、http2-与http1-的区别"><a href="#15、http2-与http1-的区别" class="headerlink" title="15、http2 与http1 的区别"></a>15、http2 与http1 的区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>总结一下：1)、新的二进制格式  2)、多路复用   3)、header 压缩   4)、采用新的压缩算法  5)、server push  6)、更安全的SSL</p>
<ul>
<li>新的二进制格式    </li>
</ul>
<p><strong>解释：</strong> http1 设计的时候是基于文本，http2 基于二进制格式。http2 的格式定义更接近tcp层的方式，length 定义了整个frame 的开始到结束，type 定义了frame 的类型，stream id 用作流控制。如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.jpg" alt="http2格式变化"></p>
<p>虽然看上去写一个是和http1完全不同了，实际上并没有改变http1的语义，只是把http1的header 和 body 用frame 重新封装了一层而已。他们的对应关系如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E4%B8%8Ehttp1%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.jpg" alt="http2与http1对应关系"></p>
<p>上述http1的首部信息会封装到 Header 的 frame，而相应的 body 封装到 Data frame。</p>
<ul>
<li>多路复用    </li>
</ul>
<p><strong>解释：</strong>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。一个request对应一个 stream 并分配一个id，这样一个连接上可以有多个stream，每个stream 的frame 可以随机地混杂在一起，接收方可以根据stream id 将各个frame 再归属到不同的request 里面。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E8%BF%9E%E6%8E%A5%E5%85%B1%E4%BA%AB.jpg" alt="http2连接共享"></p>
<p>http 性能优化的关键并不在于<strong>高带宽</strong>，而是<strong>低延迟</strong>，tcp 连接会随着时间进行自我“调谐”，起初会限制最大速度，如果传输成功，会随着时间提高传输的速度，这种调谐称为“慢启动”。http2 通过让所有数据流共用同一个连接，可以更高效地使用TCP。</p>
<p>客户端依据域名来向服务器建立连接，一般pc端浏览器会针对单个域名的server 同时建立 6~8 个连接，<strong>连接无法复用会导致请求要经历三次握手和慢启动</strong>。在http1中，假如有5个连接同时发出，在第一个请求没有收到回复之前，后续从应用层发出的请求只能排队，请求2，3，4，5只能等请求1的response 回来之后才能逐个发出。网络通畅的时候性能影响不大，一旦请求1的request 因为什么原因没有抵达服务器，影响到后续所有的请求，问题就比较严重了。</p>
<ul>
<li>header 压缩    </li>
</ul>
<p><strong>解释：</strong>http2针对header 采用新的压缩方式，高效地压缩算法可以很大地压缩header。并且，通讯双方各自缓存一份 header fields 表，避免重复header 的传输。</p>
<ul>
<li>采用新的压缩算法</li>
</ul>
<p><strong>解释：</strong>http2在采用gzip之外的新的压缩算法，更加安全。</p>
<ul>
<li>server push</li>
</ul>
<p><strong>解释：</strong>http2 能通过push的方式将客户端需要的内容预先推送过去。</p>
<ul>
<li>更安全的SSL</li>
</ul>
<p><strong>解释：</strong>http2.0 对 tls 的安全性做了进一步加强。</p>
</details>
&gt; 以上内容参考自[知乎上的回答](https://www.zhihu.com/question/34074946)

<h2 id="16、网络状态码？以-2、3、4、5-开头的代表什么意思。"><a href="#16、网络状态码？以-2、3、4、5-开头的代表什么意思。" class="headerlink" title="16、网络状态码？以 2、3、4、5 开头的代表什么意思。"></a>16、网络状态码？以 2、3、4、5 开头的代表什么意思。</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="1xx-临时响应"><a href="#1xx-临时响应" class="headerlink" title="1xx-临时响应"></a>1xx-临时响应</h3><p>100： 继续。请求者应当继续提出请求<br>101： 切换协议。请求者要求服务器切换协议，服务器确认并准备切换   </p>
<h3 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx-成功"></a>2xx-成功</h3><p>200： 成功。服务器成功处理请求<br>201： 已创建。请求成功并且服务器创建了新的资源<br>202： 已接受。 服务器接受请求，但是尚未处理<br>203： 非授权信息。服务器成功处理请求，但返回的信息可能来自另一来源<br>204： 无内容。服务器成功处理请求，但是没有返回任何内容<br>205： 重置内容。服务器成功处理请求，但是没有返回任何内容<br>206： 部分内容。服务器成功处理了部分GET请求</p>
<h3 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx-重定向"></a>3xx-重定向</h3><p>300： 多种选择。服务器根据请求者选择一项操作，火提供操作列表供请求者选择<br>301： 永久移动。请求的资源永久移动到新位置了，返回此响应时会自动转到新位置<br>302： 临时移动。从不同位置响应请求，但是后续还是以原来位置继续请求<br>303： 查看其它位置。<br>304： 未修改。自上次请求后，请求的网页未修改过，此时不会返回网页内容<br>305： 使用代理。请求者只能使用代理访问请求的网页。    </p>
<h3 id="4xx-请求错误"><a href="#4xx-请求错误" class="headerlink" title="4xx-请求错误"></a>4xx-请求错误</h3><p>400： 错误请求。服务器不理解请求语法<br>401： 未授权。请求要求身份验证<br>403： 进制。服务器拒绝请求<br>404： 未找到。服务器找不到请求的网页<br>405： 方法禁用。禁用请求中指定的方法<br>408： 请求超时。服务器等候请求时发生超时<br>410： 已删除。请求的资源已永久删除<br>413： 请求实体过大。请求实体过大，服务器无法响应<br>414： 请求的URI过长。请求的URI（通常为网址）过长，无法处理<br>415： 不支持的媒体类型。</p>
<h3 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx-服务器错误"></a>5xx-服务器错误</h3><p>500： 服务器内部错误。服务器遇到错误，无法完成请求<br>501： 尚未实施。服务器不具备完成请求的功能<br>502： 错误网关。<br>503： 服务不可用。暂时地维护或者超载了<br>504： 网关超时。服务器作为网关或者代理，但是没有及时从上游服务器收到请求<br>505： HTTP版本不支持。服务器不支持请求中所用的HTTP协议版本   </p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="http://tool.chinaz.com/pagestatus/">站长工具</a> </p>
</blockquote>
<h2 id="17、HttpDNS"><a href="#17、HttpDNS" class="headerlink" title="17、HttpDNS"></a>17、HttpDNS</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="当前-DNS-系统存在的问题"><a href="#当前-DNS-系统存在的问题" class="headerlink" title="当前 DNS 系统存在的问题"></a>当前 DNS 系统存在的问题</h3><ul>
<li>域名缓存。运营商的 LocalDNS 会缓存域名解析的结果，而不是向权威域名发起递归。运营商缓存dns就可以实现把dns解析结果指向广告</li>
<li>解析转发。运营商自身不进行域名递归解析，而是把它发给其它运营商。一些小运营商就是这样做的。这样，比如说访问的是qq.com，则腾讯的权威dns收到的域名解析请求的来源就变成了其它运营商，最终导致用户流量被导向了错误的IDC，比如明明是广东的用户，被导向去了北京的服务器。    </li>
<li>NAT ，网络地址转换。运营商LocalDNS出口根据权威DNS目标ip进行NAT，导致腾讯权威dns无法正确识别运营商的 LocalDNS 的ip，引发域名解析错误，流量跨网等</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>使用 114 等中立DNS 服务器</p>
</li>
<li><p>使用HttpDNS，HttpDNS 的基本原理如下：</p>
</li>
</ul>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/HttpDNS%E5%8E%9F%E7%90%86.webp" alt="HttpDNS的原理"></p>
<p><strong>注意：HttpDNS主要用于客户端</strong></p>
<p>HttpDNS 的使用过程主要有两步：</p>
<ol>
<li>客户端直接访问HttpDNS 接口，获取Host对应的IP。     </li>
<li>客户端通过IP，向后台发送请求。以Http为例，通过在Header中指定host 字段，向HttpDNS 返回的IP 发送标准的Http请求即可。</li>
</ol>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/u6-53Kp9Jb48dKWzaJOKig">鹅厂网事上的博客</a></p>
</blockquote>
<h2 id="18、https的证书验证"><a href="#18、https的证书验证" class="headerlink" title="18、https的证书验证"></a>18、https的证书验证</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>证书是一级一级的验证的，验证当前的证书时，首先拿上一级的证书的公钥，用上一级的公钥来验证当前证书的签名，验证成功就通过，不成功就报错了。然后一级一级上去，顶级。因为本地(浏览器和操作系统)一般存有信任的根证书，顶级证书一般都能通过本地证书验证。</p>
</details>

<blockquote>
<p>以上内容可以参考<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/37370216">知乎上的内容</a></p>
</blockquote>
<h2 id="19、https的攻击方式"><a href="#19、https的攻击方式" class="headerlink" title="19、https的攻击方式"></a>19、https的攻击方式</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>1、中间人攻击。类似Fiddler 这种方式，前提是黑客通过某种特殊手段在被攻击者的手机上安装了根证书<br>2、Https协议降级攻击。比如说client端仅仅支持某个有漏洞的ssl版本(比如SSLv3.0)，那么服务端只能接收或者直接拒绝。如果接受的话，攻击者就能攻击(应该是 Padding Oracle 攻击)<br>3、使用对称加密的时候破解的对称加密</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/22917510">知乎的博客</a>、<a target="_blank" rel="noopener" href="https://blog.fundebug.com/2019/09/17/mitm-for-https/">中间人攻击</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/20/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/20/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">面试题-系统源码理解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-20 11:13:00" itemprop="dateCreated datePublished" datetime="2019-11-20T11:13:00+08:00">2019-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-18 17:28:02" itemprop="dateModified" datetime="2021-08-18T17:28:02+08:00">2021-08-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1、okhttp的理解"><a href="#1、okhttp的理解" class="headerlink" title="1、okhttp的理解"></a>1、okhttp的理解</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先看下okhttp 的整个工作流程：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/okhttp%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="okhttp工作流程"></p>
<ol>
<li>首先通过 Builder 创建 OkhttpClient 对象    </li>
<li>根据设定的条件，使用Request.Builder 构建request 对象      </li>
<li>根据 OkhttpClient 与 request 创建 RealCall     </li>
<li>不论是通过execute 还是enqueue 方式异步执行，最终都通过 getResponseWithInterceptorChain 方式获取Http 的返回结果           </li>
<li>步骤4中，通过Okio 封装的Socket 请求网络，并获取返回结果    </li>
</ol>
<p>Interceptor 是Okhttp 中最重要的一个东西，它不止拦截请求执行一些额外处理，实际上实际的网络请求、缓存、透明压缩等都是通过Interceptor 实现，它们一起连成 Interceptor.chain，每一个Interceptor 决定它自己能处理哪些事件，如果不能处理，则交给下一个Interceptor 处理，也就是<strong>责任链模式。</strong>这很类似View 中对点击事件的处理。</p>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="http://www.androidos.net.cn/book/android-road/android/open-source-framework/okhttp.html">okhttp 解析</a></p>
</blockquote>
<h3 id="okhttp有几种发起请求的方式？"><a href="#okhttp有几种发起请求的方式？" class="headerlink" title="okhttp有几种发起请求的方式？"></a>okhttp有几种发起请求的方式？</h3><p>两种，分别是：</p>
<ul>
<li>同步请求，将同步请求任务加入调度器的<strong>同步执行的双端队列</strong>（即runningSyncCalls，意为正在执行） ，然后直接调用 getResponseWithInterceptorChain 返回结果</li>
<li>异步请求，异步请求加入调度器，经历 readyAsyncCalls 和 runningAsyncCalls，之后调用 getResponseWithInterceptorChain</li>
</ul>
<blockquote>
<p>同主机任务最多支持5个并发，同时执行的任务不超过64个。注意，任务执行完成之后，不管同步还是异步，都会将任务从队列中清除</p>
</blockquote>
<h3 id="okhttp的interceptor怎么实现责任链？"><a href="#okhttp的interceptor怎么实现责任链？" class="headerlink" title="okhttp的interceptor怎么实现责任链？"></a>okhttp的interceptor怎么实现责任链？</h3><ul>
<li>实现 Interceptor接口，重写intercept方法    </li>
<li>做自己需要的处理，比如更改header之后需要重新builder出request，如果不涉及这块，可以不用重新build</li>
<li>使用chain.proceed(request)将请求传到给下一级，并且会有response返回</li>
<li>可以对response进行处理，比如根据response重试之类的，如果不做处理就将response作为结果抛给上一级处理</li>
</ul>
<h3 id="okhttp的调度器"><a href="#okhttp的调度器" class="headerlink" title="okhttp的调度器"></a>okhttp的调度器</h3><p>Dispatcher维护了三个队列，分别是： 同步正在执行队列、异步准备执行队列 以及 异步正在执行队列</p>
<h3 id="有哪些拦截器"><a href="#有哪些拦截器" class="headerlink" title="有哪些拦截器"></a>有哪些拦截器</h3><ul>
<li>CacheInterceptor：处理cache相关处理，如果本地有了可⽤的Cache，就可以在没有网络交互的情况下就返回缓存结果</li>
<li>addInterceptor(Interceptor)，就是我们自定义的一些拦截器，在所有的拦截器处理之前进行最早的拦截处理，比如一些公共参数，Header都可以在这里添加</li>
<li>ConnectInterceptor，这里主要就是负责建立连接了，会建立TCP连接或者TLS连接</li>
<li>networkInterceptors，这里也是开发者自己设置的，但是由于位置不同，所以用处也不同。<strong>这个位置添加的拦截器可以看到请求和响应的数据了，所以可以做一些网络调试</strong>。它对应  addNetworkInterceptor 方法</li>
<li>RetryAndFollowUpInterceptor，这里会对连接做一些初始化工作，以及请求失败的充实工作，重定向的后续请求工作</li>
<li>。。。<strong>未完待续，下次做笔记写完整</strong></li>
</ul>
<h3 id="okhttp的线程池怎么实现"><a href="#okhttp的线程池怎么实现" class="headerlink" title="okhttp的线程池怎么实现"></a>okhttp的线程池怎么实现</h3><p>查看Dispatcher类这个代码就可以知道：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get:Synchronized</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">"executorService"</span>) <span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line">    <span class="keyword">get</span>() {</span><br><span class="line">      <span class="keyword">if</span> (executorServiceOrNull == <span class="literal">null</span>) {</span><br><span class="line">        executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">            SynchronousQueue(), threadFactory(<span class="string">"<span class="variable">$okHttpName</span> Dispatcher"</span>, <span class="literal">false</span>))</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> executorServiceOrNull!!</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<p>将线程池的<strong>核心线程数设置为0</strong>；线程池容纳的最大线程数量为 Int.MAX_VALUE；超时时间设置为 60s ；队列设置为同步队列 SynchronousQueue ，先来先服务；</p>
<p><strong>OkHttp线程池设计为核心线程为0是因为客户端可能在一段时间内不会有网络请求，为了避免浪费不必要的线程内存，所以不保留最低线程，同时最大线程设置为Int.MAX_VALUE为了防止同一时间有大量的请求进入，造成部分请求被抛弃的问题，设置60秒为线程空闲最大时间，在一段时间不使用的情况进行线程回收。</strong></p>
<p>SynchronousQueue每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。因此队列内部其实没有任何一个元素，或者说容量为0。<strong>因此我们可以理解来了任务直接执行</strong>。</p>
<p>还有要注意的一点就是，如果异步请求中，runningAsyncCalls 的数量大于64后，就会加入到 readyAsyncCall 排队等待</p>
<h3 id="okhttp用到什么设计模式"><a href="#okhttp用到什么设计模式" class="headerlink" title="okhttp用到什么设计模式"></a>okhttp用到什么设计模式</h3><ul>
<li>责任链模式(拦截器)</li>
<li>建造者(比如 Request 就是通过建造者模式建造出来的)</li>
<li>工厂模式(比如CacheInterCeptor中的策略工厂 CacheStrategy.Factory)</li>
<li>单例模式</li>
</ul>
<blockquote>
<p>以上内容参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37700275/article/details/105044858">csdn</a>、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/16425e270dd1">简书</a>、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7cb9300c6d71">简书2</a></p>
</blockquote>
</details>

<h2 id="2、谈谈对RxJava的理解"><a href="#2、谈谈对RxJava的理解" class="headerlink" title="2、谈谈对RxJava的理解"></a>2、谈谈对RxJava的理解</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="常用操作符"><a href="#常用操作符" class="headerlink" title="常用操作符"></a>常用操作符</h3><ul>
<li>map：将被观察者发送的数据类型转换为其他类型    </li>
<li>flatMap ： 将事件序列中的元素整合，返回一个新的被观察者    </li>
<li>zip ： 将多个观察者事件整合发送给观察者</li>
</ul>
<h3 id="如何实现线程切换"><a href="#如何实现线程切换" class="headerlink" title="如何实现线程切换"></a>如何实现线程切换</h3><ul>
<li>Observer 最终会封装成 SubscribeTask ，这个类实现了 Runnable 接口。    </li>
<li>最终在 Runnable 的run 方法中完成 观察者-被观察者的订阅关系      </li>
<li>也即，这个run 在哪个线程执行，observer 方法就在哪个方法执行。     </li>
<li>如果是 AndroidSchedulers.mainThread 的话，则会以Android主线程的Looper(Looper.getMainLooper())新建一个 Handler ，之后将上述Runnable 封装成Message ，通过Handler 发送到主线程。     </li>
<li>如果是其他线程，则会丢给特定线程或者线程池处理。     </li>
</ul>
<blockquote>
<p>以上内容参考自： <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1408083">rxjava2线程切换原理</a>、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5213fe112fa9">rxjava使用与原理</a></p>
</blockquote>
</details>

<h2 id="3、fresco的理解"><a href="#3、fresco的理解" class="headerlink" title="3、fresco的理解"></a>3、fresco的理解</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="为什么使用fresco"><a href="#为什么使用fresco" class="headerlink" title="为什么使用fresco"></a>为什么使用fresco</h3><ol>
<li>部门决定采用webp 格式的图片，而fresco 对其支持           </li>
<li>5.0 以下Android系统，使用 ashmem(匿名共享内存) 区域存储bitmap ，它的创建、释放都不会触发 GC，带来良好的性能。   </li>
</ol>
<blockquote>
<p>fresco 使用ashmem 区域存储bitmap ，gc不会处理这块区域，并且也不会被”ashmem内置清除机制”回收，所以减少gc，提升性能。在ashmem 中，fresco 采用引用计数方式，自己管理内存。</p>
</blockquote>
<ol start="3">
<li>使用了三级缓存，方便图片快速复用、加载：Bitmap 缓存 + 未解码缓存 + 硬盘缓存，前面两个是内存缓存，Bitmap 根据不同系统版本存放不同区域(5.0以下存放ashmem)，未解码存放在堆内存。      </li>
<li>fresco 的设计，UIThread 只做从内存缓存中加载图片和显示图片两件事，其他诸如 图片Decode、缓存读写 都放在非 UI线程。      </li>
</ol>
<h3 id="fresco-原理解析"><a href="#fresco-原理解析" class="headerlink" title="fresco 原理解析"></a>fresco 原理解析</h3><p>典型的MVC模式应用：</p>
<ul>
<li>DraweeView ： view 层，负责显示图片。它继承ImageView 的目的是使用它来显示 drawable ，其他的ImageView 方法都没有使用，也不推荐使用。   </li>
<li>Hierarchy： model 层，负责生成要显示的图片     </li>
<li>DraweeController： controller 层     </li>
</ul>
<p>DraweeView 把获得event 转给 controller，controller 决定是否隐藏或者显示什么图像，而这些图像存储在 Hierarchy，最后 DraweeView 直接通过 getTopLevelDrawable 获取要显示的图像。</p>
<p>DraweeView 不直接与 Hierarchy 及 DraweeController 打交道，而是通过 DraweeHolder 间接与他们打交道，因为 DraweeHolder 管理着 Hierarchy 与 Controller。</p>
<h2 id="图片库的选择"><a href="#图片库的选择" class="headerlink" title="图片库的选择"></a>图片库的选择</h2><h3 id="Picasso"><a href="#Picasso" class="headerlink" title="Picasso"></a>Picasso</h3><p>自己没有实现缓存，配合 Okhttp 在 Okhttp里面实现缓存</p>
<p>优点：</p>
<ul>
<li>与Square系的库搭配较好，如okhttp、retrofit等</li>
<li>包小</li>
<li>功能简单</li>
</ul>
<h3 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h3><p>优点：</p>
<ul>
<li>支持webp、gif、video</li>
<li>支持Memory和Disk缓存</li>
<li>默认RGB_565，开销小</li>
</ul>
<h2 id="fresco"><a href="#fresco" class="headerlink" title="fresco"></a>fresco</h2><p>优点</p>
<ul>
<li><p>支持webp图片</p>
</li>
<li><p>native层缓存图片，减少oom</p>
</li>
<li><p>使用简单，几乎都能在xml上搞定</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>太大</li>
</ul>
<h3 id="fresco-图片切换原理"><a href="#fresco-图片切换原理" class="headerlink" title="fresco 图片切换原理"></a>fresco 图片切换原理</h3><p>DraweeHierarchy 内部维护着一个Drawable序列，这些个Drawable代表不同层次的图片，如果没有设置，这层Drawable就会为null，如果设置了但此时不应该展示它，比如 ActualImage 已经加载到了，不需要placeHold图片了，就把这层Drawable的 alpha 置为 0 。</p>
<p>准确地说是 FadeDrawable 中包含了上述的Drawable，在调用 FadeDrawable 的onDraw() 方法时，就会一层一层绘制，如果该层为null或者alpha为0，就不绘制，这样就实现了切换。</p>
<h3 id="关于Ashmem"><a href="#关于Ashmem" class="headerlink" title="关于Ashmem"></a>关于Ashmem</h3><p>Ashmem不能被Java应用直接处理，但是也有一些例外，图片就是其中之一.当你创建一张没有经过压缩的Bitmap的时候，Android的API允许你指定是否是可清除的:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">options.inPurgeable = <span class="keyword">true</span>;</span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeByteArray(jpeg, <span class="number">0</span>, jpeg.length, options);</span><br></pre></td></tr></tbody></table></figure>



<p>经过以上处理，当 Android 绘制系统在渲染这些图片，Android 的系统库就会把这些 Bitmap 从 Ashmem 堆中抽取出来，而当渲染结束后，这些 Bitmap 又会被放回到原来的位置。如果一个被抽取的图片需要再绘制一次，系统仅仅需要把它再解码一次，这个操作非常迅速。</p>
<p>Fresco 如何将图片放到Ashmem中？<strong>Ashmem一般在应用层是无法直接访问的，除了几个特例之外，其中之一就是 decode bitmap</strong>。我们可以通过设置BitmapFactory.Options.inPurgeable = true 来创建一个Purgeable Bitmap，这样decode出来的bitmap是在Ashmem内存中的，GC无法直接回收它。当Bitmap在使用时会被pin住，这样就不会被释放，使用完之后就unpin，这样系统在未来某个时刻会释放这部分内存。如果unpin的图片后续又要使用，就得再次decode，如果是在ui线程执行decode，就可能掉帧，因此google建议使用 inBitmap 来尝试使用已经存在的内存区域，而不是新分配区域，不过，要使用inBitmap ，必须要求二者有相同的解码格式，比如都是8888或者都是 565 的。</p>
<p>Fresco 为了让inPurgeable的bitmap不被自动unpinned，可以使用jni函数  AndroidBitmap_lockPixels()来强制pin bitmap，这样避免在unpinned之后，重新decode 这个Bitmap 而引起掉帧，不过这样就需要自己来管理这块空间了，我们可以使用 AndroidBitmap_unlockPixels 来让bitmap 重新变为 unpinned 状态。这样，系统在内存不足的时候，就可以回收这块内存了。Fresco使用Ashmem这块的知识点详细<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wytiger/p/5690039.html">参考这篇文章</a></p>
<blockquote>
<p>参考<a target="_blank" rel="noopener" href="http://blog.itpub.net/69952849/viewspace-2685599/">itpub</a>、<a target="_blank" rel="noopener" href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0402/2683.html">jcodeer</a>、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2bb77edb3011">简书</a></p>
</blockquote>
</details>

<h2 id="4、ThreadLocal-详解"><a href="#4、ThreadLocal-详解" class="headerlink" title="4、ThreadLocal 详解"></a>4、ThreadLocal 详解</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>ThreadLocal 很典型的一个用处就是存储线程的 Looper，我们知道，子线程中初始化Handler 的时候，需要先执行 Looper.prepare ，这个操作就是新建一个Looper 并且将其保存到 ThreadLocal 中。</p>
<p>Thread 类中有个专门存储线程的 ThreadLocal 数据的结构，即 ThreadLocal.Values 。保存值时，首先通过 Thread.currentThread 获取到当前线程，再获取该线程的 ThreadLocal.Values ，这个 Values 中有个 Object[] table 的数组，ThreadLocal 对象就存在这个数组中。每个 ThreadLocal 对象根据自己的 hashcode 按照一定规则获取到在数组中的 index ，之后进行读取或者存储。</p>
<p>这样，每个线程通过同一个 ThreadLocal 获取到的是不同的值。各个线程可以相互独立地执行操作。</p>
</details>

<blockquote>
<p>以上内容总结自源码，部分语言参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/singwhatiwanna/article/details/48350919">任玉刚的博客内容</a></p>
</blockquote>
<h2 id="5、LocalBroadcastManager"><a href="#5、LocalBroadcastManager" class="headerlink" title="5、LocalBroadcastManager"></a>5、LocalBroadcastManager</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>LocalBroadcastManager 注册本地广播<strong>只能通过代码，不能通过xml静态注册</strong>。本地广播不会跨进程，不用跟system_server 交互。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>首先，LocalBroadcastManager.getInstance 是个单例，在初始化过程中，会根据 mainLooper 创建一个Handler：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LocalBroadcastManager</span><span class="params">(Context context)</span> </span>{</span><br><span class="line">    mAppContext = context;</span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler(context.getMainLooper()) {</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) {</span><br><span class="line">                <span class="keyword">case</span> MSG_EXEC_PENDING_BROADCASTS:</span><br><span class="line">                    executePendingBroadcasts();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其次，注册过程，其实可以理解成订阅某种消息，以便在符合条件的消息发送的时候，这里能接收：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerReceiver</span><span class="params">(<span class="meta">@NonNull</span> BroadcastReceiver receiver, <span class="meta">@NonNull</span> IntentFilter filter)</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) {</span><br><span class="line">    	<span class="comment">//创建ReceiverRecord对象</span></span><br><span class="line">        ReceiverRecord entry = <span class="keyword">new</span> ReceiverRecord(filter, receiver);</span><br><span class="line">        <span class="comment">//mReceivers：数据类型为HashMap&lt;BroadcastReceiver, ArrayList&gt;， 记录广播接收者与IntentFilter列表的对应关系</span></span><br><span class="line">        ArrayList&lt;ReceiverRecord&gt; filters = mReceivers.get(receiver);</span><br><span class="line">        <span class="keyword">if</span> (filters == <span class="keyword">null</span>) {</span><br><span class="line">            filters = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">            mReceivers.put(receiver, filters);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        filters.add(entry);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;filter.countActions(); i++) {</span><br><span class="line">            String action = filter.getAction(i);</span><br><span class="line">            <span class="comment">//mActions：数据类型为HashMap&lt;String, ArrayList&gt;， 记录action与广播接收者的对应关系</span></span><br><span class="line">            ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action);</span><br><span class="line">            <span class="keyword">if</span> (entries == <span class="keyword">null</span>) {</span><br><span class="line">                entries = <span class="keyword">new</span> ArrayList&lt;ReceiverRecord&gt;(<span class="number">1</span>);</span><br><span class="line">                mActions.put(action, entries);</span><br><span class="line">            }</span><br><span class="line">            entries.add(entry);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着，发送广播，可以理解为，根据 sendBroadcast(Intent intent) 中 intent 的值获取 actions，再根据action 来查询相应的广播接收者，当然，如果当前receiver 正在处理其他广播，则跳过：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) {</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据Intent的action来查询相应的广播接收者列表</span></span><br><span class="line">        ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction());</span><br><span class="line">        <span class="keyword">if</span> (entries != <span class="keyword">null</span>) {</span><br><span class="line">        	<span class="comment">//用于存放与当前action匹配的receiver</span></span><br><span class="line">            ArrayList&lt;ReceiverRecord&gt; receivers = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;entries.size(); i++) {</span><br><span class="line">                ReceiverRecord receiver = entries.get(i);</span><br><span class="line">                <span class="keyword">if</span> (receiver.broadcasting) {</span><br><span class="line">                	<span class="comment">//当前receiver正在处理其他广播，则跳过</span></span><br><span class="line">                    <span class="keyword">continue</span>; </span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> match = receiver.filter.match(action, type, scheme, data,categories, <span class="string">"LocalBroadcastManager"</span>);</span><br><span class="line">                <span class="keyword">if</span> (match &gt;= <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (receivers == <span class="keyword">null</span>) {</span><br><span class="line">                        receivers = <span class="keyword">new</span> ArrayList&lt;ReceiverRecord&gt;();</span><br><span class="line">                    }</span><br><span class="line">                    receivers.add(receiver);</span><br><span class="line">                    receiver.broadcasting = <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (receivers != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;receivers.size(); i++) {</span><br><span class="line">                    receivers.get(i).broadcasting = <span class="keyword">false</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//创建相应广播，添加到mPendingBroadcasts队列</span></span><br><span class="line">                mPendingBroadcasts.add(<span class="keyword">new</span> BroadcastRecord(intent, receivers));</span><br><span class="line">                <span class="keyword">if</span> (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) {</span><br><span class="line">                    <span class="comment">//发送消息【见小节2.3.1】</span></span><br><span class="line">                    mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在 LocalBroadcastManager 的构造函数中我们初始化了这个以 mainLooper 建立的Handler，此时利用它 sendEmptyMessage，在handleMessage 中最终会调用 executePendingBroadcasts 方法（说明此函数也运行在主线程）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executePendingBroadcasts</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">        <span class="keyword">final</span> BroadcastRecord[] brs;</span><br><span class="line">        <span class="comment">//将mPendingBroadcasts保存到brs数组</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mReceivers) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mPendingBroadcasts.size();</span><br><span class="line">            <span class="keyword">if</span> (N &lt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            brs = <span class="keyword">new</span> BroadcastRecord[N];</span><br><span class="line">            mPendingBroadcasts.toArray(brs);</span><br><span class="line">            mPendingBroadcasts.clear();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//挨个回调相应广播接收者的onReceive</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;brs.length; i++) {</span><br><span class="line">            <span class="keyword">final</span> BroadcastRecord br = brs[i];</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> nbr = br.receivers.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;nbr; j++) {</span><br><span class="line">                <span class="keyword">final</span> ReceiverRecord rec = br.receivers.get(j);</span><br><span class="line">                <span class="keyword">if</span> (!rec.dead) {</span><br><span class="line">                    rec.receiver.onReceive(mAppContext, br.intent);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过以上的原理分析，我们知道本地广播只是在发送广播的时候，在主线程中挨个通知 action 符合的receiver，因此并不会超出进程范围，也不会超出 app 范围，只会在当前app 的当前进程发生。</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="http://gityuan.com/2017/04/23/local_broadcast_manager/">gityuan的分析</a></p>
</blockquote>
<h2 id="6、Java线程池ThreadPoolExecutor实现原理"><a href="#6、Java线程池ThreadPoolExecutor实现原理" class="headerlink" title="6、Java线程池ThreadPoolExecutor实现原理"></a>6、Java线程池ThreadPoolExecutor实现原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>ThreadPoolExecutor 构造函数参数非常多，有以下：</p>
<ul>
<li><p>corePoolSize： 通过 submit 或者 execute 提交任务时，如果当前线程池的线程数 n &lt; corePoolSize ，则创建一个新的线程处理任务，即使其他 core 线程是空闲的。    </p>
</li>
<li><p>maximumPoolSize: 如果当前线程数 n &gt; corePoolSize &amp;&amp; n &lt; maximumPoolSize ，那么不会创建新的线程；但是如果 n &gt;= maximumPoolSize 时，就会创建新的线程。如果是个无界队列(LinkedBlockingQueue)，那么不存在满的情况(n &gt;= maximumPoolSize),也就不会创建新线程。    </p>
</li>
<li><p>keepAliveTime: 如果当前线程池中的线程数 n &gt; corePoolSize,那么如果在 keepAliveTime 时间内没有新的任务需要处理，那么就会销毁 corePoolSize - n 个线程。    </p>
</li>
<li><p>handler ：异常处理策略。即当任务提交失败的时候，调用这个处理器。</p>
</li>
</ul>
<h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><p>ThreadPoolExecutor 使用一个 AtomicInteger 的前三位表示线程池状态，后 29 位表示线程数，因此是可以支持上亿的线程计数。线程池主要有几种状态：</p>
<ul>
<li>Running： 线程池正在运行，可以接收新任务。    </li>
<li>ShutDown： 不再接收新任务，但会继续处理队列中任务。    </li>
<li>Stop： 不接受新任务，也不处理队列中任务，并且<strong>中断正在处理的任务</strong>    </li>
<li>Tidying： 所有任务处理玩，线程数为 0(线程池为空)    </li>
<li>Terminated： 已经执行完毕(执行了 terminated)    </li>
</ul>
<p>submit 执行过程 就是将 Runnable 和 Callable 封装成 RunnableFuture 之后，最终提交给execute 执行。使用 HashSet 类型的 worker 来存储正在运行的任务，只要 worker.size() &lt; corePoolSize，提交新的任务就马上开启新线程执行(上面提到过)。在提交过程中要检查线程池的状态，检查是否关闭了。</p>
<p>worker的数目也是通过 CAS的方式 增减的。</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://github.com/aCoder2013/blog/issues/28">github上的博客</a></p>
</blockquote>
<h2 id="7、延伸-Java-线程池的异常处理机制"><a href="#7、延伸-Java-线程池的异常处理机制" class="headerlink" title="7、延伸-Java 线程池的异常处理机制"></a>7、延伸-Java 线程池的异常处理机制</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>如果是使用submit 提交的话，可以通过继承 ThreadPoolExecutor 再重写 afterExecute 方法，得到实际的异常 (包含 Runnable 和 Throwable)    </li>
<li>如果是调用的execute 方法提交的话，那就会抛到 dispatchUncaughtException 里面去了，这时候我们只有对线程 Thread.setUncaughtExceptionHandler(UncaughtExceptionHandler)  来捕捉。即自己写 ThreadFactory (thread 工厂类),并为创建的线程 setUncaughtExceptionHandler       </li>
<li>还有一种，就是对 Runnable 的 run 方法里面整个 try-catch    </li>
</ul>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="http://ifeve.com/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/">并发编程网</a> 或者它<a target="_blank" rel="noopener" href="https://github.com/aCoder2013/blog/issues/3">在github上的相同文章</a></p>
</blockquote>
<h2 id="8、AsyncTask-解析"><a href="#8、AsyncTask-解析" class="headerlink" title="8、AsyncTask 解析"></a>8、AsyncTask 解析</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>AsyncTask 是个抽象类，必须子类实现才能使用。在构建的时候，需要指定三个泛型参数类型，分别是 Params、Progress、Result ，即类似 AsyncTask&lt;Integers, Integers, ResponseBean&gt; ，当然，如果某个参数不需要，类型可以写成 Void 。</p>
<p>其整体原理还是 将task丢给ThreadPool 在子线程执行，得到结果后，通过 Handler 的 sendEmptyMessage 的方式将结果切换到主线程</p>
<p>在 AsyncTask 使用的过程中需要遵守如下原则：</p>
<ul>
<li>必须在UI线程中实例化             </li>
<li>execute 必须在UI线程中调用                </li>
<li>不要人为调用 onPreExecute、onPostExecute、doInBackground 和 onProgressUpdate               </li>
<li>一个 AsyncTask 实例只能执行一次，如果多次调用会报异常                  </li>
</ul>
<p>AsyncTask 中有 <strong>static</strong> 的 ThreadPool ，<strong>意味着不管有多少个实例，都只有这个线程池</strong>，而在初始化这个线程池的时候，corePoolSize 在不同版本的值默认被设置为 1 或者 5 (Android 3.0以前是5，还不能改；3.0之后设置为1，但是可以自己设置Excutor )，并且 BlockingQueue 基本上是个无界队列(BlockingQueue 或 SynchronousQueue，队列不存在满的情况)，根据 ThreadPool 的原理，我们每次最多只有一个线程或者 5 个线程在执行，<strong>意味着多的任务就要排队，并不能实时执行</strong>，并且在早期，我们不能设置自定义的 ThreadPoolExcutor，到后来才可以(貌似是Android 4.0以后)。</p>
<p>AsyncTask 存在的问题：</p>
<ol>
<li>AsyncTask 对象只能execute 一次，多次请求会导致多个对象创建          </li>
<li>生命周期与Activity 的生命周期不一致，有可能导致内存泄露           </li>
<li>cancle 并不马上生效，因为它就是线程，在cancle之后，还得等它完成           </li>
</ol>
</details>

<blockquote>
<p>以上内容参考自 系统源码、<a target="_blank" rel="noopener" href="http://zmywly8866.github.io/2015/09/29/android-call-asynctask-excute-not-run.html">github上的博客</a>、<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yanyojun/p/6414919.html">cnblogs的博客</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43507738/article/details/83418989">csdn的博客</a></p>
</blockquote>
<h2 id="9、阿里Alpha原理"><a href="#9、阿里Alpha原理" class="headerlink" title="9、阿里Alpha原理"></a>9、阿里Alpha原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>想象下有以下场景： </p>
<p>有6个任务需要在Application里面执行，其中Task1，Task4，Tas6需要在主线程执行，Task2，Task3需要在Task1执行完才能执行，Task4，Task5需要Task2和Task3执行完才能执行，Task6需要Task4和Task5执行完才能执行，Task4的耗时要大于Task5，是不是顿时就乱了？其实可以通过 PERT 图来捋一捋这个关系，涉及到具体实现的话，可以参考阿里巴巴的 alpha 框架。</p>
<p>Alpha是一个<strong>基于PERT图</strong>构建的Android异步启动框架</p>
<p>首先解决多进程疑惑，在start方法中就首先判断了 <strong>主进程任务、非主进程任务 以及 适用于所有进程的任务</strong>，这些任务是通过 public void addProject(Task project, int mode) 方法添加进去的。</p>
<p>在实际情况中，可能会有多个任务同时开始，并且也有可能多个任务作为结束节点，所以为了<strong>方便控制整个流程</strong>，alpha 设计了startTask 和 finishTask，标记流程的开始和结束，方便任务的监听</p>
<p>如果Task 是在主线程执行的，那么就通过Handler 将时间传递给主线程；如果是非主线程，则通过线程池去执行。</p>
<p>在一个Task执行完成后，就会遍历自己持有的 <strong>mSuccessorList(紧后任务列表，也就是当前任务执行完成之后可以执行的Task列表，这里面的Task会根据Priority进行排序)</strong>，并依次执行里面元素的 onPredecessorFinished 方法。</p>
<p>mSuccessorList 列表中的Task 是通过 after 方法加入的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//紧后任务添加</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">after</span><span class="params">(Task task)</span> </span>{</span><br><span class="line">    task.addSuccessor(mCacheTask);</span><br><span class="line">    mFinishTask.removePredecessor(task);</span><br><span class="line">    mIsSetPosition = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要操作在这个方法里</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSuccessor</span><span class="params">(Task task)</span> </span>{</span><br><span class="line">    <span class="comment">//task 添加紧前任务</span></span><br><span class="line">    task.addPredecessor(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//真正添加为紧后任务</span></span><br><span class="line">    mSuccessorList.add(task);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>意思是Task2要在Task1后面执行，这样，Task2就是Task1的紧后任务，同理，Task1也成了Task2的紧前任务，那这个紧前任务有什么用呢？试想一下，如果Task1、Task2、Task3的紧后任务都是 Task4，那么，在Task1执行完成之后，还要判断 Task2和Task3是否执行完成，然后才能决定是否执行Task4，这就是紧前任务的作用了。</p>
</details>

<blockquote>
<p>以上文章主要参考自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuzhengisme/article/details/106996006">积木zz的csdn博客</a>, 有博客说，使用 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/163014950">Anchors</a> 比使用 Alpha 更精细，后续再看</p>
</blockquote>
<h2 id="10、LeakCanary-原理"><a href="#10、LeakCanary-原理" class="headerlink" title="10、LeakCanary 原理"></a>10、LeakCanary 原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>原理：</p>
<ol>
<li>通过registerActivityLifecycleCallbacks 来监听 Activity 的生命周期 onActivityDestroyed。    </li>
<li>即 lifecycleCallbacks 监听Activity 的 onDestroy 方法，正常情况下执行了onDestroy 后资源立即回收。    </li>
<li>监察机制利用了 WeakReference 和 ReferenceQueue ，使用 WeakReference 对Activity 进行引用，在Activity回收的时候，就会将该WeakReference 引用放到 ReferenceQueue 中。     </li>
<li>在onDestroy 之后，等待一段时间，再通过监测 ReferenceQueue 是否包含 WeakReference 就能检查 Activity 是否被正确回收。    </li>
<li>如果Activity 没有被回收，就手动 GC 一次，等待若干时间，之后再次判断Activity 是否被回收，若未被回收，说明 Activity 已经泄露。    </li>
<li>如果Activity 泄露了，则抓取 dump 信息显示出来。</li>
</ol>
<p>以上要注意的是：</p>
<p>1、是使用<strong>WeakReference</strong>对Activity进行引用<br>2、LeakCanary可以配置<strong>忽略</strong>某些路径的内存泄漏<br>3、手动GC是使用的 Runtime.getRuntime().gc() 实现，代码中解释是这样触发gc的概率会比System.gc() 高一些: System.gc() does not garbage collect every time. Runtime.gc() is more likely to perform a gc.<br>4、 当Activity对象被回收时，会将 <strong>WeakReference(而不是Activity)对象</strong>放入 ReferenceQueue 中，自己写的测试代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> RecyclebleObject testObject;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;RecyclebleObject&gt; objectWeakReference;</span><br><span class="line">    <span class="keyword">private</span> ReferenceQueue&lt;RecyclebleObject&gt; referenceQueue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        testObject = <span class="keyword">new</span> RecyclebleObject();</span><br><span class="line">        referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        objectWeakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(testObject, referenceQueue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TextView btnClick = findViewById(R.id.click_view);</span><br><span class="line"></span><br><span class="line">        btnClick.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{</span><br><span class="line">                <span class="keyword">if</span> (testObject == <span class="keyword">null</span>) {</span><br><span class="line">                    testObject = <span class="keyword">new</span> RecyclebleObject();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                Log.e(<span class="string">"NullTest"</span>, <span class="string">"testObject = "</span> + testObject);</span><br><span class="line">                Log.e(<span class="string">"NullTest"</span>, <span class="string">"referenceQueue 中的内容： "</span> + referenceQueue.poll());</span><br><span class="line">                testObject = <span class="keyword">null</span>;</span><br><span class="line">                Runtime.getRuntime().gc();</span><br><span class="line"></span><br><span class="line">                btnClick.postDelayed(<span class="keyword">new</span> Runnable() {</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                        Log.e(<span class="string">"NullTest"</span>, <span class="string">"GC 后，testObject = "</span> + testObject);</span><br><span class="line">                        Reference result = referenceQueue.poll();</span><br><span class="line">                        Log.e(<span class="string">"NullTest"</span>, <span class="string">"GC 后，referenceQueue 的内容： "</span> + result + <span class="string">",这个对象与objectWeakReference 相等吗？ "</span> + (result == objectWeakReference));</span><br><span class="line">                    }</span><br><span class="line">                }, <span class="number">1000</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码将会打印出以下结果：</p>
<blockquote>
<p>testObject = com.example.myapplication.RecyclebleObject@86f4db5<br>referenceQueue 中的内容： null<br>GC 后，testObject = null<br>GC 后，referenceQueue 的内容： java.lang.ref.WeakReference@f6c4a,这个对象与objectWeakReference 相等吗？ true     </p>
</blockquote>
<p>说明在回收后， WeakReference 对象会出现在 referenceQueue 中，而不是 testObject 本身出现在 referenceQueue  。</p>
<hr>
<p>有意思的是，在 LeakCanary2 时，并不需要接入者手动初始化(LeakCanary.install(this);)了，而是只需要引入即可。其根本原理是：<strong>LeakCanary 写了个 ContentProvider 并在 AndroidManifest中注册了，并在 ContentProvider 的onCreate方法中执行了 install 操作！</strong>我们知道，ContentProvider 的 onCreate 方法会在启动App的时候自动执行，并且比 Application 的 onCreate 方法还要早，因此它自动执行完全没问题。</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/261e70f3083f">JasmineBen的博客</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/braintt/article/details/99685243">CSDN上的博客</a>、以及自己写的代码验证</p>
</blockquote>
<h2 id="11、Toast显示流程"><a href="#11、Toast显示流程" class="headerlink" title="11、Toast显示流程"></a>11、Toast显示流程</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先，为了避免Toast显示冲突，会将要显示的Toast放在队列中，然后依次取出来展示</p>
<ol>
<li>makeText的时候，创建Toast对象和TN对象，Toast创建好后，加载布局，创建mNextView，然后 TN 是控制Toast的显示和隐藏以及取消的，它里面有个 Handler ，以当前线程的Looper来初始化，Toast的显示隐藏取消就是通过这个Handler来处理的。        </li>
<li>Toast对象创建完成就 enqueueToast 到NotificationManagerService 进程中去排队的(所以这中间是有跨进程通信这个概念的)，在中间会判断是否要显示这个Toast(如果此Toast正在取消或者隐藏就不展示了)，接着就开始排队，显示的话，就是不断从队列里面取出 ToastRecord ，然后调用 Toast对应的TN 的show 方法展示Toast。</li>
<li>TN收到显示的消息，创建WindowManager对象，然后将第一步创建的 View 添加到 WindowManager ，之后Toast 就显示出来了。          </li>
</ol>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/Android%E5%9F%BA%E7%A1%80/Toast%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B.webp" alt="Toast显示流程"></p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7177360e3f63">简书上的博客</a></p>
</blockquote>
<h2 id="12、onTouchListener、onTouchListener-的onTouch方法、onTouchEvent、onClickListener、onLongClickListener-的执行顺序？"><a href="#12、onTouchListener、onTouchListener-的onTouch方法、onTouchEvent、onClickListener、onLongClickListener-的执行顺序？" class="headerlink" title="12、onTouchListener、onTouchListener 的onTouch方法、onTouchEvent、onClickListener、onLongClickListener 的执行顺序？"></a>12、onTouchListener、onTouchListener 的onTouch方法、onTouchEvent、onClickListener、onLongClickListener 的执行顺序？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>dispatchTouchEvent 在 onTouchListener 之前发生，如果在 dispatchTouchEvent 的 down 事件就return 了 false，则后续的事件压根就不会传过来了，所以不会有什么故事。        </li>
<li>但如果 down 事件返回了 true ，则事件虽然onTouchListener 和 onTouchEvent 会发生，但不会有点击事件了，即onLongClick 和 onClick 都不会响应了。    </li>
<li>onTouchListener 在onTouchEvent 之前发生， onLongClick 与 onClick 依赖于是在onTouchEvent 里面发生的，也就是说 click 事件是在 onTouchEvent 之后执行，并且 onClick 在 onLongClick 之后执行。        </li>
<li>如果在 onTouchListener 的 onTouch 方法中返回true，则没有后面的 onTouchEvent 什么事了，更别提 click 事件        </li>
<li>在onTouch 发生后，如果直接在 onTouchEvent 中返回true 或者false ，那就没有 click 什么事情了（因为click 是在super.onTouchEvent中）    </li>
<li>如果TouchEvent 不做处理，那么在down事件发生后长按，则会响应 onLongClick 事件，之后up，如果之前的 onLongClick 返回false ，则还会接着 onClick，反之，如果之前的 onLongClick 返回true，则 onClick 不会执行。     </li>
</ul>
</details>

<blockquote>
<p>以上内容来自自己的实验，以及<a target="_blank" rel="noopener" href="https://blog.csdn.net/qiantanlong/article/details/82017462">csdn上的博客1</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/wang_k516/article/details/52849565">csdn上的博客2</a></p>
</blockquote>
<h2 id="13、Android-事件中-CANCLE-事件是怎么来的？它的作用是啥？"><a href="#13、Android-事件中-CANCLE-事件是怎么来的？它的作用是啥？" class="headerlink" title="13、Android 事件中 CANCLE 事件是怎么来的？它的作用是啥？"></a>13、Android 事件中 CANCLE 事件是怎么来的？它的作用是啥？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>第一个问题：我们知道view如果处理了 Down 事件，则随之而来的 Move 和 Up 事件也会交给它处理，但是交给它处理之前，父View 可以拦截，如果被拦截了，就会返回 Cancel 事件，并且不会收到后续的 Move 和 Up 事件</p>
<p>第二个问题：</p>
</details>

<blockquote>
<p>以上内容参考自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/cufelsd/article/details/89471402">csdn上的博客</a></p>
</blockquote>
<h2 id="14、Handler-解析"><a href="#14、Handler-解析" class="headerlink" title="14、Handler 解析"></a>14、Handler 解析</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Handler 有多个构造函数，看下图：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/Handler.png" alt="Handler构造函数"></p>
<p>这些参数有几个需要解释下，callback：用于控制消息执行顺序的，具体参看Handler 的 dispatchMessage 方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) {</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在执行时，如果 msg 设置了 callback，则优先执行，接下来，如果Handler 有设置了 callback ，则执行这个callback ，最后才是我们熟悉的 handleMessage 方法。因此，我们说 这个 callback 是控制执行顺序的。</p>
<p>Looper 参数表明的是，Handler 将在哪个线程执行，使用哪个线程的。</p>
<p>boolean 类型的 async 值是指 Handler 是否发送异步消息，这个异步消息要配合<strong>消息屏障</strong>使用。首先设置了消息屏障，之后 Looper 中只会执行异步消息了，直到消息屏障被 remove 。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                    <span class="keyword">do</span> {</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    } <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                    </span><br><span class="line">                    ...</span><br><span class="line">                    </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="15、ViewStub源码解析"><a href="#15、ViewStub源码解析" class="headerlink" title="15、ViewStub源码解析"></a>15、ViewStub源码解析</h2><p>首先，在构造函数里面有两个点值得关注：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewStub</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>{</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//置为不可见</span></span><br><span class="line">        setVisibility(GONE);</span><br><span class="line">        <span class="comment">//置为不会draw</span></span><br><span class="line">        setWillNotDraw(<span class="keyword">true</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>构造方法里面就直接将ViewStub置为不可见，并且，设置为不会 draw ，因为ViewStub本身不展示，所以无需 draw 。然后，我们一般都是通过inflate 或者 setVisibility 来设置ViewStub的可见性：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisibility</span><span class="params">(<span class="keyword">int</span> visibility)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mInflatedViewRef != <span class="keyword">null</span>) {</span><br><span class="line">        View view = mInflatedViewRef.get();</span><br><span class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span>) {</span><br><span class="line">            view.setVisibility(visibility);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"setVisibility called on un-referenced view"</span>);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">super</span>.setVisibility(visibility);</span><br><span class="line">        <span class="keyword">if</span> (visibility == VISIBLE || visibility == INVISIBLE) {</span><br><span class="line">            inflate();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//获取VIewStub的parent</span></span><br><span class="line">    <span class="keyword">final</span> ViewParent viewParent = getParent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewParent != <span class="keyword">null</span> &amp;&amp; viewParent <span class="keyword">instanceof</span> ViewGroup) {</span><br><span class="line">        <span class="keyword">if</span> (mLayoutResource != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">final</span> ViewGroup parent = (ViewGroup) viewParent;</span><br><span class="line">            <span class="comment">//也就是 .inflate(mLayoutResource, parent, false) 最后一个参数为false</span></span><br><span class="line">            <span class="keyword">final</span> View view = inflateViewNoAdd(parent);</span><br><span class="line">            replaceSelfWithView(view, parent);</span><br><span class="line"></span><br><span class="line">            mInflatedViewRef = <span class="keyword">new</span> WeakReference&lt;&gt;(view);</span><br><span class="line">            <span class="keyword">if</span> (mInflateListener != <span class="keyword">null</span>) {</span><br><span class="line">                mInflateListener.onInflate(<span class="keyword">this</span>, view);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"ViewStub must have a valid layoutResource"</span>);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ViewStub must have a non-null ViewGroup viewParent"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由以上代码可以看到，调用 setVisibility 时，如果以前有inflate出来真正的 view 了，那就直接对这个 view.setVisibility ;否则，如果 setVisibility 为 visible 或者 invisible ，都会触发 inflate 操作。</p>
<p>inflate 操作，如果没有指定真正的 view 的布局id (mLayoutResource)，那会抛出异常，之后，将真正的 view 以 ViewStub的parent 作为 parent 先inflate 出来，接下来 replaceSelfWithView 其实就是将真正的 view 替换到原来 viewstub的位置(位置 index 和布局参数 layoutparams 都拿过去)，而 原来的 ViewStub 会被remove 掉：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceSelfWithView</span><span class="params">(View view, ViewGroup parent)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = parent.indexOfChild(<span class="keyword">this</span>);</span><br><span class="line">    parent.removeViewInLayout(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewGroup.LayoutParams layoutParams = getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (layoutParams != <span class="keyword">null</span>) {</span><br><span class="line">        parent.addView(view, index, layoutParams);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        parent.addView(view, index);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="为何无大小不绘制"><a href="#为何无大小不绘制" class="headerlink" title="为何无大小不绘制"></a>为何无大小不绘制</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>{</span><br><span class="line">    setMeasuredDimension(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>从源码可以直接看到，在 onMeasure 中，直接 setMeasuredDimension(0, 0) 即宽和高都变为  0 了，并且draw 和 dispatchDraw 都是空方法。</p>
<h3 id="能inflate多次吗"><a href="#能inflate多次吗" class="headerlink" title="能inflate多次吗"></a>能inflate多次吗</h3><p>还是看inflate 的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ViewParent viewParent = getParent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewParent != <span class="keyword">null</span> &amp;&amp; viewParent <span class="keyword">instanceof</span> ViewGroup) {</span><br><span class="line">       ...</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ViewStub must have a non-null ViewGroup viewParent"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>能够看到，inflate 的时候，这里会获取 ViewStub 自己的 parent，然后呢，会判断  <strong>viewParent != null</strong>，由于前面说了，inflate 的时候已经将 ViewStub 从patent 中移除，所以这里肯定为 null ，因此，这就会报错啦。<strong>所以我们只能inflate一次</strong></p>
<blockquote>
<p>以上内容参考AS打开的源码，以及<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37700275/article/details/103180521">CSDN</a>上的观点</p>
</blockquote>
<h2 id="16、事件传递顺序"><a href="#16、事件传递顺序" class="headerlink" title="16、事件传递顺序"></a>16、事件传递顺序</h2><p>首先，由源代码可知：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>{  </span><br><span class="line">    <span class="keyword">if</span> (mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  </span><br><span class="line">            mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) {  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(event);  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先执行 dispatchTouchEvent ，其次 执行 OnTouchListener.onTouch，如果返回true ，则不会执行后续的 onTouchEvent 了</p>
<p>其次，看 onTouchEvent 的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>{  </span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) {  </span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:  </span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent){</span><br><span class="line">                    <span class="comment">// This is a tap, so remove the longpress check</span></span><br><span class="line">                    removeLongPressCallback();</span><br><span class="line">                    ...</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) {</span><br><span class="line">                        mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                    }</span><br><span class="line">                   </span><br><span class="line">                    <span class="comment">//触发OnClick事件</span></span><br><span class="line">                    <span class="keyword">if</span> (!post(mPerformClick)) {</span><br><span class="line">                        performClick();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:  </span><br><span class="line">                   <span class="keyword">if</span> (isInScrollingContainer) {</span><br><span class="line">                       ...</span><br><span class="line">                   } <span class="keyword">else</span> {</span><br><span class="line">                      <span class="comment">// Not inside a scrolling container, so show the feedback right away</span></span><br><span class="line">                      setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                      <span class="comment">// 触发事件</span></span><br><span class="line">                      checkForLongClick(<span class="number">0</span>, x, y);</span><br><span class="line">                  }</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            ...</span><br><span class="line">        }  </span><br><span class="line">        <span class="comment">//如果该控件是可以点击的，就一定会返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    }  </span><br><span class="line">    <span class="comment">//如果该控件是不可以点击的，就一定会返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由此可知，onLongClickListener 、onClickListerner 都是在 onTouchEvent 中触发的，前者是在DOWN事件中触发，后者是在UP事件中触发。如果 onLongClickListener  执行了，onClickListerner 就不会执行。</p>
<p>综上，dispatchTouchEvent -&gt; onTouchListener -&gt; onTouchEvent -&gt; onLongClick -&gt; onClick 的顺序</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gucun4848/article/details/53487504">参考这</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37700275/article/details/93200473">这里</a></p>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/19/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC1%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/19/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC1%E7%AB%A0/" class="post-title-link" itemprop="url">第1章：Android系统架构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-19 22:26:00" itemprop="dateCreated datePublished" datetime="2019-11-19T22:26:00+08:00">2019-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-04 11:33:01" itemprop="dateModified" datetime="2020-01-04T11:33:01+08:00">2020-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>分为五层，从上往下依次是应用层、应用框架层、系统运行库层、硬件抽象层和Linux内核层。</p>
<ul>
<li>应用层(System Apps)：系统内置的应用程序以及非系统级的应用程序都属于应用层，负责与用户进行直接交互。    </li>
<li>应用框架层(Java API FrameWork)：应用框架层为开发人员提供了开发应用程序所需要的API，我们平时开发应用程序都是调用这一层提供的API。    </li>
<li>系统运行库层(Native)：系统运行库层分为两部分：分别是C/C++程序库和Android运行时库。运行时库又分为核心库和ART(Dalvik)，核心库提供了Java语言核心库的大多数功能，这样开发者可以使用Java语言来编写Android应用。     </li>
<li>硬件抽象层(HAL)：硬件抽象层是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商的知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台。    </li>
<li>Linux内核层(Linux Kernel)：Android 的核心系统服务基于Linux内核，在此基础上添加了部分Android专用驱动。</li>
</ul>
<h2 id="Android系统源码目录"><a href="#Android系统源码目录" class="headerlink" title="Android系统源码目录"></a>Android系统源码目录</h2><p>Android 8.0.0系统根目录结构说明如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC1%E7%AB%A0/Android%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95-1.png" alt="Android系统目录-1"></p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC1%E7%AB%A0/Android%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95-2.png" alt="Android系统目录-2"></p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层位于整个Android系统的最上层，开发者开发的应用程序以及系统内置应用程序都在应用层，它的目录结构如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC1%E7%AB%A0/%E5%BA%94%E7%94%A8%E5%B1%82%E7%9B%AE%E5%BD%95-1.png" alt="应用层目录-1"></p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC1%E7%AB%A0/%E5%BA%94%E7%94%A8%E5%B1%82%E7%9B%AE%E5%BD%95-2.png" alt="应用层目录-2"></p>
<h3 id="应用框架层部分"><a href="#应用框架层部分" class="headerlink" title="应用框架层部分"></a>应用框架层部分</h3><p>应用框架层是系统的核心部分，一方面向上提供接口给应用层调用，另一方面向下与下层进行衔接，应用框架层的主要实现代码在 frameworks/base 和 frameworks/av 目录下，其中frameworks/base 目录结构如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC1%E7%AB%A0/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E5%B1%82%E7%9B%AE%E5%BD%95.png" alt="应用框架层目录"></p>
<h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><p>系统源码阅读的方式有在线阅读和下载源码到本地用软件工具阅读。</p>
<h3 id="在线阅读"><a href="#在线阅读" class="headerlink" title="在线阅读"></a>在线阅读</h3><p>Android 在线阅读源码的网站有很多，比如：<a target="_blank" rel="noopener" href="http://androidxref.com/">http://androidxref.com/</a>,<a target="_blank" rel="noopener" href="http://www.androidos.net.cn/">http://www.androidos.net.cn/</a>,在书中，作者推荐使用前一个url在线阅读；我个人比较推荐第二个，因为它在类搜索这块做得非常舒服，像使用google、baidu 一样容易使用，此外，它还是中文界面。</p>
<h3 id="使用Source-Insight"><a href="#使用Source-Insight" class="headerlink" title="使用Source Insight"></a>使用Source Insight</h3><p>下载源码到本地，再用软件工具阅读源码是最好的方式，不受网速影响，效率更高，本地阅读源码可以采用 Android Studio、Eclipse、Sublime 和Source Insight 等软件，这里推荐使用Source Insight 。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/18/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC10%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/18/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC10%E7%AB%A0/" class="post-title-link" itemprop="url">第10章：Java虚拟机</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-18 20:48:00" itemprop="dateCreated datePublished" datetime="2019-11-18T20:48:00+08:00">2019-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-19 21:05:34" itemprop="dateModified" datetime="2019-11-19T21:05:34+08:00">2019-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>需要注意的是，Android中的Dalvik 和 ART 并不属于Java 虚拟机。</p>
<p>当一个Java 文件经过Java编译器后会生成Class 文件，这个Class 文件会由 Java 虚拟机进行处理，Java 虚拟机与 Java 语言没有必然的联系，它只与特定的二进制文件：Class 文件有关。任何语言只要能编译成 Class 文件，都能被Java 虚拟机识别并执行。</p>
<h2 id="Java虚拟机结构"><a href="#Java虚拟机结构" class="headerlink" title="Java虚拟机结构"></a>Java虚拟机结构</h2><p>按照Java虚拟机规范，抽象的Java 虚拟机如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC10%E7%AB%A0/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BB%93%E6%9E%84.png" alt="Java虚拟机结构"></p>
<p>从图可以看出，Java虚拟机结构包括 运行时数据区域、执行引擎、本地库接口和本地方法库，其中类加载子系统并不属于Java 虚拟机的内部结构。下面针对这个图来介绍Android 开发需要掌握的Class 文件格式和运行时数据区域。</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>类的生命周期如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC10%E7%AB%A0/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="类的生命周期"></p>
<p>类加载的各个阶段的工作：</p>
<ol>
<li><p>加载： 查找并加载Class文件    </p>
</li>
<li><p>连接： 包括验证、准备和解析    </p>
<ul>
<li>验证：确保被导入类型的正确性     </li>
<li>准备：为类的**静态字段分配字段，并用默认值初始化这些字段    </li>
<li>解析：虚拟机将常量池内的符号引用替换为直接引用    </li>
</ul>
</li>
<li><p>初始化： 将类变量初始化为正确的初始值。    </p>
</li>
</ol>
<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>可取的几点：</p>
<ul>
<li>为了在线程切换后能恢复到正确的执行位置，每个线程都会有个独立的程序计数器。如果线程执行的方法是Native方法，则程序计数器的值为空(Undefined)，否则，保存正在执行的字节码指令地址。    </li>
<li>可以选择在方法区不显示垃圾收集    </li>
</ul>
<p>其他的可以参考深入理解Java虚拟机的<a href="https://glassx.gitee.io/2019/04/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0/">这篇文章</a>即可。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>当虚拟机接收到一个 new 指令时，它会做如下操作：</p>
<ol>
<li>判断对象对应的类是否加载、链接、以及初始化。    </li>
<li>为对象分配内存：如果内存规整，则只需要将指针指示器向空闲的内存移动若干距离即可；若不规整，则需要由虚拟机维护一个列表记录哪些内存是可用的。</li>
<li>处理并发安全问题，有两种方式解决：   <ul>
<li>对分配内存空间的动作做同步处理，比如采用 CAS 方式配合失败重试</li>
<li>为每个线程在Java堆中预先分配一小块内存，只有这块内存被使用完后，才需要同步的方式分配新的内存。</li>
</ul>
</li>
<li>初始化分配到的内存空间：将分配到的内存，出对象头以外都初始化为零值。     </li>
<li>设置对象的对象头：将对象所属的类、对象的hashcode、以及GC分代年龄等存放在对象头。    </li>
<li>执行init方法进行初始化。</li>
</ol>
<h2 id="垃圾标记算法"><a href="#垃圾标记算法" class="headerlink" title="垃圾标记算法"></a>垃圾标记算法</h2><p>GC 主要做两个工作：一是内存的划分和分配，二是对垃圾进行回收。关于内存的划分和分配，目前Java虚拟机内存的划分是依赖于GC 的，比如现在的GC 都采用分代收集算法来回收垃圾的。<strong>Java 堆作为GC 的主要管理区域</strong>，被细分为新生代和老年代。</p>
<blockquote>
<p>查看gc日志的时候，[GC(Systemt.gc()) 和 [Full GC(Systemt.gc() 用于说明此次垃圾收集的<strong>停顿类型(而非区分新生代和老年代)</strong>，后者表示此次GC发生了 STW(Stop the World，只有GC线程在运行，其他线程都暂停)。</p>
</blockquote>
<p>其余主要内容，<a href="https://glassx.gitee.io/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/">参考以前写的这篇文章</a></p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>首先标记可以被回收的对象，之后回收被标记的对象所占的空间。它主要有两大缺点：一个是标记和清除两个过程的效率都不高，另一个就是，容易产生大量的内存碎片，<strong>碎片太多可能会导致没有足够的连续内存分配给较大的对象</strong>，从而提前触发新的GC。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>把空间分为两个相等部分，每次只使用其中一部分，垃圾收集时，把存货的对象复制到另一部分，再把当前部分全部清理掉，这样不需要考虑碎片化问题，缺点就是可用内存变为了原来的一半。</p>
<h3 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h3><p>新生代一半存活的对象比较少，可以使用复制算法，但是老年代不能选择复制算法了，因为老年代的对象存活率会较高，这样会有很多复制操作，导致效率降低。它的主要方式是，在标记可回收的对象后，将所有还存活的对象压缩到内存的一端，使它们紧凑地排列在一起，然后对边界外的内存进行回收。<strong>标记-压缩算法解决了标记-清除算法容易产生大量内存碎片的问题，但是它的效率仍然是很低的。</strong></p>
<h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p>垃圾收集的类型分为两种，分别是：</p>
<ul>
<li>Minor Collection: 新生代垃圾收集    </li>
<li>Full Collection: 老年代垃圾收集，也称 Major Collection， Full Collection 通常会伴随至少一次的 Minor Collection。 Full Collection 收集频率低，耗时长。</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">116</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共274k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.gitee.io/page/6/',]
      });
      });
  </script>


</body>
</html>
