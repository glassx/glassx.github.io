<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/21/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/21/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">37</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">215</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2018/06/11/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/11/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%85%AD%E7%AB%A0/" class="post-title-link" itemprop="url">第6章：数据存储全方案：详解持久化技术</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-11 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-11T08:00:00+08:00">2018-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:51:55" itemprop="dateModified" datetime="2019-11-17T21:51:55+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>Android系统主要提供了3种方式用于简单地实现数据持久化功能——文件存储、SharedPreference存储以及数据库存储。</p>
<h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>文件存储是Android中最基本的存储方式，它不对存储内容进行任何的格式化处理，因而比较适合用于存储一些<strong>简单的文本数据</strong>或者<strong>二进制数据</strong>。</p>
<h3 id="将数据存储到文件"><a href="#将数据存储到文件" class="headerlink" title="将数据存储到文件"></a>将数据存储到文件</h3><p>Context类提供了一个openFileOutput()方法，可以用于将数据存储到指定文件，需要两个参数，第一个参数是文件名，纯粹的名称，不可以包含路径，因为所有的文件都是默认存储到<strong>/data/data/<packagename>/files/</packagename></strong>目录下；还有个参数是操作模式，主要有两种（其他2种在4.2被废弃了）：</p>
<ul>
<li>MODE_PRIVATE:默认的操作模式，表示当指定同样文件名的时候，所写入的内容将会覆盖原来文件中的内容。</li>
<li>MODE_APPEND:表示如果该文件已经存在，就往文件里面追加内容，不存在就创建新文件。</li>
</ul>
<p>保存文件的一般如以下代码操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>{</span><br><span class="line">	String dataStr = <span class="string">"data to save"</span>;</span><br><span class="line">	FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">	BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span>{</span><br><span class="line">		<span class="comment">//文件名是data</span></span><br><span class="line">		out = openFileOutput(<span class="string">"data"</span>,Context.MODE_PRIVATE);</span><br><span class="line">		writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out));</span><br><span class="line">		writer.write(dataStr);</span><br><span class="line">	}<span class="keyword">catch</span>(IOException e){</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	}finnaly{</span><br><span class="line">		<span class="keyword">try</span>{</span><br><span class="line">			<span class="keyword">if</span>(writer != <span class="keyword">null</span>){</span><br><span class="line">				writer.close();</span><br><span class="line">			}<span class="keyword">catch</span>(IOException e){</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>存储成功后，可以通过Android Device Monitor 进入File Explorer标签，在目录中/data/data/<packagename>/files/中就能找到 data 文件。同理，读取存到文件中的代码应如下所示：</packagename></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">()</span></span>{</span><br><span class="line">	FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">	BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">	StringBuilder content = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">try</span>{</span><br><span class="line">		in = openFileInput(<span class="string">"data"</span>);</span><br><span class="line">		reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">		String line = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">while</span>((line = reader.readLine()) != <span class="keyword">null</span>){</span><br><span class="line">			content.append(line);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}<span class="keyword">catch</span>(IOException e){</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	}finnaly{</span><br><span class="line">		<span class="keyword">try</span>{</span><br><span class="line">			<span class="keyword">if</span>(reader != <span class="keyword">null</span>){</span><br><span class="line">				reader.close();</span><br><span class="line">			}<span class="keyword">catch</span>(IOException e){</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> content.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="SharedPreference"><a href="#SharedPreference" class="headerlink" title="SharedPreference"></a>SharedPreference</h2><p>SharedPreference是使用键值对的方式来存储数据的，保存一条数据的时候，需要给这条数据提供一个对应的键，读取数据时通过这个键把对应的值读取出来，SharedPreference文件都是存放在/data/data/<packagename>/shared_prefs目录下。要想存储数据，首先要获取到SharedPreference对象，Android主要提供了3中方式：</packagename></p>
<ul>
<li><p>Context类中的getSharedPreference()方法：此方法接收两个参数，第一个用于指定文件名称，第二个用于指定操作模式，目前只有MODE_PRIVATE可选（其他的几种在4.2或者6.0版本被废弃了），并且是默认的操作模式，表示只有当前应用程序才可以对这个文件进行读写。</p>
</li>
<li><p>Activity中的getPreferences()方法：和Context类中的getSharedPreference()方法类似，只不过它只接受一个操作模式参数，因为使用这个方法时会自动将当前Activity的类名作为SharedPreference的文件名。</p>
</li>
<li><p>PreferenceManager类中的getDefaultSharedPreferences()方法：它接受一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreference文件。</p>
</li>
</ul>
<p>获取到SharedPreference对象之后，就可以开始存储数据了，主要分为3步实现：</p>
<ol>
<li>调用SharedPreference对象的edit()方法获取SharedPreference.Editor对象</li>
<li>向SharedPreference.Editor对象添加数据。</li>
<li>调用apply()方法提交，从而完成存储操作。</li>
</ol>
<p>代码形式应该是这样的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences.Editor editor = getSharedPreferences(<span class="string">"data"</span>,MODE_PRIVATE).edit();</span><br><span class="line">editor.putString(<span class="string">"name"</span>,<span class="string">"Tom"</span>);</span><br><span class="line">editor.apply();</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储完成后，读取数据</span></span><br><span class="line">SharedPreferences pref = getSharedPreferences(<span class="string">"data"</span>,MODE_PRIVATE);</span><br><span class="line">String name = pref.getString(<span class="string">"name"</span>,<span class="string">""</span>);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a>SQLite数据库存储</h2><p>文件存储和SharedPrefrences存储只适用于保存一些简单的数据和键值对，要存储大量复杂的关系型数据的时候，有点难以应付了。</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>Android为了让我们更方便地管理数据库，专门提供了一个SQLiteOpenHelper抽象类，要想使用的话，我们就需要创建一个自己的类去继承它，它有两个抽象方法，onCreate和onUpgrade用来创建和升级数据库，其它两个重要的实例方法：getReadableDatabase和getWritableDatabase，他们都可以创建或者打开一个现有的数据库（没有就创建），在数据库不可写入的时候（如磁盘满了），前者以只读的形式打开数据库，后者会出现异常。它有两个构造方法可重写，一般使用哪个参数较少的即可，总共4个参数，第一个context，第二个是数据库名，第三个是自定义的Cursor，一般传null，第四个表示当前的数据库版本号，用于对数据库进行升级操作。一般代码如下图所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span></span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CREATE_BOOK = <span class="string">"create table Book ("</span></span><br><span class="line">		+ <span class="string">"id integer primary key autoincrement,"</span></span><br><span class="line">		+ <span class="string">"author text,"</span></span><br><span class="line">		+ <span class="string">"price real,"</span></span><br><span class="line">		+ <span class="string">"pages integer,"</span></span><br><span class="line">		+<span class="string">"name text)"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span>{</span><br><span class="line">			db.exeSQL(CREATE_BOOK);</span><br><span class="line">		}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用的时候应该是这样子的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>,<span class="string">"BookStore.db"</span>,<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//就会创建成功了</span></span><br><span class="line">dbHelper.getWritableDatabase();</span><br></pre></td></tr></tbody></table></figure>

<p>上例创建了一个Book表，使用primary key 将id设置为主键，并用autoincrement关键字表示id是自增长的。可以使用</p>
<blockquote>
<p>adb shell</p>
</blockquote>
<p>命令，之后cd到/data/data/<packagename>/databases/目录下用<strong>ls</strong>列出该目录的文件，可以看到BookStore.db文件，以及BookStore.db-journal文件，后者是数据库的临时文件。SQLite没有其他数据库一样有很多繁杂的数据类型，它的数据类型很简单：<strong>integer表示整型，real表示浮点型，text表示文本，blob表示二进制类型</strong>；</packagename></p>
<h3 id="升级数据库"><a href="#升级数据库" class="headerlink" title="升级数据库"></a>升级数据库</h3><p>此时项目中有一张Book表用于存放输的各种详细数据了，但是如果再想添加一张Category表用于记录图书的分类，如果仅仅直接在MyDatabaseHelper的onCreate中写成：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span>{</span><br><span class="line">	db.exeSQL(CREATE_BOOK);</span><br><span class="line">	db.exeSQL(CREATE_CATEGORY);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>是行不通的，因为使用的时候先初始化helper：<strong>dbHelper = new MyDatabaseHelper(this,”BookStore.db”,null,1)</strong>再获取数据库：<strong>dbHelper.getWritableDatabase()</strong>，而由于此时已经存在数据库BookStore.db了，因此不会再执行helper的onCreate方法了。此时清除app数据可以做到创建Category表，但是这在实际应用中不合理，而我们可以用<strong>onUpgrade</strong>方法来解决，我们前面构造了MyDatabaseHelper，第4个参数是版本号，我们目前是1，所以只要传入的值大于当前版本号1，onUpgrade方法就可以执行，因此我们可以这样增加Category表：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span></span>{</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db,<span class="keyword">int</span> oldVersion,<span class="keyword">int</span> newVersion)</span></span>{</span><br><span class="line">		db.exeSQL(<span class="string">"drop table if exists Book"</span>);</span><br><span class="line">		db.exeSQL(<span class="string">"drop table if exists Category"</span>);</span><br><span class="line">		onCreate(db);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码执行了两条drop语句，发现数据库已经存在Book表和Category表了就删除，然后调用onCreate方法重新创建，因此在onCreate中也得写成：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span>{</span><br><span class="line">	db.exeSQL(CREATE_BOOK);</span><br><span class="line">	db.exeSQL(CREATE_CATEGORY);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在使用的时候也得升级版本号：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>,<span class="string">"BookStore.db"</span>,<span class="keyword">null</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//就会创建成功了</span></span><br><span class="line">dbHelper.getWritableDatabase();</span><br></pre></td></tr></tbody></table></figure>

<p>获取到数据库，接下来可以对其CRUD操作，其中C代表添加（Create），R代表查询（retrieve），U代表更新（Update），D代表删除（Delete）。Android开发者水平参差不齐，并非每一个都会SQL语言，Android提供了一系列的辅助性方法，是的在Android中即使不去编写SQL语句，也能轻松完成所有CRUD操作。getReadableDatabase与getWriteableDatabase方法不仅可以用来创建和升级数据库，他们还会返回一个SQLiteDatabase对象，借助这个对象就可以轻松CRUD：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**添加数据**/</span></span><br><span class="line">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"name"</span>,<span class="string">"thinking in java"</span>);</span><br><span class="line">values.put(<span class="string">"price"</span>,<span class="number">16.96</span>);</span><br><span class="line">values.put(<span class="string">"pages"</span>,<span class="number">512</span>);</span><br><span class="line"><span class="comment">//插入时指定表名为"Book"</span></span><br><span class="line">db.insert(<span class="string">"Book"</span>,<span class="keyword">null</span>,values);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**以下是更新**/</span></span><br><span class="line">values.clear();</span><br><span class="line">values.put(<span class="string">"price"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//第三个参数对应SQL语句中的where部分，表示更新所有name等于?的行，而?是一个占位符，</span></span><br><span class="line"><span class="comment">//可以通过第四个参数提供的一个字符串数组为第三个参数中的每个占位符指定相应内容</span></span><br><span class="line">db.update(<span class="string">"Book"</span>,values,<span class="string">"name=?"</span>,<span class="keyword">new</span> String[]{<span class="string">"thinking in java"</span>});</span><br><span class="line"></span><br><span class="line"><span class="comment">/**以下是删除**/</span></span><br><span class="line"><span class="comment">//表示删除pages的值大于500的数据</span></span><br><span class="line">db.delete(<span class="string">"Book"</span>,<span class="string">"pages &gt; ?"</span>,<span class="keyword">new</span> String[]{<span class="string">"500"</span>});</span><br><span class="line"></span><br><span class="line"><span class="comment">/**以下是查询**/</span></span><br><span class="line">Cursor cusor = db.query(<span class="string">"Book"</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span>(cursor.moveToFirst()){</span><br><span class="line">	<span class="keyword">do</span>{</span><br><span class="line">		String name = cursor.getString(cursor.getColumnIndex(<span class="string">"name"</span>));</span><br><span class="line">		String pages = cursor.Double(cursor.getColumnIndex(<span class="string">"price"</span>));</span><br><span class="line">	}<span class="keyword">while</span>(cursor.moveToNext());</span><br><span class="line">}</span><br><span class="line">cusor.close();</span><br></pre></td></tr></tbody></table></figure>

<p>当然，可以直接使用SQL语句直接完成上述操作：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>添加</span><br><span class="line">db.execSQL("insert into Book (name,pages,price) values(?,?,?)",<span class="keyword">new</span> String[]{"thinking in java","512","20"});</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>升级</span><br><span class="line">db.execSQL("update Book set price = ? where name = ",<span class="keyword">new</span> String[]{"20","thinking in java"});</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除</span><br><span class="line">db.execSQL("delete from Book where pages &gt; ?",<span class="keyword">new</span> String[]{"500"});</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询</span><br><span class="line">db.execSQL("select * from Book",<span class="keyword">null</span>);</span><br></pre></td></tr></tbody></table></figure>



<h2 id="使用LitePal"><a href="#使用LitePal" class="headerlink" title="使用LitePal"></a>使用LitePal</h2><p><strong>略</strong></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2018/06/10/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/10/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%94%E7%AB%A0/" class="post-title-link" itemprop="url">第5章： 全局大喇叭：详解广播机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-10 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-10T08:00:00+08:00">2018-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-05 20:39:05" itemprop="dateModified" datetime="2020-05-05T20:39:05+08:00">2020-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h3 id="广播机制介绍"><a href="#广播机制介绍" class="headerlink" title="广播机制介绍"></a>广播机制介绍</h3><p>Android中广播分为<strong>标准广播</strong>和<strong>有序广播</strong>，标准广播是一种完全异步执行的广播，广播发出后，所有广播接收器机会会在同一时刻接收到广播，但同时意味着它也是无法被截断的。有序广播是一种同步执行的广播，同一时刻只有一个广播接收器能收到这条消息，当这个广播接收器的逻辑执行完毕之后才会继续传递，优先级高的广播接收器可以先收到广播，并且还可以阶段正在传递的广播，这样后面的广播接收器就收不到这条广播消息。</p>
<h4 id="动态注册和静态注册广播"><a href="#动态注册和静态注册广播" class="headerlink" title="动态注册和静态注册广播"></a>动态注册和静态注册广播</h4><p>动态注册一般在Activity的onCreate方法中写上类似于：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">receiver = <span class="keyword">new</span> MyReceiver();</span><br><span class="line">registerReceiver(receiver,filter);</span><br></pre></td></tr></tbody></table></figure>

<p>并且在onDestroy方法中注销广播：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; unregisterReceiver(receiver);</span><br></pre></td></tr></tbody></table></figure>

<p>然后，完善一般是内部类的MyReceiver：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span></span>{</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context,Intent intent)</span></span>{</span><br><span class="line">		Toast.makeText(context,<span class="string">"receive the broadcast"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后得在适当的时候发送广播：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>当然，如果你是用广播在APP中实现强制退出登录（如QQ账号在另一台设备上登录了），那你只需要在当前Activity上弹一个窗提示已经被强制下线即可，因此有必要将广播在BaseActivity中注册，并且在BaseActivity的onPause方法（注意不是onDestroy方法了，因为我们只需要栈顶的Activity能够响应就行）中注销广播即可。如果是接收系统级广播，可能还得在AndroidManife.xml中声明相关权限</strong>。APP中实现强制退出登录时的广播接收器可以这样写：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForceOfflineReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span></span>{</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(<span class="keyword">final</span> Context context,Intent intent)</span></span>{</span><br><span class="line">		AltertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(context);</span><br><span class="line">		builder.setTitle(<span class="string">"warning"</span>);</span><br><span class="line">		builder.setMessage(<span class="string">"force offline"</span>);</span><br><span class="line">		builder.setCancelable(<span class="keyword">false</span>);</span><br><span class="line">		builder.setPositiveButton(<span class="string">"ok"</span>,<span class="keyword">new</span> DialogInterface.OnclickListener(){</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onclick</span><span class="params">(DialogInterface dialog,<span class="keyword">int</span> which)</span></span>{</span><br><span class="line">				ActivityCollector.finishAll();<span class="comment">//销毁所有活动</span></span><br><span class="line">				Intent intent = <span class="keyword">new</span> Intent(context,LoginActivity.class);</span><br><span class="line">				context.startActivity(intent);</span><br><span class="line"></span><br><span class="line">			}</span><br><span class="line">		});</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>静态注册广播是在AndroidManife.xml中做如下的声明，<strong>其中MyReceiver类一般不是内部类，因为即使app未启动也能接收广播</strong>：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:label</span>=<span class="string">"@string/appname"</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:name</span>=<span class="string">".MyReceiver"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.MyReceiver"</span></span></span><br><span class="line"><span class="tag"> &lt;/<span class="attr">receiver</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果要发送有序广播，只需要将以上发送广播的代码<strong>sendBroadcast(intent)</strong>替换成<strong>sendOrderedBroadcast(intent,null);</strong>即可。设置广播的优先级只需要设置intentFilter的priority属性即可（AndroidManifest文件中是intent-filter属性）。</p>
<h3 id="使用本地广播"><a href="#使用本地广播" class="headerlink" title="使用本地广播"></a>使用本地广播</h3><p>前面发送的广播属于系统全局广播，发出的广播可以被任何应用接收到，并且我们也可以接受来自其它任何应用发出的广播，这容易引起安全性问题，比如关键数据广播被其他应用截获，或者其他应用发送各种垃圾广播。本地广播的发送有些不同：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalBroadcastManager manager = LocalBroadcastManager.getInstance(<span class="keyword">this</span>);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">manager.sendBroadcast(intent);</span><br></pre></td></tr></tbody></table></figure>

<p>注册：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">localReceiver = <span class="keyword">new</span> LocalReceiver();</span><br><span class="line">manager.registerReceiver(localReceiver,filter);</span><br></pre></td></tr></tbody></table></figure>
<p>同样注销广播：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager.unregisterReceiver(localReceiver);</span><br></pre></td></tr></tbody></table></figure>

<p>本地广播的几点优势：</p>
<ul>
<li>可以明确地知道正在发送的广播不会离开我们的程序，因此不必担心机密数据泄露。</li>
<li>其他的程序无法将广播发送到我们程序内部，因此不用担心会有安全漏洞隐患。</li>
<li>发送本地广播比发送系统全局广播更加高效。</li>
</ul>
<p><strong>另有一点需要说明：本地广播是无法通过静态注册方式来接收的，其实这也完全可以理解，因为静态注册主要就是为了让程序在未启动的情况下也能接收广播，而发送本地广播时，我们的程序肯定是已经启动了；此外，不要再onReceive方法中添加过多的逻辑或者进行任何耗时的操作，因为广播接收器中是不允许开启线程的，当onReceive方法运行了较长时间而没有结束时，程序就会报错。因此它更多的只是扮演一种打开程序其他组件的角色，如弹一条通知，或者启动一个服务等。</strong></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2018/06/09/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/09/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">第4章：手机平板要兼顾：探究fragment</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-09 16:00:00" itemprop="dateCreated datePublished" datetime="2018-06-09T16:00:00+08:00">2018-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:52:15" itemprop="dateModified" datetime="2019-11-17T21:52:15+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>这一章前面部分主要讲解Fragment的基本使用，这点我觉得官方文档关于fragment的知识可能会更好一些，以下是官方的阐述：</p>
<p>主要是平时使用Fragment时，对其使用方法有疑惑，以下或许能解释部分：</p>
<h3 id="为什么使用Fragment"><a href="#为什么使用Fragment" class="headerlink" title="为什么使用Fragment"></a>为什么使用Fragment</h3><p><strong>参考自官方</strong>：主要是为了在大屏幕手机（如平板电脑）上更加零落的UI设计，可以更方便地组合和交换UI组件。</p>
<h3 id="Fragment的创建"><a href="#Fragment的创建" class="headerlink" title="Fragment的创建"></a>Fragment的创建</h3><p>想为Fragment提供布局，则必须实现onCreateView()回调，可以通过xml定义布局资源，为此，onCreateView()提供了一个LayoutInflater对象：</p>
<pre><code>public static class ExampleFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.example_fragment, container, false);
    }
}</code></pre><h3 id="向Activity中添加Fragment"><a href="#向Activity中添加Fragment" class="headerlink" title="向Activity中添加Fragment"></a>向Activity中添加Fragment</h3><h4 id="1、在Activity的布局文件中声明："><a href="#1、在Activity的布局文件中声明：" class="headerlink" title="1、在Activity的布局文件中声明："></a>1、在Activity的布局文件中声明：</h4><pre><code>&lt;?xml version="1.0" encoding="utf-8"&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;

    &lt;fragment android:name="com.example.ListFragment"
            android:id="@+id/list"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" /&gt;

    &lt;fragment android:name="com.example.AticleFragment"
            android:id="@+id/viewer"
            android:layout_weight="2"
            android:layout_width="0dp"
            android:layout_height="match_parent" /&gt;
&lt;/LinearLayout&gt;</code></pre><blockquote>
<p><strong>官方解释</strong>:Activity初始化布局时，会实例化布局中指定的每个fragment，并为每个Fragment调用onCreateView()方法，系统会直接插入Fragment返回的View来替代<fragment>元素。</fragment></p>
</blockquote>
<h4 id="2、通过编程方式将Fragment添加到某个现有的ViewGroup："><a href="#2、通过编程方式将Fragment添加到某个现有的ViewGroup：" class="headerlink" title="2、通过编程方式将Fragment添加到某个现有的ViewGroup："></a>2、通过编程方式将Fragment添加到某个现有的ViewGroup：</h4><p>可以在Activity运行期间将Fragment添加进去，你只需要指定Fragment要放入哪个ViewGroup，这需要使用FragmentTransaction：</p>
<pre><code>FragmentManager fragmentManager = getFragmentManager();
FragmentTransaction transaction = fragmentManager.beginTransaction();</code></pre><p>然后，你可以使用add()方法添加一个fragment：</p>
<pre><code>ExampleFragment fragment = new ExampleFragment();
transaction.add(R.id.fragment_container,fragment);
transaction.commit();</code></pre><blockquote>
<p>一旦通过FragmentTransaction做出了更改，就必须commit以使更改生效。</p>
</blockquote>
<h4 id="3、添加没有UI的Fragment："><a href="#3、添加没有UI的Fragment：" class="headerlink" title="3、添加没有UI的Fragment："></a>3、添加没有UI的Fragment：</h4><p>你可以使用Fragment为Activity提供后台行为，而不显示额外的UI。使用函数：</p>
<pre><code>add(Fragment,String)</code></pre><p>String类型参数为Fragment提供一个唯一的字符串标记，由于Fragment没有雨Activity中的视图关联，因此不会收到onCreate()调用，因此你可以不实现这个方法。如果你稍后想从Activity中获取到这个Fragment，可以使用findFragmentByTag()。</p>
<blockquote>
<p>可以在SDK的sample中查看具体用法：<sdk_root>/APIDemos/app/src/main/java/com/example/android/apis/app/FragmentRetainInstance.java </sdk_root></p>
</blockquote>
<h3 id="执行Fragment事务"><a href="#执行Fragment事务" class="headerlink" title="执行Fragment事务"></a>执行Fragment事务</h3><p>需要使用FragmentTransaction，可以使用：</p>
<pre><code>add() 、remove() 、replace()</code></pre><p>等方法设置想要执行的更改，然后commit生效。</p>
<p>不过在commit之前你可能想调用 addToBackStack()将其添加到Fragment事务返回栈，允许用户按返回键返回上一Fragment状态。</p>
<p>来个例子：</p>
<pre><code>/**create new fragment and transaction**/

Fragment newFragment = new ExampleFragment();
FragmentTransaction transaction = getFragment().beginTransaction();

/**Replace whatever is in the fragment_container view with this fragment
and add the transaction to the back stack**/

transaction.replace(R.id.fragment_container,newFragment);
transaction.addToBackStack(null);

//commit the transaction
transaction.commit();</code></pre><p>向FragmentTransaction添加更改的顺序无关紧要，但有一些注意事项：</p>
<blockquote>
<p>commit操作不会立即执行，而是等主线程认为可以执行的时候再运行，不过，如果有必要，你也可以从主线程调用executePendingTransactions() 以立即执行commit。</p>
</blockquote>
<blockquote>
<p>最后必须调用commit，而且只能在用户离开Activity之前commit，否则会引发异常，如果对于需要commit的更改无关紧要，可以使用commitAllowingStateLoss()。</p>
</blockquote>
<blockquote>
<p>可以向同一个容器中添加多个fragment，你添加的顺序决定他们在视图层次结构中出现的顺序。</p>
</blockquote>
<h3 id="管理Fragment"><a href="#管理Fragment" class="headerlink" title="管理Fragment"></a>管理Fragment</h3><p>需要使用FragmentManager，你可以使用它执行以下操作：</p>
<ul>
<li><p>findFragmentById() （<strong>对于在Activity布局中提供UI的Fragment</strong>）或者findFragmentByTag()（<strong>对于提供或者不提供UI的Fragment都可</strong>）。</p>
</li>
<li><p>popBackStack() (<strong>模拟用户发出的返回命令</strong>)，将Fragment从返回栈中弹出。</p>
</li>
<li><p>addOnBackStackChangedListener() 监听返回栈变化</p>
</li>
</ul>
<h3 id="与Activity通信"><a href="#与Activity通信" class="headerlink" title="与Activity通信"></a>与Activity通信</h3><p>Fragment可以通过getActivity()访问Activity实例，并轻松执行诸如在Activity布局中查找视图等任务：</p>
<pre><code>View listView = getActivity().findViewById(R.id.list);</code></pre><p>同样，Activity也可以使用findFragmentById 或者 findFragmentByTag,通过从FragmentManager获取Fragment的引用来调用Fragment中的方法：</p>
<pre><code>ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);</code></pre><h3 id="一个应用场景例子"><a href="#一个应用场景例子" class="headerlink" title="一个应用场景例子"></a>一个应用场景例子</h3><p>一个新闻应用中Activity两个Fragment，Fragment A放列表list，Fragment B 放对应内容，那么A在列表项选定后，告诉Activity，以便Activity通知B显示该新闻。其方案可以这样设计：</p>
<p>在A中声明接口OnArticleSelectedListener ：</p>
<pre><code>public static class FragmentA extends ListFragment {
    ...
    // Container Activity must implement this interface
    public interface OnArticleSelectedListener {
        public void onArticleSelected(Uri articleUri);
    }
    ...
}</code></pre><p>同事在Activity中实现接口OnArticleSelectedListener，在A的onAttach方法时判断Activity是否这样做了：</p>
<pre><code>public static class FragmentA extends ListFragment {
    OnArticleSelectedListener mListener;
    ...
    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        try {
            mListener = (OnArticleSelectedListener) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException(activity.toString() + " must implement OnArticleSelectedListener");
        }
    }
    ...
}</code></pre><p>当有点击事件的时候，A看起来是这样子的：</p>
<pre><code>public static class FragmentA extends ListFragment {
    OnArticleSelectedListener mListener;
    ...
    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        // Append the clicked item's row ID with the content provider Uri
        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);
        // Send the event and Uri to the host activity
        mListener.onArticleSelected(noteUri);
    }
    ...
}</code></pre><p>Fragment的生命周期如下图：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-4/fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="fragment生命周期"></p>
<p>其中将fragment进行至fragment的resume状态（即可以跟用户交互）的核心序列如下：</p>
<ul>
<li><p>onAttach(Activity) ：activity与fragment关联的时候调用.</p>
</li>
<li><p>onCreate(Bundle) ：fragment初始化的时候调用.</p>
</li>
<li><p>onCreateView(LayoutInflater, ViewGroup, Bundle) ：为fragment创建返回view界面.</p>
</li>
<li><p>onActivityCreated(Bundle): 通知fragment它绑定的那个Activity已经执行完了onCreate()操作.</p>
</li>
<li><p>onViewStateRestored(Bundle)： 通知fragment它保存的view state已经被恢复了.</p>
</li>
<li><p>onStart()： fragment对用户可见 (还要取决于包含这个fragment的activity是否已经启动了).</p>
</li>
<li><p>onResume()： 使fragment可以和用户交互了 (还要取决于包含这个fragment的activity是否已经resume了).<br>如果一个fragment不再使用了，它会执行一系列相反的过程:</p>
</li>
<li><p>onPause()： fragment不能与用户交互（可能是由于activity的pause）。 </p>
</li>
<li><p>onStop()： fragment不可见了（可能是由于activitystop了）。</p>
</li>
<li><p>onDestroyView()：通知fragment清理与它相关的view资源。</p>
</li>
<li><p>onDestroy()：在完全清理fragment的状态时调用。</p>
</li>
<li><p>onDetach()：当fragment与activity解除绑定时调用。</p>
</li>
</ul>
<h3 id="动态加载布局的技巧"><a href="#动态加载布局的技巧" class="headerlink" title="动态加载布局的技巧"></a>动态加载布局的技巧</h3><h4 id="使用限定符"><a href="#使用限定符" class="headerlink" title="使用限定符"></a>使用限定符</h4><p>如果使用平板就会发现里面的应用基本上是双页模式，但是在手机上限于屏幕大小，都是单页模式。如果判断该使用双页模式还是单页模式，这就要借助<strong>限定符（qualifiers）</strong>来实现了，我们可以有两个布局文件，一个 layout_single.xml 单页模式布局放在layout目录，一个 layout_double.xml 双页模式布局放在 layout-large 目录，其中的large是个限定符。Android中常用限定符如下：<br><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-4/%E9%99%90%E5%AE%9A%E7%AC%A61.png" alt="android限定符1"><br><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-4/%E9%99%90%E5%AE%9A%E7%AC%A62.png" alt="android限定符2"></p>
<h4 id="使用最小限定符"><a href="#使用最小限定符" class="headerlink" title="使用最小限定符"></a>使用最小限定符</h4><p>前面解决了单页双页模式，但是到底怎么才算large，我们需要更精确地控制的话，需要最小限定符。我们新建layout-600dp文件夹，将双页布局文件放入其中，这样就会意味着，当程序运行在宽度小于600dp的设备上时，显示的是单页布局，否则使用的是双页布局。</p>
<p>以上两种技巧可以将手机版和pad版都使用同一个app，避免维护多个app，一处改动，需要在两个app中同步改动。注意在代码中区别目前是双页模式还是单页模式，可以用以下方式：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(findViewById(R.id.anotherpageid) == <span class="keyword">null</span>){</span><br><span class="line">    <span class="comment">//单页</span></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">    <span class="comment">//双页</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中R.id.anotherpageid是在单页中所没有的那个布局的id。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2018/06/09/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%89%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/09/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%89%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：软件和也要拼脸蛋</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-09 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-09T08:00:00+08:00">2018-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:50:58" itemprop="dateModified" datetime="2019-11-17T21:50:58+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>布局文件中如果添加Button，并指定其text为”button”的话，但是显示的是”BUTTON”，全部变为大写了，要去掉这一效果，可以添加属性<strong>android:textAllCaps=”false”</strong></p>
<p>RelativeLayout 中还有另外一组对于控件进行定位的属性，android:layout_alignLeft表示让一个控件的左边缘和另一个控件的左边缘对齐，同理，还有android:layout_alignRight、Top、Bottom 。</p>
<h3 id="创建自定义控件"><a href="#创建自定义控件" class="headerlink" title="创建自定义控件"></a>创建自定义控件</h3><p>我们所用的所有控件都是直接或者间接继承自View的，所有的布局都是直接或者间接继承ViewGroup，View是Android中最基本的一种UI组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是在View的基础上添加各自特有功能；而ViewGroup则是一种特殊的View，它可以包含很多子View和子ViewGroup，是一个防止控件和布局的容器。常用控件和布局的继承结构如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-3/%E5%9B%BE1.png" alt="view继承关系"></p>
<p>App中的标题栏几乎在每个界面都是一样的，除了标题不一样，其他的诸如左边按钮点击就finish当前页面，右边的是菜单按钮，这些功能基本上一样，如果在每个页面都单独为这些按钮重复添加相同的监听，比较繁琐。所以可以将标题栏单独封装成单独的一个TitleLayout的，每次只需要引入到布局中即可。</p>
<h3 id="使用listview"><a href="#使用listview" class="headerlink" title="使用listview"></a>使用listview</h3><p>可以继承ArrayAdapter简化操作，类似如下(当然，这里在getView的时候没有进行复用优化，仅仅只是示例)：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Fruit</span>&gt;</span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> resourceId;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FruitAdapter</span><span class="params">(Context context,<span class="keyword">int</span> resourceId,List&lt;Fruit&gt; objects)</span></span>{</span><br><span class="line">		<span class="keyword">super</span>(context,resourceId,objects);</span><br><span class="line">		<span class="keyword">this</span>.resourceId = resourceId;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position,View convertView,ViewGroup parent)</span></span>{</span><br><span class="line">		Fruit fruit = getItemt(position);</span><br><span class="line">		View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,<span class="keyword">false</span>);</span><br><span class="line">		ImageView ivFruit = view.findViewById(R.id.img);</span><br><span class="line">		TextView tvFruit = view.findViewById(R.id.txt);</span><br><span class="line">		ivFruit.setImageResource(fruit.getImageId());</span><br><span class="line">		tvFruit.setText(fruit.getName());</span><br><span class="line">		<span class="keyword">return</span> view;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h3 id="使用更强大的RecyclerView"><a href="#使用更强大的RecyclerView" class="headerlink" title="使用更强大的RecyclerView"></a>使用更强大的RecyclerView</h3><p>在设置LayoutManager的时候，可以指定排布的方向比如以下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinearLayoutManager manager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">manager.setOrientation(LinearLayoutManager.HORIZONTAL);<span class="comment">//平时一般使用竖直方向，这里特意指定横向</span></span><br></pre></td></tr></tbody></table></figure>

<p>为什么Listview很难或者根本无法实现这种效果呢，其实这主要得益于RecyclerView的出色设计，ListView的布局排列是由自身去管理的，，而RecyclerView则将这个工作交给了LayoutManager，LayoutManager指定了一套可扩展的布局排列接口，自雷只要按照接口的规范来实现，就能定制出不同排列方式的布局了。</p>
<p>实现点击事件，可以在Adapter中的<strong>onCreateViewHolder</strong>方法中来做到，诸如以下实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent,<span class="keyword">int</span> viewType)</span></span>{</span><br><span class="line">	View view = LayoutInflater.from(parent.getContext).inflate(R.layout.fruit_item,parent,<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">final</span> ViewHolder holder = <span class="keyword">new</span> ViewHolder(view);</span><br><span class="line">	holder.ivFruit.setOnclickListener(<span class="keyword">new</span> View.OnclickListener(){</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>{</span><br><span class="line">			<span class="keyword">int</span> postion = holder.getAdapterPosition();</span><br><span class="line">			<span class="comment">//doSomeThing you want</span></span><br><span class="line">		}</span><br><span class="line">	});</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2018/06/07/%E9%9D%A2-%E9%A1%B9%E7%9B%AE/Intent%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/07/%E9%9D%A2-%E9%A1%B9%E7%9B%AE/Intent%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7/" class="post-title-link" itemprop="url">Intent 传递的数据过大</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-07 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-07T08:00:00+08:00">2018-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 22:01:29" itemprop="dateModified" datetime="2019-11-17T22:01:29+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">问题</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>这个问题源于最近做的项目中出现的bug，一个Activity A通过startActivity(intent)的方式（intent中携带了String类型的data）启动另一个Activity B时，发生了崩溃，查看错误日志如下：</p>
<p><img src="/assets/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/intent%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97.png" alt="启动Activity时的错误日志"></p>
<p>可以看到，这是 <strong>android.os.TransactionTooLargeException</strong> ，字面意思是事务太大。这就很好理解了，因为笔者使用了intent携带数据，在事后分析这个data在传入的时候大约50k，因此导致了这个问题。后来使用<strong>SharedPreference</strong>将数据捎带过去解决了问题，这个bug本身看懂了报错就很简单，因此不再赘述。后面有空有兴趣之后再补上分析Intent传递数据到底是多大的限制。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2018/06/05/%E9%9D%A2-%E9%A1%B9%E7%9B%AE/listview%E6%90%AD%E9%85%8Dcheckbox%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/05/%E9%9D%A2-%E9%A1%B9%E7%9B%AE/listview%E6%90%AD%E9%85%8Dcheckbox%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Listview 中 CheckBox 状态错误问题原因及解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-05 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-05T08:00:00+08:00">2018-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 22:01:36" itemprop="dateModified" datetime="2019-11-17T22:01:36+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">问题</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>在开发过程中碰到很多问题，有些问题在锤子便签中记录了一个概要，有的问题甚至连记录都没有，此次开个头，将碰到的问题记录下来。</p>
<p>今天要写的问题跟Listview有关，顺便复习下ListView的相关复用机制，以及Listview的Adapter中getView方法为什么需要ViewHolder，是怎么提高加载效率的。下面开始进入回忆状态，事情的经过是这样的：</p>
<p>在平时的 Android 开发过程中，我们可能需要去实现以下效果：</p>
<p><img src="/assets/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/listview%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98/%E5%9C%BA%E6%99%AF.png" alt="使用场景"></p>
<p>在 Listview 中使用CheckBox，但是会碰到 CheckBox 选中/非选中 这种状态错乱的问题，笔者最近在项目中就碰到了，比如我选中了 id0、id1、id2 三个 CheckBox ，再想选择 id15 ，这就要求滑动 Listview 了，滑到 id15 CheckBox 将其选中，再滑动到顶部，握草，发现 id0、id1、id2 已经变成 非选中 状态了，莫非是我记错了？再重新来一次，还是一样！这就不科学了，一定是哪里出了问题，我当时的代码是这样的：</p>
<pre><code>@Override
public View getView(final int i, View view, ViewGroup viewGroup) {
    ViewHolder viewHolder = null;
    if(view == null){
        viewHolder = new ViewHolder();
        view = LayoutInflater.from(context).inflate(R.layout.layout,null);
        viewHolder.cb = (CheckBox) view.findViewById(R.id.select_cb);
        viewHolder.tvName = (TextView) view.findViewById(R.id.name_tv);
        view.setTag(viewHolder);
    }else{
        viewHolder = (ViewHolder) view.getTag();
    }
    viewHolder.cb.setChecked(data.get(i).isSlected());
    viewHolder.tvName.setText(data.get(i).getName());
    viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
        @Override
        public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked)     {
            data.get(i).setSlected(isChecked);
        }
    });
    return view;
}</code></pre><p>脑子里第一反应是各处的 item 串了，联想到使用 viewholder 来复用 item ，于是就去了解了一番 Listview 对 item 的复用机制。</p>
<h3 id="复用机制"><a href="#复用机制" class="headerlink" title="复用机制"></a>复用机制</h3><p>我们知道，listview 需要承载大量的数据，并且需要写一个 Adapter 与其适配，这样数据就能展现出来了，但是不知道大家有没有仔细想过，为什么需要 Adapter 这个东西，它到底起了个什么作用。</p>
<h5 id="从-Adapter-说起"><a href="#从-Adapter-说起" class="headerlink" title="从 Adapter 说起"></a>从 Adapter 说起</h5><p>说到底，Android 中控件就是为了展示数据以及交互用，只不过Listview特殊些，它用于展示大量的信息的，但是 Listview 只承担交互和展示工作的，至于数据来自哪里，它不care。这样，listview工作最基本需要一个 Listview 控件和一个数据源，但是数据源可能是数组，可能是集合，甚至可能是数据库表中查询出来的游标，如果 Listview 要去为每一种数据源进行匹配的话，它一定会变得非常臃肿了，于是 Adapter 出现了。</p>
<p>顾名思义，Adapter 是适配器的意思，它在 Listview 与数据源之间起了一个桥梁作用，与之前的情况不同的是，Adapter 的接口都是统一的，因此 Listview 不需要担心任何适配问题。而 Adapter 是个接口（interface），它可以有各种子类，比如 ArrayAdapter 可用于数组和 List 类型的数据源匹配，SimpleCursorAdapter 可以用于游标类型的数据源匹配，这样把适配问题解决了，并且扩展性不错。</p>
<h5 id="RecycleBin-类"><a href="#RecycleBin-类" class="headerlink" title="RecycleBin 类"></a>RecycleBin 类</h5><p>在解释复用机制之前，还有必要说一下 RecycleBin 类，因为它是 Listview 能够展现成百上千条数据并且不会 OOM 的关键，RecycleBin 是 AbsListview 的一个内部类，其主要代码如下：</p>
<pre><code>/**
 * The RecycleBin facilitates reuse of views across layouts. The RecycleBin
 * has two levels of storage: ActiveViews and ScrapViews. ActiveViews are
 * those views which were onscreen at the start of a layout. By
 * construction, they are displaying current information. At the end of
 * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews
 * are old views that could potentially be used by the adapter to avoid
 * allocating views unnecessarily.
 */
class RecycleBin {
    private RecyclerListener mRecyclerListener;

    /**
     * The position of the first view stored in mActiveViews.
     */
    private int mFirstActivePosition;

    /**
     * Views that were on screen at the start of layout. This array is
     * populated at the start of layout, and at the end of layout all view
     * in mActiveViews are moved to mScrapViews. Views in mActiveViews
     * represent a contiguous range of Views, with position of the first
     * view store in mFirstActivePosition.
     */
    private View[] mActiveViews = new View[0];

    /**
     * Unsorted views that can be used by the adapter as a convert view.
     */
    private ArrayList&lt;View&gt;[] mScrapViews;

    private int mViewTypeCount;

    private ArrayList&lt;View&gt; mCurrentScrap;

    /**
     * Fill ActiveViews with all of the children of the AbsListView.
     * 
     * @param childCount
     *            The minimum number of views mActiveViews should hold
     * @param firstActivePosition
     *            The position of the first view that will be stored in
     *            mActiveViews
     */
    void fillActiveViews(int childCount, int firstActivePosition) {
        if (mActiveViews.length &lt; childCount) {
            mActiveViews = new View[childCount];
        }
        mFirstActivePosition = firstActivePosition;
        final View[] activeViews = mActiveViews;
        for (int i = 0; i &lt; childCount; i++) {
            View child = getChildAt(i);
            AbsListView.LayoutParams lp = (AbsListView.LayoutParams)     child.getLayoutParams();
            // Don't put header or footer views into the scrap heap
            if (lp != null &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                // Note: We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in
                // active views.
                // However, we will NOT place them into scrap views.
                activeViews[i] = child;
            }
        }
    }

    /**
     * Get the view corresponding to the specified position. The view will
     * be removed from mActiveViews if it is found.
     * 
     * @param position
     *            The position to look up in mActiveViews
     * @return The view if it is found, null otherwise
     */
    View getActiveView(int position) {
        int index = position - mFirstActivePosition;
        final View[] activeViews = mActiveViews;
        if (index &gt;= 0 &amp;&amp; index &lt; activeViews.length) {
            final View match = activeViews[index];
            activeViews[index] = null;
            return match;
        }
        return null;
    }

    /**
     * Put a view into the ScapViews list. These views are unordered.
     * 
     * @param scrap
     *            The view to add
     */
    void addScrapView(View scrap) {
        AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
        if (lp == null) {
            return;
        }
        // Don't put header or footer views or views that should be ignored
        // into the scrap heap
        int viewType = lp.viewType;
        if (!shouldRecycleViewType(viewType)) {
            if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                removeDetachedView(scrap, false);
            }
            return;
        }
        if (mViewTypeCount == 1) {
            dispatchFinishTemporaryDetach(scrap);
            mCurrentScrap.add(scrap);
        } else {
            dispatchFinishTemporaryDetach(scrap);
            mScrapViews[viewType].add(scrap);
        }

        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }

    /**
     * @return A view from the ScrapViews collection. These are unordered.
     */
    View getScrapView(int position) {
        ArrayList&lt;View&gt; scrapViews;
        if (mViewTypeCount == 1) {
            scrapViews = mCurrentScrap;
            int size = scrapViews.size();
            if (size &gt; 0) {
                return scrapViews.remove(size - 1);
            } else {
                return null;
            }
        } else {
            int whichScrap = mAdapter.getItemViewType(position);
            if (whichScrap &gt;= 0 &amp;&amp; whichScrap &lt; mScrapViews.length) {
                scrapViews = mScrapViews[whichScrap];
                int size = scrapViews.size();
                if (size &gt; 0) {
                    return scrapViews.remove(size - 1);
                }
            }
        }
        return null;
    }

    public void setViewTypeCount(int viewTypeCount) {
        if (viewTypeCount &lt; 1) {
            throw new IllegalArgumentException("Can't have a viewTypeCount &lt; 1");
        }
        // noinspection unchecked
        ArrayList&lt;View&gt;[] scrapViews = new ArrayList[viewTypeCount];
        for (int i = 0; i &lt; viewTypeCount; i++) {
            scrapViews[i] = new ArrayList&lt;View&gt;();
        }
        mViewTypeCount = viewTypeCount;
        mCurrentScrap = scrapViews[0];
        mScrapViews = scrapViews;
    }

}</code></pre><ul>
<li><p>注释说 RecycleBin 用于view的reuse，它维持了两个存储空间，ActiveViews 和 ScrapViews，前者存放显示在屏幕上的view，到列表最后的时候，它里面的view都会去到 ScrapViews 中。而后者用于存放 old views ，这些view可能可以直接以convertView的形式直接利用，避免没必要的 allocat 内存，这就是Adapter中convertView的由来。</p>
</li>
<li><p>fillActiveViews() :这个方法会根据传入的参数来将 Listview 中指定的元素存储到 mActiveViews 数组中。</p>
</li>
<li><p>getActiveView() :跟 fillActiveViews 方法对应，用于从 mActiveViews 中获取数据，需要注意的是，一旦第 position 个数据被获取成功之后，该view就会从 mActiveViews 中移除，下次再获取第position个位置将会返回 null，也就是说mActiveViews不能复用。</p>
</li>
<li><p>addScrapView() :用于将一个废弃的view进行缓存，当一个view要废弃的时候（比如滚出屏幕），就调用该方法缓存，以便下次使用。</p>
</li>
<li><p>getScrapView() :从 ScrapViews 中取出一个view，这些废弃缓存中的view是没有顺序可言的，因此取的算法也非常简单，获取尾部的就行。</p>
</li>
<li><p>setViewTypeCount() :我们知道在 adapter 中我们可以重写 getViewTypeCount() 来表示Listview中有几种类型的数据项，而setViewTypeCount()的作用就是为每种类型的数据项都单独启用一个 RecycleBin 缓存机制。</p>
</li>
</ul>
<h5 id="扯点view的绘制"><a href="#扯点view的绘制" class="headerlink" title="扯点view的绘制"></a>扯点view的绘制</h5><p>Listview 再牛逼，也是继承自view的，而view的执行流程就是3步，onMeasure() 用于测量 view 的大小，onLayout() 用于确定 View 的布局，onDraw() 用于将 view 绘制到界面上。</p>
<p>Listview 最特殊的地方在于 onLayout() ,而这是在它父类 AbsListview 中实现的，它主要就一个重要判断：如果 Listview 的大小或者位置发生了变化，那就要求所有子布局强制重绘。而 layoutchildren() 方法是用来进行子元素布局的，具体由 Listview 自己实现，可以解析下。</p>
<p>刚开始，Listview 中没有任何子view，因此会去调用 fillActiveViews() 方法，这是为了将 Listview 中的子 view 进行缓存的，由于此时子 view 为空，因此会调用 fillFromTop() ，最终调用到 fillDown() 方法，进行 Listview 的填充操作。fillDown() 中有个while循环，当遍历完从 Listview 顶部到底部的距离的item或者 adapter 中的数据遍历结束，while就跳出。在while中，执行 makeAndAddView() ，它会尝试从 RecycleBin 中快速获取 active view ，但此时 RecycleBin 中还未缓存任何view，因此获得null，所以就会尝试调用 obtainView() ，它是可以保证返回一个 view 的，于是将获取到的view立刻传入到了 setupChild() 中。</p>
<p>那到底 obtainView() 怎么保证获取到view的？不夸张地说，Listview 中最重要的内容都在 obtainView() 中了，该方法里首先调用了 RecycleBin 的 getScrapView() 方法尝试获取一个废弃缓存中的 view ，当然这时候是获取不到的，得到null，之后再调用 mAdapter 的 getView() 方法来获取一个 view ，这时候似曾相识了，有 adapter 和 getView() 方法了，对，就是我们平常写的那个 adapter，然后重写的那个 getView(),这时候会传入 position，convertView (此时为null)，parent (当然是 this 了)。</p>
<h5 id="捋一下item的复用"><a href="#捋一下item的复用" class="headerlink" title="捋一下item的复用"></a>捋一下item的复用</h5><p>一切从 onLayout 开始，当大小或者位置发生了变化，就会调用onLayout，onLayout完毕之后，就剩下 ondraw 去绘制了。onLayout中，（为了叙述方便，不考虑数据不足以填满Listview的情况），首先要拿item的view放到Listview中，先从ActiveViews中拿，如果为空，则打算从 ScrapViews 中拿，还是为空，则利用 adapter 去创造，创造一屏 itemview 填充于 ActiveViews 中，之后 Listview 从 ActiveViews 中取出 itemview ，ActiveViews 删除该 itemview ，如果 itemview 滑动隐藏了，就会丢弃到 ScrapViews 中，这样滑动的时候触发 onLayout ，onLayout 再去找 itemview 填充，如果有现成的就用，没有就创造。 </p>
<h3 id="分析源码谈原因"><a href="#分析源码谈原因" class="headerlink" title="分析源码谈原因"></a>分析源码谈原因</h3><p>再来看源码，为了更方便，加上toast提示：</p>
<pre><code>@Override
public View getView(final int i, View view, ViewGroup viewGroup) {
    ViewHolder viewHolder = null;
    if(view == null){
        viewHolder = new ViewHolder();
        view = LayoutInflater.from(context).inflate(R.layout.layout,null);
        viewHolder.cb = (CheckBox) view.findViewById(R.id.select_cb);
        viewHolder.tvName = (TextView) view.findViewById(R.id.name_tv);
        view.setTag(viewHolder);
    }else{
        viewHolder = (ViewHolder) view.getTag();
    }
    viewHolder.cb.setChecked(data.get(i).isSlected());
    viewHolder.tvName.setText(data.get(i).getName());
    viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
        @Override
        public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked)     {

        Toast.makeText(context,"这是点击了第" + i + "个" ,Toast.LENGTH_SHORT).show();
            data.get(i).setSlected(isChecked);
        }
    });
    return view;
}</code></pre><p>运行之后我们看到整个列表，选中第1个，会弹toast “这是点击了第0个” 接着往上慢慢滑动，直至将第一个item隐藏的时候，发现 toast 弹出来了，显示 <strong>这是点击了第0个</strong>！而这个时候最下面之前被第一条隐藏的item也展现出来了，综合上面的知识，可以知道，这个隐藏的item是复用了第1个item的view，复用view的时候，由于该隐藏item是<strong>未checked</strong>，而第一条item是<strong>已经checked</strong>，因此它执行     </p>
<blockquote>
<p>viewHolder.cb.setChecked(data.get(i).isSlected());</p>
</blockquote>
<p>的时候，会触发 OnCheckedChangeListener ，由于之前第一个 item 设置了监听：</p>
<pre><code>viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            @Override
            public void onCheckedChanged(CompoundButton compoundButton, boolean     isChecked)     {

            Toast.makeText(context,"这是点击了第" + i + "个" ,Toast.LENGTH_SHORT).show();
                data.get(i).setSlected(isChecked);
            }
        });</code></pre><p>这时候就触发了监听事件，因此toast就弹出来了，并且把第一条item的数据也由checked改成unchecked，因此你下次再见到第一个item的时候，状态就变成unchecked了。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>最后可以说结论了，这个现象是由于listview中item复用导致，如果你不用viewholder是不会有这问题的，其实这个结论并不重要，重要的是理解这里面的发生机制。当然，说了问题起因，当然得给个解决方案，方法不止一种，我个人用的一种方法是在</p>
<blockquote>
<p>viewHolder.cb.setChecked(data.get(i).isSlected());</p>
</blockquote>
<p>之前添加一句：</p>
<blockquote>
<p>viewHolder.cb.setOnCheckedChangeListener(null);</p>
</blockquote>
<p>我想你肯定知道为什么。</p>
<p><strong>注：参考（引用）以下博客劳动成果：</strong></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/44996879">郭霖 ： Android ListView工作原理完全解析，带你从源码的角度彻底理解</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2018/06/01/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/01/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：先从看得到的入手</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-01 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-01T08:00:00+08:00">2018-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:51:11" itemprop="dateModified" datetime="2019-11-17T21:51:11+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Intent使用"><a href="#Intent使用" class="headerlink" title="Intent使用"></a>Intent使用</h2><p>显式地就不说了，使用隐式的Intent时并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，并帮我们找出合适的活动去启动。</p>
<h3 id="普通的隐式Intent使用"><a href="#普通的隐式Intent使用" class="headerlink" title="普通的隐式Intent使用"></a>普通的隐式Intent使用</h3><p>比如在AndroidManifest.xml中声明activity的时候，可以添加：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.ACTION_START"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>在代码中就能以下面代码来启动这个activity了（由于category是DEFAULT，所以在intent中并未指定category了）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.ACTION_START"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></tbody></table></figure>

<p>如果在AndroidManifest.xml中声明activity的时候同时指定了<strong>action</strong>和<strong>category</strong>，那么必须要在Intent中严格匹配才能打开，否则可能报错，比如写成：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.ACTION_START"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"com.example.MY_CATEGORY"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>则代码中必须添加以下代码才能正确运行。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.ACTION_START"</span>);</span><br><span class="line">**intent.addCategory(<span class="string">"com.example.MY_CATEGORY"</span>);**</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="更多隐式Intent用法"><a href="#更多隐式Intent用法" class="headerlink" title="更多隐式Intent用法"></a>更多隐式Intent用法</h3><p>使用隐式的Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，比如说要在应用程序中点击一个按钮，然后要在浏览器中打开一个网页，则使用以下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"http://www.baidu.com"</span>));</span><br><span class="line">startActivity(Intent);</span><br></pre></td></tr></tbody></table></figure>

<p>这里面，setData()接收一个Uri对象，主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传入到Uri.parse()方法中解析产生的。那如果我们要自己写个浏览器应用，让其它应用也能像这样利用我们的APP打开网页，又该怎么做呢，这就要求在<intent-filter>中添加一个&lt;data标签&gt;，用于更精确地指定当前活动能够响应什么类型的数据。<data>标签中可以配置以下内容：</data></intent-filter></p>
<ul>
<li>android:scheme。用于指定数据的协议部分，例如上例中的http部分。</li>
<li>android:host。用于指定数据的主机名部分，如上例中的<a target="_blank" rel="noopener" href="http://www.baidu.com。">www.baidu.com。</a></li>
<li>android:port。用于指定数据的端口部分。</li>
<li>android:path。用于指定主机名和端口之后的部分。</li>
</ul>
<p>所以，如果我们要做一个浏览器，至少要在AndroidManifest.xml对主activity声明：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.ACTION_START"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>下次其他APP需要用http协议打开网页时，我们的APP也会在候选列表中了。除了http协议意外，我们还可以指定很多其他协议，比如<strong>geo</strong>表示地理位置、<strong>tel</strong>表示拨打电话。</p>
<h2 id="活动的生命周期"><a href="#活动的生命周期" class="headerlink" title="活动的生命周期"></a>活动的生命周期</h2><ul>
<li>onCreate()，活动第一次被创建的时候调用，应该在这里面完成活动的初始化操作。</li>
<li>onStart()，在活动由不可见变为课件的时候调用。</li>
<li>onResume()，在活动准备好和用户进行交互的时候调用，此时活动一定位于返回栈的栈顶，并且处于运行状态。</li>
<li>onPause()，在系统准备去启动或者恢复另一个活动的时候调用，通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但是工作不能太多，不然会影响下一个Activity的使用。</li>
<li>onStop(),活动完全不可见的时候调用，它和onPause主要的区别在于，如果启动的新活动是一个对话框式的活动，那么onPause方法会得到执行，而onStop不会执行。</li>
<li>onDestroy()，活动晓辉之前调用。</li>
<li>onRestart()，由停止状态变为运行状态之前调用。一般是由上一个活动返回到当前活动。</li>
</ul>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-2/%E5%9B%BE1.png" alt="Activity声明周期"></p>
<h3 id="活动回收了怎么办"><a href="#活动回收了怎么办" class="headerlink" title="活动回收了怎么办"></a>活动回收了怎么办</h3><p>想象以下场景，应用中有活动A，在A的基础上启动活动B，活动A此时进入了停止状态，此时由于内存不足，将活动A回收了，然后用户按Back键返回活动A，会出现什么情况呢？其实还是会正常显示A，只不过这是并不会执行onRestart方法，而是会执行活动A的onCreate方法，因为活动A在这种情况下会被重新创建一次。</p>
<p>如果A进程中有输入框，并且已经输入了一些文字了，如果回收被重新创建，那么会丢失输入的信息，影响用户体验。Activity中还提供了一个onSaveInstanceState()回调方法，这个方法可以保证在活动回收之前一定会被调用，这个方法会携带一个Bundle类型的参数，它允许以key-value的形式存取值，我们可以这样将要保存的数据存下来：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">        outState.putString(<span class="string">"name"</span>,<span class="string">"glassx"</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>数据已经保存下来了，但是在哪里恢复呢？其实我们一直使用的onCreate方法其实也有一个Bundle类型的参数，这个参数一般情况下是null，如果在活动呗系统回收之前有通过onSaveInstanceState保存的话，这个参数就会带有之前所保存的全部数据，因此通过以下方法取即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(savedInstanceState != <span class="keyword">null</span>){</span><br><span class="line">        	String name = savedInstanceState.getString(<span class="string">"glassx"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>


<h2 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h2><p>在实际项目中我们应该根据特定的需求为每个活动指定恰当的启动模式，启动模式一种四种：<strong>standard、singleTop、singleTask、singleInstance</strong>。</p>
<ul>
<li><p>standard是默认的启动模式。每次启动都会创建一个新的实例。</p>
</li>
<li><p>singleTop：有些情况下，可能会觉得standard不太合理，活动明明已经在栈顶了，为毛还要再创建新的实例呢？singleTop模式可以解决这个问题，当活动以该模式启动时，如果发现返回栈的栈顶已经是该活动，那就直接使用它，不创建新的实例，并且调用栈顶实例的<strong>onNewIntent</strong>方法；如果栈顶不是该活动，就创建该活动的新的实例。</p>
</li>
<li><p>singleTask：如果活动的启动模式指定为singleTask，那么每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果有，把这个活动之上的所有活动统统出栈，并且直接使用该实例，并调用该实例的<strong>onNewIntent</strong>方法？？（存疑，等会实践下）。反之没有的话就创建该活动的实例。</p>
</li>
<li><p>singleInstance：指定为singleInstance模式的活动会启用一个新的返回栈来管理这个活动（其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈）。</p>
<blockquote>
<p>那么这样做有什么意义呢？想象以下场景，我们的程序中有一个活动是允许其他程序调用的，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，应该如何实现呢？前面3中模式做不到，因为每个应用程序都会有自己的返回栈，同一个活动在不同的返回栈中入栈必然是创建了新的实例。而使用singleInstance模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活动，不管哪个应用来访问这个活动，都公用一个返回栈，也就解决了共享活动实例的问题。</p>
</blockquote>
</li>
</ul>
<p><strong>注意：如果三个活动，A和C都是standard模式，B是singleInstance模式，那么A启动B，B启动C后，在C界面按返回键是回退到A，再按返回键回退到B，接着按返回键才会退出应用，因为A和C是同一个回退栈中，B单独在一个栈中，可以用如下图来理解这一过程</strong>。</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-2/%E5%9B%BE2.png" alt="Activity声明周期"></p>
<h2 id="活动的最佳实践"><a href="#活动的最佳实践" class="headerlink" title="活动的最佳实践"></a>活动的最佳实践</h2><h3 id="知晓当前是在哪一个活动"><a href="#知晓当前是在哪一个活动" class="headerlink" title="知晓当前是在哪一个活动"></a>知晓当前是在哪一个活动</h3><p>建一个BaseActivity，在onCreate的时候打印出来当前实例的类名，之后其他的activity都继承这个activity即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        </span><br><span class="line">        Log.d(<span class="string">"BaseActivity"</span>,getClass().getSimpleName());</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="随时随地退出app"><a href="#随时随地退出app" class="headerlink" title="随时随地退出app"></a>随时随地退出app</h3><p>如果你在第三个activity界面，这个时候想要退出App是非常不方便的，可以新建一个类来管理所有Activity：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityController</span></span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Activity&gt; activities = <span class="keyword">new</span> ArrayList&lt;Activity&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addActivity</span><span class="params">(Activity ac)</span></span>{</span><br><span class="line">		activities.add(ac);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeActivity</span><span class="params">(Activity ac)</span></span>{</span><br><span class="line">		activities.remove(ac);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finishAll</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">for</span>(Activity ac : activities){</span><br><span class="line">			ac.finish();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这样只需要在BaseActivity的onCreate里面执行ActivityController的<strong>addActivity</strong>方法，即可把Activity添加进去，在BaseActivity的onDestroy方法中执行<strong>removeActivity</strong>，将其移除，在需要退出app的时候，只需要执行finishAll即可。</p>
<h3 id="启动活动最佳写法"><a href="#启动活动最佳写法" class="headerlink" title="启动活动最佳写法"></a>启动活动最佳写法</h3><p>每个Activity中都写上启动自己的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span></span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">actionStart</span><span class="params">(Context context,String name,String sex)</span></span>{</span><br><span class="line">		Intent intent  = <span class="keyword">new</span> Intent(context,TestActivity.class);</span><br><span class="line">		intent.putExtra(<span class="string">"name"</span>,name);</span><br><span class="line">		intent.putExtra(<span class="string">"sex"</span>,sex);</span><br><span class="line">		context.startActivity(intent);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样做的一个好处就是，启动这个activity所需要的参数一目了然，而无需阅读这个activity的源码就可以直接调用方法就能避免漏掉参数。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2018/05/31/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/31/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">第1章：开启启程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-31 18:00:00" itemprop="dateCreated datePublished" datetime="2018-05-31T18:00:00+08:00">2018-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:50:45" itemprop="dateModified" datetime="2019-11-17T21:50:45+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h4 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h4><ol>
<li><p>最底层是Linux内核层。</p>
<blockquote>
<p>为Android设备各种硬件提供了底层驱动，如显示驱动，音频驱动等。</p>
</blockquote>
</li>
<li><p>系统运行库层。</p>
<blockquote>
<p>这层通过一些C/C++库来为Android系统提供主要的特性支持。如Sqlite库提供了数据库支持，OpenGL|ES提供提供3D绘图等。</p>
</blockquote>
</li>
<li><p>应用框架层。</p>
<blockquote>
<p>主要提供了构建应用程序可能用到的各种API。</p>
</blockquote>
</li>
<li><p>应用层。</p>
<blockquote>
<p>所有安装在手机上的应用程序都属于这一层。比如系统自带的联系人、短信等程序，自己开发的应用。</p>
</blockquote>
</li>
</ol>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-1/%E5%9B%BE1.png" alt="Android系统层次"></p>
<h3 id="Android应用开发特色"><a href="#Android应用开发特色" class="headerlink" title="Android应用开发特色"></a>Android应用开发特色</h3><h4 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h4><p>四大组件分别是活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）和内容提供器（Content Provider）</p>
<p>build.gradle 文件中，<strong>compileSdkVersion</strong>用于指定项目的编译版本；<strong>buildToolsVersion</strong>用于指定项目构建工具的版本；<strong>applicationId</strong>用于指定项目的包名，并且它的优先级高于在 AndroidManifest.xml<br>中指定的包名；<strong>minSdkVersion</strong>用于指定项目最低兼容的Android版本;<strong>targetSdkVersion</strong>表明你在该目标版本上做过了充分的测试，系统将为你的应用程序启用一些最新的功能和特性。比如说Android6.0 系统中引入了运行时权限这个功能，如果你将targetSdkVersion指定成23或者更高，那么系统就会为你的程序启用运行时权限功能；否则就不会启用运行时权限功能。</p>
<p>而在build.gradle的<strong>dependencies</strong>闭包中，声明了当前项目所有的依赖关系，Android studio 项目一共有3中依赖方式，本地依赖、库依赖和远程依赖，本地依赖可以对本地的jar包或者目录添加依赖关系，形式如：<strong>compile fileTree(dir: ‘libs’, include: [‘*.jar’])</strong>；库依赖可以对项目中的库模块添加依赖关系，如<strong>compile(name: ‘testsdk’, ext: ‘aar’)</strong>；远程依赖则可以对jcenter库上的开源项目添加依赖关系，如<strong>compile ‘com.android.support.constraint:constraint-layout:1.0.2’</strong>，其中，com.android.support.constraint是域名，用于和其他公司的库作区分，constraint-layout是组名称，用于和同一个公司其他库作区分。</p>
<p><strong>关于日志：</strong>不用System.out.println()，因为Log系统可以对日志分级，可以展示打印时间，可以添加过滤器等等。<strong>Log快捷键：如果要打Log.d，则输入logd，按tab键即可，同理Log.i只需要logi之后按Tab键，以此类推，四种级别的日志都能快捷打出来。还有，如果在oncreate方法外面输入logt，然后按下Tab键，就会以当前的类名作为值自动生成一个类似下面的TAG常量：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"HelloWorldActivity"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2018/05/30/%E4%B9%A6-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-%E7%AC%AC6%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/30/%E4%B9%A6-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-%E7%AC%AC6%E7%AB%A0/" class="post-title-link" itemprop="url">第6章：死锁</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-30 18:00:00" itemprop="dateCreated datePublished" datetime="2018-05-30T18:00:00+08:00">2018-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:50:18" itemprop="dateModified" datetime="2019-11-17T21:50:18+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>如果有两个进程A和B需要将扫描的文档记录到CD上，进程A请求扫描仪并被授权使用，请求CD时发现已被B占用了，于是被拒绝，同理，B请求扫描仪也会被拒绝，于是产生<strong>死锁</strong>。在一个数据库系统中，为了避免竞争，可对若干记录加锁，如果进程A对R1加锁了，进程B对R2加了锁，接着这两个进程又试图把各自对方的记录也加锁，这是也会产生死锁。所以，<strong>软硬件资源都可能出现死锁</strong>。</p>
<h2 id="资源和死锁条件"><a href="#资源和死锁条件" class="headerlink" title="资源和死锁条件"></a>资源和死锁条件</h2><p><strong>资源</strong>分为两类，一类是<em>可抢占资源（preemptable resource）</em> 可以从拥有它的进程中枪战而不产生任何副作用，比如存储器。一个系统拥有256M的用户内存和一条打印机，如果有两个256M内存的进程都想打印，进程A获得了打印机，而B战友内存，但是幸运的是可以通过把进程B患处内存、把进程A换入内存可以实现抢占B的内存，这样，进程A继续运行并执行打印任务，然后释放打印机和内存。另一类是<em>不可抢占资源（nonpreemptable resource）</em>是指在不引起相关的计算失败的情况下，无法把它从占有它的进程中抢占过来，如CD刻录机。如果一个进程已经在开始刻盘，突然将刻录机分配给另一个进程，那么将划坏CD盘。</p>
<p>因此，总的来说，死锁和不可抢占资源有关，有关可抢占资源的潜在死锁通常可以通过在进程之间重新分配资源而化解，所以我们主要关注不可抢占资源上。当然，Coffman等人总结了发生（资源）死锁需要具备四个必要条件：</p>
<ul>
<li><p><strong>不可抢占</strong>。</p>
<blockquote>
<p>已经分配给一个进程的资源不能强制性地被抢占，他只能被占有它的进程显式地释放。</p>
</blockquote>
</li>
<li><p><strong>互斥条件。</strong></p>
<blockquote>
<p>每个资源要么已经分配了一个进程，要么就是可用的。</p>
</blockquote>
</li>
<li><p><strong>占有和等待</strong>。</p>
<blockquote>
<p>已经得到了某个资源的进程还可以再请求新的资源。</p>
</blockquote>
</li>
<li><p><strong>环路等待</strong>。</p>
<blockquote>
<p>死锁发生时，系统中一定有由两个或者以上的进程组成一条环路，该环路中每个进程都在等待着下一个进程所占有的资源。</p>
</blockquote>
</li>
</ul>
<p><strong>注意：死锁发生时，以上四个条件一定是同时满足的。任何一个不成立就不会发生死锁</strong></p>
<h2 id="死锁建模"><a href="#死锁建模" class="headerlink" title="死锁建模"></a>死锁建模</h2><p>在讨论死锁解决方案之前，讨论如何对死锁建模是有意义的。有个叫Holt的人指出可以利用有向图建立死锁四个条件的模型——在有向图中有两类节点：用圆形表示进程，用方形表示资源。从资源节点到进程节点的有向边代表该资源已被请求、授权并被进程占用，由进程节点到资源节点的有向边表明当前进程正在请求该资源。以下是一个示意图：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE1.png" alt="死锁建模示意图"></p>
<p>图中，当前资源R整备进程A占用，进程B正等待着资源S，图c)进入了死锁状态，进程C等待着资源T，资源T被进程D占用，进程D又等待着由进程C占用的资源U。</p>
<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><p>总而言之，有四种处理死锁的策略：</p>
<ul>
<li><p>忽略该问题。也许如果你忽略它，他也会忽略你。</p>
</li>
<li><p>检测死锁并恢复。</p>
<blockquote>
<p>让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题。</p>
</blockquote>
</li>
<li><p>仔细对资源进行分配，动态地避免死锁。</p>
</li>
<li><p>破坏引起死锁的四个必要条件之一，防止死锁产生。</p>
</li>
</ul>
<p>以下对这四种策略分别阐述。</p>
<h3 id="忽略问题"><a href="#忽略问题" class="headerlink" title="忽略问题"></a>忽略问题</h3><p>最简单的方法是<strong>鸵鸟算法：</strong>把头埋进沙子里，假装根本没有问题发生。不同人对于该方法的看法不同，数学家认为这种方法不能接受，不管代价多大，都要彻底防止死锁产生；而对于工程师，它们会考量死锁发生的频率和严重性，如果平均5年一次死锁，那么大多数工程师不会以性能损失和可用性代价去防止死锁。</p>
<h3 id="检测死锁和死锁恢复"><a href="#检测死锁和死锁恢复" class="headerlink" title="检测死锁和死锁恢复"></a>检测死锁和死锁恢复</h3><h4 id="每种类型一个资源的死锁检测"><a href="#每种类型一个资源的死锁检测" class="headerlink" title="每种类型一个资源的死锁检测"></a>每种类型一个资源的死锁检测</h4><p>从最简单的例子开始，假定每种类型的资源只有一个，即排除了同时有两台打印机的情况。我们假设一个系统包括A到G共7个进程，R到W共6中资源，资源的占有情况和进程对资源的请求情况如下：<br>（1）A进程持有R资源，且需要S资源。<br>（2）B进程不持有任何资源，但需要T资源。<br>（3）C进程不吃油任何资源，但需要S资源。<br>（4）D进程持有U资源，且需要S资源和T资源。<br>（5）E进程持有T资源，且需要V资源。<br>（6）F进程持有W资源，且需要S资源。<br>（7）G进程持有V资源，且需要U资源。</p>
<p><strong>问：系统是否存在死锁？如果存在，涉及哪些进程？</strong></p>
<p>回答这一问题，初看很难，但是建模构造一张资源分配图之后，可以直观地看到图中包含了一个环，如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE2.png" alt="对问题建模"></p>
<p>在换种，可以看出进程D、E、G已经死锁，A、C、F没有死锁，因为可以把资源S分配给它们中的任意一个。</p>
<h4 id="每种类型有多个资源的死锁检测"><a href="#每种类型有多个资源的死锁检测" class="headerlink" title="每种类型有多个资源的死锁检测"></a>每种类型有多个资源的死锁检测</h4><p>如果一类资源可能存在多个，就需要采用另一个方法来检测死锁。现在我们提供一种基于矩阵的算法来检测从P1到Pn这n个进程中的死锁。假设资源类型数为m，E1代表资源类型1，E2代表资源类型2，以此类推。E是<strong>现有资源向量</strong>，代表每种已存在的资源总数，比如资源类型1代表磁带机，那么E1=2就表示系统有两台磁带机。</p>
<p>在任意时刻，某些资源已被分配所以不可用，假设A是<strong>可用资源向量</strong>，那么Ai表示当前可供使用的资源数（即没有被分配的资源）。如果仅有的两台磁带机都已经分配出去了，那么A1的值为0 。</p>
<p>现在我们需要两个数组：C代表当前<strong>当前分配矩阵</strong>，R代表<strong>请求矩阵</strong>。C的第i行代表Pi当前所持有的每一种类型资源的资源数，所以Cij代表进程i所持有的资源j的数量，同理Rij代表Pi所需要的资源j的数量，数据结构如下图：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE3.png" alt="矩阵数据结构"></p>
<p>这四种数据结构之间有一个重要的恒等式，具体地说，某种资源要么已分配，要么可用，这个结论意味着：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE4.png" alt="资源等式"></p>
<p>换言之，如果我们将所有已分配的资源j的数量加起来在和所有可供使用的资源数相加，结果就是该类资源的资源总数。死锁检测算法就是给予向量的比较，我们定义向量A和向量B之间的关系为A小于或等于B以表明A的每一个分量要么等于要么小于和B向量对应的分量。</p>
<p>每个进程起初是没有被标记的，算法开始会对进程做标记，进程被标记后就表明它们能够被执行，不会进入死锁，死锁检测算法如下：</p>
<ol>
<li>寻找一个没有标记的进程Pi，对于它而言，R矩阵的第i行向量小于或等于A。</li>
<li>如果找到了这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转到第1步。</li>
<li>如果没有这样的进程，算法终止。</li>
</ol>
<p>算法的第1步是寻找可以运行完毕的进程，该进程有资源请求并且该请求可被当前的可用资源满足。这一选中的进程随后就被运行完毕，在这段时间内它释放自己持有的所有资源并将它们返回到可用资源库中，然后，这一进程被标记为完成，如果所有的进程最终都能运行完的话，就不存在死锁，如果进程一直不能被运行，那它们就是死锁进程。</p>
<h4 id="从死锁恢复"><a href="#从死锁恢复" class="headerlink" title="从死锁恢复"></a>从死锁恢复</h4><p>我们讨论各种从死锁中恢复的方法，尽管这些方法看起来都不那么令人满意：</p>
<ul>
<li><p>利用抢占恢复。</p>
<blockquote>
<p>临时将资源从当前所有者哪里转移到另一个进程，许多情况下这是需要人工敢于的。比如，要将激光打印机从它持有的进程那里拿走，管理员可以收集已打印好的文档，然后该进程被挂起，接着打印机被分配给另一个进程。</p>
</blockquote>
</li>
<li><p>利用回滚恢复。</p>
<blockquote>
<p>周期性地将进程的状态写入一个文件以备重启。一旦检测到死锁，拥有所需要资源的进程会回滚到一个时间点，在此时间点之前该进程获得了一些其他资源，在该检查点之后所做的工作都丢失。实际上，是将该进程复位到一个更早的状态，那时候它还没取得所需的这个资源。接着就把这个资源分配给一个死锁进程。</p>
</blockquote>
</li>
<li><p>杀死进程恢复。</p>
<blockquote>
<p>杀死环中的一个进程。或者杀死环外带有该资源的一个进程。</p>
</blockquote>
</li>
</ul>
<h3 id="动态避免死锁"><a href="#动态避免死锁" class="headerlink" title="动态避免死锁"></a>动态避免死锁</h3><p>利用资源轨迹图、安全状态和不安全状态、银行家算法去解决。这里略复杂，暂时先不深入研究。</p>
<h3 id="破坏引起死锁的四个条件之一"><a href="#破坏引起死锁的四个条件之一" class="headerlink" title="破坏引起死锁的四个条件之一"></a>破坏引起死锁的四个条件之一</h3><ul>
<li><p>破坏互斥条件，如果资源不被一个进程独占，那么死锁肯定不会产生。</p>
<blockquote>
<p>当然，允许两个进程同时使用打印机会造成混乱，通过采用<strong>假脱机（spooling printer）</strong>技术可以允许若干个进程同时产生输出。该模型中唯一真正请求使用物理打印机的进程是打印机守护进程，由于守护进程绝不会请求其他资源，因此不会产生死锁。</p>
</blockquote>
</li>
<li><p>破坏占有和等待条件。只要禁止已持有资源的进程再等待其他资源便可以消除死锁。</p>
<blockquote>
<p>一种实现方法是规定所有进程在开始执行前请求所需的全部资源。如果所需的全部资源可用，那么就将它们分配给这个进程，于是该进程肯定能够运行结束。如果一个或者多个资源正被使用，那么就不分配，进程等待。<strong>另一种</strong>方案是，要求当一个进程请求资源时，先暂时释放其当前占用的所有资源，然后再尝试一次获得所需要的全部资源。</p>
</blockquote>
</li>
<li><p>破坏不可抢占条件。</p>
<blockquote>
<p>假如一个进程已分配到一台打印机且正在进行打印输出，如果由于它需要的绘图仪无法获得而强制性把打印机抢占掉，则会引起混乱。但是，一些资源可以通过虚拟化的形式来避免发生这样的情况，假脱机打印机向磁盘输出，并且只允许打印机守护进程访问真正的物理打印机，就可以消除涉及打印机的死锁。<strong>然而，不是所有资源都可以进行类似的虚拟化，比如数据库中的记录在操作的时候必须要锁定，因此存在死锁的可能</strong></p>
</blockquote>
</li>
<li><p>破坏环路等待。</p>
<blockquote>
<p>消除环路有几种方法。比较靠谱的方案是，对所有的资源统一编号，现在的规则是，进程可以在任何时刻提出资源请求，但是所有请求必须按照资源编号的顺序（升序）提出，如下图所示，进程可以先请求打印机后请求磁带机，但不可以先请求绘图仪后请求打印机。</p>
</blockquote>
</li>
</ul>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE5.png" alt="资源排序"></p>
<p><strong>最后，总结一张图用于预防死锁：</strong></p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE6.png" alt="预防死锁的方法汇总"></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2018/05/29/%E4%B9%A6-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/29/%E4%B9%A6-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：进程与线程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-29 18:00:00" itemprop="dateCreated datePublished" datetime="2018-05-29T18:00:00+08:00">2018-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:50:12" itemprop="dateModified" datetime="2019-11-17T21:50:12+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>进程是操作系统提供的最古老也是最重要的抽象概念之一。即使CPU只有一个，但他们也支持（伪）并发操作的能力。他们将一个单独的CPU变换成多个虚拟的CPU，没有进程的抽象，现代计算将不复存在。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>在任何多道程序设计系统中，CPU由一个进程快速切换到另一个进程，使每个进程各运行几十或者几百个毫秒，严格地来说，在某一个瞬间，CPU只能运行一个进程，但在1秒钟期间，它可能运行多个进程，这样就能产生并行的错觉，这就是伪并行。伪并行概念用来区分<strong>多处理器系统</strong>（系统有两个或者更多CPU并共享同一个物理内存）的真正硬件并行。</p>
<h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><p>一个进程就是一个正在执行的程序的实例，包括程序计数器、寄存器和变量当前值。从概念上讲，每个进程拥有它自己的CPU，当然，真正的CPU在各进程间来回切换，这种快速的切换称作<strong>多道程序设计</strong>。在多道程序计算机内存中有若干道程序，这些程序被抽象为若干个各自拥有自己控制流程（即每个程序自己的逻辑程序计数器）的进程，并且每个程序都独立地运行。当然，实际上只有一个物理程序计数器，所以程序运行时，它的逻辑程序计数器被装入实际的程序计数器，当该程序结束（或暂停）执行时，物理程序计数器被保存在内存中该进程的逻辑程序计数器中。</p>
<p>由于CPU在各进程之间来回快速切换，所以每个进程执行器运算的速度是不确定的，并且当同一进程再次运行时，器运算速度通常也不可再现。例如，考虑一个 I/O 进程，它执行一个10000次的空循环以等待磁带机达到正常速度，然后发出命令读取第一个记录。如果CPU决定在空循环期间切换到其他进程，则磁带机进程可能在第一条记录通过磁头之后还未被再次执行。</p>
<p>进程和程序间的却别是微妙的，但是非常重要。想象以为父亲正在为他的女儿烘制生日蛋糕，则做蛋糕的食谱就是程序（即用适当形式描述的算法），这位父亲是处理器（CPU），而做蛋糕各种原料（面粉、糖、鸡蛋等）就是输入的数据，<strong>进程就是他阅读食谱、取各种原料以及烘制蛋糕等一系列动作的总和</strong>。现假设他的儿子被蜜蜂蛰了哭着跑进来，父亲于是就记录下当前照着食谱做到哪里了（保存进程当前状态），拿出急救手册，为儿子处理蜇伤，我们看到处理机从一个进程（做蛋糕）切换到另一个优先级高的进程（医疗救治），每个进程有各自的程序（食谱和急救手册）。当急救完成之后，父亲又继续做蛋糕，从离开时的那一步继续做下去。值得注意的是，我们可能经常两次去启动同一个字处理软件，即一个程序运行了两遍，这也要算作两个进程。</p>
<h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>有4中主要事件导致进程创建：</p>
<ul>
<li><p>系统初始化</p>
<blockquote>
<p>启动操作系统时，通常会创建若干进程，这些进程中有些是前台进程，用于同用户（人类）交互。其他的是后台进程，后台进程一般具有某些专门的功能，例如，设计一个后台进程接收发来的电子邮件，这个进程在一天的大部分时间都在睡眠，但是当电子邮件达到时就被唤醒了。停留在后台处理诸如电子邮件、web页面、新闻、打印之类的活动的进程称为<strong>守护进程（daemon）</strong>。</p>
</blockquote>
</li>
<li><p>正在运行的进程进行系统调用创建</p>
<blockquote>
<p>正在运行的进程发出系统调用，以便创建一个或者多个线程协助其工作。</p>
</blockquote>
</li>
<li><p>用户请求创建一个新的进程。</p>
<blockquote>
<p>用户双击图标或者输入命令行，启动一个新的程序。</p>
</blockquote>
</li>
<li><p>一个批处理作业的初始化</p>
<blockquote>
<p>仅在大型机的批处理系统中应用，用户在这种系统中提交批处理作业，在操作系统认为有资源科运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。</p>
</blockquote>
</li>
</ul>
<p>在Unix系统中，只有一个系统调用可以创建新的进程：<strong>fork</strong>。它会创建一个与调用进程相同的副本，这两个进程（父进程和子进程）拥有相同的存储镜像、同样的环境字符串和同样的打开文件，这就是全部情形。通常，子进程接着执行execve或者一个类似的系统调用，以修改器存储镜像并运行一个新的程序。例如，当一个用户在shell中输入sort时，shell就创建一个子进程，然后这个子进程执行sort。在Windows中，情形正相反，一个win32函数调用 CreateProcess既处理进程的创建，也负责把正确的程序装入新的进程。不论在Unix还是Windows中，进程创建后，父进程和子进程有各自不同的地址空间。</p>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>进程终止，通常由下列条件引起：</p>
<ul>
<li><p>正常退出（自愿）</p>
<blockquote>
<p>进程完成了自己的工作，调用系统调用，通知工作已经完成。</p>
</blockquote>
</li>
<li><p>出错退出（自愿）</p>
<blockquote>
<p>进程发现了严重错误，如要编译某个文件，但是该文件不存在，于是编译器就会退出。再给出了错误参数时，面向屏幕的交互式进程通常不退出，相反，这些程序会弹出一个对话框，并要求用户再试一次。</p>
</blockquote>
</li>
<li><p>严重错误（非自愿）</p>
<blockquote>
<p>进程引起的错误，通常是由于程序中的错误导致，例如执行了非法指令，引用不存在的内存等。在这类错误中，进程会收到信号（被中断），而不是在这类错误出现时终止。</p>
</blockquote>
</li>
<li><p>被其他进程杀死（非自愿）</p>
</li>
</ul>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但进城之间经常需要相互作用，一个进程的输出结果可能作为另一个进程的输入，在shell命令：</p>
<blockquote>
<p>cat chapter1 chapter2 chapter3 | grep tree</p>
</blockquote>
<p>中，第一个进程运行cat，将三个文件链接并输出，第二个进程运行grep，它从输入中选择所有包含单词tree的那些行。根据这两个进程的相对速度，可能发生这种情况：grep准备就绪可以运行，但输入还没有完成，于是必须阻塞grep；还有可能是：一个概念上能够运行的进程被迫停止，因为操作系统调度另一个进程占用了CPU。下图可以看到显示进程的三种状态的状态图：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE1.png" alt="进程三种状态"></p>
<p>运行态和就绪态在逻辑上是类似的，二者都可以运行，只是后者还没有CPU分配给它，阻塞态就完全不同，处于该状态的进程不能运行，即使CPU空闲也不行。在操作系统发现进程不能继续运行下去时，发生转换1；转换2和3是由于进程调度引起的；当进程等待的一个外部事件发生时（如一些输入到达），则发生转换4。</p>
<h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p>操作系统维护者一张表格，即进程表（process table）。每个进程占用一个进程表项，该表项包含了进程状态的重要信息，诸如程序计数器、堆栈指针，内存分配状况、所打开的文件的状态、账号和调度信息等。下图展示了典型系统中的关键字段：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE2.png" alt="典型的进程表项字段"></p>
<h3 id="多道程序设计模型"><a href="#多道程序设计模型" class="headerlink" title="多道程序设计模型"></a>多道程序设计模型</h3><p>采用多道程序设计可以提高CPU利用率，从概率的角度来看cpu的利用率是比较好。假设一个进程等待I/O操作的时间与其停留在内存中的时间比是<em>p</em>,当内存中有n个进程时，则所有n个进程都在等待I/O（此时CPU空转）的概率是p的n次方，CPU的利用率由一下公式给出：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE3.png" alt="CPU利用率公式"></p>
<p>从完全精确的角度考虑，应该指出此概率模型只是描述了一个大致的状况。它假设所有n个进程都是独立的，即内存中的5个进程中，3个运行，2个等待是完全可以接受的，但在单cpu中，不能同时运行3个进程，所以当CPU忙时，已就绪的进程必须等待CPU，因而，进程不是独立的，更精确的模型应该使用排队论构造，但它仍然是具有参考意义的，下图以n为变量的函数表示CPU的利用率，n称为多道程序设计的<strong>道数（degree of multiprogramming）</strong>。</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE4.png" alt="CPU利用率-道数的关系"></p>
<p>从图中可以看到，如果进程花费80%的时间等待I/O，为使CPU的浪费低于10%，至少要有10个进程同时在内存中。当读者认识到一个等待用户从终端输入的交互式进程是处于I/O等待状态时，很明显，80%甚至更多的I/O等待时间是普遍的，即使是在服务器中，做大量磁盘I/O操作的进程也会花费同样或更多的等待时间。虽然图中的模型很粗略，但它依然对预测CPU的性能很有效。例如，假设计算机有512MB内存，操作系统占128MB，每个用户程序占128MB，那么这些内存允许3个用户程序同时驻留内存，若80%时间用于I/O等待，则CPU利用率大约是1-0.8<em>0.8</em>0.8 ，大约49%，在增加512MB内存后，CPU利用率可以提高到79%，换而言之，第二个512M内存提高了30%的吞吐量。但是增加第三个512MB内存只能讲CPU利用率提高到91%，吞吐量仅提高12%，因此可以确定第一次增加内存是合算的投资，第二个则不是。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><p>人们认为需要使用线程的理由如下：</p>
<ul>
<li><p>并行的线程可以共享同一个地址空间和所有可用数据的。</p>
<blockquote>
<p>对于某些应用而言，这是必需的，二者正式多进程模型（它们具有不同的地址空间）所无法表达的。</p>
</blockquote>
</li>
<li><p>线程比进程更轻量级，更快捷地创建和撤销。</p>
<blockquote>
<p>在许多系统中，创建一个线程较一个进程要快10~100倍。在有大量线程需要动态和快速修改时，这一特性很有用。</p>
</blockquote>
</li>
<li><p>若多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行，从而加快应用程序执行速度。</p>
</li>
<li><p>在多CPU系统中，多线程是有益的，在这样的系统中，真正的并行有了实现的可能。</p>
</li>
</ul>
<p>假如字处理软件被编写成含有3个线程的程序，一个与用户交互，另一个在后台重新进行格式处理，一旦有某一句语句被删掉，交互线程就通知格式化线程对整个文档重新进行处理，同时交互线程继续监控键盘和鼠标，并相应诸如滚动到第一页之类的简单命令。剩下那个每隔一段时间进行磁盘备份，防止程序崩溃或者系统崩溃。拥有三个线程的情形如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE5.png" alt="三个线程协同"></p>
<p>如果程序是单线程的，那么在进行磁盘备份时，来自键盘和鼠标的命令就会被忽略，直到备份工作完成为止。并且，很显然在这里三个不同的进程是不能工作的，这是因为三个线程都需要在同一个文件上进行操作，通过让三个线程代替三个进程，三个线程共享公共内存，于是它们都可以访问同一个正在编辑的文件。</p>
<p>现在考虑另一个多线程发挥作用的例子，一个web服务器，某些页面较其它页面相比，有更多的访问，比如对主页的访问比其它更深层次的页面访问次数更多。利用这一事实，web服务器可以把获得大量访问的页面集合保存在内存中，这样的一种页面集合称为<strong>高速缓存（cache）</strong>，高速缓存也应用在其它很多场合。一种组织web服务器的方式如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE6.png" alt="多线程web服务器"></p>
<p>上图中，一个称为分派程序（dispatcher）的线程从网络中读入工作请求，在检查请求之后，分派现成挑选一个空转的（即被阻塞的）工作线程（worker thread）提交该请求。接着分派现成唤醒该工作线程，将它由阻塞状态转变为就绪状态。工作线程被唤醒后，它检查有关的请求是否在web页面的cache中，这个高速缓存是所有线程都可以访问的，如果没有，该线程开始执行从磁盘中调入页面的I/O操作，并且进入阻塞直到磁盘操作完成。当上述工作线程阻塞在磁盘操作时，为了完成更多操作，分派线程可能挑选另一个工作线程运行，也可以把另一个已经就绪的工作线程投入运行。</p>
<p>这种模型允许把服务器编写为一个集合，在分派线程的程序中包含一个无限循环，该循环用来获得工作请求并把工作请求派给工作线程。每个工作线程的代码包含一个从分派线程接收请求的无限循环，收到请求后，如果页面存在，则返回给客户机，接着该工作线程阻塞，等待一个新的请求到来。</p>
<p>在没有多线程的情况下，编写web服务器。一种可能的方式是：web服务器的主循环获得请求，检查请求，并在取下一个请求之前完成整个工作。在等待磁盘操作时，服务器空转，不处理任何到来的其他请求。课件线程较好地改善了web服务器的性能。如果对于这种性能的降低不可接受，那如果使用read系统调用，则还有一种可能的方式。在请求到来时，这个唯一的线程对请求进行考察，如果请求能在高速缓存中得到满足，那么一切都好，否则，就启动一个非阻塞的磁盘操作。服务器在表格中记录当前请求的状态，然后去处理下一个事件。下一个事件可能是一个新工作的请求，或是磁盘对先前操作的回答。如果是新工作的请求，就开始该工作；如果是磁盘的回答，就从表格中取出对应的信息，并处理该回答。对于非阻塞磁盘I/O而言，这种回答多数会以信号或者中断的形式出现。<strong>注意，这种情况下，“顺序进程”模型消失了，每次服务器从为某个请求工作的状态切换到另一个状态时，都必须显式地保存或者重新装入相应的计算状态。</strong>这里，每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，我们把这类设计称为<strong>有限状态机（finite-state machine）</strong>。</p>
<p>现在很清楚多线程必须提供的是什么了，多线程使得“顺序进程”的思想得以保留下来，这种顺序进程阻塞了系统调用（如磁盘I/O），但是仍旧实现了并行性。</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE7.png" alt="构造服务器三种方法"></p>
<h3 id="经典线程模型"><a href="#经典线程模型" class="headerlink" title="经典线程模型"></a>经典线程模型</h3><p>进程用于把资源集中到一起，而线程是在CPU上被调度执行的实体。在同一个进程环境中，多个线程共享一个地址空间和其他资源，这意味着线程间共享同样的全局变量，一个线程也可以读、写甚至清除另一个线程的堆栈，线程间是没有保护的，因为这是没有必要的，因为同一个进程中的多个线程是合作而不是竞争关系。线程之间对于资源的持有如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE8.png" alt="线程与资源"></p>
<p>和传统进程一样（即只有一个线程的进程），线程可以处于若干种状态的任何一个：运行、阻塞、就绪或者终止。认识到每个线程有其自己的堆栈很重要，下图展示这一状况：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE9.png" alt="每个线程有自己的堆栈"></p>
<p>每个线程的堆栈有一帧，供各个被调用但是还没有从中返回的过程使用。例如，如果过程X调用过程Y，而Y又调用Z，那么当Z执行时，供X、Y和Z使用的帧会全部存在堆栈中。通常每个线程会调用不同的过程，从而有一个各自不同的执行历史，这就是为什么每个线程需要有自己的堆栈的原因。这里还可以了解线程的<strong>join</strong>操作和<strong>yield</strong>操作。</p>
<h3 id="POSIX-线程"><a href="#POSIX-线程" class="headerlink" title="POSIX 线程"></a>POSIX 线程</h3><p>POSIX线程是线程的POSIX（Portable Operating System Interface of UNIX，可移植操作系统接口）标准。它定义的线程包叫做Pthread。有两种主要的方法实现线程包：<strong>在用户空间中和在内核中</strong>。这两种方法互有利弊，不过混合实现方式也是可能的。</p>
<h3 id="在用户空间中实现线程"><a href="#在用户空间中实现线程" class="headerlink" title="在用户空间中实现线程"></a>在用户空间中实现线程</h3><p>这种方法是把整个线程包放在用户空间，内核对线程包一无所知，从内核角度考虑，就是按单线程进程方式管理。这种方法的优点：</p>
<ul>
<li>最明显的优点是：用户级线程包可以在不支持线程的操作系统上实现。<blockquote>
<p>线程在一个运行时系统的顶部运行，这个运行时系统是一个管理线程的过程的集合。在用户空间管理线程时，每个进程需要有其专用的<strong>线程表（thread table）</strong>，用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器等。该线程表由运行时系统管理，当一个线程转换到就绪态或者阻塞态时，需要在线程表中存放重新启动该线程所需的信息。如下图可以对比不同方式实现的线程包：</p>
</blockquote>
</li>
</ul>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE10.png" alt="用户级和内核级线程包"></p>
<ul>
<li><p>可以方便地在进程内调度切换到另一个线程，并且线程切换非常快捷。</p>
<blockquote>
<p>在线程运行完成，例如，线程调用thread_yield ，就可以把线程的信息保存在线程表中，进而，线程调度程序来选择另一个要运行的线程。保存该线程状态的过程和调度程序都只是本地过程，所以启动它们比进行内核调用效率更高。</p>
</blockquote>
</li>
<li><p>允许进程有自己定制的调度算法。</p>
<blockquote>
<p>例如，那些有垃圾收集线程的应用程序就不用担心线程会在不合适的时刻停止。</p>
</blockquote>
</li>
</ul>
<p>尽管用户级线程具有上述的优点，但是它的缺点也明显：</p>
<ul>
<li><p>第一个问题是如何实现阻塞系统调用。</p>
<blockquote>
<p>假设在还没有任何按键动作之前，一个线程读取键盘，让该线程时机进行该系统调用时不可接受的，因为这会停止所有的线程。使用线程的一个主要目标是：首先要允许每个线程使用阻塞调用，但是还要避免被阻塞的线程影响其他的线程。有了阻塞系统的调用，这个目标不太容易实现。</p>
</blockquote>
</li>
<li><p>页面故障问题。</p>
<blockquote>
<p>如果某个程序调用或者跳转到了一条不在内存的指令上，而操作系统将到磁盘上取回这个丢失的指令（和该指令的“邻居们”），这就称为<strong>页面故障</strong>。如果有一个线程引起页面故障，内核甚至不知道有线程存在，通常会把整个进程阻塞，直到磁盘I/O完成为止，尽管其他线程是可以运行的。</p>
</blockquote>
</li>
<li><p>如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU。</p>
<blockquote>
<p>在一个单独的进程内部，没有时间中断，所以不可能用轮转调度（轮流）的方式调度进程。</p>
</blockquote>
</li>
<li><p>可能反对用户级线程的最大负面意见是，程序员通常在经常发生线程阻塞的应用中才希望使用多个线程。</p>
</li>
</ul>
<h3 id="在内核中实现线程"><a href="#在内核中实现线程" class="headerlink" title="在内核中实现线程"></a>在内核中实现线程</h3><p>由上面在用户空间实现的线程和在内核空间实现的线程对比图可以看出，在内核中实现线程不在需要运行时系统，另外，每个进程中也没有线程表。所有能够阻塞线程的调用都以系统调用的形式实现，这与运行时系统过程相比，代价是相当可观的。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程或者运行另一个进程中的线程。而在用户级线程中，运行时始终运行自己进程的线程，直到内核剥夺它的CPU。如果某个进程中的线程引起页面故障，内核可以很方便地检查该进程是否还有其他可运行的线程，如果有，在等待所需要的页面从磁盘读入时，就选择一个线程运行。</p>
<p>在内核中实现线程有以下缺点：</p>
<ul>
<li><p>但是内核中创建、撤销、切换线程操作代价都比较大。</p>
<blockquote>
<p>在内核中尽量减少创建和撤销线程，最好能实现复用（在执行完成后，标记为不可运行，当要创建新线程时，再将其启用）。</p>
</blockquote>
</li>
<li><p>信号是发给进程而不是线程，当信号达到时要考虑将信号交给哪个线程处理。</p>
<blockquote>
<p>即使线程可以注册感兴趣的信号，但是多个线程注册同一个信号如何处理也是个问题。</p>
</blockquote>
</li>
</ul>
<h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3><p>有试图将用户级线程的优点与内核级线程的优点结合起来的方法，一种方法是使用内核级线程，然后将用户级线程与某些内核线程多路复用起来，如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE11.png" alt="用户级和内核级线程混合实现"></p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><em>这个部分看了两次都不甚明白，先跳过。</em></p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="进程行为"><a href="#进程行为" class="headerlink" title="进程行为"></a>进程行为</h3><p>几乎所有进程的（磁盘）I/O请求或计算都是交替突发的。如下图所示，CPU不停顿地运行一段时间，然后发出一个系统调用以便读写文件。如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE12.png" alt="突发进行"></p>
<p>图中有一件事值得注意，某些进程花了大多数时间在计算上，称为计算密集型；有些在等待I/O上花了大多数啊时间，称为I/O密集型。有必要指出，随着CPU越来越快，更多的进程倾向于I/O密集型，这里的基本思想是，如果需要运行I/O密集型进程，那么就应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙碌。</p>
<h3 id="何时调度"><a href="#何时调度" class="headerlink" title="何时调度"></a>何时调度</h3><ul>
<li>创建新进程后，决定运行父进程还是子进程。</li>
<li>在一个进程退出时必须做出调度决策。</li>
<li>一个进程阻塞时，必须选择另一个进程运行。</li>
<li>发生I/O中断时，做出调度决策。</li>
</ul>
<h3 id="调度算法的目标"><a href="#调度算法的目标" class="headerlink" title="调度算法的目标"></a>调度算法的目标</h3><p>在讨论目标前，有必要了解我们会处于那些环境中，在不同的应用领域有不同的环境，可以将其分为三类：</p>
<ul>
<li>批处理</li>
<li>交互式</li>
<li>实时</li>
</ul>
<p>下图针对所有环境列出不同的目标：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE13.png" alt="不同环境不同目标"></p>
<p><strong>批处理系统的调度算法</strong></p>
<blockquote>
<p>先来先服务<br>最短作业优先<br>最短剩余时间优先</p>
</blockquote>
<p><strong>交互式系统调度算法</strong></p>
<blockquote>
<p>轮转调度<br>优先级调度<br>多级队列调度：<br>最短进程优先<br>保证调度<br>彩票调度<br>公平分享调度</p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/22/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">215</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共433.2k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/21/',]
      });
      });
  </script>


</body>
</html>
