<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/2/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">173</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(10-1)%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(10-1)%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">Java筑基-：线程基本使用入门（2）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-10 19:25:00" itemprop="dateCreated datePublished" datetime="2023-05-10T19:25:00+08:00">2023-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-17 22:13:34" itemprop="dateModified" datetime="2023-05-17T22:13:34+08:00">2023-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、分而治之思想"><a href="#一、分而治之思想" class="headerlink" title="一、分而治之思想"></a>一、分而治之思想</h2><p>算法中分而治之思想和动态规划思想有点类似，要注意区分：</p>
<ul>
<li><p><strong>分而治之:</strong> 将一个任务分割成很多小任务，并且各个任务之间无关联</p>
</li>
<li><p><strong>动态规划：</strong> 将一个任务 A 分割成很多小任务，比如 a1、a2、a3 ，假如存在 a1 执行完成才能执行a3，那就是小任务有关联性了，这就是动态规划思想了</p>
</li>
</ul>
<blockquote>
<p> 快排，归并，二分都是分而治之的思想。</p>
</blockquote>
<p>在 Java 7 中提供了 Fork/Join 工具（Fork：将任务拆分成很多独立的子任务；Join：将所有的子任务结果合并）来让分而治之的思想并发执行起来。当然，我们也可以不使用这个框架，自己将任务分成很多小任务，然后用多线程去执行。不过呢，Java 的 ForkJoin 给提供了<strong>工作窃取（work-stealing）</strong> 算法，能够让执行更高效。</p>
<h3 id="2-1-工作窃取"><a href="#2-1-工作窃取" class="headerlink" title="2.1 工作窃取"></a>2.1 工作窃取</h3><p><strong>工作窃取（work-stealing）</strong> 简单来说就是空闲线程试图从繁忙线程的 deques 中窃取工作。</p>
<p>默认情况下，每个工作线程从自己的双端队列中获取任务，但如果自己队列中任务已经执行完成，队列为空时，它就会从另一个繁忙线程的双端队列尾部或者全局入口队列中获取任务，因为这是最大概率可能找到工作的地方。</p>
<blockquote>
<p>为什么会有任务先执行完成呢？因为工作量的划分不一定均等。即使是相同数量的数字相加，比如，每个任务都是10个数字相加，如果数字很大的话，耗时也会很长。</p>
</blockquote>
<h2 id="二、Java-提供的-ForkJoin"><a href="#二、Java-提供的-ForkJoin" class="headerlink" title="二、Java 提供的 ForkJoin"></a>二、Java 提供的 ForkJoin</h2><p>Java 提供分而治之的框架： ForkJoin。既然是要提交任务，我们需要对任务进行封装，ForkJoin 提供了 ForkJoinTask<v> 来包装任务：</v></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>不过一般不直接使用它，而是用它的 2 个主要的子类：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">RecursiveAction</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>从这 2 个子类我们能看出，RecursiveTask 更适合有返回值的情形；RecursiveAction 适合没有返回值的情形。ForkJoinTask 它有2种使用方法：</p>
<ul>
<li><p>同步用法：采用 invoke 来提交任务</p>
</li>
<li><p>异步用法：采用submit 或者 execute 方法来提交任务</p>
</li>
</ul>
<p>使用 ForkJoin 的方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] src = MakeArray.makeArray();</span><br><span class="line">    <span class="comment">//第一步，创建池子</span></span><br><span class="line">    ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    <span class="comment">//第二步：构建任务</span></span><br><span class="line">    SumTask innerFind = <span class="keyword">new</span> SumTask(src, <span class="number">0</span>, src.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//第三步、提交，invoke 意味着同步执行</span></span><br><span class="line">    pool.invoke(innerFind);</span><br><span class="line">    <span class="comment">//第四步、获取结果</span></span><br><span class="line">    System.out.println(<span class="string">"the result is "</span> + innerFind.join() +</span><br><span class="line">            <span class="string">"，spend time："</span> + (System.currentTimeMillis() - start));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中，makeArray 只是用来生成一个数组：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeArray</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_LENGTH = <span class="number">4000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> THRESHOLD = <span class="number">47</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] makeArray() {</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[ARRAY_LENGTH];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_LENGTH; i++) {</span><br><span class="line">            result[i] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>真正的任务代码，由于我们需要有返回值，所以我们继承了 RecursiveTask ：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREASHOLD = MakeArray.ARRAY_LENGTH / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] src;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fromIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> toIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.src = src;</span><br><span class="line">        <span class="keyword">this</span>.fromIndex = fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.toIndex = toIndex;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//判定任务大小是否合适</span></span><br><span class="line">        <span class="keyword">if</span> (toIndex - fromIndex &lt; THREASHOLD) {</span><br><span class="line">            <span class="comment">//满足要求，计算结果</span></span><br><span class="line">            System.out.println(<span class="string">"from index = "</span> + fromIndex + <span class="string">"，toIndex = "</span> + toIndex);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt;= toIndex; i++) {</span><br><span class="line">                <span class="comment">//Thread.sleep(1);</span></span><br><span class="line">                count = count + src[i];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//还不满足要求，则继续拆分任务</span></span><br><span class="line">            <span class="keyword">int</span> mid = (fromIndex + toIndex) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//拆分出左边的任务</span></span><br><span class="line">            SumTask left = <span class="keyword">new</span> SumTask(src, fromIndex, mid);</span><br><span class="line">            <span class="comment">//拆分出右边的任务</span></span><br><span class="line">            SumTask right = <span class="keyword">new</span> SumTask(src, mid + <span class="number">1</span>, toIndex);</span><br><span class="line">            <span class="comment">//提交到我们创建的 pool 中</span></span><br><span class="line">            invokeAll(left, right);</span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在重写的 compute 方法中，我们不断拆分任务，直至任务满足我们定义的阈值位置。计算量越大，中途 IO 操作越多 或者 休眠时间越多， ForkJoin 的优势越明显。如果只是少量数据，那么由于：</p>
<ol>
<li><p>ForkJoin 的递归调用</p>
</li>
<li><p>ForkJoin 多线程切换</p>
</li>
</ol>
<p>反而导致还没单线程那么快。但是当计算过程中有IO 操作或者休眠时间时，ForkJoin 在大量数据情况下的优势就会显示出来。我们注意上述代码中注释的代码 ： Thread.sleep(1); 如果在单线程计算和 ForkJoin 计算过程中都休眠 1ms ，后续导致的耗时差异是很大的，这个可以自行验证。</p>
<p>上面我们看了同步的操作，接下来看下如果进行异步操作，以下代码将根据指定的文件中，所有的 txt 文件，有可能文件下还有目录：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">        FindDirFiles task = <span class="keyword">new</span> FindDirFiles(<span class="keyword">new</span> File(<span class="string">"D:/"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步提交</span></span><br><span class="line">        pool.execute(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程做自己的事情</span></span><br><span class="line">        System.out.println(<span class="string">"Task isRuning"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"doing other works"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取结果，这是一个阻塞方法</span></span><br><span class="line">        task.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于上述join 是阻塞方法，所以一定得有结果之后，才会打印下面的 task end</span></span><br><span class="line">        System.out.println(<span class="string">"task end"</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>首先 main 方法中调用与上述的同步差不多，只不过在使用 execute 异步调用后，主线程的日志和子线程的日志同时在打，最后，我们会调用 task.join 阻塞方法，这也导致当所有文件遍历完成后，才会在main 线程中 输出最后的 task end 语句。我们看下 FindDirFiles 的实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindDirFiles</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> File path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FindDirFiles</span><span class="params">(File path)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>{</span><br><span class="line">        List&lt;FindDirFiles&gt; subTasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        File[] files = path.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">for</span> (File file : files) {</span><br><span class="line">                <span class="keyword">if</span> (file.isDirectory()) {</span><br><span class="line">                    <span class="comment">//对每个子目录新建一个子任务</span></span><br><span class="line">                    subTasks.add(<span class="keyword">new</span> FindDirFiles(file));</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">//遇到文件，检查</span></span><br><span class="line">                    <span class="keyword">if</span> (file.getAbsolutePath().endsWith(<span class="string">"txt"</span>)) {</span><br><span class="line">                        System.out.println(<span class="string">"文件："</span> + file.getAbsolutePath());</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!subTasks.isEmpty()) {</span><br><span class="line">                <span class="comment">//在当前的 ForkJoinPool 上调度所有的子任务</span></span><br><span class="line">                <span class="keyword">for</span> (FindDirFiles subTask : invokeAll(subTasks)) {</span><br><span class="line">                    subTask.join();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于不需要返回结果，所以我们继承 RecursiveAction 即可，在 compute 中，我们将为每个目录创建一个 Task 加入 list 中，最后一并 invokeAll 执行。</p>
<h2 id="三、CountDownLatch"><a href="#三、CountDownLatch" class="headerlink" title="三、CountDownLatch"></a>三、CountDownLatch</h2><p>它的作用是等待一个线程或者多个线程执行完成后再执行后续的操作。比如说要等所有的初始化工作（多个子线程）执行完成之后，才进入主线程执行。</p>
<p>对于 CountDownLatch 而言，计数器和线程数量是没关系的，有可能在同一个线程中做 2 个任务执行  2 次 countDown 操作。</p>
<p>线程做完 countDown 操作之后，能够继续执行，并不是说一定就要关闭之类的。</p>
<p>CountdownLatch 的 await 方法（即等待所有的扣减到 0 后才能执行的地方）可以在多个地方使用，比如同时在 主线程调用 countDownLatch.await() 以及在某个子线程中调用 countDownLatch.await() ，当 countDownLatch 计数器减为 0 的时候，主线程和那个子线程都会被唤醒接着执行。</p>
<h2 id="四、CyclicBarrier"><a href="#四、CyclicBarrier" class="headerlink" title="四、CyclicBarrier"></a>四、CyclicBarrier</h2><p>它的主要思想是，在某个点设置一个屏障， 比如 3 个线程，如果 A 线程先执行完成，它会 await 在那里等待；同样 B 线程也会这样，一直到 C 线程也执行完成，此时，3个线程才一起执行。它有 2 个主要构造方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parties 表示操控的线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以及：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中第二个 构造方法的 barrierAction 表示的是，当所有的操控的线程都执行到这个屏障的时候，此时优先执行一下这个 Rnnable ，之后三个线程才继续执行。这样做的一个好处就是：</p>
<p>举个例子吧，如果3 个线程计算一个任务的 3 个部分，这时候，我们可以用设置这个 Runnable 来合并这 3 部分结果，之后，这 3 个线程都拿着合并后的结果执行后面的操作。</p>
<h2 id="五、CountDownLatch-与-CyclicBarrier-的区别"><a href="#五、CountDownLatch-与-CyclicBarrier-的区别" class="headerlink" title="五、CountDownLatch 与  CyclicBarrier 的区别"></a>五、CountDownLatch 与  CyclicBarrier 的区别</h2><p>虽然二者在功能上很相似，但其实是有很大区别的，主要体现在：</p>
<ul>
<li><p>CountDownLatch 定义的数字只能扣减一次，CyclicBarrier 能多次调用 await ，后续的 await 还都能触发 barrierAction 的执行</p>
</li>
<li><p>CountDownLatch 用外部线程协调；而 CyclicBarrier 本身相互协调</p>
</li>
<li><p>CountDownLatch 扣减数和线程数不一样，比如一个线程可以 countdown 多次；但 CyclicBarrier 初始化时传入的 数量必须是管控的线程数量</p>
</li>
<li><p>这点没大听懂，大体是说 CountDownLatch 运行中不允许其他线程执行；而CyclicBarrier 可以通过 barrierAction 执行其他线程任务。<font color="#ff0000">还需要额外确认这点</font></p>
</li>
</ul>
<h2 id="六、Semaphore"><a href="#六、Semaphore" class="headerlink" title="六、Semaphore"></a>六、Semaphore</h2><p>主要用于<strong>流控</strong>的场景。比如，数据库最多只能有 10 个连接，那么我们可以通过 Semaphore 发放 10 个 <strong>许可证</strong>。在正常使用的时候通过 acquire 和 release  来控制获取和释放操作。还是看如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionImpl</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>{</span><br><span class="line">    。。。省略实现</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>{</span><br><span class="line">    <span class="comment">//许可证数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> POOL_SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2个新号指示器，分别表示 池子还有可用的连接 / 已用的连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore useful, uselessful;</span><br><span class="line">    <span class="comment">//存放资源的池子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="comment">//初始化放入资源</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) {</span><br><span class="line">            pool.addLast(<span class="keyword">new</span> ConnectionImpl());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SemaphoreDemo</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.useful = <span class="keyword">new</span> Semaphore(POOL_SIZE);</span><br><span class="line">        <span class="keyword">this</span>.uselessful = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归还连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnConnection</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"当前有"</span> + useful.getQueueLength() + <span class="string">"个线程等待连接，"</span></span><br><span class="line">                    + <span class="string">"可用连接数："</span> + useful.availablePermits());</span><br><span class="line">            <span class="comment">//通过 uselessful 的 acquire 来获取空位</span></span><br><span class="line">            <span class="keyword">synchronized</span> (pool) {</span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//许可证释放</span></span><br><span class="line">            useful.release();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">takeConnect</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//获取许可，如果没有许可可能阻塞</span></span><br><span class="line">        useful.acquire();</span><br><span class="line">        Connection connection;</span><br><span class="line">        <span class="comment">//拿到许可，为什么还需要同步？</span></span><br><span class="line">        <span class="comment">//这是因为如果有 4 个许可，那么可能同时有 4 个线程过来取值，所以，还需要对池子同步</span></span><br><span class="line">        <span class="keyword">synchronized</span> (pool) {</span><br><span class="line">            connection = pool.removeFirst();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//空位释放</span></span><br><span class="line">        uselessful.release();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来就是编写 Demo 使用：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusiThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SemaphoreDemo semaphoreDemo = <span class="keyword">new</span> SemaphoreDemo();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="comment">//随机，让每个线程持有的连接时间不一样</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Connection connection = semaphoreDemo.takeConnect();</span><br><span class="line">            System.out.println(<span class="string">"Thread_"</span> + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">"获取数据库连共耗时【"</span> + (System.currentTimeMillis() - start) + <span class="string">"】ms"</span>);</span><br><span class="line">            <span class="comment">//模拟业务操作</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span> + r.nextInt(<span class="number">100</span>));</span><br><span class="line">            System.out.println(<span class="string">"查询数据完成，归还连接"</span>);</span><br><span class="line">            semaphoreDemo.returnConnection(connection);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) {</span><br><span class="line">        Thread t = <span class="keyword">new</span> BusiThread();</span><br><span class="line">        t.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码会显示出前面 10 个线程几乎是 0ms 就获取到资源，而后续的会等待：</p>
<blockquote>
<p>Thread_Thread-1获取数据库连共耗时【0】ms<br>Thread_Thread-0获取数据库连共耗时【0】ms<br>Thread_Thread-2获取数据库连共耗时【0】ms<br>Thread_Thread-3获取数据库连共耗时【0】ms<br>Thread_Thread-4获取数据库连共耗时【0】ms<br>Thread_Thread-5获取数据库连共耗时【0】ms<br>Thread_Thread-6获取数据库连共耗时【0】ms<br>Thread_Thread-7获取数据库连共耗时【0】ms<br>Thread_Thread-8获取数据库连共耗时【0】ms<br>Thread_Thread-9获取数据库连共耗时【1】ms<br>查询数据完成，归还连接<br>当前有40个线程等待连接，可用连接数：0<br>Thread_Thread-10获取数据库连共耗时【113】ms<br>查询数据完成，归还连接<br>当前有39个线程等待连接，可用连接数：0<br>Thread_Thread-11获取数据库连共耗时【124】ms<br>查询数据完成，归还连接<br>当前有38个线程等待连接，可用连接数：0<br>Thread_Thread-12获取数据库连共耗时【141】ms</p>
<p>。。。省略一部分运行数据</p>
</blockquote>
<p>这里可能大家有个疑问，为什么需要定义 2 个 Semaphore： useful, uselessful。其中 前者是代表可用的许可，后者代表空位。为什么这么设计？还得从 Semaphore 的机制说起：即使没有调用 acquire ，而是直接调用 release ，这样也是可以的，<strong>可以在release 的时候传入一个 new 出来的Connection 对象 ！！！</strong>，假如出现这种情况的话，我们的许可证会越来越多，而不是我们初衷的限制了。</p>
<p>acquire 只是做流控，但是不能做同步操作，比如，它有 4 个许可证，意味着可以允许 4 个线程同时去取资源，这时候我们还是需要对存储资源的池子做同步的。 所以，我们上述的代码 takeConnect() 方法中，在 acquire 之后，还需要 synchronized (pool) 操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">takeConnect</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">//获取许可，如果没有许可可能阻塞</span></span><br><span class="line">    useful.acquire();</span><br><span class="line">    <span class="comment">//省略无关代码。。。</span></span><br><span class="line">    <span class="keyword">synchronized</span> (pool) {</span><br><span class="line">        connection = pool.removeFirst();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//省略无关代码。。。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="七、Exchange"><a href="#七、Exchange" class="headerlink" title="七、Exchange"></a>七、Exchange</h2><p>Exchange 的使用场景很少。它的含义是：两个线程 A 和 B，在某一位置设定一个点，当某个先执行完了，就会等待另一个线程。当 2 个线程都执行到这个点时，二者交换数据，然后接着继续执行，没错，只是交换数据。</p>
<h2 id="八、Callable-、Task"><a href="#八、Callable-、Task" class="headerlink" title="八、Callable 、Task"></a>八、Callable 、Task</h2><p>我们前面说了开启一个线程有 2 种方式：new Thread 和 new Runnable 。但是，由于 Runnable 类的 run 方法是 void 类型的，没有返回值：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因此 Java 中给准备了 Callable 这样的类，让方法有返回值：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于Thread 中只能接收 Runnable 参数，因此 Callable 不能直接传入使用，因此就有了 Task 这种类型，可能课程中的这张图更形象一点：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/Runnable%E5%92%8CCallable%E5%92%8CFuture.png" alt="Runnable和Callable和Future"></p>
<p>关于 Callable 的使用，我们可以参考下面的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            System.out.println(<span class="string">"Callable 子线程开始计算"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5000</span>;i++) {</span><br><span class="line">                sum += i;</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"Callable 子线程计算结束，结果："</span> + sum);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">        UseCallable useCallable = <span class="keyword">new</span> UseCallable();</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(useCallable);</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        System.out.println(<span class="string">"main 方法中获取结果："</span> + task.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不过，需要注意的是，我们如果想取消 Task ，可以直接调用 task.cancel(true); ，其中传入的 true 是中断线程的标志，前面章节有说我们不建议使用 volatile 类型的变量去停止线程，还是希望使用 interrupt 去停止。所以，我们光调用 task.cancel(true);还不行，还得在线程中配合中断操作，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5000</span>;i++) {</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//删除无关代码</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/04/20/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(09-1)%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/20/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(09-1)%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8-1/" class="post-title-link" itemprop="url">Java筑基-：(09-1)线程基本使用入门-1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-20 22:01:00" itemprop="dateCreated datePublished" datetime="2023-04-20T22:01:00+08:00">2023-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-17 22:38:20" itemprop="dateModified" datetime="2023-05-17T22:38:20+08:00">2023-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、错误加锁的问题"><a href="#一、错误加锁的问题" class="headerlink" title="一、错误加锁的问题"></a>一、错误加锁的问题</h2><p>Java 的 Object 类中有 hashCode() 方法，它是用对象在内存中的地址来产生这个哈希值，当然，我们可以重写 hashCode() 方法。如果在重写了 hashCode() 方法之后还想获取到这个由内存中地址产生的哈希值，可以使用 identityHashCode() 方法。</p>
<p>在使用 synchronized 关键字去做同步的时候，要确保 synchronized 里面的对象是同一个对象，否则会达不到效果，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Work work = <span class="keyword">new</span> Work(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> Thread(work).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    Integer i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(Integer integer)</span> </span>{</span><br><span class="line">        i = integer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (i) {</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(<span class="string">"当前 i = "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>本来预期输出 2~6 的值，但是这段代码输出的数字是不可控的。这是为什么呢？问题就在 i ++ 上， 反编译可以看到， i ++ 之后就会生成新的 Integer 对象，这样一来，导致后续的程序获取的 Integer 就不是同一个对象了。</p>
<blockquote>
<p>改进方法可以是自己创建一个 Object obj = new Object() ；因为这个对象不会改变，所以我们可以用它来作为锁对象。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) {</span><br><span class="line">            <span class="comment">//省略代码。。。</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="二、volatile-关键字"><a href="#二、volatile-关键字" class="headerlink" title="二、volatile 关键字"></a>二、volatile 关键字</h2><p>比较简单，略</p>
<h2 id="三、ThreadLocal-使用"><a href="#三、ThreadLocal-使用" class="headerlink" title="三、ThreadLocal 使用"></a>三、ThreadLocal 使用</h2><p>Spring 在事务中用到了 ThreadLocal ，为什么要这么做？这是因为我们想要为每个线程保存自己的数据库 connection （连接）。这样比较容易控制事务的边界。</p>
<p>关于 ThreadLocal 需要注意的有 2 点：</p>
<ul>
<li><p>ThreadLocal 能够给初始值</p>
</li>
<li><p>每个线程单独操作自己的线程中的ThreadLocalMap ，所以压根不会有冲突</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal 给初始值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; num = <span class="keyword">new</span> ThreadLocal&lt;&gt;(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="四、ThreadLocal-的实现"><a href="#四、ThreadLocal-的实现" class="headerlink" title="四、ThreadLocal 的实现"></a>四、ThreadLocal 的实现</h2><p>如果要理解 ThreadLocal 的原理，就从它最简单的 get() 方法开始看(以下代码是基于我本地的 JDK 20 ，不过和前面版本相差也不太大)：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//Thread.currentThread() 表示当前线程</span></span><br><span class="line">    <span class="keyword">return</span> get(Thread.currentThread());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">get</span><span class="params">(Thread t)</span> </span>{</span><br><span class="line">    <span class="comment">//根据当前线程，获得 ThreadLocalMap 对象</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//。。。 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里getEntry 传入了 this ，也就是以 ThreadLocal 本身为 key</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">    T result = (T) e.value;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>也就是说，首先根据当前线程的 thread 对象 获得 ThreadLocalMap 对象 map ，之后，以ThreadLocal 自身（那个this） 为 key ，从 map 中取出 value ，这个 value 就是我们想要的值了，来看下 getMap 的实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里直接返回了 Thread.threadLocals，这意味着 ThreadLocalMap 类型的 map 是 Thread 的成员变量 ！那就没什么好说的了，每个 thread 对象自己都有这么个成员变量，每次操作的时候都是对线程对象 thread 自己的 ThreadLocalMap 类型的成员变量 threadLocals 进行操作，当然不会有线程问题了。</p>
<p>这里还有个问题需要澄清，就是如果定义了多个 ThreadLocal 对象 threadLocal1、threadLocal2… ，那么又是怎么保存的呢？我们来看下 ThreadLocal 的内部类 ThreadLocalMap 就知道了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="comment">// 。。。 省略无关代码</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>{</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>{</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//The initial capacity -- MUST be a power of two.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ThreadLocal.ThreadLocalMap.Entry[] table;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 。。。 省略无关代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ThreadLocal 中有个 ThreadLocalMap 类，并且 ThreadLocalMap 中有个 Entry [] 数组类型的 table ，用来存放所有的 Entry 。</p>
<blockquote>
<p>这里有个细节， Entry [] 数组的初始大小是16，并且官方建议这个值应该是 2^n 这样的值</p>
</blockquote>
<p>上面看到 ThreadLocal 的 get() 方法最终会调用 ThreadLocalMap 的 getEntry 方法，看ThreadLocalMap.getEntry 应该更能理解：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ThreadLocalMap 类</span><br><span class="line"><span class="keyword">private</span> ThreadLocal.ThreadLocalMap.<span class="function">Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>{</span><br><span class="line">    <span class="comment">//根据 key 获取 在数组 table 中的index </span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//根据 index 获取 table[index]</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry e = table[i];</span><br><span class="line">    <span class="comment">//处理可能的 hash 冲突和空值</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.refersTo(key))</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看了 get() 方法之后，ThreadLocal 的 set 的逻辑应该也能很容易理解了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># java.lang.<span class="function">ThreadLocal </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>{</span><br><span class="line">        <span class="comment">//将当前线程传过去</span></span><br><span class="line">        set(Thread.currentThread(), value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Thread t, T value)</span> </span>{</span><br><span class="line">        <span class="comment">//根据当前线程获取它的 ThreadLocalMap 对象</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//。。。省略无关代码</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//ThreadLocalMap 对象不空，调用其 set 方法，以ThreadLocal 本身作为 key</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//如果 ThreadLocalMap 对象还是空的，就创建个</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>最后调用到 ThreadLocalMap 的 set 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>{</span><br><span class="line">    <span class="comment">//前面说的 Entry[] 数组</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">    <span class="comment">//通过某种方式获取到即将插在数组中的位置 i</span></span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略无关代码。。。</span></span><br><span class="line">    <span class="comment">//可能位置 i 会有冲突，就 nextIndex，也有可能直接覆盖之前的值</span></span><br><span class="line">    <span class="comment">//nextIndex 其实就是 + 1 操作，如果超出了数组长度，就又从 0 开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Entry 对象，存入value，然后放入 tab[i] 中</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略无关代码。。。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>就是经过某种方法计算出在数组中的位置 i （可能会有位置冲突，就需要重新计算，或者之前有设置过了，就需要覆盖），然后创建 Entry 实体，存入 table[i] 中。</p>
<p>经过以上代码就整个流程能够串起来了：</p>
<ol>
<li><p>ThreadLocalMap 是 ThreadLocal 的内部类，ThreadLocalMap 中有一个 Entry[] 数组，用于存放（该线程）所有使用 ThreadLocal 存放的值（以 ThreadLocal 对象本身为key ，得出 index， 再根据 index 从 Entry 数组中取值）</p>
</li>
<li><p>每个线程对象 thread 都有一个 ThreadLocalMap 对象 threadLocals</p>
</li>
<li><p>当创建一个 ThreadLocal 对象，调用其 set 方法时，首先检测当前线程是否存在threadLocals，不存在就创建</p>
</li>
<li><p>然后以 ThreadLocal 对象本身为 key ，设置的值为 value ，存入ThreadLocalMap 中的 Entry[] 数组中（会有冲突处理过程）</p>
</li>
<li><p>当从某个线程中 get 某个 ThreadLocal 对象的值时，首先获取到该线程，然后取其 threadLocals 对象</p>
</li>
<li><p>之后以 ThreadLocal 对象本身作为 key ，调用 threadLocals 对象的 getEntry 方法</p>
</li>
<li><p>根据 key 计算该 Entry 在 table 数组中可能的位置 index ，这个 index 可能会冲突， 如果冲突了就会做前面说的 nextIndex 操作（其实就是 + 1 操作，如果超出了数组长度，就又从 0 开始），重新获取新的 index 再次尝试</p>
</li>
<li><p>最后，通过获取的 index 从 Entry[] 数组类型的变量 table 中获取 Entry： Entry entry = table[index]</p>
</li>
</ol>
<h2 id="五、ThreadLocal-可能造成内存泄漏"><a href="#五、ThreadLocal-可能造成内存泄漏" class="headerlink" title="五、ThreadLocal 可能造成内存泄漏"></a>五、ThreadLocal 可能造成内存泄漏</h2><p>ThreadLocal 用不好会造成内存泄露。</p>
<p>在使用完后，需要调用remove方法将其Entry移除，否则会导致内存泄露，直到线程对象 thread 被销毁才能被回收。首先看下 ThreadLocal 的原理图 ：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ThreadLocal内存泄漏示意图"></p>
<p>结合源码我们知道，Entry类是继承WeakReference的，当 ThreadLocal 对象没有被引用之后，可能就被回收了，所以 Entry 中的key就成为了 null ，不可能再被使用到了。</p>
<p>但是，由于我们没有调用 remove 方法（事实上，get和set方法调用过程也可能触发清理 key 为 null 的 Entry），这个 Entry 实例还是存在的，虽然 key 没有了，value 还是在的，所以造成了泄露。</p>
<blockquote>
<p>在ThreadLocal 新增或者删除一个元素的时候，会触发这种 key 为 null 的 Entry 扫描操作，这也是不断添加 ThreadLocal 对象并不断移除这些 ThreadLocal 对象时查看内存变化会维持在一个不高不低的阶段的原因。</p>
</blockquote>
<h2 id="六、ThreadLocal-可能引发线程不安全"><a href="#六、ThreadLocal-可能引发线程不安全" class="headerlink" title="六、ThreadLocal 可能引发线程不安全"></a>六、ThreadLocal 可能引发线程不安全</h2><p>当 ThreadLocal 中使用的是一个静态变量时，可能产生线程不安全的情况，因为各个线程大家的value都是指向同一份引用，比如如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUnsafe</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Number number = <span class="keyword">new</span> Number(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        number.value = number.value + <span class="number">1</span>;</span><br><span class="line">        threadLocal.set(number);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"中 integer 的值 为："</span> + threadLocal.get().value);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Number&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">5</span>;i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadLocalUnsafe()).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>{</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Number</span><span class="params">(<span class="keyword">int</span> num)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>.value = num;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在我运行后，输出全部是 5 ：</p>
<blockquote>
<p>Thread-4中 integer 的值 为：5<br>Thread-0中 integer 的值 为：5<br>Thread-3中 integer 的值 为：5<br>Thread-2中 integer 的值 为：5<br>Thread-1中 integer 的值 为：5</p>
</blockquote>
<p>一般来说，number 初始值是 0 ，每个线程给它 + 1 操作后存入 ThreadLocal 中，后续通过 threadLocal 取出来的时候值应该不一样才对，但是我们看到的是各个线程的值都是一样的。这是因为 ThreadLocal 在存入 value 的时候，存入的都是 number 这同一个对象，所以只要一处改了，就到处都改了，这种情况要注意。</p>
<h2 id="七、线程配合"><a href="#七、线程配合" class="headerlink" title="七、线程配合"></a>七、线程配合</h2><p>wait 和 notify 都要在同步代码块中使用，他们有标准的使用范式，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wait 过程</span></span><br><span class="line"><span class="keyword">synchronized</span> (对象) {</span><br><span class="line">    <span class="keyword">while</span> (条件不满足) {</span><br><span class="line">        对象.wait();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//业务逻辑</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//notify 过程</span></span><br><span class="line"><span class="keyword">synchronized</span> (对象) {</span><br><span class="line">    <span class="comment">//业务逻辑改变条件</span></span><br><span class="line">    对象.notifyAll();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>wait在休眠之前就会释放锁，而notify 与notifyAll不会，他调用了之后，还要等同步区间执行完了，才释放锁。</p>
<p>范式中间为什么要用while循环而不是if判断条件？</p>
<blockquote>
<p>如果对象执行 notifyAll ，那么很多线程都会被唤醒，比如是 5 个线程在等待打印机，当某个线程打印完成 notifyAll 的时候，这 5 个线程都被唤醒，由于是使用 if 语句判断的，唤醒之后直接执行后续的代码了，即业务逻辑（打印）了，此时就会出问题。但是如果是while 循环的话，唤醒之后还会判断条件是否满足（打印机是否被别人占了），这样逻辑才正确。</p>
</blockquote>
<h2 id="八、等待超时处理"><a href="#八、等待超时处理" class="headerlink" title="八、等待超时处理"></a>八、等待超时处理</h2><p>线程等待超时处理，比如使用池化技术的时候，我们去从 pool 中获取资源，但是会有超时提醒，这时候就能用 wait/notify 去做这样的事情。视频中的例子主要需要注意 remain 时长计算，因为唤醒一次就要重新计算等待时长，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (pool) {</span><br><span class="line">        <span class="keyword">if</span> (mills &lt; <span class="number">0</span>) {<span class="comment">//永不超时</span></span><br><span class="line">            <span class="keyword">while</span>(pool.isEmpty()) {</span><br><span class="line">                wait();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> pool.removeFirst();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//超时时刻</span></span><br><span class="line">            <span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">            <span class="comment">//等待时长</span></span><br><span class="line">            <span class="keyword">long</span> remain = mills;</span><br><span class="line">            <span class="keyword">while</span>(pool.isEmpty() &amp;&amp; remain &gt; <span class="number">0</span>) {</span><br><span class="line">                wait(remain);</span><br><span class="line">                <span class="comment">//重新计算等待时长</span></span><br><span class="line">                remain = future - System.currentTimeMillis();</span><br><span class="line">            }</span><br><span class="line">            Connection connection = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!pool.isEmpty()) {</span><br><span class="line">                connection = pool.removeFirst();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> connection;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>为什么需要重新计算？因为唤醒后可能抢不到锁，还会在while中接着等待。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/04/12/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(10)%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/12/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(10)%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Java筑基-：(10)线程与进程理论知识入门</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-12 20:48:00" itemprop="dateCreated datePublished" datetime="2023-04-12T20:48:00+08:00">2023-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-16 16:44:52" itemprop="dateModified" datetime="2023-04-16T16:44:52+08:00">2023-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、Java-线程安全停止工作"><a href="#一、Java-线程安全停止工作" class="headerlink" title="一、Java 线程安全停止工作"></a>一、Java 线程安全停止工作</h2><p>interrupt() 方法是对线程发起中断，只是改写了一下 标志位！不代表线程要立即停止工作。不过可以根据这个标志位来决定是否停止线程了。</p>
<blockquote>
<p>基于这一点，我们可以说 <strong>JDK 中的线程是协作式的，而不是抢占式的。</strong></p>
</blockquote>
<p>所以，我们可以在 while 循环中，可以通过 isInterrupted() 来判断标记位状态，来判断是否终止线程，比如：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UsetThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">while</span>(!isInterrupted()) {</span><br><span class="line">            System.out.println(<span class="string">"线程正在执行"</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程isInterrupted标记位："</span> + isInterrupted());</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"最终线程isInterrupted标记位："</span> + isInterrupted());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这里，需要注意线程自己成员方法 isInterrupt() 以及 Thread.isInterrupt() 方法，如果是后者的话，它发现Thread.isInterrupt() == true 的时候，会又置为 false。所以上述在while 循环外面输出的<strong>最终线程xxx</strong>会为false（而如果用线程的成员方法isInterrupt() 这里会输出true ）：</p>
<blockquote>
<p>最终线程isInterrupted标记位：false 。不过我在本地运行（JDK1.8）的时候，并没有 Thread.isInterrupted() 这个方法了，可能高版本不见了</p>
</blockquote>
<h3 id="还是推荐使用-isInterrupted-来终止线程"><a href="#还是推荐使用-isInterrupted-来终止线程" class="headerlink" title="还是推荐使用 isInterrupted() 来终止线程"></a>还是推荐使用 isInterrupted() 来终止线程</h3><p>博客或者很多书籍上都会定义一个 volatile 类型的boolean 值 isCancel 来判断是否要结束线程的运行，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isCancel) {</span><br><span class="line">    doSomething();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是，其实我们并不推荐这样做，因为这样的话，假如我在里面实现了Thread.sleep()  操作，这时候，我压根就不会判断到这个 isCacel 变量：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isCancel) {</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    doSomething();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是，在  sleep 阶段我们可以照常响应 interrupt 操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isInterrupted()) {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        sleep(<span class="number">300</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        System.out.println(<span class="string">"in InterruptedException 中，isInterrupted = "</span> + isInterrupted());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里是会响应try-catch 的，但是这里要注意一点，这个 println 会输出 ：</p>
<blockquote>
<p>in InterruptedException 中，isInterrupted = false</p>
</blockquote>
<p>也就是<strong>在 catch 里面，我们去判断 isInterrupt 居然还是 false</strong>，这是因为抛出这个异常之后，又会将标志位置为 false，所以如果要真正让状态对，还需要我们在 catch 代码中手动实现 interrupt 方法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while(!isInterrupted()) {</span><br><span class="line">    try {</span><br><span class="line">        sleep(300);</span><br><span class="line">    } catch (InterruptedException e) {</span><br><span class="line">        interrupt();</span><br><span class="line">        System.out.println("in InterruptedException 中，isInterrupted = " + isInterrupted());</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>sleep 、wait 、join 等方法在使用的时候都会 catch InterruptedException 异常：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    Thread.sleep(<span class="number">400</span>);</span><br><span class="line">} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    obj.wait();</span><br><span class="line">} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    thread.join();</span><br><span class="line">} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>那么，为什么要这么设计成在 catch InterruptedException 的时候，isInterrupted 还是 false 呢？也就是说如果不这样会有什么问题呢？</p>
<p>假设 sleep 过程持有了资源，如果中断来了直接中断，没有给程序员干预的时间，可能造成资源不能释放，造成死锁。并且注意一点：<strong>死锁状态的线程，是不会理会中断的。</strong></p>
<p>所以，要让你自己处理完自己的操作之后（比如释放锁资源），才自己去设置 interrupt = true，自主性更强。像上述第二段代码，自己加了 interrupt 之后，再次 while 循环就不会进去了。</p>
<h2 id="二、Thread-的-run-和-start"><a href="#二、Thread-的-run-和-start" class="headerlink" title="二、Thread 的 run 和 start"></a>二、Thread 的 run 和 start</h2><p>new Thread 的时候，只是创建了一个 Thread 类的实例而已。如果直接调用 Thread.run() 方法，就是和普通对象的普通方法是一样的，并不会新开线程；只有调用 start 方法，才会启用新的线程。</p>
<h2 id="三、Thread-的-join-方法"><a href="#三、Thread-的-join-方法" class="headerlink" title="三、Thread 的 join 方法"></a>三、Thread 的 join 方法</h2><p>线程 A 执行，这时候如果在 A 线程中调用线程Ｂ的 join 方法，<strong>则 A 线程会挂起</strong>，等 B 线程执行完成后，A 线程再继续执行。</p>
<p>所以，面试问怎么保证 2 个线程顺序执行，怎么办？那就使用 join() 方法咯。</p>
<h2 id="四、线程的优先级"><a href="#四、线程的优先级" class="headerlink" title="四、线程的优先级"></a>四、线程的优先级</h2><p>Java 里面的优先级级数和操作系统里面的级数是不一定相同的。最终有没有用，还得看操作系统的决策，所以优先级高的线程，获得的时间片不一定多。</p>
<h2 id="五、守护线程"><a href="#五、守护线程" class="headerlink" title="五、守护线程"></a>五、守护线程</h2><p>当所有的用户线程和非守护线程结束后，守护线程才结束掉，我们通过 thread.setDaemon(true);  操作即可将线程设置为守护线程。</p>
<p>在守护线程的 run() 方法中，finally 都不一定能给保证执行（用户线程是可以保证finally执行），这是为什么呢，资源还怎么释放呢？这是因为，一般守护线程关闭的时候，整个进程都要结束了，所以这时候资源都是会一起释放了，这时候守护资源也无需保证 finally 一定执行了。</p>
<blockquote>
<p> 一般适合做后台调度和支持性工作。</p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/04/12/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(09)%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/12/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(09)%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Java筑基-：(09)线程与进程理论知识入门</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-12 20:00:00" itemprop="dateCreated datePublished" datetime="2023-04-12T20:00:00+08:00">2023-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-14 22:13:08" itemprop="dateModified" datetime="2023-04-14T22:13:08+08:00">2023-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>进程是申请资源的基本单位，线程是cpu 时间片的基本单位。</p>
<h2 id="一、cpu-核心与线程数"><a href="#一、cpu-核心与线程数" class="headerlink" title="一、cpu 核心与线程数"></a>一、cpu 核心与线程数</h2><p>目前一个 cpu 上可以有多个核心，cpu 上一个核心可以对应一个线程。</p>
<p>Intel 的 <strong>超线程技术</strong>，可以实现 1 个cpu 核心对应 2 个逻辑处理器。所以在 windows上你查看性能的时候，发现只有 4 核心，但是有 8 个逻辑处理器。</p>
<h2 id="二、线程轮转"><a href="#二、线程轮转" class="headerlink" title="二、线程轮转"></a>二、线程轮转</h2><p>1.6G 的 CPU 执行一条指令一般在 0.6ns （0.6纳秒）级别，所以是非常快的。但是线程的上下文切换时非常耗时的，一般耗时在 2W 个 CPU 周期级别。</p>
<h2 id="三、并行-和-并发"><a href="#三、并行-和-并发" class="headerlink" title="三、并行 和 并发"></a>三、并行 和 并发</h2><ul>
<li><p>并行就是同时进行，比如，有 2 个咖啡机，就可以同时 2 个人并行打咖啡</p>
</li>
<li><p>并发：说并发，一定是有时间单位的，会有并发量的说法。所以基于上面的例子来说，只有一台咖啡机，大家轮着来，这时候就有类似 这个咖啡机每小时的并发量是 10，就是给10个人提供服务。</p>
</li>
</ul>
<h2 id="四、高并发的意义"><a href="#四、高并发的意义" class="headerlink" title="四、高并发的意义"></a>四、高并发的意义</h2><ul>
<li><p>充分利用硬件资源。比如有四核，但是你只有一个线程</p>
</li>
<li><p>用户响应。比如商城 App ，下单之后，会给快递发送消息，给用户发送短信等等，这些其实都是互相独立的，不用单线程进行</p>
</li>
</ul>
<p>但是，多线程不一定快，因为有竞争锁的过程，可能比单线程还慢</p>
<p>OS 对线程数总数是有限制的，比如 Linux 1000个，windows 2000 个</p>
<p>线程都会有栈空间的，所以线程数量太多的话，空间占用都很可观</p>
<p>句柄和文件描述符也都有数量上限</p>
<p>Java 程序天生就是多线程的，比如，你写个main方法，简单写几行代码，比如下面的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">    <span class="comment">//Java 虚拟机线程系统的管理接口</span></span><br><span class="line">    ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">    <span class="comment">//不需要获取同步的monitor 和 synchronizer 信息，仅仅获取线程堆栈信息</span></span><br><span class="line">    ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (ThreadInfo threadInfo: threadInfos) {</span><br><span class="line">        System.out.println(<span class="string">"["</span> + threadInfo.getThreadId() + <span class="string">"]"</span> + threadInfo.getThreadName());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>上面的 ThreadMXBean就是用来查看当前虚拟机所有的线程的，我们可以看到有多个线程在运行，运行的结果可能会如下所示：</p>
<blockquote>
<p>[1]main<br>[8]Reference Handler<br>[9]Finalizer<br>[10]Signal Dispatcher<br>[11]Attach Listener<br>[17]Common-Cleaner<br>[18]Monitor Ctrl-Break<br>[19]Notification Thread</p>
</blockquote>
<p>其中 main 线程我们能理解，就是我们的主线程； Finalizer 方法也好理解，因为 Object 类中有个 finalize() 方法，我们在学习 GC 的时候了解过，如果对象不可达，但是重写了 finalize() 方法还没执行的话，会交给一个 低优先级（守护）线程去执行，但是不保证 finalize() 方法执行完成。说的就是这个 Finalizer 线程。</p>
<h2 id="五、开启新线程的方式"><a href="#五、开启新线程的方式" class="headerlink" title="五、开启新线程的方式"></a>五、开启新线程的方式</h2><p>到底有几种方式，其实挺纠结的，那么我们就以 Java 的 Thread.java 类的官方文档来看：</p>
<blockquote>
<p> There are two ways to create a new thread of execution</p>
</blockquote>
<p>上面说的就是 2 种：</p>
<ul>
<li><p>扩展 Thread 类（继承一下Thread），重写 run 方法。</p>
</li>
<li><p>Runnable 接口。比如： UserRunnable implements Runnable，之后，在 new Thread的时候，将这个 UserRunnable 作为参数传进去</p>
</li>
</ul>
<blockquote>
<p>类似 Callable 之类的其实就是 Runnable 接口来实现新线程的。</p>
</blockquote>
<h3 id="Thread-和-Runnable-二者的区别"><a href="#Thread-和-Runnable-二者的区别" class="headerlink" title="Thread 和 Runnable 二者的区别"></a>Thread 和 Runnable 二者的区别</h3><p>Thread 是 Java 对线程的抽象，而 Runnable 是对任务的抽象</p>
<h2 id="六、线程的停止"><a href="#六、线程的停止" class="headerlink" title="六、线程的停止"></a>六、线程的停止</h2><p>stop 、destroy suspend 、resume 等线程方法已经被废弃了，因为他们停止的时候，不一定<strong>正常</strong>释放资源。比如要写文件 10k ，但是才写了 4k，就stop 了。</p>
<p>但是 interrupt 方法可以作为我们停止线程的一个方法。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/04/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(08)FileIO%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E2%80%94dex%E6%96%87%E4%BB%B6%E6%94%B9%E9%80%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(08)FileIO%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E2%80%94dex%E6%96%87%E4%BB%B6%E6%94%B9%E9%80%A0/" class="post-title-link" itemprop="url">Java筑基-：(08)FileIO项目实战—dex文件改造</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-10 19:29:00" itemprop="dateCreated datePublished" datetime="2023-04-10T19:29:00+08:00">2023-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-17 22:23:58" itemprop="dateModified" datetime="2023-05-17T22:23:58+08:00">2023-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>自己编译的模拟器，它可以在源码上打log，做到可控。并且，所有的行为都会经过模拟器，比如后面你的url请求</p>
<h2 id="二、常用的思路"><a href="#二、常用的思路" class="headerlink" title="二、常用的思路"></a>二、常用的思路</h2><p>加固思路有以下几种：</p>
<ul>
<li><p>反模拟器，一旦发现模拟器，就停止核心代码运行</p>
</li>
<li><p>代码虚拟化，自己写的代码先运行在自己写的虚拟机上，后续再运行到系统的虚拟机上<br>加密，核心代码是以压缩或者加密形式存在的，被分割成一段一段的，需要的时候，再把目标段加载到内存。</p>
</li>
<li><p>加壳方案，分为壳dex和源dex，壳不加密，源加密</p>
</li>
</ul>
<p>关于第 3 种加固方案的总体示意图如下：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/%E5%8A%A0%E5%9B%BA%E6%96%B9%E6%A1%88%E6%A6%82%E8%A7%88.png" alt="加固方案概览"></p>
<p>最后为什么有个签名，因为加固过程会修改 APK，必然破坏了 APK ，因此需要重新签名。以上方案值得我们的思考的有几点：</p>
<ul>
<li><p>壳dex 与 源 dex 可以随意拼凑吗？</p>
</li>
<li><p>壳 dex 怎么生成？</p>
</li>
<li><p>如何签名？</p>
</li>
<li><p>如果运行新的 apk（如何脱壳）？</p>
</li>
</ul>
<h2 id="四、Apk打包过程"><a href="#四、Apk打包过程" class="headerlink" title="四、Apk打包过程"></a>四、Apk打包过程</h2><p>简单说一下 APK 的打包过程，整体流程如下图所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/apk%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B.png" alt="Android打包流程"></p>
<p>几个重要的过程：</p>
<ol>
<li><p>首先 aapt 工具将资源文件生成 R.java 文件</p>
</li>
<li><p>aidl 工具将 aidl 文件生成 Java 文件</p>
</li>
<li><p>将上述的 java 文件、项目自己的 java 文件，通过 Java compiler 一起生成 .class 文件</p>
</li>
<li><p>.class 文件通过 dx 工具生成 dex 文件</p>
</li>
<li><p>将 dex 文件和那些资源文件一起压缩生成 apk</p>
</li>
<li><p>签名</p>
</li>
</ol>
<h2 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h2><p>生成原始 apk ，然后解压到目录 unzip 中文件夹中，当然，要把之前的签名文件给剔除；之后，找到所 unzip 中所有的 dex 文件，进行加密。</p>
<p>接下来，将项目中的一个 lib 生成的 aar 转成 dex 文件， dx 工具可以将 jar 转成 dex，当然，这个 lib 有自己的 Application ，在正式使用的时候，上述 原始 apk 中的 Application 在最开始的时候要通过反射的方式调用这个 lib 的 Application ，让其形式上作为 App 的默认 Application ，以便后续的解密。</p>
<p>将加密的 dex 和 aar 转成的 dex 一起放入 unzip 中，这样 ，unzip 文件夹中有了 加密的 dex 和 lib 的dex ，以及原始 apk 中所有的 资源，这时候通过 zip 压缩，就能将 unzip 中所有的内容压缩起来，改名 apk （这个打包apk 的过程需要确认）</p>
<p>最后，对这个 apk 进行签名，就形成了正式的apk 。</p>
<h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p>上述打包的 APK 最终需要安装使用，安装成功后，</p>
<p>我们的安装包都会安装在 </p>
<blockquote>
<p>/data/data/包名/files/fake_apk/  </p>
</blockquote>
<p>这种目录下，在壳的 Application （那个lib 中的 Application）的 attachBaseContext 的时候，我们可以将这个apk加载进来，然后过滤出所有加密的 dex 文件，之后解密，然后将这些解密后的文件存入到指定的目录，后续就使用这些已经解密的dex 。当然，我们不需要每次都去解密这个 dex ，将其存起来就好了，下次直接使用。</p>
<h2 id="对称加密、非对称加密"><a href="#对称加密、非对称加密" class="headerlink" title="对称加密、非对称加密"></a>对称加密、非对称加密</h2><p>看了，但是笔记略</p>
<blockquote>
<p>后续要根据视频内容自己写一下整个的加壳、脱壳的过程</p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/04/08/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(07)Java%20IO%E5%9C%A8Android%E4%B8%AD%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/08/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(07)Java%20IO%E5%9C%A8Android%E4%B8%AD%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E7%AF%87/" class="post-title-link" itemprop="url">Java筑基-：(07)Java IO在Android中应用基础篇</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-08 14:30:00 / 修改时间：23:18:59" itemprop="dateCreated datePublished" datetime="2023-04-08T14:30:00+08:00">2023-04-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>数据流是一组有序、有起点和终点的字节的数据序列，包括输入流和输出流。</p>
<h2 id="一、IO-简介"><a href="#一、IO-简介" class="headerlink" title="一、IO 简介"></a>一、IO 简介</h2><p>流序列中的数据既可以是未经过加工的原始二进制数据，也可以是经过一定编码处理后符合某种格式规定的特定数据。在Java 中流分为 2 种： <strong>字节流 和 字符流</strong>：</p>
<ul>
<li>字节流： 数据流中最小的数据单位是字节</li>
<li>字符流：数据流中最小的数据单元是字符，Java 中的字符是 Unicode 编码，<strong>一个字符占用 2 个字节</strong></li>
</ul>
<p>java.io 中最重要的就是 5 个类和一个接口：</p>
<ul>
<li><p>5个类指： File、字节流中的 OutputStream 和 InputStream、字符流中的 Writer 和 Reader ；</p>
</li>
<li><p>一个接口是指 ： Serializable </p>
</li>
</ul>
<blockquote>
<p>在 Android 中，文本文件/XML 等这些都是用 <strong>字符流</strong>来读写；而如 RAR、图片等非文本，则用字节流来读写。</p>
</blockquote>
<h2 id="二、Java-IO-中的装饰模式"><a href="#二、Java-IO-中的装饰模式" class="headerlink" title="二、Java IO 中的装饰模式"></a>二、Java IO 中的装饰模式</h2><p>以一段容易让人费解的代码开始：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">        <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> File(file))));</span><br></pre></td></tr></tbody></table></figure>

<p>这个代码看起来很乱，多重嵌套，其实要理解 IO ，也不难，难的是要更优地去使用 IO 。接下来抽丝剥茧地解释一下上述代码：</p>
<ol>
<li><p>new File() 就是创建一个 File 文件，这个没什么好说的</p>
</li>
<li><p>FileOutputStream 这层就是将 File 转为字节流</p>
</li>
<li><p>BufferedOutputStream 就是<strong>用来提升速度的</strong>，减少对磁头的调用，如果没有它，就会一个一个字节地去访问磁盘；有了它之后，就是一块一块地访问</p>
</li>
<li><p>而使用 DataOutputStream 就是保持数据的格式</p>
</li>
</ol>
<p>我们在日常使用的时候，一般都要是优先考虑 DataOutputStream ，然后交给 BufferedOutputStream 提升效率。上面的例子就是典型的用法。</p>
<p>要理解输入输出流，要把自己当做电脑的 <strong>内存</strong>，站在内存的角度思考，这样 OutputStream 就是写出到磁盘上了，InputStream 就是读入到内存了。</p>
<p>为了能更好地理解，我们这里写一个 Demo：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testDataOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">    DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">            <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"C:\\Users\\panda\\IdeaProjects\\JavaDemo\\src\\testtxt\\out.txt"</span>))</span><br><span class="line">    ));</span><br><span class="line">    out.writeInt(<span class="number">1</span>);</span><br><span class="line">    out.writeBoolean(<span class="keyword">false</span>);</span><br><span class="line">    out.writeByte((<span class="keyword">byte</span>)<span class="number">0x41</span>);</span><br><span class="line">    out.writeLong((<span class="keyword">long</span>)<span class="number">0x98765432</span>);</span><br><span class="line"></span><br><span class="line">    out.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>我们能看到上述代码往文件中写入了东西，但是直接打开看起来是乱码的，这只是编码的问题，使用正确的编码就不会有问题。</p>
<blockquote>
<p>还有一点要注意，使用 DataOutputStream 写入之后，通过 DataIntputStream 读出来的时候，需要保证顺序，比如上述例子里面先写入 int ，后写入 boolean ，读的时候也要先读 int 后读 boolean ，否则会错乱</p>
</blockquote>
<p>序列化的时候，大量使用这个 IO 操作。</p>
<h2 id="三、装饰器模式"><a href="#三、装饰器模式" class="headerlink" title="三、装饰器模式"></a>三、装饰器模式</h2><p>在上述代码中，我们使用 FileOutputStream 也能满足需求，但是为了磁盘好我们又包装了 BufferedOutputStream ，此时也已经能用了，但是为了数据格式，我们又加了 DataOutputStream 。</p>
<p>这种整个一层一层封装就是我们常见的<strong>装饰模式</strong>，如果要对装饰模式理解深刻一点的话，可以用视频中老师举的例子： 人本身就是一个类（类似Android 中的 Context），但是人一般都穿内衣（），而内衣之外，一般都会穿日常衣服装饰自己。整个装饰器模式的结构如下图所示：</p>
<h2 id="四、字节流与字符流的区别"><a href="#四、字节流与字符流的区别" class="headerlink" title="四、字节流与字符流的区别"></a>四、字节流与字符流的区别</h2><p>在开发中到底使用字节流好还是使用字符流好呢？</p>
<p>首先，在硬盘上保存文件或者进行传输的时候都是以字节的形式进行的，包括图片也是按字节完成。<strong>字符只有到了内存中才会形成</strong>。所以，如果要使用 Java 程序实现拷贝功能的话，应该选用字节流进行操作，并且采用边读边写的方式（节省内存）。</p>
<h2 id="五、字节流与字符流的转换"><a href="#五、字节流与字符流的转换" class="headerlink" title="五、字节流与字符流的转换"></a>五、字节流与字符流的转换</h2><p>虽然 Java 支持字节流和字符流，但是有时候需要在二者之间进行转换， InputStreamReader 和 OutputStream 这 2 个类是字节流和字符流之间相互转换的类。</p>
<h3 id="5-1-InputStreamReader"><a href="#5-1-InputStreamReader" class="headerlink" title="5.1 InputStreamReader"></a>5.1 InputStreamReader</h3><p>用于<strong>将字节流的字节码转成字符</strong>，其中一个构造 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用默认字符集创建一个 InputStreamReader 对象</span></span><br><span class="line">InputStreamReader(InputStream in)</span><br></pre></td></tr></tbody></table></figure>



<h3 id="5-2-OutputStreamWriter"><a href="#5-2-OutputStreamWriter" class="headerlink" title="5.2 OutputStreamWriter"></a>5.2 OutputStreamWriter</h3><p>用于<strong>将写入的字符转成字节后写入一个字节流</strong>，其中一个构造方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用默认字符集创建一个 OutputStreamWriter</span></span><br><span class="line">OutputStreamWriter(OutputStream out)</span><br></pre></td></tr></tbody></table></figure>



<h3 id="5-3-BufferedWriter-和-BufferedReader"><a href="#5-3-BufferedWriter-和-BufferedReader" class="headerlink" title="5.3 BufferedWriter 和  BufferedReader"></a>5.3 BufferedWriter 和  BufferedReader</h3><p>为了频繁转换字节流和字符流，对以上2个类进行了封装， 即 BufferedWriter类封装了OutputStreamWriter类；BufferedReader类封装了InputStreamReader类；示例代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter out=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">BufferedReader in= <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的语句可以从控制台读取一行字符串</span></span><br><span class="line">BufferedReader in=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String line=in.readLine();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/04/05/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(06)Java%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6-%E5%BA%8F%E5%88%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/05/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(06)Java%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6-%E5%BA%8F%E5%88%97%E5%8C%96/" class="post-title-link" itemprop="url">Java筑基-：(06)Java基础进阶-序列化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-05 14:59:00" itemprop="dateCreated datePublished" datetime="2023-04-05T14:59:00+08:00">2023-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-08 23:15:56" itemprop="dateModified" datetime="2023-04-08T23:15:56+08:00">2023-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、序列化与二进制串"><a href="#一、序列化与二进制串" class="headerlink" title="一、序列化与二进制串"></a>一、序列化与二进制串</h2><p>序列化其实就是<strong>将数据结构转换成二进制串的过程</strong>。这里的二进制串，在 Java 中很容易和 String 的概念混淆，实际上 String 也是一种特殊对象（Object），对于跨语言间的通信，序列化后的数据当然不能使某种语言的特殊数据类型。</p>
<blockquote>
<p>二进制串在 Java 里面所指的应当是 byte[] </p>
</blockquote>
<h2 id="二、序列化-反序列化的目的"><a href="#二、序列化-反序列化的目的" class="headerlink" title="二、序列化/反序列化的目的"></a>二、序列化/反序列化的目的</h2><ul>
<li><p>数据的生命周期需要比 JVM 长。Java 允许我们在内存中创建可复用的对象，但是一般只有 JVM 存在的时候，这些对象才能存在，即对象生命周期不能比 JVM 更长。所以，如果需要停止 JVM 后数据还存在，就要序列化保存这些数据。</p>
</li>
<li><p>序列化只是对变量而言。序列化对象的时候，<strong>只针对变量进行序列化</strong>，不针对方法进行序列化。</p>
</li>
<li><p>需要永久保存或者在网络上传输的时候，需要序列化之后才能进行。</p>
</li>
</ul>
<h2 id="三、序列化常见的方案"><a href="#三、序列化常见的方案" class="headerlink" title="三、序列化常见的方案"></a>三、序列化常见的方案</h2><ul>
<li><p>Java 中有 Serializable</p>
</li>
<li><p>Android 中有 Parcelable</p>
</li>
<li><p>还有 Json、xml 、Protocol Buffer 等</p>
</li>
</ul>
<h2 id="四、选择合理的序列化方案"><a href="#四、选择合理的序列化方案" class="headerlink" title="四、选择合理的序列化方案"></a>四、选择合理的序列化方案</h2><ul>
<li><p>性能</p>
</li>
<li><p>通用性</p>
</li>
<li><p>鲁棒性</p>
</li>
<li><p>可调式性/可读性</p>
</li>
<li><p>可扩展/兼容性</p>
</li>
<li><p>安全性/访问限制</p>
</li>
</ul>
<h2 id="五、Serializable"><a href="#五、Serializable" class="headerlink" title="五、Serializable"></a>五、Serializable</h2><p>首先， Serializable 只是一个接口，为什么一个空的接口能够实现序列化？<strong>因为它只是一个标识、标记！</strong></p>
<p>如果要保存到磁盘上，还需要使用 IO 流（ObjectInputStream/ObjectOutPutStream）来辅助，这个好理解。</p>
<h2 id="六、Externalizable"><a href="#六、Externalizable" class="headerlink" title="六、Externalizable"></a>六、Externalizable</h2><p>要自己实现 writeExternal 和 readExternal 方法，但是使用的时候需要注意以下几点：</p>
<ul>
<li><p>write 和 read 方法二者要对应，比如，write 的阶段没有只写入了一个 String 类型，但是读的时候 读了 String 还要读 int ，这时候就会导致崩溃报错。</p>
</li>
<li><p>write 和 read 的顺序要保持一致，比如先 write 了String ，再 write  了int ，读的时候如果先读int ，后读String ，也会导致报错</p>
</li>
<li><p>要有默认无参的、public类型的构造函数，如果你自己写了有参数的构造函数，一定再加上无参的默认构造函数</p>
</li>
</ul>
<blockquote>
<p>为什么要有一个 public 无参的构造函数？</p>
</blockquote>
<h2 id="七、相关面试题"><a href="#七、相关面试题" class="headerlink" title="七、相关面试题"></a>七、相关面试题</h2><h3 id="7-1-什么是-serialVersionUID-？-如果不定义会发生什么？"><a href="#7-1-什么是-serialVersionUID-？-如果不定义会发生什么？" class="headerlink" title="7.1 什么是 serialVersionUID ？ 如果不定义会发生什么？"></a>7.1 什么是 serialVersionUID ？ 如果不定义会发生什么？</h3><ol>
<li><p>serialVersionUID 是一个 private static final long 类型的 ID ，它<strong>通常是对象的 hashCode</strong></p>
</li>
<li><p>它用于对象的版本控制，我们可以在类文件中指定这个值</p>
</li>
<li><p>如果不指定它的值，当你序列化类 A.java 生成了文件 a.txt ，之后，在 A 类中添加了一个字段 sex ，则在反序列化的时候会报错，提示版本不一致</p>
</li>
<li><p>还有，如果指定serialVersionUID 为 1，序列化 A 的时候生成了 a.txt ，这时候添加了字段 sex ，如果此时不改 serialVersionUID 的值，反序列化的时候，能成功，只是 sex 字段为 null（这里说的是对象类型，如果是 int 等类型就会是 0 ，后面一样）而已</p>
</li>
<li><p>接着上面，如果序列化了 A ，添加了 sex 字段，此时还将 serialVersionUID 改为 2 ，此时反序列化就会报错，同样是版本不一致</p>
</li>
</ol>
<h3 id="7-2-序列化的时候，如果某些成员不要序列化，该怎么实现？"><a href="#7-2-序列化的时候，如果某些成员不要序列化，该怎么实现？" class="headerlink" title="7.2 序列化的时候，如果某些成员不要序列化，该怎么实现？"></a>7.2 序列化的时候，如果某些成员不要序列化，该怎么实现？</h3><p>使用 transient 关键字。加了 这个关键字的对象 sex ，在反序列化的时候会为null（如果是int 等类型就会是 0） 。</p>
<h3 id="7-3-如果类-A-中有成员未实现可序列化接口，会发生什么？"><a href="#7-3-如果类-A-中有成员未实现可序列化接口，会发生什么？" class="headerlink" title="7.3 如果类 A 中有成员未实现可序列化接口，会发生什么？"></a>7.3 如果类 A 中有成员未实现可序列化接口，会发生什么？</h3><p>如果 A 中有成员 User 对象没有实现可序列化接口，序列化的时候会报 “不可序列化”的异常。</p>
<h3 id="7-4-如果类-A-是可序列化的，但是其父类不是，则反序列化后，从父类继承过来的实例变量状态如何？"><a href="#7-4-如果类-A-是可序列化的，但是其父类不是，则反序列化后，从父类继承过来的实例变量状态如何？" class="headerlink" title="7.4 如果类 A 是可序列化的，但是其父类不是，则反序列化后，从父类继承过来的实例变量状态如何？"></a>7.4 如果类 A 是可序列化的，但是其父类不是，则反序列化后，从父类继承过来的实例变量状态如何？</h3><p>假如 User 继承了 Person 类，并且实现了 Serializable 接口，但是 Person 类没有实现 Serializable 接口。</p>
<p>即 父类的成员未默认值，Object 类型为 null ，int 等类型为  0。</p>
<p>如果要想父类也实现，需要父类也实现 Serializable 接口，并且有默认的构造函数（无参的，public 的）。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/31/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(04)JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/31/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(04)JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%8A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" class="post-title-link" itemprop="url">Java筑基-：(04)JVM垃圾回收器及性能调优</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-31 22:59:00" itemprop="dateCreated datePublished" datetime="2023-03-31T22:59:00+08:00">2023-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-08 22:56:06" itemprop="dateModified" datetime="2023-04-08T22:56:06+08:00">2023-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、JVM-中常见的垃圾回收器"><a href="#一、JVM-中常见的垃圾回收器" class="headerlink" title="一、JVM 中常见的垃圾回收器"></a>一、JVM 中常见的垃圾回收器</h2><p>一般来说的话，年轻代占整个堆空间的 1/3 ，而老年代占整个堆空间的的 2/3 。</p>
<p>但是对于 Parallel Scavenge/Parallel Old 这对组合（这种组合目前的<strong>吞吐量</strong>最大，前者回收年轻代，后者回收老年代，从名字也能看出来）垃圾收集器而言，之前说的一些内容可能不适用了：</p>
<ul>
<li><p>堆的大小是会动态变化的，不是一成不变的，比如最开始是 200 ，后来空间不够，GC 过后被扩容到 300M ；如果发现空闲堆太多，可能就缩小到 100M 了； </p>
</li>
<li><p>年轻代不一定占堆空间的 1/3 了，年轻代和老年代的占比也可能变化</p>
</li>
<li><p>年轻代里面也可能不是 8:1:1 的结构了</p>
</li>
</ul>
<p>一般来说，平时建议堆的最大大小和最小大小设置同一个值，不要让空间时不时变化。</p>
<h2 id="二、响应优先的垃圾回收器"><a href="#二、响应优先的垃圾回收器" class="headerlink" title="二、响应优先的垃圾回收器"></a>二、响应优先的垃圾回收器</h2><p>后来，大家的需求变成<strong>响应优先</strong>， <strong>CMS （Concurrent Mark Sweep）</strong> 标记清除  垃圾回收器就是这个跨时代的垃圾回收器。 它是单独针对老年代的垃圾收集器。<strong>导致卡顿的一般是老年代的 GC 操作</strong>。它是怎么做到响应时间最短呢？步骤如下：</p>
<ol>
<li><p>初始标记——GC Roots 的数量是决定性因素</p>
</li>
<li><p>并发标记</p>
</li>
<li><p>重新标记</p>
</li>
<li><p>并发清除</p>
</li>
</ol>
<p>为什么能响应时间最短，那是因为把耗时的标记和清除操作都能并发了！</p>
<p>为什么能做到并发清理？因为标记-清除可以做到并发，因为我并不关心垃圾，我只关心与 GC Roots 有连接的部分。所以垃圾被覆盖啊之类的都是可以的，<strong>所以我能够不暂停而去做清理操作</strong>。</p>
<h2 id="三、CMS-的预清理"><a href="#三、CMS-的预清理" class="headerlink" title="三、CMS 的预清理"></a>三、CMS 的预清理</h2><p>预清理主要往 2 个方面努力：</p>
<ul>
<li><p>在并发标记的阶段，如果 Eden 区有 A 对象引用到 老年代中与GC Roots没有连接的 B 对象（会被老年代里面视为垃圾），就要把 B 标记为GC Roots 可达的点。这个操作本来是放在重新标记阶段，现在放在并发标记阶段。这样，减少了重新标记 STW 的时间。</p>
</li>
<li><p>并发标记阶段，如果老年代内部引用发生变化（之前不可达的变为可达的了），建一个类似于卡表结构，后续的重新标记阶段就无需考虑这个区域了</p>
</li>
</ul>
<p>处理 From 和 to 区（那 2 个survivor 区域的名字）的对象 ， 到老年代可达，导致老年代的并发标记中的引用变化。并发可中断预处理的过程就是 ：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(xxx){</span><br><span class="line">    <span class="number">1</span>、处理 from 和 to 区的对象到老年代可达，导致的老年代并发标记中的引用变化</span><br><span class="line">    <span class="number">2</span>、老年代内部的引用变化，记录在一张表中</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样，在重新标记就可能只需要扫描部分区域即可。</p>
<p>退出循环的部分条件：</p>
<ul>
<li><p>时间控制，达到一个时间之后自动停止</p>
</li>
<li><p>Eden 区的内存使用达到设定的比例，如果比例太高的话，你这个并发预处理没什么作用</p>
</li>
</ul>
<p>都是为了让一些在重新标记做的事情，可以放到并发标记阶段，减少停留时间</p>
<blockquote>
<p>预处理是做一次，扫到就扫到了，没扫到就算了；而 并发可中断预处理 会在 while 中一遍一遍地轮，多次扫描。</p>
</blockquote>
<p>CMS 中的问题：</p>
<ul>
<li><p>CPU 敏感：由于有多线程</p>
</li>
<li><p>浮动垃圾：由于是多线程，所以会有一些清理不到，比如你边扫地别人边丢垃圾</p>
</li>
<li><p>内存碎片：CMS 本质还是标记-清理算法</p>
</li>
</ul>
<h2 id="四、JVM-的调优技巧"><a href="#四、JVM-的调优技巧" class="headerlink" title="四、JVM 的调优技巧"></a>四、JVM 的调优技巧</h2><p>如果需要确定总堆的大小，可以用堆空间的<strong>活跃数据</strong>来做，比如，JVM 运行了一个星期之后，一般就能得到其活跃区间的大小了，一般总堆以及 年轻代、老年代的设置规则如下：</p>
<table>
<thead>
<tr>
<th>空间</th>
<th>倍数</th>
</tr>
</thead>
<tbody><tr>
<td>总堆大小</td>
<td>3~4倍活跃数据大小</td>
</tr>
<tr>
<td>年轻代</td>
<td>1~1.5倍活跃数据大小</td>
</tr>
<tr>
<td>老年代</td>
<td>2~3倍活跃数据大小</td>
</tr>
<tr>
<td>永久代/元空间</td>
<td>1.2~1.5倍Full GC 后的永久代空间占用</td>
</tr>
</tbody></table>
<h3 id="4-1-拓展-增大年轻代空间能不能提高-GC-效率？"><a href="#4-1-拓展-增大年轻代空间能不能提高-GC-效率？" class="headerlink" title="4.1 拓展-增大年轻代空间能不能提高 GC 效率？"></a>4.1 拓展-增大年轻代空间能不能提高 GC 效率？</h3><p>答案： <strong>可以</strong>。因为如下原因：</p>
<ul>
<li><p>GC 时间间隔会增大。扩容之后，一般扫描的时间间隔会增加，比如以前是 500ms ，后续会变为 1000ms。</p>
</li>
<li><p>放在年轻代回收比放在老年代回收好，因为新生代的复制算法效率比较高。未增大之前，可能过两轮对象就进入老年代了（大对象直接进入、或者说某一个年龄超过一半了，等等都是会进入老年代的，不一定得年龄到了）；但是增大之后，由于新生代对象的朝生夕死的特性，还没挨到下一次GC，对象就已经不可达了，进入不了老年代</p>
</li>
<li><p>扫描判断对象是否存活的耗时比复制存活对象的耗时少。年轻代 gc 消耗的时间是： 扫描对象（耗时 T1） 、复制存活的对象到幸存区（T2），那么总时间是 T1 + T2 。那么想想，当我们扩容成 2 倍的时候，是什么情况？扫描时间应该是变成了 2 * T2 了，但是存活对象的复制过程呢？由于GC间隔时间拉长，很多对象被回收了，复制存活对象的耗时一般会比 2 * T2 要小。</p>
</li>
</ul>
<h3 id="4-2-JVM-如何如何避免-Minor-GC-时扫描全堆的？"><a href="#4-2-JVM-如何如何避免-Minor-GC-时扫描全堆的？" class="headerlink" title="4.2 JVM 如何如何避免 Minor GC 时扫描全堆的？"></a>4.2 JVM 如何如何避免 Minor GC 时扫描全堆的？</h3><p>前面我们说不同的代有不同的垃圾回收器，他们的算法是一样的，如下图所示：</p>
<p>那么，当跨代引用的时候，是如何做到无需扫描全堆的呢？举个例子，假如<strong>你要回收年轻代</strong>，我们老年代里面有个对象 A，引用了年轻代中的一个对象 B，那么老年代的 A 会被作为 GC Roots ，那么你要确定这个根，你要在老年代里面去找根？</p>
<p>所以如果有跨代，那么我们是否要进行全堆的扫描（不然没法知道GC Roots 啊，虽然你说上述情况可以作为 GC Roots）？答案是不用的，因为 JVM 可能会维护有<strong>卡表结构</strong>，它标记了所有的对象。未跨代的时候，是某个标记，假设说是 0 ；如果有跨代引用，在卡表里面就标记成另一个了，假设是 0 。</p>
<h3 id="4-3-常量池（方法区）"><a href="#4-3-常量池（方法区）" class="headerlink" title="4.3 常量池（方法区）"></a>4.3 常量池（方法区）</h3><p>常量池一般有 3 种，分别如下：</p>
<ul>
<li><p>Class 常量池：.class 文件中带的，编译时的字面量、引用。</p>
</li>
<li><p>运行时常量池：运行时如果用到的某个类A ，如果 ClassLoader 还未加载这个类 A ，那么就会是一个符号引用，这是个常量，到运行时符号引用转为直接引用。</p>
</li>
<li><p>字符串常量池：规范里面是没有的。与 String 的设计思想有关系，String 对象不可变（类被final，value数组也是final）</p>
</li>
</ul>
<p>new String(“abc”) ，已经有字面量 “abc” 了，在编译的 时候就会被放入常量池里面，并且在堆里面会创建一个 String 对象，值指向常量池的那个 “abc” 。</p>
<p>“ab” + “cd” +”ef” 这种，编译器在编译的时候就会变成 “abcdef” 直接给优化了</p>
<p>如果发现如下这种循环次数比较多的字符串相加，编译器也会优化:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"ab"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++) {</span><br><span class="line">   str += arr[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>变为使用 StringBuilder 来实现。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/31/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(05)%E5%AE%89%E5%8D%93%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/31/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(05)%E5%AE%89%E5%8D%93%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-1/" class="post-title-link" itemprop="url">Java筑基-：(05)安卓虚拟机与类加载机制-1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-31 22:59:00" itemprop="dateCreated datePublished" datetime="2023-03-31T22:59:00+08:00">2023-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-08 23:10:39" itemprop="dateModified" datetime="2023-04-08T23:10:39+08:00">2023-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、JVM-与-Dalvik"><a href="#一、JVM-与-Dalvik" class="headerlink" title="一、JVM 与 Dalvik"></a>一、JVM 与 Dalvik</h2><p>JVM 与 Dalvik 实现不同：</p>
<ul>
<li><p>JVM 是基于栈的虚拟机：每个运行时的线程都有一个独立的栈，每一次方法的调用都会往栈里面压入一个栈帧，最顶部的是当前栈帧，代表当前执行的方法。<strong>基于栈的虚拟机通过操作数栈进行所有操作。</strong></p>
</li>
<li><p>Dalvik 是基于寄存器的虚拟机：相当于<strong>将操作数栈和局部变量表合并成了虚拟寄存器</strong>。</p>
</li>
</ul>
<p>对于如下同一段代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>二者运行过程差异如下图所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%84.png" alt="二者差异"></p>
<p>上图是JVM 运行过程</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%84.png" alt="Dalvik的结构"></p>
<p>上图是 Dalvik 的运行过程。</p>
<h2 id="二、Dalvik-和-Art-区别"><a href="#二、Dalvik-和-Art-区别" class="headerlink" title="二、Dalvik 和 Art 区别"></a>二、Dalvik 和 Art 区别</h2><p>Android Dalvik 最开始是解释执行，执行的是 dex 字节码，需要经过虚拟机翻译，然后才能被机器执行。而从 2.2 开始，支持 JIT 即时编译（Just In Time），运行过程中将热点代码直接编译成机器码，后续就省略了翻译过程！因此效率更高，但也因此跨平台不行。</p>
<p>Android 5.0 最开始 ART 虚拟机执行的是本地机器码，但是 Dex 里面还是字节码。所以这个机器码从哪里来？原因是 安装做了优化，做了 AOT （Ahead Of Time）提前编译，做了 dex2oat 的优化，所以安装也慢（5.0 、6.0）。但是从 7.0 以后，又没那么慢了，变成混编了，混合了 AOT、解释 以及 JIT 这三种方式了。在运行过程中解释执行，对热点代码进行 JIT ，并且经过 JIT 编译的方法（这是临时的）记录到配置文件中。当设备空闲和充电的时候，编译守护进程会运行，根据 Profile 文件对常用代码进行 AOT 编译，下次就可以直接运行使用，而不用再从dex 文件中找了。</p>
<p>对比：</p>
<table>
<thead>
<tr>
<th>栈式 vs 寄存器式</th>
<th>对比</th>
</tr>
</thead>
<tbody><tr>
<td>指令条数</td>
<td>栈式 &gt; 寄存器式</td>
</tr>
<tr>
<td>移植性</td>
<td>栈式优于寄存器式</td>
</tr>
<tr>
<td>代码尺寸</td>
<td>栈式 &lt; 寄存器式</td>
</tr>
<tr>
<td>指令优化</td>
<td>栈式更不易优化</td>
</tr>
<tr>
<td>解释器执行速度</td>
<td>栈式解释器速度稍慢</td>
</tr>
<tr>
<td>代码生成难度</td>
<td>栈式简单</td>
</tr>
<tr>
<td>简单实现中数据移动次数</td>
<td>栈式移动次数多</td>
</tr>
</tbody></table>
<h2 id="三、ClassLoder"><a href="#三、ClassLoder" class="headerlink" title="三、ClassLoder"></a>三、ClassLoder</h2><ul>
<li><p>BootClassLoader ： 加载Android FrameWork 中的类，比如 String、Activity 等</p>
</li>
<li><p>PathClassLoader： 我们程序的 ClassLoader ，我们引入的第三方库、写的代码等</p>
</li>
</ul>
<blockquote>
<p>Android 都是自己写了这些 ClassLoader ，没有使用 Java 之前的那些，这个也能理解，原来Java 自己去加载类的时候，是加载 .class 文件；而 Android中是加载 .dex 文件了</p>
</blockquote>
<p>ClassLoader 在 load 一个类的时候，都是需要 IO 操作的（从磁盘把文件读进来），然后按照一定格式解析（类似Json 一样），所以，这个 load 这个操作一定是个耗时操作。</p>
<blockquote>
<p>注意，ClassLoader 做双亲委派机制，其中的 parent 不是指当前类的父类，这个 parent 只是 ClassLoader 中的一个成员变量而已。所以应该叫做<strong>父加载器</strong>更好点</p>
<p>比如，PathClassLoader 的父加载器是 BootClassLoder ，但是它的父类是 BaseDexClassLoader </p>
</blockquote>
<h3 id="3-1-为什么双亲委托机制"><a href="#3-1-为什么双亲委托机制" class="headerlink" title="3.1 为什么双亲委托机制"></a>3.1 为什么双亲委托机制</h3><ul>
<li><p>避免重复。被父加载器加载过了，自己就不用加载了</p>
</li>
<li><p>安全： 防止核心API 库被随意篡改。</p>
<blockquote>
<p>比如说你自己创建个 java.lang.String 类，如果没有双亲委派机制，那么你加载了你自己的 String 类，要是有崩溃，那么其他类基本上都会受影响，String 使用太广泛了。所以，双亲委派反正都是父ClassLoader 去加载，会导致都是同一个，不会有歧义。</p>
</blockquote>
</li>
</ul>
<h3 id="3-2-PathClassLoader"><a href="#3-2-PathClassLoader" class="headerlink" title="3.2 PathClassLoader"></a>3.2 PathClassLoader</h3><p>里面可以有个 dexPath 参数，初看起来只能传入一个 dex 的路径，其实是可以传入多个的，多个路径以 <strong>冒号 (:)</strong> 分割即可。之后，为每个路径的dex 文件生成一个 Element 元素，最后形成 一个 dexElements 数组。 </p>
<p><font color="#ff0000">ClassLoader 中有个 DexPathList？？？？存疑，自己去看下</font></p>
<h2 id="四、热修复"><a href="#四、热修复" class="headerlink" title="四、热修复"></a>四、热修复</h2><p>修复了 Demo.java 这个类，之后打包成  dex 文件，然后想办法将其插入到 dexElements 数组的最前面，这样，找 Demo.java 这个类的时候，从 dexElements 数组从前往后找，先找到修复后的 Demo.java ，后面的有bug 的 Demo.java 就会不管了。这样就能实现热修复了。</p>
<p>可以在 Application 的第一个方法中插入新的 dex ，要保证需要修复的类没有被加载过。因为被加载过就有这个类的缓存了，就不会从 dex 文件中去找了。</p>
<h3 id="4-1-将补丁-dex-插入到-dexElements-数组最前面"><a href="#4-1-将补丁-dex-插入到-dexElements-数组最前面" class="headerlink" title="4.1 将补丁 dex 插入到 dexElements 数组最前面"></a>4.1 将补丁 dex 插入到 dexElements 数组最前面</h3><p>这里肯定需要用到反射，具体步骤如下：</p>
<ol>
<li><p>获取到当前应用的 PathClassLoader</p>
</li>
<li><p>反射获取到它的属性对象 pathList </p>
</li>
<li><p>反射修改 pathList 的 dexElements ，这里又分为 3 个步骤</p>
<ol>
<li><p>把补丁包 patch.dex 转化为 Element[] 数组 </p>
</li>
<li><p>获得 pathList 的 dexElements 属性 dexElements</p>
</li>
<li><p>将上述新生成的 Element 数组，与老的 dexElements 合并生成新的数组 newPatchElements ，之后将这个 newPatchElements 赋值给上述的 pathList 的成员变量</p>
</li>
</ol>
</li>
</ol>
<p>怎么把单个的类打包成 dex ？在 build-tools 目录下，使用里面的 dx 来打包，命令如下：</p>
<blockquote>
<p>dx –dex –output=output.dex /packagename/A.class </p>
</blockquote>
<h3 id="4-2-我们为什么不能修改系统的类，只能修改自己的类呢？"><a href="#4-2-我们为什么不能修改系统的类，只能修改自己的类呢？" class="headerlink" title="4.2 我们为什么不能修改系统的类，只能修改自己的类呢？"></a>4.2 我们为什么不能修改系统的类，只能修改自己的类呢？</h3><p>这是因为双亲委派机制，系统的类（比如 String 类）都是通过 BootClassLoader 去加载的，而我们的类是 PathClassLoader 加载的。并且 PathClassLoader 的父加载器是 BootClassLoader ！</p>
<h2 id="五、答疑环节"><a href="#五、答疑环节" class="headerlink" title="五、答疑环节"></a>五、答疑环节</h2><p>前面讲到Android N 的时候，会有一些代码变成 机器码了，所以，这时候我们用上述的方法，是不能完成热修复的。那咋办？Tinker 自己创建了一个 ClassLoader ，这样系统就不会使用系统给的 ClassLoader ，缓存的机器码自然也就不存在了，还是会去找dex去执行。</p>
<p><strong>作业：自己实现一个 热修复的代码Demo。</strong>，补丁包直接放在 sd 卡里面即可。</p>
<blockquote>
<p>这里需要注意在 Android 10.0 的时候，对存储权限有格外要求，你可以放在私有目录</p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/31/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(03)%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/31/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(03)%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Java筑基-：(03)对象的分配及垃圾回收机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-31 17:12:00" itemprop="dateCreated datePublished" datetime="2023-03-31T17:12:00+08:00">2023-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-08 22:49:13" itemprop="dateModified" datetime="2023-04-08T22:49:13+08:00">2023-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、-JVM-中对象的创建过程"><a href="#一、-JVM-中对象的创建过程" class="headerlink" title="一、 JVM 中对象的创建过程"></a>一、 JVM 中对象的创建过程</h2><p>对象的整体创建过程如下所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" alt="对象创建过程"></p>
<p>我们的<strong>常量池</strong>里面可能存在符号引用，什么是符号引用？我们引用了一个对象，但是不知道这个对象的真实地址。举个例子：你引用了  com.esun.B  ，如果是<strong>直接引用的话，那就是真实的地址。</strong> 如果你在 A 的常量池里面引用了 B ，但是 B 还没有加载进来，这时候你就只能用一个符号。</p>
<p>在检查加载的过程会去检验是否能正常将符号引用转换为直接引用。</p>
<h3 id="1-1-内存分配"><a href="#1-1-内存分配" class="headerlink" title="1.1 内存分配"></a>1.1 内存分配</h3><p>内存分配一般有 2 种方式：</p>
<ul>
<li><p>指针碰撞。内存比较规整，前面内存已经分配到 7 了，那么这次分配从 8 开始</p>
</li>
<li><p>空闲列表。不在乎内存碎片，根据维护的空闲列表来分配</p>
</li>
</ul>
<p>分配的时候需要注意多线程安全，主要有 2 种方式：</p>
<ul>
<li><p>CAS  + 失败重试操作</p>
</li>
<li><p>本地线程分配缓冲：给每个线程在 Eden 区默认划分一块空间，线程分配的时候，就在那块空间去操作，由于线程有自己专属的，所以并不会有线程安全问题</p>
</li>
</ul>
<h3 id="1-2-对象内存布局"><a href="#1-2-对象内存布局" class="headerlink" title="1.2 对象内存布局"></a>1.2 对象内存布局</h3><p>一个对象会包括对象头、实例数据、以及对齐填充（不一定有）。其中对象头很重要，它主要包括：</p>
<ul>
<li><p>Markword</p>
</li>
<li><p>类型指针，指向方法区中的 Class ，标明它是哪个类型</p>
</li>
<li><p>记录数组长度（如果是数组对象才有）</p>
</li>
</ul>
<h2 id="二、GC"><a href="#二、GC" class="headerlink" title="二、GC"></a>二、GC</h2><h3 id="2-1-判断对象存活"><a href="#2-1-判断对象存活" class="headerlink" title="2.1 判断对象存活"></a>2.1 判断对象存活</h3><p>有 2 种主流的方式：</p>
<ul>
<li><p>引用计数，不能解决循环引用——Python 就是用这种方案</p>
</li>
<li><p>可达性分析，也说 根可达方法</p>
</li>
</ul>
<p>GCRoots 主要有4种，但是不止4种：</p>
<ul>
<li><p>静态变量</p>
</li>
<li><p>线程栈变量</p>
</li>
<li><p>常量池</p>
</li>
<li><p>JNI （指针）</p>
</li>
<li><p>如果还纠结，就有其他：Class对象、类加载器、</p>
</li>
</ul>
<blockquote>
<p>方法区中的 class 对象是否能被回收？肯定能被回收，有一个很重要的条件是 new 出的所有对象都被回收了。其他的还包括它的 ClassLoader 也被回收了等等。</p>
</blockquote>
<p>真正要宣布一个对象可回收需要 2 次标记，首先是不可达，其次就是 finalize ，所以不可达不是非死不可的条件。 finalize 里面可以让引用继续来。 DirectByteBuffer 直接内存分配，它里面也用了虚引用，是否用来协助内存回收？？待确认</p>
<h3 id="2-2-对象分配策略"><a href="#2-2-对象分配策略" class="headerlink" title="2.2 对象分配策略"></a>2.2 对象分配策略</h3><p>对象的分配原则：</p>
<ul>
<li><p>对象优先在 Eden 分配</p>
</li>
<li><p>空间分配担保</p>
</li>
<li><p>大对象直接进入老年代</p>
</li>
<li><p>长期存活的对象进入老年代</p>
</li>
<li><p>动态年龄判定</p>
</li>
</ul>
<p>我们说<strong>几乎所有的对象都在堆上分配</strong>，为什么是几乎？因为还有<strong>栈上分配</strong>这种方案：</p>
<ul>
<li>触发了 JIT （热点数据），逃逸分析的时候发现对象不会逃出当前方法和线程，的时候就可能触发栈上分配</li>
</ul>
<h3 id="2-3-GC-详情"><a href="#2-3-GC-详情" class="headerlink" title="2.3 GC 详情"></a>2.3 GC 详情</h3><p>堆分代：</p>
<ul>
<li><p>新生代： Eden区、s0、s1 区，三者大小 8:1:1 ？为什么，因为大多数对象都是朝生夕死的，存活时间很短</p>
</li>
<li><p>老年代，一般老年代 GC ，就会触发 Full  GC： 也就是年轻代、老年代、方法区都 GC</p>
</li>
</ul>
<p>新生代一般是用复制算法，老年代是标记整理、标记清除算法</p>
<p>标记整理算法都是怎么做呢？ 其实是： 标记——&gt;整理——&gt; 清除 ，为什么要这么做呢？（有些人会以为是：标记——&gt;清除——&gt; 整理 ），这是因为这里的时候，可以覆盖那些垃圾，等整理完了之后，垃圾可能会变少了，清除也快一些。</p>
<blockquote>
<p>这个过程会有STW 的，暂停所有线程，这是为什么？因为整理的时候，对象的位置会发生变化啊，整理之后，以前在位置 15 的时候变成 位置 6 了，所以要停止。</p>
</blockquote>
<h2 id="三、虚拟机的优化技术"><a href="#三、虚拟机的优化技术" class="headerlink" title="三、虚拟机的优化技术"></a>三、虚拟机的优化技术</h2><ul>
<li><p>热点数据编译成本地代码</p>
</li>
<li><p>本地线程分配缓冲</p>
</li>
</ul>
<p>最终， JVM 的学习一张图看了：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg" alt="JVM一张图"></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">173</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共355.9k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/2/',]
      });
      });
  </script>


</body>
</html>
