<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/2/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">35</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">208</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/23/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/02-%E7%BB%84%E4%BB%B6%E5%8C%96-%E7%AC%AC%E4%B8%80%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/23/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/02-%E7%BB%84%E4%BB%B6%E5%8C%96-%E7%AC%AC%E4%B8%80%E8%8A%82/" class="post-title-link" itemprop="url">02-组件化-第一节</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-23 15:41:00" itemprop="dateCreated datePublished" datetime="2023-06-23T15:41:00+08:00">2023-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:13:10" itemprop="dateModified" datetime="2023-06-28T22:13:10+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、起因"><a href="#一、起因" class="headerlink" title="一、起因"></a>一、起因</h2><p>早期的时候，一个项目都在一个一起，通过包名来控制不同的模块和功能。这种方式的缺点：</p>
<ul>
<li>层次混乱：无论怎么做分包，随着项目增大，就会失去层次感，接手的人扑街</li>
<li>耦合度高，低内聚：。包名约束太弱，稍不注意就不同业务包直接相互调用</li>
<li>不易于版本管理，容易代码冲突</li>
<li>难以重用</li>
</ul>
<p>所以，很容易想到组件化的好处：</p>
<ul>
<li>不相互依赖</li>
<li>可以互相交互</li>
<li>高度解耦</li>
<li>自由拆卸组合</li>
<li>重复利用</li>
</ul>
<h2 id="二、组件化环境"><a href="#二、组件化环境" class="headerlink" title="二、组件化环境"></a>二、组件化环境</h2><p>各个模块组件都能单独打包，对于测试是很友好的。在正式上线的时候，所有模块都需要App 壳才能运行。</p>
<h3 id="2-1-Gradle"><a href="#2-1-Gradle" class="headerlink" title="2.1 Gradle"></a>2.1 Gradle</h3><p>gradle 的根在哪里？ 就是 <em>settings.gradle</em> 这个文件！然后，我们整个项目有个 gradle ，这个 project 就在项目根目录下 <em>build.gradle</em> 。 build 的步骤就是：</p>
<ol>
<li><p>settings.gradle</p>
</li>
<li><p>Project 级别的 build.gradle</p>
</li>
<li><p>壳工程的 build.gradle</p>
</li>
<li><p>library 中的 build.gradle</p>
</li>
</ol>
<p>app 和 各个 module 中都有 gradle 文件，里面可能会包含相同代码，比如 编译工具版本、最小支持版本。<strong>我们可以在project 下面新建 gradle ，比如命名为 app.gradle，在里面写上 ext 扩展块</strong>，代码如下：</p>
<figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ext {</span><br><span class="line">    compileSdkVersion <span class="number">30</span></span><br><span class="line">    defaultConfit {</span><br><span class="line">        minSdkVersion <span class="number">16</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不过此时还不能被系统所认识，只能知道这是 key-value 的形式，我们只能将其引入到<strong>project 所属的gradle 中</strong>才能实现，那么，在 Project 的 build.gradle 中可以写如下代码：</p>
<figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">from:</span> <span class="string">'app.gradle'</span></span><br></pre></td></tr></tbody></table></figure>



<p>所以，在各个模块中，可以使用这个公共的gradle 文件了：</p>
<figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> ext = rootProject.ext</span><br><span class="line">android {</span><br><span class="line">    compileSdkVersion ext.compileSdkVersion</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里不去定义 def ext 也是可以的，但是为什么要这么做呢？这是为了性能考虑，因为这样定义一下就相当于局部变量了，能提高运行速度（老师说这个可以在面试时候去说的，说明真的玩过gradle）。</p>
<p>最后，放上App 壳和各个模块之间的配置，可以做到：</p>
<ul>
<li><p>正式环境和测试环境的部署</p>
</li>
<li><p>当测试环境时，各个模块可以单独运行和打包，正式环境的时候必须依赖App壳才能运行</p>
</li>
<li><p>所有的公共配置都放在app.gradle 中，各个模块按需获取其中的配置（可能某些模块对于某个配置不需要）</p>
</li>
</ul>
<p>配置代码如下：</p>
<figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//公共的依赖 derry.gradle 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展快</span></span><br><span class="line">ext {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在 Gradle</span></span><br><span class="line">    <span class="comment">// 正式环境 和 测试环境</span></span><br><span class="line">    isRelease = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正式环境 和 测试环境 服务器 URL 配置</span></span><br><span class="line">    url = [</span><br><span class="line">            <span class="string">"debug"</span>  : <span class="string">"https://192.188.22.99/debug"</span>,</span><br><span class="line">            <span class="string">"release"</span>: <span class="string">"https://192.188.22.99/release"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立Map存储，  key 和 value  都是自定义的</span></span><br><span class="line">    androidID = [</span><br><span class="line">            <span class="attr">compileSdkVersion        :</span> <span class="number">30</span>,</span><br><span class="line">            <span class="attr">buildToolsVersion        :</span> <span class="string">"30.0.1"</span>,</span><br><span class="line"></span><br><span class="line">            <span class="attr">applicationId            :</span> <span class="string">"com.derry.derry"</span>,</span><br><span class="line">            <span class="attr">minSdkVersion            :</span> <span class="number">16</span>,</span><br><span class="line">            <span class="attr">targetSdkVersion         :</span> <span class="number">30</span>,</span><br><span class="line">            <span class="attr">versionCode              :</span> <span class="number">1</span>,</span><br><span class="line">            <span class="attr">versionName              :</span> <span class="string">"1.0"</span>,</span><br><span class="line"></span><br><span class="line">            <span class="symbol">testInstrumentationRunner:</span> <span class="string">"androidx.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立Map存储，  key 和 value  都是自定义的</span></span><br><span class="line">    appID = [</span><br><span class="line">            <span class="symbol">app:</span> <span class="string">"com.derry.modularproject"</span>,</span><br><span class="line">            <span class="symbol">login:</span> <span class="string">"com.derry.login"</span>,</span><br><span class="line">            <span class="symbol">register:</span> <span class="string">"com.derry.register"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 300 行  MAP  key  value</span></span><br><span class="line">    dependenciesID = [</span><br><span class="line">            <span class="string">"appcompat"</span>       : <span class="string">"androidx.appcompat:appcompat:1.2.0"</span>,</span><br><span class="line">            <span class="string">"constraintlayout"</span>: <span class="string">"androidx.constraintlayout:constraintlayout:2.0.1"</span>,</span><br><span class="line">            <span class="string">"material"</span>        : <span class="string">"com.google.android.material:material:1.1.0"</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//project 根目录下的 build.gradle</span></span><br><span class="line"><span class="comment">// 根目录下的build.gradle 引入   公共的一份 引入过来</span></span><br><span class="line">apply <span class="attr">from :</span> <span class="string">'derry.gradle'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></span><br><span class="line">buildscript {</span><br><span class="line">    repositories {</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    }</span><br><span class="line">    dependencies {</span><br><span class="line">        classpath <span class="string">"com.android.tools.build:gradle:4.0.1"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">allprojects {</span><br><span class="line">    repositories {</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">task clean(<span class="attr">type:</span> Delete) {</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//某个library</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">'com.android.library'</span></span><br><span class="line"></span><br><span class="line">println <span class="string">"Derry ---&gt; lib Student hao 2"</span></span><br><span class="line"></span><br><span class="line">android {</span><br><span class="line">    compileSdkVersion androidID.compileSdkVersion</span><br><span class="line">    buildToolsVersion androidID.buildToolsVersion</span><br><span class="line"></span><br><span class="line">    defaultConfig {</span><br><span class="line">        minSdkVersion androidID.minSdkVersion</span><br><span class="line">        targetSdkVersion androidID.targetSdkVersion</span><br><span class="line">        versionCode androidID.versionCode</span><br><span class="line">        versionName androidID.versionName</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">"androidx.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    buildTypes {</span><br><span class="line">        release {</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android-optimize.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">dependencies {</span><br><span class="line">    implementation fileTree(<span class="attr">dir:</span> <span class="string">"libs"</span>, <span class="attr">include:</span> [<span class="string">"*.jar"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*implementation "androidx.appcompat:appcompat:1.2.0"</span></span><br><span class="line"><span class="comment">    implementation "androidx.constraintlayout:constraintlayout:2.0.1"</span></span><br><span class="line"><span class="comment">    implementation "com.google.android.material:material:1.1.0"</span></span><br><span class="line"><span class="comment">    implementation "androidx.vectordrawable:vectordrawable:1.1.0"</span></span><br><span class="line"><span class="comment">    implementation "androidx.navigation:navigation-fragment:2.2.2"</span></span><br><span class="line"><span class="comment">    implementation "androidx.navigation:navigation-ui:2.2.2"</span></span><br><span class="line"><span class="comment">    implementation "androidx.lifecycle:lifecycle-extensions:2.2.0"*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一行搞定300行 循环搞定</span></span><br><span class="line">    dependenciesID.each {k,v -&gt; implementation v}</span><br><span class="line"></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    androidTestImplementation <span class="string">'androidx.test.ext:junit:1.1.2'</span></span><br><span class="line">    androidTestImplementation <span class="string">'androidx.test.espresso:espresso-core:3.3.0'</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//login这个 module 的 build.gradle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// apply plugin: 'com.android.application'</span></span><br><span class="line"><span class="keyword">if</span> (isRelease) { <span class="comment">// 如果是发布版本时，各个模块都不能独立运行</span></span><br><span class="line">    apply <span class="attr">plugin:</span> <span class="string">'com.android.library'</span> <span class="comment">// 正式环境  library不能独立运行</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    apply <span class="attr">plugin:</span> <span class="string">'com.android.application'</span> <span class="comment">// 测试环境 application独立运行</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">android {</span><br><span class="line">    compileSdkVersion <span class="number">30</span></span><br><span class="line">    buildToolsVersion <span class="string">"30.0.1"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig {</span><br><span class="line">        <span class="comment">// applicationId "" // 有appid 能够独立运行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isRelease) {  <span class="comment">// 能够独立运行 必须要有appID</span></span><br><span class="line">            applicationId appID.login <span class="comment">// 组件化模式能独立运行才能有applicationId</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        minSdkVersion <span class="number">16</span></span><br><span class="line">        targetSdkVersion <span class="number">30</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">"androidx.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    buildTypes {</span><br><span class="line">        release {</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android-optimize.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    sourceSets {</span><br><span class="line">        main {</span><br><span class="line">            <span class="keyword">if</span> (!isRelease) {</span><br><span class="line">                <span class="comment">// 如果是组件化模式，需要单独运行时 Debug</span></span><br><span class="line">                manifest.srcFile <span class="string">'src/main/debug/AndroidManifest.xml'</span> <span class="comment">// 生效</span></span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 正式环境下</span></span><br><span class="line">                <span class="comment">// 集成化模式，整个项目打包apk</span></span><br><span class="line">                manifest.srcFile <span class="string">'src/main/AndroidManifest.xml'</span> <span class="comment">// 让我们之前 默认的路径下的清单文件再次生效</span></span><br><span class="line"></span><br><span class="line">                java {</span><br><span class="line">                    <span class="comment">// 减小包大小，release 时 debug 目录下文件不需要合并到主工程</span></span><br><span class="line">                    exclude <span class="string">"**/debug/**"</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">dependencies {</span><br><span class="line">    implementation fileTree(<span class="attr">dir:</span> <span class="string">"libs"</span>, <span class="attr">include:</span> [<span class="string">"*.jar"</span>])</span><br><span class="line">    implementation <span class="string">'androidx.appcompat:appcompat:1.2.0'</span></span><br><span class="line">    implementation <span class="string">'androidx.constraintlayout:constraintlayout:2.0.4'</span></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    androidTestImplementation <span class="string">'androidx.test.ext:junit:1.1.2'</span></span><br><span class="line">    androidTestImplementation <span class="string">'androidx.test.espresso:espresso-core:3.3.0'</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p>上面代码可能有一些重复的，每个 gradle 文件可能侧重某一个点，需要注意甄别。</p>
<h2 id="三、组件之间的通信方式"><a href="#三、组件之间的通信方式" class="headerlink" title="三、组件之间的通信方式"></a>三、组件之间的通信方式</h2><p>如果订单模块想要访问个人模块的信息，那我们必须要有个什么注册表，我们将这些功能注册到这个注册表中，需要调用的时候，就通过这个注册表。</p>
<blockquote>
<p>值得注意的一点是，为什么需要不用横向依赖，因为横向依赖的方式可能会有一些意想不到的问题，比如循环依赖，比如订单module 依赖个人 module ，个人 module 又依赖 订单module 。</p>
</blockquote>
<p>可行的集中通信方式：</p>
<ul>
<li><p>EventBus：缺点是EventBean 的维护成本太高，不好管理</p>
</li>
<li><p>广播：不好管理，都统一发送出去了，并且后续Android版本广播都需要动态注册了（这点存疑，需要验证）</p>
</li>
<li><p>使用隐式意图：这个就更麻烦了，要求每个 Activity 都必须有自己<strong>唯一</strong>的action 名字</p>
</li>
<li><p>类加载方式：容易写错包名的类，相对而言缺点较少，可以尝试</p>
</li>
<li><p>使用全局 Map ：因为所有的 module 都需要依赖公共基础库，所以可以在公共基础库中添加一个 Map ，注册所有的Activity， 需要注册很多对象，相对而言缺点少，可以尝试</p>
</li>
</ul>
<p>其中类加载和 全局 Map 的方式使用代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jumpPersonal</span><span class="params">(View view)</span> </span>{</span><br><span class="line">    <span class="comment">// todo 方式一 类加载</span></span><br><span class="line">    <span class="comment">// 类加载跳转，可以成功。维护成本较高且容易出现人为失误</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Class targetClass = Class.forName(<span class="string">"com.xiangxue.personal.Personal_MainActivity"</span>);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, targetClass);</span><br><span class="line">        intent.putExtra(<span class="string">"name"</span>, <span class="string">"derry"</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// personal/Personal_MainActivity getMap</span></span><br><span class="line">    <span class="comment">// todo 方式二 全局Map</span></span><br><span class="line">    Class&lt;?&gt; targetActivity =</span><br><span class="line">            RecordPathManager.startTargetActivity(<span class="string">"personal"</span>, <span class="string">"Personal_MainActivity"</span>);</span><br><span class="line">    startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, targetActivity));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>需要注意的一点是，使用类加载方式，我们使用的是 Class.forName 的方式，这个是反射吗？<strong>这并不是反射，这只是类加载！反射我们是指反射属性，方法等，我们也不会看到导入的包里面有 Reflect 等反射的包名</strong></p>
</blockquote>
<p>当然，使用全局 Map 的方式必须还要在 Common 公共依赖里面有管理类：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局路径记录器（根据子模块进行分组）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 组名：app，order，personal</span></span><br><span class="line"><span class="comment"> *       详情order=[Order_MainActivity,Order_MainActivity2,Order_MainActivity3]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordPathManager</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先理解成 仓库</span></span><br><span class="line"><span class="comment">     * group: app,order,personal</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * order:</span></span><br><span class="line"><span class="comment">     *      OrderMainActivity1</span></span><br><span class="line"><span class="comment">     *      OrderMainActivity2</span></span><br><span class="line"><span class="comment">     *      OrderMainActivity3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;PathBean&gt;&gt; maps = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将路径信息加入全局Map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupName 组名，如："personal"</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pathName  路劲名，如："Personal_MainActivity"</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz     类对象，如：Personal_MainActivity.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addGroupInfo</span><span class="params">(String groupName, String pathName, Class&lt;?&gt; clazz)</span> </span>{</span><br><span class="line">        List&lt;PathBean&gt; list = maps.get(groupName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == list) {</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(<span class="keyword">new</span> PathBean(pathName, clazz));</span><br><span class="line">            <span class="comment">// 存入仓库</span></span><br><span class="line">            maps.put(groupName, list);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 存入仓库</span></span><br><span class="line">            maps.put(groupName, list);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只需要告诉我，组名 ，路径名，  就能返回 "要跳转的Class"</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupName 组名 oder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pathName 路径名  OrderMainActivity1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 跳转目标的class类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; startTargetActivity(String groupName, String pathName) {</span><br><span class="line">        List&lt;PathBean&gt; list = maps.get(groupName);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) {</span><br><span class="line">            Log.d(Config.TAG, <span class="string">"startTargetActivity 此组名得到的信息，并没有注册进来哦..."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 遍历 寻找 去匹配 “PathBean”对象</span></span><br><span class="line">        <span class="keyword">for</span> (PathBean pathBean : list) {</span><br><span class="line">            <span class="keyword">if</span> (pathName.equalsIgnoreCase(pathBean.getPath())) {</span><br><span class="line">                <span class="keyword">return</span> pathBean.getClazz();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>然后，我们可以在各个 Module 里面需要注册当前 Module 所拥有的全部 Activity （当然，这个并不优雅，开发者可能会忘记，可以采用注解或者其他的方式去做，这里只是简单实现）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppApplication</span> <span class="keyword">extends</span> <span class="title">BaseApplication</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果项目有100个Activity，这种加法会不会太那个？  缺点</span></span><br><span class="line">        RecordPathManager.addGroupInfo(<span class="string">"app"</span>, <span class="string">"MainActivity"</span>, MainActivity.class);</span><br><span class="line">        RecordPathManager.addGroupInfo(<span class="string">"order"</span>, <span class="string">"Order_MainActivity"</span>, Order_MainActivity.class);</span><br><span class="line">        RecordPathManager.addGroupInfo(<span class="string">"personal"</span>, <span class="string">"Personal_MainActivity"</span>, Personal_MainActivity.class);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>所以，全局Map 的方案跳转的时候，只需要标明你想跳转哪个module ，以及module 中的哪个 Activity。但是上述方式还是有点麻烦，这时候，<strong>阿里开源的 Arouter就应运而生了</strong>。</p>
<p>组件化通信框架很多，但是目前最优秀的是 ARouter 。</p>
<p>组件化：模块之间没有依赖，便于重用</p>
<p>插件化：侧重动态化加载某些功能，主要问题是兼容性问题，支付宝都放弃了，因为你兼容了 5.0 ，能兼容 11.0 吗</p>
<p>模块化：模块化是业务层面的拆分，组件化是功能层次的划分</p>
<p>Google 表态说是 FrameWork 仍然还是 Java ，不会改成 Kotlin  </p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/22/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/11-Retrofit%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/22/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/11-Retrofit%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">11-Retrofit设计模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-22 19:57:00" itemprop="dateCreated datePublished" datetime="2023-06-22T19:57:00+08:00">2023-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 23:02:47" itemprop="dateModified" datetime="2023-06-28T23:02:47+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、策略模式"><a href="#一、策略模式" class="headerlink" title="一、策略模式"></a>一、策略模式</h2><p>都是基于同一个目的，采用不同的方式去实现。</p>
<p>比如： 想去西藏旅游，可以骑自行车、坐火车、坐飞机，这是不同的策略，最终都是去西藏旅游。</p>
<p>所以，Retrofit 中生成 call 采用 Adapter 的策略方式，这样就能适配各种情况，比如有人采用 RXJava ，这样就能设计自己Adapter ，返回的 call 不是 Okhttp 里面的 Call ，这样，避免太过于僵化。</p>
<h3 id="1-1-设计模式"><a href="#1-1-设计模式" class="headerlink" title="1.1 设计模式"></a>1.1 设计模式</h3><p>设计模式怎么学习：</p>
<ol>
<li><p>什么是设计模式</p>
</li>
<li><p>分析源码采用，为什么用，有什么好处</p>
</li>
<li><p>思考自己的项目，写对应的代码</p>
</li>
</ol>
<h2 id="二、动态代理"><a href="#二、动态代理" class="headerlink" title="二、动态代理"></a>二、动态代理</h2><p>为什么我使用 Retrofit 的时候，只需要定义一个 接口，然后就能直接使用这个接口了，接口也不能创建对象啊。其实就是动态代理的设计模式实现的。来看看他们这个的使用方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></tbody></table></figure>

<p>使用动态代理，虚拟机就会自动生成一个类，实现了这个接口的一个类。</p>
<p>静态代理相当于经纪人，可以代理特定的人；动态代理相当于经济公司，动态生成代理人，能够适应各种各样的被代理人需求，拍电影的、唱歌的、跳舞的都能代理，因为是动态生成的。</p>
<h2 id="三、适配器设计模式"><a href="#三、适配器设计模式" class="headerlink" title="三、适配器设计模式"></a>三、适配器设计模式</h2><p>适配器的缺点：过多的适配器容易增加阅读的复杂度。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/22/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/10-retrofit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/22/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/10-retrofit/" class="post-title-link" itemprop="url">10-retrofit</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-22 10:49:00" itemprop="dateCreated datePublished" datetime="2023-06-22T10:49:00+08:00">2023-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 23:01:45" itemprop="dateModified" datetime="2023-06-28T23:01:45+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>注意：Retrofit 的源码是基于 2.0.1 </p>
<h2 id="一、切面编程"><a href="#一、切面编程" class="headerlink" title="一、切面编程"></a>一、切面编程</h2><p>Okhttp 作为一个网络库是非常好的了，因为它采用了AOP切面思想（那些 Interceptors），也实现高内聚低耦合，但是在实际使用的时候有一些问题：</p>
<ul>
<li><p>用户网络请求的接口配置繁琐，尤其需要配置复杂请求body 、请求头 的时候</p>
</li>
<li><p>数据解析过程中需要用户手动拿到 responseBody 进行解析，（请求参数）不能复用</p>
</li>
<li><p>无法适配自动进行线程切换</p>
</li>
<li><p>存在嵌套的网络请求（如：UserId 获取到之后再获取用户详细信息，详细信息获取后再下单），就会陷入“回调地狱”</p>
</li>
</ul>
<p>基于此，Retrofit 就诞生了，它主要解决 2 个问题：</p>
<ul>
<li><p>请求前：统一配置网络的请求头，一致适配请求 request</p>
</li>
<li><p>请求后：数据适配（解析json数据）、线程切换</p>
</li>
</ul>
<p>Retrofit 总共 16个类，却采用了 8 种设计模式。</p>
<h2 id="二、Retrofit-类的本身设计思想"><a href="#二、Retrofit-类的本身设计思想" class="headerlink" title="二、Retrofit 类的本身设计思想"></a>二、Retrofit 类的本身设计思想</h2><h3 id="2-1-Retrofit-的整体使用"><a href="#2-1-Retrofit-的整体使用" class="headerlink" title="2.1 Retrofit 的整体使用"></a>2.1 Retrofit 的整体使用</h3><p>总体分为4个步骤：</p>
<ol>
<li><p>构建一个Retrofit</p>
</li>
<li><p>基于访问接口创建一个 接口类型的对象</p>
</li>
<li><p>基于接口类型的对象以及参数构建一个 Okhttp Call</p>
</li>
<li><p>将请求 Call 添加到 Okhttp 的请求队列</p>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步</span></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步</span></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步</span></span><br><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第四步</span></span><br><span class="line">repos.enqueue(<span class="keyword">new</span>  Callable&lt;List&lt;Repo&gt;&gt;(){</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(XX xx, YY yy)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(M m ,N n)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>其中，接口 GitHubService.java 的代码可能是这样的 ：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>{</span><br><span class="line">  <span class="meta">@GET("users/{user}/repos")</span></span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path("user")</span> String user);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  根据上面的代码，我们可以有几个疑问：</p>
<ul>
<li><p>看第二步，貌似我们的接口被直接使用了？根据我们学习的 Java 知识，接口不能被直接使用啊，没有接口实例啊</p>
</li>
<li><p>第三步传入的 参数 “octocat” 到底去哪里了</p>
</li>
<li><p>url 到底怎么形成的？因为我们传入的只有一个主域名 “<a target="_blank" rel="noopener" href="https://api.github.com/&quot;">https://api.github.com/"</a></p>
</li>
<li><p>为什么所有的请求都是同样的方式</p>
</li>
</ul>
<p>当你一行行看代码的时候就完蛋了，就会陷入细节，应该先看框架，看大体，思路流程好了之后再看细节。</p>
<p>参数大于 5 个 &amp;&amp; 带有可选参数，我们就可以使用构建者模式，这是使用 Builder 的一个原则。</p>
<h2 id="三、Retrofit-设计的-AOP-思想"><a href="#三、Retrofit-设计的-AOP-思想" class="headerlink" title="三、Retrofit 设计的 AOP 思想"></a>三、Retrofit 设计的 AOP 思想</h2><p>从代码：</p>
<blockquote>
<p>GitHubService service = retrofit.create(GitHubService.class); </p>
</blockquote>
<p>可以看出，retrofit 肯定创建了接口子类对象了， 不然不可能给接口变量赋值。在 Retrofit 类中这个 create 方法的实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>{</span><br><span class="line">  validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">return</span> (T)</span><br><span class="line">      Proxy.newProxyInstance(</span><br><span class="line">          service.getClassLoader(),</span><br><span class="line">          <span class="keyword">new</span> Class&lt;?&gt;[] {service},</span><br><span class="line">          <span class="keyword">new</span> InvocationHandler() {</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">              <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">              <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) {</span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">              }</span><br><span class="line">              args = args != <span class="keyword">null</span> ? args : emptyArgs;</span><br><span class="line">              Platform platform = Platform.get();</span><br><span class="line">              <span class="keyword">return</span> platform.isDefaultMethod(method)</span><br><span class="line">                  ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">                  : loadServiceMethod(method).invoke(args);</span><br><span class="line">            }</span><br><span class="line">          });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从上面可以看出来，这是动态代理实现的。它会生成一个 </p>
<h2 id="四、是否可以作为单例"><a href="#四、是否可以作为单例" class="headerlink" title="四、是否可以作为单例"></a>四、是否可以作为单例</h2><p>Retrofit 在使用的时候，能不能封装成单例呢？很多同学在 build 出来 Retrofit 对象后，将其作为单例保存，但其实不建议这么做。老师说的是可能带来内存泄漏，在 build 的时候，会有很多变量都会保存起来在 Retrofit 中，都会一直占内存。（对于这个论据不太认可，网络是会贯穿整个 App 使用周期的，所以网络的对象持续整个 App 生命周期感觉问题也不大）</p>
<blockquote>
<p>如果网络请求非常非常频繁，比如股票，那我们就可以考虑 netty 。普通 App 的请求使用完就可以销毁。</p>
</blockquote>
<h2 id="五、ServiceMethod-的存在价值"><a href="#五、ServiceMethod-的存在价值" class="headerlink" title="五、ServiceMethod 的存在价值"></a>五、ServiceMethod 的存在价值</h2><p>注解的使用：</p>
<ul>
<li><p>apt 技术：生成代码</p>
</li>
<li><p>注解 + 反射 运用</p>
</li>
</ul>
<p>ServiceMethod 主要作用就是解析注解，解析请求返回值</p>
<p>将接口转变为 Okhttp 的 Call ，把注解和传入的参数一起封装在里面。所以，一个请求接口对应一个 ServiceMethod ，当一个 interface 中有多个 方法时，就会对应多个 ServiceMethod 。</p>
<p>默认的话，获取到的 Call 是 ExecutorCallbackCall<t> 这个类型。第四步中的 enqueue 操作，最终会调用到 OkhttpCall 的 enqueue ，会里面会创建一个真正的 OkhttpCall 。 </t></p>
<p>ServiceMethod 中封装了所有的变量，所以 toRequest 方法可以利用这些变量（包括 post/get 等）封装出一个 OKhttp 的 Request 对象。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/21/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/09-Glide-%E7%AC%AC%E4%B8%89%E8%8A%82%E8%AF%BE(%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AD%A6%E4%B9%A0)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/21/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/09-Glide-%E7%AC%AC%E4%B8%89%E8%8A%82%E8%AF%BE(%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AD%A6%E4%B9%A0)/" class="post-title-link" itemprop="url">09-Glide-第三节课(缓存机制的学习)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-21 10:33:00" itemprop="dateCreated datePublished" datetime="2023-06-21T10:33:00+08:00">2023-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 23:00:16" itemprop="dateModified" datetime="2023-06-28T23:00:16+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>缓存和生命周期是 Glide 的精华。</p>
<h2 id="一、资源封装"><a href="#一、资源封装" class="headerlink" title="一、资源封装"></a>一、资源封装</h2><p>Glide 总共有三级缓存，分别是：</p>
<ul>
<li><p>活动缓存</p>
</li>
<li><p>LRU 内存缓存</p>
</li>
<li><p>磁盘缓存</p>
</li>
</ul>
<p>整个资源的获取流程是比较复杂的，一张图来说就是这样：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Glide%E7%BC%93%E5%AD%98%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt="Glide缓存加载过程"></p>
<p>具体而言就是：</p>
<ol>
<li><p>加载图片的时候，<strong>首先从活动缓存中获取</strong>，如果没有，则去LRU 内存缓存中获取</p>
</li>
<li><p>如果LRU内存缓存中有的话，则将图片<strong>剪切</strong>（图片从内存缓存中<strong>移动</strong>到活动缓存中，LRU内存缓存自己就没有了）到活动缓存并且使用</p>
</li>
<li><p>如果 LRU 内存中没有的话，则会请求网络，请求成功后保存到磁盘缓存中，<strong>并且复制一份到活动缓存供马上使用</strong></p>
</li>
<li><p>当监听到生命周期执行 onDestroy （非 Application 生命周期情况下利用空白 Fragment 监听），则会将活动缓存中的图片<strong>移入LRU内存缓存中</strong></p>
</li>
</ol>
<blockquote>
<p>注意，LRU 内存缓存和 磁盘缓存都采用了 LRU 算法存储图片</p>
</blockquote>
<h2 id="资源封装"><a href="#资源封装" class="headerlink" title="资源封装"></a>资源封装</h2><p>Glide 的资源封装，是将图片 url 作为 key（需要处理下，比如是用sh256处理） ，Bitmap 作为 Value </p>
<h2 id="活动缓存（ActiveCache-java）"><a href="#活动缓存（ActiveCache-java）" class="headerlink" title="活动缓存（ActiveCache.java）"></a>活动缓存（ActiveCache.java）</h2><p>提到缓存，肯定就涉及到：容器、put 、get 这三个</p>
<p>活动缓存的容器就使用一个 普通的 HashMap 即可，因为只需要存储目前正在使用的图片，其中key 为 处理过的 url ，value 为封装的 Bitmap 即可。同时各个元素添加进来的时候实现接口 callback ，方便在生命周期变化的时候回收和移动封装的 Bitmap 。</p>
<h2 id="内存缓存-MemoryCache-java"><a href="#内存缓存-MemoryCache-java" class="headerlink" title="内存缓存(MemoryCache.java)"></a>内存缓存(MemoryCache.java)</h2><p>LRUCache 的实现中，sizeOf 默认是返回 1 ，意味着，默认情况下每个元素的大小是 1 不是实际的图片大小。所以在 MemoryCache.java （继承了 LRUCache 类）需要重写其 sizeOf 方法。</p>
<h3 id="Android-获取-Bitmap-的大小"><a href="#Android-获取-Bitmap-的大小" class="headerlink" title="Android 获取 Bitmap 的大小"></a>Android 获取 Bitmap 的大小</h3><p>在最开始的时候，使用 Bitmap.getRowBytes ，这个方法最终是在 native 层实现的。到了 API 12 也就是 3.0 的时候，开始更改方法，变成了  Bitmap.getByteCount() ，它是在 Java 层实现的。到了 API 19 也就是 4.4 的时候，又变成了 Bitmap.getAllocationByteCount 了，又放到 Native 层实现了。</p>
<blockquote>
<p>说一下，为什么我们设计的时候，需要将 url 进行处理后才能作为key ？这是因为我们磁盘存储文件的时候，命名不能包含斜杠和冒号等内容，会直接报错的的</p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/20/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8809%EF%BC%892021.12.28-PKMS%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%E5%AE%9E%E6%88%98---derry%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/20/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8809%EF%BC%892021.12.28-PKMS%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%E5%AE%9E%E6%88%98---derry%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（09）2021.12.28-PKMS权限申请实战---derry老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-20 10:48:28" itemprop="dateCreated datePublished" datetime="2023-06-20T10:48:28+08:00">2023-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:06:41" itemprop="dateModified" datetime="2023-06-28T22:06:41+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>6.0 以后，Android 权限分为正常权限和危险权限，危险权限有以下几种：</p>
<ul>
<li>calendar</li>
<li>Camera</li>
<li>Location</li>
<li>Phone-拨打电话</li>
<li>SMS -短信相关</li>
<li>Storage -读取存储相关的权限</li>
</ul>
<p>权限是一组一组的，如果你申请了 读取 存储的权限，那么写存储的权限可以不用，因为它们是同一组的。</p>
<p>权限申请整体代码过程如下图所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B.png" alt="权限申请代码流程"></p>
<p>在 Activity 的 requestPermissions 的方法里面，最终会调用 startActivityForResult 启动授权 Activity ，这也是为什么我们能收到 onRequestPermissionsResult 的原因：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">requestPermissions</span><span class="params">(<span class="meta">@NonNull</span> String[] permissions, <span class="keyword">int</span> requestCode)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (requestCode &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"requestCode should be &gt;= 0"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (mHasCurrentPermissionsRequest) {</span><br><span class="line">        Log.w(TAG, <span class="string">"Can request only one set of permissions at a time"</span>);</span><br><span class="line">        <span class="comment">// Dispatch the callback with empty arrays which means a cancellation.</span></span><br><span class="line">        onRequestPermissionsResult(requestCode, <span class="keyword">new</span> String[<span class="number">0</span>], <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);</span><br><span class="line">    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, <span class="keyword">null</span>);</span><br><span class="line">    mHasCurrentPermissionsRequest = <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里面有个小的知识点，Intent 是通过 build 创建出来的，这里是启动隐式的 App：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">buildRequestPermissionsIntent</span><span class="params">(<span class="meta">@NonNull</span> String[] permissions)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (ArrayUtils.isEmpty(permissions)) {</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"permission cannot be null or empty"</span>);</span><br><span class="line">    }</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(ACTION_REQUEST_PERMISSIONS);</span><br><span class="line">    intent.putExtra(EXTRA_REQUEST_PERMISSIONS_NAMES, permissions);</span><br><span class="line">    intent.setPackage(getPermissionControllerPackageName());</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>直接使用 new Intent(ACTION_REQUEST_PERMISSIONS) 的方式，这是通过隐式意图来激活某个 Activity ，根据常量 ACTION_REQUEST_PERMISSIONS 可以在源码找到（肯定是在 AndroidManifest.xml 中）这个 Activity 就是 GrantPermissionsActivity 。这种隐藏的 App （比如apk安装器）我们直接启动是启动不了的。 </p>
<p>用户点击确认授权，会通过进程间通信交给PermissionManagerService 去处理，当然，过程还需要 PKMS 去查询这个 App 。</p>
<p>当授权通过后，会通过 Settings.writeRuntimePermissionxxx 方法将这个记录保留到 xml （system/users/0/runtime-permissions.xml 文件）中永久保存，此后会一直存在，如果卸载 App ，就将这个记录删除掉。</p>
<h3 id="权限申请源码流程总结"><a href="#权限申请源码流程总结" class="headerlink" title="权限申请源码流程总结:"></a>权限申请源码流程总结:</h3><p>第一步：MainActivity 调用 requestPermissions 进行动态权限申请；<br>第二步：requestPermissions函数通过隐式意图，激活PackageInstaller的GrantPermissionsActivity界面，让用户选择是否授权；<br>第三步：经过PKMS把相关信息传递给PermissionManagerService处理；<br>第四步：PermissionManagerService处理结束后回调给—-&gt;PKMS中的onPermissionGranted方法把处理结果返回；<br>第五步：PKMS通知过程中权限变化，并调用writeRuntimePermissionsForUserLPr函数让PackageManager的settings记录下相关授权信息；</p>
<h2 id="手写无侵入式框架"><a href="#手写无侵入式框架" class="headerlink" title="手写无侵入式框架"></a>手写无侵入式框架</h2><p>为什么要写？我短短一个 Activity 代码，申请权限却要写很长很长的权限申请代码。</p>
<p>权限申请</p>
<p>权限被取消</p>
<p>权限被取消，还勾选不再提示</p>
<p>可以用到 AspectJ ，这个后台用到，可以控制注解方法的执行不执行，满足条件执行 A 方法，不满足不执行。这个框架很复杂，是 javac 的二次封装。</p>
<p>这个框架的设计图如下：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%97%A0%E4%BE%B5%E5%85%A5%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt="无侵入框架设计图"></p>
<blockquote>
<p>以后的框架，应该都需要是 ，无侵入式的（由框架劫持用户的行为） AspectJ 劫持函数的执行</p>
<p>AspectJ 为什么可以无侵入式的 监听+劫持 我们的任何注解<br>javac Test.java Test.class (JVM只认识class) （我们看不懂字节码，JVM看得懂）<br>AspectJ(Javac) Test.java 注入代码 Test.class (JVM只认识class) （我们看不懂字节码，JVM看得懂）</p>
<p>空白的Activity（申请权限 申请成功 申请失败 用户拒绝申请 回调给外界 告诉AspectJ）</p>
<p>任何一个框架，都有三种方式实现：<br>1.无侵入式的 由框架监听用户 劫持用户的行为，用户是没有能力调用框架的（依赖AspectJ）<br>2.APT 注解处理器 侵入式的框架，编译期 Dagger2 Room ARouter DataBinding<br>3.传统 xUtils 反射</p>
<p>无侵入式：用户没有能力调用我们的框架，它连看都看不到我们的框架，<br> 是由我们的框架，全局监听用户的行为，劫持用户，控制用户，执行用户</p>
<p>我们框架特点：<br> 我只需要使用三个注解就行了</p>
<p>用户没有能力调用框架的API</p>
<p>用户也不需要传递this</p>
<p>由我们的框架 来 监听用户的 注解的</p>
</blockquote>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>动态申请权限的流程？</p>
<p>有 15 步，应用进程跨系统服务进程 PKMS 通过 PermissionManagerService 检查权限情况，回调回来给 PKMS ，并且通过 Settings 通过 io 操作将权限结果写入 xml 文件中永久保存，除非卸载，才删除这个记录</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/17/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/09-Glide-%E7%AC%AC%E4%BA%8C%E8%8A%82%E8%AF%BE(%E6%9C%80%E6%96%B0Glide4.11%20%E4%B8%BB%E7%BA%BF%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/17/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/09-Glide-%E7%AC%AC%E4%BA%8C%E8%8A%82%E8%AF%BE(%E6%9C%80%E6%96%B0Glide4.11%20%E4%B8%BB%E7%BA%BF%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90)/" class="post-title-link" itemprop="url">09-Glide-第二节课(最新Glide4.11 主线流程分析)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-17 21:29:00" itemprop="dateCreated datePublished" datetime="2023-06-17T21:29:00+08:00">2023-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:59:10" itemprop="dateModified" datetime="2023-06-28T22:59:10+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>看源码最重要的 第一步，只管主线，简单走通，不要管支线</p>
<p>面试题：项目中已经大量使用 Glide ，但加载图片还是偶尔会出现内存溢出问题，说明大概原因。</p>
<p>答：可能在 Glide.with 的时候，传入了 Application 的作用域，或者从子线程使用了 Glide 也会导致变为 Application 作用域。在这种作用域下，不会创建空白 Fragment 对绑定页面进行生命周期管理。就会造成内存回收不及时的问题。</p>
<p>into 方法的时候，RequestBuilder 中会根据 ImageView 的 ScaleType 来生成不同的 ScaleType 的对象:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(<span class="meta">@NonNull</span> ImageView view)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!requestOptions.isTransformationSet() &amp;&amp; requestOptions.isTransformationAllowed() &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (view.getScaleType()) {</span><br><span class="line">      <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">      <span class="keyword">case</span> FIT_START:</span><br><span class="line">      <span class="keyword">case</span> FIT_END:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_XY:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER:</span><br><span class="line">      <span class="keyword">case</span> MATRIX:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Do nothing.</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> into(</span><br><span class="line">      glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">      <span class="comment">/*targetListener=*/</span> <span class="keyword">null</span>,</span><br><span class="line">      requestOptions,</span><br><span class="line">      Executors.mainThreadExecutor());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结一下，Glide 中最重要的 3 个分段 with、load、into 的三个作用：</p>
<ul>
<li><p>with：返回 RequestManager ，里面决定是哪种作用域</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(FragemntActivity activity)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(Util.isOnBackgroundThread()) {</span><br><span class="line">        <span class="comment">//子线程，Application </span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">//Activity/Fragment 作用域</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>load：最终返回 RequestBuilder </p>
</li>
<li><p>into ： 最终返回 ImageViewTarget </p>
</li>
</ul>
<p>根据宽高、签名、等等一系列信息，作为某个图片缓存的 key ，在内存缓存和磁盘中获取这些缓存的图片。</p>
<h3 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h3><p>Glide 里面有活动缓存（ActiveResources）和内存缓存（Cache，也叫二级缓存，也叫LRU缓存），他们都在内存里面。那为什么要在内存里面设置 2 级缓存？<strong>Glide 将正在显示的图片都放在活动缓存里面</strong>（活动缓存里面都是使用 WeakReference 来引用图片），然后其他的图片都放在内存缓存里面。这又是什么讲究？内存缓存是 LRUCache 实现的，它可以存储很多图片，假如没有活动缓存这一级，而是直接使用内存缓存的话，那么在缓存的图片数量或者大小超限的时候，正在使用的图片就可能被清除掉，导致崩溃 Bug（比如RecyclerView里面使用，划过来可以，再划回去重新加载的时候被回收了就崩溃了） ，这也是为什么需要设计 2 级缓存。</p>
<blockquote>
<p>当应用需要获取图片的时候，首先从活动缓存中获取，如果没有，则去内存缓存中获取，如果命中了，则将 内存缓存中的图片添加到活动缓存中，并且将图片资源从内存缓存中删除。当引用的页面（Activity/Fragment）关掉之后，活动缓存的图片又可以放入内存缓存中去，如果页面再次打开，就又可能从内存缓存中加载进入活动缓存。活动缓存和内存缓存中只能存在一份缓存，不可能同时在 内存缓存和活动缓存中都存在。活动缓存里面会做引用计数，如果计数为 0 的时候，会将图片放回到内存缓存里面。</p>
</blockquote>
<p>面试官：Glide 源码中到处都是接口，我们应该怎么阅读？</p>
<p>答： 我们要找里面的伏笔。比如，我们 getRequest 的时候，要一直追踪下去，看看到底这个 getRequest 返回的是 Request 的哪个子类。不然很难知道具体是哪个类实现。</p>
<p>面试官：使用 Glide 为什么需要加入网络权限？</p>
<p>答： Glide 中执行图片请求的时候 <strong>有等待队列和运行队列</strong>2个队列，并且有 <strong>活动缓存和内存缓存</strong>2级缓存，如果这2级缓存都没有命中的话，需要通过网络去获取资源。并且，还可以通过 job.get 去判断目前任务是否完成，最终使用 UrlConnection 去完成最终的网络请求。</p>
<p>我们平时使用 Glide 一般都是传入 String 类型的 url ，然后会返回 InputStream 这种流，decode 的作用就是将流转成 Bitmap 。</p>
<p>面试官：使用 Glide 的时候，如果 with 函数在子线程调用，会有什么问题？</p>
<p>答：子线程不会去添加生命周期机制，主线程才会添加空白Fragment 监听 Activity/Fragment 的生命周期变化。</p>
<p>面试官：with 函数传入 Application ，会怎么样？</p>
<p>答：如果传入的是Activity 或者 Fragment ，当它们销毁的时候，Glide 会回收当前页面加载的图片任务和资源，但是如果传入的是 Application ，那么只有当应用结束的时候资源才会跟随销毁了。</p>
<p>如果ImageView 很小，但是图片是个很大的图片，Glide 会给做优化，只会给目标大小的图片就可以了。</p>
<p>最后，以一张Glide 的简化流程图结束：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Glide%E6%95%B4%E4%BD%93%E7%AE%80%E5%8C%96%E5%9B%BE.png" alt="简化的Glide流程图"></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/17/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/09-Glide-%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE(%E6%9C%80%E6%96%B0Glide4.11%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/17/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/09-Glide-%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE(%E6%9C%80%E6%96%B0Glide4.11%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB)/" class="post-title-link" itemprop="url">09-Glide-第一节课(最新Glide4.11源码阅读)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-17 16:09:00" itemprop="dateCreated datePublished" datetime="2023-06-17T16:09:00+08:00">2023-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:55:08" itemprop="dateModified" datetime="2023-06-28T22:55:08+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、为何监听Activity-Fragment-生命周期"><a href="#一、为何监听Activity-Fragment-生命周期" class="headerlink" title="一、为何监听Activity/Fragment 生命周期"></a>一、为何监听Activity/Fragment 生命周期</h2><p>Glide 的使用很简单：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>).load().into(imageView)</span><br></pre></td></tr></tbody></table></figure>

<p>其中的职责很简单：</p>
<ul>
<li><p>with ： 生命周期管理。传入 Activity 或者 Fragment 就会创建一个空白 Fragment 来监听生命周期，传入 Application Context 则不会</p>
</li>
<li><p>load：构建出 RequestBuilder 对象</p>
</li>
<li><p>into ： 做了几件事情：1）运行队列、等待队列 2）活动缓存 3）内存缓存 4）网络模型</p>
</li>
</ul>
<p>面试题：我们使用了 Glide.with(this).load().into 加载图片之后，在 Activity 的 onDestroy 中是不是要调用：<em>Glide.with(this).clear(imageView)</em> 来清理掉不用的 View 呢？</p>
<blockquote>
<p>很多同学可能会回复这是必须的，但是事实上这不是必需的，因为 Glide 内部会有监听机制，在 Activity 的onDestroy 中会自动 clear 掉。</p>
</blockquote>
<h2 id="二、生命周期作用域"><a href="#二、生命周期作用域" class="headerlink" title="二、生命周期作用域"></a>二、生命周期作用域</h2><p>那么 Glide 是怎么做到自动 clear 呢？原理在于<strong>它会创建一个空白的 Fragment 来监控 Activity/Fragment 的生命周期变化</strong>。</p>
<p>你可以发送很多的加载图片的request ，这些统一由 RequestManager 去管理。</p>
<p><strong>如果在子线程使用 Glide 加载图片，即时你传入 Activity ，也是在 Application 作用域，这时候不会给你搞那个空白的 Fragment</strong> 。总结一下各种情况下根据 with 传入的参数而产生的生命周期作用域：</p>
<ul>
<li><p><strong>在子线程</strong>：作用域为 Application</p>
</li>
<li><p>（在主线程）传入 ServiceContext/Application Context： 作用域为 Application</p>
</li>
<li><p>（在主线程）传入View：作用域为 Fragment 或者 Activity</p>
</li>
<li><p>（在主线程）传入 Fragment： 作用域为 Fragment</p>
</li>
<li><p>（在主线程）传入 Activity： 作用域为 Activity</p>
</li>
</ul>
<blockquote>
<p>所以也可以总结说 Application 作用域和非Application 作用域，这是根据是否创建空白 Fragment 监听生命周期这个动作来区分的</p>
</blockquote>
<p>老师说学习开源框架最好的方式就是：先大概看一遍，然后仿照它的 API 开始自己写，把它所有的实现都简化：比如它是工厂模式创建对象，那我就直接 new 出来；假如它有各种判空，直接干掉，假如有复杂的条件判断，先干掉。实现最简单的，这样才能快速理解整个流程。</p>
<p>RequestManager 中，生命周期 onStart 的时候: 运行队列-全部开始执行；等待队列-全部清空；onStop 的时候： 运行队列-全部停止，所有任务添加到等待队列；</p>
<p>Glide 中设计很巧妙的一个点就是：Glide 需要保证一个 Activity 只能有一个空白 Fragment 来监听它的生命周期，那么在 RequestManagerRetriever 这个类中，就会写出看起来匪夷所思的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RequestManagerFragment <span class="title">getRequestManagerFragment</span><span class="params">(FragmentManager fm, Fragment parentHint, <span class="keyword">boolean</span> isParentVisible)</span> </span>{</span><br><span class="line">  RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">  <span class="keyword">if</span> (current == <span class="keyword">null</span>) {</span><br><span class="line">    current = pendingRequestManagerFragments.get(fm);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) {</span><br><span class="line">      current = <span class="keyword">new</span> RequestManagerFragment();</span><br><span class="line">      current.setParentFragmentHint(parentHint);</span><br><span class="line">      <span class="keyword">if</span> (isParentVisible) {</span><br><span class="line">        current.getGlideLifecycle().onStart();</span><br><span class="line">      }</span><br><span class="line">      pendingRequestManagerFragments.put(fm, current);</span><br><span class="line">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">      handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建了这个 fragment 需要将其放入map 中先保存起来，之后再 commit 这个 fragment ；再然后就通过 Handler 移除这个 fragment ，为什么这么做？</p>
<p>这是因为 fragment 做 commit 操作的时候，是通过主线程的 Handler 执行的，最后会体现在handler 往主线程发送了一个 Message，如果这个Message 还没执行，此时来了第二个请求，那么它通过 getTag 去获取这个 Fragment 是获取不到的，那么就会再创建一个，所以这里需要缓存下；那为什么在 commit 之后可以通过（主线程的） Handler 移除缓存的Fragment 呢？那么是因为 ，由于 commit 操作先执行，那么 commit 这个 Message 肯定在后续的移除 fragment 的这个 Message 之后，由于 Handler 是顺序执行这些 Message 的，所以执行移除操作的时候，commit 的那个 message 肯定已经执行过了，所以可以执行！</p>
<p>JetPack 的 Lifecycle 就是 模仿的 Glide 。Glide 的源码太庞大了。</p>
<p>有两个空白 Fragment ，一个是 Androidx 的 Fragment ，一个是 android.app 的 Fragment 。我们要注意区分。</p>
<h2 id="三、生命周期回调"><a href="#三、生命周期回调" class="headerlink" title="三、生命周期回调"></a>三、生命周期回调</h2><p>Fresco 看起来非常舒服，很容易看懂</p>
<p>但是 Glide 可能你看了一周源码，还是找不到网络请求的地方，看懂 Glide 的源码之后，再去看 Fresco 和 Picaso 都是很简单的事情。老师说是要研究半年才能给大家说这个事情。</p>
<p>老师说 RxJava 和 Okhttp 在 Glide 面前是小弟。这个也确实比较复杂</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/16/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/08-Okhttp-%E3%80%90%E4%B8%8B%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/16/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/08-Okhttp-%E3%80%90%E4%B8%8B%E3%80%91/" class="post-title-link" itemprop="url">08-Okhttp-【下】</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-16 16:03:00" itemprop="dateCreated datePublished" datetime="2023-06-16T16:03:00+08:00">2023-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:50:30" itemprop="dateModified" datetime="2023-06-28T22:50:30+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、重试重定向拦截器-重试限制"><a href="#一、重试重定向拦截器-重试限制" class="headerlink" title="一、重试重定向拦截器-重试限制"></a>一、重试重定向拦截器-重试限制</h2><p>首先判断是否取消了，取消了直接抛出异常</p>
<p>之后在 try-catch 代码块里面执行责任链获取 response，并且捕捉 RouteException （路线异常，比如 socket 连接失败）和 IOException （IO 异常），在这 2 种 异常中判断是否需要重试，调用的是 recover 函数：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查是否需要重试</span></span><br><span class="line"><span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) {</span><br><span class="line">    <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">//。。。。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出，检查是否需要重试，如果不需要，直接抛出异常就终止了，否则才继续往后面走重试。那么是否需要重试的条件是什么呢？ 有以下几点：</p>
<ul>
<li><p>OkHttpClient 可以配置是否允许重试，设置为 false 直接不能重试</p>
</li>
<li><p>request body 不允许复用，那就不能重试</p>
</li>
<li><p>产生了 FileNotFoundException 异常，也不用重试了</p>
</li>
<li><p>产生了不允许重试的异常（协议异常-如返回204代表无响应体，但是Content-Lenth 不为0，二者产生冲突，就是协议异常了、证书异常、除连接超时之外的 IO 中断异常）</p>
</li>
<li><p>最后一关，是否有拥有更多路线（设置了代理，DNS 返回了多个 ip -应该重试其他ip），即使上面的判断都通过，只要没有更多路线，都不能重试</p>
</li>
</ul>
<p>重定向限制次数，<strong>20 次</strong></p>
<h2 id="二、重试重定向拦截器-重定向规则"><a href="#二、重试重定向拦截器-重定向规则" class="headerlink" title="二、重试重定向拦截器-重定向规则"></a>二、重试重定向拦截器-重定向规则</h2><p>次数超出 20 次，也抛出异常。</p>
<p>代码中是通过 followUpRequest 方法来确定重定向的，同过 response 的响应码来判断响应码，这个重定向看起来不只是重定向功能，如果只是重定向，可能只需要判断 3xx 这个码就可以了，实际上，这里面判断多个码，包括：</p>
<ul>
<li><p>3xx：重定向</p>
</li>
<li><p>401：服务器需要授权，比如某些接口需要登录</p>
</li>
<li><p>407：代理需要授权，比如付费代理，验证身份</p>
</li>
<li><p>408：请求超时</p>
</li>
<li><p>421：当前客户端所在的ip到服务器的连接数超了</p>
</li>
<li><p>503：服务不可用</p>
</li>
</ul>
<p>个人觉得准备面试的话就记住 3xx、需要授权、连接数超了这几个基本上就可以了</p>
<blockquote>
<p>代理有 2 种，HTTP 代理和 Socket 代理，Http代理代理的是 Http，Socket 代理它代理的是 TCP/IP </p>
</blockquote>
<h2 id="三、桥接拦截器"><a href="#三、桥接拦截器" class="headerlink" title="三、桥接拦截器"></a>三、桥接拦截器</h2><p>桥接拦截器主要功能就是在请求前和请求后做一些通用繁琐处理：</p>
<ul>
<li><p>请求前补全请求头（设置cookie、设置UA、设置Host字段、content-Length 、Content-Type 、Gzip 压缩等）</p>
</li>
<li><p>得到响应后：接收 Cookies 并回调给用户，在下次请求的时候读取相应 cookies 数据设置到请求头；如果有设置 gzip ，则解析 gzip 数据</p>
</li>
</ul>
<h2 id="四、缓存拦截器"><a href="#四、缓存拦截器" class="headerlink" title="四、缓存拦截器"></a>四、缓存拦截器</h2><p>关于缓存的请求头和响应头非常多，所以这里很复杂，Http 的缓存我们可以按照行为分为： <strong>强缓存</strong> 和 <strong>协商缓存</strong>。</p>
<ul>
<li><p>强缓存： 有缓存的时候，直接将缓存给用户，不会发送请求给服务端，可以通过 Cache-Control 和 Expires 来判断缓存过期时间。</p>
</li>
<li><p>协商缓存：请求还是会发给服务端，但是服务端可能会返回 304 （此时没有请求体的），意味着服务端在这段时间没有修改，使用本地的缓存就好。</p>
</li>
</ul>
<p>如果 networkReqeust 存在，则优先发起网络请求，否则使用 cacheResponse 缓存，若都不存在则请求失败。</p>
<h2 id="五、连接拦截器-新建连接"><a href="#五、连接拦截器-新建连接" class="headerlink" title="五、连接拦截器-新建连接"></a>五、连接拦截器-新建连接</h2><p>代码很少，总共就 4 行代码</p>
<p>在这里来判断是 http1 还是 http2。找到连接之后，还需要连接是否健康（未关闭，正常工作），</p>
<p>普通代理：可以想象 Fiddler，它是可以更改你的数据再发送出去的</p>
<p>隧道代理：是无法更改客户端的请求的，将客户端的数据无脑地发送给服务端</p>
<p>Okhttp 支持你创建代理，可以选择是 Http 代理还是 Sockets 代理。老师有写这些代理使用的方式，有现成代码，这里就不贴出来了。</p>
<p>ALPN 是 TLS 的扩展协议，从 与 服务端的 hello 里面可以协商到使用哪一种协议。会存储在 sslSocket 中</p>
<h2 id="六、连接拦截器-连接池"><a href="#六、连接拦截器-连接池" class="headerlink" title="六、连接拦截器-连接池"></a>六、连接拦截器-连接池</h2><p>首先从连接池中获取连接，如果没有，才去做上述的新建连接。</p>
<p>每次put 新的连接到池子里面的时候，都会扔进去一个定时执行的 Task，用于执行 clean 任务，清除不可用的连接，无效的连接。不移走会占用内存。比如，你刚创建的连接，那么5分钟后肯定会过期，如果没有使用的话</p>
<p>连接池最多允许 5 个空闲连接；连接池中闲置的连接最多允许闲置 5 分钟。比如，某个连接 baidu.com 只使用了一次，这样就能将其清理掉。清理的时候，将闲置时长最长的清理掉。 </p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E8%BF%9E%E6%8E%A5%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B.png" alt="连接执行流程"></p>
<h2 id="七、请求服务拦截器与面试总结"><a href="#七、请求服务拦截器与面试总结" class="headerlink" title="七、请求服务拦截器与面试总结"></a>七、请求服务拦截器与面试总结</h2><p>发送很简单，这里就不写了，有个点需要注意下，如果是发送个比较大的文件，是需要与服务端协商的，Okhttp 是这样做的：</p>
<ol>
<li><p>如果服务器允许则返回 100 ，则客户端继续发送请求体</p>
</li>
<li><p>如果服务器不允许就直接返回给用户</p>
</li>
<li><p>如果服务器忽略这个问询的请求头，一直无法读取应答，此时会抛出超时异常</p>
</li>
</ol>
<h3 id="7-1-面试题"><a href="#7-1-面试题" class="headerlink" title="7.1 面试题"></a>7.1 面试题</h3><p>Okhttp 的请求过程</p>
<p>构建 Request ，通过 OkhttpClient 获得 Call （RealCall对象）如果：</p>
<ul>
<li><p>是同步请求，则在发起请求的线程中直接获取结果（调用5个Interceptor）</p>
</li>
<li><p>如果是异步请求，则通过 Dispatcher 分发到线程池中进行请求获取结果（也是调用5个Interceptor）</p>
</li>
</ul>
<p>拦截器如何工作的？</p>
<p>责任链模式将请求者与执行者解耦，请求者只需将请求发送给责任链即可</p>
<p>应用拦截器与网络拦截器的区别？</p>
<ul>
<li><p>他们在 interceptors 中的顺序不一样</p>
</li>
<li><p>网络拦截器不一定执行，因为有可能直接拿了缓存，不需要后续的执行了</p>
</li>
</ul>
<p>Okhttp 如何复用连接？</p>
<p>host 验证规则一样、dns 一样等等，这些属性都一样。当然，也会清理垃圾连接，超过 5 分钟没有使用的连接，超过5个闲置连接后，清理闲置最久的连接</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/15/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/08-Okhttp-%E3%80%90%E4%B8%8A%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/08-Okhttp-%E3%80%90%E4%B8%8A%E3%80%91/" class="post-title-link" itemprop="url">08-Okhttp-【上】</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-15 18:57:00" itemprop="dateCreated datePublished" datetime="2023-06-15T18:57:00+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:49:49" itemprop="dateModified" datetime="2023-06-28T22:49:49+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、Okhttp介绍"><a href="#一、Okhttp介绍" class="headerlink" title="一、Okhttp介绍"></a>一、Okhttp介绍</h2><p>okhttp 4 的源码(4.9.3版本，它的包名还是 okhttp3，还是要注意下)</p>
<p>Retrofit 只是封装 Okhttp ，让其更容易使用</p>
<p>http 2.0 的特性：头部压缩、server push、多路复用</p>
<blockquote>
<p>关于多路复用，其实Http 1.1 也有 keep-alive 这样的标记位来重复使用这条连接，但是这种保持连接只能第一个消息发送完收到 ack 之后，才能发送第二条数据，这种就是串行的；而 http 2.0 可以在第一条还未返回结果的时候就发送第二条，这种才是真正的多路复用。</p>
</blockquote>
<blockquote>
<p>因为 http1.1 用的是文本，必须要按照顺序， hello world，必须要按顺序，但是 http2.0 可以先传 r 再传h再传 d 等，它是基于 fragment 的，fragment 有顺序标识。 </p>
</blockquote>
<p>okhttp 支持 http2.0 可以复用连接，避免每次去连接都要三次握手之类的。Http2 还有个连接池，池子里面有各种连接，比如baidu.com 的连接、taobao.com 的连接，下次需要请求相关域名的时候，直接使用这个池子里面的连接即可。</p>
<p>okhttp 的 post 请求的缓存默认是关闭的，只有 get 请求的缓存开启。如果post 请求想开启缓存，只需要做如下 cache 配置就可以了：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OkhttpClient.Builder().cache(Cache(File(<span class="string">"/xxx"</span>), <span class="number">1024</span>))</span><br></pre></td></tr></tbody></table></figure>

<h2 id="二、Okhttp-的基本使用与请求流程"><a href="#二、Okhttp-的基本使用与请求流程" class="headerlink" title="二、Okhttp 的基本使用与请求流程"></a>二、Okhttp 的基本使用与请求流程</h2><p>Okhttp 的大体流程如下：</p>
<ol>
<li><p>创建一个 OkhttpClient（不管是自己Builder 还是直接new 都可以）</p>
</li>
<li><p>创建一个 Request ，封装请求数据</p>
</li>
<li><p>Request 交给 OkhttpClient  的 newCall 操作得到一个RealCall </p>
</li>
<li><p>之后，不管是通过 execute 还是 enqueue 方法，反正最终是将这个call 交给 Dispatcher 去调度</p>
</li>
<li><p>被调度的时候，经过各种 interceptor 拦截器拦截后，最终可以得到 Response ，流程如下图所示：</p>
</li>
</ol>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Okhttp%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.jpg" alt="Okhttp的执行流程"></p>
<h2 id="三、分发器异步分发限制"><a href="#三、分发器异步分发限制" class="headerlink" title="三、分发器异步分发限制"></a>三、分发器异步分发限制</h2><p>Dispatchers 里面维护了 3 个队列：</p>
<ul>
<li><p>准备执行的异步请求队列</p>
</li>
<li><p>正在执行的异步请求队列</p>
</li>
<li><p>正在执行的同步请求队列</p>
</li>
</ul>
<p>AsyncCall 在 enqueue 的时候，会判断队列里面（不管是准备执行的还是正在执行的）有没有 call 和目前这个 AsyncCall 的host 是一样的，如果是一样的，那就将自己的 callsPerHost 的属性替换成队列中 Call 的 callsPerHost 属性（我个人理解的是，这样方便计数，所有的 Call 都用这一个AtomicInteger 变量来统计数量，这样，后续判断同一个 Host 最多只能5个来同时请求就比较好判断了，只需要取这个值）</p>
<blockquote>
<p>所以， callsPerHost 表示的是同一个host 有多少个请求在执行</p>
</blockquote>
<p>异步总连接不能超过64个，然后 同一个 host 的请求不能超过5个。</p>
<h2 id="四、分发器异步请求分发流程"><a href="#四、分发器异步请求分发流程" class="headerlink" title="四、分发器异步请求分发流程"></a>四、分发器异步请求分发流程</h2><p>如果所有异步请求数超过 64 个 （或者同一个 host 的请求数超过 5个）的情况下，那么 call 将不会被执行，那么他们在什么时候会被触发去执行呢？其实，在 RealCall 里面的 run 方法里面，会在 try-catch 块去获取请求的 response ：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取response 结果</span></span><br><span class="line">response = getResponseWithInterceptorChain()</span><br></pre></td></tr></tbody></table></figure>

<p>在最终的 finally 中，会执行 client.dispatcher.finished(this) ，告知 Dispatcher 当前 Call 已经结束。之后在 Dispatcher 中会再次激活这个等待队列：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> {</span><br><span class="line">    call.callsPerHost.decrementAndGet()</span><br><span class="line">    finished(runningAsyncCalls, call)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出，首先将 callsPerHost 减1 ，意味着这个 host 在执行的请求数减少一个。在里面还会执行重载的 finished 方法，再次去执行 promoteAndExecute 方法去从队列中获取 Call 去分发执行。所以，整个异步任务执行的工作流程如下所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="异步请求执行的流程"></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>Okhttp 异步连接的线程池初始化很有意思：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">           SynchronousQueue(), threadFactory(<span class="string">"<span class="variable">$okHttpName</span> Dispatcher"</span>, <span class="literal">false</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>它指定 corePollSize 为 0，Keep Alive 的时长是 60s ，无界队列，这其实和我们使用 Executors.newCachedThreadPool 是一样的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这种线程池有什么特点呢？</p>
<ul>
<li><p>核心线程数为 0 ：线程池有个例外的情况，哪怕核心线程数设置为 0 ，在第一个任务的时候，还是会开启线程让执行。</p>
</li>
<li><p>最大线程数设置为 Integer.MAX_VALUE ，几乎不限制任务数量</p>
</li>
<li><p>使用 SynchronousQueue 队列提交任务。提交肯定失败！因为它不存储元素的。那既然提交任务肯定失败，那我们为什么还用这个呢？我们考虑下线程池，如果队列有容量的话，在线程数大于等于corePoolSize 的时候，<strong>新的任务会被添加到等待队列</strong>，只有在往 队列中添加失败的时候，才会去判断如果小于 maximumPoolSize 的时候，新建线程任务。所以，这种线程池可以让任务马上执行，而不是在那里等待。</p>
</li>
</ul>
<p>所以上述线程池，如果设置corePoolSize 为 0 ，再设置个 LinkedBlockingQueue 的话，第一个任务会执行，第二个任务会放在 LinkedBlockingQueue 中。1 完成后，执行2,2执行后才能3等等。</p>
<h2 id="五、分发器处理同步请求"><a href="#五、分发器处理同步请求" class="headerlink" title="五、分发器处理同步请求"></a>五、分发器处理同步请求</h2><p>只需要注意，同步请求执行完成后（finnaly 中也是调用 finish），也会去执行 promoteAndExecute 方法，去重新从等待队列中获取 Call 执行任务。有个细节注意，**同步任务执行完成后，会触发异步任务队列的重新获取！</p>
<h2 id="六、Okhttp拦截器责任链设计模式"><a href="#六、Okhttp拦截器责任链设计模式" class="headerlink" title="六、Okhttp拦截器责任链设计模式"></a>六、Okhttp拦截器责任链设计模式</h2><p>Okhttp 里面会有5个默认的拦截器，并且我们也能通过addInterceptor 和 addNetworkInterceptor 方法添加拦截器，代码如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response {</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    <span class="comment">//添加我们通过 addInterceptor 方法添加的拦截器</span></span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) {</span><br><span class="line">        <span class="comment">//添加我们通过 addNetworkInterceptor 添加的拦截器</span></span><br><span class="line">        interceptors += client.networkInterceptors</span><br><span class="line">    }</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line">    <span class="comment">//省略无关代码。。。。。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从代码可以看出，通过 addInterceptor 添加的拦截器会首先被 add 进 interceptors 列表中，之后依次添加充实、桥、缓存、连接 拦截器，然后如果不是 websocket 的话，就添加通过 addNetworkInterceptor 添加的拦截器，最后添加的是 CallServerInterceptor 拦截器。</p>
<blockquote>
<p>所以，addInterceptor 和 addNetworkInterceptor 方法添加拦截器的区别是什么？在代码中的体现是在 interceptors 数组中的位置不一样，一个是在最开始，一个是在倒是第二个。</p>
</blockquote>
<p>但是这个顺序到底会有什么影响？Okhttp 使用责任链设计模式，在发起请求的时候，是从上往下经过这些 Interceptor ，这样就先经过我们 addInterceptor 添加的拦截器，后续才经过 addNetworkInterceptor 添加的拦截器。但是结果返回的时候，是从后面往前面返回的。</p>
<p>老师在课程里面讲了下如果自己去实现责任链的 Demo ，这个可以模拟下。</p>
<h2 id="七、Okhttp-拦截器功能概述"><a href="#七、Okhttp-拦截器功能概述" class="headerlink" title="七、Okhttp 拦截器功能概述"></a>七、Okhttp 拦截器功能概述</h2><p>首先总体概述一下各种拦截器的含义：</p>
<ul>
<li><p>重试定向拦截器。在交给下一个拦截器之前，判断用户是否取消了请求，如果已经取消了，就不需要将结果交回给用户了。并且，在返回结果之后，根据响应码判断是否需要重定向，如果满足条件就会重启执行所有的拦截器。</p>
</li>
<li><p>桥接拦截器。在交出之前，负责将 HTTP 协议必备的请求头加入（比如host 等），并添加一些默认行为（比如 GZIP 压缩），在获得结果后，调用保存cookie 接口并解析GZIP 数据</p>
</li>
<li><p>缓存拦截器。顾名思义就是交出之前读取并判断是否使用缓存；获得结果后判断是否需要缓存</p>
</li>
<li><p>连接拦截器。从连接池中寻找一个连接，如果没有则创建一个连接，并获得对应的 Socket 流；在获得结果后不进行额外处理</p>
</li>
<li><p>请求服务拦截器。进行真正的服务器通信，向服务器发送数据，解析读取响应数据。</p>
</li>
</ul>
<h3 id="刨根究底-addInterceptor-和-addNetworkInterceptor"><a href="#刨根究底-addInterceptor-和-addNetworkInterceptor" class="headerlink" title="刨根究底 addInterceptor 和 addNetworkInterceptor"></a>刨根究底 addInterceptor 和 addNetworkInterceptor</h3><p>当我们只是需要在请求参数里面添加字段，比如 sign 字段，或者在 response 里面修改一点数据，那么我们使用 addInterceptor 和 addNetworkInterceptor 都是可以的。</p>
<p>但是如果我们打印日志，使用了 httpLogingInterceptor 这个拦截器，打印请求数据和返回数据，<strong>如果你用 addInterceptor 添加拦截器，那么打印出来的是用户写的请求参数，如果使用的是 addNetworkInterceptor ，那么这个请求参数就还包括 Okhttp 自动补全的一些参数</strong> 。</p>
<h2 id="八、Okhttp-相关的面试题"><a href="#八、Okhttp-相关的面试题" class="headerlink" title="八、Okhttp 相关的面试题"></a>八、Okhttp 相关的面试题</h2><p>1、Okhttp 的分发器是如何工作的？</p>
<p>对于同步请求，只是记录一下；对于异步任务，首先添加到 ready 队列中，然后检查所有请求数小于64，以及同 host 请求数小于 5 是否满足，满足执行并添加到 running 队列中。</p>
<p>应用拦截器和网络拦截器有什么区别？</p>
<p>在 interceptors 中的顺序不同。导致接收到的数据完整性是不一样的。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/15/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/07-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/07-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82/" class="post-title-link" itemprop="url">07-网络编程-第二节</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-15 17:00:00" itemprop="dateCreated datePublished" datetime="2023-06-15T17:00:00+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:44:23" itemprop="dateModified" datetime="2023-06-28T22:44:23+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>省略第一节的 NIO ，后续有时间看</p>
<h2 id="NIO之单线程Reactor模式"><a href="#NIO之单线程Reactor模式" class="headerlink" title="NIO之单线程Reactor模式"></a>NIO之单线程Reactor模式</h2><p>略，后续有时间看</p>
<h2 id="网络编程面试-TCP、UDP与HTTP"><a href="#网络编程面试-TCP、UDP与HTTP" class="headerlink" title="网络编程面试-TCP、UDP与HTTP"></a>网络编程面试-TCP、UDP与HTTP</h2><p>DDoS攻击是啥？SYN 洪水攻击？</p>
<p>利用合理的服务请求，占用服务资源：带宽攻击和联通性攻击。带宽攻击需要控制大量的肉鸡，SYN 洪泛攻击属于 连通性攻击，发送半连接。</p>
<p>哪些应用适用 UDP 实现？</p>
<p>DNS，直播，多播，可以上层应用自己实现可靠性传输（新的 UDT 协议可以了解一下，Http3 用 UDT）比如广域网中计算中心光纤连接通信</p>
<p>如果应用场景中大多数是简短信息，那么适合用udp实现。因为 udp 是基于报文段的，直接对上层的应用数据封装成报文段然后丢在网络中，如果信息量太大，在链路层会被分片，影响传输效率</p>
<p>http 和 https 的区别？</p>
<p>http 80端口，https 是443端口</p>
<p>是否需要证书</p>
<p>scheme 不同，http 和 https</p>
<p>如果让你来设计QQ，网络协议上如何设计？</p>
<ul>
<li><p>登录采用 TCP 协议和 Http 协议：client采用 TCP 向 server 发送信息，Http 协议下载信息。登录后，会有一个 TCP 连接来保持在线状态</p>
</li>
<li><p>好友之间发送消息，主要采用 UDP 协议：利用上层应用层来保证可靠传输，如果发送失败，提示用户发送失败，并可以重新发送。</p>
</li>
<li><p>内网传文件采用 P2P 技术。内网里面可以采用 P2P 技术，不需要服务器中转</p>
</li>
</ul>
<h2 id="TCP粘包的解决"><a href="#TCP粘包的解决" class="headerlink" title="TCP粘包的解决"></a>TCP粘包的解决</h2><p>包可能很小，每次都要发送出去得到确认。可以把这些小包合在一起，发送出去，确认一次就行。解决：</p>
<ol>
<li><p>消息头+消息体，消息头用来描述消息的长度，每次读消息先读消息头</p>
</li>
<li><p>消息定长，每个消息都是一样长</p>
</li>
<li><p>特殊的分隔符，比如 Netty使用回车换行符来区分</p>
</li>
</ol>
<blockquote>
<p>这个比较抽象，老师在视频里面讲了个例子，比如从客户端用 for 语句循环 100 次发送  “james,hello,hahah” 等这些字符串，但是服务端可能说只收到 2 次，因为数据可能粘包，很多数据合在一起发送了，这时候我们没法区分这些次数和数据。如果用 natty 来做的话，会在每次发送后插入 回车换行符，这样，在接收的时候就能根据回车换行符分割。</p>
</blockquote>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>阿里的 FastJson 不建议使用，安全问题比较多</p>
<p>ProtocolBuffer  可读性比较差</p>
<p>老师自己平时用的是 Kyro ，说是只能在 Java 语言中使用</p>
<h2 id="select、poll、epoll-的区别"><a href="#select、poll、epoll-的区别" class="headerlink" title="select、poll、epoll 的区别"></a>select、poll、epoll 的区别</h2><p>是不是每次都选择 epoll 才是最好的呢？不是，在连接少，用户都活跃的情况，select 和 poll 可能效率更高</p>
<h2 id="直接内存、零拷贝"><a href="#直接内存、零拷贝" class="headerlink" title="直接内存、零拷贝"></a>直接内存、零拷贝</h2><h3 id="直接内存比堆内存快在哪里？"><a href="#直接内存比堆内存快在哪里？" class="headerlink" title="直接内存比堆内存快在哪里？"></a>直接内存比堆内存快在哪里？</h3><p>任何语言，你通过socket 发送数据，都需要有一个 缓冲区，先把数据写入缓冲区，之后从缓冲区读取数据到内核发送出去。</p>
<p>如果可以选择，先选直接内存缓冲区，因为直接内存的缓冲区比堆内存的缓冲区肯定是要快的。</p>
<p>那么，为什么会快呢？如果你选择堆上的 Buffer ，那么在发送的时候，还会在直接内存上创建一个 Buffer ，这样一来，首先需要将数据拷贝到堆上的buffer，之后拷贝到 直接内存上的 Buffer ，最后才发送出去；如果是Buffer 直接创建在直接内存上，就没有这个步骤，减少一次拷贝，示意图如下：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E7%9B%B4%E6%8E%A5Buffer%E5%92%8C%E5%A0%86%E4%B8%8ABuffer%E5%8C%BA%E5%88%AB.png" alt="直接buffer和堆上buffer"></p>
<p>为什么使用堆 Buffer 的时候需要使用到直接内存的 Buffer 呢？因为堆上有GC机制，在 Socket 过程中，数据是不能变化的，如果在中途堆上的 Buffer 被GC 了，那咋办？所以只能再开一个直接内存的 Buffer ，这样 GC 管不着。</p>
<p>在新生代的 GC 是不会去管直接内存的 Buffer 的，只有 Full GC 的时候，才会顺便去回收直接内存的。</p>
<p>所以堆外内存（DirectBuffer）的优劣势在哪？</p>
<ul>
<li><p>减少GC 带来的 STW ，增强性能</p>
</li>
<li><p>加快复制速度，如果采用堆内 Buffer 的话，还是需要 DirectBuffer 这个环节，使用 DirectBuffer 可以省略这个步骤</p>
</li>
</ul>
<p>劣势：</p>
<ul>
<li><p>产生内存泄漏很难排查</p>
</li>
<li><p>不适合存储很复杂的对象</p>
</li>
</ul>
<h3 id="有哪几种零拷贝方案？"><a href="#有哪几种零拷贝方案？" class="headerlink" title="有哪几种零拷贝方案？"></a>有哪几种零拷贝方案？</h3><p>linux 中有好几种：</p>
<ul>
<li><p>mmap</p>
</li>
<li><p>linux 的 sendFile 函数，如果有硬件支持的话，只需要告诉缓存的开始位置和大小，都不用真正将数据复制到 socket 的缓冲区，就能将数据发送出去</p>
</li>
<li><p>linux 提供的 splice 方案，不需要硬件支持，使用管道（piple line） 就能将数据直接拷贝到 socket 的缓冲区</p>
</li>
</ul>
<p>不过体现在 JDK 里面就 2 种，一种就是 mmap 方案，还有一种就是NIO 提供的  FIleChannel ，它可以转换为 SocketChannel ，直接将文件通过 socket 发送，这样可以利用 linux 的 mmap 方案做到零拷贝。</p>
<h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><p>时间局部性</p>
<p>在一个方法里面使用到了成员变量，在方法里面可能会用局部变量承接这个成员变量，这样就能加快速度</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">208</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共389.9k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/2/',]
      });
      });
  </script>


</body>
</html>
