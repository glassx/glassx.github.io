<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.gitee.io/page/2/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.gitee.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">30</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">9</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">129</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/09/21/%E4%B9%A6-Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/21/%E4%B9%A6-Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">第12章：封装控件</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-21 22:17:00 / 修改时间：22:18:08" itemprop="dateCreated datePublished" datetime="2021-09-21T22:17:00+08:00">2021-09-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="自定义属性与自定义-Style"><a href="#自定义属性与自定义-Style" class="headerlink" title="自定义属性与自定义 Style"></a>自定义属性与自定义 Style</h2><p>我们一般会自定义一个View，比如 MyCustomView，然后再设置自定义属性：在 res/values 目录下，创建一个 attrs.xml ，在其中编写 declare-styleable ：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"MyCustomView"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"header"</span> <span class="attr">format</span>=<span class="string">"reference"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">flag</span> <span class="attr">name</span>=<span class="string">"child"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">flag</span> <span class="attr">name</span>=<span class="string">"young"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">attr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个过程有2点需要注意：</p>
<ul>
<li>declare-styleable 旁边的name属性，这个属性的取值对应所定义的<strong>类名</strong>。因为我们自定义的类名叫做 MyCustomView ，所以这里的name 取值也是 MyCustomView    </li>
<li>自定义属性值可以组合使用，比如 <attr name="color" format="color|reference"> 表示既可以自定义 color 值（比如#ff0000），也可以利用 @color/xxx 来引用 color.xml 中已有的值    </attr></li>
</ul>
<p>当然，我们有时候也需要使用常量来表示，比如上述的 flag，相当于代码中的常量，比如 young 就表示数字 18。</p>
<h3 id="在xml中使用自定义属性"><a href="#在xml中使用自定义属性" class="headerlink" title="在xml中使用自定义属性"></a>在xml中使用自定义属性</h3><p>要记得以 xmlns 导入自定义的属性集：</p>
<blockquote>
<p>xmlns:attrstest=”<a target="_blank" rel="noopener" href="http://schemas.android.com/apk/res-auto&quot;">http://schemas.android.com/apk/res-auto"</a></p>
</blockquote>
<p>在代码中获取自定义的属性主要使用 <strong>TypedArray</strong></p>
<h3 id="declare-styleable-标签其他属性的用法"><a href="#declare-styleable-标签其他属性的用法" class="headerlink" title="declare-styleable 标签其他属性的用法"></a>declare-styleable 标签其他属性的用法</h3><p>暂略</p>
<h2 id="测量与布局"><a href="#测量与布局" class="headerlink" title="测量与布局"></a>测量与布局</h2><h3 id="ViewGroup-的绘制流程"><a href="#ViewGroup-的绘制流程" class="headerlink" title="ViewGroup 的绘制流程"></a>ViewGroup 的绘制流程</h3><p>View 和ViewGroup 基本相同，只不过ViewGroup 不仅要绘制自己，还要绘制其子控件，而View 只需要绘制自己即可，所以就以 ViewGroup 来讲解。</p>
<p>绘制流程分为 3 个步骤，测量（onMeasure）、布局（onLayout）、绘制（onDraw），需要注意的一点是：onMeasure 用于测量当前控件的大小，为正式布局提供建议（<strong>只是提供建议，至于用不用，需要看 onLayout 函数</strong>）。</p>
<h3 id="onMeasure-函数与-MeasureSpec"><a href="#onMeasure-函数与-MeasureSpec" class="headerlink" title="onMeasure 函数与 MeasureSpec"></a>onMeasure 函数与 MeasureSpec</h3><p>测量过程通过 measure() 函数实现，是 View 树自顶向下的遍历，每个 View 在循环过程中将尺寸细节往下传递，<strong>当测量过程完成后，所有的 View 都存储了自己的尺寸。</strong></p>
<p>并且，布局过程 layout 也是自顶向下实现的，在这个过程中，每个父 View 负责通过计算好的尺寸放置它的子 View。</p>
<h4 id="onMeasure-函数"><a href="#onMeasure-函数" class="headerlink" title="onMeasure 函数"></a>onMeasure 函数</h4><p>该函数有2个int类型的参数 widthMeasureSpec 和 heightMeasureSpec ，这两个参数都是父View传递过来给当前 View 的一个<strong>建议值</strong>。</p>
<h4 id="MeasureSpec-组成"><a href="#MeasureSpec-组成" class="headerlink" title="MeasureSpec 组成"></a>MeasureSpec 组成</h4><p>虽然上述参数是int 类型的，但是它们是由 mode + size 两部分组成的。它们转换成二进制后，<strong>前2位表示模式（mode），后30位表示数值（size）</strong>。模式主要有3种：</p>
<ul>
<li>UNSPECIFIED（mode位：00）：父元素不对子元素施加任何约束，子元素可以得到任意想要的大小    </li>
<li>EXACTLY（mode位：01）：父元素决定子元素的确切大小，子元素将被限定在给定的便捷里而忽略它本身大小</li>
<li>AT_MOST（mode位：10）:子元素至多能达到指定的大小值</li>
</ul>
<p>由以上特性，我们就可以很简单地直到模式和数值的提取：<strong>MODE_MASK，它的二进制表示中，前2位是1，其余30位都是 0，这样，我们只需要将widthMeasureSpec （或 heightMeasureSpec） 位与(&amp;)  MODE_MASK 就可以得到 mode 值，将 他们 &amp; ~MODE_MASK 即可得到数值</strong>。</p>
<h4 id="mode-的用处"><a href="#mode-的用处" class="headerlink" title="mode 的用处"></a>mode 的用处</h4><p>参数 widthMeasureSpec 和 heightMeasureSpec 各自都有对应的mode，而这个mode 来自 XML 定义，简单来说xml 布局和 mode  有如下关系：</p>
<ul>
<li>Wrap_content -&gt; MeasureSpec.AT_MOST</li>
<li>match_parent -&gt; MeasureSpec.EXACTLY</li>
<li>具体值 -&gt; MeasureSpec.EXACTLY</li>
</ul>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.example.FlowLayout</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>比如上述例子中，FlowLayout 在 onMeasure() 函数中传值时，widthMeasureSpec 的mode 是 MeasureSpec.EXACTLY ，即父窗口宽度值；heightMeasureSpec 的mode是 MeasureSpec.AT_MOST ，即值不确定。一定要注意的是：<strong>当模式是 MeasureSpec.EXACTLY 时，就不必设定我们计算的值了，因为这个大小是用户指定的，我们不应该改。但当模式是 MeasureSpec.AT_MOST 时，就需要将大小设定为我们计算的数值，因为用户使用的是 wrap_content，没有设置具体值</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec,<span class="keyword">int</span> heightMeasureSpec)</span> </span>{</span><br><span class="line">  <span class="comment">//假设width 与 height 使我们计算得到控件应该占的宽和高，省略计算过程</span></span><br><span class="line">  <span class="keyword">int</span> width = ...;</span><br><span class="line">  <span class="keyword">int</span> height = ...;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//假设 measureWidth 与 measureHeight 是获取到的后30位的value</span></span><br><span class="line">  <span class="keyword">int</span> measureWidth = ...;</span><br><span class="line">  <span class="keyword">int</span> measureHeight = ...;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在 onMeasure 函数中，最终我们必须要通过 setMeasuredDimension 来设置</span></span><br><span class="line">  setMeasuredDimension((widthMode == MeasureSpec.EXACTLY)?measureWidth: width, (heightMode == MeasureSpec.EXACTLY)? measureHeight: height,)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="onLayout-函数"><a href="#onLayout-函数" class="headerlink" title="onLayout 函数"></a>onLayout 函数</h3><p>前面说了 ，onLayout 实现了所有子View的布局，注意，是<strong>所有子View</strong>。那它自己的布局怎么办？这个后续说。其实 onLayout 是个抽象函数，也就是所有继承 ViewGroup 的类都要自己去实现这个函数，LinearLayout 和 RelativeLayout 都是如此，均重写了。</p>
<h3 id="简单示例-自己加的章节"><a href="#简单示例-自己加的章节" class="headerlink" title="简单示例(自己加的章节)"></a>简单示例(自己加的章节)</h3><p>用一个简单示例说明 onMeasure 与 onLayout 的具体使用，比如要做如下效果图：</p>
<p><img src="/assets/Book-Notes/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/%E7%AE%80%E5%8D%95%E6%95%88%E6%9E%9C.png" alt="简单效果"></p>
<p>这个效果图需要关注2点：（1）、三个TextView 竖直排列  （2）、背景Layout宽度是 match_parent ，高度是 wrap_content 。首先看下布局文件：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.example.myapplication.MyLinLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"#ff00ff"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#ff0000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"第一个VIEW"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#00ff00"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"第二个VIEW"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#0000ff"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"第三个VIEW"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.example.myapplication.MyLinLayout</span>&gt;</span>                   </span><br></pre></td></tr></tbody></table></figure>

<p>自定义的 MyLinLayout 的宽高分别为 match_parent 和 wrap_content。</p>
<h4 id="MyLinLayout-重写-onMeasure-函数"><a href="#MyLinLayout-重写-onMeasure-函数" class="headerlink" title="MyLinLayout 重写 onMeasure() 函数"></a>MyLinLayout 重写 onMeasure() 函数</h4><p>前面提到 <strong>onMeasure 的作用就是根据 container 内部的子控件计算自己的宽和高 ，然后通过 setMeasuredDimension 方法设置进去</strong>。先看看完整的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> measureWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> measureHeight = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">        <span class="comment">//测量子控件</span></span><br><span class="line">        View child = getChildAt(i);</span><br><span class="line">        measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        <span class="comment">//获取子控件的宽高</span></span><br><span class="line">        <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">        <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">        <span class="comment">//得到最大宽度，并且累加高度</span></span><br><span class="line">        height += childHeight;</span><br><span class="line">        width = Math.max(childWidth, width);</span><br><span class="line">        setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth : width, </span><br><span class="line">                (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight : height);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<p>步骤如下：</p>
<ol>
<li>获取从父类传过来的建议宽高，提取mode 和value </li>
<li>测量所有的子 View ，之后就能获取所有子View 的测量宽高</li>
<li>根据所有子View 的宽高，来获得自己的<strong>计算宽高，这个值计算的其实就是自己宽和高都被设置为 wrap_content 情况下的值</strong>，因为 Exactly 的时候，并不建议我们去改value 的。</li>
<li>因为是竖直排列，所以container 的高度应该是各个子View的高度和；宽度应该是各个子View 最大的宽度</li>
<li>最后，根据当前用户设置的mode来判断是否需要将这个计算宽高设置进去，用它来实现当前container 所在的位置</li>
</ol>
<p>由于我们在上面的xml 布局文件中，将 MyLinLayout 的宽度设置为 match_parent ，高度为 wrap_content ，所以在onMeasure 里面，</p>
<p>int measureWidthMode 应该是MeasureSpec.EXACTLY；  measureHeightMode 为 MeasureSpec.AT_MOST，<strong>换句话说，width 使用的是从父类传过来的 measureWidth ，高度是我们自己计算的 height</strong>，即实际情况应该等价于：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setMeasuredDimension(measureWidth, height);</span><br></pre></td></tr></tbody></table></figure>



<h3 id="MyLinLayout-重写-onLayout-函数"><a href="#MyLinLayout-重写-onLayout-函数" class="headerlink" title="MyLinLayout 重写 onLayout 函数"></a>MyLinLayout 重写 onLayout 函数</h3><p>在这一部分是根据自己的医院把 container 内部的各个控件排列起来，先看完整代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">        View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">        <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">        <span class="comment">//设置子View的位置</span></span><br><span class="line">        child.layout(<span class="number">0</span>, top, childWidth, top + childHeight);</span><br><span class="line">        top += childHeight;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码讲完，再讲一个非常容易混淆的问题：</p>
<h4 id="getMeasuredWidth-与-getWidth"><a href="#getMeasuredWidth-与-getWidth" class="headerlink" title="getMeasuredWidth 与 getWidth"></a>getMeasuredWidth 与 getWidth</h4><p>这两个值大部分时候是相同的，但是含义根本不一样，二者区别主要体现在：</p>
<ul>
<li>getMeasuredWidth 函数在 measure 过程结束后就可以获取到宽度值，而getWidth 需要在 layout 完成后才能获取到高度值！</li>
<li>getMeasuredWidth 获取的值是通过 setMeasuredDimension 函数来设置的；而 getWidth 函数值则是通过 layout（left,top,right,bottom） 函数来进行设置的</li>
</ul>
<p>看完两个函数后，我们也明白了 onMeasure 阶段提供的测量结果只是为布局提供建议的，最终要看 onLayout 函数。<strong>因为我们在 child.layout 的时候，直接通过 0 + child.measuredWidth 来计算right 的值，所以我 getMeasuredWidth 与 getWidth 函数返回的值就是一样的了</strong>。</p>
<h4 id="疑问：container-自己什么时候被布局"><a href="#疑问：container-自己什么时候被布局" class="headerlink" title="疑问：container 自己什么时候被布局"></a>疑问：container 自己什么时候被布局</h4><p>这其实要追溯到 View 的 layout 里面：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">  ...省略代码</span><br><span class="line">        <span class="keyword">boolean</span> changed =  setFrame(l, t, r, b);</span><br><span class="line">    ...省略代码</span><br><span class="line">       onLayout(changed, l, t, r, b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>setFrame 设置的是自己的位置，结束后才调用 onLayout 。此时，measure 和 layout 都结束了，但是我们还没考虑 margin。</p>
<h3 id="获取子控件margin"><a href="#获取子控件margin" class="headerlink" title="获取子控件margin"></a>获取子控件margin</h3><p>如果要自定义 ViewGroup 支持子控件的 layout_margin 参数，则自定义的 ViewGroup 类<strong>必须重写 generateLayoutParams() 函数，并且在该函数返回一个 ViewGroup.MarginLayoutParams 派生类对象！</strong></p>
<p>为了验证，我们可以在之前的 MyLinLayout 例子基础上，为 TextView 添加 margin ，但是我们能看到，压根就没有起作用，代码就先略了。这是为什么呢？因为测量和布局都是我们自己实现的，我们在 onLayout() 函数中没有根据 margin 来布局。</p>
<p>需要注意的是，<strong>如果我们在 onLayout() 函数中根据 margin 来布局，那么 onMeasure() 函数中计算 container 的大小时，也要加上 layout_margin 参数，否则导致 container 太小而控件显示不全</strong>。</p>
<h4 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h4><p>之前说的需要重写  generateLayoutParams()  函数，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(LayoutParams p)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MarginLayoutParams(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MarginLayoutParams(getContext(), attrs);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MarginLayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至于为什么要这么写，稍后再讲。</p>
<h4 id="重写-onMeasure-函数"><a href="#重写-onMeasure-函数" class="headerlink" title="重写 onMeasure() 函数"></a>重写 onMeasure() 函数</h4><p>略</p>
<h2 id="实现-FlowLayout-容器"><a href="#实现-FlowLayout-容器" class="headerlink" title="实现 FlowLayout 容器"></a>实现 FlowLayout 容器</h2><p>先略</p>
<p>当measure 完成之后，尺寸才会存到 View 属性中，我们才能获取到 View 的属性</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/09/20/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E9%98%B2%E6%AD%A2jar%E8%A2%AB%E5%8F%8D%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/20/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E9%98%B2%E6%AD%A2jar%E8%A2%AB%E5%8F%8D%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">Java基础-防止jar被反编译</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-20 18:25:00" itemprop="dateCreated datePublished" datetime="2021-09-20T18:25:00+08:00">2021-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-28 16:31:33" itemprop="dateModified" datetime="2021-09-28T16:31:33+08:00">2021-09-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>java作为解释型语言，因其高度抽象的特性导致其很容易被反编译，容易被反编译，自然有防止反编译的措施存在。常见的防反编译的技术有以下几种。</p>
<h3 id="隔离Java程序"><a href="#隔离Java程序" class="headerlink" title="隔离Java程序"></a>隔离Java程序</h3><p>最简单的方法就是让用户不能够访问到 Java Class 程序，这种方法是最根本的方法。具体方法有很多，比如：</p>
<ul>
<li>将关键的Java Class 放在服务端，客户端通过访问接口来获得服务，而不是直接访问 Class 文件，这样黑客就没法反编译 Class 文件。</li>
</ul>
<p>但是有很多应用场景不适合这种保护方式，比如<strong>单机运行的程序</strong> 就无法格力Java 程序。</p>
<h3 id="对-Class-文件进行加密"><a href="#对-Class-文件进行加密" class="headerlink" title="对 Class 文件进行加密"></a>对 Class 文件进行加密</h3><p>为了防止Class 文件被直接反编译，许多开发人员将一些关键的 Class 文件进行加密，例如，<strong>注册码、序列号管理</strong>等相关的类。</p>
<p>在使用这些类之前，程序寿险需要对这些类进行解密，然后再将这些类装在到 JVM 中，<strong>这些类的加密可以由硬件完成，也可以使用软件完成</strong>。</p>
<h3 id="转换成-Native-Code"><a href="#转换成-Native-Code" class="headerlink" title="转换成 Native Code"></a>转换成 Native Code</h3><p>Native Code 往往难以被反编译，开发人员可以选择将整个应用程序转换成 Native Code，也可以选择将关键模块转换为 Native Code。</p>
<p>当然，这么做的同时，<strong>也牺牲了Java 的跨平台特性</strong>。如果仅仅转换关键部分，Java 程序在使用这些模块时，需要使用 JNI 技术调用。</p>
<p>为了保证Native 代码不被修改和替代，通常需要对这些代码<strong>进行数字签名</strong>。在使用前，往往需要先对 Native Code 进行认证。</p>
<h3 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h3><p>代码混淆是对 Class 文件进行重新组织和处理，功能虽然还保证，但是很难被反编译，即使反编译后也非常难懂。</p>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/BTH73KaZKqwX3JL2O1T-PA">如何防止你的java jar被反编译</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/09/19/%E4%B9%A6-Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC2%E7%AB%A0-%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/19/%E4%B9%A6-Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC2%E7%AB%A0-%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">第2章：组件化编程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-19 11:22:00" itemprop="dateCreated datePublished" datetime="2021-09-19T11:22:00+08:00">2021-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-24 17:36:47" itemprop="dateModified" datetime="2021-12-24T17:36:47+08:00">2021-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="信息传递（自己起的，感觉书起的章节很乱）"><a href="#信息传递（自己起的，感觉书起的章节很乱）" class="headerlink" title="信息传递（自己起的，感觉书起的章节很乱）"></a>信息传递（自己起的，感觉书起的章节很乱）</h2><p>Android中提供了很多不同的信息传递方式，本节主要衡量每种传递方式的效率和使用场景。</p>
<p>在最基础的组件化架构中，组件层中的模块是相互独立的，并不存在依赖，没有依赖就没法传递消息，那该如何传递消息呢？我们需要第三方协助，也就是基础层（BaseModule），如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%9F%BA%E7%A1%80%E5%8C%96%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1.png" alt="基础组件化通信"></p>
<p>从图可以看出，<strong>Base module 就是跨越组件化层级通信的关键，也是模块间交流的基础</strong>。</p>
<h3 id="方式1、本地广播"><a href="#方式1、本地广播" class="headerlink" title="方式1、本地广播"></a>方式1、本地广播</h3><p>本地广播与全局广播比较：</p>
<ul>
<li>本地广播只能动态注册，全局广播可以动态和静态注册</li>
<li>本地广播只局限于当前App（严谨说是当前进程），全局广播可以跨进程</li>
<li>本地广播使用Handler 实现，就在当前进程传播，因此效率比全局广播高</li>
</ul>
<p>但是，<strong>在用于组件间通信时，本地广播将一切全交给系统负责了，无法干预传输途中的任何步骤</strong>。</p>
<h3 id="方式2、事件总线"><a href="#方式2、事件总线" class="headerlink" title="方式2、事件总线"></a>方式2、事件总线</h3><p>事件总线主要有 EventBus 和 RxBus。</p>
<p>事件总线通过记录对象、使用监听者模式来通知对象各种事件。工作机制如下图：</p>
<p><img src="/assets/Book-Notes/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E5%B7%A5%E4%BD%9C%E7%A4%BA%E6%84%8F.png" alt="事件总线工作示意"></p>
<p>其中，EventBus 是一款针对Android优化的发布/订阅事件总线，主要功能是替代 Intent、Handler、BroadCast，在Fragment、Activity、Service、线程之间传递消息，<strong>优点是开销小，代码更优雅，发送和接收者解耦；缺点是依附的对象销毁时一定要记得取消订阅，否则由于强引用会导致内存泄漏，并且，每个事件都必须自定义一个事件类，造成事件类太多</strong>。</p>
<blockquote>
<p>注意： EventBus 2.x 使用的是 运行时注解，很大程度上是依赖于反射规则的，采用反射的方式对整个注册的类的所有方法进行扫描来完成注册；而Eventbus 3.x 使用的是 编译时注解，在编译的时候，就会将相应操作编译成 .class 文件，在编译时就进行操作这样运行时的速度就会快很多。</p>
</blockquote>
<p>RxBus 是基于RxJava 衍生而来的，只要引入了 RxJava 和 R小Android 就能很方便地使用 RxBus ，它的实现很有意思，<strong>采用静态内部类的单例，由于内部静态类只会被加载一次，所以实现方式是线程安全的</strong>（可以与volatile + double check 对比着看）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxBus</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Subject bus;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RxBus</span><span class="params">()</span> </span>{</span><br><span class="line">    bus = <span class="keyword">new</span> SerializedSubject&lt;&gt;(PublishSubject.create());</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RxBus <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> RxBusHolder.mInstance;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RxBusHolder</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RxBus mInstance = <span class="keyword">new</span> RxBus();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="组件化事件总线考量"><a href="#组件化事件总线考量" class="headerlink" title="组件化事件总线考量"></a>组件化事件总线考量</h3><p>通信事件都要放到公共的Base模块中，Base模块也需要依赖于事件总线框架，信息组件都都需要放在Base模块中，我们看一下总线传递的流程：</p>
<p><img src="/assets/Book-Notes/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%80%BB%E7%BA%BF%E4%BC%A0%E9%80%92%E6%B5%81%E7%A8%8B.png" alt="总线传递流程"></p>
<p>组件化要求功能模块独立，应该尽量少影响 App module 和 Base module ，其中 Base module 尽量做得通用，不受其他模块影响。而<strong>如果上述事件总线放在 Base module 中，每个模块增删时，都需要添加或者删除Base module 的事件</strong>，而增删事件会让其他代码索引到这些事件的代码时造成错误，这样会破坏组件化设计的规则。</p>
<p>这就是目前组件化通信会遇到的瓶颈。两种比较适合现阶段组件化通信的方式：</p>
<ul>
<li>ModuleBus： 能传递一些基础类型数据，不需要在 Base module 添加额外的类，所以不会影响 Base模块的架构，但也无法动态移除信息接收端代码，而自定义的事件信息模型还是需要添加到 Base module    </li>
<li>组件化架构的 ModularizationArchitecture 库。每个功能模块都需要使用注解建立 Action 时间，每个 Action 完成一个事件动作，没有用到反射，参数通过 HashMap&lt;Stirng,String&gt;传递，无法传递对象    </li>
</ul>
<p>但是，<strong>如果一定要使用 EventBus 或者 RxBus事件总线</strong>，这里提供一种架构方案，最大限度地解耦：</p>
<p><img src="/assets/Book-Notes/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0/EventBus%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E4%BD%BF%E7%94%A8.png" alt="EventBus正确使用使用"></p>
<p>其中xxBus独立为一个module ，Base module 依赖 xxBus 对事件通信的解耦，抽离事件到 xxBus 事件总线模块，以后天啊及事件的Event 的实体都需要在上面创建。</p>
<h2 id="组件间跳转"><a href="#组件间跳转" class="headerlink" title="组件间跳转"></a>组件间跳转</h2><p>在组件化中，两个功能模块是不存在直接依赖的，<strong>其依赖规则是通过 Base module 间接依赖的</strong>。</p>
<p>Activity 跳转，直观的跳转就是startActivity 发送一个包装好的 intent去实现。但是如果Activity 在其他 moudle ，则无法索引到 Activity 类，这时候我们会很自然想到使用 intent 包装隐式 Action 实现。隐式跳转的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1 通过AndroidManifest中声明的action来启动</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"material.com.settings"</span>);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2 包名 + 类名的方式</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClassName(<span class="string">"模块包名"</span>, <span class="string">"Activity路径"</span>);</span><br><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"模块包名"</span>,<span class="string">"Activity路径"</span>));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></tbody></table></figure>



<p>但是第2种方式会产生崩溃，提示Activity并没有在AndroidManifest中注册，可是明明注册了啊？这里真正需要理解的是， setClassName 和 setComponent 函数第一个参数的真正含义，<strong>它们是 App 的包名而不是所在的 module 的包名 ！</strong>这在第1章的时候已经聊过了，<strong>当最终合成 AndroidManifest 后，module的包名压根就不存在了</strong>（<font color="#ff0000">有空需要自己去验证下</font>）。</p>
<p>由于隐式跳转有可能找不到目标Activity 而导致崩溃，所以，我们应该首先判断intent是否能够正常跳转。</p>
<p>此外，还有对安全问题的考虑，因为其他App也能通过隐式的 Intent 来启动 Activity （<strong>隐式跳转是原生的，作用范围是整个Android系统</strong>），为了确保只有自己的 App 能启动组件，需要设置 exported = false。</p>
<h3 id="ARouter-路由跳转"><a href="#ARouter-路由跳转" class="headerlink" title="ARouter 路由跳转"></a>ARouter 路由跳转</h3><p>ARouter 使用 AOP 切面编程可以进行控制跳转的过滤。在 Application 中进行 init 之后，我们就对跳转目标做处理：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="meta">@Route(path="gank_web/1")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>{}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">"gank_web/1"</span>)</span><br><span class="line">  .withString(<span class="string">"url"</span>,url)</span><br><span class="line">  .navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取传递的参数</span></span><br><span class="line">Intent intent = getIntent();</span><br><span class="line">String url = intent.getStringExtra(<span class="string">"url"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>整一个过程还是非常优雅的。</p>
<h3 id="组件化最佳路由"><a href="#组件化最佳路由" class="headerlink" title="组件化最佳路由"></a>组件化最佳路由</h3><p>既然已经存在隐式跳转，为什么我们还要选择路由呢？<strong>在组件化架构中，假如移除一些功能  module 和跳转关系，则跳转无法成功，此时，如果要做一些提示，将迁入更多的判断机制代码。而使用路由机制，可以统一对这些索引不到的 module 页面进行提前拦截和做出提示。</strong></p>
<p>路由除了跳转，另一个重要作用就是拦截，比如可以在跳转前进行登录状态验证，路由表的引入，也不需要在 AndroidManifest 中声明隐式跳转。</p>
<p><strong>路由的选择：</strong>现在开源软件中有不少路由结构，比如： ActivityRouter、天猫统跳协议、ARouter、DeepLinkDispatch、OkDeepLink 等。如果你的项目没有引入 RxJava，那么 ARouter 的介入成本低，是首选；如果接入了，那 OkDeepLink 可以 兼容 RxJava ，可以做考虑。当然，OkDeepLink 会在 Intent 中加入 FLAG_ACTIVITY_NEW_TASK 标识，那么创建每个Activity 都会创建新的任务栈来装载 ！这样无法做到标准的压栈。</p>
<h3 id="空类索引"><a href="#空类索引" class="headerlink" title="空类索引"></a>空类索引</h3><p>如果不想使用第三方路由，可以采用空类索引的方式实现跳转，它的原理就是：<strong>使用空类来欺骗编译。</strong>具体的步骤为（个人理解，不一定对）：</p>
<ol>
<li>在各个 module 编写好，但还没实现跨 module 跳转之前</li>
<li>将所有 module 打包，就会生成 apk 了，只是还暂时不能跳转而已</li>
<li>通过某种手段（人工或者工具）解压 apk ，并读取 AndroidManifest.xml 文件中的四大组件信息，生成一个 jar 包 </li>
<li>这个 jar 包里面的内容是空的四大组件，比如，AndroidManifest 中有个 com.example.ActivityA ，那么在 jar 包中也会声明（同路径、同类名）一个 com.example.ActivityA，并且继承 Activity </li>
<li>之后，将这个 jar 包以 provided 形式（只是引入，不会编译进去）到各个 module 中</li>
<li>此后，各个 module 便可以直接以普通的显式 Intent 来 startActivity 了！</li>
</ol>
<h2 id="动态创建"><a href="#动态创建" class="headerlink" title="动态创建"></a>动态创建</h2><p>动态创建也是为了解耦</p>
<h3 id="动态创建-Fragment"><a href="#动态创建-Fragment" class="headerlink" title="动态创建 Fragment"></a>动态创建 Fragment</h3><p>如果在单Activity + 多Fragment情景中，可以使用动态创建 Fragment （反射的方式），之后添加到 ViewPager 里面，这种方式用于模块间的解耦是非常合适的。因为普通方式使用 Fragment 的话，需要强引用 Fragment，而这些Fragment 可能不在当前使用的 module 中，而且因为ARouter 也支持这种 Fragment 方式，所以直接使用 ARouter 是不错的。当然，由于我们是通过反射方式创建实例的，因此需要防止Fragment所在的 module 被移除之后产生 Exception，并且反射也会消耗性能。</p>
<h3 id="动态配置Application"><a href="#动态配置Application" class="headerlink" title="动态配置Application"></a>动态配置Application</h3><p>前面介绍了 Application 产生的替换原则。如果某些功能模块需要做一些初始化操作，<strong>则只能强引用到主 module 的 Application 中</strong>，是否有方法可以降低耦合呢？</p>
<p><strong>第一种方案：</strong>通过主 module 获取各个 module 的初始化文件，然后通过反射初始化的 Java 文件来调用初始化方法：</p>
<ol>
<li><p>Base module 中定义接口 BaseAppInit，里面有 init() 方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseAppInit</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">init</span><span class="params">(Application app)</span></span></span><br><span class="line"><span class="function">}</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在 module 中使用 BaseAppInit ，实现它：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsInit</span> <span class="keyword">implements</span> <span class="title">BaseAppInit</span> </span>{</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">(Application app)</span> </span>{</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在 PageConfig 中添加配置</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NEWS_INIT = <span class="string">"material.com.news.api.NewsInit"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] initModules = {</span><br><span class="line">  NEWS_INIT</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在主 module 的 Application 中实现初始化方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initModules</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">for</span> (String init: PageConfig.initModules) {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      Class&lt;?&gt; clazz = Class.forName(init);</span><br><span class="line">      BaseAppInit moduleInit = (BaseAppInit)clazz.newInstance();</span><br><span class="line">      moduleInit.init(<span class="keyword">this</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">      e.printStack();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在 Application的 onCreate 中调用 上述的 initModules 方法即可</p>
</li>
</ol>
<p><strong>第二种方案：</strong>在 Base module 中创建 BaseApplication ，之后主 Module 中的 Application 继承 BaseApplication 即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 Base Module 中创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAppLogic</span> </span>{</span><br><span class="line">  <span class="keyword">protected</span> BaseApplication mApplication;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplication</span><span class="params">(BaseApplication application)</span></span>{</span><br><span class="line">    mApplication = application;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>{}</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span> </span>{}</span><br><span class="line">  ...<span class="comment">//其余一些 Application 中重要的回调</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Base Module 中的 BaseApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>{</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>{</span><br><span class="line">    initLogic();</span><br><span class="line">    logicCreate();</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span></span>{</span><br><span class="line">    logicLowMemory();</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//供主module 调用</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">logicCreate</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//供主module 调用</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">logicLowMemory</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>唉，第二次了还是没看懂这个方案，先不写了（<font color="#ff0000">以上内容代码没写完的</font>）。我个人觉得可以参考 ARouter 的思路，给子 module 自定义的 Application 加编译时注解，在编译的时候把这些 Application 找出来，生成新的类，然后就可以反射调用子module的 Application 方法了。</p>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>存储方式主要5种，网络存储、File I/O 、SQLite、ContentProvider、SharedPreference，根据 安全、效率、量级 三个维度去决定使用哪种方式：</p>
<p><img src="/assets/Book-Notes/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%80%83%E8%99%91%E7%BB%B4%E5%BA%A6.png" alt="数据存储考虑维度"></p>
<h3 id="组件化存储"><a href="#组件化存储" class="headerlink" title="组件化存储"></a>组件化存储</h3><p>Android 原生的存储体系是全局的，在组件化开发中，五中原生的存储方式是完全通用的。文中介绍了 greeDAO 这个关系映射的数据库框架，greeDAO 是目前众多ORM（对象关系映射）数据库中最稳定、速度最快、编写体验最好的框架，并且<strong>支持数据加密，RxJava，</strong>它能通过对象的方式去操作关系型数据库，但是它的底层还是 SQLite ，它的原理是将一个实体对象转换成意向数据，然后保存到SQLite。也正因为基于SQLite ，所以不能存储图片这样的大文件。关于数据库在组件化的应用，实体类放在本身的module 是无法传递的，需要放在一个统一的 module 中来管理这些类的产生和引用，其greenDao 需要在 Base module 中引入，编写时注解生成的对象也应该在 Base module 中，这样全部的模块才能引用到这个数据：</p>
<p><img src="/assets/Book-Notes/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E6%9E%B6%E6%9E%84.png" alt="关系型数据库简单架构"></p>
<p>当然，更好的设计，文中也建议与事件总线一样，如下图：</p>
<p><img src="/assets/Book-Notes/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84.png" alt="关系型数据库架构"></p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="组件化权限"><a href="#组件化权限" class="headerlink" title="组件化权限"></a>组件化权限</h3><p>通过查看 AndroidManifest 文件，可以看到各个 module 中的权限申请，最终会被合并到完整 AndroidManifest 中。这时候，我们有两种权限放置方案：</p>
<ol>
<li>将 normal 级别的权限申请都放到 Base module 中，然后在各个 module 中分别申请 dangerous 权限，这样分配的好处在于：<strong>当添加或者移除一个模块时，隐私权限的申请也跟随移除，做到最大限度地解耦</strong></li>
<li>还有人提议，将权限全部转交给每个 module 中，达到最大程度的解耦，这样做的缺点在于：<strong>会增加AndroidManifest 的合并检测的耗时</strong></li>
</ol>
<p>当项目需要适配到 Android 6.0 以上的动态权限申请时，需要在 Base module 中添加自己封装的一套权限申请工具，其他组件层的 module 都能使用这套工具，书中推荐选择 AndPermission 。</p>
<h3 id="动态权限框架"><a href="#动态权限框架" class="headerlink" title="动态权限框架"></a>动态权限框架</h3><p>AndPermission  使用简单，并且最大程度适配国内各大厂商的 ROM。</p>
<h3 id="路由拦截"><a href="#路由拦截" class="headerlink" title="路由拦截"></a>路由拦截</h3><p>当调用其他模块的功能时，就是路由拦截器起作用的时候了，<strong>将路由拦截器和权限申请结合在一起</strong>，前面介绍的 ARouter 是跳转钱是会遍历 Interceptor 的，因此我们可以设置拦截器来实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettingsIntercptor</span> <span class="keyword">implements</span> <span class="title">IInterceptor</span> </span>{</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Postcard postcard, InterceptorCallback callback)</span> </span>{</span><br><span class="line">    <span class="comment">//通过 postcard 中的跳转地址过滤</span></span><br><span class="line">    <span class="keyword">if</span> (postcard.getPath.equals(<span class="string">"/gank_setting/1"</span>)) {</span><br><span class="line">      <span class="comment">//权限申请处理</span></span><br><span class="line">  </span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>在上述过程可能涉及到弹出 Dialog ，那么我们首先要获取当前的 Activity 。我们可以通过在 Base module 中的 BaseApplication 中做 registerActivityLifecycle 来保存栈顶的 Activity，有两种方案：</p>
<ol>
<li>在onCreate 的时候持有这个 Activity ，但是这可能引起内存泄漏</li>
<li><strong>我们在 resume 的时候持有 这个activity ，由于 下一个 Activity 的 resume 肯定比当前 Activity 的 destroy 要先执行</strong>，所以可以肯定静态持有栈顶 Activity 不会导致内存泄漏（细品就知道了）。</li>
</ol>
<h2 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h2><p>在 Application module 中查看 R.java 文件：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">anim</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> abc_fade_in = <span class="number">0x7f050000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> abc_fade_out = <span class="number">0x7f050001</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> abc_fade_from_bottom = <span class="number">0x7f050002</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是，在 Lib module 中查看 R.java 文件：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">anim</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> abc_fade_in = <span class="number">0x7f050000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> abc_fade_out = <span class="number">0x7f050001</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> abc_fade_from_bottom = <span class="number">0x7f050002</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>仔细观察会发现，<strong>在 Lib module 中的静态变量没有被赋予 final 属性</strong>。在第1章提及，各个 module 会生成 aar 文件，并且被引用到 Application  module 中，最终合并成 apk 文件，当各个次级 module 在 Application module 中被解压后，在编译时 R.java 会被重新解压到 build/generated/source/r/debug(release)/包名/R.java 中。</p>
<p><strong>合并后的 R.java 中 的id 属性会被添加 final 修饰符</strong>。（<font color="#ff0000">这是我自己理解的，需要验证</font>）</p>
<h3 id="组件化的静态变量"><a href="#组件化的静态变量" class="headerlink" title="组件化的静态变量"></a>组件化的静态变量</h3><p>在 Lib module 中，R.java 文件没有了 final 关键字会导致什么问题呢？</p>
<p><strong>这就会导致凡是规定必须采用常量的地方都无法直接使用 R.java 中的变量，包括 switch-case  和注解。</strong>为此，我们只能抛弃 switch-case 而只能使用 if-else 来实现，if 里面不需要常量。</p>
<p>（<font color="#ff0000">这个知识点是自己加的</font>&gt;）不同的 module 之间无法保证 R.java 中变量对应的数值不同，但是我们可以保证 R.java 的值不同，为了避免R.java 中资源的冲突，不同的 module 中，我们资源命名最好加前缀加以区分，比如登录module ，资源以 login_ 开头，比如社区module ，资源可以以 comm_ 开头等等。</p>
<h3 id="R2-java-的秘密"><a href="#R2-java-的秘密" class="headerlink" title="R2.java 的秘密"></a>R2.java 的秘密</h3><p>ButterKnife ，一个专注于 Android View 的注入框架，可以大量减少 findviewById 和 setOnClickListener 操作的第三方库。当使用注入View 绑定时：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindView(R2.id.submit)</span></span><br><span class="line"><span class="keyword">public</span> Toolbar mToolbar;</span><br></pre></td></tr></tbody></table></figure>

<p>编译成 class 后，R的值会替换为常量：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindView(2131492966)</span></span><br><span class="line"><span class="keyword">public</span> Toolbar mToolbar;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注解中只能使用常量</strong>，如果不是常量就会报错，那么 ButterKnife 是如何解决的呢？它的原理是使用替换的方法，<strong>将 R.java 文件复制一份，命名为 R2.java ，然后给 R2.java 的变量加上 final 修饰符，在相关的地方直接使用 R2 资源！</strong>这一点，可以从 ButterKnife Gradle 中的 ButterKnifePlugin 源码中找到答案，源码略。最终生成的 R2 与 R 文件在同一个目录。</p>
<p>当然，ButterKnife 中处理后代码还是会用 findViewById ，用的是 R 的，而不是 R2， 但是 onClick 的时候，用的还是 R2，因为我们 view.getId() 返回的是 R 中的id ，而 R2 是 R 的副本，所以是一致的，不会有问题。</p>
<p>值得注意的是，library 使用 R2 的方式时，会出现 library 和 Application 切换 R 文件资源的引用问题，这里全部使用 R2 的方式生成引用资源 id，则不会出现此问题。</p>
<h2 id="资源冲突"><a href="#资源冲突" class="headerlink" title="资源冲突"></a>资源冲突</h2><h3 id="组件化的资源汇合"><a href="#组件化的资源汇合" class="headerlink" title="组件化的资源汇合"></a>组件化的资源汇合</h3><p>全部功能都依赖 Base module ，但是 Application module 最终还是得将功能 module 的 aar 文件汇总后，才能开始编译，那会不会出现多个 Base module 呢，不会，我们可以通过 gradle 命令查看 module 的依赖树：</p>
<blockquote>
<p>./gradlew module_name: dependencies</p>
</blockquote>
<p>则会展示依赖树，有些传递依赖标记了 * ，表示这个依赖被忽略了，因为有其他定级依赖中也依赖了这个传递的依赖。</p>
<h3 id="AndroidManifest-冲突问题"><a href="#AndroidManifest-冲突问题" class="headerlink" title="AndroidManifest 冲突问题"></a>AndroidManifest 冲突问题</h3><p>前面说了，AndroidManifest 中 Application 的 app:name 冲突时，需要使用 “tools:replace=android:name” 声明可替换</p>
<h3 id="包冲突"><a href="#包冲突" class="headerlink" title="包冲突"></a>包冲突</h3><p>包冲突可以先检查依赖报告，用以下命令查看依赖目录树：</p>
<blockquote>
<p>./gradlew module_name: dependencies</p>
</blockquote>
<p>有冲突可以使用 exclude 解决：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'com.facebook.fresco:fresco:0.10.0'</span>) {</span><br><span class="line">  exclude group: <span class="string">'com.android.support'</span>, <span class="keyword">module</span>:<span class="string">'support-v4'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h3 id="资源名冲突"><a href="#资源名冲突" class="headerlink" title="资源名冲突"></a>资源名冲突</h3><p>因为无法保证不同的module 中资源名称不同，<strong>那么Gradle 就会合并相同命名的资源，并且后编译的模块会覆盖之前编译的模块中的资源字段中的内容</strong>。所以，一般在一开始命名的时候，不同的 module 加上不同的前缀即可解决。只能一点可以采用 gradle 命名提示机制，resourcePrefix字段：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android {</span><br><span class="line">    resourcePrefix "组件名_"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="组件化混淆"><a href="#组件化混淆" class="headerlink" title="组件化混淆"></a>组件化混淆</h2><h3 id="混淆基础"><a href="#混淆基础" class="headerlink" title="混淆基础"></a>混淆基础</h3><p>混淆包括了代码压缩，代码混淆以及资源压缩等优化过程。AS 中的 ProGuard 是一个压缩、优化和混淆Java 字节码的工具，可以删除无用类、字段、方法和属性，还可以删除无用注释，最大限度优化字节码文件。</p>
<p>不能混淆的情况有以下：</p>
<ul>
<li>反射中使用的元素</li>
<li>最好不让一些Bean 对象混淆</li>
<li>四大组件要在AndroidManifest中声明，混淆后类名发生改变，因此不要混淆</li>
<li>注解不要混淆，注解一般要用到反射</li>
<li>不能混淆枚举红的 value 和 valueOf ，因为这两个方法是静态添加到代码中运行的，也会被反射使用</li>
<li>JNI 调用 java 的方法，需要通过类名和方法名构成地址形成</li>
<li>java 使用 Native 方法，Native 是C/C++ 编写的，方法是无法一同混淆的</li>
<li>JS 调用 java的方法（-keepattributes *JavascriptInterface*） </li>
<li>webview中 Javascript 的调用方法不能混淆</li>
<li>第三方库建议使用自身混淆规则</li>
<li>Parcelable 的子类和 Creator 的静态成员变量不混淆</li>
</ul>
<h3 id="资源混淆"><a href="#资源混淆" class="headerlink" title="资源混淆"></a>资源混淆</h3><p>proguard 可以混淆代码，其实资源名也是能混淆的，混淆后变为 R.string.a 之类的，它有3种方案：</p>
<p><img src="/assets/Book-Notes/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E8%B5%84%E6%BA%90%E6%B7%B7%E6%B7%86%E6%96%B9%E6%A1%88.png" alt="资源混淆方案"></p>
<p>书中推荐使用 微信的 AndResGuard 混淆机制，它的工作流程如下：</p>
<p><img src="/assets/Book-Notes/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0/AndResGuard%E6%B7%B7%E6%B7%86%E6%B5%81%E7%A8%8B.png" alt="资源混淆方案"></p>
<h3 id="组件化混淆-1"><a href="#组件化混淆-1" class="headerlink" title="组件化混淆"></a>组件化混淆</h3><p>重点是保证只混淆一次：</p>
<ul>
<li><p>第一种方案：只在 Application module 中设置混淆，其他module 都关闭混淆，所有的规则都放在 Application 的module 中</p>
<blockquote>
<p>缺点：当某些模块移除之后，需要手动移除混淆规则，虽然理论上混淆规则多了不会崩溃或者编译不过，但是会对编译效率造成影响</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>第二种方案：命令将 所有的 module 中的 proguard-rule.pro 文件合成，然后覆盖 Application module 中的混淆文件</p>
<blockquote>
<p>有合成操作，也会影响编译效率</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>第三种方案： 将 proguard-rule.pro 文件打进 aar</p>
<p>Library module 自身拥有将 proguard-rule.pro 文件打包到 aar 中的设置，如添加一个 consumerProguardFiles 属性：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig {</span><br><span class="line">  consumerProguardFiles <span class="string">'proguard-fules.pro'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



</li>
</ul>
<p>开源库中可以依赖此标志来指定库的混淆方式，consumerProguardFiles 属性会将 *.pro 文件打包进aar ，混淆时会自动使用次混淆配置文件。不过，以 consumerProguardFiles 形式添加 混淆文件具有以下特性：</p>
<ol>
<li>proguard.txt 文件会在aar文件中</li>
<li>proguard 配置会在混淆时使用    </li>
<li>此配置只针对aar</li>
<li>此配置只针对 库文件有效，对应用程序无效</li>
</ol>
<p>当 Application module 将全部代码汇总混淆的时候， Library module 会被打包为 release.aar ，然后被引用汇总，通过 proguard.txt 规则各自混淆，保证只混淆一次。</p>
<p>第三种方案可以最大限度地解耦混淆解耦工作。</p>
<h2 id="多渠道打包"><a href="#多渠道打包" class="headerlink" title="多渠道打包"></a>多渠道打包</h2><p>可以使用几种方式打渠道包：</p>
<ul>
<li><p>使用Python 打包，推荐 AndroidMultiChannelBuildTool</p>
</li>
<li><p>美团批量打包工具 Walle </p>
<blockquote>
<p>其原理是修改 V2 内容区，V2签名以一组 ID-value 的形式保存在这个区块中，可以自定义一组 ID-value 并写入到这个区域</p>
</blockquote>
</li>
<li><p>在apk文件后面添加 zip comment，推荐 packer-ng-plugin，它也提供了python 和 gradle 两种打包方式</p>
<blockquote>
<p>Apk 的本质是一个带签名信息的 zip 文件，符合zip文件的格式规范，不过 V2会校验包实际大小了，因此不能添加 comment 了</p>
</blockquote>
</li>
<li><p>使用官方的方式打包</p>
<p>重点说下官方打包，包含有几个步骤：</p>
<ol>
<li><p>在 AndroidManifest 文件中假如渠道区分标识，写入一个 meta 标签</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data android:name=<span class="string">"channel"</span> android:value=<span class="string">"${channel}"</span>/&gt;</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>在App目录的build.gradle 中配置 productFlavors</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">productFlavors {</span><br><span class="line">    qihu360{}</span><br><span class="line">    baidu {}</span><br><span class="line">    //...省略其他渠道</span><br><span class="line">    </span><br><span class="line">    productFlavors.all {</span><br><span class="line">        flavor -&gt; flavor.manifestPlaceholders = [channel: name]</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
<ol start="3">
<li><p>在 AS 的 Build -&gt; Generate signed apk 中选择设置渠道</p>
<blockquote>
<p>当然如果要一次性打出全部的渠道，只需要 执行 .gradlew build 即可，就可以打出所有的 Release 和 Debug 包</p>
</blockquote>
</li>
</ol>
<h2 id="多渠道模块设置"><a href="#多渠道模块设置" class="headerlink" title="多渠道模块设置"></a>多渠道模块设置</h2><p>有个时候，我们的App可能要打包成 管理员端、普通用户端 ，等等此类需求是比较棘手的，不同的版本依赖的module不一样，这时候怎么弄呢？我们可以使用原生的 Gradle 来配置构建，下面演示一个用户版本和管理版本：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//下面的代码都在根目录的 build.gradle 中</span><br><span class="line"></span><br><span class="line">productFlavors {</span><br><span class="line">   //用户版</span><br><span class="line">   client {</span><br><span class="line">       manifestPlaceholders = [</span><br><span class="line">           channel: "10086", //渠道号</span><br><span class="line">           verNum: "1", //版本号</span><br><span class="line">           app_name: "Gank" //App名</span><br><span class="line">       ]</span><br><span class="line">   }</span><br><span class="line">   </span><br><span class="line">   //服务版</span><br><span class="line">   server {</span><br><span class="line">       manifestPlaceholders = [</span><br><span class="line">           channel: "10087", //渠道号</span><br><span class="line">           verNum: "1", //版本号</span><br><span class="line">           app_name: "Gank服务版" //App名</span><br><span class="line">       ]</span><br><span class="line">   }   </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">dependencies {</span><br><span class="line">    clientCompile project(':settings') //引入客户版特定module</span><br><span class="line">    clientCompile project(':submit')//我怀疑书上打错了，应该这里只是 compile 吧？是客户版与服务版公用的？</span><br><span class="line">    serverCompile project(':server_settings') //引入服务版特定module</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>上面通过 productFlavors 属性设置多渠道，而 manifestPlaceholders 设置不同渠道中的不同属性，<strong>这些属性需要在 AndroidManifest 中声明才能使用</strong>。<strong>在 dependencies 中通过设置 xxxCompile 来配置不同渠道需要引用的 module 文件。</strong>接下来，我们要在 App module 的 AndroidManifest 文件中声明：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">    android:allowBackup="true"</span><br><span class="line">    &lt;!--app引用名--&gt;</span><br><span class="line">    android:label="${app_name}"</span><br><span class="line">    &lt;!--标记可替代--&gt;</span><br><span class="line">    tools:replace="label"&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--版本号声明--&gt;</span><br><span class="line">    &lt;meta-data android:name="verNum" android:value="${verNum}"/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--渠道号声明--&gt;</span><br><span class="line">    &lt;meta-data android:name="channel" android:value="${channel}"/&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></tbody></table></figure>



<p>其中，android:label 属性用于更改签名，${xxx} 会自动引用 manifestPlaceholders 对应的 key 值， tools:replace 属性在以前的 Application 替代中提到，最后替换的属性名需要添加 tools:replace ，这里提示编译器需要替换的 label 属性。</p>
<p>声明 meta-data 用于某些额外自定义的属性，这些属性都可以通过代码读取：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//获取metadata的方法，当然，要防止异常，这里省略了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getMetaData</span><span class="params">(Context context, String metaName)</span></span>{</span><br><span class="line">  String pkgName = context.getPackageName();</span><br><span class="line">  ApplicationInfo appInfo = context.getPackageManager().getApplicationInfo(pkgName, PackageManager.GET_META_DATA);</span><br><span class="line">  Object obj = appInfo.metaData.get(metaName);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取  channel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChannelNum</span> <span class="params">(Context context)</span></span>{</span><br><span class="line">  Object obj = getMetaData(context);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)obj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//之后，在路由跳转的时候，可以根据 channel 来做跳转拦截，代码略</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p>以上shi值调用，至于需要某个类调用，则可以直接将路径以值的形式来传递（同样在meta-data中），然后解析处meta-data，最后用反射方式就能完成对象的创建，之后就能调用了，代码就略了。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/09/19/%E4%B9%A6-Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC1%E7%AB%A0-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/19/%E4%B9%A6-Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC1%E7%AB%A0-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">第1章：组件化基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-19 09:29:00" itemprop="dateCreated datePublished" datetime="2021-09-19T09:29:00+08:00">2021-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 16:26:27" itemprop="dateModified" datetime="2021-12-22T16:26:27+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="你知道组件化吗"><a href="#你知道组件化吗" class="headerlink" title="你知道组件化吗"></a>你知道组件化吗</h2><p>在项目开发中，一般将公用的代码提取出来用于制作基础库 Base Module ，将某些单独的功能封装到 Library module 中，根据业务来划分 module，组内每个人分别开发各自的模块，如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E9%A1%B9%E7%9B%AE%E5%8E%9F%E5%A7%8B%E6%9E%B6%E6%9E%84.png" alt="项目原始架构"></p>
<p>但是，随着时间推移，扩展了一些业务模块之后，模块间互相调用的情况就越来越多，结构可能就会很混乱了，并且，耦合可能会非常严重。这时候，新的规划规则出现了，这就是<strong>组件化、模块化 以及 插件化</strong>。</p>
<ul>
<li><strong>组件：</strong>指的是单一功能的组件，如视频组件（VideoSDK）、支付组件（PaySDK）等，<strong>每个组件都能单独抽出来制作成SDK</strong>    </li>
<li><strong>模块：</strong>指的是独立的业务模块，如首页模块（HomeModule）、直播模块（LiveModule）等，模块相对组件来说粒度更大，它可能包含多种不同的组件     </li>
</ul>
<p>组件化和模块化都是为了代码重用和业务解耦，<strong>区别在于模块化是业务导向，组件化是功能导向</strong>。模块化和组件化的缺点在于：旧项目需要重新适配组件化。当项目的越来越大，方法数可能就会超过 65535，此时有两种选择： <strong>MultiDex 分包解决以及 插件化方法解决</strong>。</p>
<h2 id="基础组件化架构"><a href="#基础组件化架构" class="headerlink" title="基础组件化架构"></a>基础组件化架构</h2><p>我们用一个非常基础的组件化架构图来解释组件化基础：</p>
<p><img src="/assets/Book-Notes/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%9F%BA%E7%A1%80%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84.png" alt="基础的组件化架构"></p>
<p>其中，基础层包含一些基础库和对基础库的封装（如图片加载、网络加载、数据存储等）、组件层包含一些简单的业务（如登录、图片浏览等）、应用层用于统筹全部组件，并输出生成App。虽然这个架构简陋，但是已经包含了组件化的内涵。</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>通过Android Studio ，我们有3中基本的依赖，如下代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies {</span><br><span class="line">    compile fileTree(include: ['*.jar，*.aar'], dir: 'libs')</span><br><span class="line">    compile project(':base')</span><br><span class="line">    annotationProcessor 'com.alibba:arouter-compiler:1.1.1'</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这 3 种依赖分别是（我自己给命名的） jar dependency、module依赖、仓库索引依赖。需要注意的是：</p>
<ul>
<li>读入自身目录使用的是 ： fileTree 字段</li>
<li>读入其他资源 module 使用的是： project 字段，而 “:base”中冒号表示文件目录与自己相同层级</li>
</ul>
<h3 id="聚合和解耦"><a href="#聚合和解耦" class="headerlink" title="聚合和解耦"></a>聚合和解耦</h3><p>最好能考虑插拔，不要移除某个业务项目多数模块就不能工作了。<strong>聚合和解耦是项目架构的基础</strong></p>
<h2 id="重新认识-AndroidManifest"><a href="#重新认识-AndroidManifest" class="headerlink" title="重新认识 AndroidManifest"></a>重新认识 AndroidManifest</h2><p>manifest 字面意思就是货单、旅客名单，AndroidManifest 就是 Android 项目的声明配置文件。我们知道，这里面放的是 <strong>Android四大组件以及 自定义的 Application</strong>。</p>
<p>如果项目中有多个 module，每个moudle都配有一份 manifest ，那么最终生成一个 App 时只会存在一个 AndroidManifest，因为这些 Androidmanifest 会合并，解决冲突后成一份。我们能在： app/build/intermediates/manifests/full/debug/Androidmanifest.xml 中找到这个最终合成的 AndroidManifest 文件。<strong>intermediates 目录是用来包含 App 生成过程中产生的“中间文件”</strong>。</p>
<h3 id="AndroidManifest属性汇总"><a href="#AndroidManifest属性汇总" class="headerlink" title="AndroidManifest属性汇总"></a>AndroidManifest属性汇总</h3><p>当编译主 module 时，会将那些功能 module 重新编译，然后将成果（aar） 放到主 module 的 intermediates 目录中。</p>
<p><img src="/assets/Book-Notes/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%B6%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0/%E6%88%90%E6%9E%9C%E6%94%BE%E5%85%A5%E4%B8%BBmodule.png" alt="子module成果放入主module"></p>
<p>可以看到，会在 app/build/intermediates/exploded-aar 中引用其最终生成的 aar 文件，<strong>exploded-aar 还包含了其他第三方仓库引用到的库</strong>。</p>
<p>aar 文件解压能看到目录中一般包含 aidl、assets 等资源， classes.jar 是每个module 的真正代码，res包含功能 module 的资源，而每个 module 都有自己的 AndroidManifest ，即使 module 没有四大组件，在 AndroidManifest 中也依然带有 application 标识，甚至还会帮我们补全 use-sdk 信息。</p>
<h3 id="AndroidManifest-属性变更"><a href="#AndroidManifest-属性变更" class="headerlink" title="AndroidManifest 属性变更"></a>AndroidManifest 属性变更</h3><p>module 的 manifest 文件在合入的时候，<strong>最主要的差别在于，activity 声明的时候，name 属性不再是缩进，而是完整地址</strong>，当然了，剩下的其他四大组件也会一样，为什么会这样呢？<strong>因为 AndroidManifest 会引用多个 module 中的文件，需要知道具体路径，不然在编译器打包时招不到具体路径</strong>。如下所示：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在module中写法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--合并后--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"com.example.MainActivity"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>此外，还会补全一些属性，比如 icon 和 theme （如果没有在编写中指定）。权限最终也会被合并。当然也会有 Application 的合并（如果module中也注册了Application 的话）。</p>
<p>多个module中声明的相同权限，最终只会有一份，关于主题的声明，<strong>Activity 的主题都会引用自身module 声明的 主题，不声明当然就是使用默认主题了</strong>，主moudle 中声明 的 theme 将默认为整个 App 的 UI 主题风格。</p>
<h3 id="注册Application"><a href="#注册Application" class="headerlink" title="注册Application"></a>注册Application</h3><ul>
<li></li>
</ul>
<h3 id="关于shareUid（题目自己加的）"><a href="#关于shareUid（题目自己加的）" class="headerlink" title="关于shareUid（题目自己加的）"></a>关于shareUid（题目自己加的）</h3><p>通过声明 <strong>Shared User id</strong>，拥有同一个User id 的多个 App 可以配置成运行正在同一个进程中，所以默认可以互相访问任意数据。需要注意的是 <strong>如果只是在功能module 中声明 shareUid，那么最终并不会被何如最终的 AndroidManifest 中，只有主 module 的声明的 sharedUserId 才会最终打包到 AndroidManifest</strong>。</p>
<h2 id="你所不知道的-Application"><a href="#你所不知道的-Application" class="headerlink" title="你所不知道的 Application"></a>你所不知道的 Application</h2><p>看一下 Application 中比较重要的方法：</p>
<ul>
<li>onTerminate：当终止应用程序时回调，<strong>但是不保证一定调用</strong>，比如，当程序被内核终止以便为其他应用释放空间时，就不会有提醒和这个回调</li>
<li>onLowMemory： 当后台程序已经终止且此时资源还是匮乏时执行该回调，<strong>一般应该在这里释放一些不必要的资源</strong></li>
<li>onConfigurationChanged：配置改变时触发，例如手机屏幕旋转</li>
<li>registerActivityLifecycleCallbacks()  ：用于监听Activity 的生命周期，可以利用方法获取在栈顶的 Activity 对象，用于弹dialog 等   </li>
</ul>
<h3 id="组件化-Application"><a href="#组件化-Application" class="headerlink" title="组件化 Application"></a>组件化 Application</h3><p>这个小节把“注册Application”的内容一起合并进来了。注，这里说的 Application 是指 AndroidManifest 中的。</p>
<p>如果主工程创建一个 Application，Library 里面也声明了，那么在merge 的时候可能会出错，因为如果 Library 中定义了与 主项目 相同的属性（如android:icon 和 android:theme），此时就合并失败，并且<strong>提示可以用 tools:replace=”android:name” 来声明Application 是可被替换的</strong>。例如，我们在 application 标签下添加：</p>
<blockquote>
<p>Tools:replace=”android:icon, android:theme”   (多个属性的话，使用 “,” 分开)</p>
</blockquote>
<p>App 最终只会允许声明一个 Application 到 AndroidManifest 中，如果存在多个 Application 的情况可以参考以下 Application 的替换规则如下：</p>
<ul>
<li>主module有，功能module 没有，那就用主的</li>
<li>其中一个功能module有，主module没有，则用功能module的</li>
<li>如果功能module中有多个Application，那么在解决冲突后，最终载入到<strong>后编译的module中</strong>  </li>
<li>若主module 有，功能module也有，解决冲突后，最后编译的主 module 的 Application 会在 AndroidManifest 里面。</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/09/19/%E9%9D%A2-%E6%80%BB%E7%BB%93/%E8%AE%B0%E4%B8%8D%E7%89%A2%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/19/%E9%9D%A2-%E6%80%BB%E7%BB%93/%E8%AE%B0%E4%B8%8D%E7%89%A2%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">总结-新</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-19 09:09:00 / 修改时间：09:09:23" itemprop="dateCreated datePublished" datetime="2021-09-19T09:09:00+08:00">2021-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%B6%E6%AE%B5/" itemprop="url" rel="index">
                    <span itemprop="name">阶段</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><ul>
<li><p>优化：闪屏、极速版、viewStub、IdleHandler加载Webview、classes.dex只保留App启动所需要的代码、避开峰值，滑动时不加载图片。线程优化-采用线程池、不加载大的sp，监控方式：视频录制</p>
</li>
<li><p>内存泄漏，比如 EventBus没有反注册、Activity被静态持有</p>
</li>
<li><p>衡量指标： 快开慢开比：比如2秒快开比，5秒快开比；90% 用户启动时间。冷启动，从3.5秒左右降低到1秒左右，内存从经常性的 380M 左右降低到 330M 的水平，优化前88%左右,93%的收集数据显示1秒以内打开；主要集中在网络超时、网络无连接两种异常，其中网络超时占了40%左右</p>
</li>
</ul>
<ul>
<li>Serializable 的反序列默认是不会执行构造函数的</li>
</ul>
<ul>
<li>SQLite 默认支持多进程并发操作，它通过文件锁来控制多进程的并发，但是SQLite 的锁粒度并没有非常细，针对的是整个DB文件，简单来说，多进程可以同时获取 SHARED 锁来读取数据，但是只有一个进程可以获取 EXCLUSIVE 锁来写数据库</li>
</ul>
<ul>
<li>网络请求： DNS解析(本地或服务查询)、连接（握手、TLS、慢启动、重定向）、发送数据包（延迟、丢包）、接收（IO、解析）、关闭</li>
</ul>
<ul>
<li>网络性能监控：360的 ArgusAPM插桩技术、以及 TraceNetTrafficMonitor ：使用Aspect 切面功能</li>
</ul>
<ul>
<li>软件绘制使用的是 Skia 库，画笔：Skia或者OpenGL；画纸：Surface；画板：Graphic Buffer</li>
</ul>
<ul>
<li>硬件绘制与软件绘制最核心的区别是<strong>硬件绘制通过GPU完成 Graphic Buffer内容的绘制</strong></li>
</ul>
<ul>
<li>Surface 对应2个Buffer，一个前台的，一个后台的，Surface与Buffer之间通过 匿名共享内存交换数据的。可以采用 Tracer for OpenGL ES 逐帧分析性能</li>
</ul>
<ul>
<li>Android的多渠道打包其中的一种思路就是这样，在 apk 尾巴上追加几个字节，来标记apk的渠道，apk启动时，从apk尾巴上读取这个渠道值。不过，后来google发现了这个漏洞，在新版本系统中，<strong>系统安装apk时，会检查apk实际大小，二者不相等就会报错安装失败</strong>。</li>
</ul>
<ul>
<li>UI渲染用 gfxinfo 监测性能，当然也可以用 Systrace，怎么操作？</li>
</ul>
<ul>
<li>SharedPreference 缺点：跨进程不安全、加载慢（异步加载，可能主线程会等待）、卡顿（onPause会强制写入磁盘）、Json转义</li>
</ul>
<ul>
<li>ContentProvider 的原理：通过 Binder 传输匿名共享内存的文件描述符给数据获取方（Client内部有一个 CursorWindow 对象，发送请求时，把这个CursorWindow 类型对象传过去，这个对象暂时为空，Server 收到请求，搜集数据，填充到这个CursorWindow 对象中，Client 读取内部这个CursorWindow 对象，获取数据）。适合传输大量数据，传小数据不一定划算</li>
</ul>
<ul>
<li>静态代理就是对于每种情形都编写一个Proxy，在调用的时候，使用真实的target的来调用方法；动态代理就是根据系统提供的Proxy.newProxyInstance，它的原理是通过 Method.invok ，避免创建多个Proxy</li>
</ul>
<ul>
<li>动态广播先于静态广播接收到</li>
</ul>
<ul>
<li>assets目录存放的文件，最终还是通过 getResources 去open打开，所以，资源文件都可以归结到 Resource 里面</li>
</ul>
<ul>
<li><font color="#ff0000">资源插件化解决：创建AssertManager对象，调用 addAssertPath 将所有的插件路径都添加进去，之后根据AssetManager对象创建 Resources 和 Theme 对象。 重写 Activity 的 getAsset、getResources 、和 getTheme 方法（第8、15章）。</font></li>
</ul>
<ul>
<li>资源插件化问题解决：修改AAPT以及打包gradle文件，为插件资源指定不同前缀。插件使用宿主的资源，就固定id；宿主通过provider 以 aar形式引入到 插件项目中</li>
</ul>
<ul>
<li>动态广播插件化：动态广播，只需要保证宿主APP能加载到动态广播类就行，所以，无序特别处理</li>
</ul>
<ul>
<li>Service、ContentProvider、广播这些通用方案都是本地站位，因为数量不多</li>
</ul>
<ul>
<li>ACTION_DOWN事件在哪个控件消费了（return true）， 那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。（事件分发机制）</li>
</ul>
<ul>
<li>getX 是获取事件到屏幕的距离；getRawX 是获取事件距离控件顶边的距离</li>
</ul>
<ul>
<li>View的滑动方法： layout、LayoutParams、属性动画、ObjectAnimator、offsetLeftAndRight、scrollTo、scrollBy、Scroller（computeScroll）</li>
</ul>
<ul>
<li>Zygote 启动SystemServer，后者再启动各种服务，比如 AMS、WMS</li>
</ul>
<ul>
<li>React 只关注MVC框架中的View层，为减少直接操作DOM，它使用虚拟DOM来差异化更新 DOM，实现数据单向流动。而传统的HTML 页面更新元素是全量更新</li>
</ul>
<ul>
<li>RN 的UI层变化， 就映射到 虚拟DOM，计算出diff后转成json发送给Native生成页面元素。编写的 RN 代码最终会打包成 main.bundle.js 文件供App 加载，此文件可以存在App本地或者服务器上更新。<font color="#ff0000">我个人的理解是，生成虚拟DOM之后的.js文件发到Android或者ios中，由本地进行差异对比生成json，本地再根据json更改view。</font></li>
</ul>
<ul>
<li>B想从A中获取数据，然后呢，它就mmap 一块内存，这块内存对应到物理内存上，但是Binder驱动在内核空间中也指向一块虚拟内存K，这块内存与B那块内存在物理上是一样的。这时候，只需要A将通过 copy_from_user 将数据复制到 K 中，即完成了数据的一次复制。<font color="#ff0000">同步回去博客</font></li>
</ul>
<ul>
<li>直接内存，NIO ： 在Native 分配堆外内存，在Java对中通过 DirectBuffer 作为引用</li>
</ul>
<ul>
<li>GC Root： 虚拟机栈引用、本地方法栈引用、方法区静态、方法区中常量</li>
</ul>
<ul>
<li>类加载过程： 加载、校验、准备、解析（将常量池的符号引用搞成直接引用）、初始化、使用、卸载</li>
</ul>
<ul>
<li>锁优化：自旋、锁消除、锁粗化、轻量级锁、偏向锁</li>
<li>轻量级锁，使用CAS操作尝试将对象的 MarkWord 改成轻量级锁标志，如果成功，则拥有锁；否则，判断锁是否指向当前线程，如果是，则直接进入。否则，就等待(个人觉得应该是CAS重试)。如果有两个以上线程在争用这个锁，就升级为重量级锁，后面的线程阻塞。      </li>
<li>偏向锁：偏向锁在轻量级锁基础上连 CAS 都不做。在对象第一次被线程获取后，把线程id写在 MarkWord 中(这个当然是CAS操作)，当另一个线程尝试获取的时候，偏向模式就结束(指的是这个CAS操作不做了)，恢复到未锁定或者轻量级锁状态，后续就是轻量级锁规则了       </li>
</ul>
<ul>
<li>拥塞控制方法： 慢启动、拥塞避免（增速慢，不再翻番）、快速恢复（拥塞窗口减半，再做拥塞避免）</li>
</ul>
<ul>
<li>TCP慢可能的原因：握手、捎带确认算法、拥塞控制算法</li>
</ul>
<ul>
<li>数字签名就是加了密的摘要。证书包含的内容： 证书格式、对象名称、对象的公钥、有效期、颁发者、签名算法等</li>
</ul>
<ul>
<li><strong>lateinit 主要用于 var 声明的变量，然而它不能用于基本数据类型，如 Int、Long 等</strong>，我们需要使用Integet这种包装类作为替代</li>
</ul>
<ul>
<li>Data class 的特点是： 默认给写了getter、setter、equals、copy（浅拷贝）、toString 等方法</li>
</ul>
<ul>
<li><strong>Kotlin 中的 Int 类型等同于 int</strong></li>
<li><strong>Kotlin 中的 Int? 等同于 Integer ！</strong></li>
</ul>
<ul>
<li>一般来说，<strong>Kotlin 属于 无栈协程</strong>，它依靠对协程体本身编译生成的状态机的状态流转实现，变量的保存也是通过闭包语法实现</li>
</ul>
<ul>
<li>adb shell -》 run as   -》 cd  /data/data/app_webview，非Root情况下 获取webview的Cookies ，使用 sqlite3打开即可</li>
</ul>
<ul>
<li>MeasureSpec 的含义是：父View传递给当前 View 的一个建议值。UNSPECIFIED 父不约束子，子View可以取任意尺寸。Exactly（match_parent、具体数值）： 父为子指定特定的尺寸，子必须在这个尺寸之内 ；AT_MOST（wrap_content）：父为子指定一个最大的尺寸，子要在这里面</li>
</ul>
<ul>
<li>当子具体数值时：EXACTLY，大小为数值；当子为 match_parent： 为父容器的mode，父的剩余空间；当子为wrap_content: mode 为 AT_MOST ，不超过父容器</li>
</ul>
<ul>
<li>内部拦截手势冲突时，在setOntouchListener 中 disallowParent设置为 true，在合适的时候，再设置为false。</li>
</ul>
<ul>
<li>在WebviewClient 的 shouldInterceptRequest ，自行重新组装 WebResourceResponse</li>
</ul>
<ul>
<li>安全努力：app签名校验、https防抓包、本地广播、sp加密</li>
</ul>
<ul>
<li>自己写AIDL，会生成Stub 接口，在用于数据传递的Service （在主进程）中 自己写 binder实现 Stub 接口，实现其中的方法，在onBind 方法中返回这个 binder 。将数据传给webview：  webview.loadUrl(“javascript:”)</li>
</ul>
<ul>
<li>handler处理流程：<strong>首先判断msg.callback 、其次是Handler的mCallback，最后才是交给 Handler 的 handleMessage 处理</strong></li>
</ul>
<ul>
<li>epoll： 以前是将文件描述符数组发给内核，内核遍历；现在是 内核保存了一份文件描述符，只需要穿进去改动的部分。以前内核轮询来发现是否可以读写，现在是通过异步IO事件唤醒而不是轮询；最后，现在系统是仅将有IO事件的文件描述符返回给用户。</li>
</ul>
<ul>
<li>ViewRootImpl 的 scheduleTraversals ，会往MessageQueue 中插入同步屏障 msg，之后在Vsync的时候，就会发送异步消息。之后在unscheduleTraversals中移除</li>
</ul>
<ul>
<li>ANR： 输入5s，广播：前台10，后台60；服务：前台20，后台200；ContentProvider 的publish 超时 10s </li>
</ul>
<ul>
<li>内存分配流程： 分配-&gt; GC无soft -&gt; 增长到最大 -&gt; GC 有 soft ，增长大最大 -&gt; OOM</li>
</ul>
<ul>
<li>挂堆、标记、放堆、挂起线程、</li>
</ul>
<p>想让消息提前执行？</p>
<p>可重入的原理</p>
<p>启动模式兼容？无论singleTop还是singleTask，再回到这个Activity时，并不会触发它的onCreate，而是会触发它的onNewIntent(其实这里说的bug我并没有明白，等测试后再说)。为此，我们需要在MockClass2 中，拦截onNewIntent方法，把占位 StubActivity 替换回插件Activity，代码如下：</p>
<p>写个自定义容器，在里面横着放子View，当一行放不下一个View的时候，自动换行</p>
<p>RenderThread？</p>
<p><font color="#ff0000">Binder原理？两种签名方式？</font></p>
<p>systrace + 函数插桩怎么操作</p>
<p>HardwarLayout、SoftWareLayout</p>
<p>RN布局常用的方法</p>
<p>Android 中 js 桥的原理</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/09/14/%E9%9D%A2-%E7%9F%A5%E8%AF%86/http3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/14/%E9%9D%A2-%E7%9F%A5%E8%AF%86/http3/" class="post-title-link" itemprop="url">网络-http3</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-14 21:30:00" itemprop="dateCreated datePublished" datetime="2021-09-14T21:30:00+08:00">2021-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-28 16:19:22" itemprop="dateModified" datetime="2021-09-28T16:19:22+08:00">2021-09-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="QUIC-概览"><a href="#QUIC-概览" class="headerlink" title="QUIC 概览"></a>QUIC 概览</h2><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/QUIC%E5%8D%8F%E8%AE%AE.png" alt="QUIC协议预览"></p>
<p>  所以，QUIC 与 http3 啥关系呢？ QUIC 用来替代 TCP、SSL/TLS 的传输协议，在传输层之上还有应用层，如http、ftp、imap 等，理论上这些协议都能运行在 QUIC 之上。<strong>运行在 QUIC 之上的 HTTP 协议被称为 https 。</strong> QUIC的几个重要特性如下面介绍：</p>
<h3 id="1、只要1个RTT建立连接"><a href="#1、只要1个RTT建立连接" class="headerlink" title="1、只要1个RTT建立连接"></a>1、只要1个RTT建立连接</h3><p>  Http2 基于TLS首次建立连接需要 3 个RTT，而 http3 首次建立连接只需要 1 RTT,首次连接后，后续连接只需要 0 RTT。如图：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B.png" alt="QUIC协议预览"></p>
<p>那么，http3 如何做到，且看连接过程：</p>
<ol>
<li>首次连接时，客户端发送 Inchoate Client Hello 给服务端。   </li>
<li>服务端生成 g、p、a，再根据 g、p、a 算出 A，然后将 g、p、A 放到 Server Config 中再发送 Rejection 消息给客户端。    </li>
<li>客户端接收到 g、p、A 后，再自己生成 b ，根据 g、p、b 计算出 B，根据 A、p、b 算出初始秘钥 K ，B 和 K 计算好之后，客户端用 K 加密 http 数据，连同 B 一起发送给服务端     </li>
<li>服务端收到 B 后，根据 a、p、B 生成与客户端相同的秘钥，再用这个秘钥解密收到的 http 数据。为了前向安全，服务端会更新自己的随机数 a 和 公钥，再生成新的密钥 S，然后把公钥、Http 返回的数据通过 Server Hello 发送给客户</li>
<li>客户端收到 Server Hello 后，生成与服务端一致的新秘钥 S ，后面的传输都用 S 加密。     </li>
</ol>
<h3 id="2、连接迁移（QUIC连接不受四元组影响）"><a href="#2、连接迁移（QUIC连接不受四元组影响）" class="headerlink" title="2、连接迁移（QUIC连接不受四元组影响）"></a>2、连接迁移（QUIC连接不受四元组影响）</h3><p>  QUIC 连接不受四元组（源IP、源端口、目的IP、目的端口）影响，道理很简单：<strong>QUIC 不以四元组作为标识，而是使用一个 64 位的随机数，即使 IP 或者端口变化，称之为 Connection ID ，只要 这个 Connection ID 没变化，那么连接依然可以维持连接</strong>。</p>
<p>  而使用TCP的话，切换网络时至少会有一个因素发生变化，当连接发生变化时，如果还使用原来的TCP连接，则会导致连接失败，就得等原来的连接超时后重新建立连接，所以，<strong>我们有时候发现切换到一个新网络时，即使新网络很好，但内容还是要加载很久</strong>。如果实现得好，当检测到网络变化时立刻建立新TCP连接，但这样建立连接还是需要好几百毫秒。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/%E8%BF%9E%E6%8E%A5%E8%BF%81%E7%A7%BB.png" alt="连接迁移"></p>
<h3 id="3、队头阻塞-多路复用"><a href="#3、队头阻塞-多路复用" class="headerlink" title="3、队头阻塞/多路复用"></a>3、队头阻塞/多路复用</h3><p>  TCP 是个面向连接的协议，即发送请求后需要收到 ACK 消息，如果每次请求都要收到上次请求的 ACK 消息后再请求，无疑效率很低。</p>
<p>  后来http1.1 做了改进，允许一个TCP连接同时发送多个请求，在这个背景下，谈谈http1.1的队头阻塞：一个TCP连接同时传输了 10 个请求，其中 1、2、3个请求已经被客户端接收，但是第 4 个请求丢失，那么后面第 5~10 个请求都被阻塞，需要等第 4 个请求处理完毕才能被处理，这样就浪费了带宽。因此，http一般又允许 6 个TCP 连接，这样可以更加充分利用 带宽，但是每个连接中队头阻塞的问题还是存在。</p>
<p>  http2 的多路复用解决了 http1.x 中的队头阻塞问题，它不用等上一个请求的所有数据包传输完毕之后才能下一个请求，http2每个请求被拆分多个 Fragme 通过一条 TCP 连接同时被传输，这样即使一个请求被阻塞，也不影响其他请求，如下所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E7%9A%84%E5%90%8C%E6%97%B6%E4%BC%A0%E8%BE%93.png" alt="连接迁移"></p>
<p>由于http2 还是基于 TCP 的，虽然在上述粒度上已经解决队头阻塞，但TCP 处理数据时有严格的前后顺序，先发送的 Frame 要先被处理，这样，即使发送了 4 个请求，1，3，4 都已经到达，但是只能先处理了 1， 而 3 、 4 到了也不能被处理，这时候整条连接都被阻塞，如图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E7%9A%84%E9%98%BB%E5%A1%9E.png" alt="连接迁移"></p>
<p>不仅如此，http2基于TLS ，TLS协议也存在队头阻塞问题，因为TLS 也是基于 TCP ，它将一堆数据加密，加密完成后又拆分成多个 TCP 包传输，丢了任何一个都不能解密。</p>
<p>  那 QUIC 是如何解决的呢？有2点：</p>
<ul>
<li>QUIC 的传输单元是 Packet，加密单元也是 Packet ，整个加密、传输、解密都是基于 Packet，这样就能避免 TLS 的队头阻塞    </li>
<li>QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间丢失了包，也不会阻塞整条连接。</li>
</ul>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>TCP 的拥塞控制就3个方法： 慢启动、拥塞避免、快速恢复 （博客中应该写错了）</p>
<p>QUIC 可以在应用层修改 拥塞控制策略；而TCP 要修改的话，只能在系统层面，</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP 会对每个TCP 连接进行流量控制，意思是让对方不要发送太快，TCP 主要通过 滑动窗口 来实现这个功能。</p>
<p>QUIC 只需要建立一条连接，这条连接同时传输多条 Stream ，好比一条路，两头分别有仓库，道路中间很多车辆运送物资。QUIC 流量控制有两个级别： 连接级别 和 Stream 级别。就好比纪要控制这条路的总流量，不要一下子很多车辆涌进来，货物来不及处理，也不能一辆车一下子运送很多东西，这样货物也来不及处理。那到底怎么实现呢？它的实现也与滑动窗口类似，接收方会发送 WINDOW_UPDATE frame 告诉发送方你可以再多发送些数据过来。</p>
<blockquote>
<p>以上内容参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/143464334">腾讯技术团队的博客</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/09/14/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/14/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">特别篇：自己的总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-14 19:46:00 / 修改时间：21:39:21" itemprop="dateCreated datePublished" datetime="2021-09-14T19:46:00+08:00">2021-09-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="识别插件的类"><a href="#识别插件的类" class="headerlink" title="识别插件的类"></a>识别插件的类</h2><p>方案：将所有的插件 dex 合并到 宿主中，具体步骤为：</p>
<ol>
<li><p>根据宿主的 ClassLoader，获取宿主的 dexElements 字段</p>
<blockquote>
<p>具体步骤为： 首先反射出 BaseDexClassLoader 的 pathList 字段，它是 DexPathList  类型的；第二步，反射出 DexPathList 的 dexElements 字段，他是个<strong>数组</strong>。</p>
</blockquote>
</li>
<li><p>根据插件的 dexFile ，反射出一个 Element 类型对象，这就是插件 dex</p>
</li>
<li><p>把插件 dex 和 宿主 dexElements 合并成一个新的 dex 数组，替换宿主之前的 dexElements 字段</p>
</li>
</ol>
<h2 id="欺骗系统"><a href="#欺骗系统" class="headerlink" title="欺骗系统"></a>欺骗系统</h2><p>启动时，其实是启动 PlaceHoldActivity ，将真正要启动的 TargetActivity 放在 Intent 的数据里面，主要步骤：</p>
<p>1、Hook 到 ActivityManagerNative （它里面的gDefault，这个字段是个单例），把 TargetActivity 替换为 PlaceHoldActivity    </p>
<p>2、Hook 到 H（Handler） 类的 mCallback 字段，将 PlaceHoldActivity 换成真正的 TargetActivity。或者，如果不想使用这种 Hook，可以在创建Activity （execStartActivity）对象的时候再替换回来</p>
<h2 id="资源使用"><a href="#资源使用" class="headerlink" title="资源使用"></a>资源使用</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol>
<li>通过反射，构建一个 AssetManager 对象 <font color="#CD6889">mAssetManager</font>，之后，反射调用 mAssetManager 的 addAssetPath 方法，将宿主和插件的 dexPath 全部添加进去，这样，这个新的 mAssetManager 拥有宿主以及插件中的所有的资源了。</li>
<li>根据上述的 mAssetManager 构建处一个 Resources 对象 <font color="#CD6889">mResources</font></li>
<li>使用 newTheme 创建一个 Theme 对象 <font color="#CD6889">mTheme</font></li>
<li>在 Activity 中重写 getAssets()、getResources()、getTheme() 方法，分别返回上述的mAssetManager、mResources、mTheme</li>
</ol>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void loadResources(){</span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        AssetManager assetManager= AssetManager.<span class="keyword">class</span>.newInstance();</span><br><span class="line">        Method addAssetPath = assetManager.getClass().getMethod(<span class="string">"addAssetPath"</span>,String.<span class="keyword">class</span>);</span><br><span class="line">        addAssetPath.invoke(assetManager, dexPath);</span><br><span class="line">        mAssetManager = assetManager;</span><br><span class="line">    }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    Resources superResources = <span class="keyword">super</span>.getResources();</span><br><span class="line">    mResources = new Resources(mAssetManager, superResources.getDisplayMetrics(), superResources.getConfiguration());</span><br><span class="line">    mTheme = mResources.newTheme();</span><br><span class="line">    mTheme.setTo(<span class="keyword">super</span>.getTheme());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AssetManager getAssets() {</span><br><span class="line">    <span class="keyword">if</span> (mAssetManager == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getAssets();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> mAssetManager;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resources getResources() {</span><br><span class="line">    <span class="keyword">if</span> (mResources == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getResources();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> mResources;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resources.Theme getTheme() {</span><br><span class="line">    <span class="keyword">if</span> (mTheme == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getTheme();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> mTheme;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>注意一点，由于将所有资源集合在一块，所以资源id可能冲突</strong>，解决方案：修改AAPT命令，将宿主和插件之间的id前缀都区分开，比如宿主的资源id以 0x71 开头，插件1以 0x72，插件2以 0x73  等，避免冲突。</p>
<p><strong>还有</strong>，如果插件需要使用宿主的资源，那么，可以在宿主中将id写死，具体方式为自定义一个public.xml ，在里面写死。然后插件中以 provided 的方式将宿主的aar引入（这样，打包的时候就不会将这个aar打进去），引用资源的时候，直接使用这个写死的id就行。</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--public.xml--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"&gt;</span></span><br><span class="line"><span class="meta">&lt;resources&gt;</span></span><br><span class="line"><span class="meta">    &lt;public type="string" name="welcom" id="0x71050024"/&gt;</span></span><br><span class="line"><span class="meta">&lt;/resources&gt;</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="启动模式（LaunchMode）"><a href="#启动模式（LaunchMode）" class="headerlink" title="启动模式（LaunchMode）"></a>启动模式（LaunchMode）</h2><p>普通使用的都是Standard 模式，如果要解决其他 3 种 LaunchMode 问题，使用的是<strong>占位Activity的思想</strong>，即事先为这3种 LaunchMode 创建很多 PlaceHoldActivity。比如：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SingleInstancePlaceHoldActivity1</span><br><span class="line">SingleInstancePlaceHoldActivity2</span><br><span class="line">SingleInstancePlaceHoldActivity3</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">SingleTaskPlaceHoldActivity1</span><br><span class="line">SingleTaskPlaceHoldActivity2</span><br><span class="line">SingleTaskPlaceHoldActivity3</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">SingleTopPlaceHoldActivity1</span><br><span class="line">SingleTopPlaceHoldActivity2</span><br><span class="line">SingleTopPlaceHoldActivity3</span><br></pre></td></tr></tbody></table></figure>



<p>接下来，从服务器下载一个 Json ，指定插件Activity 要使用哪个 PlaceHoldActivity ，这里所说的 Activity 只包括 LauncherMode 为 SingleTop、SingleTask、SingleInstance 的 Activity。我们无法指定插件 Activity 的 LaunchMode ，但是通过这种指定占位，<strong>当 ActivityA 和 SingleTaskPlaceHoldActivity1 建立对应关系之后，ActivityA 的 LaunchMode 就是 SingleTask 了！</strong></p>
<p>但是这里还有个小bug，无论是SingleTop 还是 SingleTask ，再回到这个Activity时，并不会触发它的 onCreate ，而是触发 它的 onNewIntent 方法！为此，<strong>我们需要在Hook的 Handler.Callback 中拦截 onNewIntent 方法，把占位的 PlaceHoldActivity 替换回插件Activity</strong>： </p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockClass2</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>{</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">    <span class="keyword">switch</span>(msg.what) {</span><br><span class="line">      <span class="keyword">case</span> <span class="number">112</span>:</span><br><span class="line">        handleNewIntent(msg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleNewIntent</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">    Object obj = msg.obj;</span><br><span class="line">    ArrayList intents = (ArrayList)RefInvoke.getFieldObject(obj, <span class="string">"intents"</span>);</span><br><span class="line">    <span class="keyword">for</span>(Object object: intents) {</span><br><span class="line">      Intent raw = (Intent)object;</span><br><span class="line">      Intent target = raw.getParcelableExtra(AMSHookHelper.EXTRA_TARGET_INTENT);</span><br><span class="line">      <span class="keyword">if</span>(target != <span class="keyword">null</span>) {</span><br><span class="line">        raw.setComponent(target.getComponent());</span><br><span class="line">        <span class="keyword">if</span>(target.getExtras() != <span class="keyword">null</span>) {</span><br><span class="line">          raw.putExtras(target.getExtras());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/09/10/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC7%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/10/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC7%E7%AB%A0/" class="post-title-link" itemprop="url">第7章：多态和扩展</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-10 19:29:00 / 修改时间：21:30:53" itemprop="dateCreated datePublished" datetime="2021-09-10T19:29:00+08:00">2021-09-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="多态的不同方式"><a href="#多态的不同方式" class="headerlink" title="多态的不同方式"></a>多态的不同方式</h2><p>当一个子类继承父类的时候，这就是<strong>子类型多态</strong>；另一种熟悉的多态是<strong>参数多态</strong>，泛型就是参数多态常见的形式。</p>
<h3 id="对第三方类扩展"><a href="#对第三方类扩展" class="headerlink" title="对第三方类扩展"></a>对第三方类扩展</h3><p>考虑业务类 ClassA、ClassB是第三方引入的并且<strong>不能修改</strong>，如果我们想要给它们扩展一些方法，比如将对象转换为 Json 字符串，那么利用以前多态技术就会显得麻烦。幸运的是，Kotlin 支持扩展语法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> ClassA.<span class="title">toJson</span><span class="params">()</span></span>: String = {</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>就可以很方便地添加了toJson方法，需要注意的是，<strong>扩展属性和方法的实现运行在ClassA的实例</strong>，他们的定义操作不会修改 ClassA 类本身，所以被扩展的第三方类免于被污染。</p>
<h3 id="特设多态与运算符重载"><a href="#特设多态与运算符重载" class="headerlink" title="特设多态与运算符重载"></a>特设多态与运算符重载</h3><p>除了子类型多态、参数多态外，还有一种灵活的多态——<strong>特设多态</strong>。可能概念不好理解，举个具体的例子，你想定义一个通用的sum方法，也许会这么写：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">sum</span><span class="params">(x: <span class="type">T</span>, y: <span class="type">T</span>)</span></span>: T = x + y</span><br></pre></td></tr></tbody></table></figure>

<p>但编译器会报错，因为某些类型不一定支持加法操作。这时候，我们希望定义一种通用的“加法语义上的操作”，可以定义一个通用的 Summable 接口，然后让需要支持假发操作的类来实现它：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sumable</span>&lt;<span class="type">T</span>&gt; </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">plusThat</span><span class="params">(that: <span class="type">T</span>)</span></span>: T</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Len</span></span>(<span class="keyword">val</span> v: <span class="built_in">Int</span>): Sumable&lt;Len&gt; {</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">plusThat</span><span class="params">(that: <span class="type">Len</span>)</span></span> = Len(<span class="keyword">this</span>.v + that.v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以发现，这并没有什么问题。然而，如果要针对不可修改的第三方类扩展加法操作时，这种方式也会遇到问题。于是，又想到了Kotlin的扩展，针对以上例子，我们完全可以采用扩展的语法来解决问题，此外，Kotlin 原生支持<strong>运算符重载</strong>可以很好解决上述问题：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Area</span></span>(<span class="keyword">val</span> value: <span class="built_in">Double</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Area.<span class="title">plus</span><span class="params">(that: <span class="type">Area</span>)</span></span>: Area {</span><br><span class="line">  <span class="keyword">return</span> Area(<span class="keyword">this</span>.value + that.value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">  println(Area(<span class="number">1.0</span>) + Area(<span class="number">2.0</span>)) <span class="comment">//运行结果： Area(value=3.0)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过 operator 关键字以及Kotlin中<strong>内置可重载的运算符plus</strong>，就实现了功能。operator 的作用是，将一个函数标记为重载一个操作符或者实现一个约定，这里的<strong>plus是Kotlin规定的函数名</strong>。除了plus，我们还可以通过重载减法(minus)、乘法(times)、触发(div)、取余(mod，在kotlin 1.1 版本开始被 rem 替代)。此外，回忆kotlin中常用语法，也是用这种神奇的语言特性实现的，比如：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">in</span> list<span class="comment">// 转换为 list.contains(a)</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="扩展：-为别的类添加方法、属性"><a href="#扩展：-为别的类添加方法、属性" class="headerlink" title="扩展： 为别的类添加方法、属性"></a>扩展： 为别的类添加方法、属性</h2><p>继续深入Kotlin 的特设多态语言特性</p>
<h3 id="扩展与开放封闭原则"><a href="#扩展与开放封闭原则" class="headerlink" title="扩展与开放封闭原则"></a>扩展与开放封闭原则</h3><p>熟悉设计模式的读者知道，在修改现有代码时，我们应该遵循开放封闭原则，对扩展开放，对修改封闭。然而实际并不乐观，比如Android开发，为实现某个需求，引入了第三方库，但是需求发生变动后，当前库无法满足需求，且库的作者没有升级计划。这时候你也许就会考虑对源码修改，这就违背了开放封闭原则。</p>
<p>Java中一种惯常做法是继承第三方类，添加新功能，但是，强行的继承可能违背“里氏替换原则”。更合理的方案，就是通过Kotlin的扩展功能。</p>
<h3 id="使用扩展函数、属性"><a href="#使用扩展函数、属性" class="headerlink" title="使用扩展函数、属性"></a>使用扩展函数、属性</h3><p>扩展函数的声明的关键字是 <type> 。此外，我们需要一个“接收者类型”（通常是类或者接口）来作为它的前缀，以为 MutableList<int>扩展exchange方法为例：</int></type></p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">exchange</span><span class="params">(fromIndex: <span class="type">Int</span>, toIndex: <span class="type">Int</span>)</span></span> {</span><br><span class="line">  <span class="keyword">val</span> temp = <span class="keyword">this</span>[fromIndex]</span><br><span class="line">  <span class="keyword">this</span>[fromIndex] = <span class="keyword">this</span>[toIndex]</span><br><span class="line">  <span class="keyword">this</span>[toIndex] = temp</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>MutableList<t> 是Kotlin标准库中的类，这里作为接收者类型，exchange是扩展函数名。Kotlin的this要比Java的更灵活，这里扩展函数体内的this代表的是<strong>接收者类型的对象</strong>。注意，Kotlin中是严格区分接收者是否可空的，<strong>如果你的函数是可空的，你需要重写一个可空类型的扩展函数</strong>。</t></p>
<h4 id="扩展函数的实现机制"><a href="#扩展函数的实现机制" class="headerlink" title="扩展函数的实现机制"></a>扩展函数的实现机制</h4><p>扩展函数这么方便，会不会对性能造成影响呢？以 MutableList<int>.exchange 为例，对应的Java代码为：</int></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Metadata(</span></span><br><span class="line"><span class="meta">   mv = {1, 5, 1},</span></span><br><span class="line"><span class="meta">   k = 2,</span></span><br><span class="line"><span class="meta">   d1 = {"\u0000\u0012\n\u0000\n\u0002\u0010\u0002\n\u0002\u0010!\n\u0002\u0010\b\n\u0002\b\u0003\u001a \u0010\u0000\u001a\u00020\u0001*\b\u0012\u0004\u0012\u00020\u00030\u00022\u0006\u0010\u0004\u001a\u00020\u00032\u0006\u0010\u0005\u001a\u00020\u0003¨\u0006\u0006"},</span></span><br><span class="line"><span class="meta">   d2 = {"exchange", "", "", "", "fromIndex", "toIndex", "CommoKotlin"}</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KotClassKt</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="meta">@NotNull</span> List $<span class="keyword">this</span>$exchange, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>{</span><br><span class="line">      Intrinsics.checkNotNullParameter($<span class="keyword">this</span>$exchange, <span class="string">"$this$exchange"</span>);</span><br><span class="line">      <span class="keyword">int</span> temp = ((Number)$<span class="keyword">this</span>$exchange.get(fromIndex)).intValue();</span><br><span class="line">      $<span class="keyword">this</span>$exchange.set(fromIndex, $<span class="keyword">this</span>$exchange.get(toIndex));</span><br><span class="line">      $<span class="keyword">this</span>$exchange.set(toIndex, temp);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>结合上述Java代码可以看出，我们可以将扩展函数近似理解为<strong>静态方法</strong>。我们知道静态方法的特点：不依赖类的特定实例，被该类所有的实例共享，并且，用public修饰，本质上也就是个全局方法，所以，<strong>扩展函数不会带来额外的性能消耗</strong>。</p>
<h4 id="扩展函数的作用域"><a href="#扩展函数的作用域" class="headerlink" title="扩展函数的作用域"></a>扩展函数的作用域</h4><p>一般来说，我们习惯将扩展函数直接定义在包内，例如之前的 exchange 例子，我们可以将其放在 com.example.extension包下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.extension</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">exchange</span><span class="params">(fromIndex: <span class="type">Int</span>, toIndex: <span class="type">Int</span>)</span></span> {</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们知道，<strong>在同一个包内是可以直接调用exchange方法的，如果需要在其他包中调用，只需要import即可</strong>，这与Java全局静态方法类似。与此同时，在实际开发中，我们可能会将扩展函数定义在一个 Class 内部统一管理：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extends</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">exchange</span><span class="params">(fromIndex: <span class="type">Int</span>, toIndex: <span class="type">Int</span>)</span></span> {</span><br><span class="line">        <span class="keyword">val</span> temp = <span class="keyword">this</span>[fromIndex]</span><br><span class="line">        <span class="keyword">this</span>[fromIndex] = <span class="keyword">this</span>[toIndex]</span><br><span class="line">        <span class="keyword">this</span>[toIndex] = temp</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但你会发现，之前的exchange方法无法调用了！我们看下它的Java源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Metadata(</span></span><br><span class="line"><span class="meta">   mv = {1, 5, 1},</span></span><br><span class="line"><span class="meta">   k = 1,</span></span><br><span class="line"><span class="meta">   d1 = {"\u0000\u001c\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\b\u0002\n\u0002\u0010\u0002\n\u0002\u0010!\n\u0002\u0010\b\n\u0002\b\u0003\u0018\u00002\u00020\u0001B\u0005¢\u0006\u0002\u0010\u0002J \u0010\u0003\u001a\u00020\u0004*\b\u0012\u0004\u0012\u00020\u00060\u00052\u0006\u0010\u0007\u001a\u00020\u00062\u0006\u0010\b\u001a\u00020\u0006¨\u0006\t"},</span></span><br><span class="line"><span class="meta">   d2 = {"Lcom/glassx/Extends;", "", "()V", "exchange", "", "", "", "fromIndex", "toIndex", "CommoKotlin"}</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Extends</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="meta">@NotNull</span> List $<span class="keyword">this</span>$exchange, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>{</span><br><span class="line">      Intrinsics.checkNotNullParameter($<span class="keyword">this</span>$exchange, <span class="string">"$this$exchange"</span>);</span><br><span class="line">      <span class="keyword">int</span> temp = ((Number)$<span class="keyword">this</span>$exchange.get(fromIndex)).intValue();</span><br><span class="line">      $<span class="keyword">this</span>$exchange.set(fromIndex, $<span class="keyword">this</span>$exchange.get(toIndex));</span><br><span class="line">      $<span class="keyword">this</span>$exchange.set(toIndex, temp);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们才发现exchange方法没有static关键字了，所以，<strong>当扩展方法在一个 Class 内部时，我们只能在该类和该类的子类中调用</strong>。</p>
<h3 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h3><p>与扩展函数一样，我们还能为一个类添加扩展属性，比如为MutableList<int>添加一个判断和是否为偶数的属性：</int></p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> MutableList&lt;<span class="built_in">Int</span>&gt;.sumIsEven: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.sum() % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">list.sumIsEven</span><br></pre></td></tr></tbody></table></figure>

<p>但是，如果你准备给这个属性添加默认值，并且写出如下代码：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> MutableList&lt;<span class="built_in">Int</span>&gt;.sumIsEven: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.sum() % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<p>代码会编译不通过，告知扩展属性不能有初始化器。这是为什么呢？其实，与扩展函数一样，其本质也是对应Java中的静态方法，反编译成Java后，会看到一个 getSumIsEven 的静态方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Metadata(</span></span><br><span class="line"><span class="meta">   mv = {1, 5, 1},</span></span><br><span class="line"><span class="meta">   k = 2,</span></span><br><span class="line"><span class="meta">   d1 = {"\u0000\u0012\n\u0000\n\u0002\u0010\u000b\n\u0002\u0010!\n\u0002\u0010\b\n\u0002\b\u0003\"\u001b\u0010\u0000\u001a\u00020\u0001*\b\u0012\u0004\u0012\u00020\u00030\u00028F¢\u0006\u0006\u001a\u0004\b\u0004\u0010\u0005¨\u0006\u0006"},</span></span><br><span class="line"><span class="meta">   d2 = {"sumIsEven", "", "", "", "getSumIsEven", "(Ljava/util/List;)Z", "CommoKotlin"}</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsKt</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">getSumIsEven</span><span class="params">(<span class="meta">@NotNull</span> List $<span class="keyword">this</span>$sumIsEven)</span> </span>{</span><br><span class="line">      Intrinsics.checkNotNullParameter($<span class="keyword">this</span>$sumIsEven, <span class="string">"$this$sumIsEven"</span>);</span><br><span class="line">      <span class="keyword">return</span> CollectionsKt.sumOfInt((Iterable)$<span class="keyword">this</span>$sumIsEven) % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>由于扩展没有实际地将成员插入类中，因此对扩展属性来说幕后字段是无效的，它们的行为只能由显式提供的 getters 和setters 定义</strong>。</p>
<blockquote>
<p>幕后字段：如果属性中存在访问器使用默认实现，那么Kotlin 会自动提供幕后字段 field ，其仅可用于 getter 和 setter 中。</p>
</blockquote>
<h3 id="扩展的特殊情况"><a href="#扩展的特殊情况" class="headerlink" title="扩展的特殊情况"></a>扩展的特殊情况</h3><h4 id="类似Java的静态扩展函数"><a href="#类似Java的静态扩展函数" class="headerlink" title="类似Java的静态扩展函数"></a>类似Java的静态扩展函数</h4><p>在Kotlin中，如果要声明一个静态的扩展函数，必须要有 伴生对象（companion object）上，所以我们要这样定义带有伴生对象的类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>{</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> {</span><br><span class="line">    <span class="keyword">val</span> age = <span class="number">10</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在已有伴生对象的情况下，如果不想再Son中定义扩展函数，而是在Son的伴生对象上定义，可以这么写：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Son.Companion.<span class="title">foo</span><span class="params">()</span></span> {</span><br><span class="line">  println(<span class="string">"age = <span class="variable">$age</span>"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样在没有Son的实例对象的情况下，也能调用，使用：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">  Son.foo()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="成员方法优先级总是高于扩展函数"><a href="#成员方法优先级总是高于扩展函数" class="headerlink" title="成员方法优先级总是高于扩展函数"></a>成员方法优先级总是高于扩展函数</h4><p>如果扩展函数和现有类的成员方法一样，那么<strong>优先调用成员方法</strong>，这一点好理解，我们不应该更改原有实现。</p>
<h4 id="类的实例与接收者实例"><a href="#类的实例与接收者实例" class="headerlink" title="类的实例与接收者实例"></a>类的实例与接收者实例</h4><p>略，没看清楚表达什么</p>
<h3 id="标准库中的扩展函数：run、let、also、takeIf"><a href="#标准库中的扩展函数：run、let、also、takeIf" class="headerlink" title="标准库中的扩展函数：run、let、also、takeIf"></a>标准库中的扩展函数：run、let、also、takeIf</h3><p>略</p>
<h2 id="Android中扩展的应用"><a href="#Android中扩展的应用" class="headerlink" title="Android中扩展的应用"></a>Android中扩展的应用</h2><p>略</p>
<h2 id="扩展不是万能的"><a href="#扩展不是万能的" class="headerlink" title="扩展不是万能的"></a>扩展不是万能的</h2><p>略</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/09/06/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/06/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">第5章：类型系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-06 20:40:00 / 修改时间：20:41:13" itemprop="dateCreated datePublished" datetime="2021-09-06T20:40:00+08:00">2021-09-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="null引用"><a href="#null引用" class="headerlink" title="null引用"></a>null引用</h2><h3 id="null-做了哪些恶"><a href="#null-做了哪些恶" class="headerlink" title="null 做了哪些恶"></a>null 做了哪些恶</h3><ul>
<li><p>null 存在歧义，一个值为null可以代表很多含义，比如：未初始化、值不合法、值不需要、值不存在    </p>
<blockquote>
<p>一个典型的例子就是 HashMap 保存数据，Java中的HashMap允许 key 为null，比如一个教室，我们将座位号与坐在上面的人保存到HashMap中，在获取这些位置信息的时候，null就产生了歧义，到底是座位不存在还是座位没人。</p>
</blockquote>
</li>
<li><p>难以避免的 NPE</p>
</li>
<li><p>冗余的防御使代码，各种判空</p>
</li>
</ul>
<h2 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h2><p>Java8里面有Optional ，这个不作讨论。</p>
<h3 id="Kotlin的可空类型"><a href="#Kotlin的可空类型" class="headerlink" title="Kotlin的可空类型"></a>Kotlin的可空类型</h3><p>在Kotlin中，我们可以在任何类型后面加上 ? ，比如 “Int?”，实际等同于 “Int? = Int or null”</p>
<ol>
<li><p>安全的调用 ?.</p>
</li>
<li><p>Kotlin的Elvis操作符（也称为合并运算符） ?:  ，比如，学生不戴眼镜，度数就为 -1，则可以类似如下表示：</p>
</li>
</ol>
<blockquote>
<p>val result = student.glasses?.degreeOfMyopia ?: -1</p>
</blockquote>
<ol start="3">
<li>非空断言 !!  ，有时候我们想确保一个学生是戴眼镜的，那么: <code>val result = student!!.glasses</code></li>
</ol>
<p>其中，关于第2点，Kotlin能够这样写，具体实现其实还是根据 if-else 去逐层判断，并没有什么魔法。这样判断的原因无非就是：兼容Java、性能考虑</p>
<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p>在经过is判断会后之后使用就无须强制转换，如下使用方法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span>(obj) {</span><br><span class="line">	<span class="keyword">is</span> String -&gt; print(obj.length)</span><br><span class="line">	<span class="keyword">else</span> -&gt; print(<span class="string">"not a String"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="智能类型转换"><a href="#智能类型转换" class="headerlink" title="智能类型转换"></a>智能类型转换</h3><p>除了上述的智能转换，对于可空类型我们也可以使用 Smart Casts：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stu: Student = Student(Glasses(<span class="number">189.00</span>))</span><br><span class="line"><span class="keyword">if</span>(stu.glasses != <span class="literal">null</span>) println(stu.glasses.degreeOfMyopia)</span><br></pre></td></tr></tbody></table></figure>

<p>不过，根据官方文档，<strong>当且仅当Kotlin编译器确定在类型检查后该变量不会再改变，才会产生Smart Casts</strong>。利用这点，我们能够确保多线程应用安全，举个例子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kot</span> </span>{</span><br><span class="line">	<span class="keyword">var</span> stu: Student? = getStu()</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">dealStu</span><span class="params">()</span></span>{</span><br><span class="line">	    <span class="keyword">if</span>(stu != <span class="literal">null</span>) {</span><br><span class="line">	    <span class="comment">//还是不能这样写，编译器会因为可能在其他线程会修改该值有风险而报错，如果 stu 改成val 的就不会有这样的情况</span></span><br><span class="line">	        print(stu.glasses)</span><br><span class="line">	    }</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当然，我们也能利用let来更优雅一点：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dealStu</span><span class="params">()</span></span>{</span><br><span class="line">	stu?.let {print(it.glasses)}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在开发过程中，难免碰到类型转换，一般使用类似：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu: Student = getStu <span class="keyword">as</span> Student?</span><br><span class="line"><span class="comment">//当然，也能使用以下方法，二者效果是一样的</span></span><br><span class="line"><span class="keyword">var</span> stu: Student = getStu <span class="keyword">as</span>? Student</span><br></pre></td></tr></tbody></table></figure>

<p>除此之外，有些同学可能会认为需要频繁类型转换，所以会配合泛型封装一个“有效的”类型转换方法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">cast</span><span class="params">(original: <span class="type">Any</span>)</span></span>: T? = original <span class="keyword">as</span>? T</span><br></pre></td></tr></tbody></table></figure>

<p>使用上了 as? ，看起来没问题，那我们应该可以这样用：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ans = cast&lt;String&gt;(<span class="number">140163L</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>用法看起来也挺合理，但是在调用的时候，会抛出 Long cannot be cast to String 这样的异常。这其实是类型擦除的后果。Kotlin的设计者们同样注意到这点，加入了 <strong>reified</strong>关键字，可以理解为<strong>具体化</strong>，利用它我们可以在方法体内访问泛型指定的 JVM 对象(注意，还要在方法前加入 inline 修饰)。代码使用如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">cast</span><span class="params">(original: <span class="type">Any</span>)</span></span>: T? = original <span class="keyword">as</span>? T</span><br></pre></td></tr></tbody></table></figure>

<h2 id="比Java-更面向对象的设计"><a href="#比Java-更面向对象的设计" class="headerlink" title="比Java 更面向对象的设计"></a>比Java 更面向对象的设计</h2><p>Java并不能真正意义上被称作一门“纯面向对象”的语言，因为它的原始类型（如int）的值与函数并不能视作对象。</p>
<h3 id="Any：-非空类型的根类型"><a href="#Any：-非空类型的根类型" class="headerlink" title="Any： 非空类型的根类型"></a>Any： 非空类型的根类型</h3><p>与Object 作为 Java类层级的顶层类似，Any类型是Kotlin中所有非空类型（如String、Int）的超类。与Java不同，Kotlin不区分原始类型和其他类型，Koltin中，<strong>所有类型的最终根类型都是Any</strong>。另外，<strong>Kotlin把Java方法参数和返回类型中用到的Object类型看做 Any ，当Kotlin函数中使用Any时，它会被编译成 Java字节码中的 Object</strong>。</p>
<h3 id="Any-：所有类型的根类型"><a href="#Any-：所有类型的根类型" class="headerlink" title="Any?：所有类型的根类型"></a>Any?：所有类型的根类型</h3><p>如果说Any是所有非空类型的根类型，那么 Any? 才是所有类型(可空和非空类型)的根类型。如果只有Java这门编程语言的经验，很容易陷入一个误区：继承关系决定父子类型关系。因为在Java中，类与类型大部分情况下都是“等价的”。</p>
<p>事实上，“继承”和“子类型化”是两个完全不同的概念。如Kotlin中的Int是Number的子类，那么在需要Number类型的地方传入 Int类型是没问题的。这是“继承”强调的“实现上的复用”。而子类型化是一种类型语义的关系，与实现没关系。<strong>虽然Any 与 Any? 看起来没有继承关系，然而在我们需要用 Any? 类型值的地方，显然可以传入一个类型为 Any 的值，反之却不然！</strong></p>
<p>所以，我们可以大胆地说，Any？ 是 Any 的父类型，而且是所有类型的根类型。</p>
<blockquote>
<p>Any? 与 Any??。 你可能会问，那 Any??是不是 Any? 的父类型？如果成立，岂不是意味着没有所谓的所有类型的根类型了？其实，Kotlin的可空类型可以看做数学上的并集。如果用类型的并集表示 Any ，可以写成  Any U Null ，那么 Any?? 就可以写成 Any U Null U Null ，等价于 Any U Null ，即 Any??等价于 Any? 。</p>
</blockquote>
<h3 id="Nothing-与-Nothing"><a href="#Nothing-与-Nothing" class="headerlink" title="Nothing 与 Nothing?"></a>Nothing 与 Nothing?</h3><p>顾名思义，Nothing是没有实例的类型。<strong>Kotlin 中 return、throw等（流程控制中与跳转相关的表达式）返回值都是 Nothing。</strong>Nothing 只能包含一个值：null，本质上与null没有区别，所以我们可以使用null作为任何可空类型的值。</p>
<h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p>Kotlin 中没有 int、float、double、long这类的原始类型，取而代之的是它们对应的引用类型包装类： Int、Float、Double、Long。看起来让Kotlin比Java更加接近纯面向对象设计，但这样说其实是不够严谨的。</p>
<p>以Int 为例，虽然它可以像Integer 一样提供额外的操作函数，但这两个类型在底层实现上存在差异，看一段代码：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x1 = <span class="number">18</span> <span class="comment">//kotlin</span></span><br><span class="line">int x2 = <span class="number">18</span>;<span class="comment">//Java</span></span><br><span class="line">Integer x3 = <span class="number">18</span>;<span class="comment">//Java</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是我们观察 Kotlin <strong>编译完成后的字节码可以发现，Kotlin中的Int在JVM中实际以int 存储(对应字节码类型为 I)</strong>。但是作为一个“包装类型”，Int编译后应该装箱才对，难道Kotlin不会自动装箱？其实可以再看看 Int? 的字节码，就可以得出结论：</p>
<ul>
<li><strong>Kotlin 中的 Int 类型等同于 int</strong></li>
<li><strong>Kotlin 中的 Int? 等同于 Integer ！</strong></li>
</ul>
<p>Int 作为一种小技巧，让Int看起来是引用类型。</p>
<h3 id="“新”的数组类型"><a href="#“新”的数组类型" class="headerlink" title="“新”的数组类型"></a>“新”的数组类型</h3><p>Kotlin 中可以这样创造数组：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> funList = arrayOf()<span class="comment">//声明长度为0的数组</span></span><br><span class="line"><span class="keyword">val</span> funList = arrayOf(n1,n2,n3,....nt)<span class="comment">//声明并初始化长度t的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于Smart Casts ，编译器能够推出funList的元素类型。当然，我们也能手动指定：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> funList = arrayOf&lt;T&gt;(n1,n2,...nt)</span><br><span class="line"></span><br><span class="line"><span class="comment">//与array类似，我们可以这样定义原始类型的数组</span></span><br><span class="line"><span class="keyword">val</span> xArray = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>要注意的是，IntArray等类型并不是 Array的子类。还有，<strong>Kotlin对原始类型的特殊优化，主要体现在避免了自动装箱带来的开销！</strong></p>
<h2 id="泛型：-让类型更安全"><a href="#泛型：-让类型更安全" class="headerlink" title="泛型： 让类型更安全"></a>泛型： 让类型更安全</h2><p>首先，Kotlin中也有泛型。</p>
<h3 id="泛型：类型安全的利刃"><a href="#泛型：类型安全的利刃" class="headerlink" title="泛型：类型安全的利刃"></a>泛型：类型安全的利刃</h3><p>大家都知道1.5以前的Java的List需要靠强制转换来取值的，并且可以存入各种各样类型的值，在编译期还发现不了，这就很难受了。所以后来就出了泛型，泛型主要优势有几点：</p>
<ul>
<li>类型检查，在编译时就检查出错误。</li>
<li>更加语义化，List<string>便可以知道里面存储的是 String 类型。<br>自动类型转换，获取数据时不需要手动强转，更安全。</string></li>
<li>能写出更通用的代码。</li>
</ul>
<h3 id="Kotlin中使用泛型"><a href="#Kotlin中使用泛型" class="headerlink" title="Kotlin中使用泛型"></a>Kotlin中使用泛型</h3><p>首先，在Kotlin中，使用 <code>val arrayListt = ArrayList()</code> 这种方式是不允许的，但在Java中可以这么做，这是因为在Java中 1.5版本后才引入的，Java为了兼容可以这么做。但是，由于Kotlin具有类型推导能力，所以 <code>val arrayListt = arrayListOf("one","two")</code> 是允许的。</p>
<h3 id="类型约束：设定类型上界"><a href="#类型约束：设定类型上界" class="headerlink" title="类型约束：设定类型上界"></a>类型约束：设定类型上界</h3><p>我们知道，泛型本身就有类型约束的作用，比如，你无法向一个String类型List中添加一个Double对象。那么这里说的是约束什么呢？用例子来看下，假设我们有一个盘子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> t: T)</span><br></pre></td></tr></tbody></table></figure>
<p>这个盘子类有一个泛型参数，表示可以接收各种东西，如水果或者主食。但是，如果有一天想把盘子归类，有些只能放水果，有些只能放菜，又该如何呢？还是看例子，我们可以定义一个水果类(Fruit)，并声明 Apple 和 Banana 来继承它，并定义出水果盘子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>(): Fruit()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span></span>(): Fruit()</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个水果盘子：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitPlate</span>&lt;<span class="type">T: Fruit</span>&gt;</span>()</span><br></pre></td></tr></tbody></table></figure>

<p>上述的FruitPlate中T被限定了只能是 Fruit 类及其子类类型，其他类则不被允许。这种约束我们叫做<strong>上界约束</strong>，和Java的语法类似，只不过java 用extends关键字。假如我们要求水果盘子不一定装水果，有时候还能空着，那应该怎么办呢？我们可以在泛型参数类型后面加一个”?”即可：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitPlate</span>&lt;<span class="type">T: Fruit?</span>&gt;</span>(<span class="keyword">val</span> t: T)</span><br></pre></td></tr></tbody></table></figure>

<p>**如果，泛型有多个条件，怎么办？比如，有一把刀，只能用来切长在地上的水果，我们可以用 where 关键字这样实现：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Ground</span></span>{}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watermelon</span></span>(): Fruit(), Ground</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">cut</span><span class="params">(t: <span class="type">T</span>)</span></span> <span class="keyword">where</span> T: Fruit, T: Ground {</span><br><span class="line">	print(<span class="string">"you can cut me"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个where关键字就限定了多个条件，水果以及长在地上。</p>
<h2 id="泛型的背后：-类型擦除"><a href="#泛型的背后：-类型擦除" class="headerlink" title="泛型的背后： 类型擦除"></a>泛型的背后： 类型擦除</h2><h3 id="Java-为何无法声明一个泛型数组"><a href="#Java-为何无法声明一个泛型数组" class="headerlink" title="Java 为何无法声明一个泛型数组"></a>Java 为何无法声明一个泛型数组</h3><p>我们看个简单的例子，Apple是Fruit的子类：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Apple[] appleArray = <span class="keyword">new</span> Apple[<span class="number">10</span>];</span><br><span class="line">Fruit[] fruitArray = appleArray;<span class="comment">//允许的</span></span><br><span class="line">fruitArray[<span class="number">0</span>] = <span class="keyword">new</span> Banana();<span class="comment">//编译通过，运行报错</span></span><br><span class="line"></span><br><span class="line">List&lt;Apple&gt; appleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Fruit&gt; fruitList = appleList;<span class="comment">//不允许</span></span><br></pre></td></tr></tbody></table></figure>

<p>为什么数组可以这么做，而List就不行呢？关键的一点，<strong>数组是协变的，而List是不变的</strong>，换句话说，Object[] 是所有对象数组的父类，而 List<object> 却不是 List<t>的父类！我们知道Java中的List会类型擦除，具体表现如下：<p></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(appleArray.getClass());</span><br><span class="line">println(appleList.getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> [<span class="title">Ljavat</span>.<span class="title">Apple</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">ArrayList</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>Kotlin与Java这个机制是一样的，也会存在类型擦除。但与Java不同的是，<strong>Kotlin中的数组是支持泛型的，当然也不再协变</strong>。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> appleArray = arrayOfNulls&lt;Apple&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">val</span> anyArray: Array&lt;Any?&gt; = appleArray <span class="comment">//不允许</span></span><br></pre></td></tr></tbody></table></figure>

<p>这又是为什么呢？</p>
<h3 id="向后兼容的罪"><a href="#向后兼容的罪" class="headerlink" title="向后兼容的罪"></a>向后兼容的罪</h3><p>Java的list使用类型擦除是为了兼容老版本。既然类型擦除了，为什么我们在使用泛型的时候，能够进行类型检查，类型自动转呢？这是因为类型检查这些操作在编译器编译前就检查了，所以类型擦除不影响它。然后，我们可以发现，List 的get方法其实也是通过强制转换类型来实现的！</p>
<h3 id="类型擦除的矛盾"><a href="#类型擦除的矛盾" class="headerlink" title="类型擦除的矛盾"></a>类型擦除的矛盾</h3><p>通常情况使用泛型我们不在意它的擦除，但是在序列化/反序列化的时候，我们就需要知道类型了，咋办？既然编译后会擦除泛型参数类型，那么我们是不是可以主动指定参数类型来达到运行时获取泛型参数类型效果呢？看下例子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接着上面的Plate的代码写</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="type">T</span>&gt; </span>(<span class="keyword">val</span> t: T, <span class="keyword">val</span> clazz: Class&lt;T&gt;) {</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">()</span></span>{</span><br><span class="line">	    print(clazz)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">val</span> applePlate = Plate(Apple(), Apple::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">applePlate.getType()<span class="comment">//会打印 class Apple</span></span><br></pre></td></tr></tbody></table></figure>

<p>上述方法可以解决很多问题了，但是它无法获取泛型的类型，比如：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> type = ArraList&lt;String&gt;::<span class="keyword">class</span>.java<span class="comment">//不被允许</span></span><br></pre></td></tr></tbody></table></figure>

<p>有没有其他方式呢？有，可以利用匿名内部类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = ArraList&lt;String&gt;()</span><br><span class="line"><span class="keyword">val</span> list2 = <span class="keyword">object</span>: ArrayList&lt;String&gt;(){}<span class="comment">//匿名内部类</span></span><br><span class="line"></span><br><span class="line">println(list1.javaClass.genericSuperclass)</span><br><span class="line">println(list2.javaClass.genericSuperclass)</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">java.util.AbstractList&lt;E&gt;</span><br><span class="line">javaUtil.ArrayList&lt;java.lang.String&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>竟然可以了，原理是啥呢？<strong>其实，泛型类型擦除并不是真的将全部的类型信息都擦除，还是会将类型信息放在对应 Class 的常量池的。</strong>所以，我们能通过相应的方式来获取这个类型信息，使用匿名内部类就可以实现这种需求。我们着手来设计一个能获取所有类型信息的泛型类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsToken</span>&lt;<span class="type">T</span>&gt; </span>{</span><br><span class="line">	<span class="keyword">var</span> type: Type = Any::<span class="keyword">class</span>.java</span><br><span class="line"></span><br><span class="line">	<span class="keyword">init</span> {</span><br><span class="line">	    <span class="keyword">val</span> superClass = <span class="keyword">this</span>.javaClass.genericSuperclass</span><br><span class="line">	    type = (superClass <span class="keyword">as</span> ParameterizedType).getActualTypeArguments()[<span class="number">0</span>]</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">	<span class="keyword">val</span> gt = <span class="keyword">object</span>: GenericsToken&lt;Map&lt;String,String&gt;&gt;(){}</span><br><span class="line">	print(gt.type)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">java.util.map&lt;java.lang.String, ?extends java.lang.String&gt;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>匿名内部类在初始化的时候就会绑定父类或者接口的相应信息，这样就能通过获取父类或者父接口的泛型类信息来实现我们的需求，你可以用这样一个类来获取任何泛型的类型，我们常用的Gson也是使用了相同的设计</strong>。比如，我们在Kotlin中可以这样使用Gson来进行泛型类的反序列化：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> json = ...</span><br><span class="line"><span class="keyword">val</span> rType = <span class="keyword">object</span>: TypeToken&lt;List&lt;String&gt;&gt;(){}.type</span><br><span class="line"><span class="keyword">val</span> stringList = Gson.fromJson&lt;List&lt;String&gt;&gt;(json,tType)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用内联函数获取泛型"><a href="#使用内联函数获取泛型" class="headerlink" title="使用内联函数获取泛型"></a>使用内联函数获取泛型</h3><p>其实，Kotlin中除了上述方法外，还可以通过内联函数实现。<strong>内联函数在编译的时候，便会将相应函数的字节码插入调用的地方，也就是说参数类型也会被插入字节码中</strong>。下面我们就用内联函数实现一个可以获取泛型参数的方法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">getType</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">return</span> T::<span class="keyword">class</span>.java</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>非常简单，只需要加上 reified 关键词即可。所以，我们可以在Kotlin中改进Gson的使用方式：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T: Any&gt;</span> Gson.<span class="title">fromJson</span><span class="params">(json: <span class="type">String</span>)</span></span>: T {</span><br><span class="line">	<span class="keyword">return</span> Gson().fromJson(json, T::<span class="keyword">class</span>.java)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">val</span> list = Gson.fromJson&lt;List&lt;Stirng&gt;&gt;(json)</span><br></pre></td></tr></tbody></table></figure>
<p>这里是对Gson进行了扩展，实现很优雅。注意，<strong>Java不支持内联函数，所以在Kotlin中声明的普通内联函数可以在Java中调用，被当做常规函数了；而用reified来实例化参数类型的内联函数不能在Java 中调用，因为它永远需要内联的</strong>。</p>
<h2 id="打破泛型不变"><a href="#打破泛型不变" class="headerlink" title="打破泛型不变"></a>打破泛型不变</h2><p>略吧，看迷糊了，下次补上</p>
</t></object></p></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/09/06/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E5%8D%A1%E9%A1%BF-ANR%E7%AD%89%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/06/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E5%8D%A1%E9%A1%BF-ANR%E7%AD%89%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7/" class="post-title-link" itemprop="url">卡顿、ANR、死锁线上监控</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-06 20:00:00 / 修改时间：20:27:10" itemprop="dateCreated datePublished" datetime="2021-09-06T20:00:00+08:00">2021-09-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>性能优化这块，很多人只能说出传统的分析方式，比如 ANR 分析，只会通过<strong>查看/data/arn/下的log</strong>，分析主线程堆栈、cpu、锁等信息。但是这种方法有<strong>局限性，有些高版本设备需要root权限才能访问 /data/anr/ 目录</strong>，或者，如果只是用户反馈，我们压根没法复现的情况，就很难分析问题了。</p>
<h2 id="卡顿原理与监控"><a href="#卡顿原理与监控" class="headerlink" title="卡顿原理与监控"></a>卡顿原理与监控</h2><p>卡顿原理里面需要注意的一点是：存在消息屏障的情况下，*<em>当异步消息被处理完后，如果没有及时把消息屏障消息移除，会导致同步消息一直没有机会处理，一直阻塞在nativePollOnce *</em>。</p>
<h3 id="卡顿原理"><a href="#卡顿原理" class="headerlink" title="卡顿原理"></a>卡顿原理</h3><p>首先，我们可以看下Looper.loop的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">//1、取消息</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//2、消息处理前回调</span></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) {</span><br><span class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">            }</span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//3、消息开始处理</span></span><br><span class="line">            msg.target.dispatchMessage(msg);<span class="comment">// 分发处理消息</span></span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//4、消息处理完回调</span></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) {</span><br><span class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">            }</span><br><span class="line">       }</span><br><span class="line">       ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这个loop方法主线程循环，可以长时间运行，从代码可以看出导致卡顿的原因可能有两个地方：</p>
<ul>
<li>注释1处的取消息 queue.next() 阻塞     </li>
<li>注释3处 dispatchMessage 耗时太久    </li>
</ul>
<p>看下 MessageQueue#next 的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">//1、nextPollTimeoutMillis 不为0则阻塞</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="comment">// 2、先判断当前第一条消息是不是同步屏障消息，</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">//3、遇到同步屏障消息，就跳过去取后面的异步消息来处理，同步消息相当于被设立了屏障</span></span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> {</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                } <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//4、正常的消息处理，判断是否有延时</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) {</span><br><span class="line">                    <span class="comment">//4 </span></span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) {</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    }</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//5、如果此时是同步屏障，没有取到消息，那么下次循环就走到1那里去了，nativePollOnce为-1，会一直阻塞</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">          ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p>MessageQueue 是一个<strong>链表数据结构</strong>，它的 next 方法大致流程是这样的：</p>
<ol>
<li>首先判断它头结点(第一个消息)是否是同步屏障消息，如果是，则只处理异步msg，同步msg不处理   </li>
<li>如果是同步屏障的话，若没有获取到异步消息，就会走到注释5，设置 nextPollTimeoutMillis = -1 后，下次循环就会在注释 1 处阻塞     </li>
<li>如果获取到正常的 msg ，不管是同步还是异步，处理流程都一样，先在注释4处判断是否演示，如果延时，则会给 nextPollTimeoutMillis 赋值，下次循环到 1 处就会阻塞一段时间；如果不延时，则会return ，<strong>交给 handler 处理（确实是交给Handler处理： msg.target.dispatchMessage(msg) ，在这里面会 首先判断msg.callback 、其次是Handler的mCallback，最后才是交给 Handler 的 handleMessage 处理）</strong></li>
</ol>
<h3 id="简单介绍Linux-中的IO多路复用方案"><a href="#简单介绍Linux-中的IO多路复用方案" class="headerlink" title="简单介绍Linux 中的IO多路复用方案"></a>简单介绍Linux 中的IO多路复用方案</h3><p>Linux上IO多路复用方案有 <strong>select、poll、epoll</strong>，它们 3 个中 epoll 的性能表现是最优秀的，能支持的并发量也最大，简单介绍：</p>
<ul>
<li><strong>select</strong> 操作系统提供的函数，通过它，我们可以把一个<strong>文件描述符的数组发给操作系统，让操作系统去遍历，确定哪个文件描述符可以读写，然后让我们处理</strong>。    </li>
<li><strong>poll</strong>：和select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制    </li>
<li><strong>epoll</strong>： 主要针对select 做了3个优化：</li>
</ul>
<blockquote>
<p>1、内核中保存一份文件描述符集合，无序用户每次传入，只需要告诉内核修改的部分</p>
<p>2、内核通过异步IO事件唤醒而不是轮询的方式找到就绪的文件描述符    </p>
<p>3、内核仅将有IO事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合</p>
</blockquote>
<h3 id="同步屏障"><a href="#同步屏障" class="headerlink" title="同步屏障"></a>同步屏障</h3><p>Android 不允许用户调用 发送同步屏障的方法，它是hide的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* @hide</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>{</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>系统一些高优先级的操作会用到同步屏障消息，例如，View在绘制的时候，最终都要调用 ViewRootImpl 的 scheduleTraversals ，会往MessageQueue 中插入同步屏障 msg，之后在unscheduleTraversals中移除 ：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) {</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//插入同步屏障消息</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unscheduleTraversals</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) {</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//移除同步屏障消息</span></span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>为了保证View的绘制过程不被主线程其他任务影响，View在绘制之前会先往MessageQueue 中插入同步屏障消息，然后注册 Vsync 信号监听，<strong>Choreographer$FrameDisplayEventReceiver</strong>就是做这事：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title">DisplayEventReceiver</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>{</span><br><span class="line">        ...</span><br><span class="line">        Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//1、发送异步消息</span></span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 2、doFrame优先执行</span></span><br><span class="line">        doFrame(mTimestampNanos, mFrame);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>收到 Vsync 信号，注释1会发送异步消息，保证注释2中的doFrame 方法（View真正开始绘制的方法，会调用ViewRootImpl 的 doTraversal、performTraversals）优先执行。<strong>需要注意的是，App要谨慎使用异步msg，使用不当可能会<a target="_blank" rel="noopener" href="https://juejin.cn/post/6947986170135445535">出现主线程假死的问题</a>，排查也会比较困难</strong>。</p>
<h3 id="Handler-的dispatchMessage方法"><a href="#Handler-的dispatchMessage方法" class="headerlink" title="Handler 的dispatchMessage方法"></a>Handler 的dispatchMessage方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) {</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里印证了前面说的msg 处理顺序， msg.callback -&gt; Handler.mCallback -&gt; handleMessage</p>
<h2 id="卡顿监控方案"><a href="#卡顿监控方案" class="headerlink" title="卡顿监控方案"></a>卡顿监控方案</h2><h3 id="卡顿监控方案一：通过Looper-loop中的日志打印监控"><a href="#卡顿监控方案一：通过Looper-loop中的日志打印监控" class="headerlink" title="卡顿监控方案一：通过Looper.loop中的日志打印监控"></a>卡顿监控方案一：通过Looper.loop中的日志打印监控</h3><p>首先，我们可以回顾上面 Looper.loop 的源码。注释2和注释4会打印日志，中间过程3是处理msg的过程，这样两段日志之间的耗时就是msg处理的耗时。Google 为我们提供了这个接口，我们只需要 Looper.getMainLooper().setMessageLogging(printer) 设置我们自己的printer就行。需要注意的是，<strong>监听到发生卡顿之后，dispatchMessage 早已调用结束，已经出栈，此时再去获取主线程的堆栈，堆栈中是不会包含卡顿代码的！</strong>。</p>
<p>所以，<strong>我们需要在后台开一个线程，定时获取主线程堆栈，然后以时间点作为key，堆栈信息作为value，保存到Map中</strong>，发生卡顿的时候，只需要取出卡顿时间段内的堆栈信息即可。</p>
<p>不过，这种方法只适合线下使用，因其存在以下缺陷：</p>
<ul>
<li>logging.println 存在字符拼接，频繁调用会<strong>创建大量对象，造成内存抖动</strong></li>
<li><strong>获取主线程堆栈，会暂停主线程的运行</strong></li>
</ul>
<h3 id="卡顿监控方案二：字节码插桩"><a href="#卡顿监控方案二：字节码插桩" class="headerlink" title="卡顿监控方案二：字节码插桩"></a>卡顿监控方案二：字节码插桩</h3><p>通过 Gradle Plugin + ASM ，<strong>编译期在每个方法开始和结束的位置分别插入一行代码，统计方法耗时！</strong>，行业内的轮子有 <strong>微信的 Matrix 方案</strong>。</p>
<p>对于这种插桩方法，需要注意的是：</p>
<ul>
<li>避免方法数暴增。在方法的入口和出口应该插入相同的函数，在编译时提前给代码中每个方法分配一个独立的ID作为参数。</li>
<li>过滤简单函数。过滤一些直接return、i++ 之类的简单函数，并支持黑名单配置，对一些调用非常频繁的函数，需要添加到黑名单来降低整个方案对性能的消耗。</li>
</ul>
<p>微信对Matrix做了大量优化，整个包体积增大1%~2%，帧率下降 2 帧以内，对性能影响可以接收，<strong>不过依然只会在灰度包使用</strong>。</p>
<h2 id="ANR监控"><a href="#ANR监控" class="headerlink" title="ANR监控"></a>ANR监控</h2><h3 id="ANR-原理"><a href="#ANR-原理" class="headerlink" title="ANR 原理"></a>ANR 原理</h3><p>ANR的原理可以比喻成<strong>埋炸弹</strong>和<strong>拆炸弹</strong>的过程，以Service为例，在通知AMS启动服务之前，通过Handler发送演示消息，这就是埋炸弹，若是 10s 内（前台服务是20s）没人来拆炸弹，炸弹就会爆炸。在ActivityThread中创建服务对象时，调用其 onCreate 之后，就会执行remove之前发送的消息，即拆炸弹。</p>
<p>常见的ANR情形如下：</p>
<ul>
<li>Service。 前台服务在20s内未执行完成，后台服务是前台服务的10倍，200s</li>
<li>输入事件。输入事件分发超时5s，包括按键和触摸事件</li>
<li>广播。前台广播在10s内未执行完成，后台60s</li>
<li>ContentProvider。在publish过程超时10s;</li>
</ul>
<h3 id="AppErrors"><a href="#AppErrors" class="headerlink" title="AppErrors"></a>AppErrors</h3><p>所有的ANR，最终都会调用 AppErrors 的 appNotResponding 方法，主要包括几个流程：</p>
<ol>
<li>写入event log</li>
<li>写入 main log</li>
<li>生成tracesFile</li>
<li>输出ANR logcat （控制台可以看到）</li>
<li>尝试写入traceFile</li>
<li>输出drapbox</li>
<li>后台ANR，直接杀进程</li>
<li>错误报告</li>
<li>弹出ANR dialog</li>
</ol>
<p>关于ANR，可以看<a target="_blank" rel="noopener" href="http://gityuan.com/2019/04/06/android-anr/">gityuan的《彻底理解安卓应用五响应机制》</a></p>
<h3 id="ANR分析方法：导出ANR文件"><a href="#ANR分析方法：导出ANR文件" class="headerlink" title="ANR分析方法：导出ANR文件"></a>ANR分析方法：导出ANR文件</h3><p>导出ANR文件，即导出/data/anr/traces.txt文件，首先查看主线程，搜索main：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55c5c9e9b60743de9f10d5372ac7087b~tplv-k3u1fbpfcp-zoom-1.image" alt="搜索main示意"></p>
<p>ANR日志有很多信息，可以看到主线程id是1（tid=1），在等待一个锁，这个锁一直被id为22的线程持有，再来看看22号线程的堆栈：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a9e111b93404118bd9b8cca2085dd48~tplv-k3u1fbpfcp-zoom-1.image" alt="持有锁的线程"></p>
<p>22号线程处于Blocked状态，正在等待一个锁，这个锁被id为1的线程持有，同时这个22号线程还持有一个锁，这个锁是主线程想要的。</p>
<p>通过ANR日志可以分析除这个ANR是死锁导致的，并且有具体的堆栈信息。这只是一种，还有其他ANR情况，比如内存不足、CPU被抢占、系统服务没有及时响应。</p>
<p><strong>如果作为线上的话，在ANR发生时，可以将这个traces.txt文件上报到服务器，只不过有些手机需要root权限才能读取 /data/anr目录</strong></p>
<h3 id="ANR监控-1"><a href="#ANR监控-1" class="headerlink" title="ANR监控"></a>ANR监控</h3><h4 id="1、抓取系统的-traces-txt"><a href="#1、抓取系统的-traces-txt" class="headerlink" title="1、抓取系统的 traces.txt"></a>1、抓取系统的 traces.txt</h4><ol>
<li>当监控线程发现主线程卡死时，主动向系统发送 SIGNAL_QUIT信号</li>
<li>等待 /data/anr/traces.txt 文件生成</li>
<li>文件生成后进行上报</li>
</ol>
<p>这种方案可以参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1064396">手Q的线程死锁监控与自动化分析实践</a>，但是，这种方案存在以下问题：</p>
<ul>
<li>traces.txt 里面包含所有线程信息，上传后需要<strong>人工过滤分析</strong></li>
<li>很多高版本系统<strong>需要root权限才能读取到 /data/anr</strong> 这个目录</li>
</ul>
<h4 id="2、ANRWatchDog"><a href="#2、ANRWatchDog" class="headerlink" title="2、ANRWatchDog"></a>2、ANRWatchDog</h4><p>它的主要原理：</p>
<ol>
<li>开启一个线程，死循环，循环中睡眠 5s    </li>
<li>往UI线程post一个Runnable，将_tick 赋值为 0 ，将 _reported 赋值为 false</li>
<li>线程睡眠 5s 后检查 _tick 和 _report 的字段是否被修改    </li>
<li>如果一直没有被修改，说明主线程post的Runnable 一直没有被执行，说明主线程至少卡顿5s <strong>(只能说至少，这里存在5s内的误差)</strong></li>
<li>将贤臣各堆栈信息输出</li>
</ol>
<p>但是，这种方案，其实是有缺陷的，它有个时候会捕获不到 ANR ，什么原因呢？</p>
<p><strong>ANRWatchDog缺点</strong></p>
<p>可以用一个图片来表示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ae96474849043f4acb5719e2bf3e797~tplv-k3u1fbpfcp-watermark.awebp" alt="漏检测示意图"></p>
<p>这种情况红色表示卡顿：</p>
<ol>
<li>假设主线程卡顿了 2s 之后，ANRWatchDog 刚好开始下一轮循环，将 _tick 赋值为5，并往主线程post一个任务，执行 _tick = 0</li>
<li>主线程过了 3s 之后刚好不卡顿了，将 _tick 置为 0 ，</li>
<li>等到 ANRWatchDog 睡眠 5s 之后，发现 _tick = 0 ，判断并没有发生 ANR</li>
</ol>
<p>针对 ANRWatchDog 存在的问题，可以做一个优化。</p>
<h3 id="3、ANRMoitor"><a href="#3、ANRMoitor" class="headerlink" title="3、ANRMoitor"></a>3、ANRMoitor</h3><p>针对 ANRWatchDog 的漏检测问题，设计一个 ANRMoitor ，ANRWatchDog 出现问题的主要原因是，<strong>因为线程睡眠 5s ，不知道前一秒主线程是否已经出现卡顿了，如果盖层每隔 1s 检测一次，就可以把误差降低到 1s 内。</strong>我们<strong>想让子线程间隔1s执行一次任务，可以通过 HandlerThread 来实现</strong>，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Volatile</span></span><br><span class="line"><span class="keyword">var</span> mainHandlerRunEnd = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程会间隔1s调用一次这个Runnable</span></span><br><span class="line"><span class="keyword">private</span> val mThreadRunnable = Runnable {</span><br><span class="line">    </span><br><span class="line">    blockTime++</span><br><span class="line">    <span class="comment">//1、标志位 mainHandlerRunEnd 没有被主线程修改，说明有卡顿</span></span><br><span class="line">    <span class="keyword">if</span> (!mainHandlerRunEnd &amp;&amp; !isDebugger()) {</span><br><span class="line">        logw(TAG, <span class="string">"mThreadRunnable: main thread may be block at least $blockTime s"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、卡顿超过5s，触发ANR流程，打印堆栈</span></span><br><span class="line">    <span class="keyword">if</span> (blockTime &gt;= <span class="number">5</span>) {</span><br><span class="line">        <span class="keyword">if</span> (!mainHandlerRunEnd &amp;&amp; !isDebugger() &amp;&amp; !mHadReport) {</span><br><span class="line">            mHadReport = <span class="keyword">true</span></span><br><span class="line">            <span class="comment">//5s了，主线程还没更新这个标志，ANR</span></span><br><span class="line">            loge(TAG, <span class="string">"ANR-&gt;main thread may be block at least $blockTime s "</span>)</span><br><span class="line">            loge(TAG, getMainThreadStack())</span><br><span class="line">            <span class="comment">//todo 回调出去，这里可以按需把其它线程的堆栈也输出</span></span><br><span class="line">            <span class="comment">//todo debug环境可以开一个新进程，弹出堆栈信息</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、如果上一秒没有卡顿，那么重置标志位，然后让主线程去修改这个标志位</span></span><br><span class="line">    <span class="keyword">if</span> (mainHandlerRunEnd) {</span><br><span class="line">        mainHandlerRunEnd = <span class="keyword">false</span></span><br><span class="line">        mMainHandler.post {</span><br><span class="line">        	mainHandlerRunEnd = <span class="keyword">true</span></span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"> <span class="comment">//子线程间隔1s调用一次mThreadRunnable</span></span><br><span class="line">    sendDelayThreadMessage()</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p>具体流程：</p>
<ol>
<li>子线程每隔 1s 执行一次 mThreadRunnable，检测标志位 mainHandlerRunEnd 是否被修改</li>
<li>假如 mainHandlerRunEnd 被如期修改为 true，则重置 mainHandlerRunEnd 为 false，继续执行步骤 1</li>
<li>假如 mainHandlerRunEnd 没有被修改为true，说明有卡顿，累计卡顿 5s 就触发 ANR</li>
</ol>
<p>这种方案也能在线下应用，定位到耗时代码。<strong>最好可以结合 ProcessLifecycleOwner ，应用在前台时才开启，否则停止检测。</strong></p>
<h2 id="死锁监控"><a href="#死锁监控" class="headerlink" title="死锁监控"></a>死锁监控</h2><p>就是检测等待啥锁，锁被谁持有了</p>
<h2 id="形成闭环"><a href="#形成闭环" class="headerlink" title="形成闭环"></a>形成闭环</h2><p>前面分别讲了卡顿监控、ANR监控和死锁监控，可以把它们连接起来，形成闭环：</p>
<ol>
<li>发生ANR</li>
<li>获取主线程堆栈</li>
<li>检测死锁</li>
<li>上报服务器</li>
<li>结合git，定位到最后修改代码的同学，提问题单</li>
</ol>
<p>以上内容参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6973564044351373326">蓝师傅的博客</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">129</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共273.8k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.gitee.io/page/2/',]
      });
      });
  </script>


</body>
</html>
