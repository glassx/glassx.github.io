<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/12/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">39</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">223</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/09/14/%E9%9D%A2-%E7%9F%A5%E8%AF%86/http3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/14/%E9%9D%A2-%E7%9F%A5%E8%AF%86/http3/" class="post-title-link" itemprop="url">网络-http3</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-14 21:30:00" itemprop="dateCreated datePublished" datetime="2021-09-14T21:30:00+08:00">2021-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-28 16:19:22" itemprop="dateModified" datetime="2021-09-28T16:19:22+08:00">2021-09-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="QUIC-概览"><a href="#QUIC-概览" class="headerlink" title="QUIC 概览"></a>QUIC 概览</h2><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/QUIC%E5%8D%8F%E8%AE%AE.png" alt="QUIC协议预览"></p>
<p>  所以，QUIC 与 http3 啥关系呢？ QUIC 用来替代 TCP、SSL/TLS 的传输协议，在传输层之上还有应用层，如http、ftp、imap 等，理论上这些协议都能运行在 QUIC 之上。<strong>运行在 QUIC 之上的 HTTP 协议被称为 https 。</strong> QUIC的几个重要特性如下面介绍：</p>
<h3 id="1、只要1个RTT建立连接"><a href="#1、只要1个RTT建立连接" class="headerlink" title="1、只要1个RTT建立连接"></a>1、只要1个RTT建立连接</h3><p>  Http2 基于TLS首次建立连接需要 3 个RTT，而 http3 首次建立连接只需要 1 RTT,首次连接后，后续连接只需要 0 RTT。如图：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B.png" alt="QUIC协议预览"></p>
<p>那么，http3 如何做到，且看连接过程：</p>
<ol>
<li>首次连接时，客户端发送 Inchoate Client Hello 给服务端。   </li>
<li>服务端生成 g、p、a，再根据 g、p、a 算出 A，然后将 g、p、A 放到 Server Config 中再发送 Rejection 消息给客户端。    </li>
<li>客户端接收到 g、p、A 后，再自己生成 b ，根据 g、p、b 计算出 B，根据 A、p、b 算出初始秘钥 K ，B 和 K 计算好之后，客户端用 K 加密 http 数据，连同 B 一起发送给服务端     </li>
<li>服务端收到 B 后，根据 a、p、B 生成与客户端相同的秘钥，再用这个秘钥解密收到的 http 数据。为了前向安全，服务端会更新自己的随机数 a 和 公钥，再生成新的密钥 S，然后把公钥、Http 返回的数据通过 Server Hello 发送给客户</li>
<li>客户端收到 Server Hello 后，生成与服务端一致的新秘钥 S ，后面的传输都用 S 加密。     </li>
</ol>
<h3 id="2、连接迁移（QUIC连接不受四元组影响）"><a href="#2、连接迁移（QUIC连接不受四元组影响）" class="headerlink" title="2、连接迁移（QUIC连接不受四元组影响）"></a>2、连接迁移（QUIC连接不受四元组影响）</h3><p>  QUIC 连接不受四元组（源IP、源端口、目的IP、目的端口）影响，道理很简单：<strong>QUIC 不以四元组作为标识，而是使用一个 64 位的随机数，即使 IP 或者端口变化，称之为 Connection ID ，只要 这个 Connection ID 没变化，那么连接依然可以维持连接</strong>。</p>
<p>  而使用TCP的话，切换网络时至少会有一个因素发生变化，当连接发生变化时，如果还使用原来的TCP连接，则会导致连接失败，就得等原来的连接超时后重新建立连接，所以，<strong>我们有时候发现切换到一个新网络时，即使新网络很好，但内容还是要加载很久</strong>。如果实现得好，当检测到网络变化时立刻建立新TCP连接，但这样建立连接还是需要好几百毫秒。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/%E8%BF%9E%E6%8E%A5%E8%BF%81%E7%A7%BB.png" alt="连接迁移"></p>
<h3 id="3、队头阻塞-多路复用"><a href="#3、队头阻塞-多路复用" class="headerlink" title="3、队头阻塞/多路复用"></a>3、队头阻塞/多路复用</h3><p>  TCP 是个面向连接的协议，即发送请求后需要收到 ACK 消息，如果每次请求都要收到上次请求的 ACK 消息后再请求，无疑效率很低。</p>
<p>  后来http1.1 做了改进，允许一个TCP连接同时发送多个请求，在这个背景下，谈谈http1.1的队头阻塞：一个TCP连接同时传输了 10 个请求，其中 1、2、3个请求已经被客户端接收，但是第 4 个请求丢失，那么后面第 5~10 个请求都被阻塞，需要等第 4 个请求处理完毕才能被处理，这样就浪费了带宽。因此，http一般又允许 6 个TCP 连接，这样可以更加充分利用 带宽，但是每个连接中队头阻塞的问题还是存在。</p>
<p>  http2 的多路复用解决了 http1.x 中的队头阻塞问题，它不用等上一个请求的所有数据包传输完毕之后才能下一个请求，http2每个请求被拆分多个 Fragme 通过一条 TCP 连接同时被传输，这样即使一个请求被阻塞，也不影响其他请求，如下所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E7%9A%84%E5%90%8C%E6%97%B6%E4%BC%A0%E8%BE%93.png" alt="连接迁移"></p>
<p>由于http2 还是基于 TCP 的，虽然在上述粒度上已经解决队头阻塞，但TCP 处理数据时有严格的前后顺序，先发送的 Frame 要先被处理，这样，即使发送了 4 个请求，1，3，4 都已经到达，但是只能先处理了 1， 而 3 、 4 到了也不能被处理，这时候整条连接都被阻塞，如图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E7%9A%84%E9%98%BB%E5%A1%9E.png" alt="连接迁移"></p>
<p>不仅如此，http2基于TLS ，TLS协议也存在队头阻塞问题，因为TLS 也是基于 TCP ，它将一堆数据加密，加密完成后又拆分成多个 TCP 包传输，丢了任何一个都不能解密。</p>
<p>  那 QUIC 是如何解决的呢？有2点：</p>
<ul>
<li>QUIC 的传输单元是 Packet，加密单元也是 Packet ，整个加密、传输、解密都是基于 Packet，这样就能避免 TLS 的队头阻塞    </li>
<li>QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间丢失了包，也不会阻塞整条连接。</li>
</ul>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>TCP 的拥塞控制就3个方法： 慢启动、拥塞避免、快速恢复 （博客中应该写错了）</p>
<p>QUIC 可以在应用层修改 拥塞控制策略；而TCP 要修改的话，只能在系统层面，</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP 会对每个TCP 连接进行流量控制，意思是让对方不要发送太快，TCP 主要通过 滑动窗口 来实现这个功能。</p>
<p>QUIC 只需要建立一条连接，这条连接同时传输多条 Stream ，好比一条路，两头分别有仓库，道路中间很多车辆运送物资。QUIC 流量控制有两个级别： 连接级别 和 Stream 级别。就好比纪要控制这条路的总流量，不要一下子很多车辆涌进来，货物来不及处理，也不能一辆车一下子运送很多东西，这样货物也来不及处理。那到底怎么实现呢？它的实现也与滑动窗口类似，接收方会发送 WINDOW_UPDATE frame 告诉发送方你可以再多发送些数据过来。</p>
<blockquote>
<p>以上内容参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/143464334">腾讯技术团队的博客</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/09/14/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/14/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">特别篇：自己的总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-14 19:46:00 / 修改时间：21:39:21" itemprop="dateCreated datePublished" datetime="2021-09-14T19:46:00+08:00">2021-09-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="识别插件的类"><a href="#识别插件的类" class="headerlink" title="识别插件的类"></a>识别插件的类</h2><p>方案：将所有的插件 dex 合并到 宿主中，具体步骤为：</p>
<ol>
<li><p>根据宿主的 ClassLoader，获取宿主的 dexElements 字段</p>
<blockquote>
<p>具体步骤为： 首先反射出 BaseDexClassLoader 的 pathList 字段，它是 DexPathList  类型的；第二步，反射出 DexPathList 的 dexElements 字段，他是个<strong>数组</strong>。</p>
</blockquote>
</li>
<li><p>根据插件的 dexFile ，反射出一个 Element 类型对象，这就是插件 dex</p>
</li>
<li><p>把插件 dex 和 宿主 dexElements 合并成一个新的 dex 数组，替换宿主之前的 dexElements 字段</p>
</li>
</ol>
<h2 id="欺骗系统"><a href="#欺骗系统" class="headerlink" title="欺骗系统"></a>欺骗系统</h2><p>启动时，其实是启动 PlaceHoldActivity ，将真正要启动的 TargetActivity 放在 Intent 的数据里面，主要步骤：</p>
<p>1、Hook 到 ActivityManagerNative （它里面的gDefault，这个字段是个单例），把 TargetActivity 替换为 PlaceHoldActivity    </p>
<p>2、Hook 到 H（Handler） 类的 mCallback 字段，将 PlaceHoldActivity 换成真正的 TargetActivity。或者，如果不想使用这种 Hook，可以在创建Activity （execStartActivity）对象的时候再替换回来</p>
<h2 id="资源使用"><a href="#资源使用" class="headerlink" title="资源使用"></a>资源使用</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol>
<li>通过反射，构建一个 AssetManager 对象 <font color="#CD6889">mAssetManager</font>，之后，反射调用 mAssetManager 的 addAssetPath 方法，将宿主和插件的 dexPath 全部添加进去，这样，这个新的 mAssetManager 拥有宿主以及插件中的所有的资源了。</li>
<li>根据上述的 mAssetManager 构建处一个 Resources 对象 <font color="#CD6889">mResources</font></li>
<li>使用 newTheme 创建一个 Theme 对象 <font color="#CD6889">mTheme</font></li>
<li>在 Activity 中重写 getAssets()、getResources()、getTheme() 方法，分别返回上述的mAssetManager、mResources、mTheme</li>
</ol>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void loadResources(){</span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        AssetManager assetManager= AssetManager.<span class="keyword">class</span>.newInstance();</span><br><span class="line">        Method addAssetPath = assetManager.getClass().getMethod(<span class="string">"addAssetPath"</span>,String.<span class="keyword">class</span>);</span><br><span class="line">        addAssetPath.invoke(assetManager, dexPath);</span><br><span class="line">        mAssetManager = assetManager;</span><br><span class="line">    }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    Resources superResources = <span class="keyword">super</span>.getResources();</span><br><span class="line">    mResources = new Resources(mAssetManager, superResources.getDisplayMetrics(), superResources.getConfiguration());</span><br><span class="line">    mTheme = mResources.newTheme();</span><br><span class="line">    mTheme.setTo(<span class="keyword">super</span>.getTheme());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AssetManager getAssets() {</span><br><span class="line">    <span class="keyword">if</span> (mAssetManager == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getAssets();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> mAssetManager;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resources getResources() {</span><br><span class="line">    <span class="keyword">if</span> (mResources == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getResources();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> mResources;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resources.Theme getTheme() {</span><br><span class="line">    <span class="keyword">if</span> (mTheme == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getTheme();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> mTheme;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>注意一点，由于将所有资源集合在一块，所以资源id可能冲突</strong>，解决方案：修改AAPT命令，将宿主和插件之间的id前缀都区分开，比如宿主的资源id以 0x71 开头，插件1以 0x72，插件2以 0x73  等，避免冲突。</p>
<p><strong>还有</strong>，如果插件需要使用宿主的资源，那么，可以在宿主中将id写死，具体方式为自定义一个public.xml ，在里面写死。然后插件中以 provided 的方式将宿主的aar引入（这样，打包的时候就不会将这个aar打进去），引用资源的时候，直接使用这个写死的id就行。</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--public.xml--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"&gt;</span></span><br><span class="line"><span class="meta">&lt;resources&gt;</span></span><br><span class="line"><span class="meta">    &lt;public type="string" name="welcom" id="0x71050024"/&gt;</span></span><br><span class="line"><span class="meta">&lt;/resources&gt;</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="启动模式（LaunchMode）"><a href="#启动模式（LaunchMode）" class="headerlink" title="启动模式（LaunchMode）"></a>启动模式（LaunchMode）</h2><p>普通使用的都是Standard 模式，如果要解决其他 3 种 LaunchMode 问题，使用的是<strong>占位Activity的思想</strong>，即事先为这3种 LaunchMode 创建很多 PlaceHoldActivity。比如：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SingleInstancePlaceHoldActivity1</span><br><span class="line">SingleInstancePlaceHoldActivity2</span><br><span class="line">SingleInstancePlaceHoldActivity3</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">SingleTaskPlaceHoldActivity1</span><br><span class="line">SingleTaskPlaceHoldActivity2</span><br><span class="line">SingleTaskPlaceHoldActivity3</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">SingleTopPlaceHoldActivity1</span><br><span class="line">SingleTopPlaceHoldActivity2</span><br><span class="line">SingleTopPlaceHoldActivity3</span><br></pre></td></tr></tbody></table></figure>



<p>接下来，从服务器下载一个 Json ，指定插件Activity 要使用哪个 PlaceHoldActivity ，这里所说的 Activity 只包括 LauncherMode 为 SingleTop、SingleTask、SingleInstance 的 Activity。我们无法指定插件 Activity 的 LaunchMode ，但是通过这种指定占位，<strong>当 ActivityA 和 SingleTaskPlaceHoldActivity1 建立对应关系之后，ActivityA 的 LaunchMode 就是 SingleTask 了！</strong></p>
<p>但是这里还有个小bug，无论是SingleTop 还是 SingleTask ，再回到这个Activity时，并不会触发它的 onCreate ，而是触发 它的 onNewIntent 方法！为此，<strong>我们需要在Hook的 Handler.Callback 中拦截 onNewIntent 方法，把占位的 PlaceHoldActivity 替换回插件Activity</strong>： </p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockClass2</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>{</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">    <span class="keyword">switch</span>(msg.what) {</span><br><span class="line">      <span class="keyword">case</span> <span class="number">112</span>:</span><br><span class="line">        handleNewIntent(msg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleNewIntent</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">    Object obj = msg.obj;</span><br><span class="line">    ArrayList intents = (ArrayList)RefInvoke.getFieldObject(obj, <span class="string">"intents"</span>);</span><br><span class="line">    <span class="keyword">for</span>(Object object: intents) {</span><br><span class="line">      Intent raw = (Intent)object;</span><br><span class="line">      Intent target = raw.getParcelableExtra(AMSHookHelper.EXTRA_TARGET_INTENT);</span><br><span class="line">      <span class="keyword">if</span>(target != <span class="keyword">null</span>) {</span><br><span class="line">        raw.setComponent(target.getComponent());</span><br><span class="line">        <span class="keyword">if</span>(target.getExtras() != <span class="keyword">null</span>) {</span><br><span class="line">          raw.putExtras(target.getExtras());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/09/10/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC7%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/10/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC7%E7%AB%A0/" class="post-title-link" itemprop="url">第7章：多态和扩展</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-10 19:29:00 / 修改时间：21:30:53" itemprop="dateCreated datePublished" datetime="2021-09-10T19:29:00+08:00">2021-09-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="多态的不同方式"><a href="#多态的不同方式" class="headerlink" title="多态的不同方式"></a>多态的不同方式</h2><p>当一个子类继承父类的时候，这就是<strong>子类型多态</strong>；另一种熟悉的多态是<strong>参数多态</strong>，泛型就是参数多态常见的形式。</p>
<h3 id="对第三方类扩展"><a href="#对第三方类扩展" class="headerlink" title="对第三方类扩展"></a>对第三方类扩展</h3><p>考虑业务类 ClassA、ClassB是第三方引入的并且<strong>不能修改</strong>，如果我们想要给它们扩展一些方法，比如将对象转换为 Json 字符串，那么利用以前多态技术就会显得麻烦。幸运的是，Kotlin 支持扩展语法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> ClassA.<span class="title">toJson</span><span class="params">()</span></span>: String = {</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>就可以很方便地添加了toJson方法，需要注意的是，<strong>扩展属性和方法的实现运行在ClassA的实例</strong>，他们的定义操作不会修改 ClassA 类本身，所以被扩展的第三方类免于被污染。</p>
<h3 id="特设多态与运算符重载"><a href="#特设多态与运算符重载" class="headerlink" title="特设多态与运算符重载"></a>特设多态与运算符重载</h3><p>除了子类型多态、参数多态外，还有一种灵活的多态——<strong>特设多态</strong>。可能概念不好理解，举个具体的例子，你想定义一个通用的sum方法，也许会这么写：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">sum</span><span class="params">(x: <span class="type">T</span>, y: <span class="type">T</span>)</span></span>: T = x + y</span><br></pre></td></tr></tbody></table></figure>

<p>但编译器会报错，因为某些类型不一定支持加法操作。这时候，我们希望定义一种通用的“加法语义上的操作”，可以定义一个通用的 Summable 接口，然后让需要支持假发操作的类来实现它：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sumable</span>&lt;<span class="type">T</span>&gt; </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">plusThat</span><span class="params">(that: <span class="type">T</span>)</span></span>: T</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Len</span></span>(<span class="keyword">val</span> v: <span class="built_in">Int</span>): Sumable&lt;Len&gt; {</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">plusThat</span><span class="params">(that: <span class="type">Len</span>)</span></span> = Len(<span class="keyword">this</span>.v + that.v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以发现，这并没有什么问题。然而，如果要针对不可修改的第三方类扩展加法操作时，这种方式也会遇到问题。于是，又想到了Kotlin的扩展，针对以上例子，我们完全可以采用扩展的语法来解决问题，此外，Kotlin 原生支持<strong>运算符重载</strong>可以很好解决上述问题：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Area</span></span>(<span class="keyword">val</span> value: <span class="built_in">Double</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Area.<span class="title">plus</span><span class="params">(that: <span class="type">Area</span>)</span></span>: Area {</span><br><span class="line">  <span class="keyword">return</span> Area(<span class="keyword">this</span>.value + that.value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">  println(Area(<span class="number">1.0</span>) + Area(<span class="number">2.0</span>)) <span class="comment">//运行结果： Area(value=3.0)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过 operator 关键字以及Kotlin中<strong>内置可重载的运算符plus</strong>，就实现了功能。operator 的作用是，将一个函数标记为重载一个操作符或者实现一个约定，这里的<strong>plus是Kotlin规定的函数名</strong>。除了plus，我们还可以通过重载减法(minus)、乘法(times)、触发(div)、取余(mod，在kotlin 1.1 版本开始被 rem 替代)。此外，回忆kotlin中常用语法，也是用这种神奇的语言特性实现的，比如：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">in</span> list<span class="comment">// 转换为 list.contains(a)</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="扩展：-为别的类添加方法、属性"><a href="#扩展：-为别的类添加方法、属性" class="headerlink" title="扩展： 为别的类添加方法、属性"></a>扩展： 为别的类添加方法、属性</h2><p>继续深入Kotlin 的特设多态语言特性</p>
<h3 id="扩展与开放封闭原则"><a href="#扩展与开放封闭原则" class="headerlink" title="扩展与开放封闭原则"></a>扩展与开放封闭原则</h3><p>熟悉设计模式的读者知道，在修改现有代码时，我们应该遵循开放封闭原则，对扩展开放，对修改封闭。然而实际并不乐观，比如Android开发，为实现某个需求，引入了第三方库，但是需求发生变动后，当前库无法满足需求，且库的作者没有升级计划。这时候你也许就会考虑对源码修改，这就违背了开放封闭原则。</p>
<p>Java中一种惯常做法是继承第三方类，添加新功能，但是，强行的继承可能违背“里氏替换原则”。更合理的方案，就是通过Kotlin的扩展功能。</p>
<h3 id="使用扩展函数、属性"><a href="#使用扩展函数、属性" class="headerlink" title="使用扩展函数、属性"></a>使用扩展函数、属性</h3><p>扩展函数的声明的关键字是 <type> 。此外，我们需要一个“接收者类型”（通常是类或者接口）来作为它的前缀，以为 MutableList<int>扩展exchange方法为例：</int></type></p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">exchange</span><span class="params">(fromIndex: <span class="type">Int</span>, toIndex: <span class="type">Int</span>)</span></span> {</span><br><span class="line">  <span class="keyword">val</span> temp = <span class="keyword">this</span>[fromIndex]</span><br><span class="line">  <span class="keyword">this</span>[fromIndex] = <span class="keyword">this</span>[toIndex]</span><br><span class="line">  <span class="keyword">this</span>[toIndex] = temp</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>MutableList<t> 是Kotlin标准库中的类，这里作为接收者类型，exchange是扩展函数名。Kotlin的this要比Java的更灵活，这里扩展函数体内的this代表的是<strong>接收者类型的对象</strong>。注意，Kotlin中是严格区分接收者是否可空的，<strong>如果你的函数是可空的，你需要重写一个可空类型的扩展函数</strong>。</t></p>
<h4 id="扩展函数的实现机制"><a href="#扩展函数的实现机制" class="headerlink" title="扩展函数的实现机制"></a>扩展函数的实现机制</h4><p>扩展函数这么方便，会不会对性能造成影响呢？以 MutableList<int>.exchange 为例，对应的Java代码为：</int></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Metadata(</span></span><br><span class="line"><span class="meta">   mv = {1, 5, 1},</span></span><br><span class="line"><span class="meta">   k = 2,</span></span><br><span class="line"><span class="meta">   d1 = {"\u0000\u0012\n\u0000\n\u0002\u0010\u0002\n\u0002\u0010!\n\u0002\u0010\b\n\u0002\b\u0003\u001a \u0010\u0000\u001a\u00020\u0001*\b\u0012\u0004\u0012\u00020\u00030\u00022\u0006\u0010\u0004\u001a\u00020\u00032\u0006\u0010\u0005\u001a\u00020\u0003¨\u0006\u0006"},</span></span><br><span class="line"><span class="meta">   d2 = {"exchange", "", "", "", "fromIndex", "toIndex", "CommoKotlin"}</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KotClassKt</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="meta">@NotNull</span> List $<span class="keyword">this</span>$exchange, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>{</span><br><span class="line">      Intrinsics.checkNotNullParameter($<span class="keyword">this</span>$exchange, <span class="string">"$this$exchange"</span>);</span><br><span class="line">      <span class="keyword">int</span> temp = ((Number)$<span class="keyword">this</span>$exchange.get(fromIndex)).intValue();</span><br><span class="line">      $<span class="keyword">this</span>$exchange.set(fromIndex, $<span class="keyword">this</span>$exchange.get(toIndex));</span><br><span class="line">      $<span class="keyword">this</span>$exchange.set(toIndex, temp);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>结合上述Java代码可以看出，我们可以将扩展函数近似理解为<strong>静态方法</strong>。我们知道静态方法的特点：不依赖类的特定实例，被该类所有的实例共享，并且，用public修饰，本质上也就是个全局方法，所以，<strong>扩展函数不会带来额外的性能消耗</strong>。</p>
<h4 id="扩展函数的作用域"><a href="#扩展函数的作用域" class="headerlink" title="扩展函数的作用域"></a>扩展函数的作用域</h4><p>一般来说，我们习惯将扩展函数直接定义在包内，例如之前的 exchange 例子，我们可以将其放在 com.example.extension包下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.extension</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">exchange</span><span class="params">(fromIndex: <span class="type">Int</span>, toIndex: <span class="type">Int</span>)</span></span> {</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们知道，<strong>在同一个包内是可以直接调用exchange方法的，如果需要在其他包中调用，只需要import即可</strong>，这与Java全局静态方法类似。与此同时，在实际开发中，我们可能会将扩展函数定义在一个 Class 内部统一管理：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extends</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">exchange</span><span class="params">(fromIndex: <span class="type">Int</span>, toIndex: <span class="type">Int</span>)</span></span> {</span><br><span class="line">        <span class="keyword">val</span> temp = <span class="keyword">this</span>[fromIndex]</span><br><span class="line">        <span class="keyword">this</span>[fromIndex] = <span class="keyword">this</span>[toIndex]</span><br><span class="line">        <span class="keyword">this</span>[toIndex] = temp</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但你会发现，之前的exchange方法无法调用了！我们看下它的Java源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Metadata(</span></span><br><span class="line"><span class="meta">   mv = {1, 5, 1},</span></span><br><span class="line"><span class="meta">   k = 1,</span></span><br><span class="line"><span class="meta">   d1 = {"\u0000\u001c\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\b\u0002\n\u0002\u0010\u0002\n\u0002\u0010!\n\u0002\u0010\b\n\u0002\b\u0003\u0018\u00002\u00020\u0001B\u0005¢\u0006\u0002\u0010\u0002J \u0010\u0003\u001a\u00020\u0004*\b\u0012\u0004\u0012\u00020\u00060\u00052\u0006\u0010\u0007\u001a\u00020\u00062\u0006\u0010\b\u001a\u00020\u0006¨\u0006\t"},</span></span><br><span class="line"><span class="meta">   d2 = {"Lcom/glassx/Extends;", "", "()V", "exchange", "", "", "", "fromIndex", "toIndex", "CommoKotlin"}</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Extends</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="meta">@NotNull</span> List $<span class="keyword">this</span>$exchange, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>{</span><br><span class="line">      Intrinsics.checkNotNullParameter($<span class="keyword">this</span>$exchange, <span class="string">"$this$exchange"</span>);</span><br><span class="line">      <span class="keyword">int</span> temp = ((Number)$<span class="keyword">this</span>$exchange.get(fromIndex)).intValue();</span><br><span class="line">      $<span class="keyword">this</span>$exchange.set(fromIndex, $<span class="keyword">this</span>$exchange.get(toIndex));</span><br><span class="line">      $<span class="keyword">this</span>$exchange.set(toIndex, temp);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们才发现exchange方法没有static关键字了，所以，<strong>当扩展方法在一个 Class 内部时，我们只能在该类和该类的子类中调用</strong>。</p>
<h3 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h3><p>与扩展函数一样，我们还能为一个类添加扩展属性，比如为MutableList<int>添加一个判断和是否为偶数的属性：</int></p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> MutableList&lt;<span class="built_in">Int</span>&gt;.sumIsEven: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.sum() % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">list.sumIsEven</span><br></pre></td></tr></tbody></table></figure>

<p>但是，如果你准备给这个属性添加默认值，并且写出如下代码：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> MutableList&lt;<span class="built_in">Int</span>&gt;.sumIsEven: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.sum() % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<p>代码会编译不通过，告知扩展属性不能有初始化器。这是为什么呢？其实，与扩展函数一样，其本质也是对应Java中的静态方法，反编译成Java后，会看到一个 getSumIsEven 的静态方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Metadata(</span></span><br><span class="line"><span class="meta">   mv = {1, 5, 1},</span></span><br><span class="line"><span class="meta">   k = 2,</span></span><br><span class="line"><span class="meta">   d1 = {"\u0000\u0012\n\u0000\n\u0002\u0010\u000b\n\u0002\u0010!\n\u0002\u0010\b\n\u0002\b\u0003\"\u001b\u0010\u0000\u001a\u00020\u0001*\b\u0012\u0004\u0012\u00020\u00030\u00028F¢\u0006\u0006\u001a\u0004\b\u0004\u0010\u0005¨\u0006\u0006"},</span></span><br><span class="line"><span class="meta">   d2 = {"sumIsEven", "", "", "", "getSumIsEven", "(Ljava/util/List;)Z", "CommoKotlin"}</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsKt</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">getSumIsEven</span><span class="params">(<span class="meta">@NotNull</span> List $<span class="keyword">this</span>$sumIsEven)</span> </span>{</span><br><span class="line">      Intrinsics.checkNotNullParameter($<span class="keyword">this</span>$sumIsEven, <span class="string">"$this$sumIsEven"</span>);</span><br><span class="line">      <span class="keyword">return</span> CollectionsKt.sumOfInt((Iterable)$<span class="keyword">this</span>$sumIsEven) % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>由于扩展没有实际地将成员插入类中，因此对扩展属性来说幕后字段是无效的，它们的行为只能由显式提供的 getters 和setters 定义</strong>。</p>
<blockquote>
<p>幕后字段：如果属性中存在访问器使用默认实现，那么Kotlin 会自动提供幕后字段 field ，其仅可用于 getter 和 setter 中。</p>
</blockquote>
<h3 id="扩展的特殊情况"><a href="#扩展的特殊情况" class="headerlink" title="扩展的特殊情况"></a>扩展的特殊情况</h3><h4 id="类似Java的静态扩展函数"><a href="#类似Java的静态扩展函数" class="headerlink" title="类似Java的静态扩展函数"></a>类似Java的静态扩展函数</h4><p>在Kotlin中，如果要声明一个静态的扩展函数，必须要有 伴生对象（companion object）上，所以我们要这样定义带有伴生对象的类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>{</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> {</span><br><span class="line">    <span class="keyword">val</span> age = <span class="number">10</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在已有伴生对象的情况下，如果不想再Son中定义扩展函数，而是在Son的伴生对象上定义，可以这么写：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Son.Companion.<span class="title">foo</span><span class="params">()</span></span> {</span><br><span class="line">  println(<span class="string">"age = <span class="variable">$age</span>"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样在没有Son的实例对象的情况下，也能调用，使用：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">  Son.foo()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="成员方法优先级总是高于扩展函数"><a href="#成员方法优先级总是高于扩展函数" class="headerlink" title="成员方法优先级总是高于扩展函数"></a>成员方法优先级总是高于扩展函数</h4><p>如果扩展函数和现有类的成员方法一样，那么<strong>优先调用成员方法</strong>，这一点好理解，我们不应该更改原有实现。</p>
<h4 id="类的实例与接收者实例"><a href="#类的实例与接收者实例" class="headerlink" title="类的实例与接收者实例"></a>类的实例与接收者实例</h4><p>略，没看清楚表达什么</p>
<h3 id="标准库中的扩展函数：run、let、also、takeIf"><a href="#标准库中的扩展函数：run、let、also、takeIf" class="headerlink" title="标准库中的扩展函数：run、let、also、takeIf"></a>标准库中的扩展函数：run、let、also、takeIf</h3><p>略</p>
<h2 id="Android中扩展的应用"><a href="#Android中扩展的应用" class="headerlink" title="Android中扩展的应用"></a>Android中扩展的应用</h2><p>略</p>
<h2 id="扩展不是万能的"><a href="#扩展不是万能的" class="headerlink" title="扩展不是万能的"></a>扩展不是万能的</h2><p>略</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/09/06/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/06/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">第5章：类型系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-06 20:40:00 / 修改时间：20:41:13" itemprop="dateCreated datePublished" datetime="2021-09-06T20:40:00+08:00">2021-09-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="null引用"><a href="#null引用" class="headerlink" title="null引用"></a>null引用</h2><h3 id="null-做了哪些恶"><a href="#null-做了哪些恶" class="headerlink" title="null 做了哪些恶"></a>null 做了哪些恶</h3><ul>
<li><p>null 存在歧义，一个值为null可以代表很多含义，比如：未初始化、值不合法、值不需要、值不存在    </p>
<blockquote>
<p>一个典型的例子就是 HashMap 保存数据，Java中的HashMap允许 key 为null，比如一个教室，我们将座位号与坐在上面的人保存到HashMap中，在获取这些位置信息的时候，null就产生了歧义，到底是座位不存在还是座位没人。</p>
</blockquote>
</li>
<li><p>难以避免的 NPE</p>
</li>
<li><p>冗余的防御使代码，各种判空</p>
</li>
</ul>
<h2 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h2><p>Java8里面有Optional ，这个不作讨论。</p>
<h3 id="Kotlin的可空类型"><a href="#Kotlin的可空类型" class="headerlink" title="Kotlin的可空类型"></a>Kotlin的可空类型</h3><p>在Kotlin中，我们可以在任何类型后面加上 ? ，比如 “Int?”，实际等同于 “Int? = Int or null”</p>
<ol>
<li><p>安全的调用 ?.</p>
</li>
<li><p>Kotlin的Elvis操作符（也称为合并运算符） ?:  ，比如，学生不戴眼镜，度数就为 -1，则可以类似如下表示：</p>
</li>
</ol>
<blockquote>
<p>val result = student.glasses?.degreeOfMyopia ?: -1</p>
</blockquote>
<ol start="3">
<li>非空断言 !!  ，有时候我们想确保一个学生是戴眼镜的，那么: <code>val result = student!!.glasses</code></li>
</ol>
<p>其中，关于第2点，Kotlin能够这样写，具体实现其实还是根据 if-else 去逐层判断，并没有什么魔法。这样判断的原因无非就是：兼容Java、性能考虑</p>
<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p>在经过is判断会后之后使用就无须强制转换，如下使用方法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span>(obj) {</span><br><span class="line">	<span class="keyword">is</span> String -&gt; print(obj.length)</span><br><span class="line">	<span class="keyword">else</span> -&gt; print(<span class="string">"not a String"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="智能类型转换"><a href="#智能类型转换" class="headerlink" title="智能类型转换"></a>智能类型转换</h3><p>除了上述的智能转换，对于可空类型我们也可以使用 Smart Casts：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stu: Student = Student(Glasses(<span class="number">189.00</span>))</span><br><span class="line"><span class="keyword">if</span>(stu.glasses != <span class="literal">null</span>) println(stu.glasses.degreeOfMyopia)</span><br></pre></td></tr></tbody></table></figure>

<p>不过，根据官方文档，<strong>当且仅当Kotlin编译器确定在类型检查后该变量不会再改变，才会产生Smart Casts</strong>。利用这点，我们能够确保多线程应用安全，举个例子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kot</span> </span>{</span><br><span class="line">	<span class="keyword">var</span> stu: Student? = getStu()</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">dealStu</span><span class="params">()</span></span>{</span><br><span class="line">	    <span class="keyword">if</span>(stu != <span class="literal">null</span>) {</span><br><span class="line">	    <span class="comment">//还是不能这样写，编译器会因为可能在其他线程会修改该值有风险而报错，如果 stu 改成val 的就不会有这样的情况</span></span><br><span class="line">	        print(stu.glasses)</span><br><span class="line">	    }</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当然，我们也能利用let来更优雅一点：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dealStu</span><span class="params">()</span></span>{</span><br><span class="line">	stu?.let {print(it.glasses)}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在开发过程中，难免碰到类型转换，一般使用类似：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu: Student = getStu <span class="keyword">as</span> Student?</span><br><span class="line"><span class="comment">//当然，也能使用以下方法，二者效果是一样的</span></span><br><span class="line"><span class="keyword">var</span> stu: Student = getStu <span class="keyword">as</span>? Student</span><br></pre></td></tr></tbody></table></figure>

<p>除此之外，有些同学可能会认为需要频繁类型转换，所以会配合泛型封装一个“有效的”类型转换方法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">cast</span><span class="params">(original: <span class="type">Any</span>)</span></span>: T? = original <span class="keyword">as</span>? T</span><br></pre></td></tr></tbody></table></figure>

<p>使用上了 as? ，看起来没问题，那我们应该可以这样用：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ans = cast&lt;String&gt;(<span class="number">140163L</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>用法看起来也挺合理，但是在调用的时候，会抛出 Long cannot be cast to String 这样的异常。这其实是类型擦除的后果。Kotlin的设计者们同样注意到这点，加入了 <strong>reified</strong>关键字，可以理解为<strong>具体化</strong>，利用它我们可以在方法体内访问泛型指定的 JVM 对象(注意，还要在方法前加入 inline 修饰)。代码使用如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">cast</span><span class="params">(original: <span class="type">Any</span>)</span></span>: T? = original <span class="keyword">as</span>? T</span><br></pre></td></tr></tbody></table></figure>

<h2 id="比Java-更面向对象的设计"><a href="#比Java-更面向对象的设计" class="headerlink" title="比Java 更面向对象的设计"></a>比Java 更面向对象的设计</h2><p>Java并不能真正意义上被称作一门“纯面向对象”的语言，因为它的原始类型（如int）的值与函数并不能视作对象。</p>
<h3 id="Any：-非空类型的根类型"><a href="#Any：-非空类型的根类型" class="headerlink" title="Any： 非空类型的根类型"></a>Any： 非空类型的根类型</h3><p>与Object 作为 Java类层级的顶层类似，Any类型是Kotlin中所有非空类型（如String、Int）的超类。与Java不同，Kotlin不区分原始类型和其他类型，Koltin中，<strong>所有类型的最终根类型都是Any</strong>。另外，<strong>Kotlin把Java方法参数和返回类型中用到的Object类型看做 Any ，当Kotlin函数中使用Any时，它会被编译成 Java字节码中的 Object</strong>。</p>
<h3 id="Any-：所有类型的根类型"><a href="#Any-：所有类型的根类型" class="headerlink" title="Any?：所有类型的根类型"></a>Any?：所有类型的根类型</h3><p>如果说Any是所有非空类型的根类型，那么 Any? 才是所有类型(可空和非空类型)的根类型。如果只有Java这门编程语言的经验，很容易陷入一个误区：继承关系决定父子类型关系。因为在Java中，类与类型大部分情况下都是“等价的”。</p>
<p>事实上，“继承”和“子类型化”是两个完全不同的概念。如Kotlin中的Int是Number的子类，那么在需要Number类型的地方传入 Int类型是没问题的。这是“继承”强调的“实现上的复用”。而子类型化是一种类型语义的关系，与实现没关系。<strong>虽然Any 与 Any? 看起来没有继承关系，然而在我们需要用 Any? 类型值的地方，显然可以传入一个类型为 Any 的值，反之却不然！</strong></p>
<p>所以，我们可以大胆地说，Any？ 是 Any 的父类型，而且是所有类型的根类型。</p>
<blockquote>
<p>Any? 与 Any??。 你可能会问，那 Any??是不是 Any? 的父类型？如果成立，岂不是意味着没有所谓的所有类型的根类型了？其实，Kotlin的可空类型可以看做数学上的并集。如果用类型的并集表示 Any ，可以写成  Any U Null ，那么 Any?? 就可以写成 Any U Null U Null ，等价于 Any U Null ，即 Any??等价于 Any? 。</p>
</blockquote>
<h3 id="Nothing-与-Nothing"><a href="#Nothing-与-Nothing" class="headerlink" title="Nothing 与 Nothing?"></a>Nothing 与 Nothing?</h3><p>顾名思义，Nothing是没有实例的类型。<strong>Kotlin 中 return、throw等（流程控制中与跳转相关的表达式）返回值都是 Nothing。</strong>Nothing 只能包含一个值：null，本质上与null没有区别，所以我们可以使用null作为任何可空类型的值。</p>
<h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p>Kotlin 中没有 int、float、double、long这类的原始类型，取而代之的是它们对应的引用类型包装类： Int、Float、Double、Long。看起来让Kotlin比Java更加接近纯面向对象设计，但这样说其实是不够严谨的。</p>
<p>以Int 为例，虽然它可以像Integer 一样提供额外的操作函数，但这两个类型在底层实现上存在差异，看一段代码：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x1 = <span class="number">18</span> <span class="comment">//kotlin</span></span><br><span class="line">int x2 = <span class="number">18</span>;<span class="comment">//Java</span></span><br><span class="line">Integer x3 = <span class="number">18</span>;<span class="comment">//Java</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是我们观察 Kotlin <strong>编译完成后的字节码可以发现，Kotlin中的Int在JVM中实际以int 存储(对应字节码类型为 I)</strong>。但是作为一个“包装类型”，Int编译后应该装箱才对，难道Kotlin不会自动装箱？其实可以再看看 Int? 的字节码，就可以得出结论：</p>
<ul>
<li><strong>Kotlin 中的 Int 类型等同于 int</strong></li>
<li><strong>Kotlin 中的 Int? 等同于 Integer ！</strong></li>
</ul>
<p>Int 作为一种小技巧，让Int看起来是引用类型。</p>
<h3 id="“新”的数组类型"><a href="#“新”的数组类型" class="headerlink" title="“新”的数组类型"></a>“新”的数组类型</h3><p>Kotlin 中可以这样创造数组：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> funList = arrayOf()<span class="comment">//声明长度为0的数组</span></span><br><span class="line"><span class="keyword">val</span> funList = arrayOf(n1,n2,n3,....nt)<span class="comment">//声明并初始化长度t的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于Smart Casts ，编译器能够推出funList的元素类型。当然，我们也能手动指定：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> funList = arrayOf&lt;T&gt;(n1,n2,...nt)</span><br><span class="line"></span><br><span class="line"><span class="comment">//与array类似，我们可以这样定义原始类型的数组</span></span><br><span class="line"><span class="keyword">val</span> xArray = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>要注意的是，IntArray等类型并不是 Array的子类。还有，<strong>Kotlin对原始类型的特殊优化，主要体现在避免了自动装箱带来的开销！</strong></p>
<h2 id="泛型：-让类型更安全"><a href="#泛型：-让类型更安全" class="headerlink" title="泛型： 让类型更安全"></a>泛型： 让类型更安全</h2><p>首先，Kotlin中也有泛型。</p>
<h3 id="泛型：类型安全的利刃"><a href="#泛型：类型安全的利刃" class="headerlink" title="泛型：类型安全的利刃"></a>泛型：类型安全的利刃</h3><p>大家都知道1.5以前的Java的List需要靠强制转换来取值的，并且可以存入各种各样类型的值，在编译期还发现不了，这就很难受了。所以后来就出了泛型，泛型主要优势有几点：</p>
<ul>
<li>类型检查，在编译时就检查出错误。</li>
<li>更加语义化，List<string>便可以知道里面存储的是 String 类型。<br>自动类型转换，获取数据时不需要手动强转，更安全。</string></li>
<li>能写出更通用的代码。</li>
</ul>
<h3 id="Kotlin中使用泛型"><a href="#Kotlin中使用泛型" class="headerlink" title="Kotlin中使用泛型"></a>Kotlin中使用泛型</h3><p>首先，在Kotlin中，使用 <code>val arrayListt = ArrayList()</code> 这种方式是不允许的，但在Java中可以这么做，这是因为在Java中 1.5版本后才引入的，Java为了兼容可以这么做。但是，由于Kotlin具有类型推导能力，所以 <code>val arrayListt = arrayListOf("one","two")</code> 是允许的。</p>
<h3 id="类型约束：设定类型上界"><a href="#类型约束：设定类型上界" class="headerlink" title="类型约束：设定类型上界"></a>类型约束：设定类型上界</h3><p>我们知道，泛型本身就有类型约束的作用，比如，你无法向一个String类型List中添加一个Double对象。那么这里说的是约束什么呢？用例子来看下，假设我们有一个盘子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> t: T)</span><br></pre></td></tr></tbody></table></figure>
<p>这个盘子类有一个泛型参数，表示可以接收各种东西，如水果或者主食。但是，如果有一天想把盘子归类，有些只能放水果，有些只能放菜，又该如何呢？还是看例子，我们可以定义一个水果类(Fruit)，并声明 Apple 和 Banana 来继承它，并定义出水果盘子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>(): Fruit()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span></span>(): Fruit()</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个水果盘子：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitPlate</span>&lt;<span class="type">T: Fruit</span>&gt;</span>()</span><br></pre></td></tr></tbody></table></figure>

<p>上述的FruitPlate中T被限定了只能是 Fruit 类及其子类类型，其他类则不被允许。这种约束我们叫做<strong>上界约束</strong>，和Java的语法类似，只不过java 用extends关键字。假如我们要求水果盘子不一定装水果，有时候还能空着，那应该怎么办呢？我们可以在泛型参数类型后面加一个”?”即可：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitPlate</span>&lt;<span class="type">T: Fruit?</span>&gt;</span>(<span class="keyword">val</span> t: T)</span><br></pre></td></tr></tbody></table></figure>

<p>**如果，泛型有多个条件，怎么办？比如，有一把刀，只能用来切长在地上的水果，我们可以用 where 关键字这样实现：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Ground</span></span>{}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watermelon</span></span>(): Fruit(), Ground</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">cut</span><span class="params">(t: <span class="type">T</span>)</span></span> <span class="keyword">where</span> T: Fruit, T: Ground {</span><br><span class="line">	print(<span class="string">"you can cut me"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个where关键字就限定了多个条件，水果以及长在地上。</p>
<h2 id="泛型的背后：-类型擦除"><a href="#泛型的背后：-类型擦除" class="headerlink" title="泛型的背后： 类型擦除"></a>泛型的背后： 类型擦除</h2><h3 id="Java-为何无法声明一个泛型数组"><a href="#Java-为何无法声明一个泛型数组" class="headerlink" title="Java 为何无法声明一个泛型数组"></a>Java 为何无法声明一个泛型数组</h3><p>我们看个简单的例子，Apple是Fruit的子类：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Apple[] appleArray = <span class="keyword">new</span> Apple[<span class="number">10</span>];</span><br><span class="line">Fruit[] fruitArray = appleArray;<span class="comment">//允许的</span></span><br><span class="line">fruitArray[<span class="number">0</span>] = <span class="keyword">new</span> Banana();<span class="comment">//编译通过，运行报错</span></span><br><span class="line"></span><br><span class="line">List&lt;Apple&gt; appleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Fruit&gt; fruitList = appleList;<span class="comment">//不允许</span></span><br></pre></td></tr></tbody></table></figure>

<p>为什么数组可以这么做，而List就不行呢？关键的一点，<strong>数组是协变的，而List是不变的</strong>，换句话说，Object[] 是所有对象数组的父类，而 List<object> 却不是 List<t>的父类！我们知道Java中的List会类型擦除，具体表现如下：<p></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(appleArray.getClass());</span><br><span class="line">println(appleList.getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> [<span class="title">Ljavat</span>.<span class="title">Apple</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">ArrayList</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>Kotlin与Java这个机制是一样的，也会存在类型擦除。但与Java不同的是，<strong>Kotlin中的数组是支持泛型的，当然也不再协变</strong>。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> appleArray = arrayOfNulls&lt;Apple&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">val</span> anyArray: Array&lt;Any?&gt; = appleArray <span class="comment">//不允许</span></span><br></pre></td></tr></tbody></table></figure>

<p>这又是为什么呢？</p>
<h3 id="向后兼容的罪"><a href="#向后兼容的罪" class="headerlink" title="向后兼容的罪"></a>向后兼容的罪</h3><p>Java的list使用类型擦除是为了兼容老版本。既然类型擦除了，为什么我们在使用泛型的时候，能够进行类型检查，类型自动转呢？这是因为类型检查这些操作在编译器编译前就检查了，所以类型擦除不影响它。然后，我们可以发现，List 的get方法其实也是通过强制转换类型来实现的！</p>
<h3 id="类型擦除的矛盾"><a href="#类型擦除的矛盾" class="headerlink" title="类型擦除的矛盾"></a>类型擦除的矛盾</h3><p>通常情况使用泛型我们不在意它的擦除，但是在序列化/反序列化的时候，我们就需要知道类型了，咋办？既然编译后会擦除泛型参数类型，那么我们是不是可以主动指定参数类型来达到运行时获取泛型参数类型效果呢？看下例子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接着上面的Plate的代码写</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="type">T</span>&gt; </span>(<span class="keyword">val</span> t: T, <span class="keyword">val</span> clazz: Class&lt;T&gt;) {</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">()</span></span>{</span><br><span class="line">	    print(clazz)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">val</span> applePlate = Plate(Apple(), Apple::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">applePlate.getType()<span class="comment">//会打印 class Apple</span></span><br></pre></td></tr></tbody></table></figure>

<p>上述方法可以解决很多问题了，但是它无法获取泛型的类型，比如：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> type = ArraList&lt;String&gt;::<span class="keyword">class</span>.java<span class="comment">//不被允许</span></span><br></pre></td></tr></tbody></table></figure>

<p>有没有其他方式呢？有，可以利用匿名内部类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = ArraList&lt;String&gt;()</span><br><span class="line"><span class="keyword">val</span> list2 = <span class="keyword">object</span>: ArrayList&lt;String&gt;(){}<span class="comment">//匿名内部类</span></span><br><span class="line"></span><br><span class="line">println(list1.javaClass.genericSuperclass)</span><br><span class="line">println(list2.javaClass.genericSuperclass)</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">java.util.AbstractList&lt;E&gt;</span><br><span class="line">javaUtil.ArrayList&lt;java.lang.String&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>竟然可以了，原理是啥呢？<strong>其实，泛型类型擦除并不是真的将全部的类型信息都擦除，还是会将类型信息放在对应 Class 的常量池的。</strong>所以，我们能通过相应的方式来获取这个类型信息，使用匿名内部类就可以实现这种需求。我们着手来设计一个能获取所有类型信息的泛型类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsToken</span>&lt;<span class="type">T</span>&gt; </span>{</span><br><span class="line">	<span class="keyword">var</span> type: Type = Any::<span class="keyword">class</span>.java</span><br><span class="line"></span><br><span class="line">	<span class="keyword">init</span> {</span><br><span class="line">	    <span class="keyword">val</span> superClass = <span class="keyword">this</span>.javaClass.genericSuperclass</span><br><span class="line">	    type = (superClass <span class="keyword">as</span> ParameterizedType).getActualTypeArguments()[<span class="number">0</span>]</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">	<span class="keyword">val</span> gt = <span class="keyword">object</span>: GenericsToken&lt;Map&lt;String,String&gt;&gt;(){}</span><br><span class="line">	print(gt.type)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">java.util.map&lt;java.lang.String, ?extends java.lang.String&gt;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>匿名内部类在初始化的时候就会绑定父类或者接口的相应信息，这样就能通过获取父类或者父接口的泛型类信息来实现我们的需求，你可以用这样一个类来获取任何泛型的类型，我们常用的Gson也是使用了相同的设计</strong>。比如，我们在Kotlin中可以这样使用Gson来进行泛型类的反序列化：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> json = ...</span><br><span class="line"><span class="keyword">val</span> rType = <span class="keyword">object</span>: TypeToken&lt;List&lt;String&gt;&gt;(){}.type</span><br><span class="line"><span class="keyword">val</span> stringList = Gson.fromJson&lt;List&lt;String&gt;&gt;(json,tType)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用内联函数获取泛型"><a href="#使用内联函数获取泛型" class="headerlink" title="使用内联函数获取泛型"></a>使用内联函数获取泛型</h3><p>其实，Kotlin中除了上述方法外，还可以通过内联函数实现。<strong>内联函数在编译的时候，便会将相应函数的字节码插入调用的地方，也就是说参数类型也会被插入字节码中</strong>。下面我们就用内联函数实现一个可以获取泛型参数的方法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">getType</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">return</span> T::<span class="keyword">class</span>.java</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>非常简单，只需要加上 reified 关键词即可。所以，我们可以在Kotlin中改进Gson的使用方式：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T: Any&gt;</span> Gson.<span class="title">fromJson</span><span class="params">(json: <span class="type">String</span>)</span></span>: T {</span><br><span class="line">	<span class="keyword">return</span> Gson().fromJson(json, T::<span class="keyword">class</span>.java)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">val</span> list = Gson.fromJson&lt;List&lt;Stirng&gt;&gt;(json)</span><br></pre></td></tr></tbody></table></figure>
<p>这里是对Gson进行了扩展，实现很优雅。注意，<strong>Java不支持内联函数，所以在Kotlin中声明的普通内联函数可以在Java中调用，被当做常规函数了；而用reified来实例化参数类型的内联函数不能在Java 中调用，因为它永远需要内联的</strong>。</p>
<h2 id="打破泛型不变"><a href="#打破泛型不变" class="headerlink" title="打破泛型不变"></a>打破泛型不变</h2><p>略吧，看迷糊了，下次补上</p>
</t></object></p></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/09/06/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E5%8D%A1%E9%A1%BF-ANR%E7%AD%89%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/06/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E5%8D%A1%E9%A1%BF-ANR%E7%AD%89%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7/" class="post-title-link" itemprop="url">卡顿、ANR、死锁线上监控</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-06 20:00:00 / 修改时间：20:27:10" itemprop="dateCreated datePublished" datetime="2021-09-06T20:00:00+08:00">2021-09-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>性能优化这块，很多人只能说出传统的分析方式，比如 ANR 分析，只会通过<strong>查看/data/arn/下的log</strong>，分析主线程堆栈、cpu、锁等信息。但是这种方法有<strong>局限性，有些高版本设备需要root权限才能访问 /data/anr/ 目录</strong>，或者，如果只是用户反馈，我们压根没法复现的情况，就很难分析问题了。</p>
<h2 id="卡顿原理与监控"><a href="#卡顿原理与监控" class="headerlink" title="卡顿原理与监控"></a>卡顿原理与监控</h2><p>卡顿原理里面需要注意的一点是：存在消息屏障的情况下，*<em>当异步消息被处理完后，如果没有及时把消息屏障消息移除，会导致同步消息一直没有机会处理，一直阻塞在nativePollOnce *</em>。</p>
<h3 id="卡顿原理"><a href="#卡顿原理" class="headerlink" title="卡顿原理"></a>卡顿原理</h3><p>首先，我们可以看下Looper.loop的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="comment">//1、取消息</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//2、消息处理前回调</span></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) {</span><br><span class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">            }</span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//3、消息开始处理</span></span><br><span class="line">            msg.target.dispatchMessage(msg);<span class="comment">// 分发处理消息</span></span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//4、消息处理完回调</span></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) {</span><br><span class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">            }</span><br><span class="line">       }</span><br><span class="line">       ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这个loop方法主线程循环，可以长时间运行，从代码可以看出导致卡顿的原因可能有两个地方：</p>
<ul>
<li>注释1处的取消息 queue.next() 阻塞     </li>
<li>注释3处 dispatchMessage 耗时太久    </li>
</ul>
<p>看下 MessageQueue#next 的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">//1、nextPollTimeoutMillis 不为0则阻塞</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="comment">// 2、先判断当前第一条消息是不是同步屏障消息，</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">//3、遇到同步屏障消息，就跳过去取后面的异步消息来处理，同步消息相当于被设立了屏障</span></span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> {</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                } <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//4、正常的消息处理，判断是否有延时</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) {</span><br><span class="line">                    <span class="comment">//4 </span></span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) {</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    }</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//5、如果此时是同步屏障，没有取到消息，那么下次循环就走到1那里去了，nativePollOnce为-1，会一直阻塞</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">          ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p>MessageQueue 是一个<strong>链表数据结构</strong>，它的 next 方法大致流程是这样的：</p>
<ol>
<li>首先判断它头结点(第一个消息)是否是同步屏障消息，如果是，则只处理异步msg，同步msg不处理   </li>
<li>如果是同步屏障的话，若没有获取到异步消息，就会走到注释5，设置 nextPollTimeoutMillis = -1 后，下次循环就会在注释 1 处阻塞     </li>
<li>如果获取到正常的 msg ，不管是同步还是异步，处理流程都一样，先在注释4处判断是否演示，如果延时，则会给 nextPollTimeoutMillis 赋值，下次循环到 1 处就会阻塞一段时间；如果不延时，则会return ，<strong>交给 handler 处理（确实是交给Handler处理： msg.target.dispatchMessage(msg) ，在这里面会 首先判断msg.callback 、其次是Handler的mCallback，最后才是交给 Handler 的 handleMessage 处理）</strong></li>
</ol>
<h3 id="简单介绍Linux-中的IO多路复用方案"><a href="#简单介绍Linux-中的IO多路复用方案" class="headerlink" title="简单介绍Linux 中的IO多路复用方案"></a>简单介绍Linux 中的IO多路复用方案</h3><p>Linux上IO多路复用方案有 <strong>select、poll、epoll</strong>，它们 3 个中 epoll 的性能表现是最优秀的，能支持的并发量也最大，简单介绍：</p>
<ul>
<li><strong>select</strong> 操作系统提供的函数，通过它，我们可以把一个<strong>文件描述符的数组发给操作系统，让操作系统去遍历，确定哪个文件描述符可以读写，然后让我们处理</strong>。    </li>
<li><strong>poll</strong>：和select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制    </li>
<li><strong>epoll</strong>： 主要针对select 做了3个优化：</li>
</ul>
<blockquote>
<p>1、内核中保存一份文件描述符集合，无序用户每次传入，只需要告诉内核修改的部分</p>
<p>2、内核通过异步IO事件唤醒而不是轮询的方式找到就绪的文件描述符    </p>
<p>3、内核仅将有IO事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合</p>
</blockquote>
<h3 id="同步屏障"><a href="#同步屏障" class="headerlink" title="同步屏障"></a>同步屏障</h3><p>Android 不允许用户调用 发送同步屏障的方法，它是hide的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* @hide</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>{</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>系统一些高优先级的操作会用到同步屏障消息，例如，View在绘制的时候，最终都要调用 ViewRootImpl 的 scheduleTraversals ，会往MessageQueue 中插入同步屏障 msg，之后在unscheduleTraversals中移除 ：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) {</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//插入同步屏障消息</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unscheduleTraversals</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) {</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//移除同步屏障消息</span></span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>为了保证View的绘制过程不被主线程其他任务影响，View在绘制之前会先往MessageQueue 中插入同步屏障消息，然后注册 Vsync 信号监听，<strong>Choreographer$FrameDisplayEventReceiver</strong>就是做这事：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title">DisplayEventReceiver</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>{</span><br><span class="line">        ...</span><br><span class="line">        Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//1、发送异步消息</span></span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 2、doFrame优先执行</span></span><br><span class="line">        doFrame(mTimestampNanos, mFrame);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>收到 Vsync 信号，注释1会发送异步消息，保证注释2中的doFrame 方法（View真正开始绘制的方法，会调用ViewRootImpl 的 doTraversal、performTraversals）优先执行。<strong>需要注意的是，App要谨慎使用异步msg，使用不当可能会<a target="_blank" rel="noopener" href="https://juejin.cn/post/6947986170135445535">出现主线程假死的问题</a>，排查也会比较困难</strong>。</p>
<h3 id="Handler-的dispatchMessage方法"><a href="#Handler-的dispatchMessage方法" class="headerlink" title="Handler 的dispatchMessage方法"></a>Handler 的dispatchMessage方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) {</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里印证了前面说的msg 处理顺序， msg.callback -&gt; Handler.mCallback -&gt; handleMessage</p>
<h2 id="卡顿监控方案"><a href="#卡顿监控方案" class="headerlink" title="卡顿监控方案"></a>卡顿监控方案</h2><h3 id="卡顿监控方案一：通过Looper-loop中的日志打印监控"><a href="#卡顿监控方案一：通过Looper-loop中的日志打印监控" class="headerlink" title="卡顿监控方案一：通过Looper.loop中的日志打印监控"></a>卡顿监控方案一：通过Looper.loop中的日志打印监控</h3><p>首先，我们可以回顾上面 Looper.loop 的源码。注释2和注释4会打印日志，中间过程3是处理msg的过程，这样两段日志之间的耗时就是msg处理的耗时。Google 为我们提供了这个接口，我们只需要 Looper.getMainLooper().setMessageLogging(printer) 设置我们自己的printer就行。需要注意的是，<strong>监听到发生卡顿之后，dispatchMessage 早已调用结束，已经出栈，此时再去获取主线程的堆栈，堆栈中是不会包含卡顿代码的！</strong>。</p>
<p>所以，<strong>我们需要在后台开一个线程，定时获取主线程堆栈，然后以时间点作为key，堆栈信息作为value，保存到Map中</strong>，发生卡顿的时候，只需要取出卡顿时间段内的堆栈信息即可。</p>
<p>不过，这种方法只适合线下使用，因其存在以下缺陷：</p>
<ul>
<li>logging.println 存在字符拼接，频繁调用会<strong>创建大量对象，造成内存抖动</strong></li>
<li><strong>获取主线程堆栈，会暂停主线程的运行</strong></li>
</ul>
<h3 id="卡顿监控方案二：字节码插桩"><a href="#卡顿监控方案二：字节码插桩" class="headerlink" title="卡顿监控方案二：字节码插桩"></a>卡顿监控方案二：字节码插桩</h3><p>通过 Gradle Plugin + ASM ，<strong>编译期在每个方法开始和结束的位置分别插入一行代码，统计方法耗时！</strong>，行业内的轮子有 <strong>微信的 Matrix 方案</strong>。</p>
<p>对于这种插桩方法，需要注意的是：</p>
<ul>
<li>避免方法数暴增。在方法的入口和出口应该插入相同的函数，在编译时提前给代码中每个方法分配一个独立的ID作为参数。</li>
<li>过滤简单函数。过滤一些直接return、i++ 之类的简单函数，并支持黑名单配置，对一些调用非常频繁的函数，需要添加到黑名单来降低整个方案对性能的消耗。</li>
</ul>
<p>微信对Matrix做了大量优化，整个包体积增大1%~2%，帧率下降 2 帧以内，对性能影响可以接收，<strong>不过依然只会在灰度包使用</strong>。</p>
<h2 id="ANR监控"><a href="#ANR监控" class="headerlink" title="ANR监控"></a>ANR监控</h2><h3 id="ANR-原理"><a href="#ANR-原理" class="headerlink" title="ANR 原理"></a>ANR 原理</h3><p>ANR的原理可以比喻成<strong>埋炸弹</strong>和<strong>拆炸弹</strong>的过程，以Service为例，在通知AMS启动服务之前，通过Handler发送演示消息，这就是埋炸弹，若是 10s 内（前台服务是20s）没人来拆炸弹，炸弹就会爆炸。在ActivityThread中创建服务对象时，调用其 onCreate 之后，就会执行remove之前发送的消息，即拆炸弹。</p>
<p>常见的ANR情形如下：</p>
<ul>
<li>Service。 前台服务在20s内未执行完成，后台服务是前台服务的10倍，200s</li>
<li>输入事件。输入事件分发超时5s，包括按键和触摸事件</li>
<li>广播。前台广播在10s内未执行完成，后台60s</li>
<li>ContentProvider。在publish过程超时10s;</li>
</ul>
<h3 id="AppErrors"><a href="#AppErrors" class="headerlink" title="AppErrors"></a>AppErrors</h3><p>所有的ANR，最终都会调用 AppErrors 的 appNotResponding 方法，主要包括几个流程：</p>
<ol>
<li>写入event log</li>
<li>写入 main log</li>
<li>生成tracesFile</li>
<li>输出ANR logcat （控制台可以看到）</li>
<li>尝试写入traceFile</li>
<li>输出drapbox</li>
<li>后台ANR，直接杀进程</li>
<li>错误报告</li>
<li>弹出ANR dialog</li>
</ol>
<p>关于ANR，可以看<a target="_blank" rel="noopener" href="http://gityuan.com/2019/04/06/android-anr/">gityuan的《彻底理解安卓应用五响应机制》</a></p>
<h3 id="ANR分析方法：导出ANR文件"><a href="#ANR分析方法：导出ANR文件" class="headerlink" title="ANR分析方法：导出ANR文件"></a>ANR分析方法：导出ANR文件</h3><p>导出ANR文件，即导出/data/anr/traces.txt文件，首先查看主线程，搜索main：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55c5c9e9b60743de9f10d5372ac7087b~tplv-k3u1fbpfcp-zoom-1.image" alt="搜索main示意"></p>
<p>ANR日志有很多信息，可以看到主线程id是1（tid=1），在等待一个锁，这个锁一直被id为22的线程持有，再来看看22号线程的堆栈：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a9e111b93404118bd9b8cca2085dd48~tplv-k3u1fbpfcp-zoom-1.image" alt="持有锁的线程"></p>
<p>22号线程处于Blocked状态，正在等待一个锁，这个锁被id为1的线程持有，同时这个22号线程还持有一个锁，这个锁是主线程想要的。</p>
<p>通过ANR日志可以分析除这个ANR是死锁导致的，并且有具体的堆栈信息。这只是一种，还有其他ANR情况，比如内存不足、CPU被抢占、系统服务没有及时响应。</p>
<p><strong>如果作为线上的话，在ANR发生时，可以将这个traces.txt文件上报到服务器，只不过有些手机需要root权限才能读取 /data/anr目录</strong></p>
<h3 id="ANR监控-1"><a href="#ANR监控-1" class="headerlink" title="ANR监控"></a>ANR监控</h3><h4 id="1、抓取系统的-traces-txt"><a href="#1、抓取系统的-traces-txt" class="headerlink" title="1、抓取系统的 traces.txt"></a>1、抓取系统的 traces.txt</h4><ol>
<li>当监控线程发现主线程卡死时，主动向系统发送 SIGNAL_QUIT信号</li>
<li>等待 /data/anr/traces.txt 文件生成</li>
<li>文件生成后进行上报</li>
</ol>
<p>这种方案可以参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1064396">手Q的线程死锁监控与自动化分析实践</a>，但是，这种方案存在以下问题：</p>
<ul>
<li>traces.txt 里面包含所有线程信息，上传后需要<strong>人工过滤分析</strong></li>
<li>很多高版本系统<strong>需要root权限才能读取到 /data/anr</strong> 这个目录</li>
</ul>
<h4 id="2、ANRWatchDog"><a href="#2、ANRWatchDog" class="headerlink" title="2、ANRWatchDog"></a>2、ANRWatchDog</h4><p>它的主要原理：</p>
<ol>
<li>开启一个线程，死循环，循环中睡眠 5s    </li>
<li>往UI线程post一个Runnable，将_tick 赋值为 0 ，将 _reported 赋值为 false</li>
<li>线程睡眠 5s 后检查 _tick 和 _report 的字段是否被修改    </li>
<li>如果一直没有被修改，说明主线程post的Runnable 一直没有被执行，说明主线程至少卡顿5s <strong>(只能说至少，这里存在5s内的误差)</strong></li>
<li>将贤臣各堆栈信息输出</li>
</ol>
<p>但是，这种方案，其实是有缺陷的，它有个时候会捕获不到 ANR ，什么原因呢？</p>
<p><strong>ANRWatchDog缺点</strong></p>
<p>可以用一个图片来表示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ae96474849043f4acb5719e2bf3e797~tplv-k3u1fbpfcp-watermark.awebp" alt="漏检测示意图"></p>
<p>这种情况红色表示卡顿：</p>
<ol>
<li>假设主线程卡顿了 2s 之后，ANRWatchDog 刚好开始下一轮循环，将 _tick 赋值为5，并往主线程post一个任务，执行 _tick = 0</li>
<li>主线程过了 3s 之后刚好不卡顿了，将 _tick 置为 0 ，</li>
<li>等到 ANRWatchDog 睡眠 5s 之后，发现 _tick = 0 ，判断并没有发生 ANR</li>
</ol>
<p>针对 ANRWatchDog 存在的问题，可以做一个优化。</p>
<h3 id="3、ANRMoitor"><a href="#3、ANRMoitor" class="headerlink" title="3、ANRMoitor"></a>3、ANRMoitor</h3><p>针对 ANRWatchDog 的漏检测问题，设计一个 ANRMoitor ，ANRWatchDog 出现问题的主要原因是，<strong>因为线程睡眠 5s ，不知道前一秒主线程是否已经出现卡顿了，如果盖层每隔 1s 检测一次，就可以把误差降低到 1s 内。</strong>我们<strong>想让子线程间隔1s执行一次任务，可以通过 HandlerThread 来实现</strong>，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Volatile</span></span><br><span class="line"><span class="keyword">var</span> mainHandlerRunEnd = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程会间隔1s调用一次这个Runnable</span></span><br><span class="line"><span class="keyword">private</span> val mThreadRunnable = Runnable {</span><br><span class="line">    </span><br><span class="line">    blockTime++</span><br><span class="line">    <span class="comment">//1、标志位 mainHandlerRunEnd 没有被主线程修改，说明有卡顿</span></span><br><span class="line">    <span class="keyword">if</span> (!mainHandlerRunEnd &amp;&amp; !isDebugger()) {</span><br><span class="line">        logw(TAG, <span class="string">"mThreadRunnable: main thread may be block at least $blockTime s"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、卡顿超过5s，触发ANR流程，打印堆栈</span></span><br><span class="line">    <span class="keyword">if</span> (blockTime &gt;= <span class="number">5</span>) {</span><br><span class="line">        <span class="keyword">if</span> (!mainHandlerRunEnd &amp;&amp; !isDebugger() &amp;&amp; !mHadReport) {</span><br><span class="line">            mHadReport = <span class="keyword">true</span></span><br><span class="line">            <span class="comment">//5s了，主线程还没更新这个标志，ANR</span></span><br><span class="line">            loge(TAG, <span class="string">"ANR-&gt;main thread may be block at least $blockTime s "</span>)</span><br><span class="line">            loge(TAG, getMainThreadStack())</span><br><span class="line">            <span class="comment">//todo 回调出去，这里可以按需把其它线程的堆栈也输出</span></span><br><span class="line">            <span class="comment">//todo debug环境可以开一个新进程，弹出堆栈信息</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、如果上一秒没有卡顿，那么重置标志位，然后让主线程去修改这个标志位</span></span><br><span class="line">    <span class="keyword">if</span> (mainHandlerRunEnd) {</span><br><span class="line">        mainHandlerRunEnd = <span class="keyword">false</span></span><br><span class="line">        mMainHandler.post {</span><br><span class="line">        	mainHandlerRunEnd = <span class="keyword">true</span></span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"> <span class="comment">//子线程间隔1s调用一次mThreadRunnable</span></span><br><span class="line">    sendDelayThreadMessage()</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p>具体流程：</p>
<ol>
<li>子线程每隔 1s 执行一次 mThreadRunnable，检测标志位 mainHandlerRunEnd 是否被修改</li>
<li>假如 mainHandlerRunEnd 被如期修改为 true，则重置 mainHandlerRunEnd 为 false，继续执行步骤 1</li>
<li>假如 mainHandlerRunEnd 没有被修改为true，说明有卡顿，累计卡顿 5s 就触发 ANR</li>
</ol>
<p>这种方案也能在线下应用，定位到耗时代码。<strong>最好可以结合 ProcessLifecycleOwner ，应用在前台时才开启，否则停止检测。</strong></p>
<h2 id="死锁监控"><a href="#死锁监控" class="headerlink" title="死锁监控"></a>死锁监控</h2><p>就是检测等待啥锁，锁被谁持有了</p>
<h2 id="形成闭环"><a href="#形成闭环" class="headerlink" title="形成闭环"></a>形成闭环</h2><p>前面分别讲了卡顿监控、ANR监控和死锁监控，可以把它们连接起来，形成闭环：</p>
<ol>
<li>发生ANR</li>
<li>获取主线程堆栈</li>
<li>检测死锁</li>
<li>上报服务器</li>
<li>结合git，定位到最后修改代码的同学，提问题单</li>
</ol>
<p>以上内容参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6973564044351373326">蓝师傅的博客</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/08/24/%E9%9D%A2-%E9%A1%B9%E7%9B%AE/RecyclerView%E7%9A%84notifyItemChanged%E5%BC%95%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/24/%E9%9D%A2-%E9%A1%B9%E7%9B%AE/RecyclerView%E7%9A%84notifyItemChanged%E5%BC%95%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">RecyclerView的notifyItemChanged引出的问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-24 16:07:00 / 修改时间：16:07:34" itemprop="dateCreated datePublished" datetime="2021-08-24T16:07:00+08:00">2021-08-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">问题</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>   因项目要求，设计类似抖音的视频列表播放功能。在权衡之后，采用ViewPager2 + ExoPlayer 来实现，由于直接这样使用会引起视频播放混乱的问题，即划入下一个视频的时候，上一个视频还在播放，导致同一时刻多个视频同时播放。因此，我们设定一个单例的 mPlayer ，动态地设置给 PlayView，通过在onPageSelected 回调中，调用 notifyItemChanged 方法，刷新当前的item ，让它的标志 play = true，这样让它获取单例的 player ，从而实现播放。</p>
<p>  还有，在每个 item 里面需要有个dialog，点击这个item上的某个位置就弹出来，并且，如果第 0 个item 符合某个条件，那么进入视频列表页面就会弹出dialog。这时候，诡异的问题就来了，在某个测试版本，进入视频列表页面之后，弹出了一个dialog，但是感觉这个dialog上面会有一个蒙层，点击之后，这个蒙层才会消失，之后，该页面的所有按钮才能点击 ！也就是测试所提出的，按钮需要点击两次才有效！这就奇怪了，通过LayoutInspector 也只能看到一个dialog浮在内容上(事实上这是使用不熟导致的，因为看起来，比如 ActivityA 中有3个dialog，那么在选择process的时候，会有3个 ActivityA 在那，所以应该是每有一个window都会展示一下这个activity，所以那时候应该是选了Activity，但是由于内容是一样的，所以看不出来)。</p>
<p>  但是通过打断点，发现同一个视频 id 生成了，在 itemView 中setData 3次，其实 2次是可以理解的 （数据刚加载的时候一次，在 notifyItemChanged 的一次）；与此同时，发现同一个视频 id 出现在两个 itemView 中，这就很奇怪了，并且，前两次 是 itemView1 ，在 notifyItemChanged 之后，id 就出现在了 itemViewB 中了！如果没有看过源码的话，这时候应该颠覆了认知了，因为 notifyItemChanged 应该只刷新当前 item 才对，怎么会创建了一个新的 itemView 呢？</p>
<p>  这个问题到这里，其实可以解释得通了：由于第0个视频满足刚进入页面就需要弹dialog，所以弹了一次；这时候，由于第 0 个视频又被承载到了新的 itemView 上，创建了新的View ，所以又 弹出来了一次，也就是说，上面那个阴影是一个dialog。  </p>
<p>  找到问题之后，再搜了下，发现如果 RecyclerView 默认带有动画的情况下，notifyItemChanged 会创建一个新的ViewHolder ！难怪，那理论上，如果我去掉RecyclerView的动画，应该问题就解决了，于是有了如下代码：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Adapter</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttachedToRecyclerView</span><span class="params">(rv: <span class="type">RecyclerView</span>)</span></span> {</span><br><span class="line">  <span class="keyword">super</span>.onAttachedToRecyclerView(rv)</span><br><span class="line">  rv.itemAnimator = <span class="literal">null</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>果然可以了！现在来总结以下问题：</p>
<blockquote>
<p>由于默认的动画导致刷新单个item的时候创建了新的ViewHolder， 从而引起 Dialog 再弹了一次，两个重叠在一起了，解决方案就是将 RecyclerView 的动画去掉</p>
</blockquote>
<p>以上内容参考资料<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/ask/38077">腾讯云</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/OneDeveloper/article/details/79721284">csdn的博客</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/08/18/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E8%87%AA%E5%B7%B1%E5%8A%A0%E7%9A%84%E7%89%B9%E5%88%AB%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/18/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E8%87%AA%E5%B7%B1%E5%8A%A0%E7%9A%84%E7%89%B9%E5%88%AB%E7%AF%87/" class="post-title-link" itemprop="url">自己编的-特殊函数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-18 17:25:00 / 修改时间：17:35:59" itemprop="dateCreated datePublished" datetime="2021-08-18T17:25:00+08:00">2021-08-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h3 id="run-函数"><a href="#run-函数" class="headerlink" title="run()函数"></a>run()函数</h3><p>它的实现如下，<strong>其实就是调用传入的block参数(一般是个Lambda代码块)</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> inline fun &lt;R&gt; run(block: () -&gt; R): R { </span><br><span class="line">    contract { </span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE) </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> block() </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">run {</span><br><span class="line">    myFun()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="apply-函数"><a href="#apply-函数" class="headerlink" title="apply() 函数"></a>apply() 函数</h3><p>实现如下，主要看后面两行，先是调用了block函数（block里面可以直接使用this？），然后再返回当前调用者this。即执行完block后返回当前的调用者：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T { </span><br><span class="line">    contract { </span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    }</span><br><span class="line">    block() </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法</span></span><br><span class="line">val a = ArrayList&lt;String&gt;().apply {</span><br><span class="line">    add(<span class="string">"A"</span>)</span><br><span class="line">    add(<span class="string">"B"</span>)</span><br><span class="line">    add(<span class="string">"C"</span>)</span><br><span class="line">    println(<span class="keyword">this</span>)<span class="comment">//打印 [A,B,C]</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">println(a)<span class="comment">//同样打印 [A,B,C]</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="let函数"><a href="#let函数" class="headerlink" title="let函数"></a>let函数</h3><p>只需要看源代码最后一行即可：意思是把当前调用对象作为参数传入block代码块(意味着一定要用it访问调用对象，能不能this?),最后，返回block执行结果，即作用域中的最后一个对象：：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R { </span><br><span class="line">    contract { </span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE) </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>) </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="also-函数"><a href="#also-函数" class="headerlink" title="also() 函数"></a>also() 函数</h3><p>源码先调用block(this) ，但是最后返回值是this，也就是，将当前调用者传入block，执行完后返回调用者。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T { </span><br><span class="line">    contract { </span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE) </span><br><span class="line">    }</span><br><span class="line">    block(<span class="keyword">this</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">val a = <span class="string">"ABC"</span>.also{</span><br><span class="line">    println(it)<span class="comment">//输出 ABC</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pintln(a);<span class="comment">//输出 ABC</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="with-函数"><a href="#with-函数" class="headerlink" title="with() 函数"></a>with() 函数</h3><p>源码传入一个接收者对象 reciver，然后使用该对象去调用传入的Lambda代码块： receiver.block()</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R { </span><br><span class="line">    contract { </span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE) </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> receiver.block() </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">whith(ArrayList&lt;String&gt;()) {</span><br><span class="line">    add(<span class="string">"A"</span>)</span><br><span class="line">    add(<span class="string">"B"</span>)</span><br><span class="line">    add(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="keyword">this</span>)<span class="comment">//ABC</span></span><br><span class="line">}.let {</span><br><span class="line">    println(it)<span class="comment">//kotlin.Unit</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="run、let-与-also-对比"><a href="#run、let-与-also-对比" class="headerlink" title="run、let 与 also 对比"></a>run、let 与 also 对比</h3><p>由下面代码可能更好理解run实现中 return block() 、let实现中的  return block(this)  ，以及 also 源码中的 return this ：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//run提供了一个单独的作用域，并且会返回在这个作用域当中的最后一个对象</span></span><br><span class="line"><span class="comment">//例如现在有这么一个场景，用户领取app的奖励，如果用户没有登录弹出登录dialog，如果已经登录则弹出领取奖励的dialog。我们可以使用以下代码来处理这个逻辑</span></span><br><span class="line">run {</span><br><span class="line">    <span class="keyword">if</span> (islogin) loginDialog <span class="keyword">else</span> getAwardDialog</span><br><span class="line">}.show()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">val original = <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line">original.let {</span><br><span class="line">    println(<span class="string">"The original String is $it"</span>) <span class="comment">// "abc"</span></span><br><span class="line">    it.reversed() </span><br><span class="line">}.let {</span><br><span class="line">    println(<span class="string">"The reverse String is $it"</span>) <span class="comment">// "cba"</span></span><br><span class="line">    it.length  </span><br><span class="line">}.let {</span><br><span class="line">    println(<span class="string">"The length of the String is $it"</span>) <span class="comment">// 3</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">original.also {</span><br><span class="line">    println(<span class="string">"The original String is $it"</span>) <span class="comment">// "abc"</span></span><br><span class="line">    it.reversed() </span><br><span class="line">}.also {</span><br><span class="line">    println(<span class="string">"The reverse String is ${it}"</span>) <span class="comment">// "abc"</span></span><br><span class="line">    it.length  </span><br><span class="line">}.also {</span><br><span class="line">    println(<span class="string">"The length of the String is ${it}"</span>) <span class="comment">// "abc"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>run是直接提供一个作用域，并返回作用域里面最后一个对象</li>
<li>let 将this传入block中，并且返回 block(this)，也就是作用域最后一个对象</li>
<li>also 将this传入block中，但是返回的是 this，也就是调用者本身</li>
<li>with 呢，是以 with(T) 的形式使用(但是它貌似不能判断null？)</li>
<li>apply没有传入this，但是直接返回this</li>
</ul>
<p>最后，按需使用的情景：</p>
<p><img src="https://img-blog.csdn.net/20180316005903782?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2xqZDIwMzg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="场景"></p>
<blockquote>
<p>有些内容参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/ljd2038/article/details/79576091">无嘴小呆子</a></p>
</blockquote>
<p>无需写interface，直接写个高阶函数？这个地方是不是高阶函数？</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/08/12/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/12/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：面向对象</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-12 10:25:00 / 修改时间：18:21:29" itemprop="dateCreated datePublished" datetime="2021-08-12T10:25:00+08:00">2021-08-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h2><h3 id="Kotlin-中的类及接口"><a href="#Kotlin-中的类及接口" class="headerlink" title="Kotlin 中的类及接口"></a>Kotlin 中的类及接口</h3><p> Kotlin中的类与Java的很像：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> weight: <span class="built_in">Double</span> = <span class="number">500.0</span></span><br><span class="line">	<span class="keyword">val</span> color: String = <span class="string">"blue"</span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>反编译成Java的版本：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> double weight = <span class="number">500.0D</span>;</span><br><span class="line">	<span class="meta">@NotNull</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String color = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> double getWeight() {</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@NotNull</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> String getColor() {</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> void fly() {</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由此可以看出，虽然声明方式很像，但是也存在很多不同：</p>
<ul>
<li>属性默认值。Kotlin中，除非显式声明延迟初始化，不然就需要指定默认值。</li>
<li>不同的可访问修饰符。Kotlin类中的成员默认是全局可见的(public)，而Java默认可见域是包作用域。  </li>
<li>方法默认是final修饰的。意味着不能覆写(这条是自己添加的)。</li>
</ul>
<p><strong>可带有属性和默认方法的接口</strong></p>
<p>我们知道，Java 8 之后，接口支持<strong>默认实现</strong>，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flayer</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">kind</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>{</span><br><span class="line">	    System.out.println(<span class="string">"I can fly"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来看下Kotlin的接口实现：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> speed: <span class="built_in">Int</span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> {</span><br><span class="line">	    println(<span class="string">"I can fly"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同样，<strong>我们可以用Kotlin 定义一个带有方法实现的接口</strong>，同时，它还支持抽象属性（如例子中的speed属性），然而，Kotlin是基于Java6实现的，那它是如何支持的呢？转换为Java代码看下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getSpeed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">kind</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultImpls</span> </span>{</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(Flyer $<span class="keyword">this</span>)</span> </span>{</span><br><span class="line">	        String var1 = <span class="string">"I can fly"</span>;</span><br><span class="line">	        System.out.println(var1);</span><br><span class="line">	    }</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由此我们发现，Kotlin编译器<strong>通过定义一个静态内部类 DefaultImpls 来提供fly方法的默认实现</strong>。同时，<strong>抽象属性是通过一个get方法来实现的！</strong>所以呢，我们不能像Java一样，为属性直接赋值，如下这样是错误的：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> height = <span class="number">1000</span>;<span class="comment">//error Property initializers are not allowed in interfaces</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是Kotlin 提供了另外一种方式来实现这种效果：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> height</span><br><span class="line">	    <span class="keyword">get</span>() = <span class="number">1000</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="更简洁地构造类的对象"><a href="#更简洁地构造类的对象" class="headerlink" title="更简洁地构造类的对象"></a>更简洁地构造类的对象</h3><p>如果要在Java中实现参数个数不同的构造方法，那我们就要重载很多个构造方法，这种方式主要存在2个缺点：</p>
<ul>
<li>如果要支持任意参数组合来创建对象，那么需要实现的构造方法非常多</li>
<li>每个构造方法中的代码都会冗余，如在构造方法中可能都需要对 age 和color 进行相同的赋值操作。</li>
</ul>
<p>Kotlin 通过引入新的构造语法来解决这些问题。比如我们可以用一行代码来表示复杂的构造方式：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span> = <span class="number">0.00</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">0</span>, <span class="keyword">val</span> color: String = <span class="string">"blue"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>如果用Java实现这种参数任意组合的效果，那是非常复杂的。但是如果不写入全部的参数，而只用其中某些参数的时候，需要写参数名，否则会报错：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的</span></span><br><span class="line"><span class="keyword">val</span> bird1 = Bird(<span class="number">1000.00</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确示例</span></span><br><span class="line"><span class="keyword">val</span> bird2 = Bird(weight = <span class="number">1000.00</span>, color = <span class="string">"black"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>init方法：事实上，<strong>我们的构造方法可以拥有多个 init，他们会在对象创建时按照类中从上到下的顺序先后执行</strong></p>
<p><strong>延迟初始化： by lazy 和 lateinit</strong></p>
<p>在Kotlin中，主要使用lateinit 和 by lazy 这两种语法来实现延迟初始化的效果。如果这是一个用 val 声明的变量，我们用 by lazy 来修饰：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> color: String) {</span><br><span class="line">	<span class="keyword">val</span> sex: String <span class="keyword">by</span> lazy {</span><br><span class="line">	    <span class="keyword">if</span>(color == <span class="string">"yellow"</span>) <span class="string">"male"</span> <span class="keyword">else</span> <span class="string">"female"</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结 by lazy 语法的特点如下：</p>
<ul>
<li>该变量必须是引用不可变的，而不能通过var声明</li>
<li>被首次调用时，才会进行赋值操作，一旦赋值，后续将不能更改。</li>
</ul>
<p>需要注意的是，系统会给 lazy属性默认加上同步锁，也就是 LazyThreadSafetyMode.SYNCHRONIZED ，它在同一时刻只允许一个线程对lazy属性初始化，<strong>所以，lazy是线程安全的</strong>。当然，你可以自己给lazy指定参数，如： <code>val sex: String by lazy(LazyThreadSafetyMode.NONE)</code>。</p>
<p>与lazy 不同，<strong>lateinit 主要用于 var 声明的变量，然而它不能用于基本数据类型，如 Int、Long 等</strong>，我们需要使用Integet这种包装类作为替代。lateinit 的用法如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> color: String) {</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> sex: String</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">printSex</span><span class="params">()</span></span> {</span><br><span class="line">	    sex = <span class="keyword">if</span>(color == <span class="string">"yellow"</span>) <span class="string">"male"</span> <span class="keyword">else</span> <span class="string">"female"</span></span><br><span class="line">	    println(sex)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Kotlin只用一个构造方法实现了Java中需要重载才能实现的功能，那么，Kotlin中是否真的只需要一个构造方法呢？</p>
<h3 id="主从构造方法"><a href="#主从构造方法" class="headerlink" title="主从构造方法"></a>主从构造方法</h3><p>前面似乎遗漏了一些情况，简化前面的Bird类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(age: <span class="built_in">Int</span>) {</span><br><span class="line">	<span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">init</span> {</span><br><span class="line">	    <span class="keyword">this</span>.age = age</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>假设当前我们知道鸟的生日，希望可以通过生日来得到鸟的年龄，然后创建一个Bird对象，如何实现？有一种方案就是在别处定义一个工厂方法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Bird</span><span class="params">(birth: <span class="type">DateTme</span>)</span></span> = Bird(getAgeByBirth(birth))</span><br></pre></td></tr></tbody></table></figure>

<p>在哪声明这个工厂方法呢？这种方式的缺点在于，Bird 方法与Bird类在代码层面的分离不够直观。其实我们可以像Java那样新增一个构造方法来解决，Kotlin 也支持多构造方法，与Java的区别是，<strong>Kotlin中多个构造方法之间存在主从关系</strong>：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(age: <span class="built_in">Int</span>) {</span><br><span class="line">	<span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">init</span> {</span><br><span class="line">	    <span class="keyword">this</span>.age = age</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">constructor</span>(birth: DateTime) : <span class="keyword">this</span>(getAgeByBirth(birth)){</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码的运作方式是：</p>
<ul>
<li>通过constructor方法定义一个新的构造方法，称为<strong>从构造方法</strong>。相应地，我们熟悉的构造方法叫做<strong>主构造方法</strong>，每个类最多存在一个主构造方法，但是可以存在多个从构造方法</li>
<li>如果一个类存在主构造方法，那么每个从构造方法都要直接或间接地委托给它。</li>
</ul>
<h2 id="不同的访问控制原则"><a href="#不同的访问控制原则" class="headerlink" title="不同的访问控制原则"></a>不同的访问控制原则</h2><p>构造完对象，就要考虑访问控制了。</p>
<h3 id="限制修饰符"><a href="#限制修饰符" class="headerlink" title="限制修饰符"></a>限制修饰符</h3><p>我们知道，Kotlin中的类和方法默认实现反编译成 Java的时候，会被final修饰，所以，类默认是不能被继承的，方法默认也不能被覆写的，如果要实现继承，类之前需要用open修饰： <code>open class Bird {}</code> ，方法也需要使用open 修饰： <code>open fun fly()</code> </p>
<h4 id="类默认final-真的好吗？"><a href="#类默认final-真的好吗？" class="headerlink" title="类默认final 真的好吗？"></a>类默认final 真的好吗？</h4><p>网上有很多人认为默认final有很多缺点，那为什么Kotlin要设计成默认final呢？主要有2个原因：</p>
<ul>
<li>Kotlin 当前是一门以Android为平台的开发语言，在开发中，我们很少会频繁继承一个类，默认final会更加安全。</li>
<li>Kotlin的扩展手段更加丰富。不像Java，Kotlin 可以通过多种方式去扩展，而不是通过原始类的手段，典型的莫过于 Android 的Kotlin 扩展库 android-ktx，Google就是通过Kotlin的扩展语法而不是继承来实现。</li>
</ul>
<p>此外，Kotlin还可以利用<strong>密封类</strong>来限制一个类的继承，如下所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> = <span class="string">"I can fly"</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Eagle</span>: <span class="type">Bird</span></span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Kotlin通过 <strong>sealed 关键字</strong>来修饰一个类为密封类，<strong>若要继承则需要将子类定义在同一个文件中，其他文件中的类将无法继承它</strong>。但是这种方式有它的局限性，即它不能被初始化，为什么呢？<strong>这是因为它是基于抽象类实现的</strong>，我们看反编译后的Java代码就知道了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Bird</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(DefaultConstructorMarker $constrctor_maker)</span> </span>{</span><br><span class="line">	    <span class="keyword">this</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Eagle</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">Eagle</span><span class="params">()</span> </span>{</span><br><span class="line">	        <span class="keyword">super</span>((DefaultConstructorMarker)<span class="keyword">null</span>)</span><br><span class="line">	    }</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>密封类的使用场景优先，它其实可以看成一种功能更强大的枚举，所以它在模式匹配中可以起到很大的作用</strong>。</p>
<h3 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h3><p>除了限制类修饰符外，还有一种可见性修饰符。Kotlin与Java的不同在于：</p>
<ul>
<li>默认修饰符不同，Kotlin是public，而Java是default</li>
<li>Kotlin中有一个独特的 internal    </li>
<li>Java类只有内部类可以用private修饰，其他类不允许；而Kotlin可以</li>
<li>protected访问范围不同。<strong>Java中是包、类及子类可访问，而Kotlin只有类和子类可以访问</strong>。</li>
</ul>
<p>说下Kotlin 独特的 internal 修饰符，它的作用域被称作<strong>模块内访问</strong>，那到底什么是模块？以下几种情况可以算作一个模块：</p>
<ul>
<li>一个Eclipse项目</li>
<li>一个 Intellij IDEA项目</li>
<li>一个Maven项目</li>
<li>一个Gradle项目</li>
<li>一组由一次Ant任务执行编译的代码</li>
</ul>
<p>那为什么要这种修饰符呢？Java的包内访问不好吗？Java包内访问确实是有问题的，举个例子，你再Java项目中定义了一个类，默认修饰符，那就是包私有的，其他地方将无法访问。然后你id啊宝诚一个类库，供三方使用。但如果有个开发者想使用这个类，除了copy源码以外，还有一个方式就是<strong>在程序中创建一个与该类相同名字的包，那么这个包下面的其他类就能直接使用我们前面定义的类了！</strong></p>
<p>而Kotlin这种，模块内可见指的是该类只对一起编译的其他Kotlin文件可见，开发工程与第三方类库不属于同一模块，这时候如果还想用，就只能复制源码了。</p>
<p>Java中我们很少见到private修饰的类，因为Java中的类或者方法没有单独属于某个文件的概念。若要用provate修饰，那么这个只能是其他类的内部类，而Kotlin中则可以用private给单独的类修饰，它的作用域就是当前这个Kotlin文件：</p>
<h2 id="解决多继承问题"><a href="#解决多继承问题" class="headerlink" title="解决多继承问题"></a>解决多继承问题</h2><p>Java和Kotlin都不支持多继承。为什么这样呢？是因为多继承会导致继承关系语义上的混淆。</p>
<h3 id="骡子的多继承困惑"><a href="#骡子的多继承困惑" class="headerlink" title="骡子的多继承困惑"></a>骡子的多继承困惑</h3><p>C++支持多继承，然而C++中存在一个经典的<strong>钻石问题</strong>。假如我们有个抽象的 Animal 类，它有个 run() 方法，Horse （马） 和 Donkey（驴） 都继承了Animal，假如支持多继承，Mule（驴）继承了 Horse 和 Donkey ，那么，在 Mule 中的 run() 到底是继承了谁的呢？这就是典型的钻石问题，因为继承关系像个钻石图，如下：</p>
<p><img src="/assets/Book-Notes/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0/%E9%92%BB%E7%9F%B3%E9%97%AE%E9%A2%98.png" alt="钻石问题"></p>
<h3 id="接口实现多继承"><a href="#接口实现多继承" class="headerlink" title="接口实现多继承"></a>接口实现多继承</h3><p>在Java中我们经常提及使用接口来实现多继承，其实，如果多个接口中都存在同样的方法，比如上述的 run() ，同样也会导致钻石问题。不过，<strong>Kotlin 通过提供 super 关键字来指定继承那个父接口的方法，从而解决了这个问题</strong>，如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="string">"flying animals"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="string">"flying animals"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(): Flyer, Animal {</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="keyword">super</span>&lt;Flyer&gt;.kind()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过 <code>super&lt;Flyer&gt;.kind()</code>来指定继承哪个父接口的方法！当然，子类也可以自己实现这个方法，不用父类的，完全没问题。</p>
<h3 id="内部类解决多继承问题"><a href="#内部类解决多继承问题" class="headerlink" title="内部类解决多继承问题"></a>内部类解决多继承问题</h3><p>Kotlin的内部类的定义方式和Java 还不一样，如果我们按照Java的习惯来定义 Kotlin中的内部类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterKotlin</span> </span>{</span><br><span class="line">  <span class="keyword">val</span> name = <span class="string">"not kotlin inner class"</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ErrorInnerKotlin</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span> {</span><br><span class="line">      print(<span class="string">"thie name is <span class="variable">$name</span>"</span>)<span class="comment">//报错，不能访问name</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>报错了，和Java 还真不一样。其实，我们这样声明的是Kotlin 的 <strong>嵌套类</strong>，并非内部类。如果要在Kotlin中声明一个内部类，必须在这个类前面加一个 inner 关键字，即这样子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterKotlin</span> </span>{</span><br><span class="line">  <span class="keyword">val</span> name = <span class="string">"kotlin inner class"</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerKotlin</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span> {</span><br><span class="line">      print(<span class="string">"thie name is <span class="variable">$name</span>"</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>我们知道，Java中在内部类的语法上增加一个 static 关键字，就可以变成 嵌套类；Kotlin则是相反的思路，默认是嵌套类，必须加上 inner 关键字才是一个内部类。</p>
</blockquote>
<p>了解内部类之后，可以通过内部类实现上述的骡子类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mule</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">runFast</span><span class="params">()</span></span> {</span><br><span class="line">    HorseC().runFast()</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">runSlow</span><span class="params">()</span></span> {</span><br><span class="line">    DonkeyC().runSlow()</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseC</span>: <span class="type">Horse</span></span>()</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">DonkeyC</span>: <span class="type">Donkey</span></span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用委托代替多继承"><a href="#使用委托代替多继承" class="headerlink" title="使用委托代替多继承"></a>使用委托代替多继承</h3><p><strong>Kotlin中的委托只需要通过 by 关键字就可以实现，比如之前学习的 by lazy 语法，其实就是利用了委托实现了延迟初始化</strong>。我们看下如何通过委托代替多继承需求：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Caneat</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyer</span>: <span class="type">CanFly {</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> {</span><br><span class="line">    println(<span class="string">"I can fly"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> : <span class="type">CanEat {</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    println(<span class="string">"I can eat"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(flyer: Flyer, animal: Animal): CanFly <span class="keyword">by</span> flyer, CanEat <span class="keyword">by</span> animal {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">  <span class="keyword">val</span> fyler = Flyer()</span><br><span class="line">  <span class="keyword">val</span> animal = Animal()</span><br><span class="line">  <span class="keyword">val</span> b = Bird(flyer, animal)</span><br><span class="line">  b.fly()</span><br><span class="line">  b.eat()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="真正的数据类"><a href="#真正的数据类" class="headerlink" title="真正的数据类"></a>真正的数据类</h2><h3 id="繁琐的JavaBean"><a href="#繁琐的JavaBean" class="headerlink" title="繁琐的JavaBean"></a>繁琐的JavaBean</h3><p>JavaBean中需要各种setter和getter，如果要支持对象值的比较，还得重写hashCode 和 equals 等方法。</p>
<h3 id="用data-class创建数据类"><a href="#用data-class创建数据类" class="headerlink" title="用data class创建数据类"></a>用data class创建数据类</h3><p>data class 顾名思义就是<strong>数据类</strong>，这不是Kotlin首创，在Scala等语言中也有。一般我们只需要如下定义即可：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">var</span> weight: <span class="built_in">Double</span>, <span class="keyword">var</span> age: <span class="built_in">Int</span>, <span class="keyword">var</span> color: String)</span><br></pre></td></tr></tbody></table></figure>

<p>这么一行代码，编译器为我们做了很多事情，来看看反编译后的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">double</span> var1)</span> </span>{</span><br><span class="line">      <span class="keyword">this</span>.weight = var1;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>{</span><br><span class="line">      <span class="keyword">this</span>.age = var1;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getColor</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="meta">@NotNull</span> String var1)</span> </span>{</span><br><span class="line">      Intrinsics.checkNotNullParameter(var1, <span class="string">"&lt;set-?&gt;"</span>);</span><br><span class="line">      <span class="keyword">this</span>.color = var1;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(<span class="keyword">double</span> weight, <span class="keyword">int</span> age, <span class="meta">@NotNull</span> String color)</span> </span>{</span><br><span class="line">      Intrinsics.checkNotNullParameter(color, <span class="string">"color"</span>);</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.weight = weight;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">      <span class="keyword">this</span>.color = color;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">component1</span><span class="params">()</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">component2</span><span class="params">()</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">component3</span><span class="params">()</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Bird <span class="title">copy</span><span class="params">(<span class="keyword">double</span> weight, <span class="keyword">int</span> age, <span class="meta">@NotNull</span> String color)</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      Intrinsics.checkNotNullParameter(color, <span class="string">"color"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Bird(weight, age, color);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Bird copy$<span class="keyword">default</span>(Bird var0, <span class="keyword">double</span> var1, <span class="keyword">int</span> var3, String var4, <span class="keyword">int</span> var5, Object var6) {</span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">1</span>) != <span class="number">0</span>) {</span><br><span class="line">         var1 = var0.weight;<span class="comment">//copy时，若未指定具体属性的值，则使用被copy对象的属性值，这是浅拷贝</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">2</span>) != <span class="number">0</span>) {</span><br><span class="line">         var3 = var0.age;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">4</span>) != <span class="number">0</span>) {</span><br><span class="line">         var4 = var0.color;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var0.copy(var1, var3, var4);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Bird(weight="</span> + <span class="keyword">this</span>.weight + <span class="string">", age="</span> + <span class="keyword">this</span>.age + <span class="string">", color="</span> + <span class="keyword">this</span>.color + <span class="string">")"</span>;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">int</span> var10000 = (Double.hashCode(<span class="keyword">this</span>.weight) * <span class="number">31</span> + Integer.hashCode(<span class="keyword">this</span>.age)) * <span class="number">31</span>;</span><br><span class="line">      String var10001 = <span class="keyword">this</span>.color;</span><br><span class="line">      <span class="keyword">return</span> var10000 + (var10001 != <span class="keyword">null</span> ? var10001.hashCode() : <span class="number">0</span>);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="meta">@Nullable</span> Object var1)</span> </span>{</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> != var1) {</span><br><span class="line">         <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Bird) {</span><br><span class="line">            Bird var2 = (Bird)var1;</span><br><span class="line">            <span class="keyword">if</span> (Double.compare(<span class="keyword">this</span>.weight, var2.weight) == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.age == var2.age &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.color, var2.color)) {</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这就和JavaBean很相似了，同时还有 equals 和 hashCode 的实现。同时，我们发现里面有几个JavaBean中没有的方法，比如 copy、component1、component2、component3。下一节来介绍它们。</p>
<h3 id="copy-、componentN-与-结构"><a href="#copy-、componentN-与-结构" class="headerlink" title="copy 、componentN 与 结构"></a>copy 、componentN 与 结构</h3><p>上上述代码可以看到，两个copy方法，可以传入响应的参数来生成不同的对象；同时，如果你未指定具体属性的值，那么新生成的对象的属性值将使用被copy对象的属性值，这就是我们常说的浅拷贝。看个例子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果Bird的属性是var，即可变的</span></span><br><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>,<span class="number">1</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="keyword">val</span> b2 = b1</span><br><span class="line">b2.age = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果Bird的属性是val，不可变的，那么更改属性只能通过copy</span></span><br><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>,<span class="number">1</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="keyword">val</span> b2 = b1.copy(age = <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>



<p><strong>注意，Kotlin提供的上述copy方法是浅拷贝的，所以我们要注意使用场景。</strong>因为数据类的属性可以被修饰为var，所以不能保证不会出现引用被修改的情况。</p>
<p>接下来看 componentN (其中N为1，2，3…，根据参数个数来定)，这个设计到底有什么用？我们或多或少直到怎么将属性绑定到类上，但是对于如何将类的属性绑定到响应变量上却不是很熟悉，比如：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>,<span class="number">1</span>, <span class="string">"blue"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通常方法，也符合Java的思维逻辑</span></span><br><span class="line"><span class="keyword">val</span> weight = b1.weight</span><br><span class="line"><span class="keyword">val</span> age = b1.age</span><br><span class="line"><span class="keyword">val</span> color = b1.color</span><br><span class="line"></span><br><span class="line"><span class="comment">//Kotlin 进阶方法</span></span><br><span class="line"><span class="keyword">val</span> (weight, age, color) = b1</span><br></pre></td></tr></tbody></table></figure>

<p>看到进阶方法的时候，一定感到兴奋了吧，普通方法确实很繁琐。还有一种情形，看Java的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String birdInfo = <span class="string">"20.0,1, blue"</span>;</span><br><span class="line"><span class="comment">//如果要把值取出来，就得split</span></span><br><span class="line">String[] temps = birdInfo(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">double</span> weight = Double.valueOf(temps[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> age = Integer.valueOf(temps[<span class="number">1</span>]);</span><br><span class="line">String color = temps[<span class="number">2</span>];</span><br></pre></td></tr></tbody></table></figure>

<p>在我们明明直到值得情况下，还需要这样分割，很繁琐，好在Kotlin提供了更优雅的做法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (weight, age, color) = birdInfo.split(<span class="string">","</span>)</span><br></pre></td></tr></tbody></table></figure>



<p>这个语法也很简洁和直观，其原理也很简单，就是 <strong>解构</strong>，通过编译器的约定实现解构。当然，<strong>Kotlin对于解构也有限制，在数组中它默认最多允许赋值5个变量，因为如果变量过多，效果反而会适得其反，因为到后期你都搞不清哪个值要赋给哪个变量了</strong>。除了利用编译器自动生成的 componentN之外，你还可以实现自己的 componentN，比如：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">var</span> weight: <span class="built_in">Double</span>, <span class="keyword">var</span> age: <span class="built_in">Int</span>, <span class="keyword">var</span> color: String) {</span><br><span class="line">  <span class="keyword">var</span> sex = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> component4: <span class="built_in">Int</span> {//注意 <span class="keyword">operator</span> 关键字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sex</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(weight: <span class="built_in">Double</span>, age: <span class="built_in">Int</span>, color: String, sex: <span class="built_in">Int</span>) : <span class="keyword">this</span>(weight, age, color) {</span><br><span class="line">    <span class="keyword">this</span>.sex = sex</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//使用</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">    <span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>, <span class="number">1</span>, <span class="string">"blue"</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> (weight, age, color, sex) = b1</span><br><span class="line">    ...</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>除了数组支持解构外，Kotlin也提供了其他常用数据类型，分别是 Pair 和 Triple 前者是二元组，后者是 三元组，，我们可以</p>
<p>用类似以下方法来使用它们：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pair = Pair(<span class="number">20.0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">//利用属性顺序获取</span></span><br><span class="line"><span class="keyword">val</span> weightP = pair.first</span><br><span class="line"><span class="keyword">val</span> ageP = pair.second</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用解构</span></span><br><span class="line"><span class="keyword">val</span> (weightP, ageP) = Pair(<span class="number">20.0</span>,<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>



<h2 id="从static-到-object"><a href="#从static-到-object" class="headerlink" title="从static 到 object"></a>从static 到 object</h2><p>Kotlin中告别了static，因为有了 object 关键字，除了替代static外，它还有更多的功能实现，比如单例对象以及简化匿名表达式等。</p>
<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>看一段常见的Java代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prize</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> TYPE_REDPACK = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRedpack</span><span class="params">(Prize prize)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> prize.type == TYPE_REDPACK;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这个类中既有静态变量、静态方法，也有普通变量、普通方法，然而，静态变量和静态方法是属于类的，普通变量和普通方法是属于具体对象的，所以在代码解构上职能并不清晰。Kotlin中利用 companion object 两个关键字引入伴生对象来清晰区分。</p>
<blockquote>
<p>顾名思义，“伴生”即伴随某个类的对象，它属于这个类所有，全局只有一个单例，因此伴生对象跟Java中static修饰的效果一样，<strong>在类装载的时候被初始化</strong>。</p>
</blockquote>
<p>companion object 用花括号包裹了所有静态属性和方法，使得将普通方法和属性清晰区分开来。此外，伴生对象很适合作为工厂，这里就不展开。</p>
<h3 id="天生的单例：-object"><a href="#天生的单例：-object" class="headerlink" title="天生的单例： object"></a>天生的单例： object</h3><p>单例模式最大的一个特点就是在系统中只能存在一个实例对象，所以在java中我们必须通过设置构造方法私有化，以及提供静态方法创建实例的方式来创建单例。在Kotlin中，由于object的存在，我们可以直接用它来实现单例，如下所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DatabaseConfig {</span><br><span class="line">  <span class="keyword">var</span> host: String = <span class="string">"127.0.0.1"</span></span><br><span class="line">  <span class="keyword">var</span> port: <span class="built_in">Int</span> = <span class="number">3306</span></span><br><span class="line">  <span class="keyword">var</span> userName: String = <span class="string">"root"</span></span><br><span class="line">  <span class="keyword">var</span> password: String = <span class="string">""</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>由于object全局声明的对象只有一个，所以它并不用语法上的初始化，甚至都不需要构造方法，因此，我们可以说object创造的是天生的单例</strong>。此外，由于 DatabaseConfig 的属性是 var 声明的属性，我们还能修改它们： </p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatabaseConfig.host = <span class="string">"localhost"</span></span><br><span class="line">DatabaseConfig.port = <span class="number">3307</span></span><br></pre></td></tr></tbody></table></figure>



<p>由于<strong>单例也可以和普通类一样实现接口和继承类</strong>，所以可以将其看成一种不需要主动初始化的类，它也<strong>可以拥有扩展方法</strong>，<strong>单例对象会在系统加载的时候初始化</strong>。</p>
<h3 id="object-表达式"><a href="#object-表达式" class="headerlink" title="object 表达式"></a>object 表达式</h3><p>主要说的是，利用object来完善匿名内部类，这里不展开说。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/08/10/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/10/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：基础语法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-10 15:54:00" itemprop="dateCreated datePublished" datetime="2021-08-10T15:54:00+08:00">2021-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-29 09:42:42" itemprop="dateModified" datetime="2022-10-29T09:42:42+08:00">2022-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="不一样的类型声明"><a href="#不一样的类型声明" class="headerlink" title="不一样的类型声明"></a>不一样的类型声明</h2><p>Kotlin 采用的是与 Java 相反的类型声明方式，类型名通常在变量名的后面： <code>val a: String = "I am Kotlin"</code>为什么采用这种风格呢？Kotlin官方的FAQ的回答是这样的：</p>
<blockquote>
<p>我们相信这样可以使得代码的可读性更好。同时，<strong>这也有利于使用一些良好的语法特性，比如省略类型声明</strong>。Scala的经验表明，这不是一个错误的选择。</p>
</blockquote>
<p>所以，类型放在变量后面的其中一个原因是为了<strong>类型省略</strong>，这个类型省略其实就是类型推导。</p>
<h3 id="增强的类型推导"><a href="#增强的类型推导" class="headerlink" title="增强的类型推导"></a>增强的类型推导</h3><p>类型推导是Kotlin在Java的基础上增强的语言特性之一，即编译器可以在不显式声明类型的情况下，自动推导出它所需要的类型，如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> string = <span class="string">"I am Kotlin"</span></span><br><span class="line"><span class="keyword">val</span> int = <span class="number">1314</span></span><br><span class="line"><span class="keyword">val</span> long = <span class="number">1314L</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们打印以上的变量类型，如： println(int.javaClass.name),将会获得如下结果： </span></span><br><span class="line"><span class="comment">//java.lang.String</span></span><br><span class="line"><span class="comment">//int</span></span><br><span class="line"><span class="comment">//long</span></span><br></pre></td></tr></tbody></table></figure>

<p>类型推导很大程度上提高了Kotlin这种<strong>静态类型语言</strong>的开发效率，虽然静态类型语言有很多优点，然而在编码过程中却需要书写大量的类型。</p>
<h3 id="声明函数返回值类型"><a href="#声明函数返回值类型" class="headerlink" title="声明函数返回值类型"></a>声明函数返回值类型</h3><p>虽然支持类型推导，但是函数返回值类型必须要显式声明，比如：</p>
<p><code>fun sum(x: Int, y: Int): Int { return x + y }</code></p>
<p>此时也许与Java的区别不大，其实Kotlin进一步增强了函数语法，我们可以把 {} 去掉，用等号来定义一个函数：</p>
<p><code>fun sum(x: Int, y: Int) = x + y</code></p>
<p>Kotlin支持的这种单行表达式与等号的语法定义的函数，叫做<strong>表达式函数体</strong>，作为区分，普通的函数声明叫做<strong>代码块函数体</strong>。但是别高兴太早，我们再来看一段递归程序：</p>
<p><code>fun foo(n: Int) = if(n == 0) 1 else n * foo(n - 1)</code></p>
<p>这种情况下，编译器并不能针对递归函数的情况推导类型，因此这里会报错。所以，在一些诸如递归等复杂条件下，及时用表达式定义函数，我们也必须显式声明类型，才能让程序正常工作，代码如下：</p>
<p><code>fun foo(n: Int): Int = if(n == 0) 1 else n * foo(n - 1)</code></p>
<h2 id="val-和-var-的使用规则"><a href="#val-和-var-的使用规则" class="headerlink" title="val 和 var 的使用规则"></a>val 和 var 的使用规则</h2><p>Kotlin声明变量时，引入了 val 和 var 的概念。var 容易理解，就是变量，在JavaScript 中也有用到，但是 val 是什么呢？如果在 IDEA 中反编译 val 的实现成Java代码就能发现，<strong>它是通过 final 这一特性实现的</strong>。 </p>
<h3 id="优先使用val避免副作用"><a href="#优先使用val避免副作用" class="headerlink" title="优先使用val避免副作用"></a>优先使用val避免副作用</h3><p><strong>Kotlin支持一开始不定义 val 变量的取值，随后再进行赋值</strong>，然而，因为引用不可变，所以val声明的变量只能被赋值一次，<strong>并且声明时不能省略变量类型</strong>，如下所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">  <span class="keyword">val</span> a: <span class="built_in">Int</span></span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  println(a)<span class="comment">//输出1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于不可变性，我们可以直到 val 变量在并发环境更安全。</p>
<h3 id="var-的适用场景"><a href="#var-的适用场景" class="headerlink" title="var 的适用场景"></a>var 的适用场景</h3><p>既然 val 那么好，为什么要 var 呢？首先，Kotlin 要兼容Java ，这就注定 必须有 var 的存在；其次有一些场景如果不适用 var 就必须得用到 递归 才能实现了，所以var需要存在。</p>
<h2 id="高阶函数和Lambda"><a href="#高阶函数和Lambda" class="headerlink" title="高阶函数和Lambda"></a>高阶函数和Lambda</h2><p>Kotlin 天然支持了部分<strong>函数式特性</strong>，函数式语言的一个典型特征在于<strong>函数式头等公民</strong>——我们不仅可以像类一样在顶层直接定义一个函数，<strong>也可以在函数内部定义一个局部函数</strong>！如下所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(x: <span class="type">Int</span>)</span></span> {</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(y: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> {</span><br><span class="line">    <span class="keyword">return</span> y * <span class="number">2</span></span><br><span class="line">  }</span><br><span class="line">  println(double(x))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此外，Kotlin还能直接将函数像普通变量一样传递给另一个函数，或在其他函数中被返回，如何理解这个特性？</p>
<h3 id="抽象和高阶函数"><a href="#抽象和高阶函数" class="headerlink" title="抽象和高阶函数"></a>抽象和高阶函数</h3><p>概念东西，略</p>
<h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><p>在Kotlin中，函数类型的格式非常简单，举个例子：<code>(Int) -&gt; Unit</code>，我们可以发现，Kotlin中的函数类型需要遵循以下几点：</p>
<ul>
<li>通过 -&gt; 符号来组织参数类型和返回值类型，左边是参数类型，右边是返回值类型</li>
<li>必须用一个括号来包裹参数类型，如果多个参数，可以用逗号分割，如： <code>(Int， String?) -&gt; Unit</code></li>
<li>返回值<strong>即使是 Unit ，也必须显式声明</strong>    </li>
</ul>
<p>此外，Kotlin 还支持为声明参数指定名字：<code>(errCode: Int， errMsg: String?) -&gt; Unit</code> 这还没完，<strong>高阶函数还支持返回另一个函数</strong>，所以还能这么做：</p>
<figure class="highlight k"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(Int) -&gt; ((Int) -&gt; Unit)</span><br><span class="line"><span class="comment">//如果把后半部分括号省略，可以写成：</span></span><br><span class="line">(Int) -&gt; Int -&gt; Unit</span><br></pre></td></tr></tbody></table></figure>

<h3 id="方法和成员引用"><a href="#方法和成员引用" class="headerlink" title="方法和成员引用"></a>方法和成员引用</h3><p>Kotlin 存在一种特殊的语法，<strong>通过两个冒号来四号线对于某个类的方法进行引用</strong>。假如有一个CountryTest 类的对象实例 countryTest ，如果要引用它的 isBigEuropeanCountry 方法，就可以这么写： </p>
<p><code>countryTest::isBigEuropeanCountry</code></p>
<p>此外，我们还可以直接通过这种语法，来定义一个类的构造方法引用变量：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">    <span class="keyword">val</span> getBook = ::Book</span><br><span class="line">    println(getBook(<span class="string">"Dive into Kotlin"</span>).name)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以发现，getBook 的类型为 (name: String) -&gt; Book 。类似的道理，如果我们要引用某个类中的成员变量，比如Book类中的name，就可以这样引用： <code>Book:name</code> ，以上 Book::name 的类型为 (Book) -&gt; String 。当我们在对Book 类对象的集合应用一些函数式API的时候，就会显得格外有用，比如：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">    <span class="keyword">val</span> bookNames = listOf(</span><br><span class="line">        Book(<span class="string">"Thinking in Java"</span>)</span><br><span class="line">        Book(<span class="string">"Dive into Kotlin"</span>)</span><br><span class="line">    ).map(Book::name)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>略</p>
<h3 id="Lambda-是语法糖"><a href="#Lambda-是语法糖" class="headerlink" title="Lambda 是语法糖"></a>Lambda 是语法糖</h3><p>Kotlin 在JVM 层设计了 Function 类型 (Function0，Function1…Function22)来兼容Java的Lambda表达式，其中后缀数字代表了 Lambda 参数的数量。比如，Function1在源码中就是如下表示的：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Function1</span>&lt;<span class="type">in P1, out R</span>&gt;: <span class="type">kotlin.Function</span>&lt;<span class="type">R</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(p1: <span class="type">P1</span>)</span></span>: R</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可见每个Function 类型都有一个invoke方法，设计Function类型的目的之一就是要兼容Java ，实现在Kotlin 中也能调用Java的Lambda。<strong>在 Java 中，实际上不支持把函数作为参数，而是通过函数式接口来实现这一特性。</strong></p>
<h3 id="函数、Lambda和闭包"><a href="#函数、Lambda和闭包" class="headerlink" title="函数、Lambda和闭包"></a>函数、Lambda和闭包</h3><p>略</p>
<h3 id="“柯里化”风格、扩展函数"><a href="#“柯里化”风格、扩展函数" class="headerlink" title="“柯里化”风格、扩展函数"></a>“柯里化”风格、扩展函数</h3><p>柯里化略</p>
<p>在我们介绍的Lambda的表达式中，还存在一种特殊的语法，如果一个函数只有一个参数，且该参数为函数类型，那么在调用该函数时，外面的括号就可以省略，例子如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">omit</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> {</span><br><span class="line">  block</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么我们在调用的时候，可以写成</span></span><br><span class="line">omit {</span><br><span class="line">  println(<span class="string">"parentheses is omitted"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>另一项特性 扩展函数，允许我们在不修改已有类的前提下，给它增加新的方法，示例如下：</p>
<figure class="highlight k"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun View.invisible() {</span><br><span class="line">    this.visibility = View.INVISIBLE</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上述例子中，类型View被称为<strong>接收者类型</strong>，this对应的是这个类型锁创建的<strong>接收者对象</strong>，this也能被省略，就像这样：</p>
<figure class="highlight k"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun View.invisible() {</span><br><span class="line">    visibility = View.INVISIBLE</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="面向表达式编程"><a href="#面向表达式编程" class="headerlink" title="面向表达式编程"></a>面向表达式编程</h2><p>现在，罗列下我们已经提及的表达式概念：</p>
<ul>
<li>if表达式</li>
<li>函数体表达式</li>
<li>Lambda表达式</li>
<li>函数引用表达式</li>
</ul>
<h3 id="Unit类型：让函数调用皆为表达式"><a href="#Unit类型：让函数调用皆为表达式" class="headerlink" title="Unit类型：让函数调用皆为表达式"></a>Unit类型：让函数调用皆为表达式</h3><p>之所有不能说Java中的函数调用皆是表达式，是因为存在特例 void，在Java中如果声明的函数没有返回值，那么它就要用void修饰：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">()</span> </span>{</span><br><span class="line">  System.out.println(<span class="string">"hahah"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所以foo就不具有值和类型信息，就不能算作一个表达式。函数式语言在所有的情况下都具有返回类型，所以kotlin引入了 Unit 来替代 void 关键字。如何理解 Unit ？其实与 int 一样，都是一种类型，然而它不代表任何信息，它就是一个单例，它的实例只有一个 ，可以写为 () 。</p>
<h3 id="for循环和范围表达式"><a href="#for循环和范围表达式" class="headerlink" title="for循环和范围表达式"></a>for循环和范围表达式</h3><p>在Java中，经常在for来构建循环体：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) {</span><br><span class="line">  System.out.println(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是kotlin会简单很多：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i in 1..10) println(i)  </span><br><span class="line">//当然也能把大括号和i的类型加上</span><br><span class="line">for (i:Int in 1..10) {</span><br><span class="line">  println(i) </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>范围表达式，1..10 这种语法是<strong>范围表达式</strong>(range) 。</p>
<blockquote>
<p>官网的表述是：Range表达式是通过rangeTo 函数实现的，通过 .. 操作符与某种类型的对象组成，除了整形的基本类型外，该类型需要实现 java.lang.Comparable 接口</p>
</blockquote>
<p>举个例子，由于 String类实现了 Comparable 接口，字符串之间可以比较大小，所以我们可以创建一个字符串区间，如 <code>"abc".."xyz"</code> 。</p>
<p>另外，kotlin 还提供了步长和倒序以及半开区间：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步长</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> step <span class="number">2</span>) print(i) <span class="comment">//输出 1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//倒序</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">1</span> step <span class="number">2</span>) print(i) <span class="comment">//输出： 10 8 6 4 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//半开区间</span></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">10</span>) print(i)  <span class="comment">//输出 123456789</span></span><br></pre></td></tr></tbody></table></figure>

<p>用 in 来检查成员关系，，在Kotlin中我们可以用 in 关键字来检查一个元素是否是一个区间或者集合中的成员，比如：<code>"a" in  listOf ("b" , "c")</code> ，会返回 false ；在 in 之前加上叹号就是相反结果： <code>"a" !in  listOf ("b" , "c")</code> 返回true。更多的应用场景如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结合范围表达式</span></span><br><span class="line"><span class="string">"kot"</span> <span class="keyword">in</span> <span class="string">"abc"</span>..<span class="string">"xyz"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//还能通过withIndex 提供键值元祖</span></span><br><span class="line"><span class="keyword">for</span> ((index,value) <span class="keyword">in</span> array.withIndex) {</span><br><span class="line">  println(<span class="string">"the element at <span class="variable">$index</span> is <span class="variable">$value</span>"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><p>前面见识过 in、step、downTo、until 这些写法，都不需要通过点号，而是用<strong>中缀表达式</strong>来被调用，从而语法更直观。这是如何实现的呢？看下标准库中类似的方法 to 的设计：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A,B&gt;</span> A.<span class="title">to</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="函数可变参数"><a href="#函数可变参数" class="headerlink" title="函数可变参数"></a>函数可变参数</h4><p>Java 中采用 “…” 来表示可变参数，<strong>Kotlin中通过 varargs 关键字实现可变参数…</strong>。需要注意的是，<strong>Java 中的可变参数必须是最后一个参数，Ktolin中没有这个限制</strong>，但两者都可以在函数体中以数组方式来使用可变参数变量：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printLetters</span><span class="params">(varargs letters: <span class="type">String</span>, count: <span class="type">Int</span>)</span></span> {</span><br><span class="line">  print(<span class="string">"<span class="subst">${count}</span> letters are "</span>)</span><br><span class="line">  <span class="keyword">for</span> (letter <span class="keyword">in</span> letters) print(letter) <span class="comment">// 输出 3 letters are abc</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//此外，我们还能使用星号(*)来传入外部的变量作为可变参数的变量：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> letters = arrayOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line">printLetters(*letters, count = <span class="number">3</span>) <span class="comment">//同样会输出 3 letters are abc</span></span><br></pre></td></tr></tbody></table></figure>

<p>由于to会返回 Pair 这种键值对的结构数据，因此我们经常会把它与map结合在一起使用，如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mapOf(</span><br><span class="line">    <span class="number">1</span> to <span class="string">"one"</span>,</span><br><span class="line">    <span class="number">2</span> to <span class="string">"two"</span>,</span><br><span class="line">    <span class="number">3</span> to <span class="string">"three"</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="字符串的定义和操作"><a href="#字符串的定义和操作" class="headerlink" title="字符串的定义和操作"></a>字符串的定义和操作</h2><p>kotlin 中有丰富的API，比如： <code>"abcdefg".filter {c -&gt; c in 'a'..'d'}</code> //输出 abcd</p>
<h3 id="定义原生字符串"><a href="#定义原生字符串" class="headerlink" title="定义原生字符串"></a>定义原生字符串</h3><p>Java 对原生字符串只能通过转义字符的方法支持。然而，在Kotlin中已经支持直接写原生字符串，使用3个引号的方式(“””)，体验下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rawString = <span class="string">"""</span></span><br><span class="line"><span class="string">    \n Kotlin is awesonme.</span></span><br><span class="line"><span class="string">    \n Kotlin is a better Java. """</span></span><br><span class="line"></span><br><span class="line">print(rawString)</span><br><span class="line"></span><br><span class="line"><span class="comment">//会打印：</span></span><br><span class="line">\n Kotlin <span class="keyword">is</span> awesonme.</span><br><span class="line">\n Kotlin <span class="keyword">is</span> a better Java.</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到非常简洁，如果用Java 来表示会非常复杂，尤其是 Html 代码。</p>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>略</p>
<h3 id="字符串判等"><a href="#字符串判等" class="headerlink" title="字符串判等"></a>字符串判等</h3><p>Kotlin 中判等性有两种类型：</p>
<ul>
<li>结构相等。 通过 == 来判定两个对象的内容是否相等</li>
<li>引用相等。通过 === 来判断两个对象的引用是否一样，与之相反的操作是 !== ，</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/08/10/%E4%B9%A6-ReactNative%E7%B2%BE%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/ReactNative%E7%B2%BE%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98-%E7%AC%AC1%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/10/%E4%B9%A6-ReactNative%E7%B2%BE%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/ReactNative%E7%B2%BE%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98-%E7%AC%AC1%E7%AB%A0/" class="post-title-link" itemprop="url">第1章：React 与 React Native 简介</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-10 15:30:00 / 修改时间：15:30:21" itemprop="dateCreated datePublished" datetime="2021-08-10T15:30:00+08:00">2021-08-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="React简介"><a href="#React简介" class="headerlink" title="React简介"></a>React简介</h2><p>React 只专注于 MVC 框架设计模式中的 View 层面的实现。为了大大减少传统前端直接操作DOM 的昂贵花费，React 使用Virtual DOM （虚拟DOM）进行DOM的更新，实现了单向数据流传递。下图清晰地描述了 React 底层与前端浏览器的沟通机制。</p>
<p><img src="" alt="Ract框架结构"></p>
<h3 id="React的底层特性"><a href="#React的底层特性" class="headerlink" title="React的底层特性"></a>React的底层特性</h3><p>传统<strong>HTML页面</strong>需要更新页面元素时，<strong>都是将整个页面重新加载实现重绘</strong>，这个代价非常昂贵。后来有了 AJAX 这样的局部更新技术，实现了页面的异步更新，不过AJAX代码编写、维护、性能及更新粒度上还是不够完美。</p>
<p>文档对象模型(Document Object Model， DOM) 是 W3C 组织推荐的处理可扩展标志语言的标准编程接口，<strong>在 HTML 网页上，将构成页面的对象元素组织在一个树形的结构中，用来表示文档中对象的标准模型就称为 DOM</strong>。</p>
<p>React 在底层设计了虚拟DOM，虚拟DOM 与真实 DOM 相互映射，当业务逻辑修改了 Reat 组件中的 state ，<strong>React 框架diff算法会通过比较虚拟 DOM 与 真实DOM 之间的差异，找出哪些部分被修改了，最终只更新差异部分</strong>。这样实现了React 在前端中的高性能表现。</p>
<p>其实，React 并不会在state 更改的第一时间去执行 diff 算法并立即更新页面，而是将多次操作汇聚成一次批量操作，这样再次提升页面更新重绘的效率。</p>
<h2 id="React-Native-简介"><a href="#React-Native-简介" class="headerlink" title="React Native 简介"></a>React Native 简介</h2><p>第3章：React Native 工作原理与生命周期</p>
<h3 id="React-Native框架及工作原理"><a href="#React-Native框架及工作原理" class="headerlink" title="React Native框架及工作原理"></a>React Native框架及工作原理</h3><p>因为 React Native 底层为React 框架，所以，如果是UI层的变更，那么就<strong>映射为虚拟DOM后，调用diff算法计算出变动后的 JSON 映射文件，最终由Native 层将此 JSON 文件映射渲染到原生App的页面元素上</strong>，实现了在项目中只需要控制state 以及 props的变更来引起 ios /Android 平台的 UI 变更。</p>
<p>编写的 RN 代码最终会打包成 main.bundle.js 文件供App 加载，此文件可以存在App本地或者服务器上更新。</p>
<h3 id="RN-与原生平台通信"><a href="#RN-与原生平台通信" class="headerlink" title="RN 与原生平台通信"></a>RN 与原生平台通信</h3><p>RN 与原生的通信如下图所示，采用了 JavaScriptCore 作为 JS VM，中间通过 JSON 文件与 Bridge 进行通信。若使用 Chrome 进行调试，那么所有的 JavaScript 代码都将运行在 Chrome 的 V8 引擎，与原生代码通过 WebSocket 进行通信。</p>
<p><img src="" alt="RN与原生平台通信"></p>
<h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><ol>
<li><p>父子组件之间的通信</p>
<p>在RN中，可以通过 props 的形式实现父组件向子组件传递值，如下例子展示父组件通过调用子组件并赋值子组件的 name 为 React，子组件通过 this.props.name 获取父组件传递过来的 name 字符串 React：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*父子组件通信，在父组件中调用子组件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;ChildComponent name=<span class="string">'React'</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*子组件实现，通过props获取父组件传递的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildComponent</span> <span class="title">extentds</span> <span class="title">Component</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Text</span>&gt;</span> Hello {this.props.name}!<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
<ol start="2">
<li><p>子父组件通信</p>
<p>先略了</p>
</li>
</ol>
<h2 id="React-Native-中的生命周期"><a href="#React-Native-中的生命周期" class="headerlink" title="React Native 中的生命周期"></a>React Native 中的生命周期</h2><p><strong>在 RN 程序启动时，内部的虚拟 DOM 开始建立，生命周期时建立在此虚拟DOM 的整个声明周期之中</strong>，从虚拟DOM 的初始化到虚拟DOM 的卸载 ，RN 为组件的不同状态建立了不同的生命周期。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">223</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共445.2k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/12/',]
      });
      });
  </script>


</body>
</html>
