<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.gitee.io/page/12/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.gitee.io/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">29</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">9</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">126</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/21/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%83%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/21/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%83%E7%AB%A0/" class="post-title-link" itemprop="url">第7章： 数据存储全方案——跨程序共享数据：探究内容提供器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-21 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-21T08:00:00+08:00">2018-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:50:51" itemprop="dateModified" datetime="2019-11-17T21:50:51+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>可能你会有些疑惑，为什么要将我们程序中的数据共享给其他程序呢？当然，这是视情况而定的，比如账号密码之类的隐私数据显然是不能共享给其他程序的，不过一些可以让其他程序进行二次开发的基础性数据，我们还是可以选择共享。例如联系人程序、短信程序、多媒体库等，它们的数据库中保存了很多基础数据，如果不允许其他应用进行访问，则方便性就会大打折扣。</p>
<h3 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h3><p>Android的权限机制在一开始就存在，但是在6.0以前保护隐私方面比较有限，因为像微信这种大家都离不开的软件，容易“店大欺客”，不同意它所有的权限只能不安装，这并不合理。</p>
<h4 id="权限机制详解"><a href="#权限机制详解" class="headerlink" title="权限机制详解"></a>权限机制详解</h4><p>开发者在AndroidManifest.xml中声明权限，一种情况是，用户如果在低于6.0的系统上安装该程序，会在安装时列出该应用所需要的权限，从而决定是否要安装这个程序，并且在用户安装成功之后，还能在<strong>设置</strong>中查看程序所申请的权限，但是对于那些离不开的程序（比如微信）来说，要么全部同意它申请的权限，要么不安装，这不太合理；如果在6.0及以上的系统中安装，则用户不必在安装时一次性授权所有申请的权限，而是在软件使用的过程中再对<strong>危险权限</strong>进行授权，就算拒绝了这个权限，仍然可以使用应用的其他功能，而不是以前那样直接无法安装。</p>
<p>Android 6.0 及以上将所有权限分为两类，<strong>普通权限和危险权限</strong>，普通权限是指不会直接威胁用户的安全和隐私的权限，这部分权限系统自动帮我们授权，避免用户不停地手动授权；危险权限则表示会触及用户隐私或者设备安全性的权限，如获取联系人、定位设备位置等，必须由程序员动态申请，由用户手动点击授权才可以，否则无法使用相应功能。目前为止，Android中的危险权限有9组共24个权限，如下列表所示（图片来自<a target="_blank" rel="noopener" href="https://developer.android.google.cn/guide/topics/security/permissions#normal-dangerous">官网</a>）：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-7/%E5%9B%BE1.png" alt="危险权限列表"></p>
<p>这张表格无需记住，在使用的时候作为参照，如果权限在这张表中，则进行运行时处理就好。<strong>另外注意一下，表格中每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权了，那么该权限对应的权限组中所有的其他权限也会同时被授权</strong>。</p>
<h3 id="在程序运行时申请权限"><a href="#在程序运行时申请权限" class="headerlink" title="在程序运行时申请权限"></a>在程序运行时申请权限</h3><p>以拨打电话的权限为例来说明权限的申请，点击一个按钮，就拨打指定的号码，在6.0以前可能是这样实现的：</p>
<ol>
<li>在AndroidManifest.xml中申请权限：<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CALL_PHONE"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>在代码中实现：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">btnCall.setOnclickListener(<span class="keyword">new</span> View.OnclickListener(){</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>{</span><br><span class="line">		Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CALL);</span><br><span class="line">		intent.setData(Uri.parse(<span class="string">"tel:10086"</span>));</span><br><span class="line">		startActivity(Intent);</span><br><span class="line">	}</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>在6.0以下系统上能正常拨打电话，但是在6.0或者以上系统运行，会报错<strong>Permission Denial</strong>，可以看出是由于权限被禁止导致的，因此我们应该尝试使用以下方式来申请权限：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">btnCall.setOnclickListener(<span class="keyword">new</span> View.OnclickListener(){</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>{</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(ContextCompat.checkSelfPermission(MainActivity.<span class="keyword">this</span>,Manifest.permission.CALL_PHONE) !=   </span><br><span class="line">		PackageManager.PERMISSION_GRANTED){</span><br><span class="line">			ActivityCompat.requestPermission(MainActivity.<span class="keyword">this</span>,<span class="keyword">new</span> </span><br><span class="line">			String[]{Manifest.permission.CALL_PHONE},<span class="number">1</span>);</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			call();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>{</span><br><span class="line">	Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CALL);</span><br><span class="line">	intent.setData(Uri.parse(<span class="string">"tel:10086"</span>));</span><br><span class="line">	startActivity(Intent);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionResult</span><span class="params">(<span class="keyword">int</span> requestCode,String[] permissions,<span class="keyword">int</span>[] grantResults)</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(requestCode){</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">if</span>(grantResults.lenght &gt; <span class="number">0</span> &amp;&amp; grantResults(<span class="number">0</span>) == PackageManager.PERMISSION_GRANTED){</span><br><span class="line">				call();</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				Toast.makeText(<span class="keyword">this</span>,<span class="string">"You denied the permission"</span>,Toast.LEGHTH_SHORT).show();</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上述第一步先判断用户是不是已经给我们授权了，使用的是<strong>ContextCompat.checkSelfPermission</strong>，如果已经授权，直接拨打电话，否则调用<strong>ActivityCompat.requestPermission</strong>方法向用户申请授权，这时候用户可以选择同意或者拒绝我们的申请，不论哪种结果，都会通过回调<strong>onRequestPermissionResult</strong>告知，在回调中根据不同的结果做不同的处理。<strong>记住，在动态声明权限后，AndroidManifest中还得添加<uses-permission android:name="android.permission.CALL_PHONE"> 声明</uses-permission></strong>。</p>
<h3 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h3><p>内容提供器的用法一般有两种，一是使用现有的内容提供器来读取和操作响应程序中的数据，另一种是创建自己的内容提供器给我们的数据提供外部访问接口。</p>
<h4 id="ContentResolver的基本使用"><a href="#ContentResolver的基本使用" class="headerlink" title="ContentResolver的基本使用"></a>ContentResolver的基本使用</h4><p>如果想要访问内容提供器共享的数据，就一定要借助ContentResolver类，可以通过Context中的getContentResolver方法获取到该类的实例。可以对内容进行CRUD操作，不同于SQLiteDatabase，ContentResolver增删改查不接收表名参数，而是使用Uri参数代替，该Uri主要由两部分组成：<strong>authority和path</strong>，前者用于对不同的应用程序做区分，一般采用程序包名形式，如某个程序的包名是com.example.app，那么对应的authority就可以命名为com.example.app.provider；path则是对同一应用程序中不同表做区分的，通常会添加到authority后面，所以内容Uri的形式一般如下所示(带协议声明)：</p>
<blockquote>
<p>content://com.example.app.provicer/table1<br>content://com.example.app.provicer/table2</p>
</blockquote>
<p>正式查询的时候，将Uri作为参数传入，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">"content://com.example.app.provicer/table1"</span>);</span><br><span class="line">Cuisor cursor = getContentResolver().query(uri,projection,selection,selectionArgs,sortOrder);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>其中，query方法中各个参数对应的含义如下所示：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-7/%E5%9B%BE2.png" alt="参数对应的含义"></p>
<p>接下来便可以进行相应的增删改查操作，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查</span></span><br><span class="line"><span class="keyword">if</span>(cursor != <span class="keyword">null</span>){</span><br><span class="line">	<span class="keyword">while</span>(cursor.moveToNext()){</span><br><span class="line">		String colomn1 = cursor.getString(cursor.getColumnIndex(<span class="string">"column1"</span>));</span><br><span class="line">		<span class="keyword">int</span> colomn2 = cursor.getInt(cursor.getColumnIndex(<span class="string">"column2"</span>));</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增</span></span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"column1"</span>,<span class="string">"text"</span>);</span><br><span class="line">values.put(<span class="string">"column2"</span>,<span class="number">1</span>);</span><br><span class="line">getContentResolver().insert(uri,values);</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改，把column1的值清空</span></span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"column1"</span>,<span class="string">""</span>);</span><br><span class="line">getContentResolver().update(uri,values,<span class="string">"column1 = ? and column2 = ?"</span>,<span class="keyword">new</span> String[]{<span class="string">"text"</span>,<span class="string">"1"</span>});</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line">getContentResolver().delete(uri,<span class="string">"column2 = ?"</span>,<span class="keyword">new</span> String[]{<span class="string">"1"</span>});</span><br></pre></td></tr></tbody></table></figure>

<p>其实整体就相当于sql语句，因此并不太难。</p>
<h3 id="创建自己的内容提供器"><a href="#创建自己的内容提供器" class="headerlink" title="创建自己的内容提供器"></a>创建自己的内容提供器</h3><p>因为基本上没有这样的需求，暂时略后续补上</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/11/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/11/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%85%AD%E7%AB%A0/" class="post-title-link" itemprop="url">第6章：数据存储全方案：详解持久化技术</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-11 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-11T08:00:00+08:00">2018-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:51:55" itemprop="dateModified" datetime="2019-11-17T21:51:55+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>Android系统主要提供了3种方式用于简单地实现数据持久化功能——文件存储、SharedPreference存储以及数据库存储。</p>
<h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>文件存储是Android中最基本的存储方式，它不对存储内容进行任何的格式化处理，因而比较适合用于存储一些<strong>简单的文本数据</strong>或者<strong>二进制数据</strong>。</p>
<h3 id="将数据存储到文件"><a href="#将数据存储到文件" class="headerlink" title="将数据存储到文件"></a>将数据存储到文件</h3><p>Context类提供了一个openFileOutput()方法，可以用于将数据存储到指定文件，需要两个参数，第一个参数是文件名，纯粹的名称，不可以包含路径，因为所有的文件都是默认存储到<strong>/data/data/<packagename>/files/</packagename></strong>目录下；还有个参数是操作模式，主要有两种（其他2种在4.2被废弃了）：</p>
<ul>
<li>MODE_PRIVATE:默认的操作模式，表示当指定同样文件名的时候，所写入的内容将会覆盖原来文件中的内容。</li>
<li>MODE_APPEND:表示如果该文件已经存在，就往文件里面追加内容，不存在就创建新文件。</li>
</ul>
<p>保存文件的一般如以下代码操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>{</span><br><span class="line">	String dataStr = <span class="string">"data to save"</span>;</span><br><span class="line">	FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">	BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span>{</span><br><span class="line">		<span class="comment">//文件名是data</span></span><br><span class="line">		out = openFileOutput(<span class="string">"data"</span>,Context.MODE_PRIVATE);</span><br><span class="line">		writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out));</span><br><span class="line">		writer.write(dataStr);</span><br><span class="line">	}<span class="keyword">catch</span>(IOException e){</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	}finnaly{</span><br><span class="line">		<span class="keyword">try</span>{</span><br><span class="line">			<span class="keyword">if</span>(writer != <span class="keyword">null</span>){</span><br><span class="line">				writer.close();</span><br><span class="line">			}<span class="keyword">catch</span>(IOException e){</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>存储成功后，可以通过Android Device Monitor 进入File Explorer标签，在目录中/data/data/<packagename>/files/中就能找到 data 文件。同理，读取存到文件中的代码应如下所示：</packagename></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">()</span></span>{</span><br><span class="line">	FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">	BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">	StringBuilder content = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">try</span>{</span><br><span class="line">		in = openFileInput(<span class="string">"data"</span>);</span><br><span class="line">		reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">		String line = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">while</span>((line = reader.readLine()) != <span class="keyword">null</span>){</span><br><span class="line">			content.append(line);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}<span class="keyword">catch</span>(IOException e){</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	}finnaly{</span><br><span class="line">		<span class="keyword">try</span>{</span><br><span class="line">			<span class="keyword">if</span>(reader != <span class="keyword">null</span>){</span><br><span class="line">				reader.close();</span><br><span class="line">			}<span class="keyword">catch</span>(IOException e){</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> content.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="SharedPreference"><a href="#SharedPreference" class="headerlink" title="SharedPreference"></a>SharedPreference</h2><p>SharedPreference是使用键值对的方式来存储数据的，保存一条数据的时候，需要给这条数据提供一个对应的键，读取数据时通过这个键把对应的值读取出来，SharedPreference文件都是存放在/data/data/<packagename>/shared_prefs目录下。要想存储数据，首先要获取到SharedPreference对象，Android主要提供了3中方式：</packagename></p>
<ul>
<li><p>Context类中的getSharedPreference()方法：此方法接收两个参数，第一个用于指定文件名称，第二个用于指定操作模式，目前只有MODE_PRIVATE可选（其他的几种在4.2或者6.0版本被废弃了），并且是默认的操作模式，表示只有当前应用程序才可以对这个文件进行读写。</p>
</li>
<li><p>Activity中的getPreferences()方法：和Context类中的getSharedPreference()方法类似，只不过它只接受一个操作模式参数，因为使用这个方法时会自动将当前Activity的类名作为SharedPreference的文件名。</p>
</li>
<li><p>PreferenceManager类中的getDefaultSharedPreferences()方法：它接受一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreference文件。</p>
</li>
</ul>
<p>获取到SharedPreference对象之后，就可以开始存储数据了，主要分为3步实现：</p>
<ol>
<li>调用SharedPreference对象的edit()方法获取SharedPreference.Editor对象</li>
<li>向SharedPreference.Editor对象添加数据。</li>
<li>调用apply()方法提交，从而完成存储操作。</li>
</ol>
<p>代码形式应该是这样的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences.Editor editor = getSharedPreferences(<span class="string">"data"</span>,MODE_PRIVATE).edit();</span><br><span class="line">editor.putString(<span class="string">"name"</span>,<span class="string">"Tom"</span>);</span><br><span class="line">editor.apply();</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储完成后，读取数据</span></span><br><span class="line">SharedPreferences pref = getSharedPreferences(<span class="string">"data"</span>,MODE_PRIVATE);</span><br><span class="line">String name = pref.getString(<span class="string">"name"</span>,<span class="string">""</span>);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a>SQLite数据库存储</h2><p>文件存储和SharedPrefrences存储只适用于保存一些简单的数据和键值对，要存储大量复杂的关系型数据的时候，有点难以应付了。</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>Android为了让我们更方便地管理数据库，专门提供了一个SQLiteOpenHelper抽象类，要想使用的话，我们就需要创建一个自己的类去继承它，它有两个抽象方法，onCreate和onUpgrade用来创建和升级数据库，其它两个重要的实例方法：getReadableDatabase和getWritableDatabase，他们都可以创建或者打开一个现有的数据库（没有就创建），在数据库不可写入的时候（如磁盘满了），前者以只读的形式打开数据库，后者会出现异常。它有两个构造方法可重写，一般使用哪个参数较少的即可，总共4个参数，第一个context，第二个是数据库名，第三个是自定义的Cursor，一般传null，第四个表示当前的数据库版本号，用于对数据库进行升级操作。一般代码如下图所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span></span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CREATE_BOOK = <span class="string">"create table Book ("</span></span><br><span class="line">		+ <span class="string">"id integer primary key autoincrement,"</span></span><br><span class="line">		+ <span class="string">"author text,"</span></span><br><span class="line">		+ <span class="string">"price real,"</span></span><br><span class="line">		+ <span class="string">"pages integer,"</span></span><br><span class="line">		+<span class="string">"name text)"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span>{</span><br><span class="line">			db.exeSQL(CREATE_BOOK);</span><br><span class="line">		}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用的时候应该是这样子的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>,<span class="string">"BookStore.db"</span>,<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//就会创建成功了</span></span><br><span class="line">dbHelper.getWritableDatabase();</span><br></pre></td></tr></tbody></table></figure>

<p>上例创建了一个Book表，使用primary key 将id设置为主键，并用autoincrement关键字表示id是自增长的。可以使用</p>
<blockquote>
<p>adb shell</p>
</blockquote>
<p>命令，之后cd到/data/data/<packagename>/databases/目录下用<strong>ls</strong>列出该目录的文件，可以看到BookStore.db文件，以及BookStore.db-journal文件，后者是数据库的临时文件。SQLite没有其他数据库一样有很多繁杂的数据类型，它的数据类型很简单：<strong>integer表示整型，real表示浮点型，text表示文本，blob表示二进制类型</strong>；</packagename></p>
<h3 id="升级数据库"><a href="#升级数据库" class="headerlink" title="升级数据库"></a>升级数据库</h3><p>此时项目中有一张Book表用于存放输的各种详细数据了，但是如果再想添加一张Category表用于记录图书的分类，如果仅仅直接在MyDatabaseHelper的onCreate中写成：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span>{</span><br><span class="line">	db.exeSQL(CREATE_BOOK);</span><br><span class="line">	db.exeSQL(CREATE_CATEGORY);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>是行不通的，因为使用的时候先初始化helper：<strong>dbHelper = new MyDatabaseHelper(this,”BookStore.db”,null,1)</strong>再获取数据库：<strong>dbHelper.getWritableDatabase()</strong>，而由于此时已经存在数据库BookStore.db了，因此不会再执行helper的onCreate方法了。此时清除app数据可以做到创建Category表，但是这在实际应用中不合理，而我们可以用<strong>onUpgrade</strong>方法来解决，我们前面构造了MyDatabaseHelper，第4个参数是版本号，我们目前是1，所以只要传入的值大于当前版本号1，onUpgrade方法就可以执行，因此我们可以这样增加Category表：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span></span>{</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db,<span class="keyword">int</span> oldVersion,<span class="keyword">int</span> newVersion)</span></span>{</span><br><span class="line">		db.exeSQL(<span class="string">"drop table if exists Book"</span>);</span><br><span class="line">		db.exeSQL(<span class="string">"drop table if exists Category"</span>);</span><br><span class="line">		onCreate(db);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码执行了两条drop语句，发现数据库已经存在Book表和Category表了就删除，然后调用onCreate方法重新创建，因此在onCreate中也得写成：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span>{</span><br><span class="line">	db.exeSQL(CREATE_BOOK);</span><br><span class="line">	db.exeSQL(CREATE_CATEGORY);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在使用的时候也得升级版本号：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>,<span class="string">"BookStore.db"</span>,<span class="keyword">null</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//就会创建成功了</span></span><br><span class="line">dbHelper.getWritableDatabase();</span><br></pre></td></tr></tbody></table></figure>

<p>获取到数据库，接下来可以对其CRUD操作，其中C代表添加（Create），R代表查询（retrieve），U代表更新（Update），D代表删除（Delete）。Android开发者水平参差不齐，并非每一个都会SQL语言，Android提供了一系列的辅助性方法，是的在Android中即使不去编写SQL语句，也能轻松完成所有CRUD操作。getReadableDatabase与getWriteableDatabase方法不仅可以用来创建和升级数据库，他们还会返回一个SQLiteDatabase对象，借助这个对象就可以轻松CRUD：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**添加数据**/</span></span><br><span class="line">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"name"</span>,<span class="string">"thinking in java"</span>);</span><br><span class="line">values.put(<span class="string">"price"</span>,<span class="number">16.96</span>);</span><br><span class="line">values.put(<span class="string">"pages"</span>,<span class="number">512</span>);</span><br><span class="line"><span class="comment">//插入时指定表名为"Book"</span></span><br><span class="line">db.insert(<span class="string">"Book"</span>,<span class="keyword">null</span>,values);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**以下是更新**/</span></span><br><span class="line">values.clear();</span><br><span class="line">values.put(<span class="string">"price"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//第三个参数对应SQL语句中的where部分，表示更新所有name等于?的行，而?是一个占位符，</span></span><br><span class="line"><span class="comment">//可以通过第四个参数提供的一个字符串数组为第三个参数中的每个占位符指定相应内容</span></span><br><span class="line">db.update(<span class="string">"Book"</span>,values,<span class="string">"name=?"</span>,<span class="keyword">new</span> String[]{<span class="string">"thinking in java"</span>});</span><br><span class="line"></span><br><span class="line"><span class="comment">/**以下是删除**/</span></span><br><span class="line"><span class="comment">//表示删除pages的值大于500的数据</span></span><br><span class="line">db.delete(<span class="string">"Book"</span>,<span class="string">"pages &gt; ?"</span>,<span class="keyword">new</span> String[]{<span class="string">"500"</span>});</span><br><span class="line"></span><br><span class="line"><span class="comment">/**以下是查询**/</span></span><br><span class="line">Cursor cusor = db.query(<span class="string">"Book"</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span>(cursor.moveToFirst()){</span><br><span class="line">	<span class="keyword">do</span>{</span><br><span class="line">		String name = cursor.getString(cursor.getColumnIndex(<span class="string">"name"</span>));</span><br><span class="line">		String pages = cursor.Double(cursor.getColumnIndex(<span class="string">"price"</span>));</span><br><span class="line">	}<span class="keyword">while</span>(cursor.moveToNext());</span><br><span class="line">}</span><br><span class="line">cusor.close();</span><br></pre></td></tr></tbody></table></figure>

<p>当然，可以直接使用SQL语句直接完成上述操作：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>添加</span><br><span class="line">db.execSQL("insert into Book (name,pages,price) values(?,?,?)",<span class="keyword">new</span> String[]{"thinking in java","512","20"});</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>升级</span><br><span class="line">db.execSQL("update Book set price = ? where name = ",<span class="keyword">new</span> String[]{"20","thinking in java"});</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除</span><br><span class="line">db.execSQL("delete from Book where pages &gt; ?",<span class="keyword">new</span> String[]{"500"});</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询</span><br><span class="line">db.execSQL("select * from Book",<span class="keyword">null</span>);</span><br></pre></td></tr></tbody></table></figure>



<h2 id="使用LitePal"><a href="#使用LitePal" class="headerlink" title="使用LitePal"></a>使用LitePal</h2><p><strong>略</strong></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/10/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/10/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%94%E7%AB%A0/" class="post-title-link" itemprop="url">第5章： 全局大喇叭：详解广播机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-10 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-10T08:00:00+08:00">2018-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-05 20:39:05" itemprop="dateModified" datetime="2020-05-05T20:39:05+08:00">2020-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h3 id="广播机制介绍"><a href="#广播机制介绍" class="headerlink" title="广播机制介绍"></a>广播机制介绍</h3><p>Android中广播分为<strong>标准广播</strong>和<strong>有序广播</strong>，标准广播是一种完全异步执行的广播，广播发出后，所有广播接收器机会会在同一时刻接收到广播，但同时意味着它也是无法被截断的。有序广播是一种同步执行的广播，同一时刻只有一个广播接收器能收到这条消息，当这个广播接收器的逻辑执行完毕之后才会继续传递，优先级高的广播接收器可以先收到广播，并且还可以阶段正在传递的广播，这样后面的广播接收器就收不到这条广播消息。</p>
<h4 id="动态注册和静态注册广播"><a href="#动态注册和静态注册广播" class="headerlink" title="动态注册和静态注册广播"></a>动态注册和静态注册广播</h4><p>动态注册一般在Activity的onCreate方法中写上类似于：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">receiver = <span class="keyword">new</span> MyReceiver();</span><br><span class="line">registerReceiver(receiver,filter);</span><br></pre></td></tr></tbody></table></figure>

<p>并且在onDestroy方法中注销广播：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; unregisterReceiver(receiver);</span><br></pre></td></tr></tbody></table></figure>

<p>然后，完善一般是内部类的MyReceiver：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span></span>{</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context,Intent intent)</span></span>{</span><br><span class="line">		Toast.makeText(context,<span class="string">"receive the broadcast"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后得在适当的时候发送广播：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>当然，如果你是用广播在APP中实现强制退出登录（如QQ账号在另一台设备上登录了），那你只需要在当前Activity上弹一个窗提示已经被强制下线即可，因此有必要将广播在BaseActivity中注册，并且在BaseActivity的onPause方法（注意不是onDestroy方法了，因为我们只需要栈顶的Activity能够响应就行）中注销广播即可。如果是接收系统级广播，可能还得在AndroidManife.xml中声明相关权限</strong>。APP中实现强制退出登录时的广播接收器可以这样写：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForceOfflineReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span></span>{</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(<span class="keyword">final</span> Context context,Intent intent)</span></span>{</span><br><span class="line">		AltertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(context);</span><br><span class="line">		builder.setTitle(<span class="string">"warning"</span>);</span><br><span class="line">		builder.setMessage(<span class="string">"force offline"</span>);</span><br><span class="line">		builder.setCancelable(<span class="keyword">false</span>);</span><br><span class="line">		builder.setPositiveButton(<span class="string">"ok"</span>,<span class="keyword">new</span> DialogInterface.OnclickListener(){</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onclick</span><span class="params">(DialogInterface dialog,<span class="keyword">int</span> which)</span></span>{</span><br><span class="line">				ActivityCollector.finishAll();<span class="comment">//销毁所有活动</span></span><br><span class="line">				Intent intent = <span class="keyword">new</span> Intent(context,LoginActivity.class);</span><br><span class="line">				context.startActivity(intent);</span><br><span class="line"></span><br><span class="line">			}</span><br><span class="line">		});</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>静态注册广播是在AndroidManife.xml中做如下的声明，<strong>其中MyReceiver类一般不是内部类，因为即使app未启动也能接收广播</strong>：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:label</span>=<span class="string">"@string/appname"</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:name</span>=<span class="string">".MyReceiver"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.MyReceiver"</span></span></span><br><span class="line"><span class="tag"> &lt;/<span class="attr">receiver</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果要发送有序广播，只需要将以上发送广播的代码<strong>sendBroadcast(intent)</strong>替换成<strong>sendOrderedBroadcast(intent,null);</strong>即可。设置广播的优先级只需要设置intentFilter的priority属性即可（AndroidManifest文件中是intent-filter属性）。</p>
<h3 id="使用本地广播"><a href="#使用本地广播" class="headerlink" title="使用本地广播"></a>使用本地广播</h3><p>前面发送的广播属于系统全局广播，发出的广播可以被任何应用接收到，并且我们也可以接受来自其它任何应用发出的广播，这容易引起安全性问题，比如关键数据广播被其他应用截获，或者其他应用发送各种垃圾广播。本地广播的发送有些不同：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalBroadcastManager manager = LocalBroadcastManager.getInstance(<span class="keyword">this</span>);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">manager.sendBroadcast(intent);</span><br></pre></td></tr></tbody></table></figure>

<p>注册：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">localReceiver = <span class="keyword">new</span> LocalReceiver();</span><br><span class="line">manager.registerReceiver(localReceiver,filter);</span><br></pre></td></tr></tbody></table></figure>
<p>同样注销广播：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager.unregisterReceiver(localReceiver);</span><br></pre></td></tr></tbody></table></figure>

<p>本地广播的几点优势：</p>
<ul>
<li>可以明确地知道正在发送的广播不会离开我们的程序，因此不必担心机密数据泄露。</li>
<li>其他的程序无法将广播发送到我们程序内部，因此不用担心会有安全漏洞隐患。</li>
<li>发送本地广播比发送系统全局广播更加高效。</li>
</ul>
<p><strong>另有一点需要说明：本地广播是无法通过静态注册方式来接收的，其实这也完全可以理解，因为静态注册主要就是为了让程序在未启动的情况下也能接收广播，而发送本地广播时，我们的程序肯定是已经启动了；此外，不要再onReceive方法中添加过多的逻辑或者进行任何耗时的操作，因为广播接收器中是不允许开启线程的，当onReceive方法运行了较长时间而没有结束时，程序就会报错。因此它更多的只是扮演一种打开程序其他组件的角色，如弹一条通知，或者启动一个服务等。</strong></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/09/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/09/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">第4章：手机平板要兼顾：探究fragment</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-09 16:00:00" itemprop="dateCreated datePublished" datetime="2018-06-09T16:00:00+08:00">2018-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:52:15" itemprop="dateModified" datetime="2019-11-17T21:52:15+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>这一章前面部分主要讲解Fragment的基本使用，这点我觉得官方文档关于fragment的知识可能会更好一些，以下是官方的阐述：</p>
<p>主要是平时使用Fragment时，对其使用方法有疑惑，以下或许能解释部分：</p>
<h3 id="为什么使用Fragment"><a href="#为什么使用Fragment" class="headerlink" title="为什么使用Fragment"></a>为什么使用Fragment</h3><p><strong>参考自官方</strong>：主要是为了在大屏幕手机（如平板电脑）上更加零落的UI设计，可以更方便地组合和交换UI组件。</p>
<h3 id="Fragment的创建"><a href="#Fragment的创建" class="headerlink" title="Fragment的创建"></a>Fragment的创建</h3><p>想为Fragment提供布局，则必须实现onCreateView()回调，可以通过xml定义布局资源，为此，onCreateView()提供了一个LayoutInflater对象：</p>
<pre><code>public static class ExampleFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.example_fragment, container, false);
    }
}</code></pre><h3 id="向Activity中添加Fragment"><a href="#向Activity中添加Fragment" class="headerlink" title="向Activity中添加Fragment"></a>向Activity中添加Fragment</h3><h4 id="1、在Activity的布局文件中声明："><a href="#1、在Activity的布局文件中声明：" class="headerlink" title="1、在Activity的布局文件中声明："></a>1、在Activity的布局文件中声明：</h4><pre><code>&lt;?xml version="1.0" encoding="utf-8"&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;

    &lt;fragment android:name="com.example.ListFragment"
            android:id="@+id/list"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" /&gt;

    &lt;fragment android:name="com.example.AticleFragment"
            android:id="@+id/viewer"
            android:layout_weight="2"
            android:layout_width="0dp"
            android:layout_height="match_parent" /&gt;
&lt;/LinearLayout&gt;</code></pre><blockquote>
<p><strong>官方解释</strong>:Activity初始化布局时，会实例化布局中指定的每个fragment，并为每个Fragment调用onCreateView()方法，系统会直接插入Fragment返回的View来替代<fragment>元素。</fragment></p>
</blockquote>
<h4 id="2、通过编程方式将Fragment添加到某个现有的ViewGroup："><a href="#2、通过编程方式将Fragment添加到某个现有的ViewGroup：" class="headerlink" title="2、通过编程方式将Fragment添加到某个现有的ViewGroup："></a>2、通过编程方式将Fragment添加到某个现有的ViewGroup：</h4><p>可以在Activity运行期间将Fragment添加进去，你只需要指定Fragment要放入哪个ViewGroup，这需要使用FragmentTransaction：</p>
<pre><code>FragmentManager fragmentManager = getFragmentManager();
FragmentTransaction transaction = fragmentManager.beginTransaction();</code></pre><p>然后，你可以使用add()方法添加一个fragment：</p>
<pre><code>ExampleFragment fragment = new ExampleFragment();
transaction.add(R.id.fragment_container,fragment);
transaction.commit();</code></pre><blockquote>
<p>一旦通过FragmentTransaction做出了更改，就必须commit以使更改生效。</p>
</blockquote>
<h4 id="3、添加没有UI的Fragment："><a href="#3、添加没有UI的Fragment：" class="headerlink" title="3、添加没有UI的Fragment："></a>3、添加没有UI的Fragment：</h4><p>你可以使用Fragment为Activity提供后台行为，而不显示额外的UI。使用函数：</p>
<pre><code>add(Fragment,String)</code></pre><p>String类型参数为Fragment提供一个唯一的字符串标记，由于Fragment没有雨Activity中的视图关联，因此不会收到onCreate()调用，因此你可以不实现这个方法。如果你稍后想从Activity中获取到这个Fragment，可以使用findFragmentByTag()。</p>
<blockquote>
<p>可以在SDK的sample中查看具体用法：<sdk_root>/APIDemos/app/src/main/java/com/example/android/apis/app/FragmentRetainInstance.java </sdk_root></p>
</blockquote>
<h3 id="执行Fragment事务"><a href="#执行Fragment事务" class="headerlink" title="执行Fragment事务"></a>执行Fragment事务</h3><p>需要使用FragmentTransaction，可以使用：</p>
<pre><code>add() 、remove() 、replace()</code></pre><p>等方法设置想要执行的更改，然后commit生效。</p>
<p>不过在commit之前你可能想调用 addToBackStack()将其添加到Fragment事务返回栈，允许用户按返回键返回上一Fragment状态。</p>
<p>来个例子：</p>
<pre><code>/**create new fragment and transaction**/

Fragment newFragment = new ExampleFragment();
FragmentTransaction transaction = getFragment().beginTransaction();

/**Replace whatever is in the fragment_container view with this fragment
and add the transaction to the back stack**/

transaction.replace(R.id.fragment_container,newFragment);
transaction.addToBackStack(null);

//commit the transaction
transaction.commit();</code></pre><p>向FragmentTransaction添加更改的顺序无关紧要，但有一些注意事项：</p>
<blockquote>
<p>commit操作不会立即执行，而是等主线程认为可以执行的时候再运行，不过，如果有必要，你也可以从主线程调用executePendingTransactions() 以立即执行commit。</p>
</blockquote>
<blockquote>
<p>最后必须调用commit，而且只能在用户离开Activity之前commit，否则会引发异常，如果对于需要commit的更改无关紧要，可以使用commitAllowingStateLoss()。</p>
</blockquote>
<blockquote>
<p>可以向同一个容器中添加多个fragment，你添加的顺序决定他们在视图层次结构中出现的顺序。</p>
</blockquote>
<h3 id="管理Fragment"><a href="#管理Fragment" class="headerlink" title="管理Fragment"></a>管理Fragment</h3><p>需要使用FragmentManager，你可以使用它执行以下操作：</p>
<ul>
<li><p>findFragmentById() （<strong>对于在Activity布局中提供UI的Fragment</strong>）或者findFragmentByTag()（<strong>对于提供或者不提供UI的Fragment都可</strong>）。</p>
</li>
<li><p>popBackStack() (<strong>模拟用户发出的返回命令</strong>)，将Fragment从返回栈中弹出。</p>
</li>
<li><p>addOnBackStackChangedListener() 监听返回栈变化</p>
</li>
</ul>
<h3 id="与Activity通信"><a href="#与Activity通信" class="headerlink" title="与Activity通信"></a>与Activity通信</h3><p>Fragment可以通过getActivity()访问Activity实例，并轻松执行诸如在Activity布局中查找视图等任务：</p>
<pre><code>View listView = getActivity().findViewById(R.id.list);</code></pre><p>同样，Activity也可以使用findFragmentById 或者 findFragmentByTag,通过从FragmentManager获取Fragment的引用来调用Fragment中的方法：</p>
<pre><code>ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);</code></pre><h3 id="一个应用场景例子"><a href="#一个应用场景例子" class="headerlink" title="一个应用场景例子"></a>一个应用场景例子</h3><p>一个新闻应用中Activity两个Fragment，Fragment A放列表list，Fragment B 放对应内容，那么A在列表项选定后，告诉Activity，以便Activity通知B显示该新闻。其方案可以这样设计：</p>
<p>在A中声明接口OnArticleSelectedListener ：</p>
<pre><code>public static class FragmentA extends ListFragment {
    ...
    // Container Activity must implement this interface
    public interface OnArticleSelectedListener {
        public void onArticleSelected(Uri articleUri);
    }
    ...
}</code></pre><p>同事在Activity中实现接口OnArticleSelectedListener，在A的onAttach方法时判断Activity是否这样做了：</p>
<pre><code>public static class FragmentA extends ListFragment {
    OnArticleSelectedListener mListener;
    ...
    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        try {
            mListener = (OnArticleSelectedListener) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException(activity.toString() + " must implement OnArticleSelectedListener");
        }
    }
    ...
}</code></pre><p>当有点击事件的时候，A看起来是这样子的：</p>
<pre><code>public static class FragmentA extends ListFragment {
    OnArticleSelectedListener mListener;
    ...
    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        // Append the clicked item's row ID with the content provider Uri
        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);
        // Send the event and Uri to the host activity
        mListener.onArticleSelected(noteUri);
    }
    ...
}</code></pre><p>Fragment的生命周期如下图：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-4/fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="fragment生命周期"></p>
<p>其中将fragment进行至fragment的resume状态（即可以跟用户交互）的核心序列如下：</p>
<ul>
<li><p>onAttach(Activity) ：activity与fragment关联的时候调用.</p>
</li>
<li><p>onCreate(Bundle) ：fragment初始化的时候调用.</p>
</li>
<li><p>onCreateView(LayoutInflater, ViewGroup, Bundle) ：为fragment创建返回view界面.</p>
</li>
<li><p>onActivityCreated(Bundle): 通知fragment它绑定的那个Activity已经执行完了onCreate()操作.</p>
</li>
<li><p>onViewStateRestored(Bundle)： 通知fragment它保存的view state已经被恢复了.</p>
</li>
<li><p>onStart()： fragment对用户可见 (还要取决于包含这个fragment的activity是否已经启动了).</p>
</li>
<li><p>onResume()： 使fragment可以和用户交互了 (还要取决于包含这个fragment的activity是否已经resume了).<br>如果一个fragment不再使用了，它会执行一系列相反的过程:</p>
</li>
<li><p>onPause()： fragment不能与用户交互（可能是由于activity的pause）。 </p>
</li>
<li><p>onStop()： fragment不可见了（可能是由于activitystop了）。</p>
</li>
<li><p>onDestroyView()：通知fragment清理与它相关的view资源。</p>
</li>
<li><p>onDestroy()：在完全清理fragment的状态时调用。</p>
</li>
<li><p>onDetach()：当fragment与activity解除绑定时调用。</p>
</li>
</ul>
<h3 id="动态加载布局的技巧"><a href="#动态加载布局的技巧" class="headerlink" title="动态加载布局的技巧"></a>动态加载布局的技巧</h3><h4 id="使用限定符"><a href="#使用限定符" class="headerlink" title="使用限定符"></a>使用限定符</h4><p>如果使用平板就会发现里面的应用基本上是双页模式，但是在手机上限于屏幕大小，都是单页模式。如果判断该使用双页模式还是单页模式，这就要借助<strong>限定符（qualifiers）</strong>来实现了，我们可以有两个布局文件，一个 layout_single.xml 单页模式布局放在layout目录，一个 layout_double.xml 双页模式布局放在 layout-large 目录，其中的large是个限定符。Android中常用限定符如下：<br><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-4/%E9%99%90%E5%AE%9A%E7%AC%A61.png" alt="android限定符1"><br><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-4/%E9%99%90%E5%AE%9A%E7%AC%A62.png" alt="android限定符2"></p>
<h4 id="使用最小限定符"><a href="#使用最小限定符" class="headerlink" title="使用最小限定符"></a>使用最小限定符</h4><p>前面解决了单页双页模式，但是到底怎么才算large，我们需要更精确地控制的话，需要最小限定符。我们新建layout-600dp文件夹，将双页布局文件放入其中，这样就会意味着，当程序运行在宽度小于600dp的设备上时，显示的是单页布局，否则使用的是双页布局。</p>
<p>以上两种技巧可以将手机版和pad版都使用同一个app，避免维护多个app，一处改动，需要在两个app中同步改动。注意在代码中区别目前是双页模式还是单页模式，可以用以下方式：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(findViewById(R.id.anotherpageid) == <span class="keyword">null</span>){</span><br><span class="line">    <span class="comment">//单页</span></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">    <span class="comment">//双页</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中R.id.anotherpageid是在单页中所没有的那个布局的id。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/09/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%89%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/09/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%89%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：软件和也要拼脸蛋</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-09 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-09T08:00:00+08:00">2018-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:50:58" itemprop="dateModified" datetime="2019-11-17T21:50:58+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>布局文件中如果添加Button，并指定其text为”button”的话，但是显示的是”BUTTON”，全部变为大写了，要去掉这一效果，可以添加属性<strong>android:textAllCaps=”false”</strong></p>
<p>RelativeLayout 中还有另外一组对于控件进行定位的属性，android:layout_alignLeft表示让一个控件的左边缘和另一个控件的左边缘对齐，同理，还有android:layout_alignRight、Top、Bottom 。</p>
<h3 id="创建自定义控件"><a href="#创建自定义控件" class="headerlink" title="创建自定义控件"></a>创建自定义控件</h3><p>我们所用的所有控件都是直接或者间接继承自View的，所有的布局都是直接或者间接继承ViewGroup，View是Android中最基本的一种UI组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是在View的基础上添加各自特有功能；而ViewGroup则是一种特殊的View，它可以包含很多子View和子ViewGroup，是一个防止控件和布局的容器。常用控件和布局的继承结构如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-3/%E5%9B%BE1.png" alt="view继承关系"></p>
<p>App中的标题栏几乎在每个界面都是一样的，除了标题不一样，其他的诸如左边按钮点击就finish当前页面，右边的是菜单按钮，这些功能基本上一样，如果在每个页面都单独为这些按钮重复添加相同的监听，比较繁琐。所以可以将标题栏单独封装成单独的一个TitleLayout的，每次只需要引入到布局中即可。</p>
<h3 id="使用listview"><a href="#使用listview" class="headerlink" title="使用listview"></a>使用listview</h3><p>可以继承ArrayAdapter简化操作，类似如下(当然，这里在getView的时候没有进行复用优化，仅仅只是示例)：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Fruit</span>&gt;</span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> resourceId;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FruitAdapter</span><span class="params">(Context context,<span class="keyword">int</span> resourceId,List&lt;Fruit&gt; objects)</span></span>{</span><br><span class="line">		<span class="keyword">super</span>(context,resourceId,objects);</span><br><span class="line">		<span class="keyword">this</span>.resourceId = resourceId;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position,View convertView,ViewGroup parent)</span></span>{</span><br><span class="line">		Fruit fruit = getItemt(position);</span><br><span class="line">		View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,<span class="keyword">false</span>);</span><br><span class="line">		ImageView ivFruit = view.findViewById(R.id.img);</span><br><span class="line">		TextView tvFruit = view.findViewById(R.id.txt);</span><br><span class="line">		ivFruit.setImageResource(fruit.getImageId());</span><br><span class="line">		tvFruit.setText(fruit.getName());</span><br><span class="line">		<span class="keyword">return</span> view;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h3 id="使用更强大的RecyclerView"><a href="#使用更强大的RecyclerView" class="headerlink" title="使用更强大的RecyclerView"></a>使用更强大的RecyclerView</h3><p>在设置LayoutManager的时候，可以指定排布的方向比如以下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinearLayoutManager manager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">manager.setOrientation(LinearLayoutManager.HORIZONTAL);<span class="comment">//平时一般使用竖直方向，这里特意指定横向</span></span><br></pre></td></tr></tbody></table></figure>

<p>为什么Listview很难或者根本无法实现这种效果呢，其实这主要得益于RecyclerView的出色设计，ListView的布局排列是由自身去管理的，，而RecyclerView则将这个工作交给了LayoutManager，LayoutManager指定了一套可扩展的布局排列接口，自雷只要按照接口的规范来实现，就能定制出不同排列方式的布局了。</p>
<p>实现点击事件，可以在Adapter中的<strong>onCreateViewHolder</strong>方法中来做到，诸如以下实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent,<span class="keyword">int</span> viewType)</span></span>{</span><br><span class="line">	View view = LayoutInflater.from(parent.getContext).inflate(R.layout.fruit_item,parent,<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">final</span> ViewHolder holder = <span class="keyword">new</span> ViewHolder(view);</span><br><span class="line">	holder.ivFruit.setOnclickListener(<span class="keyword">new</span> View.OnclickListener(){</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>{</span><br><span class="line">			<span class="keyword">int</span> postion = holder.getAdapterPosition();</span><br><span class="line">			<span class="comment">//doSomeThing you want</span></span><br><span class="line">		}</span><br><span class="line">	});</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/07/%E9%9D%A2-%E9%A1%B9%E7%9B%AE/Intent%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/07/%E9%9D%A2-%E9%A1%B9%E7%9B%AE/Intent%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7/" class="post-title-link" itemprop="url">Intent 传递的数据过大</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-07 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-07T08:00:00+08:00">2018-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 22:01:29" itemprop="dateModified" datetime="2019-11-17T22:01:29+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">问题</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>这个问题源于最近做的项目中出现的bug，一个Activity A通过startActivity(intent)的方式（intent中携带了String类型的data）启动另一个Activity B时，发生了崩溃，查看错误日志如下：</p>
<p><img src="/assets/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/intent%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97.png" alt="启动Activity时的错误日志"></p>
<p>可以看到，这是 <strong>android.os.TransactionTooLargeException</strong> ，字面意思是事务太大。这就很好理解了，因为笔者使用了intent携带数据，在事后分析这个data在传入的时候大约50k，因此导致了这个问题。后来使用<strong>SharedPreference</strong>将数据捎带过去解决了问题，这个bug本身看懂了报错就很简单，因此不再赘述。后面有空有兴趣之后再补上分析Intent传递数据到底是多大的限制。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/05/%E9%9D%A2-%E9%A1%B9%E7%9B%AE/listview%E6%90%AD%E9%85%8Dcheckbox%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/05/%E9%9D%A2-%E9%A1%B9%E7%9B%AE/listview%E6%90%AD%E9%85%8Dcheckbox%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Listview 中 CheckBox 状态错误问题原因及解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-05 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-05T08:00:00+08:00">2018-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 22:01:36" itemprop="dateModified" datetime="2019-11-17T22:01:36+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">问题</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>在开发过程中碰到很多问题，有些问题在锤子便签中记录了一个概要，有的问题甚至连记录都没有，此次开个头，将碰到的问题记录下来。</p>
<p>今天要写的问题跟Listview有关，顺便复习下ListView的相关复用机制，以及Listview的Adapter中getView方法为什么需要ViewHolder，是怎么提高加载效率的。下面开始进入回忆状态，事情的经过是这样的：</p>
<p>在平时的 Android 开发过程中，我们可能需要去实现以下效果：</p>
<p><img src="/assets/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/listview%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98/%E5%9C%BA%E6%99%AF.png" alt="使用场景"></p>
<p>在 Listview 中使用CheckBox，但是会碰到 CheckBox 选中/非选中 这种状态错乱的问题，笔者最近在项目中就碰到了，比如我选中了 id0、id1、id2 三个 CheckBox ，再想选择 id15 ，这就要求滑动 Listview 了，滑到 id15 CheckBox 将其选中，再滑动到顶部，握草，发现 id0、id1、id2 已经变成 非选中 状态了，莫非是我记错了？再重新来一次，还是一样！这就不科学了，一定是哪里出了问题，我当时的代码是这样的：</p>
<pre><code>@Override
public View getView(final int i, View view, ViewGroup viewGroup) {
    ViewHolder viewHolder = null;
    if(view == null){
        viewHolder = new ViewHolder();
        view = LayoutInflater.from(context).inflate(R.layout.layout,null);
        viewHolder.cb = (CheckBox) view.findViewById(R.id.select_cb);
        viewHolder.tvName = (TextView) view.findViewById(R.id.name_tv);
        view.setTag(viewHolder);
    }else{
        viewHolder = (ViewHolder) view.getTag();
    }
    viewHolder.cb.setChecked(data.get(i).isSlected());
    viewHolder.tvName.setText(data.get(i).getName());
    viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
        @Override
        public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked)     {
            data.get(i).setSlected(isChecked);
        }
    });
    return view;
}</code></pre><p>脑子里第一反应是各处的 item 串了，联想到使用 viewholder 来复用 item ，于是就去了解了一番 Listview 对 item 的复用机制。</p>
<h3 id="复用机制"><a href="#复用机制" class="headerlink" title="复用机制"></a>复用机制</h3><p>我们知道，listview 需要承载大量的数据，并且需要写一个 Adapter 与其适配，这样数据就能展现出来了，但是不知道大家有没有仔细想过，为什么需要 Adapter 这个东西，它到底起了个什么作用。</p>
<h5 id="从-Adapter-说起"><a href="#从-Adapter-说起" class="headerlink" title="从 Adapter 说起"></a>从 Adapter 说起</h5><p>说到底，Android 中控件就是为了展示数据以及交互用，只不过Listview特殊些，它用于展示大量的信息的，但是 Listview 只承担交互和展示工作的，至于数据来自哪里，它不care。这样，listview工作最基本需要一个 Listview 控件和一个数据源，但是数据源可能是数组，可能是集合，甚至可能是数据库表中查询出来的游标，如果 Listview 要去为每一种数据源进行匹配的话，它一定会变得非常臃肿了，于是 Adapter 出现了。</p>
<p>顾名思义，Adapter 是适配器的意思，它在 Listview 与数据源之间起了一个桥梁作用，与之前的情况不同的是，Adapter 的接口都是统一的，因此 Listview 不需要担心任何适配问题。而 Adapter 是个接口（interface），它可以有各种子类，比如 ArrayAdapter 可用于数组和 List 类型的数据源匹配，SimpleCursorAdapter 可以用于游标类型的数据源匹配，这样把适配问题解决了，并且扩展性不错。</p>
<h5 id="RecycleBin-类"><a href="#RecycleBin-类" class="headerlink" title="RecycleBin 类"></a>RecycleBin 类</h5><p>在解释复用机制之前，还有必要说一下 RecycleBin 类，因为它是 Listview 能够展现成百上千条数据并且不会 OOM 的关键，RecycleBin 是 AbsListview 的一个内部类，其主要代码如下：</p>
<pre><code>/**
 * The RecycleBin facilitates reuse of views across layouts. The RecycleBin
 * has two levels of storage: ActiveViews and ScrapViews. ActiveViews are
 * those views which were onscreen at the start of a layout. By
 * construction, they are displaying current information. At the end of
 * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews
 * are old views that could potentially be used by the adapter to avoid
 * allocating views unnecessarily.
 */
class RecycleBin {
    private RecyclerListener mRecyclerListener;

    /**
     * The position of the first view stored in mActiveViews.
     */
    private int mFirstActivePosition;

    /**
     * Views that were on screen at the start of layout. This array is
     * populated at the start of layout, and at the end of layout all view
     * in mActiveViews are moved to mScrapViews. Views in mActiveViews
     * represent a contiguous range of Views, with position of the first
     * view store in mFirstActivePosition.
     */
    private View[] mActiveViews = new View[0];

    /**
     * Unsorted views that can be used by the adapter as a convert view.
     */
    private ArrayList&lt;View&gt;[] mScrapViews;

    private int mViewTypeCount;

    private ArrayList&lt;View&gt; mCurrentScrap;

    /**
     * Fill ActiveViews with all of the children of the AbsListView.
     * 
     * @param childCount
     *            The minimum number of views mActiveViews should hold
     * @param firstActivePosition
     *            The position of the first view that will be stored in
     *            mActiveViews
     */
    void fillActiveViews(int childCount, int firstActivePosition) {
        if (mActiveViews.length &lt; childCount) {
            mActiveViews = new View[childCount];
        }
        mFirstActivePosition = firstActivePosition;
        final View[] activeViews = mActiveViews;
        for (int i = 0; i &lt; childCount; i++) {
            View child = getChildAt(i);
            AbsListView.LayoutParams lp = (AbsListView.LayoutParams)     child.getLayoutParams();
            // Don't put header or footer views into the scrap heap
            if (lp != null &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                // Note: We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in
                // active views.
                // However, we will NOT place them into scrap views.
                activeViews[i] = child;
            }
        }
    }

    /**
     * Get the view corresponding to the specified position. The view will
     * be removed from mActiveViews if it is found.
     * 
     * @param position
     *            The position to look up in mActiveViews
     * @return The view if it is found, null otherwise
     */
    View getActiveView(int position) {
        int index = position - mFirstActivePosition;
        final View[] activeViews = mActiveViews;
        if (index &gt;= 0 &amp;&amp; index &lt; activeViews.length) {
            final View match = activeViews[index];
            activeViews[index] = null;
            return match;
        }
        return null;
    }

    /**
     * Put a view into the ScapViews list. These views are unordered.
     * 
     * @param scrap
     *            The view to add
     */
    void addScrapView(View scrap) {
        AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
        if (lp == null) {
            return;
        }
        // Don't put header or footer views or views that should be ignored
        // into the scrap heap
        int viewType = lp.viewType;
        if (!shouldRecycleViewType(viewType)) {
            if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                removeDetachedView(scrap, false);
            }
            return;
        }
        if (mViewTypeCount == 1) {
            dispatchFinishTemporaryDetach(scrap);
            mCurrentScrap.add(scrap);
        } else {
            dispatchFinishTemporaryDetach(scrap);
            mScrapViews[viewType].add(scrap);
        }

        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }

    /**
     * @return A view from the ScrapViews collection. These are unordered.
     */
    View getScrapView(int position) {
        ArrayList&lt;View&gt; scrapViews;
        if (mViewTypeCount == 1) {
            scrapViews = mCurrentScrap;
            int size = scrapViews.size();
            if (size &gt; 0) {
                return scrapViews.remove(size - 1);
            } else {
                return null;
            }
        } else {
            int whichScrap = mAdapter.getItemViewType(position);
            if (whichScrap &gt;= 0 &amp;&amp; whichScrap &lt; mScrapViews.length) {
                scrapViews = mScrapViews[whichScrap];
                int size = scrapViews.size();
                if (size &gt; 0) {
                    return scrapViews.remove(size - 1);
                }
            }
        }
        return null;
    }

    public void setViewTypeCount(int viewTypeCount) {
        if (viewTypeCount &lt; 1) {
            throw new IllegalArgumentException("Can't have a viewTypeCount &lt; 1");
        }
        // noinspection unchecked
        ArrayList&lt;View&gt;[] scrapViews = new ArrayList[viewTypeCount];
        for (int i = 0; i &lt; viewTypeCount; i++) {
            scrapViews[i] = new ArrayList&lt;View&gt;();
        }
        mViewTypeCount = viewTypeCount;
        mCurrentScrap = scrapViews[0];
        mScrapViews = scrapViews;
    }

}</code></pre><ul>
<li><p>注释说 RecycleBin 用于view的reuse，它维持了两个存储空间，ActiveViews 和 ScrapViews，前者存放显示在屏幕上的view，到列表最后的时候，它里面的view都会去到 ScrapViews 中。而后者用于存放 old views ，这些view可能可以直接以convertView的形式直接利用，避免没必要的 allocat 内存，这就是Adapter中convertView的由来。</p>
</li>
<li><p>fillActiveViews() :这个方法会根据传入的参数来将 Listview 中指定的元素存储到 mActiveViews 数组中。</p>
</li>
<li><p>getActiveView() :跟 fillActiveViews 方法对应，用于从 mActiveViews 中获取数据，需要注意的是，一旦第 position 个数据被获取成功之后，该view就会从 mActiveViews 中移除，下次再获取第position个位置将会返回 null，也就是说mActiveViews不能复用。</p>
</li>
<li><p>addScrapView() :用于将一个废弃的view进行缓存，当一个view要废弃的时候（比如滚出屏幕），就调用该方法缓存，以便下次使用。</p>
</li>
<li><p>getScrapView() :从 ScrapViews 中取出一个view，这些废弃缓存中的view是没有顺序可言的，因此取的算法也非常简单，获取尾部的就行。</p>
</li>
<li><p>setViewTypeCount() :我们知道在 adapter 中我们可以重写 getViewTypeCount() 来表示Listview中有几种类型的数据项，而setViewTypeCount()的作用就是为每种类型的数据项都单独启用一个 RecycleBin 缓存机制。</p>
</li>
</ul>
<h5 id="扯点view的绘制"><a href="#扯点view的绘制" class="headerlink" title="扯点view的绘制"></a>扯点view的绘制</h5><p>Listview 再牛逼，也是继承自view的，而view的执行流程就是3步，onMeasure() 用于测量 view 的大小，onLayout() 用于确定 View 的布局，onDraw() 用于将 view 绘制到界面上。</p>
<p>Listview 最特殊的地方在于 onLayout() ,而这是在它父类 AbsListview 中实现的，它主要就一个重要判断：如果 Listview 的大小或者位置发生了变化，那就要求所有子布局强制重绘。而 layoutchildren() 方法是用来进行子元素布局的，具体由 Listview 自己实现，可以解析下。</p>
<p>刚开始，Listview 中没有任何子view，因此会去调用 fillActiveViews() 方法，这是为了将 Listview 中的子 view 进行缓存的，由于此时子 view 为空，因此会调用 fillFromTop() ，最终调用到 fillDown() 方法，进行 Listview 的填充操作。fillDown() 中有个while循环，当遍历完从 Listview 顶部到底部的距离的item或者 adapter 中的数据遍历结束，while就跳出。在while中，执行 makeAndAddView() ，它会尝试从 RecycleBin 中快速获取 active view ，但此时 RecycleBin 中还未缓存任何view，因此获得null，所以就会尝试调用 obtainView() ，它是可以保证返回一个 view 的，于是将获取到的view立刻传入到了 setupChild() 中。</p>
<p>那到底 obtainView() 怎么保证获取到view的？不夸张地说，Listview 中最重要的内容都在 obtainView() 中了，该方法里首先调用了 RecycleBin 的 getScrapView() 方法尝试获取一个废弃缓存中的 view ，当然这时候是获取不到的，得到null，之后再调用 mAdapter 的 getView() 方法来获取一个 view ，这时候似曾相识了，有 adapter 和 getView() 方法了，对，就是我们平常写的那个 adapter，然后重写的那个 getView(),这时候会传入 position，convertView (此时为null)，parent (当然是 this 了)。</p>
<h5 id="捋一下item的复用"><a href="#捋一下item的复用" class="headerlink" title="捋一下item的复用"></a>捋一下item的复用</h5><p>一切从 onLayout 开始，当大小或者位置发生了变化，就会调用onLayout，onLayout完毕之后，就剩下 ondraw 去绘制了。onLayout中，（为了叙述方便，不考虑数据不足以填满Listview的情况），首先要拿item的view放到Listview中，先从ActiveViews中拿，如果为空，则打算从 ScrapViews 中拿，还是为空，则利用 adapter 去创造，创造一屏 itemview 填充于 ActiveViews 中，之后 Listview 从 ActiveViews 中取出 itemview ，ActiveViews 删除该 itemview ，如果 itemview 滑动隐藏了，就会丢弃到 ScrapViews 中，这样滑动的时候触发 onLayout ，onLayout 再去找 itemview 填充，如果有现成的就用，没有就创造。 </p>
<h3 id="分析源码谈原因"><a href="#分析源码谈原因" class="headerlink" title="分析源码谈原因"></a>分析源码谈原因</h3><p>再来看源码，为了更方便，加上toast提示：</p>
<pre><code>@Override
public View getView(final int i, View view, ViewGroup viewGroup) {
    ViewHolder viewHolder = null;
    if(view == null){
        viewHolder = new ViewHolder();
        view = LayoutInflater.from(context).inflate(R.layout.layout,null);
        viewHolder.cb = (CheckBox) view.findViewById(R.id.select_cb);
        viewHolder.tvName = (TextView) view.findViewById(R.id.name_tv);
        view.setTag(viewHolder);
    }else{
        viewHolder = (ViewHolder) view.getTag();
    }
    viewHolder.cb.setChecked(data.get(i).isSlected());
    viewHolder.tvName.setText(data.get(i).getName());
    viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
        @Override
        public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked)     {

        Toast.makeText(context,"这是点击了第" + i + "个" ,Toast.LENGTH_SHORT).show();
            data.get(i).setSlected(isChecked);
        }
    });
    return view;
}</code></pre><p>运行之后我们看到整个列表，选中第1个，会弹toast “这是点击了第0个” 接着往上慢慢滑动，直至将第一个item隐藏的时候，发现 toast 弹出来了，显示 <strong>这是点击了第0个</strong>！而这个时候最下面之前被第一条隐藏的item也展现出来了，综合上面的知识，可以知道，这个隐藏的item是复用了第1个item的view，复用view的时候，由于该隐藏item是<strong>未checked</strong>，而第一条item是<strong>已经checked</strong>，因此它执行     </p>
<blockquote>
<p>viewHolder.cb.setChecked(data.get(i).isSlected());</p>
</blockquote>
<p>的时候，会触发 OnCheckedChangeListener ，由于之前第一个 item 设置了监听：</p>
<pre><code>viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            @Override
            public void onCheckedChanged(CompoundButton compoundButton, boolean     isChecked)     {

            Toast.makeText(context,"这是点击了第" + i + "个" ,Toast.LENGTH_SHORT).show();
                data.get(i).setSlected(isChecked);
            }
        });</code></pre><p>这时候就触发了监听事件，因此toast就弹出来了，并且把第一条item的数据也由checked改成unchecked，因此你下次再见到第一个item的时候，状态就变成unchecked了。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>最后可以说结论了，这个现象是由于listview中item复用导致，如果你不用viewholder是不会有这问题的，其实这个结论并不重要，重要的是理解这里面的发生机制。当然，说了问题起因，当然得给个解决方案，方法不止一种，我个人用的一种方法是在</p>
<blockquote>
<p>viewHolder.cb.setChecked(data.get(i).isSlected());</p>
</blockquote>
<p>之前添加一句：</p>
<blockquote>
<p>viewHolder.cb.setOnCheckedChangeListener(null);</p>
</blockquote>
<p>我想你肯定知道为什么。</p>
<p><strong>注：参考（引用）以下博客劳动成果：</strong></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/44996879">郭霖 ： Android ListView工作原理完全解析，带你从源码的角度彻底理解</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/01/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/01/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：先从看得到的入手</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-01 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-01T08:00:00+08:00">2018-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:51:11" itemprop="dateModified" datetime="2019-11-17T21:51:11+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Intent使用"><a href="#Intent使用" class="headerlink" title="Intent使用"></a>Intent使用</h2><p>显式地就不说了，使用隐式的Intent时并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，并帮我们找出合适的活动去启动。</p>
<h3 id="普通的隐式Intent使用"><a href="#普通的隐式Intent使用" class="headerlink" title="普通的隐式Intent使用"></a>普通的隐式Intent使用</h3><p>比如在AndroidManifest.xml中声明activity的时候，可以添加：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.ACTION_START"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>在代码中就能以下面代码来启动这个activity了（由于category是DEFAULT，所以在intent中并未指定category了）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.ACTION_START"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></tbody></table></figure>

<p>如果在AndroidManifest.xml中声明activity的时候同时指定了<strong>action</strong>和<strong>category</strong>，那么必须要在Intent中严格匹配才能打开，否则可能报错，比如写成：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.ACTION_START"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"com.example.MY_CATEGORY"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>则代码中必须添加以下代码才能正确运行。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.ACTION_START"</span>);</span><br><span class="line">**intent.addCategory(<span class="string">"com.example.MY_CATEGORY"</span>);**</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="更多隐式Intent用法"><a href="#更多隐式Intent用法" class="headerlink" title="更多隐式Intent用法"></a>更多隐式Intent用法</h3><p>使用隐式的Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，比如说要在应用程序中点击一个按钮，然后要在浏览器中打开一个网页，则使用以下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"http://www.baidu.com"</span>));</span><br><span class="line">startActivity(Intent);</span><br></pre></td></tr></tbody></table></figure>

<p>这里面，setData()接收一个Uri对象，主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传入到Uri.parse()方法中解析产生的。那如果我们要自己写个浏览器应用，让其它应用也能像这样利用我们的APP打开网页，又该怎么做呢，这就要求在<intent-filter>中添加一个&lt;data标签&gt;，用于更精确地指定当前活动能够响应什么类型的数据。<data>标签中可以配置以下内容：</data></intent-filter></p>
<ul>
<li>android:scheme。用于指定数据的协议部分，例如上例中的http部分。</li>
<li>android:host。用于指定数据的主机名部分，如上例中的<a target="_blank" rel="noopener" href="http://www.baidu.com。">www.baidu.com。</a></li>
<li>android:port。用于指定数据的端口部分。</li>
<li>android:path。用于指定主机名和端口之后的部分。</li>
</ul>
<p>所以，如果我们要做一个浏览器，至少要在AndroidManifest.xml对主activity声明：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.ACTION_START"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>下次其他APP需要用http协议打开网页时，我们的APP也会在候选列表中了。除了http协议意外，我们还可以指定很多其他协议，比如<strong>geo</strong>表示地理位置、<strong>tel</strong>表示拨打电话。</p>
<h2 id="活动的生命周期"><a href="#活动的生命周期" class="headerlink" title="活动的生命周期"></a>活动的生命周期</h2><ul>
<li>onCreate()，活动第一次被创建的时候调用，应该在这里面完成活动的初始化操作。</li>
<li>onStart()，在活动由不可见变为课件的时候调用。</li>
<li>onResume()，在活动准备好和用户进行交互的时候调用，此时活动一定位于返回栈的栈顶，并且处于运行状态。</li>
<li>onPause()，在系统准备去启动或者恢复另一个活动的时候调用，通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但是工作不能太多，不然会影响下一个Activity的使用。</li>
<li>onStop(),活动完全不可见的时候调用，它和onPause主要的区别在于，如果启动的新活动是一个对话框式的活动，那么onPause方法会得到执行，而onStop不会执行。</li>
<li>onDestroy()，活动晓辉之前调用。</li>
<li>onRestart()，由停止状态变为运行状态之前调用。一般是由上一个活动返回到当前活动。</li>
</ul>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-2/%E5%9B%BE1.png" alt="Activity声明周期"></p>
<h3 id="活动回收了怎么办"><a href="#活动回收了怎么办" class="headerlink" title="活动回收了怎么办"></a>活动回收了怎么办</h3><p>想象以下场景，应用中有活动A，在A的基础上启动活动B，活动A此时进入了停止状态，此时由于内存不足，将活动A回收了，然后用户按Back键返回活动A，会出现什么情况呢？其实还是会正常显示A，只不过这是并不会执行onRestart方法，而是会执行活动A的onCreate方法，因为活动A在这种情况下会被重新创建一次。</p>
<p>如果A进程中有输入框，并且已经输入了一些文字了，如果回收被重新创建，那么会丢失输入的信息，影响用户体验。Activity中还提供了一个onSaveInstanceState()回调方法，这个方法可以保证在活动回收之前一定会被调用，这个方法会携带一个Bundle类型的参数，它允许以key-value的形式存取值，我们可以这样将要保存的数据存下来：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">        outState.putString(<span class="string">"name"</span>,<span class="string">"glassx"</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>数据已经保存下来了，但是在哪里恢复呢？其实我们一直使用的onCreate方法其实也有一个Bundle类型的参数，这个参数一般情况下是null，如果在活动呗系统回收之前有通过onSaveInstanceState保存的话，这个参数就会带有之前所保存的全部数据，因此通过以下方法取即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(savedInstanceState != <span class="keyword">null</span>){</span><br><span class="line">        	String name = savedInstanceState.getString(<span class="string">"glassx"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>


<h2 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h2><p>在实际项目中我们应该根据特定的需求为每个活动指定恰当的启动模式，启动模式一种四种：<strong>standard、singleTop、singleTask、singleInstance</strong>。</p>
<ul>
<li><p>standard是默认的启动模式。每次启动都会创建一个新的实例。</p>
</li>
<li><p>singleTop：有些情况下，可能会觉得standard不太合理，活动明明已经在栈顶了，为毛还要再创建新的实例呢？singleTop模式可以解决这个问题，当活动以该模式启动时，如果发现返回栈的栈顶已经是该活动，那就直接使用它，不创建新的实例，并且调用栈顶实例的<strong>onNewIntent</strong>方法；如果栈顶不是该活动，就创建该活动的新的实例。</p>
</li>
<li><p>singleTask：如果活动的启动模式指定为singleTask，那么每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果有，把这个活动之上的所有活动统统出栈，并且直接使用该实例，并调用该实例的<strong>onNewIntent</strong>方法？？（存疑，等会实践下）。反之没有的话就创建该活动的实例。</p>
</li>
<li><p>singleInstance：指定为singleInstance模式的活动会启用一个新的返回栈来管理这个活动（其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈）。</p>
<blockquote>
<p>那么这样做有什么意义呢？想象以下场景，我们的程序中有一个活动是允许其他程序调用的，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，应该如何实现呢？前面3中模式做不到，因为每个应用程序都会有自己的返回栈，同一个活动在不同的返回栈中入栈必然是创建了新的实例。而使用singleInstance模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活动，不管哪个应用来访问这个活动，都公用一个返回栈，也就解决了共享活动实例的问题。</p>
</blockquote>
</li>
</ul>
<p><strong>注意：如果三个活动，A和C都是standard模式，B是singleInstance模式，那么A启动B，B启动C后，在C界面按返回键是回退到A，再按返回键回退到B，接着按返回键才会退出应用，因为A和C是同一个回退栈中，B单独在一个栈中，可以用如下图来理解这一过程</strong>。</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-2/%E5%9B%BE2.png" alt="Activity声明周期"></p>
<h2 id="活动的最佳实践"><a href="#活动的最佳实践" class="headerlink" title="活动的最佳实践"></a>活动的最佳实践</h2><h3 id="知晓当前是在哪一个活动"><a href="#知晓当前是在哪一个活动" class="headerlink" title="知晓当前是在哪一个活动"></a>知晓当前是在哪一个活动</h3><p>建一个BaseActivity，在onCreate的时候打印出来当前实例的类名，之后其他的activity都继承这个activity即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        </span><br><span class="line">        Log.d(<span class="string">"BaseActivity"</span>,getClass().getSimpleName());</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="随时随地退出app"><a href="#随时随地退出app" class="headerlink" title="随时随地退出app"></a>随时随地退出app</h3><p>如果你在第三个activity界面，这个时候想要退出App是非常不方便的，可以新建一个类来管理所有Activity：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityController</span></span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Activity&gt; activities = <span class="keyword">new</span> ArrayList&lt;Activity&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addActivity</span><span class="params">(Activity ac)</span></span>{</span><br><span class="line">		activities.add(ac);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeActivity</span><span class="params">(Activity ac)</span></span>{</span><br><span class="line">		activities.remove(ac);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finishAll</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">for</span>(Activity ac : activities){</span><br><span class="line">			ac.finish();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这样只需要在BaseActivity的onCreate里面执行ActivityController的<strong>addActivity</strong>方法，即可把Activity添加进去，在BaseActivity的onDestroy方法中执行<strong>removeActivity</strong>，将其移除，在需要退出app的时候，只需要执行finishAll即可。</p>
<h3 id="启动活动最佳写法"><a href="#启动活动最佳写法" class="headerlink" title="启动活动最佳写法"></a>启动活动最佳写法</h3><p>每个Activity中都写上启动自己的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span></span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">actionStart</span><span class="params">(Context context,String name,String sex)</span></span>{</span><br><span class="line">		Intent intent  = <span class="keyword">new</span> Intent(context,TestActivity.class);</span><br><span class="line">		intent.putExtra(<span class="string">"name"</span>,name);</span><br><span class="line">		intent.putExtra(<span class="string">"sex"</span>,sex);</span><br><span class="line">		context.startActivity(intent);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样做的一个好处就是，启动这个activity所需要的参数一目了然，而无需阅读这个activity的源码就可以直接调用方法就能避免漏掉参数。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/05/31/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/31/%E4%B9%A6-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">第1章：开启启程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-31 18:00:00" itemprop="dateCreated datePublished" datetime="2018-05-31T18:00:00+08:00">2018-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:50:45" itemprop="dateModified" datetime="2019-11-17T21:50:45+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h4 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h4><ol>
<li><p>最底层是Linux内核层。</p>
<blockquote>
<p>为Android设备各种硬件提供了底层驱动，如显示驱动，音频驱动等。</p>
</blockquote>
</li>
<li><p>系统运行库层。</p>
<blockquote>
<p>这层通过一些C/C++库来为Android系统提供主要的特性支持。如Sqlite库提供了数据库支持，OpenGL|ES提供提供3D绘图等。</p>
</blockquote>
</li>
<li><p>应用框架层。</p>
<blockquote>
<p>主要提供了构建应用程序可能用到的各种API。</p>
</blockquote>
</li>
<li><p>应用层。</p>
<blockquote>
<p>所有安装在手机上的应用程序都属于这一层。比如系统自带的联系人、短信等程序，自己开发的应用。</p>
</blockquote>
</li>
</ol>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-1/%E5%9B%BE1.png" alt="Android系统层次"></p>
<h3 id="Android应用开发特色"><a href="#Android应用开发特色" class="headerlink" title="Android应用开发特色"></a>Android应用开发特色</h3><h4 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h4><p>四大组件分别是活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）和内容提供器（Content Provider）</p>
<p>build.gradle 文件中，<strong>compileSdkVersion</strong>用于指定项目的编译版本；<strong>buildToolsVersion</strong>用于指定项目构建工具的版本；<strong>applicationId</strong>用于指定项目的包名，并且它的优先级高于在 AndroidManifest.xml<br>中指定的包名；<strong>minSdkVersion</strong>用于指定项目最低兼容的Android版本;<strong>targetSdkVersion</strong>表明你在该目标版本上做过了充分的测试，系统将为你的应用程序启用一些最新的功能和特性。比如说Android6.0 系统中引入了运行时权限这个功能，如果你将targetSdkVersion指定成23或者更高，那么系统就会为你的程序启用运行时权限功能；否则就不会启用运行时权限功能。</p>
<p>而在build.gradle的<strong>dependencies</strong>闭包中，声明了当前项目所有的依赖关系，Android studio 项目一共有3中依赖方式，本地依赖、库依赖和远程依赖，本地依赖可以对本地的jar包或者目录添加依赖关系，形式如：<strong>compile fileTree(dir: ‘libs’, include: [‘*.jar’])</strong>；库依赖可以对项目中的库模块添加依赖关系，如<strong>compile(name: ‘testsdk’, ext: ‘aar’)</strong>；远程依赖则可以对jcenter库上的开源项目添加依赖关系，如<strong>compile ‘com.android.support.constraint:constraint-layout:1.0.2’</strong>，其中，com.android.support.constraint是域名，用于和其他公司的库作区分，constraint-layout是组名称，用于和同一个公司其他库作区分。</p>
<p><strong>关于日志：</strong>不用System.out.println()，因为Log系统可以对日志分级，可以展示打印时间，可以添加过滤器等等。<strong>Log快捷键：如果要打Log.d，则输入logd，按tab键即可，同理Log.i只需要logi之后按Tab键，以此类推，四种级别的日志都能快捷打出来。还有，如果在oncreate方法外面输入logt，然后按下Tab键，就会以当前的类名作为值自动生成一个类似下面的TAG常量：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"HelloWorldActivity"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/05/30/%E4%B9%A6-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-%E7%AC%AC6%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/30/%E4%B9%A6-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-%E7%AC%AC6%E7%AB%A0/" class="post-title-link" itemprop="url">第6章：死锁</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-30 18:00:00" itemprop="dateCreated datePublished" datetime="2018-05-30T18:00:00+08:00">2018-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 21:50:18" itemprop="dateModified" datetime="2019-11-17T21:50:18+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>如果有两个进程A和B需要将扫描的文档记录到CD上，进程A请求扫描仪并被授权使用，请求CD时发现已被B占用了，于是被拒绝，同理，B请求扫描仪也会被拒绝，于是产生<strong>死锁</strong>。在一个数据库系统中，为了避免竞争，可对若干记录加锁，如果进程A对R1加锁了，进程B对R2加了锁，接着这两个进程又试图把各自对方的记录也加锁，这是也会产生死锁。所以，<strong>软硬件资源都可能出现死锁</strong>。</p>
<h2 id="资源和死锁条件"><a href="#资源和死锁条件" class="headerlink" title="资源和死锁条件"></a>资源和死锁条件</h2><p><strong>资源</strong>分为两类，一类是<em>可抢占资源（preemptable resource）</em> 可以从拥有它的进程中枪战而不产生任何副作用，比如存储器。一个系统拥有256M的用户内存和一条打印机，如果有两个256M内存的进程都想打印，进程A获得了打印机，而B战友内存，但是幸运的是可以通过把进程B患处内存、把进程A换入内存可以实现抢占B的内存，这样，进程A继续运行并执行打印任务，然后释放打印机和内存。另一类是<em>不可抢占资源（nonpreemptable resource）</em>是指在不引起相关的计算失败的情况下，无法把它从占有它的进程中抢占过来，如CD刻录机。如果一个进程已经在开始刻盘，突然将刻录机分配给另一个进程，那么将划坏CD盘。</p>
<p>因此，总的来说，死锁和不可抢占资源有关，有关可抢占资源的潜在死锁通常可以通过在进程之间重新分配资源而化解，所以我们主要关注不可抢占资源上。当然，Coffman等人总结了发生（资源）死锁需要具备四个必要条件：</p>
<ul>
<li><p><strong>不可抢占</strong>。</p>
<blockquote>
<p>已经分配给一个进程的资源不能强制性地被抢占，他只能被占有它的进程显式地释放。</p>
</blockquote>
</li>
<li><p><strong>互斥条件。</strong></p>
<blockquote>
<p>每个资源要么已经分配了一个进程，要么就是可用的。</p>
</blockquote>
</li>
<li><p><strong>占有和等待</strong>。</p>
<blockquote>
<p>已经得到了某个资源的进程还可以再请求新的资源。</p>
</blockquote>
</li>
<li><p><strong>环路等待</strong>。</p>
<blockquote>
<p>死锁发生时，系统中一定有由两个或者以上的进程组成一条环路，该环路中每个进程都在等待着下一个进程所占有的资源。</p>
</blockquote>
</li>
</ul>
<p><strong>注意：死锁发生时，以上四个条件一定是同时满足的。任何一个不成立就不会发生死锁</strong></p>
<h2 id="死锁建模"><a href="#死锁建模" class="headerlink" title="死锁建模"></a>死锁建模</h2><p>在讨论死锁解决方案之前，讨论如何对死锁建模是有意义的。有个叫Holt的人指出可以利用有向图建立死锁四个条件的模型——在有向图中有两类节点：用圆形表示进程，用方形表示资源。从资源节点到进程节点的有向边代表该资源已被请求、授权并被进程占用，由进程节点到资源节点的有向边表明当前进程正在请求该资源。以下是一个示意图：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE1.png" alt="死锁建模示意图"></p>
<p>图中，当前资源R整备进程A占用，进程B正等待着资源S，图c)进入了死锁状态，进程C等待着资源T，资源T被进程D占用，进程D又等待着由进程C占用的资源U。</p>
<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><p>总而言之，有四种处理死锁的策略：</p>
<ul>
<li><p>忽略该问题。也许如果你忽略它，他也会忽略你。</p>
</li>
<li><p>检测死锁并恢复。</p>
<blockquote>
<p>让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题。</p>
</blockquote>
</li>
<li><p>仔细对资源进行分配，动态地避免死锁。</p>
</li>
<li><p>破坏引起死锁的四个必要条件之一，防止死锁产生。</p>
</li>
</ul>
<p>以下对这四种策略分别阐述。</p>
<h3 id="忽略问题"><a href="#忽略问题" class="headerlink" title="忽略问题"></a>忽略问题</h3><p>最简单的方法是<strong>鸵鸟算法：</strong>把头埋进沙子里，假装根本没有问题发生。不同人对于该方法的看法不同，数学家认为这种方法不能接受，不管代价多大，都要彻底防止死锁产生；而对于工程师，它们会考量死锁发生的频率和严重性，如果平均5年一次死锁，那么大多数工程师不会以性能损失和可用性代价去防止死锁。</p>
<h3 id="检测死锁和死锁恢复"><a href="#检测死锁和死锁恢复" class="headerlink" title="检测死锁和死锁恢复"></a>检测死锁和死锁恢复</h3><h4 id="每种类型一个资源的死锁检测"><a href="#每种类型一个资源的死锁检测" class="headerlink" title="每种类型一个资源的死锁检测"></a>每种类型一个资源的死锁检测</h4><p>从最简单的例子开始，假定每种类型的资源只有一个，即排除了同时有两台打印机的情况。我们假设一个系统包括A到G共7个进程，R到W共6中资源，资源的占有情况和进程对资源的请求情况如下：<br>（1）A进程持有R资源，且需要S资源。<br>（2）B进程不持有任何资源，但需要T资源。<br>（3）C进程不吃油任何资源，但需要S资源。<br>（4）D进程持有U资源，且需要S资源和T资源。<br>（5）E进程持有T资源，且需要V资源。<br>（6）F进程持有W资源，且需要S资源。<br>（7）G进程持有V资源，且需要U资源。</p>
<p><strong>问：系统是否存在死锁？如果存在，涉及哪些进程？</strong></p>
<p>回答这一问题，初看很难，但是建模构造一张资源分配图之后，可以直观地看到图中包含了一个环，如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE2.png" alt="对问题建模"></p>
<p>在换种，可以看出进程D、E、G已经死锁，A、C、F没有死锁，因为可以把资源S分配给它们中的任意一个。</p>
<h4 id="每种类型有多个资源的死锁检测"><a href="#每种类型有多个资源的死锁检测" class="headerlink" title="每种类型有多个资源的死锁检测"></a>每种类型有多个资源的死锁检测</h4><p>如果一类资源可能存在多个，就需要采用另一个方法来检测死锁。现在我们提供一种基于矩阵的算法来检测从P1到Pn这n个进程中的死锁。假设资源类型数为m，E1代表资源类型1，E2代表资源类型2，以此类推。E是<strong>现有资源向量</strong>，代表每种已存在的资源总数，比如资源类型1代表磁带机，那么E1=2就表示系统有两台磁带机。</p>
<p>在任意时刻，某些资源已被分配所以不可用，假设A是<strong>可用资源向量</strong>，那么Ai表示当前可供使用的资源数（即没有被分配的资源）。如果仅有的两台磁带机都已经分配出去了，那么A1的值为0 。</p>
<p>现在我们需要两个数组：C代表当前<strong>当前分配矩阵</strong>，R代表<strong>请求矩阵</strong>。C的第i行代表Pi当前所持有的每一种类型资源的资源数，所以Cij代表进程i所持有的资源j的数量，同理Rij代表Pi所需要的资源j的数量，数据结构如下图：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE3.png" alt="矩阵数据结构"></p>
<p>这四种数据结构之间有一个重要的恒等式，具体地说，某种资源要么已分配，要么可用，这个结论意味着：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE4.png" alt="资源等式"></p>
<p>换言之，如果我们将所有已分配的资源j的数量加起来在和所有可供使用的资源数相加，结果就是该类资源的资源总数。死锁检测算法就是给予向量的比较，我们定义向量A和向量B之间的关系为A小于或等于B以表明A的每一个分量要么等于要么小于和B向量对应的分量。</p>
<p>每个进程起初是没有被标记的，算法开始会对进程做标记，进程被标记后就表明它们能够被执行，不会进入死锁，死锁检测算法如下：</p>
<ol>
<li>寻找一个没有标记的进程Pi，对于它而言，R矩阵的第i行向量小于或等于A。</li>
<li>如果找到了这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转到第1步。</li>
<li>如果没有这样的进程，算法终止。</li>
</ol>
<p>算法的第1步是寻找可以运行完毕的进程，该进程有资源请求并且该请求可被当前的可用资源满足。这一选中的进程随后就被运行完毕，在这段时间内它释放自己持有的所有资源并将它们返回到可用资源库中，然后，这一进程被标记为完成，如果所有的进程最终都能运行完的话，就不存在死锁，如果进程一直不能被运行，那它们就是死锁进程。</p>
<h4 id="从死锁恢复"><a href="#从死锁恢复" class="headerlink" title="从死锁恢复"></a>从死锁恢复</h4><p>我们讨论各种从死锁中恢复的方法，尽管这些方法看起来都不那么令人满意：</p>
<ul>
<li><p>利用抢占恢复。</p>
<blockquote>
<p>临时将资源从当前所有者哪里转移到另一个进程，许多情况下这是需要人工敢于的。比如，要将激光打印机从它持有的进程那里拿走，管理员可以收集已打印好的文档，然后该进程被挂起，接着打印机被分配给另一个进程。</p>
</blockquote>
</li>
<li><p>利用回滚恢复。</p>
<blockquote>
<p>周期性地将进程的状态写入一个文件以备重启。一旦检测到死锁，拥有所需要资源的进程会回滚到一个时间点，在此时间点之前该进程获得了一些其他资源，在该检查点之后所做的工作都丢失。实际上，是将该进程复位到一个更早的状态，那时候它还没取得所需的这个资源。接着就把这个资源分配给一个死锁进程。</p>
</blockquote>
</li>
<li><p>杀死进程恢复。</p>
<blockquote>
<p>杀死环中的一个进程。或者杀死环外带有该资源的一个进程。</p>
</blockquote>
</li>
</ul>
<h3 id="动态避免死锁"><a href="#动态避免死锁" class="headerlink" title="动态避免死锁"></a>动态避免死锁</h3><p>利用资源轨迹图、安全状态和不安全状态、银行家算法去解决。这里略复杂，暂时先不深入研究。</p>
<h3 id="破坏引起死锁的四个条件之一"><a href="#破坏引起死锁的四个条件之一" class="headerlink" title="破坏引起死锁的四个条件之一"></a>破坏引起死锁的四个条件之一</h3><ul>
<li><p>破坏互斥条件，如果资源不被一个进程独占，那么死锁肯定不会产生。</p>
<blockquote>
<p>当然，允许两个进程同时使用打印机会造成混乱，通过采用<strong>假脱机（spooling printer）</strong>技术可以允许若干个进程同时产生输出。该模型中唯一真正请求使用物理打印机的进程是打印机守护进程，由于守护进程绝不会请求其他资源，因此不会产生死锁。</p>
</blockquote>
</li>
<li><p>破坏占有和等待条件。只要禁止已持有资源的进程再等待其他资源便可以消除死锁。</p>
<blockquote>
<p>一种实现方法是规定所有进程在开始执行前请求所需的全部资源。如果所需的全部资源可用，那么就将它们分配给这个进程，于是该进程肯定能够运行结束。如果一个或者多个资源正被使用，那么就不分配，进程等待。<strong>另一种</strong>方案是，要求当一个进程请求资源时，先暂时释放其当前占用的所有资源，然后再尝试一次获得所需要的全部资源。</p>
</blockquote>
</li>
<li><p>破坏不可抢占条件。</p>
<blockquote>
<p>假如一个进程已分配到一台打印机且正在进行打印输出，如果由于它需要的绘图仪无法获得而强制性把打印机抢占掉，则会引起混乱。但是，一些资源可以通过虚拟化的形式来避免发生这样的情况，假脱机打印机向磁盘输出，并且只允许打印机守护进程访问真正的物理打印机，就可以消除涉及打印机的死锁。<strong>然而，不是所有资源都可以进行类似的虚拟化，比如数据库中的记录在操作的时候必须要锁定，因此存在死锁的可能</strong></p>
</blockquote>
</li>
<li><p>破坏环路等待。</p>
<blockquote>
<p>消除环路有几种方法。比较靠谱的方案是，对所有的资源统一编号，现在的规则是，进程可以在任何时刻提出资源请求，但是所有请求必须按照资源编号的顺序（升序）提出，如下图所示，进程可以先请求打印机后请求磁带机，但不可以先请求绘图仪后请求打印机。</p>
</blockquote>
</li>
</ul>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE5.png" alt="资源排序"></p>
<p><strong>最后，总结一张图用于预防死锁：</strong></p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE6.png" alt="预防死锁的方法汇总"></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共267.6k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.gitee.io/page/12/',]
      });
      });
  </script>


</body>
</html>
