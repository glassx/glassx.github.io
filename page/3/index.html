<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/3/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">173</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/31/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(02)JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/31/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(02)JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Java筑基-：(02)JVM内存管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-31 15:18:00" itemprop="dateCreated datePublished" datetime="2023-03-31T15:18:00+08:00">2023-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-08 22:39:26" itemprop="dateModified" datetime="2023-04-08T22:39:26+08:00">2023-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、Java-程序执行过程"><a href="#一、Java-程序执行过程" class="headerlink" title="一、Java 程序执行过程"></a>一、Java 程序执行过程</h2><p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/Java%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Java执行过程"></p>
<h2 id="二、JVM-规范"><a href="#二、JVM-规范" class="headerlink" title="二、JVM 规范"></a>二、JVM 规范</h2><p>Java 在 JVM 上经过 ClassLoader 加载后，有 2 种执行方式：</p>
<ul>
<li><p>字节码解释器解释执行。Java 先编译成 class 文件，再由 C++ 解释器</p>
</li>
<li><p>JIT执行：HotSpot 就这样执行，将Java 代码翻译成汇编等形式的机器码，速度较快</p>
</li>
</ul>
<p>JVM 是 C++ 写的，它解释执行是怎么解释呢？它碰到你 Java 代码中的 new 关键字的时候，它就执行某一段 C ++ 代码，类似：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(碰到了<span class="keyword">new</span>) {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>也就是通过 C++ 来翻译 Java 语言。这经过了一道转换，效率是有点低的。</p>
<p>JIT 执行，直接将Java 代码翻译成汇编代码等机器代码，就能迅速执行。不过一般只有热点代码才这样做。缺点是，你要先提前翻译，编译的时间会比较长。</p>
<h3 id="2-1-运行时数据区域"><a href="#2-1-运行时数据区域" class="headerlink" title="2.1 运行时数据区域"></a>2.1 运行时数据区域</h3><p><strong>直接内存</strong>：没有经过 JVM 的虚拟化。比如总共有 8G 的存储空间，JVM 虚拟化了 6G ，但是还剩下 2G 我们没法去通过 JVM 使用，这时候就能用直接内存去使用这 2G 空间。</p>
<blockquote>
<p>优点是不受 JVM 管理，不会受到 GC 影响，毕竟 GC 会Stop The World；缺点同样明显，就是使用不方便，自己申请，用完要记得释放，否则造成内存泄漏。</p>
</blockquote>
<p>虚拟机栈的大小在不同的平台上的大小是不同的，在 Linux 上一般是 1M 。如果是死递归，不断往虚拟机栈压入栈帧，讲道理会将这个栈空间耗尽，不过现实中往往先 StackOverFlow。</p>
<p>一个线程光这个虚拟机栈就占了 1M 的空间，如果有500 个线程，那么占用的空间也是非常可观的，所以我们也要控制线程数量。</p>
<p>每个栈帧里面会包含什么呢？ 一般是：</p>
<ul>
<li><p>局部变量表</p>
</li>
<li><p>操作数栈</p>
</li>
<li><p>动态链接</p>
</li>
<li><p>完成出口</p>
</li>
</ul>
<p>可能这些概念不太好懂，举个例子，看下面的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">work</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> z = (x+y) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.work();</span><br><span class="line">        person.hashCode();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>上述代码在执行 main 方法的时候，会为 main 线程创建一个虚拟机栈，调用一个方法就会创建一个栈帧，<strong>所以 main 方法会有一个栈帧，调用 person.work 的时候也会创建一个栈帧</strong>。整个过程大体上会有如下操作：</p>
<ol>
<li><p>x 和 y 都被定义了，但是还没使用，所以压入<strong>局部变量表中</strong></p>
</li>
<li><p>执行 (x+y) * 10 的操作时，先计算 x + y = 3， 将 3 这个临时值放入<strong>操作数栈</strong></p>
</li>
<li><p>之后，将操作数 10 也压入<strong>操作数栈</strong>的栈顶</p>
</li>
<li><p>接着， 操作数栈中的 3 和 10 都出栈，相乘得到结果 30 ，再压入 <strong>操作数栈</strong> 中</p>
</li>
<li><p>因为这里定义是 z 局部变量接受这个结果，所以需要将操作数栈中的 30 出栈，在局部变量表中放入 z 这个值 30</p>
</li>
<li><p>最后要返回 z ，方法与方法之间操作，这个<strong>返回值相当于一个操作数</strong>，所以又要将 z 这个 30 值复制到 <strong>操作数栈中</strong></p>
</li>
<li><p>最后，带着 work 方法栈帧中操作数栈的这个 30 ，返回了 main 方法的 栈帧。</p>
</li>
</ol>
<blockquote>
<p>这里有个点需要注意下，构造方法也是方法，所以也会有栈帧</p>
</blockquote>
<p>这个过程一直伴随着程序计数器的不断移动。至于<strong>完成出口</strong>，是记录调用方执行到哪里之后再来调用当前方法的，上述main 方法中 ，假如 是main 方法自己执行到行号 2 的时候就调用 person.work 了，此时，work 方法中记录的程序出口就是这个行号2，work 方法执行完，切回main 方法时， 会把这个值带回去，这样便知道从哪里继续执行。来看一下下面的这张图，这是字节码：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/%E5%AD%97%E8%8A%82%E7%A0%81%E7%A4%BA%E6%84%8F.png" alt="字节码示意图"></p>
<p>左边的就是 0,1,2…12 ，这些代表行号，也代表字节码的偏移量，<strong>有些指令比较短，有些比较长，会占据不止一行，所以，行号可能会跳过，上面的图中没有 8 这个行号，就是因为 bipush 指令比较大</strong>；右边的代表操作。非静态方法的局部变量表的第 0 个位置存的是 this ，也就是当前的对象。</p>
<p><strong>动态链接</strong> 主要是<strong>跟多态有关</strong>。本地方法栈和虚拟机栈是可以合并的， HotSpot 就是这么做的。</p>
<h2 id="三、课堂问题"><a href="#三、课堂问题" class="headerlink" title="三、课堂问题"></a>三、课堂问题</h2><p>课程中 demo 搞出来个 stackoverflow ，这个值得注意：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    Person haha = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Person wo = <span class="keyword">new</span> Person();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因为在 main 方法中 wo 来new Person 的对象时， 就会触发 haha 的又来 new 一个 new Person 对象，就会陷入死循环了。</p>
<h2 id="四、直接内存"><a href="#四、直接内存" class="headerlink" title="四、直接内存"></a>四、直接内存</h2><p>如果想使用直接内存，可以通过 ByteBuffer 来实现，这样可以被回收：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">3</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ByteBuffer 是使用 unsafe 来实现的。</p>
<h2 id="五、工具"><a href="#五、工具" class="headerlink" title="五、工具"></a>五、工具</h2><p>使用 <strong>HSDB</strong> 查看 JVM 中的各个对象，能通过指定类和里面的对象，就能看到。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/26/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(01)Retrofit%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/26/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(01)Retrofit%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" class="post-title-link" itemprop="url">Java筑基-：(01)Retrofit中的注解反射与动态代理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-26 15:56:00" itemprop="dateCreated datePublished" datetime="2023-03-26T15:56:00+08:00">2023-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-08 22:31:59" itemprop="dateModified" datetime="2023-04-08T22:31:59+08:00">2023-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>注解的作用： 用于标记，接口写成 interface ，注解 的写法是 @interface 。</p>
<h2 id="一、元注解"><a href="#一、元注解" class="headerlink" title="一、元注解"></a>一、元注解</h2><p>元注解，我们用得比较多的是下面 2 种：</p>
<ul>
<li><p>@Target ： 针对哪些地方来作用这个注解，有 TYPE （作用在类、接口、枚举，甚至注解上等）、METHOD（方法）、FIELD （属性）、PARAMETER（参数）。 Target 注解的value 是个数组，可以多个的</p>
</li>
<li><p>@Retention ： 表示可以将注解信息保存到什么层次。有 SOURCE（源码）、CLASS（.class文件）、RUNTIME（虚拟机级别） </p>
</li>
</ul>
<p>Retention 中三种级别的比较：</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>典型技术</th>
<th>使用场景</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>SOURCE</td>
<td>APT（annotion processor tool：注解处理工具）</td>
<td>编译期获取注解与其成员信息，一般用于生成辅助类</td>
<td>InDef、StringDef，参数只接受指定的几种值</td>
</tr>
<tr>
<td>CLASS</td>
<td>字节码增强、插桩</td>
<td>编译出class文件后，对class修改</td>
<td></td>
</tr>
<tr>
<td>RUNTIME</td>
<td>反射</td>
<td>运行期间，反射获取注解与其元素</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>注意：对于 Android 而言，打包 dex 的时候，CLASS 级别的注解都会被抛弃掉，但是 RUNTIME 级别的会保留</p>
<p>IntDef 的实现原理：传参非指定的时，会报红，看着是报错，但是是不影响运行的！它的原理就是 lint 检测</p>
</blockquote>
<h2 id="二、自定义-APT-（annotion-processor-tool）"><a href="#二、自定义-APT-（annotion-processor-tool）" class="headerlink" title="二、自定义 APT （annotion processor tool）"></a>二、自定义 APT （annotion processor tool）</h2><p>我们可以自定义注解处理器，自定义的类继承 AbstractProcessor ，然后注册。</p>
<blockquote>
<p>自定义的注解处理器不会被编译到代码中，只是编译的时候使用。这里没有详细写明怎么去自定义，如果后续用到了，可以再去看视频</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用 APT 新增一个类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APTTest</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>{</span><br><span class="line">        String code = <span class="string">"public class A {\n"</span> +</span><br><span class="line">                <span class="string">"}"</span>;</span><br><span class="line">        Filer filer = processingEnv.getFiler();</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//为什么用 JavaFileObject？因为它能默认将生成文件放到 build 目录下，无需你手动去加路径 </span></span><br><span class="line">            JavaFileObject sourceFile = filer.createClassFile(<span class="string">"A"</span>);</span><br><span class="line">            outputStream = sourceFile.openOutputStream();</span><br><span class="line">            <span class="comment">//将代码写入文件</span></span><br><span class="line">            outputStream.write(code.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>) {</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>javac 的执行流程如下：</p>
<p><img src="/Users/panda/Desktop/%E4%B8%AA%E4%BA%BA/blogSource_WB_github/giteeBlog_WB/source/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/javac%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="javac的执行流程"></p>
<p>发现注解之后，执行注解处理器，因为你在注解处理器里面可能会做改变（或者能新增了Java文件），因此能看到注解处理之后会有一条线回去，重新开始处理下。所以，注解处理器中的 process 方法可能会执行多次（因为新生成的类中可能还包括注解，所以可能是非常多的次数）。</p>
<p>因为 process 方法会执行多次，所以我们必须要判断注解过程是否执行完了，如果已经执行完了，就不要再去生成文件 A 了，可以通过如下方法判断过程执行完：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">annotations.isEmpty()</span><br><span class="line"></span><br><span class="line">roundEnv.processingOver()</span><br></pre></td></tr></tbody></table></figure>

<h2 id="三、字节码插桩技术"><a href="#三、字节码插桩技术" class="headerlink" title="三、字节码插桩技术"></a>三、字节码插桩技术</h2><p>为什么字节码插桩？因为你还是 Java 代码的时候，可能没有这种条件去做这个事情。比如，组件 A 中需要 new 出 B 组件中的 一个类，由于大家都是互相独立的，没有引用，但是 字节码中就不一样了，所有的类都变成了 class 了，肯定有引用的。<strong>典型的如 ARouter 中的 路由表的实现。</strong></p>
<blockquote>
<p>还有个典型的例子是 腾讯的 Matrix 性能监控的实现</p>
</blockquote>
<p>字节码插桩也能用来实现  AOP ，比如 360 的 APM ，这样就能实现在代码中的判断。</p>
<blockquote>
<p> 字节码插桩的本质： .class 是个文件，它有自己的格式，可以作为读入，按照一定的格式修改，再保存就可以了</p>
</blockquote>
<h2 id="四、反射"><a href="#四、反射" class="headerlink" title="四、反射"></a>四、反射</h2><p>我们能够通过反射修改 final 类型的成员的值吗？答案是肯定的，但是肯定有人经历过下面这种情景：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ReflectTest reflectTest = <span class="keyword">new</span> ReflectTest();</span><br><span class="line">        Field a = ReflectTest.class.getDeclaredField(<span class="string">"a"</span>);</span><br><span class="line">        a.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        a.set(reflectTest, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"a = "</span> + reflectTest.a);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过上面的代码反射修改 a 的值为 2，但是最终 println 打印出来的却是  1 ，这是没有修改？其实不是，这是因为 Java 编译过程的优化导致的，这里是内联，我们看下它编译成的字节码，反编译过来：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectTest</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ReflectTest reflectTest = <span class="keyword">new</span> ReflectTest();</span><br><span class="line">        Field a = ReflectTest.class.getDeclaredField(<span class="string">"a"</span>);</span><br><span class="line">        a.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        a.set(reflectTest, <span class="number">2</span>);</span><br><span class="line">        PrintStream var10000 = System.out;</span><br><span class="line">        Objects.requireNonNull(reflectTest);</span><br><span class="line">        var10000.println(<span class="string">"a = "</span> + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看到代码最后一行，我们的 reflectTest.a 已经直接 变成 1 了，并且注意看 getA() 方法 ，它里面return a 也直接变为 return 1 。所以，我们可以知道，其实 a 的值是已经改了，但是通过上述的代码看不出来。</p>
<p>那么问题来了，如果我想获取到这个修改后的 a 值怎么办？  答案还是通过反射获取，将最后一行的打印改成这样就行，就能正常输出修改后的 2 值了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"a = "</span> + a.getInt(reflectTest));</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-1-反射调用方法为什么耗时"><a href="#4-1-反射调用方法为什么耗时" class="headerlink" title="4.1 反射调用方法为什么耗时"></a>4.1 反射调用方法为什么耗时</h3><p>比如通过对象普通调用方法，类似 object.method() ， 字节码中用 iconst_1 指令即可完成，不需要做额外事情，但是对于反射获取而言</p>
<ul>
<li><p>但是反射，我们调用的的是  Object.invoke (Object obj, Object…args) 能看出来，参数是 <strong>变长</strong> 的了，并且还都是 Object ，意味着你普通方法是 int 型 的话，这里需要装箱成  Integer类型，再包装成 Object 数组，在执行的时候又会把数组拆开，并且拆箱为基本数据类型。</p>
</li>
<li><p>从源码可知，反射需要遍历所有的方法，匹配方法名和参数，然后才能得到正确的目标方法</p>
</li>
<li><p>反射时需要检查方法的可见性，以及参数的匹配性</p>
</li>
<li><p>反射时，编译期无法对动态调用的代码做优化，比如 内联</p>
<blockquote>
<p>比如，上面我们更改 a 的值为 2 ，通过反射时就能获取这个值，说明是没有做优化的</p>
</blockquote>
</li>
</ul>
<p>当然，现在硬件性能已经非常强了，反射能带来的影响还是比较小的，。</p>
<h2 id="五、动态代理"><a href="#五、动态代理" class="headerlink" title="五、动态代理"></a>五、动态代理</h2><p>动态代理的原理是，会自动给你生成代码，相当于修改字节码。自己去看下编译期给自动生成的那个 Proxy 类。</p>
<p><font color="#ff0000">动态代理的原理还不太清楚，下次来需要着重梳理</font></p>
<h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><p> 注解+反射+ 动态代理实现 @Click 方法，动态代理为了<strong>开闭原则</strong>，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Click(R.id.button)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">(View view)</span></span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/14/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC15%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/14/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC15%E7%AB%A0/" class="post-title-link" itemprop="url">第15章：TCP数据流与窗口管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-14 19:50:00" itemprop="dateCreated datePublished" datetime="2023-03-14T19:50:00+08:00">2023-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-15 16:13:20" itemprop="dateModified" datetime="2023-03-15T16:13:20+08:00">2023-03-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="15-3-延时确认"><a href="#15-3-延时确认" class="headerlink" title="15.3 延时确认"></a>15.3 延时确认</h2><p>累积确认可以允许 TCP 延迟一段时间发送 ACK ，<strong>以便将 ACK 和相同方向上需要传的数据结合发送</strong>。不过TCP 不能任意时长地延迟 ACK，否则对方会误认为数据丢失而出现不必要的重传。</p>
<h2 id="15-4-Nagle-算法"><a href="#15-4-Nagle-算法" class="headerlink" title="15.4 Nagle 算法"></a>15.4 Nagle 算法</h2><p>从前面可知， ssh 连接中，通常单次按键就会引发数据流的传输。这些包很小，但是会造成相当高的网络传输代价，也就是说与其他包相比，有效的应用数据占比较低（IP头部有 20 字节，TCP头部 20 字节，数据部分仅仅 48 字节）。</p>
<p>Nagle 算法要求：当一个 TCP 在传数据时，小的报文段不能被发送，直到所有的在传数据都收到了 ACK，并且，TCP 需要收集这些小数据，将其整合到一个报文段中发送。</p>
<h3 id="15-5-流量控制与窗口管理"><a href="#15-5-流量控制与窗口管理" class="headerlink" title="15.5 流量控制与窗口管理"></a>15.5 流量控制与窗口管理</h3><p>前面提到可以采用可变滑动窗口来实现流量控制。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/14/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC14%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/14/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC14%E7%AB%A0/" class="post-title-link" itemprop="url">第14章：TCP超时与重传</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-14 09:00:00 / 修改时间：19:48:00" itemprop="dateCreated datePublished" datetime="2023-03-14T09:00:00+08:00">2023-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="14-1-引言"><a href="#14-1-引言" class="headerlink" title="14.1 引言"></a>14.1 引言</h2><p>TCP 拥有<strong>2套</strong>独立的机制来完成重传：</p>
<ul>
<li><p><strong>基于时间:</strong> 发送数据后设置计时器，若超时还未收到数据确认，则触发超时重传。</p>
</li>
<li><p><strong>基于确认信息的构成:</strong> 也叫做<strong>快速重传</strong>，通常发生在没有延时的情况下（根据以前的知识就是连续收到 3 个相同的 ACK），重传可能丢失的分组</p>
</li>
</ul>
<p>当失序数据到达时，重复 ACK 应当立即返回，不能延时发送，原因在于 <strong>使发送端尽早得知有失序报文，并告诉其空缺在哪</strong></p>
<blockquote>
<p>与超时重传相比，快速重传能更有效地修复丢包情况</p>
</blockquote>
<h2 id="14-3-设置超时重传"><a href="#14-3-设置超时重传" class="headerlink" title="14.3 设置超时重传"></a>14.3 设置超时重传</h2><p>TCP 并非对其接收到的每个报文段都返回 ACK，例如：当传输大批量数据时，TCP 通常采取每2个报文段返回一个 ACK 方法；另外，当数据出现丢失、失序或者重传成功时TCP 的累积确认机制表明报文段与ACK 之间并非严格一一对应的。</p>
<p>在TCP 握手阶段，SYN 、ACK 等数据包并未包含实际数据，由于 <strong>TCP 对不包含数据的报文段不提供可靠传输</strong>，意味着若出现丢包不会重传，因此<strong>无须设定重传计时器</strong>！</p>
<blockquote>
<p>由于接收端在收到失序的数据后会立即返回 ACK，以此来帮助触发快速重传，<strong>因此网络中任何一个失序的数据包都会生成重复的ACK</strong>。如果我们一旦收到重复 ACK 就立即启动快速重传，那就会导致大量不必要的重传发生，为了解决这一问题，快速重传仅在达到<strong>重复阈值</strong>之后才会被触发</p>
</blockquote>
<h2 id="14-10-重新组包"><a href="#14-10-重新组包" class="headerlink" title="14.10 重新组包"></a>14.10 重新组包</h2><p>当TCP 超时重传时，并不需要完全重传相同的报文段。TCP 允许执行<strong>重新组包</strong>发送一个更大的报文来提高性能。</p>
<blockquote>
<p>允许这样做的原因在于，TCP 是通过字节号来识别发送和接收的数据，而非报文段(或包)号。</p>
</blockquote>
<p>可以基于重新组包的方式来检测伪超时。</p>
<h2 id="14-11-与-TCP-重传相关的攻击"><a href="#14-11-与-TCP-重传相关的攻击" class="headerlink" title="14.11 与 TCP 重传相关的攻击"></a>14.11 与 TCP 重传相关的攻击</h2><p>有一类 DoS 攻击称为 低速率DoS 攻击。这类攻击向网关或主机发送大量数据，使得受害系统持续处于重传超时的状态，由于攻击者可以预知受害TCP何时启动重传，并在每次重传时发送大量数据，因此，受害 TCP 总能感知到拥塞的存在，根据Karn算法不断减小发送速率并退避发送，导致无法正常使用网络宽带</p>
<p>解决方案：随机选择 RTO，<strong>使得攻击者无法预知准确的重传时间</strong></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC13%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC13%E7%AB%A0/" class="post-title-link" itemprop="url">第13章：TCP连接管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-13 18:02:00 / 修改时间：18:59:10" itemprop="dateCreated datePublished" datetime="2023-03-13T18:02:00+08:00">2023-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="13-1-引言"><a href="#13-1-引言" class="headerlink" title="13.1 引言"></a>13.1 引言</h2><p>TCP 必须检测并修补所有在 IP 层产生的数据传输问题： 比如丢包、重复 以及 错误。</p>
<h3 id="13-5-2-TIME-WAIT-状态"><a href="#13-5-2-TIME-WAIT-状态" class="headerlink" title="13.5.2 TIME_WAIT 状态"></a>13.5.2 TIME_WAIT 状态</h3><p>TIME_WAIT 状态也称为 2MSL 等待状态，该状态下，TCP 将会等待 2 倍于<strong>最大段生存期（Maximum  Segment Lifetime， MSL</strong>的时间，这段时间连接不可用，等待链路上的报文段过期，防止复用这个连接时，将老的连接中的报文当成新连接发送的数据。</p>
<h3 id="13-5-3-静默时间"><a href="#13-5-3-静默时间" class="headerlink" title="13.5.3 静默时间"></a>13.5.3 静默时间</h3><p>在本地与外地的 IP 地址、端口号 都相同的情况下，2MSL 状态能防止新的连接将前一个连接的延迟报文解释成自身数据的状况。然而，这种方法只有在与<strong>处于2MSL等待状态的连接相关的主机未关闭的情况</strong>才有意义。为什么呢？</p>
<p>假如一台与处于 TIME_WAIT 状态下的链接相关联的主机崩溃，然后再 MSL 内重新启动，并且使用与主机崩溃之前处于 TIME_WAIT 状态的连接相同的 IP 地址与端口号，那要怎么处理呢？解决办法就是：在崩溃或者重启后，TCP 应该在创建新的连接之前等待一个 MSL 的时间，这段时间称为 <strong>静默时间</strong>。</p>
<h2 id="13-8-与-TCP-连接管理相关的攻击"><a href="#13-8-与-TCP-连接管理相关的攻击" class="headerlink" title="13.8 与 TCP 连接管理相关的攻击"></a>13.8 与 TCP 连接管理相关的攻击</h2><p>SYN 洪泛攻击时一种 TCP 拒绝服务攻击。在这种攻击中一个或者多个恶意的客户端产生一系列 TCP 连接尝试，并将他们发送给一台服务器，他们通常采用“伪造”的源 IP 地址。服务器回味每条链接分配一定数量的连接资源，由于连接尚未完全建立，服务器为了维护大量的半打开连接会在耗尽自身内存后拒绝为后续的合法连接请求服务。</p>
<blockquote>
<p>解决办法：只有当 SYN+ACK 报文段本身被确认后，才会分配真正的内存</p>
</blockquote>
<p>还有一种攻击与路径最大传输单元发现过程相关。攻击者伪造一个非常小的 MTU 值，迫使受害的 TCP  尝试采用非常小的数据报来填充数据，从而大大降低性能。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC12%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC12%E7%AB%A0/" class="post-title-link" itemprop="url">第12章：TCP:传输控制协议（初步）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-13 16:00:00 / 修改时间：18:01:08" itemprop="dateCreated datePublished" datetime="2023-03-13T16:00:00+08:00">2023-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="12-1-引言"><a href="#12-1-引言" class="headerlink" title="12.1 引言"></a>12.1 引言</h2><h3 id="12-1-1-ARQ-和-重传"><a href="#12-1-1-ARQ-和-重传" class="headerlink" title="12.1.1 ARQ 和 重传"></a>12.1.1 ARQ 和 重传</h3><p>重传的时候，接收方可能收到被传送分苏的重复副本，这就要求使用序列号来解决：在被远端发送时，每个唯一的分组都有一个新的序列号。</p>
<p>如果想要吞吐量更高，我们就要求在网络中可以同时存在多个分组，这就变得更加复杂：发送方不仅要决定什么时候注入一个分组到网络中，还要考虑注入多少个，并且在等待 ACK 的时候，怎样维持计时器，同时还需要保存每个还没收到 ACK 分组的副本防止重传需要。</p>
<h3 id="12-1-2-分组窗口和滑动窗口"><a href="#12-1-2-分组窗口和滑动窗口" class="headerlink" title="12.1.2 分组窗口和滑动窗口"></a>12.1.2 分组窗口和滑动窗口</h3><p>为了解决上述问题，我们假设每个分组有一个序列号，并且定义一个分组窗口作为<strong>已经被发送但是还没完成确认</strong>的分组集合，我们把窗口中分组的数量称为<strong>窗口大小</strong>，如下图所示：</p>
<p><img src="/assets/Book-Notes/TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/12%E7%AB%A0/%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F.png" alt="发送窗口示意图"></p>
<p>上图显示当前窗口有3个分组，整个窗口大小是3。其中，3号分组已经被发送和确认，所以发送方保存的副本可以释放了；分组 7 在发送方已经准备好，但是还没发送，因为还没“进入窗口”。现在假如发送方下一步收到分组 4 的 ACK，此时窗口向右边 “滑动”一个分组，意味着 4 可以释放了，而 7 可以发送了。这种就叫做 “滑动窗口”协议。</p>
<p>一般来说，这个滑动窗口在发送方和接收方都会有，在发送方，它记录着哪些分组可以释放，哪些正在等待 ACK，哪些分组还不能被发送；在接收方，它记录着哪些分组已经被接收和确认，哪些分组时下一步期望的，哪些分组即使接收了也会被丢弃。</p>
<h3 id="12-1-3-变量窗口：流量控制和拥塞控制"><a href="#12-1-3-变量窗口：流量控制和拥塞控制" class="headerlink" title="12.1.3 变量窗口：流量控制和拥塞控制"></a>12.1.3 变量窗口：流量控制和拥塞控制</h3><p>为了处理接收方相对发送方太慢的问题，我们在接收方跟不上时会强迫发送方慢下来，这称为<strong>流量控制</strong>。主要有以下2种方式：</p>
<ul>
<li><p>基于速率流量控制：给发送方指定某个速率，去报数据不能超过这个速率发送。多用于流应用程序，可被用于广播和组播发现</p>
</li>
<li><p>基于窗口流量控制：这是使用滑动窗口最流行的方法，思想是：窗口大小不固定，允许随时间变化而变化，必须有一种方法让接收方可以通知到发送方使用多大窗口（即窗口通告）</p>
</li>
</ul>
<p>拥塞控制用于发送方减低速度以不至于压垮发送方与接收方之间的网络。</p>
<h2 id="12-2-TCP的引入"><a href="#12-2-TCP的引入" class="headerlink" title="12.2 TCP的引入"></a>12.2 TCP的引入</h2><p>TCP 提供一种字节流抽象概念给应用程序使用，这就意味着没有消息边界。举例解释一下：如果应用程序一一端写入 10 字节，随后又写入 20 字节，再随后写入 50 字节，那么在另一端时不知道每次写入多少字节的；另一端可能以每次读取20字节分4次读取或者一次性读取80字节的方式读取。</p>
<p><strong>TCP根本不会解读字节流中的字节内容</strong>，它不知道传输的是二进制数据、ASCII 还是其他东西。</p>
<h3 id="12-2-2-TCP中的可靠性"><a href="#12-2-2-TCP中的可靠性" class="headerlink" title="12.2.2 TCP中的可靠性"></a>12.2.2 TCP中的可靠性</h3><p>TCP 必须把应用程序发送的字节流转换为一组 IP可以携带的分组，这被称为组包。这些分组包含序列号，该序列号在TCP 中代表了每个分组的第一个字节在整个数据流中的字节偏移，而不是分组号。TCP传给IP的块称为 <strong>报文段</strong>。</p>
<p>而UDP 就不同了，应用程序每次写入通常就产生一个 UDP 数据，其大小就是写入的那么大（加上头部）。</p>
<p>TCP 发送一组报文段时会设置一个<strong>重传计时器</strong>，等待对方的确认。不过它不会为每个报文段设置，而是发送一个窗口的数据，它只设置一个计时器，当 ACK 到达时再更新超时。如果有一个确认没有及时接收到，这个报文段就会被重传。</p>
<h2 id="12-3-TCP-头部封装"><a href="#12-3-TCP-头部封装" class="headerlink" title="12.3 TCP 头部封装"></a>12.3 TCP 头部封装</h2><p>UDP 的头部一般是 8 字节，TCP 头部通常是 20 个字节（带选项的话可达 60 字节）。每个TCP 的头部都包含了 源和目的IP地址，以及源和目的 端口号。</p>
<blockquote>
<p>在 TCP 术语中，一个 IP 地址和一个端口的组合被称为 套接字（Socket） 或者 端点（endpoint）</p>
</blockquote>
<p>TCP 报文段的数据部分是可选的，基于后面的知识我们可以看到：当一个连接被建立和终止时（我理解的是 握手和挥手），交换的报文段只包含 TCP 头部而没有数据。</p>
<h2 id="12-4-总结"><a href="#12-4-总结" class="headerlink" title="12.4 总结"></a>12.4 总结</h2><p>处理传输过程的差错主要有2种方法：</p>
<ul>
<li><p>差错校正码：添加一些冗余比特，使得即使某些比特被毁，真实的信息也能被恢复过来</p>
</li>
<li><p>重传，直至信息被正确接收</p>
</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC10%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC10%E7%AB%A0/" class="post-title-link" itemprop="url">第10章：用户数据报协议和IP分片</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-13 14:37:00 / 修改时间：15:59:36" itemprop="dateCreated datePublished" datetime="2023-03-13T14:37:00+08:00">2023-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="10-2-UDP-头部"><a href="#10-2-UDP-头部" class="headerlink" title="10.2 UDP 头部"></a>10.2 UDP 头部</h2><p>在UDP 中，源端口号是可选的，如果数据报的发送者不要求对方回复的话，它可以被置为 0。</p>
<p>TCP 的端口号只能被 TCP 使用，UDP 端口号只能被 UDP 使用，以此类推。这样导致的一个结果就是：2个完全不同的服务器可以使用相同的端口号和 IP 地址，只要它们属于不同的传输协议。</p>
<p>UDP 头部中的 Length 字段表示的是长度，这个长度包括 UDP 头部 和 UDP 数据 的总长度；需要注意的是，发送一个带 0 字节数据的 UDP 数据报是允许的，尽管很少见。</p>
<h2 id="10-3-UDP-校验和"><a href="#10-3-UDP-校验和" class="headerlink" title="10.3 UDP 校验和"></a>10.3 UDP 校验和</h2><p>UDP 在 IPv4 头部中的校验和只覆盖整个头部（并不覆盖IP分组中的任何数据），头部中的校验和是可选的。不过，在 IPv6 中，UDP 的校验和的计算与使用时强制的，因为在 IP 层没有头部校验和。</p>
<h2 id="10-7-IP-分片"><a href="#10-7-IP-分片" class="headerlink" title="10.7 IP 分片"></a>10.7 IP 分片</h2><p>链路层通常对可传输的每个帧的最大长度有一个上限， IP 比较外出接口的 MTU 和数据大小，如果数据报太大则进行分片。当一个 IP 数据报被分片了，直到它到大最终目的地才会被重组，这是为什么呢？为什么不在中途重组呢？有 2 个原因，第 2 个原因比第 1 个原因更重要：</p>
<ol>
<li><p>在网络中不进行重组要比重组更能减轻路由转发软件（或硬件）的负担</p>
</li>
<li><p>同一数据报的不同分片可能经由不同的路径到达相同的目的地。也就是说路径上的路由通常没有能力来重组原始数据报（因为手头只有所有分片的一个子集）</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>UDP 不提供差错纠正、队列管理、重复消除、流量控制和拥塞控制，它提供了差错检测，包含校验和。当要避免连接的开销、使用多端点（组播/广播）传送时，或者不需要 TCP 相对“笨重”的可靠语义时，最常用的就是 UDP，主要用途就是支持 DNS ，多媒体上也得到广泛使用。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/13/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC7%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC7%E7%AB%A0/" class="post-title-link" itemprop="url">第7章：Kotlin协程在Android上的应用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-13 11:33:00" itemprop="dateCreated datePublished" datetime="2023-03-13T11:33:00+08:00">2023-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-11 11:51:57" itemprop="dateModified" datetime="2023-03-11T11:51:57+08:00">2023-03-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>未开始</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/11/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/11/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">第5章：Kotlin协程框架开发初探</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-11 09:10:00" itemprop="dateCreated datePublished" datetime="2023-03-11T09:10:00+08:00">2023-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-10 21:01:35" itemprop="dateModified" datetime="2023-03-10T21:01:35+08:00">2023-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>为了学习官方协程，我们先实现一些轻量级的复合协程，只是用于学习，不适合生产环境。</p>
<h2 id="5-1-开胃菜：实现一个-delay-函数"><a href="#5-1-开胃菜：实现一个-delay-函数" class="headerlink" title="5.1 开胃菜：实现一个 delay 函数"></a>5.1 开胃菜：实现一个 delay 函数</h2><p>使用线程的时候，如果希望代码延迟一段时间再执行，通常会调用 Thread.sleep 函数，<strong>这会令当前线程阻塞</strong>。在协程中也可以这样，不过协程可以挂起还去阻塞线程，就很浪费资源，我们的目的是后面的代码延迟一段时间执行，因此可以确定以下2点：</p>
<ul>
<li><p>不要阻塞线程</p>
</li>
<li><p>是个挂起函数，指定时间之后能够恢复执行即可</p>
</li>
</ul>
<p>从上面 2 点我们可以给出 delay 函数的声明： </p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(time: <span class="type">Long</span>, unit: <span class="type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">    。。。</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来要考虑挂起，<strong>自然就想到了 suspendCoroutin</strong>：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(time: <span class="type">Long</span>, unit: <span class="type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> {</span><br><span class="line">    。。。</span><br><span class="line">    suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; {continuation: Continuation&lt;<span class="built_in">Unit</span>&gt; -&gt;  </span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    。。。</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>只需要做到在指定的 time 之后执行 continuation.resume() 就行，因此，<strong>我们只需要提供这样一个定时回调机制就可以！</strong>,定时任务很容易想到 <strong>ScheduledExecutorService</strong>，因此代码可以这样写：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> executor = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="keyword">object</span> : ThreadFactory{</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newThread</span><span class="params">(r: <span class="type">Runnable</span>)</span></span>: Thread {</span><br><span class="line">        <span class="keyword">return</span> Thread(r, <span class="string">"Scheduler"</span>).apply {</span><br><span class="line">            isDaemon = <span class="literal">true</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>这里为什么要设置 isDaemon ，放到后面说。接着我们可以实现功能了：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(time: <span class="type">Long</span>, unit: <span class="type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> {</span><br><span class="line">    suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; {continuation: Continuation&lt;<span class="built_in">Unit</span>&gt; -&gt;</span><br><span class="line">        executor.schedule(<span class="keyword">object</span>: Runnable{</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> {</span><br><span class="line">                continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">            }</span><br><span class="line">        }, time, unit)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="5-1-1-为什么这样用-ScheduledExecutorService（自己加的标题）"><a href="#5-1-1-为什么这样用-ScheduledExecutorService（自己加的标题）" class="headerlink" title="5.1.1 为什么这样用 ScheduledExecutorService（自己加的标题）"></a>5.1.1 为什么这样用 ScheduledExecutorService（自己加的标题）</h3><p>了解 ScheduledExecutorService 工作机制的朋友还会有疑惑：Scheduled-ExecutorService <strong>在等待延时的阶段还是会阻塞</strong>，这不也浪费资源吗？这里说明下2个原因：</p>
<ul>
<li><p>如果当前线程有特殊地位，例如 UI线程 等，那么它们是不能被阻塞的，因此我们将阻塞动作放到后台线程上是有意义的</p>
</li>
<li><p>后台<strong>一个线程可以承载非常多的延时任务</strong>，例如：有 10 个协程调用 delay ，那么只需要阻塞一个 后台线程即可实现这 10 个协程的延时执行 ！参考下图：</p>
</li>
</ul>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kotlin%E5%8D%8F%E7%A8%8B/%E7%AC%AC5%E7%AB%A0/%E5%A4%9A%E4%B8%AAdelay%E5%8D%8F%E7%A8%8B%E5%85%AC%E7%94%A8%E4%B8%80%E4%B8%AA%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B.png" alt="多个delay协程公用一个后台线程"></p>
<h2 id="5-2-协程的描述"><a href="#5-2-协程的描述" class="headerlink" title="5.2 协程的描述"></a>5.2 协程的描述</h2><p>Java 平台上 Thread 的定义很直观，让人很容易识别 Java 线程；而协程一开始只是在标准库中放了协程基础设施，导致难以上手和分辨。这里我们尝试给一个类来描述协程，按照官方的做法把它命名为 Job ，如下代码清单：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Job</span> : <span class="type">CoroutineContext.Element {</span></span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;Job&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt; <span class="keyword">get</span>() = Job</span><br><span class="line">    <span class="keyword">val</span> isActive: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnCancel</span><span class="params">(onCancel: <span class="type">OnCancel</span>)</span></span>: Disposable</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnCompletion</span><span class="params">(onComplete: <span class="type">OnComplete</span>)</span></span>: Disposable</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(disposable: <span class="type">Disposable</span>)</span></span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>与 Thread 相比， Job 同样有 join ，调用时会挂起( 而线程的 join 则会阻塞线程 )，直到协程完成；cancel() 类比与 Thread 的 interrupt() ，用于取消协程； isAlive() 类比 Thread 的 isAlive()  ，用于查询协程是仍在执行。</p>
<p>invokeOnCancel 用于协程取消时的回调；invokeOnCompletion 可以注册协程完成的回调。remove 用于移除回调。 key 将协程 Job 存入上下文，这样就很容易拿到 Job 实例。</p>
<h3 id="5-2-2-协程的状态"><a href="#5-2-2-协程的状态" class="headerlink" title="5.2.2 协程的状态"></a>5.2.2 协程的状态</h3><p>我们对协程进行封装，目的就是让它状态更容易管理。对于协程来讲，启动之后主要就是 <strong>未完成、已取消、已完成</strong>这几种状态，接下来定义一下状态：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineState</span> </span>{</span><br><span class="line">    <span class="comment">//未完成：协程启动后立即进入该状态，直到完成获取取消</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Imcomplete</span> : <span class="type">CoroutineState</span></span>()</span><br><span class="line">    <span class="comment">//已取消：协程被取消后立即进入该状态</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cancelling</span> : <span class="type">CoroutineState</span></span>()</span><br><span class="line">    <span class="comment">//已完成：协程执行完后（不管成功失败）进入该状态</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Complete</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> value: T? = <span class="literal">null</span>, <span class="keyword">val</span> exception: Throwable? = <span class="literal">null</span>) : CoroutineState()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>——————-中间略过一大截，看不懂—————————–</p>
<h2 id="5-4-协程的执行调度"><a href="#5-4-协程的执行调度" class="headerlink" title="5.4 协程的执行调度"></a>5.4 协程的执行调度</h2><p>协程在哪里挂起、什么时候恢复都是开发者自己决定的，意味着不像线程那样把调度工作交给操作系统，而是在用户态解决，所以协程也经常被称为<strong>用户态线程</strong>。</p>
<h3 id="5-4-2-协程的调度位置"><a href="#5-4-2-协程的调度位置" class="headerlink" title="5.4.2 协程的调度位置"></a>5.4.2 协程的调度位置</h3><p><strong>当协程执行到挂起点为止时，如果产生异步行为，协程就会在这个挂起点挂起</strong>，这里的一部情形包括以下形式：</p>
<ul>
<li><p>挂起点对应的挂起函数内部切换了线程，并在线程内部调用 Continuation 的恢复调用来恢复。</p>
</li>
<li><p>挂起函数内部通过某种事件循环机制将 Continuation 的恢复调用转到新的线程调用栈上执行。如：Android平台通过 Handler 的 post 操作，实际上这个过程不一定发生线程切换</p>
</li>
<li><p>挂起函数内部将 Continuation 保存，在后续某个时机再执行恢复调用，这个过程也不一定发生线程切换，但是函数调用栈会发生变化。</p>
</li>
</ul>
<p><strong>综上所述，不管何种形式，恢复和挂起不再同一个函数调用栈中执行就是挂起点挂起的充分条件！</strong>只有当挂起点真正挂起，我们才有机会实现调度，而<strong>实现调度需要使用协程拦截器</strong>。</p>
<h3 id="5-4-3-协程的调度器设计"><a href="#5-4-3-协程的调度器设计" class="headerlink" title="5.4.3 协程的调度器设计"></a>5.4.3 协程的调度器设计</h3><p>官方协程框架的默认调度器就是基于线程池实现的：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DefaultDispatcher : Dispatcher {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> threadGroup = ThreadGroup(<span class="string">"DefaultDispatcher"</span>) </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> threadIndex = AtomicInteger(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> executor = Executors.newFixedThreadPool(</span><br><span class="line">        Runtime.getRuntime().availableProcessors() + <span class="number">1</span></span><br><span class="line">    ) { runnable -&gt;</span><br><span class="line">        Thread(</span><br><span class="line">            threadGroup,</span><br><span class="line">            runnable,</span><br><span class="line">            <span class="string">"<span class="subst">${threadGroup.name}</span>-worker-<span class="subst">${threadIndex.getAndIncrement()}</span>"</span></span><br><span class="line">        ).apply { isDaemon = <span class="literal">true</span> }</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> {</span><br><span class="line">        executor.submit(block)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>调用dispatch 方法的时候，实际上是将 block 扔给 executor 放到线程中执行。</p>
<p>其实也可以实现成基于拦截器的方式：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> {</span><br><span class="line">    dispatcher.dispatch { delegate.resumeWith(result) }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>基于UI事件循环的调度器就是通过在disptch() 方法中用 Handler 的 post 实现：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> AndroidDispatcher : Dispatcher {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> handler = Handler(Looper.getMainLooper()) </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> {</span><br><span class="line">        handler.post(block)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<p>——————-后续的又看懵逼了—————————–</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/10/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC4%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/10/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC4%E7%AB%A0/" class="post-title-link" itemprop="url">第4章：Kotlin协程的拓展实践</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-10 16:55:00 / 修改时间：17:25:33" itemprop="dateCreated datePublished" datetime="2023-03-10T16:55:00+08:00">2023-03-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>前面的介绍了解了协程可以挂起和恢复，但是对于协程如何使用仍然倍感疑惑，所以还需要机遇简单协程构建足够有好的上层 API ，即复合协程。</p>
<h2 id="4-1-序列生成器"><a href="#4-1-序列生成器" class="headerlink" title="4.1 序列生成器"></a>4.1 序列生成器</h2><p>看得云里雾里，先略过</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">173</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共355.9k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/3/',]
      });
      });
  </script>


</body>
</html>
