<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/3/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">161</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/27/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/27/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：Kotlin协程的基础设施</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-27 14:25:00" itemprop="dateCreated datePublished" datetime="2023-02-27T14:25:00+08:00">2023-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-10 16:54:39" itemprop="dateModified" datetime="2023-03-10T16:54:39+08:00">2023-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="3-1-协程的构造"><a href="#3-1-协程的构造" class="headerlink" title="3.1 协程的构造"></a>3.1 协程的构造</h2><h3 id="3-1-1-协程的创建"><a href="#3-1-1-协程的创建" class="headerlink" title="3.1.1 协程的创建"></a>3.1.1 协程的创建</h3><p>Kotlin 提供了一个 createCoroutine 函数用来创建协程：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>其中 suspend() -&gt; T 是 createCoroutin 函数的 Receiver，对 Kotlin 函数不了解的话，这个还是有点费解的。我们依次剖析 createCoroutine 的参数和返回值：</p>
<ul>
<li><p>Receiver 是一个被 suspend 修饰的挂起函数，这也是协程协程的执行体（协程体）</p>
</li>
<li><p>参数是 completion（是 Continuation 类型）会在协程体执行完后调用，实际上就是<strong>协程完成的回调</strong></p>
</li>
<li><p>返回值也是一个 Continuation 对象，由于现在协程仅仅被创建出来，因此需要通过这个值在之后触发协程的启动</p>
</li>
</ul>
<p>以一个例子来说明 createCoroutine 的用法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> continuation = <span class="keyword">suspend</span> {</span><br><span class="line">    println(<span class="string">"In Coroutine."</span>)</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">}.createCoroutine(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt; {</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">        println(<span class="string">"Coroutine End: <span class="variable">$result</span>"</span>)</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>目前协程被创建出来了，但是它还未启动。</p>
<h3 id="3-1-2-协程的启动"><a href="#3-1-2-协程的启动" class="headerlink" title="3.1.2 协程的启动"></a>3.1.2 协程的启动</h3><p>在上述的例子中，我们已经创建了协程，之后只需要调用 continuation.resume(Unit) 之后，协程就会立即开始。为什么这样就可以触发协程体执行呢？</p>
<p>其实，我们创建协程得到的 continuation 是 SafeContinuation 的实例，不过这也是个“马甲”，它有个 delegate 属性，里面将 suspend() -&gt; T  封装成了一个 Continuation 对象</p>
<p><strong>也就是说，我们创建协程得到的 continuation 其实就是套了几层“马甲”的协程体，故调用这个 continuation.resume() 可以触发协程体的执行</strong></p>
<p>一般来讲，我们创建协程之后就会启动它，所以标准库还提供了另一个一步到位的API——startCoroutin ：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(completion: Continuation&lt;T&gt;)</span><br></pre></td></tr></tbody></table></figure>

<p>我们知道，作为参数传入的 completion 就如同回调一样，**协程体的返回值会作为 resumeWith 的参数传入，例如，下面的例子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">suspend</span> {</span><br><span class="line">        println(<span class="string">"我跑在协程里"</span>)</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    }.startCoroutine(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt; {</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">            <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">            println(<span class="string">"协程执行完成，result = <span class="variable">$result</span>"</span>)</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果协程体执行正常，则 result 为 Success 结果；否则返回 Failure 结果。上述代码结果如下：</p>
<blockquote>
<p>我跑在协程里<br>//协程执行完成，result = Failure(java.lang.IllegalStateException: 抛出异常)<br>协程执行完成，result = Success(3)</p>
</blockquote>
<h3 id="3-1-3-协程体的-Receiver"><a href="#3-1-3-协程体的-Receiver" class="headerlink" title="3.1.3 协程体的 Receiver"></a>3.1.3 协程体的 Receiver</h3><p>与协程创建和启动相关的 API 还有一组：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> R.()</span></span> -&gt; T).create(</span><br><span class="line">    receiver: R,</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start 方法略</span></span><br></pre></td></tr></tbody></table></figure>

<p>上述的 R 可以为协程体提供一个作用域，在协程体内我们可以直接使用，如下代码所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先把上述方法封装下，如果不封装怎么调用？</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">launchCoroutine</span><span class="params">(receiver: <span class="type">R</span>, block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span>)</span></span> {</span><br><span class="line">    block.startCoroutine(receiver, <span class="keyword">object</span> : Continuation&lt;T&gt; {</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> {</span><br><span class="line">            println(<span class="string">"Coroutine End: <span class="variable">$result</span>"</span>)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context = EmptyCoroutineContext</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建额外的域</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerScope</span>&lt;<span class="type">T</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">(value: <span class="type">T</span>)</span></span> {</span><br><span class="line">        println(<span class="string">"我在额外的 Receiver 中了: <span class="variable">$value</span>"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    launchCoroutine(ProducerScope&lt;<span class="built_in">Int</span>&gt;()) {</span><br><span class="line">        println(<span class="string">"In Coroutine."</span>)</span><br><span class="line">        produce (<span class="number">1024</span>)</span><br><span class="line">        <span class="comment">//delay (1000)  //我自己测试的时候，如果放开这个注释，就不会打到 2048，coroutine end 也不会执行到</span></span><br><span class="line">        produce (<span class="number">2048</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>这里要注意的一点是，如果额外的域 ProducerScope 添加了 @RestrictsSuspension 注解，则无法使用外部的函数，因此例子中的 delay 也不会调用</p>
</blockquote>
<h3 id="3-1-4-可挂起的-main-函数"><a href="#3-1-4-可挂起的-main-函数" class="headerlink" title="3.1.4 可挂起的 main 函数"></a>3.1.4 可挂起的 main 函数</h3><p>前面我们一直这样写：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样就能在程序入口就获得一个协程了，这到底是怎么实现的呢？首先，我们能确认2点：</p>
<ul>
<li><p>JVM 压根就不知道什么挂起函数，kotlin协程</p>
</li>
<li><p>JVM 肯定有一个 main 函数的</p>
</li>
</ul>
<p>为了搞清楚原理，我们可以对 Kotlin 反编译成 Java 代码（IDEA的 Kotlin byteCode 功能）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>{</span><br><span class="line">   RunSuspendKt.runSuspend(<span class="keyword">new</span> KotlinMainKt$$$main(var0));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，其实它是有真正的 main 函数的，里面的协程封装逻辑都被扔到 RunSuspendKt里面了</p>
<h3 id="3-2-1-挂起函数"><a href="#3-2-1-挂起函数" class="headerlink" title="3.2.1 挂起函数"></a>3.2.1 挂起函数</h3><p>整个 kotlin 语境下有 2种函数： 普通函数和挂起函数，<strong>其中：挂起函数能调用任何函数，但是普通函数不能调用挂起函数。</strong></p>
<p>所谓的协程挂起其实就是程序执行流程发生异步调用时，当前调用流程进入等待状态。注意：<strong>挂起函数不一定真的会挂起，只是提供了挂起的条件</strong>，那额什么情况才会真正挂起呢？</p>
<h3 id="3-2-2-挂起点"><a href="#3-2-2-挂起点" class="headerlink" title="3.2.2 挂起点"></a>3.2.2 挂起点</h3><p>回想下协程的创建过程，我们的协程体本身就是一个 Continuation 实例，正因如此，挂起函数才能在协程体内运行。<strong>在协程体内部，挂起函数的调用处称为挂起点，挂起点如果出现异步调用，当前协程就会被挂起，直到对应的 Continuation.resume 函数被调用才会恢复执行。</strong></p>
<p><strong>异步调用如何发生，取决于 resume 函数与对应的挂起函数的调用是否在相同的调用栈上</strong></p>
<h3 id="3-2-3-CPS-变换"><a href="#3-2-3-CPS-变换" class="headerlink" title="3.2.3 CPS 变换"></a>3.2.3 CPS 变换</h3><p>我们知道，挂起函数如果需要挂起，则需要通过 suspendCoroutine 来获取 Continuation 实例，我们已经知道它是协程体封装成的 Continuation，但是这个实例是怎么传入的呢？先看下面的suspend 函数：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">notSuspend</span><span class="params">()</span></span> = suspendCoroutine&lt;<span class="built_in">Int</span>&gt; { continuation -&gt;</span><br><span class="line">    continuation.resume(<span class="number">100</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看起来这个方法没有接收任何参数，kotlin 中看不出来我们就用 Java 直接调用它：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Object result = KotlinMainKt.notSuspend(<span class="keyword">new</span> Continuation&lt;Integer&gt;() {</span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CoroutineContext <span class="title">getContext</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resumeWith</span><span class="params">(<span class="meta">@NotNull</span> Object o)</span> </span>{</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们发现用Java 调用的时候，需要传入一个 Continuation<integer> ，也就是说kotlin 中的 suspend() -&gt; Int 类型 在Java 看来实际上是 Continuation<integer> -&gt; Object 类型 ！</integer></integer></p>
<p>这与我们平时写的异步回调相似，传入callback 等待结果回调。但是为什么会有返回值 Object？这里的 Object 会有 2 种情况：</p>
<ul>
<li><p>挂起函数同步返回时：作为参数传入的 Continuation 的 resumeWith 不会被调用，函数实际地返回值 Object 就是挂起函数的返回值</p>
</li>
<li><p>挂起函数挂起，执行异步逻辑。此时函数返回值 Object 是一个挂起标志，通过这个标志外部协程就可以知道该函数需要挂起等到异步逻辑执行。</p>
</li>
</ul>
<p>挂起标志是一个常量，定义在 Intrinsics.kt 当中：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> COROUTINE_SUSPENDED: Any <span class="keyword">get</span>() = CoroutineSingletons.COROUTINE_SUSPENDED</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineSingletons</span> </span>{ </span><br><span class="line">    COROUTINE_SUSPENDED, </span><br><span class="line">    UNDECIDED, </span><br><span class="line">    RESUMED </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在大家知道了原来挂起函数就是普通函数<strong>参数</strong>中多了一个 Continuation 实例，这也难怪<strong>普通函数不能调用挂起函数，但是挂起函数可以调用普通函数的原因</strong>。</p>
<p>还可以仔细想想，为什么Kotlin 语法要求挂起函数一定要运行在协程体内或者挂起函数中呢？答案是：协程体或者挂起函数中都隐含了 Continuation 实例 </p>
<h2 id="3-3-协程的上下文"><a href="#3-3-协程的上下文" class="headerlink" title="3.3 协程的上下文"></a>3.3 协程的上下文</h2><h3 id="3-3-1-协程上下文的集合特征"><a href="#3-3-1-协程上下文的集合特征" class="headerlink" title="3.3.1 协程上下文的集合特征"></a>3.3.1 协程上下文的集合特征</h3><p>协程的 Context 更像是个 List 结构，都有空的表示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list: List&lt;<span class="built_in">Int</span>&gt; = emptyList()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> context: CoroutineContext = EmptyCoroutineContext</span><br></pre></td></tr></tbody></table></figure>

<p>接下来，我们往里面添加数据(<strong>要记得将 list 和 context 设置为 var 而不是 val ，我就是因为设置 val 所以不能用  “+” 操作</strong>)：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list += <span class="number">0</span>   <span class="comment">//添加一个元素，得到一个新的list</span></span><br><span class="line">list += listOf&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">//将listOf中的元素都添加进去，生成一个新的 list</span></span><br><span class="line"></span><br><span class="line">context += EmptyCoroutineContext</span><br></pre></td></tr></tbody></table></figure>

<p>协程 Context 是一个集合，那么它的元素类型是什么呢？看下代码:</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineContext</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the element with the given [key] from this context or `null`.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An element of the [CoroutineContext]. An element of the coroutine context is a singleton context by itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> : <span class="type">CoroutineContext {</span></span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A key of this coroutine context element.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line">        <span class="comment">//省略其他代码</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>Element 是本身也实现了 CoroutineContext 接口，这看上去就好像  Int 实现了 List<int> 接口一样，这就很奇怪。其实这主要是为了 API 设计方便，Element 中是不会存放除了它自己以外的其他数据的（<strong>这句话其实不太明白，还需要后续的理解</strong>）</int></p>
<p>Element 中有个属性 key ，这个属性很关键，虽然我们往 list中添加元素时没有明确指出，但是我们都知道 list 中的元素都有一个 index 索引，而<strong>这里的协程上下文Element 的 key 就是这个集合中元素的索引，不同之处是这个索引“长”在数据里面，意味着上下文的数据在出生时就找到了自己的位置</strong>（这句话同样不太理解。。。）</p>
<blockquote>
<p>可能有人觉得协程 Context 和 Map 似乎更近，为什么这里要与 List 对比呢？一是 List 的 Key 类型是固定的 Int ，而 Map 的Key 有很多种类型；二是是协程上下文内部实现是一个单链表，这也反映出它与 List 之间的关系。</p>
</blockquote>
<h3 id="3-3-2-协程上下文元素的实现"><a href="#3-3-2-协程上下文元素的实现" class="headerlink" title="3.3.2 协程上下文元素的实现"></a>3.3.2 协程上下文元素的实现</h3><p>上一节知道协程 Conext 是个接口，实际上还有个抽象类 AbstractCoroutineContextElement，能让我们实现协程上下文更加方便：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCoroutineContextElement</span></span>(<span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> key: Key&lt;*&gt;) : Element</span><br></pre></td></tr></tbody></table></figure>

<p>创建元素并不难，<strong>只需要提供对应的 Key 即可，以下是协程名的实现（系统源码）：</strong></p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineName</span></span>(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * User-defined coroutine name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">) : AbstractCoroutineContextElement(CoroutineName) {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Key for [CoroutineName] instance in the coroutine context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineName&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以下是协程异常处理器的实现源码：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineExceptionHandler</span></span>(<span class="keyword">val</span> onErrorAction: (Throwable) -&gt; <span class="built_in">Unit</span>) : AbstractCoroutineContextElement(Key) {</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(error: <span class="type">Throwable</span>)</span></span> {</span><br><span class="line">        error.printStackTrace()</span><br><span class="line">        onErrorAction(error)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-3-3-协程上下文的使用"><a href="#3-3-3-协程上下文的使用" class="headerlink" title="3.3.3 协程上下文的使用"></a>3.3.3 协程上下文的使用</h3><p>前面说了，可以为协程上下文添加多个 Context，添加好之后，我们可以将 Context 绑定到协程上了：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> {</span><br><span class="line">    println(<span class="string">"我在协程里面"</span>)</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">}.createCoroutine(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt; {</span><br><span class="line">    <span class="keyword">var</span> tempContext: CoroutineContext = CoroutineName(<span class="string">"name-01"</span>) + </span><br><span class="line">            CoroutineExceptionHandler(){</span><br><span class="line">        println(<span class="string">"出错啦"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = tempContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>先自己构建出 tempContext 然后再将 tempContext 赋值给 context。绑定了协程的上下文，我们的协程就初步成型了！接下来演示如何使用这个CoroutineExceptionHandler:</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">    result.onFailure {</span><br><span class="line">        context[CoroutineExceptionHandler]?.onError(it)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>不管结果如何，这个 resumeWith 是一定会被调用的，如果有异常出现，我们就从协程上下文找到 CoroutineExceptionHandler 实例，调用它的 onError 方法即可</strong>，这个上下文在协程内部都是可以直接获取的，比如，在协程内部获取名字：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> {</span><br><span class="line">    println(<span class="string">"协程名字：<span class="subst">${coroutineContext[CoroutineName]?.name}</span>"</span>)</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">}.createCoroutine(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>这样，我们就知道了协程上下文的设置和获取方法了。</p>
<h2 id="3-4-协程的拦截器"><a href="#3-4-协程的拦截器" class="headerlink" title="3.4 协程的拦截器"></a>3.4 协程的拦截器</h2><p>之前的内容知道 Kotlin 协程<strong>通过调用挂起函数实现挂起，通过Continuation 的恢复调用来实现恢复</strong>，还可以通过 Context 的设置来丰富协程能力，那么，如果处理线程的调度？其实标准库还提供了拦截器（Interceptor）的组件，允许我们拦截协程异步回调时的恢复调用，那么线程调度应该也不是什么难事。</p>
<h3 id="3-4-2-拦截器的使用"><a href="#3-4-2-拦截器的使用" class="headerlink" title="3.4.2 拦截器的使用"></a>3.4.2 拦截器的使用</h3><p>拦截器 ContinuationInterceptor 继承了 CoroutineContext.Element ，而Element 又继承 CoroutineContext 类型，所以<strong>拦截器也是 上下文 的一种实现</strong>。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ContinuationInterceptor</span> : <span class="type">CoroutineContext.Element</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> : <span class="type">CoroutineContext</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>自己定义拦截器只需要实现拦截器接口 ContinuationInterceptor 即可，比如打印日志(<strong>注意：拦截器的 Key 是一个固定值: ContinuationInterceptor</strong>,协程执行时会拿到拦截器并拦截)：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span></span>() : ContinuationInterceptor{</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt; = ContinuationInterceptor</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; {</span><br><span class="line">        <span class="keyword">return</span> LogContinuation(continuation)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogContinuation</span>&lt;<span class="type">T</span>&gt; </span>(<span class="keyword">private</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; <span class="keyword">by</span> continuation {</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> {</span><br><span class="line">        println(<span class="string">"执行前"</span>)</span><br><span class="line">        continuation.resumeWith(result)</span><br><span class="line">        println(<span class="string">"执行后"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来使用的时候，我们就将拦截器作为context就好了，前面说了拦截器本来就是上下文：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">haha</span> <span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">val</span> continuation = <span class="keyword">suspend</span> {</span><br><span class="line">        println(<span class="string">"我在协程里面"</span>)</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    }.startCoroutine(<span class="keyword">object</span> : Continuation&lt;<span class="built_in">Int</span>&gt;{</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = LogInterceptor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">            <span class="comment">//。。。</span></span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="3-4-3-拦截器的执行细节"><a href="#3-4-3-拦截器的执行细节" class="headerlink" title="3.4.3 拦截器的执行细节"></a>3.4.3 拦截器的执行细节</h3><p>略</p>
<h2 id="3-5-Kotlin-协程所属类别"><a href="#3-5-Kotlin-协程所属类别" class="headerlink" title="3.5 Kotlin 协程所属类别"></a>3.5 Kotlin 协程所属类别</h2><p>略</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/26/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/26/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：协程基本概念</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-26 10:05:00" itemprop="dateCreated datePublished" datetime="2023-02-26T10:05:00+08:00">2023-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-27 21:05:41" itemprop="dateModified" datetime="2023-02-27T21:05:41+08:00">2023-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="2-2-协程的分类"><a href="#2-2-协程的分类" class="headerlink" title="2.2 协程的分类"></a>2.2 协程的分类</h2><p>可以按照按照调用栈（函数调用栈，用来保存函数调用时的状态信息的数据结构）来分，因为<strong>协程需要挂起和恢复</strong>，因此对于挂起点的状态保存就极其关键。</p>
<h3 id="2-2-1-按照调用栈分类"><a href="#2-2-1-按照调用栈分类" class="headerlink" title="2.2.1 按照调用栈分类"></a>2.2.1 按照调用栈分类</h3><p>根据是否开辟相应的调用栈来分的话可以分为 2 类：</p>
<ul>
<li><p>有栈协程，需要额外的栈空间，但是灵活，可以在任意函数调用层级的任意位置挂起</p>
</li>
<li><p>无栈协程， 节省内存，咱 Kotlin 协程一般认为就归为这一类，<strong>依靠对协程体本身编译生成的状态机的状态流转来实现控制流</strong></p>
</li>
</ul>
<blockquote>
<p>不过，Kotlin 协程可以在<strong>挂起函数范围</strong>内任意调用层次挂起，换句话说，我们启动一个 Kotlin 协程，可以在其中任意嵌套 suspend 函数 ！</p>
</blockquote>
<h3 id="2-2-2-按调度方式分类"><a href="#2-2-2-按调度方式分类" class="headerlink" title="2.2.2 按调度方式分类"></a>2.2.2 按调度方式分类</h3><ul>
<li><p>对称协程： 任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移</p>
</li>
<li><p>非对称协程：协程出让调度权的目标只能是它的调用者，即<strong>协程之间存在调用和非调用关系</strong></p>
</li>
</ul>
<blockquote>
<p>可以看出来，对称协程和线程已经非常接近了</p>
</blockquote>
<h2 id="2-3-协程的实现举例"><a href="#2-3-协程的实现举例" class="headerlink" title="2.3 协程的实现举例"></a>2.3 协程的实现举例</h2><p>列举了各种语言协程的实现，这里先略过。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/26/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC8%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/26/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC8%E7%AB%A0/" class="post-title-link" itemprop="url">第8章：JUC容器类</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-26 09:12:00" itemprop="dateCreated datePublished" datetime="2023-02-26T09:12:00+08:00">2023-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-21 22:34:05" itemprop="dateModified" datetime="2023-02-21T22:34:05+08:00">2023-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>高并发场景下常见的设计模式可能存在线程安全问题，比如传统的单例模式就是典型。本章介绍几种高并发场景下常用的几种模式：<strong>线程安全的单例模式、ForkJoin模式、生产者-消费者模式、Master-Worker模式和 Future模式。</strong></p>
<h2 id="8-1-线程安全的单例模式"><a href="#8-1-线程安全的单例模式" class="headerlink" title="8.1 线程安全的单例模式"></a>8.1 线程安全的单例模式</h2><p>没有volatile 情况下的双重检查实现的单例模式，可能会存在问题，可以看到下面这句代码：</p>
<blockquote>
<p>instance = new Singleton();</p>
</blockquote>
<p>转换成（具有原子性的）汇编指令大致会分为 3个：</p>
<ol>
<li><p>分派一块内存 M</p>
</li>
<li><p>在 M 上初始化 Singleton 对象</p>
</li>
<li><p>M 的地址赋值给 instance 变量</p>
</li>
</ol>
<p>但是，以前说过可能会进行重排序，上面 3 个指令优化之后可能会变为：</p>
<ol>
<li><p>分派一块内存 M</p>
</li>
<li><p>M 的地址赋值给 instance 变量</p>
</li>
<li><p>在 M 上初始化 Singleton 对象</p>
</li>
</ol>
<p>指令重排后，获取单例可能导致问题发生，假设 A 、B线程过来获取单例：</p>
<ol>
<li><p>A 通过 getInstance() 方法，执行到分配一块内存并将地址赋值给 instance，恰好发生了线程切换，<strong>此时，A 还没来得及对 M 指向的内存初始化</strong></p>
</li>
<li><p>线程 B 进入 getInstance() 方法，判断 instance 不为空，于是 B 直接获取到了未初始化的 instance</p>
</li>
<li><p>线程 B 使用未初始化完全的对象 instance 在访问 instance 的成员变量时可能会发生异常</p>
</li>
</ol>
<p>所以需要添加 volatile 防止指令重排。</p>
<h3 id="8-1-5-使用静态内部类实现懒汉式单例模式"><a href="#8-1-5-使用静态内部类实现懒汉式单例模式" class="headerlink" title="8.1.5 使用静态内部类实现懒汉式单例模式"></a>8.1.5 使用静态内部类实现懒汉式单例模式</h3><p>虽然通过 <strong>双重锁检查+volatile</strong>相结合的方式能实现高性能、线程安全的单例模式，但是该实现的底层原理比较复杂、实现繁琐，另一种易于理解、编程简单的单例模式实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取单例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这种方式只有在调用 getInstance() 的时候才会初始化单例，该方式既解决了线程安全问题，又解决了写法繁琐的问题。书中推荐使用这种方案。</p>
<h2 id="8-2-Master-worker-模式"><a href="#8-2-Master-worker-模式" class="headerlink" title="8.2 Master-worker 模式"></a>8.2 Master-worker 模式</h2><p>这是一种常见的高并发模式，它的核心思想是：任务的调度和执行分离，调度任务的角色是 Master，执行任务的角色是 Worker，Master 负责接收、分配和合并（Merge）任务结果，Worker 负责执行任务。</p>
<h3 id="8-2-1-Master-worker-模式的参考实现"><a href="#8-2-1-Master-worker-模式的参考实现" class="headerlink" title="8.2.1 Master-worker 模式的参考实现"></a>8.2.1 Master-worker 模式的参考实现</h3><h4 id="Master-的参考代码"><a href="#Master-的参考代码" class="headerlink" title="Master 的参考代码"></a>Master 的参考代码</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Task</span>, <span class="title">R</span>&gt; </span>{</span><br><span class="line">    <span class="comment">// 所有Worker的集合</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Worker&lt;T, R&gt;&gt; workers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务的集合</span></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;T&gt; taskQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务处理结果集合</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;String, R&gt; resultMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Master的任务调度线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保持最终的和</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong sum = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Master</span><span class="params">(<span class="keyword">int</span> workerCount)</span> </span>{</span><br><span class="line">        <span class="comment">// 每个Worker对象都需要持有queue的引用，用于领任务与提交结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workerCount; i++) {</span><br><span class="line">            Worker&lt;T, R&gt; worker = <span class="keyword">new</span> Worker&lt;&gt;();</span><br><span class="line">            workers.put(<span class="string">"子节点: "</span> + i, worker);</span><br><span class="line">        }</span><br><span class="line">        thread = <span class="keyword">new</span> Thread(() -&gt; <span class="keyword">this</span>.execute());</span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(T task)</span> </span>{</span><br><span class="line">        taskQueue.add(task);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取worker结果处理的回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resultCallBack</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        Task&lt;R&gt; task = (Task&lt;R&gt;) o;</span><br><span class="line">        String taskName = <span class="string">"Worker:"</span> + task.getWorkerId() + <span class="string">"-"</span> + <span class="string">"Task:"</span> + task.getId();</span><br><span class="line">        R result = task.getResult();</span><br><span class="line">        resultMap.put(taskName, result);</span><br><span class="line">        sum.getAndAdd((Integer) result); <span class="comment">//和的累加</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动所有的子任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; ; ) {</span><br><span class="line">            <span class="comment">// 从任务队列中获取任务，然后Worker节点轮询，轮流分</span></span><br><span class="line">            配任务</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Worker&lt;T, R&gt;&gt; entry :workers.entrySet()) {</span><br><span class="line">                T task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    task = <span class="keyword">this</span>.taskQueue.take();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取任务</span></span><br><span class="line">                    Worker worker = entry.getValue(); <span class="comment">//</span></span><br><span class="line">                    获取节点</span><br><span class="line">                    worker.submit(task, <span class="keyword">this</span>::resultCallBack); <span class="comment">//分配任务</span></span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最终的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printResult</span><span class="params">()</span> </span>{</span><br><span class="line">        Print.tco(<span class="string">"----------sum is :"</span> + sum.get());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, R&gt; entry : resultMap.entrySet()) {</span><br><span class="line">            String taskName = entry.getKey();</span><br><span class="line">            Print.fo(taskName + <span class="string">":"</span> + entry.getValue());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="Worker-的代码实现"><a href="#Worker-的代码实现" class="headerlink" title="Worker 的代码实现"></a>Worker 的代码实现</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Task</span>, <span class="title">R</span>&gt; </span>{</span><br><span class="line">    <span class="comment">//接收任务的阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;T&gt; taskQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">//Worker 的编号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger index = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerId;</span><br><span class="line">    <span class="comment">//执行任务的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.workerId = index.getAndIncrement();</span><br><span class="line">        thread = <span class="keyword">new</span> Thread(() -&gt; <span class="keyword">this</span>.run());</span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 轮询执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 轮询启动所有的子任务</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//从阻塞队列中提取任务</span></span><br><span class="line">                T task = <span class="keyword">this</span>.taskQueue.take();</span><br><span class="line">                task.setWorkerId(workerId);</span><br><span class="line">                task.execute();</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收任务到异步队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(T task, Consumer&lt;R&gt; action)</span> </span>{</span><br><span class="line">        task.resultAction = action; <span class="comment">//设置任务的回调方法</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">this</span>.taskQueue.put(task);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="8-3-FokJoin模式"><a href="#8-3-FokJoin模式" class="headerlink" title="8.3 FokJoin模式"></a>8.3 FokJoin模式</h2><p>目前没心思看，先略过</p>
<h2 id="8-4-生产者-消费者模式"><a href="#8-4-生产者-消费者模式" class="headerlink" title="8.4 生产者-消费者模式"></a>8.4 生产者-消费者模式</h2><p>略过</p>
<h2 id="8-5-Future模式"><a href="#8-5-Future模式" class="headerlink" title="8.5 Future模式"></a>8.5 Future模式</h2><p>略</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/25/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC7%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/25/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC7%E7%AB%A0/" class="post-title-link" itemprop="url">第7章：JUC容器类</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-25 21:21:00" itemprop="dateCreated datePublished" datetime="2023-02-25T21:21:00+08:00">2023-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-21 21:52:01" itemprop="dateModified" datetime="2023-02-21T21:52:01+08:00">2023-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>Java的基础容器主要有 List、Set、Queue、Map 四大类，但是大家熟知的 ArrayList、LinkedList 、HashMap 等都不是线程安全的。为了解决安全问题，Java用内置锁提供了一套线程安全的同步容器类，但是效率不高；因此，JUC提供了一套高并发容器。</p>
<h2 id="7-1-线程安全的同步容器类"><a href="#7-1-线程安全的同步容器类" class="headerlink" title="7.1 线程安全的同步容器类"></a>7.1 线程安全的同步容器类</h2><p>Java 同步容器类通过 synchronized 来实现同步的容器，比如 HashTable、Vector 以及 SynchronizedList 等容器，另外，Java 还提供了一组包装方法，将一个普通的基础容器包装成线程安全的同步容器，例如通过 Collections.synchronizedMap() 包装方法能将Map 包装成线程安全的 Map，看代码就能知道其原理：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.util.Collections</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K, V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedMap&lt;&gt;(m);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;,<span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;</span><br><span class="line">    <span class="keyword">final</span> Object mutext;</span><br><span class="line"></span><br><span class="line">    SynchronizedMap(Map&lt;K,V&gt; m) {</span><br><span class="line">        <span class="keyword">this</span>.m = Objects.requeireNonNull(m);</span><br><span class="line">        <span class="keyword">this</span>.mutext = <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span> <span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (mutext) {</span><br><span class="line">            <span class="keyword">return</span> m.size();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isEmpty</span> <span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (mutext) {</span><br><span class="line">            <span class="keyword">return</span> m.isEmpty();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ....省略其他方法</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过上述代码可以看出，Collections 提供的包装方法实现步骤：<strong>首先实现了容器的操作接口，在操作接口上使用 synchronized 进行线程同步，然后在 synchronized 临界区将实际的操作委托给被包装的基础容器。</strong></p>
<h3 id="7-1-1-同步容器面临的问题"><a href="#7-1-1-同步容器面临的问题" class="headerlink" title="7.1.1 同步容器面临的问题"></a>7.1.1 同步容器面临的问题</h3><p>由前面的描述可知：同步容器实现线程安全的方式是(包括HashTable之类的以及 Collections包装类之类的)*<em>在需要同步访问的方法上添加关键字 synchonized *</em>。所以效率并不高。</p>
<h2 id="7-2-JUC-高并发容器"><a href="#7-2-JUC-高并发容器" class="headerlink" title="7.2 JUC 高并发容器"></a>7.2 JUC 高并发容器</h2><p>为了解决同步容器的性能问题，有了 JUC 高并发容器。高并发容器是基于<strong>非阻塞算法(也说无锁编程算法)</strong>实现的容器类，<strong>主要通过 CAS(Compare And Swap) + volatile 组合实现，其中 CAS 保证原子性，volatile 保证可见性</strong>。其主要优点如下：</p>
<ul>
<li>开销小：无需在内核态和用户态来回切换</li>
<li>读写不互斥： 读读操作之间可以不互斥，只有写操作需要使用基于 CAS 机制的乐观锁</li>
</ul>
<h2 id="7-3-CopyOnWriteArrayList"><a href="#7-3-CopyOnWriteArrayList" class="headerlink" title="7.3 CopyOnWriteArrayList"></a>7.3 CopyOnWriteArrayList</h2><p>很多应用场景读操作可能会远远大于写操作，由于读操作不会修改原有数据，因此每次读取都要加锁其实是一种浪费。</p>
<h3 id="7-3-2-CopyOnWriteArrayList-原理"><a href="#7-3-2-CopyOnWriteArrayList-原理" class="headerlink" title="7.3.2 CopyOnWriteArrayList 原理"></a>7.3.2 CopyOnWriteArrayList 原理</h3><p>CopyOnWrite(写时复制)就是在修改器对一块内存进行修改时，不直接在原有内存块上进行写操作，而是将内存复制一份，在新的内存中进行写操作，写完之后，再将原来的指针(引用)指向新的内存，原来的内存GC 。CopyOnWriteArrayList 的核心成员如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>,<span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 对所有的修改器方法进行保护，访问器方法并不需要保护 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">     <span class="comment">/** 内部对象数组，通过 getArray/setArray 方法访问 */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *获取内部对象数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] getArray() {</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *设置内部对象数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>{</span><br><span class="line">      array = a;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-3-3-CopyOnWriteArrayList-的读取操作"><a href="#7-3-3-CopyOnWriteArrayList-的读取操作" class="headerlink" title="7.3.3 CopyOnWriteArrayList 的读取操作"></a>7.3.3 CopyOnWriteArrayList 的读取操作</h3><p>读取操作没有任何同步操作和锁控制，理由是内部数组array 不会发生修改，只会被另一个 array 替换，因此可以保证数据安全：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 操作内存的引用*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line"><span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回操作内存</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() {</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-3-4-CopyOnWriteArrayList-写入操作"><a href="#7-3-4-CopyOnWriteArrayList-写入操作" class="headerlink" title="7.3.4 CopyOnWriteArrayList 写入操作"></a>7.3.4 CopyOnWriteArrayList 写入操作</h3><p>写入操作 add() 方法在执行时加了独占锁以确保只能有一个线程进行写入操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); </span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>每次进行添加操作时，都会重新复制一份数组，再往新数组中添加元素，添加完了，再将array 引用指向新的数组。也就是<strong>当add() 操作完成后，array 的引用就已经指向新的存储空间了</strong>。</p>
<h3 id="7-3-5-CopyOnWriteArrayList-优缺点以及对比-自己加的章节"><a href="#7-3-5-CopyOnWriteArrayList-优缺点以及对比-自己加的章节" class="headerlink" title="7.3.5 CopyOnWriteArrayList 优缺点以及对比(自己加的章节)"></a>7.3.5 CopyOnWriteArrayList 优缺点以及对比(自己加的章节)</h3><h4 id="7-3-5-1-优缺点-自己加的章节"><a href="#7-3-5-1-优缺点-自己加的章节" class="headerlink" title="7.3.5.1 优缺点(自己加的章节)"></a>7.3.5.1 优缺点(自己加的章节)</h4><ul>
<li>优点：高并发操作下读取、遍历操作不需要同步，速度非常快，适用于“读多写少“的场景</li>
<li>缺点： 每次添加要复制一份，增加内存开销</li>
</ul>
<h4 id="7-3-5-2-比较-自己加的章节"><a href="#7-3-5-2-比较-自己加的章节" class="headerlink" title="7.3.5.2 比较(自己加的章节)"></a>7.3.5.2 比较(自己加的章节)</h4><p>CopyOnWriteArrayList 和 ReentrantReadWriteLock (读写锁) 的思想非常类似，ReentrantReadWriteLock 的泗县时：读读共享、写写互斥、读写互斥、写读互斥，而 CopyOnWriteArrayList 更进一步了：为了将读取的性能发挥到极致，读取时完全不加锁。</p>
<h2 id="7-4-BlockingQueue"><a href="#7-4-BlockingQueue" class="headerlink" title="7.4 BlockingQueue"></a>7.4 BlockingQueue</h2><p>在多线程环境中，通过 BlockingQueue (阻塞队列) 可以很容易实现多线程之间的数据共享和通信，比如在经典的“生产者-消费者“模型中，通过 BlockingQueue 可以完成一个高性能版本。</p>
<h3 id="7-4-3-常见的-BlockingQueue"><a href="#7-4-3-常见的-BlockingQueue" class="headerlink" title="7.4.3 常见的 BlockingQueue"></a>7.4.3 常见的 BlockingQueue</h3><p>BlockingQueue 的实现类大概有 ：ArrayBlockingQueue、DelayQueue、LinkedBlockingDeque、<br>PriorityBlockingQueue、SynchronousQueue等。</p>
<h4 id="7-4-3-1-ArrayBlockingQueue"><a href="#7-4-3-1-ArrayBlockingQueue" class="headerlink" title="7.4.3.1 ArrayBlockingQueue"></a>7.4.3.1 ArrayBlockingQueue</h4><p>ArrayBlockingQueue 内部<strong>采用定长数组来存储元素，添加和删除操作采用同一个锁对象，也就是说添加和删除无法并行运行(为什么不能并行呢？因为作者认为ArrayBlockingQueue的写入和获取操作已经足够轻量了)</strong>。</p>
<blockquote>
<p>为什么 ArrayBlockingQueue 比 LinkedBlockingQueue 更加常用？因为前者添加或者删除的时候不会产生或者销毁任何额外的 Node 实例，在高并发场景下，这可以减轻系统 GC 压力</p>
</blockquote>
<h4 id="7-4-3-2-LinkedBlockingQueue"><a href="#7-4-3-2-LinkedBlockingQueue" class="headerlink" title="7.4.3.2 LinkedBlockingQueue"></a>7.4.3.2 LinkedBlockingQueue</h4><p>LinkedBlockingQueue 是基于链表的阻塞队列，对于添加和删除元素分别才用了独立的锁控制，也就是在高并发场景下，消费者和生产者可以并行地操作队列中数据。</p>
<blockquote>
<p>需要注意的是，新建 LinkedBlockingQueue 时如果没有指定其容量大小，则默认大小近乎无限(Integer.MAX_VALUE)，这样的话，一旦生产速度大于消费速度，也许还没等到队列满阻塞产生，系统内存就消耗光了。</p>
</blockquote>
<h4 id="7-4-3-3-DelayQueue"><a href="#7-4-3-3-DelayQueue" class="headerlink" title="7.4.3.3 DelayQueue"></a>7.4.3.3 DelayQueue</h4><p>DelayQueue 只有当其指定的延迟时间到了才能够从队列中取该元素，<strong>它是一个没有大小限制的队列，因此添加(生产者)永远不会被阻塞，只有获取数据(消费者)才会被阻塞。</strong></p>
<blockquote>
<p>DelayQueue 的适用场景较少，常见的例子是用来管理一个超时未响应的连接队列</p>
</blockquote>
<h4 id="7-4-3-4-PriorityBlockingQueue"><a href="#7-4-3-4-PriorityBlockingQueue" class="headerlink" title="7.4.3.4 PriorityBlockingQueue"></a>7.4.3.4 PriorityBlockingQueue</h4><p>PriorityBlockingQueue 和 DelayQueue 类似，它也不会阻塞生产者，只会在没有可消费的数据时阻塞消费者。</p>
<h4 id="7-4-3-5-SynchronousQueue"><a href="#7-4-3-5-SynchronousQueue" class="headerlink" title="7.4.3.5 SynchronousQueue"></a>7.4.3.5 SynchronousQueue</h4><p>SynchronousQueue 是一种无缓冲的等待队列，不像 LinkedBlockingQueue 有中间缓冲区，所以吞吐率相对而言会低一些。不过对于单个任务来说，正因为没有缓冲区，所以响应会快一些。</p>
<p>LinkedBlockingQueue、DelayQueue 以及 PriorityBlockingQueue 都需要注意生产速度不能快于消费者，否则容易耗光内存。</p>
<h3 id="7-4-4-ArrayBlockingQueue-的基本使用"><a href="#7-4-4-ArrayBlockingQueue-的基本使用" class="headerlink" title="7.4.4 ArrayBlockingQueue 的基本使用"></a>7.4.4 ArrayBlockingQueue 的基本使用</h3><p>用 ArrayBlockingQueue 队列实现一个生产者-消费者的案例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 省略import</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueuePetStore</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AMOUNT = <span class="number">10</span>; <span class="comment">//数据区长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//共享数据区，类定义</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBuffer</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">        <span class="comment">//使用阻塞队列保存数据</span></span><br><span class="line">        <span class="keyword">private</span> ArrayBlockingQueue&lt;T&gt; dataList = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(MAX_AMOUNT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向数据区增加一个元素，委托给阻塞队列</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T element)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            dataList.add(element); <span class="comment">//直接委托</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 从数据区取出一个商品，委托给阻塞队列</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">return</span> dataList.take(); <span class="comment">//直接委托</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Print.cfo(<span class="string">"当前进程的ID是"</span> + JvmUtil.getProcessID());</span><br><span class="line">        System.setErr(System.out);</span><br><span class="line">        <span class="comment">//共享数据区，实例对象</span></span><br><span class="line">        DataBuffer&lt;IGoods&gt; dataBuffer = <span class="keyword">new</span> DataBuffer&lt;&gt;();</span><br><span class="line">        <span class="comment">//生产者执行的操作</span></span><br><span class="line">        Callable&lt;IGoods&gt; produceAction = () -&gt; {</span><br><span class="line">            <span class="comment">//首先生成一个随机的商品</span></span><br><span class="line">            IGoods goods = Goods.produceOne();</span><br><span class="line">            <span class="comment">//将商品加上共享数据区</span></span><br><span class="line">            dataBuffer.add(goods);</span><br><span class="line">            <span class="keyword">return</span> goods;</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//消费者执行的操作</span></span><br><span class="line">        Callable&lt;IGoods&gt; consumerAction = () -&gt; {</span><br><span class="line">        <span class="comment">// 从PetStore获取商品</span></span><br><span class="line">            IGoods goods = <span class="keyword">null</span>;</span><br><span class="line">            goods = dataBuffer.fetch();</span><br><span class="line">            <span class="keyword">return</span> goods;</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> THREAD_TOTAL = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 线程池，用于多线程模拟测试</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_TOTAL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假定共11个线程，其中有10个消费者，但是只有1个生产者</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> CONSUMER_TOTAL = <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PRODUCE_TOTAL = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PRODUCE_TOTAL; i++) {</span><br><span class="line">            <span class="comment">//生产者线程每生产一个商品，间隔50毫秒</span></span><br><span class="line">            threadPool.submit(<span class="keyword">new</span></span><br><span class="line">            Producer(produceAction, <span class="number">50</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONSUMER_TOTAL; i++){</span><br><span class="line">            <span class="comment">//消费者线程每消费一个商品，间隔100毫秒</span></span><br><span class="line">            threadPool.submit(<span class="keyword">new</span></span><br><span class="line">            Consumer(consumerAction, <span class="number">100</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-4-6-非阻塞式添加元素-add-、offer-方法的原理"><a href="#7-4-6-非阻塞式添加元素-add-、offer-方法的原理" class="headerlink" title="7.4.6 非阻塞式添加元素 add()、offer() 方法的原理"></a>7.4.6 非阻塞式添加元素 add()、offer() 方法的原理</h3><p>首先来看非阻塞式添加元素，<strong>在队列满而不能添加元素时，非阻塞式添加元素的方法会立即返回，所以线程不会被阻塞。</strong>add() 方法的实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出直接调用了 offer 方法，如果 offer 方法添加失败，直接抛出异常，否则返回true。</p>
<p>offer() 方法的实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//offer()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    checkNotNull(e); <span class="comment">//检查元素是否为null</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)<span class="comment">//判断数组是否已满</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            enqueue(e);<span class="comment">//添加元素到队列</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，offer() 方法的操作如下：</p>
<ol>
<li>如果数组满了，就直接释放锁，返回false</li>
<li>数组没满，将元素加入队(通过enqueue()方法)然后返回true</li>
</ol>
<h3 id="7-4-7-阻塞式添加元素：put-方法的原理"><a href="#7-4-7-阻塞式添加元素：put-方法的原理" class="headerlink" title="7.4.7 阻塞式添加元素：put() 方法的原理"></a>7.4.7 阻塞式添加元素：put() 方法的原理</h3><p>put() 方法是一个阻塞方法，如果队列元素已满，那么当前线程会被加入 notFull 条件等待队列中，直到有空位置才会被唤醒执行添加操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put()方法，阻塞时可中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();<span class="comment">//该方法可中断</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//当队列元素个数与数组长度相等时，无法添加元素</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">        <span class="comment">//将当前调用线程挂起，添加到notFull条件队列中，等待被唤醒</span></span><br><span class="line">        notFull.await();</span><br><span class="line">        enqueue(e);<span class="comment">//如果队列没有满，就直接添加</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结一下put()流程:</p>
<ol>
<li>获取 putLock 锁</li>
<li>如果队列满了，就被阻塞，put线程进入 notFull 等待队列，等着被唤醒</li>
<li>如果队列未满，通过 enqueue 方法入队</li>
<li>释放 putLock 锁</li>
</ol>
<h3 id="7-4-8-非阻塞式删除元素：-poll-方法"><a href="#7-4-8-非阻塞式删除元素：-poll-方法" class="headerlink" title="7.4.8 非阻塞式删除元素： poll() 方法"></a>7.4.8 非阻塞式删除元素： poll() 方法</h3><p>当队列空而不能删除元素时，非阻塞删除元素的方法会立即返回，执行线程不会被阻塞。poll() 方法实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//判断队列是否为null，不为null执行dequeue()方法，否则返回null</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>里面使用了 dequeue() 方法出队：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除队列头元素并返回</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//拿到当前数组的数据</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">    <span class="comment">//获取要删除的对象</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    <span class="comment">//清空位置：将数组中的takeIndex索引位置设置为null</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//takeIndex索引加1并判断是否与数组长度相等</span></span><br><span class="line">    <span class="comment">//如果相等就说明已到尽头，恢复为0</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;<span class="comment">//元素个数减1</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();<span class="comment">//同时更新迭代器中的元素数据</span></span><br><span class="line">    <span class="comment">//删除了元素说明队列有空位，唤醒notFull条件等待队列中的put线程，执行添加操作</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>主要注意后面的通过 notFull.signal() 唤醒条件等待队列中的一个 put 线程。阻塞式的 take() 方法略。</p>
<h2 id="7-5-ConcurrentHashMap"><a href="#7-5-ConcurrentHashMap" class="headerlink" title="7.5 ConcurrentHashMap"></a>7.5 ConcurrentHashMap</h2><p>在 Java 7 之前版本 ConcurrentHashMap 采用分段锁实现，数据分为一段一段的，每段分配一把锁，当一个线程访问其中一段数据的时候，其他段的数据能被正常访问，实现了真正的并发访问；Java8对内部存储结构进行了优化，性能进一步提升。</p>
<h3 id="7-5-1-HashMap-和-HashTable-的问题"><a href="#7-5-1-HashMap-和-HashTable-的问题" class="headerlink" title="7.5.1 HashMap 和 HashTable 的问题"></a>7.5.1 HashMap 和 HashTable 的问题</h3><p>HashMap 不是线程安全的，<strong>多线程环境下，HashMap 的 put() 操作可能会引起死循环，导致CPU使用率接近100%。</strong>于是JDK提供了线程安全的Map-HashTable，它使用几乎与 HashMap 几乎一样区别有2点：</p>
<ul>
<li>HashTable 不允许key 和value 为null</li>
<li>HashTable 的包括 get/set 在内的方法都是用 synchronized 来保证线程安全，对整个 Hash 表锁定，但是代价会非常大的</li>
</ul>
<h3 id="7-5-2-Java-1-7-及以前版本的-ConcurrentHashMap"><a href="#7-5-2-Java-1-7-及以前版本的-ConcurrentHashMap" class="headerlink" title="7.5.2 Java 1.7 及以前版本的 ConcurrentHashMap"></a>7.5.2 Java 1.7 及以前版本的 ConcurrentHashMap</h3><p>分段锁是一种锁设计，并不是具体的锁。对于 ConcurrentHashMap 而言，分段锁技术将 key 分成一个个小 segment 存储，给每段数据一把锁，当一个线程占用锁访问其中一段数据时，其他段数据也能被其他线程访问，实现真正的并发。</p>
<p>这个原理已经比较了解了，这里就不按照书本的章节走，略过了</p>
<h3 id="7-5-4-JDK-1-8版本-ConcurrentHashMap-的结构"><a href="#7-5-4-JDK-1-8版本-ConcurrentHashMap-的结构" class="headerlink" title="7.5.4 JDK 1.8版本 ConcurrentHashMap 的结构"></a>7.5.4 JDK 1.8版本 ConcurrentHashMap 的结构</h3><p>1.7 版本虽然<strong>通过 segment 方式实现了并发热点分离</strong>，默认情况下将一个table 分裂成 16 个小的 table(Segment表示)，从而在 Segment 维度实现并发。但是这样并发粒度还不够细。1.8 版本抛弃了 Segment 分段锁机制，存储结构采用数组+链表或者红黑树的组合方式，<strong>将并发粒度细化到每一个桶，进一步细化了热点</strong>，利用 CAS + Synchronized 来保证并发更新安全。</p>
<blockquote>
<p>JDK 1.7 的 ConcurrentHashMap 每个桶为链表结构，1.8 引入了红黑树结构，当桶的节点超过阈值(默认64)时，自动将链表结构转换为红黑树，<strong>可以理解为将链式桶转为树状桶</strong>。这样的好处在于，访问的时候只需要对一个桶锁定，而不需要将整个 Map 集合都进行粗粒度锁定。事实上，引入红黑树的一个原因是：链表查询复杂度 O(n) ，红黑树查询复杂度 O(log(n))</p>
</blockquote>
<p><img src="/assets/Book-Notes/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%8D%B72/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%8D%B72-%E7%AC%AC7%E7%AB%A0-%E4%B8%80%E4%B8%AA1.8%E7%89%88%E6%9C%AC%E7%9A%84ConcurrentHashMap%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.jpg" alt="一个1.8版本的ConcurrentHashMap实例内部结构"></p>
<h3 id="7-5-5-ConcurrentHashMap的核心原理-1-8-版本"><a href="#7-5-5-ConcurrentHashMap的核心原理-1-8-版本" class="headerlink" title="7.5.5 ConcurrentHashMap的核心原理-1.8 版本"></a>7.5.5 ConcurrentHashMap的核心原理-1.8 版本</h3><p>JDK 1.8版本的ConcurrentHashMap中通过一个 Node&lt;K,V&gt;[] 数组table 来保存添加到哈希表中的桶，在同一个 Bucket 位置是通过链表和 红黑树的形式来保存的，<strong>但是 table 是懒加载的，只有在第一次添加元素的时候才会初始化</strong>。它的主要成员属性大致如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class"><span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"> <span class="comment">//常量：表示正在转移</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED = -<span class="number">1</span>;</span><br><span class="line"> <span class="comment">// 常量：表示已经转换成树</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN = -<span class="number">2</span>; </span><br><span class="line"> <span class="comment">// 常量：hash for transient reservations</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED = -<span class="number">3</span>; </span><br><span class="line"> <span class="comment">// 常量：usable bits of normal node hash</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; </span><br><span class="line"> <span class="comment">//数组，用来保存元素</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"> <span class="comment">//转移时用的数组</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来控制表初始化和扩容的控制属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 省略其他</span></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<p>重要属性介绍如下：</p>
<ul>
<li>table用于保存添加到哈希表中的桶</li>
<li>DEFAULT_CAPACITY： table的默认长度。默认初期长度为16，在第一次添加元素时，会将table初始化成16个元素的数组</li>
<li>sizeCtl：sizeCtl用来控制table的初始化和扩容操作的过程</li>
</ul>
<p>涉及修改 sizeCtl 的方法有 5 个：</p>
<ul>
<li>initTable()：初始化哈希表时，涉及sizeCtl的修改</li>
<li>addCount()：增加容量时，涉及sizeCtl的修改</li>
<li>tryPresize()：ConcurrentHashMap扩容方法之一</li>
<li>transfer()：table数据转移到 nextTable，扩容操作的核心在于数据的转移，把旧数组中的数据前一到新的数组。ConcurrentHashMap可以利用多线程来协同扩容，简单说是把 table 数组当做多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程锁负责的取件，一个已经迁移完的 Bucket 会被替换为一个 ForwardingNode 节点，标记当前 Bucket 已经被其他线程迁移完成。</li>
<li>helpTransfer()：并发添加元素时，如果正在扩容，其他线程会帮助扩容，也就是多线程扩容。</li>
</ul>
<h3 id="7-5-6-JDK-1-8-版本-ConcurrentHashMap的核心源码"><a href="#7-5-6-JDK-1-8-版本-ConcurrentHashMap的核心源码" class="headerlink" title="7.5.6 JDK 1.8 版本 ConcurrentHashMap的核心源码"></a>7.5.6 JDK 1.8 版本 ConcurrentHashMap的核心源码</h3><p>下面来看JDK 1.8版本ConcurrentHashMap的put()操作:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自旋：并发情况下，也可以保障安全添加成功</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K, V&gt;[] tab = table; ; ) {</span><br><span class="line">        Node&lt;K, V&gt; f;</span><br><span class="line">        <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">//第一次添加，先初始化node数组</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//计算出table[i]无节点，创建节点</span></span><br><span class="line">            <span class="comment">//使用Unsafe.compareAndSwapObject 原子操作table[i]位置</span></span><br><span class="line">            <span class="comment">//如果为null，就添加新建的node节点，跳出循环</span></span><br><span class="line">            <span class="comment">//反之，再循环进入执行添加操作</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key, value, <span class="keyword">null</span>))) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) {</span><br><span class="line">            <span class="comment">//如果当前处于转移状态，返回新的tab内部表，然后进入循环执行添加操作</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//在链表或红黑树中追加节点</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//使用synchronized 对 f 对象加锁</span></span><br><span class="line">            <span class="comment">// f = tabAt(tab, i = (n - 1) &amp; hash) ： table[i] 的node对象(桶)</span></span><br><span class="line">            <span class="comment">//注意：这里没用ReentrantLock，而是使用 synchronized 进行同步</span></span><br><span class="line">            <span class="comment">//在争用不激烈的场景中，synchronized 的性能和 ReentrantLock不相上下</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) {</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) {</span><br><span class="line">                    <span class="comment">//在链表上追加节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) {</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; e = f; ; ++binCount) {</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) {</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent) {</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                }</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                            Node&lt;K, V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) {</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//在红黑树上追加节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) {</span><br><span class="line">                        Node&lt;K, V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K, V&gt;) f).putTreeVal(hash, key, value)) != <span class="keyword">null</span>) {</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) p.val = value;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">//节点数大于临界值，转换成红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD) {</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从源码可以看出，使用 CAS 自旋完成桶的设置时，使用 synchronized 内置锁保证桶内并发操作的线程安全。尽管对同一个 Map 操作的线程争夺会非常激烈，但是在同一个桶内的线程争夺通常不会很激烈，所以使用 CAS 自旋、synchronized 的偏向锁或轻量级锁 不会降低 ConcurrentHashMap 的性能。为什么不用显式锁 ReentrantLock 呢？因为如果为每个桶都创建一个 ReentrantLock 实例，就会带来大量的内存消耗，而前面那些方法带来的内存消耗微乎其微。</p>
<p>get方法也没有加锁操作，与 JDK1.7差不多，就不赘述了。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/25/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC1%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/25/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC1%E7%AB%A0/" class="post-title-link" itemprop="url">第1章：异步程序设计介绍</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-25 15:46:00" itemprop="dateCreated datePublished" datetime="2023-02-25T15:46:00+08:00">2023-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-27 21:03:50" itemprop="dateModified" datetime="2023-02-27T21:03:50+08:00">2023-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1-2-异步程序设计的关键问题"><a href="#1-2-异步程序设计的关键问题" class="headerlink" title="1.2 异步程序设计的关键问题"></a>1.2 异步程序设计的关键问题</h2><h3 id="1-2-1-结果传递"><a href="#1-2-1-结果传递" class="headerlink" title="1.2.1 结果传递"></a>1.2.1 结果传递</h3><p>不同于同步调用，异步调用是立即返回的，因此被调用方的逻辑通常存在2种情形：</p>
<ul>
<li><p>结果尚未就绪：进入任务执行的状态，等结果就绪后通过回调传递给调用方</p>
</li>
<li><p>结果已经就绪，可以立即提供结果</p>
</li>
</ul>
<p>用图片获取作为例子，上述2种情况代码示意如下所示（<strong>这是我个人觉得理解Kotlin协程实现最巧妙的例子了，其实后面的本质就是这个</strong>）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法实现</span></span><br><span class="line"><span class="function">fun <span class="title">asyncBitmap</span><span class="params">(url: String, callback: (Bitmap)</span> -&gt; Unit): Bitmap </span>{</span><br><span class="line">          val bitmap = asyncBitmap(url) {</span><br><span class="line">        show(it) <span class="comment">//...② 异步请求</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) {</span><br><span class="line">        show(bitmap) <span class="comment">//... ① 直接返回了</span></span><br><span class="line">    }  <span class="keyword">return</span> when (val bitmap = Cache.get(url)) {</span><br><span class="line">        <span class="keyword">null</span> -&gt; {</span><br><span class="line">            thread {</span><br><span class="line">                download(url)</span><br><span class="line">                    .also { Cache.put(url, it) }</span><br><span class="line">                    .also(callback)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> -&gt; bitmap</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法，如果有同步返回，就使用同步返回，否则依赖异步回调</span></span><br><span class="line"><span class="meta">@JvmStatic</span></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>{</span><br><span class="line">    val bitmap = asyncBitmap(url) {</span><br><span class="line">        show(it) <span class="comment">//...② 异步请求</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) {</span><br><span class="line">        show(bitmap) <span class="comment">//... ① 直接返回了</span></span><br><span class="line">    }</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>Kotlin 协程的挂起函数 (suspend function) 本质上就是采取了这个异步返回值的设计思路</p>
</blockquote>
<h3 id="1-2-2-异常处理"><a href="#1-2-2-异常处理" class="headerlink" title="1.2.2 异常处理"></a>1.2.2 异常处理</h3><p>我们希望异步的任务在 suspend 的时候执行，执行完成后 resume 回来，之后再同步判断是否发生了异常。这样逻辑就会简单很多。<strong>异步逻辑同步化也是 Kotlin 协程要解决的问题。</strong></p>
<h3 id="1-2-4-复杂分支"><a href="#1-2-4-复杂分支" class="headerlink" title="1.2.4 复杂分支"></a>1.2.4 复杂分支</h3><p>为同步操作添加分支甚至循环操作是很容易的，比如获取图片是同步的情况下，获取多个图片：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val bitmap = urls.map { syncBitmap(it) }</span><br></pre></td></tr></tbody></table></figure>

<p>在上述情况下我们甚至还能方便地通过一个 try-catch 捕捉所有异常。而当获取图片的操作是异步的情况时，就变得复杂，还需要用到一些同步工具来辅助：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">val countDownLatch = CountDownLatch(urls.size)</span><br><span class="line"></span><br><span class="line">val map = urls.map { it to EMPTY_BITMAP }</span><br><span class="line">    .toMap(ConcurrentHashMap&lt;String, Bitmap&gt;())</span><br><span class="line"></span><br><span class="line">urls.map { url -&gt;</span><br><span class="line">    asyncBitmap(url, onSuccess = {</span><br><span class="line">        map[url] = it</span><br><span class="line">        countDownLatch.countDown() <span class="comment">//...②</span></span><br><span class="line">    }, onError = {</span><br><span class="line">        showError(it)</span><br><span class="line">        countDownLatch.countDown()<span class="comment">//...③</span></span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">countDownLatch.await() <span class="comment">//...①</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有的图片 bitmap</span></span><br><span class="line">val bitmaps = map.values</span><br></pre></td></tr></tbody></table></figure>

<p>这里还需要借助 <strong>CountDownLatch 门闩</strong> 来实现，因此在 ① 处会阻塞当前线程，直到所有回调的 ② 或 ③ 位置执行之后，才会执行获取所有图片的操作：val bitmaps = map.values ，总之，这个过程还是挺复杂的。</p>
<blockquote>
<p>EMPTY_BITMAP 是一个空的 Bitmap 对象，为什么要这么做呢？<strong>因为 ConcurrentHashMap 不允许 value 为空！</strong></p>
</blockquote>
<h2 id="1-3-常见异步程序设计思路"><a href="#1-3-常见异步程序设计思路" class="headerlink" title="1.3 常见异步程序设计思路"></a>1.3 常见异步程序设计思路</h2><h3 id="1-3-1-Future"><a href="#1-3-1-Future" class="headerlink" title="1.3.1 Future"></a>1.3.1 Future</h3><p>但是 Future.get() 方法会造成当前调用阻塞。</p>
<h3 id="1-3-2-CompletableFuture"><a href="#1-3-2-CompletableFuture" class="headerlink" title="1.3.2 CompletableFuture"></a>1.3.2 CompletableFuture</h3><p>它的 get() 方法无需阻塞，异步调用不阻塞主流程调用但是结果脱离了主调用流程（需要回调获取）</p>
<h3 id="1-3-3-JavaScript-的-Promise——async-await"><a href="#1-3-3-JavaScript-的-Promise——async-await" class="headerlink" title="1.3.3 JavaScript 的 Promise——async/await"></a>1.3.3 JavaScript 的 Promise——async/await</h3><p>比较完好地实现了需求，他们 async/await 的语义稍微不同。</p>
<h3 id="1-3-5-Kotlin协程"><a href="#1-3-5-Kotlin协程" class="headerlink" title="1.3.5 Kotlin协程"></a>1.3.5 Kotlin协程</h3><p>Kotlin 协程是为异步程序设计而生的。</p>
<blockquote>
<p>有人称协程只是“一个线程框架”，认为协程就是用来切换线程的，显然有点“一叶障目不见泰山”了</p>
</blockquote>
<p>Kotlin 协程用一个 suspend 关键字，包含了<strong>异步调用</strong> 和 <strong>回调</strong> 两层含义。我们知道，所有异步回调对于当前调用流程只是一个<strong>挂起点</strong>。在这个挂起点可以做的事情非常多：既可以做异步回调，还可以添加调度器来处理线程切换，还可以作为协程取消响应的位置。</p>
<p>看一个 Kotlin 处理异步调用的例子：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">suspend fun <span class="title">bitmapSuspendable</span><span class="params">(url: String)</span>: Bitmap </span>=</span><br><span class="line">    suspendCoroutine&lt;Bitmap&gt; { continuation -&gt;</span><br><span class="line">        thread {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                continuation.resume(download(url))</span><br><span class="line">            } <span class="keyword">catch</span> (e: Exception) {</span><br><span class="line">                continuation.resumeWithException(e)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>suspend 修饰函数，意味着支持同步化的异步调用。上述代码中，</p>
<ul>
<li><p>continuation.resume(download(url)) 将正常的结果返回</p>
</li>
<li><p>continuation.resumeWithException(e) 则是将异常返回，在调用 bitmapSuspendable() 方法时，如果产生异常会把这个异常抛出</p>
</li>
</ul>
<p>效果如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">suspend fun <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        val bitmap = bitmapSuspendable(<span class="string">"xxxx"</span>)</span><br><span class="line">        <span class="comment">//todo 正常图片处理</span></span><br><span class="line">    } <span class="keyword">catch</span> (e: Exception) {</span><br><span class="line">        <span class="comment">//todo 异常处理</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>从 1.3.0 开始，开始支持 suspend fun main 作为函数入口了</p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/22/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC6%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/22/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC6%E7%AB%A0/" class="post-title-link" itemprop="url">第6章：AQS 抽象同步器的核心原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-22 22:24:00 / 修改时间：22:30:29" itemprop="dateCreated datePublished" datetime="2023-02-22T22:24:00+08:00">2023-02-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>前面介绍在激烈争用的情况下，CAS 自旋实现的轻量级锁会有<strong>两大问题：</strong></p>
<ul>
<li>CAS 恶性空自旋会浪费大量 CPU 资源</li>
<li>某些架构 CPU 上可能会导致 “总线风暴“</li>
</ul>
<p>解决这些问题的常见方案有 2 种： </p>
<ul>
<li>分散操作热点</li>
<li>使用队列削峰</li>
</ul>
<p>JUC 使用队列削峰方案解决 CAS 性能问题，提供了一个<strong>基于双向队列的削峰基类——抽象基础类 AbstractQueuedSynchronizer（抽象同步器类，简称 AQS）</strong> 。JUC 中许多类都是基于AQS构建：例如ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock、FutureTask等。</p>
<h2 id="6-1-锁与队列的关系"><a href="#6-1-锁与队列的关系" class="headerlink" title="6.1 锁与队列的关系"></a>6.1 锁与队列的关系</h2><p>第5章介绍了 CLH ，它用了FIFO的单项队列；AQS 是 CLH 的一个变种，主要原理差不多，用的是 FIFO 的双向链表，<strong>这样做的好处就是可以从任意一个节点开始很方便地访问前驱和后继节点</strong>。</p>
<h2 id="6-2-AQS-的核心成员"><a href="#6-2-AQS-的核心成员" class="headerlink" title="6.2 AQS 的核心成员"></a>6.2 AQS 的核心成员</h2><h3 id="6-2-1-状态标志位"><a href="#6-2-1-状态标志位" class="headerlink" title="6.2.1 状态标志位"></a>6.2.1 状态标志位</h3><p>AQS 中维持了一个单一的 volatile 修饰 int 类型的状态信息 state ，它标记了锁的状态，默认初始状态 0 为未锁定状态。同时，提供了 <strong>compareAndSetState</strong> 原子设置方法来设置 state 的值。</p>
<p>当线程 A 通过 tryAcquire() 获取到独占锁并将 state 加一后，其他线程通过 tryAcquire 获取锁就会失败(执行compareAndSet(0,1)会失败)，直到 A 释放了锁为止，其他线程才能获取锁。</p>
<p>AQS 继承了 AbstractOwnableSynchronizer ，父类中有个当前占用该锁的线程的变量  exclusiveOwnerThread：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示当前占用该锁的线程</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-2-2-队列节点类-Node"><a href="#6-2-2-队列节点类-Node" class="headerlink" title="6.2.2 队列节点类 Node"></a>6.2.2 队列节点类 Node</h3><p>AQS 是一个虚拟队列，不存在队列实例，仅存在节点之间的前后关系，Node 的主要成员如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点状态：值为SIGNAL、CANCELLED、CONDITION、PROPAGATE、0 </span></span><br><span class="line">    <span class="comment">//普通的同步节点的初始值为0，条件等待节点的初始值为CONDITION（-2）</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点所对应的线程，为抢锁线程或者条件等待线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前驱节点，当前节点会在前驱节点上自旋，循环检查前驱节点的waitStatus状态</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若当前Node不是普通节点而是条件等待节点，则节点处于某个条件的等待队列上</span></span><br><span class="line">    <span class="comment">//此属性指向下一个条件等待节点，即其条件队列上的后继节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>解释一下 waitStatus 变量中的几个值：</p>
<ul>
<li>CONDITION ：waitStatus 取这个值时，表示该线程（调用了Condition 的 awati 方法后）在条件队列中阻塞(Condition 有使用)，当持有锁的线程调用了 Condition 的 signal() 方法后，节点会从该 Condition 的等待队列转移到该锁的同步队（也就是AQS的FIFO双向队列）列中去竞争锁。</li>
<li>PROPAGATE：waitStatus 取这个值时，表示下一个线程获取共享锁后，自己的共享状态会被无条件传播下去，因为共享锁可能出现有N个锁可用，这时直接让后面 N 个节点都来工作。这种状态在 CountDownLatch 中用到了</li>
</ul>
<h3 id="6-3-1-模板模式"><a href="#6-3-1-模板模式" class="headerlink" title="6.3.1 模板模式"></a>6.3.1 模板模式</h3><p>这种模式值得看下，AQS 也使用这种模式</p>
<h2 id="6-4-通过-AQS-实现一把简单的独占锁"><a href="#6-4-通过-AQS-实现一把简单的独占锁" class="headerlink" title="6.4 通过 AQS 实现一把简单的独占锁"></a>6.4 通过 AQS 实现一把简单的独占锁</h2><p>基于 AQS 实现一个简单的<strong>非公平的独占锁</strong> SimpleMockLock：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMockLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>{</span><br><span class="line">    <span class="comment">//同步器实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的内部类：同步器</span></span><br><span class="line">    <span class="comment">// 直接使用 AbstractQueuedSynchronizer.state 值表示锁的状态</span></span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.state=1 表示锁没有被占用</span></span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.state=0 表示锁没已经被占用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>{</span><br><span class="line">        <span class="comment">//钩子方法</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">            <span class="comment">//CAS更新状态值为1</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//钩子方法</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">            <span class="comment">//如果当前线程不是占用锁的线程</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) {</span><br><span class="line">                <span class="comment">//抛出非法状态的异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果锁的状态为没有占用</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">//抛出非法状态的异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//接下来不需要使用CAS操作，因为下面的操作不存在并发场景</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//设置状态</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式锁的抢占方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="comment">//委托给同步器的acquire()抢占方法</span></span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式锁的释放方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="comment">//委托给同步器的release()释放方法</span></span><br><span class="line">            sync.release(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 省略其他未实现的方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="6-5-AQS-锁抢占的原理"><a href="#6-5-AQS-锁抢占的原理" class="headerlink" title="6.5 AQS 锁抢占的原理"></a>6.5 AQS 锁抢占的原理</h2><p>文中前面讲了一大堆，实在没法梳理各个章节的联系，云里雾里的，直到用 ReentrantLock 来讲这个过程，就清晰了，所以前面一些内容略过。</p>
<p>直接以 ReentrantLock 抢锁来说明整个抢锁流程，ReentrantLock 有2种模式：公平锁 和 非公平锁。</p>
<h3 id="6-8-1-ReentrantLock-非公平锁的抢占流程"><a href="#6-8-1-ReentrantLock-非公平锁的抢占流程" class="headerlink" title="6.8.1 ReentrantLock 非公平锁的抢占流程"></a>6.8.1 ReentrantLock 非公平锁的抢占流程</h3><p>ReentrantLock 为非公平所实现了一个内部的同步器——NonfairSync ，其显式锁获取方法 lock() 源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平抢占</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>非公平性就体现在这里：<strong>如果占用锁的线程刚释放锁，state 为 0，而队列中排队等待锁的线程还未唤醒，新来的线程就直接抢占了该锁，那么就插队了</strong>。举个例子：假设 A、B 线程在排队等锁，但是此时不在队列中的 C 直接进行 CAS 操作成功了，拿到锁开开心心返回了，那么 A、 B 只能乖乖看着。</p>
<h3 id="6-8-4-ReentrantLock-公平锁的抢占流程"><a href="#6-8-4-ReentrantLock-公平锁的抢占流程" class="headerlink" title="6.8.4 ReentrantLock 公平锁的抢占流程"></a>6.8.4 ReentrantLock 公平锁的抢占流程</h3><p>ReentrantLock 为公平所实现了一个内部的同步器——FairSync ，其显式锁获取方法 lock() 源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其核心思想是通过 AQS 模板方法 acquire 进行队列入队操作。</p>
<h3 id="6-8-5-AQS模板方法-acquire-arg"><a href="#6-8-5-AQS模板方法-acquire-arg" class="headerlink" title="6.8.5 AQS模板方法 acquire(arg)"></a>6.8.5 AQS模板方法 acquire(arg)</h3><p>自己调整的章节，本来这节在前面，但是放前面又看不懂，用意也不太明确。</p>
<p>acquire(arg) 方法是 AQS 提供的<strong>利用独占的方式获取资源的方法</strong>，源码实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>它的含义是：<strong>如果通过 tryAcquire(arg)方法尝试成功，则直接返回，表示已经抢到锁；否则，将线程加入等待队列。</strong></p>
<h3 id="6-8-6-AQS模板方法-tryAcquire-arg"><a href="#6-8-6-AQS模板方法-tryAcquire-arg" class="headerlink" title="6.8.6 AQS模板方法 tryAcquire(arg)"></a>6.8.6 AQS模板方法 tryAcquire(arg)</h3><p>在 ReentrantLock 中，在公平锁状态和非公平锁状态下， tryAcquire 的实现是不一样的。</p>
<ul>
<li>公平锁状态下会判断是否是队头，是队头就允许CAS获取锁；如果不是就判断是否是重入，重入允许进入；否则就返回了false了（自己看代码总结的）；</li>
<li>非公平状态下还是会直接 CAS 抢锁了，不管队头这些了，这也是非公平锁的行为体现</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/18/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/18/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">第5章：JUC显式锁的原理与实战</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-18 15:54:00" itemprop="dateCreated datePublished" datetime="2023-02-18T15:54:00+08:00">2023-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-22 22:36:01" itemprop="dateModified" datetime="2023-02-22T22:36:01+08:00">2023-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="5-1-显式锁"><a href="#5-1-显式锁" class="headerlink" title="5.1 显式锁"></a>5.1 显式锁</h2><p>使用 Java内置锁 时，无需通过 Java 代码显式地对同步对象的监视器进行抢占和释放，使用起来非常方便。但是不具备一些比较高级的锁功能：</p>
<ul>
<li><p>限时抢锁：设置超时时长，不至于无限等下去</p>
</li>
<li><p>可中断抢锁：抢锁时，外部线程给抢锁线程发一个中断信号，就能唤起等待锁的线程，并终止抢占过程</p>
</li>
<li><p>多个等待队列：为锁维持多个等待队列，以提高锁的效率。比如生产者-消费者模式中，生产者和消费者公用一把锁，锁上维持2个队列：一个生产队列和一个消费者队列</p>
</li>
</ul>
<h3 id="5-1-3-使用显式锁的模板代码"><a href="#5-1-3-使用显式锁的模板代码" class="headerlink" title="5.1.3 使用显式锁的模板代码"></a>5.1.3 使用显式锁的模板代码</h3><p>因为 JUC 中的显式锁都实现了 Lock 接口，所以不同类型的显式锁对象使用的方法都是模板化的、套路化的，模板代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建锁对象，SomeLock 为 Lock 的某个实现类，如 ReentrantLock</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> SomeLock();</span><br><span class="line"><span class="comment">//step 1： 抢占锁</span></span><br><span class="line">lock.lock;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//step2 ： 抢锁成功，执行临界区代码</span></span><br><span class="line">    doSomething();</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    lock.unlock(); <span class="comment">//step3： 释放锁</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>模板代码有几个需要注意的点：</p>
<ul>
<li><p>释放锁操作 unlock 必须在 try-catch 的finally 中执行，否则如果临界区代码抛出异常，锁就可能永远也得不到释放了</p>
</li>
<li><p>抢占锁的操作<strong>lock 必须在 try 语句之外</strong>，原因：lock 方法不一定能够抢锁成功（我猜测作者是想说 tryLock() 之类的方法不一定会获取成功），如果没有抢占到锁，也肯定不需要释放锁，<strong>在没有占有锁的情况下释放锁可能导致异常</strong>。</p>
</li>
<li><p>在抢占锁操作 lock 和 try 语句之间不要插入任何代码，避免抛出异常而无法执行到 try，进而无法释放锁。</p>
</li>
</ul>
<h3 id="5-1-4-基于显式锁进行“等待-通知”方式的线程间通信"><a href="#5-1-4-基于显式锁进行“等待-通知”方式的线程间通信" class="headerlink" title="5.1.4 基于显式锁进行“等待-通知”方式的线程间通信"></a>5.1.4 基于显式锁进行“等待-通知”方式的线程间通信</h3><p>Java 内置锁可以通过 Object 的 wait 和 notify 方法来实现简单的线程间通信，与此类似的是，基于 Lock 显式锁，JUC 也提供了一个用于线程间通信的接口 Condition</p>
<p>Condition 接口有2类主要方法：</p>
<ul>
<li>await() ： 在功能上与 Object.wait() 语意等效，线程会加入 await() 等待队列，<strong>并释放当前锁</strong></li>
<li>signal() ： 在功能上与 Object.notify() 语意等效，唤醒 await() 等待队列中的线程</li>
</ul>
<blockquote>
<p>为了避免与 Object 中的 wait/notify 2类方法在使用时发生混淆，JUC 对 Condition 接口方法改了名称，成为了 await/signal。Condition 对象的 signal 和<strong>同一个对象的 await 是一一配对使用的</strong>。</p>
</blockquote>
<p><strong>Condition 对象是基于显式锁的，所以不能独立创建 Condition 对象，可以通过 lock.newCondition() 方法获取</strong>一个与当前显式锁绑定的 Condition 对象。用法举例如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitTarget</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        lock.lock();<span class="comment">//抢锁</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            print(<span class="string">"开始等待"</span>);</span><br><span class="line">            condition.await();<span class="comment">//开始等待，并且释放锁</span></span><br><span class="line">            print(<span class="string">"收到通知，开始继续执行"</span>);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用 await 方法前必须要先获取锁，await 方法会让当前线程加入 Condition 的等待队列，同理， signal 方法也要在获取锁之后才能调用，调用 signal 之后一定要释放锁，只有这样被唤醒的等待线程才能抢锁。</p>
<h3 id="5-1-5-LockSupport"><a href="#5-1-5-LockSupport" class="headerlink" title="5.1.5 LockSupport"></a>5.1.5 LockSupport</h3><p>LockSupport 是JUC 提供的一个 <strong>线程阻塞与唤醒的工具类</strong>。大体有2类方法(阻塞和唤醒)：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无限期阻塞当前线程</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span></span>; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 唤醒某个被阻塞的线程</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>一个简单的演示的实例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitTarget</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            print(<span class="string">"即将进入阻塞"</span>);</span><br><span class="line">            LockSupport.park();<span class="comment">//阻塞当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) {</span><br><span class="line">                print(<span class="string">"被中断了"</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                print(<span class="string">"被重新唤醒"</span>);</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-1-5-1-LockSupport-park-的对比（自己改的标题）"><a href="#5-1-5-1-LockSupport-park-的对比（自己改的标题）" class="headerlink" title="5.1.5.1 LockSupport.park() 的对比（自己改的标题）"></a>5.1.5.1 LockSupport.park() 的对比（自己改的标题）</h4><p>1、与 Thread.sleep() 的区别</p>
<ul>
<li>Thread.sleep() 只能自己醒来，没法外部唤醒；LockSupport.park() 可以通过 unpark 唤醒</li>
<li>Thread.sleep() 声明了中断异常(InterruptedException) ，而LockSupport.park() 没有</li>
<li>被中断的时候，虽然线程都会被设置中断标记，但是线程表现不同：sleep 会抛异常，park 不会</li>
</ul>
<p>2、与 Object.wait() 的区别</p>
<ul>
<li>wait 需要在同步块中执行，park 可以在任意地方执行</li>
<li>当阻塞线程被中断时，wait 方法抛出中断异常；而park 不会抛出异常</li>
<li>如果没有调用过 wait 而直接执行 notify 会导致 IllegalMonitorStateException异常；而未做park 直接做 unpark 不会有任何异常</li>
</ul>
<blockquote>
<p>自己看了下 LockSupport 的源码，发现 park 和 unpark 都是 native 方法，所以在代码层面就没对比了</p>
</blockquote>
<h3 id="5-1-6-显式锁分类"><a href="#5-1-6-显式锁分类" class="headerlink" title="5.1.6 显式锁分类"></a>5.1.6 显式锁分类</h3><p>从多个维度分类： 可重入、悲观/乐观、公平、共享/独占、可中断/不可中断</p>
<h3 id="5-2-2-通过-CAS-实现乐观锁"><a href="#5-2-2-通过-CAS-实现乐观锁" class="headerlink" title="5.2.2 通过 CAS 实现乐观锁"></a>5.2.2 通过 CAS 实现乐观锁</h3><p>乐观锁通过 CAS 实现主要就是两个步骤：</p>
<ol>
<li>冲突检测 （CAS 检测内存位置 V 的值是否为 A）</li>
<li>数据更新 (CAS 上述检测如果是，则将位置 V 更新为 B 值，否则不更改)</li>
</ol>
<p>在实际使用中，仅仅进行一次 CAS 是不够的，一般情况下需要不断循环重试直到CAS 操作成功，也即<strong>自旋</strong></p>
<blockquote>
<p>乐观锁是一种思想，CAS 是这种思想的一种实现</p>
</blockquote>
<p>作为演示，这里设计一个简单版本的不可重入（如果需要重入就count计数，这里不贴例子了）的自旋锁：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前锁的拥有者</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//书中的例子这里是写错了，它写成 while(owner.compareAndSet(null, t))</span></span><br><span class="line">        <span class="keyword">while</span>(!owner.compareAndSet(<span class="keyword">null</span>, t)) {<span class="comment">//循环竞争锁</span></span><br><span class="line">            <span class="comment">//没获取到锁，让出cpu</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span>(t == owner.get()) {</span><br><span class="line">            owner.set(<span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-2-5-CAS-可能导致“总线风暴”"><a href="#5-2-5-CAS-可能导致“总线风暴”" class="headerlink" title="5.2.5 CAS 可能导致“总线风暴”"></a>5.2.5 CAS 可能导致“总线风暴”</h3><p>为了保障“缓存一致性”，不同的内核需要通过总线来回通信，使用 lock 前缀（用于内存屏障）指令的 Java 操作（比如CAS、volatile）会产生缓存一致性流量，很多线程同时执行lock前缀操作时，会在总线上产生过多的流量，也就是 “总线风暴”。</p>
<p>那么，基于 JUC 实现的轻量级锁怎么避免总线风暴？答案是：使用队列对抢锁线程进行排队。</p>
<h3 id="5-2-6-CLH自旋锁"><a href="#5-2-6-CLH自旋锁" class="headerlink" title="5.2.6 CLH自旋锁"></a>5.2.6 CLH自旋锁</h3><p>CLH锁就是一种基于队列排队的自旋锁（由3个发明人的名字命名的），AQS 也是基于这种原理，为了说明其原理，这里实现一个 CLH 锁的学习版本，并不是真正的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点的线程本地变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Node&gt; curNodeLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CLHLock队列的尾部指针，使用AtomicReference，方便进行</span></span><br><span class="line"><span class="comment">     * CAS操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Node&gt; tail = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CLHLock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//设置尾部节点</span></span><br><span class="line">        tail.getAndSet(Node.EMPTY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁操作：将节点添加到等待队列的尾部</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        Node curNode = <span class="keyword">new</span> Node(<span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node preNode = tail.get();</span><br><span class="line">        <span class="comment">//CAS自旋：将当前节点插入队列的尾部</span></span><br><span class="line">        <span class="keyword">while</span> (!tail.compareAndSet(preNode, curNode)) {</span><br><span class="line">            preNode = tail.get();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//设置前驱节点</span></span><br><span class="line">        curNode.setPrevNode(preNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自旋，监听前驱节点的locked变量，直到其值为false</span></span><br><span class="line">        <span class="comment">// 若前驱节点的locked状态为true，则表示前一个线程还在抢占或者占有锁</span></span><br><span class="line">        <span class="keyword">while</span> (curNode.getPrevNode().isLocked()) {</span><br><span class="line">            <span class="comment">//让出CPU时间片，提高性能</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 能执行到这里，说明当前线程获取到了锁</span></span><br><span class="line">        <span class="comment">// Print.tcfo("获取到了锁！！！");</span></span><br><span class="line">        <span class="comment">//将当前节点缓存在线程本地变量中，释放锁会用到</span></span><br><span class="line">        curNodeLocal.set(curNode);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">        Node curNode = curNodeLocal.get();</span><br><span class="line">        curNode.setLocked(<span class="keyword">false</span>);</span><br><span class="line">        curNode.setPrevNode(<span class="keyword">null</span>); <span class="comment">//help for GC</span></span><br><span class="line">        curNodeLocal.set(<span class="keyword">null</span>); <span class="comment">//方便下一次抢锁</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虚拟等待队列的节点</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> locked, Node prevNode)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.locked = locked;</span><br><span class="line">            <span class="keyword">this</span>.prevNode = prevNode;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// true：当前线程正在抢占锁，或者已经占有锁</span></span><br><span class="line">        <span class="comment">// false：当前线程已经释放锁，下一个线程可以占有锁了</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">boolean</span> locked;</span><br><span class="line">        <span class="comment">// 前一个节点，需要监听其locked字段</span></span><br><span class="line">        Node prevNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Node EMPTY = <span class="keyword">new</span> Node(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>CLH 算法的几个要点就是（我理解的是，这种步骤就是公平锁环境下弄的，非公平锁不会每次头节点获得锁）：</p>
<ol>
<li>初始状态队列尾部(tail)指向一个 EMPTY节点，tail 节点使用 AtomicReference 类型是为了让多线程并发操作时安全</li>
<li>Thread 在抢锁时会创建一个 Node 加入等待队列尾部（默认lock 属性为true），同时自己作为新的尾部，这些操作通过 CAS 自旋操作</li>
<li>Node 加入之后，会循环判断前去节点的 lock 属性是否为false，如果为false，即前驱节点释放了锁，当前节点获得了锁</li>
<li>当前node 获得锁之后，将locked 属性设置为true</li>
<li>临界区代码执行完毕后，当前节点的 locked 置为 false，方便后续节点获取锁</li>
</ol>
<h3 id="5-4-2-死锁的监测与中断"><a href="#5-4-2-死锁的监测与中断" class="headerlink" title="5.4.2 死锁的监测与中断"></a>5.4.2 死锁的监测与中断</h3><p>JDK 8 中包含一个 ThreadMXBean 接口，提供多种监视线程的方法：</p>
<ul>
<li>findDeadlockedThreads ：用于检测由于抢占JUC显式锁、Java内置锁引起死锁的线程。</li>
<li>findMonitorDeadlockedThreads：仅仅用于检测由于抢占Java内置锁引起死锁的线程。</li>
</ul>
<h2 id="5-5-共享锁与独占锁"><a href="#5-5-共享锁与独占锁" class="headerlink" title="5.5 共享锁与独占锁"></a>5.5 共享锁与独占锁</h2><p>JUC 中的共享锁包括 Semaphore（信号量）、ReadLock（读写锁中的读锁）、CountDownLatch 倒数闩</p>
<h3 id="5-5-2-共享锁-Semaphore"><a href="#5-5-2-共享锁-Semaphore" class="headerlink" title="5.5.2 共享锁 Semaphore"></a>5.5.2 共享锁 Semaphore</h3><p>Semaphore 可以用来控制在同一时刻共享资源的线程数量，维护了一组虚拟许可。<strong>将 Semaphore 称为一个许可管理器 更形象。</strong></p>
<h4 id="5-5-2-1-Semaphore-使用示例"><a href="#5-5-2-1-Semaphore-使用示例" class="headerlink" title="5.5.2.1 Semaphore 使用示例"></a>5.5.2.1 Semaphore 使用示例</h4><p>Semaphore 使用一个很形象的场景是银行排队办理业务，只有 N 个窗口，M 个人在排队，那么其实相当于有 N 个许可：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(N);</span><br><span class="line"></span><br><span class="line">Runnable r = () -&gt; {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//阻塞开始获取许可</span></span><br><span class="line">        semaphore.acquire(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//获取了一个许可</span></span><br><span class="line">        print(<span class="string">"业务办理中"</span>);</span><br><span class="line">        <span class="comment">//模拟业务操作: 处理排队业务</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//用完了释放许可</span></span><br><span class="line">        semaphore.release(<span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">catch</span>(Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-5-3-共享锁-CountDownLatch"><a href="#5-5-3-共享锁-CountDownLatch" class="headerlink" title="5.5.3 共享锁 CountDownLatch"></a>5.5.3 共享锁 CountDownLatch</h3><p>CountDownLatch 功能相当于一个多线程环境下的倒数门闩，它可以指定一个计数值，在并发环境下由线程进行减1操作，当计数变为 0 之后，被 await 阻塞的线程将会唤醒。</p>
<p>它的一个经典示例就是，司机开车之前需要每个人报数，报数到 100 后说明人到齐发车：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) {<span class="comment">// 启动报数任务</span></span><br><span class="line">    threadPoll.execute(<span class="keyword">new</span> Runable() {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            print(<span class="string">"第"</span> + i + <span class="string">"个人已到"</span>);</span><br><span class="line">            <span class="comment">//倒数闩减1</span></span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"> doneSignal.await(); <span class="comment">//step2：等待报数完成，倒数闩计数值为0</span></span><br><span class="line"> print(<span class="string">"人到齐，开车"</span>); </span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-6-读写锁"><a href="#5-6-读写锁" class="headerlink" title="5.6 读写锁"></a>5.6 读写锁</h2><p>读写锁的读和写操作的互斥原则如下：</p>
<ul>
<li>读读能共存</li>
<li>读写不能共存</li>
<li>写写不能共存</li>
</ul>
<p>JUC 包中的读写锁接口为 ReadWriteLock ，主要有2个方法： </p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>{</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回读锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回写锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其主要实现类为 ReentrantReadWriteLock ，与 ReentrantLock 相比，<strong>前者更适合 读多写少 的场景，而 ReentrantLock 适合 读写比例相差不大 的场景</strong>。</p>
<h3 id="5-6-3-StampedLock-印戳锁"><a href="#5-6-3-StampedLock-印戳锁" class="headerlink" title="5.6.3 StampedLock 印戳锁"></a>5.6.3 StampedLock 印戳锁</h3><p>StampedLock 是对 ReentrantReadWriteLock 读写所的一种改进，主要改进为： 在没有写只有读的场景，<strong>StampedLock 支持不用加读锁而是直接进行读操作，最大限度提升读的效率，只有发生过写操作后，再加读锁才能进行读操作。</strong></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/17/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC4%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/17/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC4%E7%AB%A0/" class="post-title-link" itemprop="url">第4章：可见性与有序性的原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-17 14:20:00" itemprop="dateCreated datePublished" datetime="2023-02-17T14:20:00+08:00">2023-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-18 15:53:19" itemprop="dateModified" datetime="2023-02-18T15:53:19+08:00">2023-02-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="4-1-CPU物理缓存结构"><a href="#4-1-CPU物理缓存结构" class="headerlink" title="4.1 CPU物理缓存结构"></a>4.1 CPU物理缓存结构</h2><p>L1缓存离 CPU 最近也最快，一般就 32k/64k水平；L2 缓存速度次之，容量一般比L1大；L3级缓存最大，比前面二者都大，速度也最慢，大小可能 12M 的水平。</p>
<h2 id="4-2-并发编程的三大问题"><a href="#4-2-并发编程的三大问题" class="headerlink" title="4.2 并发编程的三大问题"></a>4.2 并发编程的三大问题</h2><p>三大问题分别是： 原子性、可见性、有序性 问题。必须要保证这 3 个，只要有一个没保证，在多线程情况下就可能不正确。</p>
<p>后续的略。</p>
<h2 id="4-3-硬件层的MESI协议原理"><a href="#4-3-硬件层的MESI协议原理" class="headerlink" title="4.3 硬件层的MESI协议原理"></a>4.3 硬件层的MESI协议原理</h2><p>为了缓解内存速度和CPU速度差问题，现在计算机都会为CPU添加高速缓存，每个CPU内核都有自己的一级、二级高速缓存，同一个CPU多个内核之间共享一个三级高速缓存。</p>
<h3 id="4-3-1-总线锁和缓存锁"><a href="#4-3-1-总线锁和缓存锁" class="headerlink" title="4.3.1 总线锁和缓存锁"></a>4.3.1 总线锁和缓存锁</h3><p>CPU的处理流程为：现将计算需要用到的数据缓存到CPU的高速缓存中，CPU计算时，直接从高速缓存获取数据并在计算完成后写会高速缓存，整个运算完成后再把高速缓存的数据同步回主存。由于每个线程可能运行在不同的CPU内核中，因此<strong>同一份数据可能被缓存到多个CPU内核中，就会发生内存可见性问题</strong>。</p>
<p>后续的略。</p>
<h3 id="4-4-1-重排序"><a href="#4-4-1-重排序" class="headerlink" title="4.4.1 重排序"></a>4.4.1 重排序</h3><p><strong>编译器</strong>为什么要重排序？其目的为： <strong>与其等待阻塞指令（如等待缓存刷入），不如先去执行其他指令。</strong>另外，CPU层面也有重排序。</p>
<h2 id="4-5-JMM-详解"><a href="#4-5-JMM-详解" class="headerlink" title="4.5 JMM 详解"></a>4.5 JMM 详解</h2><p>JMM (Java Memory Model ，Java 内存模型) 并不像JVM 内存结构一样是真实存在的运行实体，更多体现为一种规范和规则。</p>
<p>JMM 定义了一组规则或规范，该规范定义了<strong>一个线程对共享变量写入时，如何确保对另一个线程是可见的</strong>，实际上 JMM 提供了合理的禁用缓存以及禁止重排序的方法，所以其核心价值在于<strong>解决可见性和有序性</strong>。它的另一大价值在于：<strong>屏蔽各大硬件和操作系统差异，保证 Java 程序在各大平台堆内存访问是一致的。</strong></p>
<p>JMM 规定所有的变量都存储在主存（类似于物理内存，但是有区别）中，每个 Java 线程都有自己的工作内存（类似于CPU高速缓存，但有区别）。</p>
<p>JMM 提供了一套自己的方案解决可见性和有序性问题，包括 volatile、synchronized、final 等。</p>
<h2 id="4-7-volatile-不具备原子性"><a href="#4-7-volatile-不具备原子性" class="headerlink" title="4.7 volatile 不具备原子性"></a>4.7 volatile 不具备原子性</h2><p>对于关键字 volatile 修饰的内存可见变量而言，具有2个重要的语义：</p>
<ul>
<li><p>使用 volatile 修饰的变量在变量的值发生改变时，会立刻同步到主存，并使其他线程的变量副本失效</p>
</li>
<li><p>禁止指令重排序</p>
</li>
</ul>
<p>使用++操作说明volatile不具备重排序功能：</p>
<ol>
<li><p>A、B线程分别运行在Core1 和 Core2 核上，假设此时共享value 的值为 0，现在线程 A、B 都读取value值到自己的工作内存上</p>
</li>
<li><p>线程 A 将 value 的值变为 1，完成了 assign、store 操作，假设在执行 write 指令前 A 的时间片用完，线程 A 被空闲但是 write 操作还没达到主存，但是呢， store 操作触发了写的信号，导致了 B 缓存过期</p>
</li>
<li><p>B重新从主存读到 value，可想而知这时候还是 0</p>
</li>
<li><p>线程 B 执行完所有操作，将 value 值变成 1 写入主存</p>
</li>
<li><p>线程 A 重新拿到时间片，将过期了的 1 写入主存</p>
</li>
</ol>
<p>所以，<strong>对于复合操作，volatile无法保障原子性，如果要保证复合操作的原子性，就需要用到锁</strong>。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/16/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：CAS原理与JUC原子类</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 14:50:00" itemprop="dateCreated datePublished" datetime="2023-02-16T14:50:00+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-22 22:22:30" itemprop="dateModified" datetime="2023-02-22T22:22:30+08:00">2023-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>JVM 的Synchrod 轻量级锁使用 CAS 进行自旋抢锁，并且处于用户态下，所以轻量级锁开销较小。</p>
<h2 id="3-1-什么是-CAS"><a href="#3-1-什么是-CAS" class="headerlink" title="3.1 什么是 CAS"></a>3.1 什么是 CAS</h2><p>JDK 5 增加的 JUC (java.util.concurrent) 并发包对操作系统的底层 CAS 原子操作进行了封装，为上层提供了 CAS 操作的 API 。</p>
<h3 id="3-1-1-Unsafe-类中的-CAS-方法"><a href="#3-1-1-Unsafe-类中的-CAS-方法" class="headerlink" title="3.1.1 Unsafe 类中的 CAS 方法"></a>3.1.1 Unsafe 类中的 CAS 方法</h3><p>Unsafe 是位于 sun.misc 包下的一个类，主要提供一些用于执行低级别、不安全的底层操作，如直接访问系统内存资源、自主管理内存资源等。从名字都可以看出这个类对普通程序员来说是“危险”的，官方也不建议直接在程序中使用这些类。</p>
<h5 id="获取-Unsafe-实例"><a href="#获取-Unsafe-实例" class="headerlink" title="获取 Unsafe 实例"></a>获取 Unsafe 实例</h5><p>Unsafe 类时一个final 修饰的不允许继承的类，并且构造函数是 private 类型，源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        Reflection.registerMethodsToFilter(Unsafe.class, Set.of(<span class="string">"getUnsafe"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe = <span class="keyword">new</span> Unsafe();</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所以我们无法在外部对 Unsafe 实例化，那么应该怎么获取呢？可以通过反射方式获取 theUnsafe 实例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmUtil</span> </span>{</span><br><span class="line">    <span class="comment">//自定义地获取Unsafe实例的辅助方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 省略不相干代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="Unsafe提供的-CAS-方法"><a href="#Unsafe提供的-CAS-方法" class="headerlink" title="Unsafe提供的 CAS 方法"></a>Unsafe提供的 CAS 方法</h5><p>总共提供了如下3种方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object expected,Object x)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,  <span class="keyword">int</span> expected,  <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">long</span> expected, <span class="keyword">long</span> x)</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>这些方法首先将内存位置的值与预期值比较，如果相匹配，那么CPU 会自动将该内存位置的值更新为新值，并返回true；否则，CPU不做任何操作，并返回false。</p>
<h3 id="3-1-2-使用-CAS-进行无锁编程"><a href="#3-1-2-使用-CAS-进行无锁编程" class="headerlink" title="3.1.2 使用 CAS 进行无锁编程"></a>3.1.2 使用 CAS 进行无锁编程</h3><p>CAS 是一种无锁算法，底层CPU 利用原子操作判断 <strong>内存值与期望值是否相等，如果相等就给内存地址赋新值，否则不做任何操作。</strong>使用 CAS 进行无锁编程的步骤大概如下：</p>
<ol>
<li><p>获得字段的期望值(oldValue)</p>
</li>
<li><p>计算出需要替换的新值(newValue)</p>
</li>
<li><p>通过 CAS 将 newValue 放在字段的内存地址上，如果 CAS 失败就重复从第1步开始，直到 CAS 成功。<strong>这种重复俗称“自旋”</strong></p>
</li>
</ol>
<p>举例： 假如 2 个线程 A 和B 对一个共享变量做 +1 操作，用 CAS 去做这个操作。但是线程是并发进行的，假如 A 和 B 都读到旧值是 1 ，然后并发通过 CAS 操作，都是 CAS(1, 2)  ，但是CAS 是原子操作，同一个内存地址的 CAS 在同一个时刻只能执行一个，因此，假设 A 先执行，A 的 CAS(1, 2) 因为期望值是1，内存值也是1，操作成功，返回true；接下来 B 执行 CAS(1, 2) 肯定会失败了，因为内存值目前已经是 2 了，而期望值是 1 ，所以只得重新获取得到期望值 2，计算出新的值 3， 最后通过 CAS(2, 3) 才能成功。</p>
<h2 id="3-2-JUC原子类"><a href="#3-2-JUC原子类" class="headerlink" title="3.2 JUC原子类"></a>3.2 JUC原子类</h2><p>并发执行时，诸如 ++ 或者 – 类的运算不具备原子性，大家可能会用 synchronized 方法做同步，但效率肯定会影响的。JDK 为这些类型不安全的操作提供了一些原子类，与 synchronized 相比效率会更高。</p>
<h3 id="3-2-1-JUC中的Atomic-原子操作包"><a href="#3-2-1-JUC中的Atomic-原子操作包" class="headerlink" title="3.2.1 JUC中的Atomic 原子操作包"></a>3.2.1 JUC中的Atomic 原子操作包</h3><p>只需要知道有： </p>
<ul>
<li><p>基本原子类：AtomicInteger、AtomicLong、AtomicBoolean</p>
</li>
<li><p>数组原子类：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p>
</li>
<li><p>引用原子类：AtomicReference、AtomicMarkableReference、AtomicStampedReference</p>
</li>
</ul>
<p>等等一些常见的即可。</p>
<h2 id="3-4-ABA问题"><a href="#3-4-ABA问题" class="headerlink" title="3.4 ABA问题"></a>3.4 ABA问题</h2><p>什么是 ABA 问题，举个例子：比如线程 A 从内存位置 M 取出 V1，另一个线程 B 也取出 V1 ，假设 B 进行了一些操作后将 M 位置的数据 V1 变成了 V2，然后又在一些操作之后将 V2 变成了 V1，然后线程 A 通过 CAS 操作时发现条件满足，CAS 操作成功。</p>
<p>但是这个过程是有问题的，A 操作的时候 V1 已经不是以前的 V1 了，这就是 ABA 问题。</p>
<h3 id="3-4-2-ABA问题的解决方案"><a href="#3-4-2-ABA问题的解决方案" class="headerlink" title="3.4.2 ABA问题的解决方案"></a>3.4.2 ABA问题的解决方案</h3><p>很多乐观锁的实现版本是： <strong>使用版本号(Version)方式来解决ABA问题。</strong> 每次在执行数据的修改操作时<strong>都会带上一个版本号</strong>，版本号和数据的版本号一致就可以执行修改操作，否则执行失败。因为操作的版本号只会增加，不会减少。</p>
<p>当然，参考乐观锁的版本号实现， JDK 提供了一个 AtomicStampedReference 类来解决 ABA 问题，AtomicStampedReference 在 CAS 的基础上增加了一个 Stamp（印戳或标记）来察觉数据是否发生了变化。</p>
<p>当然，还可以使用 AtomicMarkableReference 解决。它是 AtomicStampedReference 的简化版，不关心修改过几次，只关心是否修改过。</p>
<h2 id="3-5-提升高并发场景下-CAS-操作的性能"><a href="#3-5-提升高并发场景下-CAS-操作的性能" class="headerlink" title="3.5 提升高并发场景下 CAS 操作的性能"></a>3.5 提升高并发场景下 CAS 操作的性能</h2><p>在竞争激烈的场景下，会导致大量的 CAS 自旋，比如大量线程同时并发修改一个 AtomicInteger 是，很多线程可能不停地自旋， 这浪费了大量的 CPU。</p>
<h3 id="3-5-1-以空间换时间：LongAdder"><a href="#3-5-1-以空间换时间：LongAdder" class="headerlink" title="3.5.1 以空间换时间：LongAdder"></a>3.5.1 以空间换时间：LongAdder</h3><p>AtomicLong 使用内部变量 value 保存着实际的 long 值，所有操作都是针对该 value 的，也就是说，当高并发的情况下，value 变量其实是一个热点，N 个线程竞争这一个热点，重试的线程越多，意味着 CAS 失败的概率越高。</p>
<p>LongAdder 的核心思想是热点分离，与 ConcurrentHashMap 的设计思想类似：将 value 值分离成一个数组，当多线程访问时，通过 Hash 算法将线程映射到数组的一个元素进行操作；而获取最终value 结果时，则将数组的元素求和。</p>
<p>具体一点：LongAdder 将 value 值分散到一个数组中，不同的线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行 CAS 操作，这样热点就被分散了，这样，即使线程数再多也不担心，各个线程分配到多个元素更新。<strong>如果要获取完整的 LongAdder 存储的值，只要将各个槽中的变量值累加即可</strong></p>
<blockquote>
<p>在 CAS 竞争非常激烈的场景， LongAdder 的性能可达到 AtomicLong 的 8 倍。</p>
</blockquote>
<h2 id="3-6-CAS在JDK中的广泛应用"><a href="#3-6-CAS在JDK中的广泛应用" class="headerlink" title="3.6 CAS在JDK中的广泛应用"></a>3.6 CAS在JDK中的广泛应用</h2><h3 id="3-6-1-CAS操作的弊端和规避措施"><a href="#3-6-1-CAS操作的弊端和规避措施" class="headerlink" title="3.6.1 CAS操作的弊端和规避措施"></a>3.6.1 CAS操作的弊端和规避措施</h3><p>CAS 操作弊端主要有下面 3 点：</p>
<ul>
<li><p>ABA问题，<strong>解决思路</strong>： 添加版本号、使用 AtomicStampedReference、AtomicMarkableReference，其中前者比较常用</p>
</li>
<li><p>只能保证一个共享变量的原子操作。<strong>解决思路</strong>：将多个共享变量合并成一个共享变量来操作</p>
</li>
<li><p>开销问题。<strong>解决思路</strong>：分散操作热点(如 LongAdder)、使用队列削峰(将 发生 CAS 争用的线程加入一个队列中排队，降低 CAS 争用的激烈程度，JUC 中非常重要的基础类 AQS 就是这么做的！)</p>
</li>
</ul>
<h3 id="3-6-2-CAS-在JDK中的应用"><a href="#3-6-2-CAS-在JDK中的应用" class="headerlink" title="3.6.2 CAS 在JDK中的应用"></a>3.6.2 CAS 在JDK中的应用</h3><p>CAS 在 在java.util.concurrent.atomic包中的原子类、Java AQS 以及 显式锁、ConcurrentHashMap 等重要并发容器中都有非常广泛的应用</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/16/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：Java内置锁的核心原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-16 10:10:00" itemprop="dateCreated datePublished" datetime="2023-02-16T10:10:00+08:00">2023-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-23 23:13:31" itemprop="dateModified" datetime="2023-02-23T23:13:31+08:00">2023-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="2-2-synchronized-关键字"><a href="#2-2-synchronized-关键字" class="headerlink" title="2.2 synchronized 关键字"></a>2.2 synchronized 关键字</h2><p>synchronized 方法和 synchronized 同步块有什么区别呢？总体来说 synchronized 代码块是一种细粒度的并发控制，处于块之外的代码可以被多个线程并发访问。而如下代码本质上都是一样的，都是锁住当前对象：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">plus</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>){ <span class="comment">//对方法内部全部代码进行保护</span></span><br><span class="line">        amount++; </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">plus</span><span class="params">()</span> </span>{</span><br><span class="line">    amount++; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-3-静态的同步方法"><a href="#2-2-3-静态的同步方法" class="headerlink" title="2.2.3 静态的同步方法"></a>2.2.3 静态的同步方法</h3><p>Class 没有公共的构造方法，Class 对象是在类加载的时候由 Java 虚拟机调用类加载器中的 defineClass 方法自动构造的，<strong>因此不能显式地声明一个 Class 对象。</strong></p>
<p>普通的 synchronized 实例方法，其同步锁是当前对象 this 的监视锁，如果某个 synchronized 方法是static 方法，其同步锁又是什么呢？答案是：<strong>类对应的 Class 对象的监视锁。</strong></p>
<p>在代码执行完毕或者程序出现异常，synchronized 持有的监视锁都会正常释放，所以无需手动释放。</p>
<h2 id="2-4-Java对象结构与内置锁"><a href="#2-4-Java对象结构与内置锁" class="headerlink" title="2.4 Java对象结构与内置锁"></a>2.4 Java对象结构与内置锁</h2><p>Java 内置锁很多重要信息都存放在对象结构中。</p>
<h3 id="2-4-1-Java-对象结构"><a href="#2-4-1-Java-对象结构" class="headerlink" title="2.4.1 Java 对象结构"></a>2.4.1 Java 对象结构</h3><p>Java 对象结构包括三部分：</p>
<ul>
<li>对象头：包括3个字段：Mark Word（存储GC标记位、锁状态）、类对象指针（存放方法区Class对象的地址，能确定该对象是哪个类的实例）、Array Length（如果对象是Java 数组，那么就是数组长度；如果不是数组，就不存在这字段）</li>
<li>对象体：包括成员属性，包括父类的成员属性</li>
<li>对齐字节：填充对齐，用来保证对象所占内存字节数为8的倍数</li>
</ul>
<h3 id="2-4-2-Mark-Word-的结构信息"><a href="#2-4-2-Mark-Word-的结构信息" class="headerlink" title="2.4.2 Mark Word 的结构信息"></a>2.4.2 Mark Word 的结构信息</h3><p>从Mark Word 锁标志位的状态来看，内置锁的状态就有了 4 种： 无锁、偏向锁、轻量级锁、重量级锁，<strong>这4种状态会随着竞争的激烈程度逐渐升级，并且是不可逆的过程，即不可降级。</strong></p>
<h3 id="2-4-3-使用-JOL-工具查看对象的布局"><a href="#2-4-3-使用-JOL-工具查看对象的布局" class="headerlink" title="2.4.3 使用 JOL 工具查看对象的布局"></a>2.4.3 使用 JOL 工具查看对象的布局</h3><p>知道有 JOL 工具即可，略。</p>
<h3 id="2-4-5-无锁、偏向锁、轻量级锁和重量级锁"><a href="#2-4-5-无锁、偏向锁、轻量级锁和重量级锁" class="headerlink" title="2.4.5 无锁、偏向锁、轻量级锁和重量级锁"></a>2.4.5 无锁、偏向锁、轻量级锁和重量级锁</h3><p>JDK 1.6 以前，所有内置锁都是重量级锁，所以会在用户态和核心态之间频繁切换，所以代价很高。后续引入了 偏向锁和 轻量级锁，所以一共就有 4 种状态：无锁、偏向锁、轻量级锁、重量级锁。<strong>内置锁可以升级但是不能降级</strong>。</p>
<h2 id="2-5-偏向锁的原理与实战"><a href="#2-5-偏向锁的原理与实战" class="headerlink" title="2.5 偏向锁的原理与实战"></a>2.5 偏向锁的原理与实战</h2><p>原理：如果不存在线程竞争，那么线程获得锁之后就进入偏向状态：偏向锁标志位为 1，锁状态为 01。以后该线程获取锁时判断一下线程 ID 和标志位，就可以直接进入同步块，连 CAS 都不需要，从而提升性能。</p>
<p>但是，<strong>一旦有第二条线程需要竞争锁，偏向模式就立即结束，进入轻量级锁状态。</strong>这里需要好好理解下，感觉这句话不一定对，书中更准确的表述是：<strong>线程获取锁时，判断该偏向状态的锁的 ID 是不是自己的，如果是自己的，则直接进入同步块；否则，采用 CAS 操作将 Mark Word 中的偏向锁 ID 换成自己的，如果 CAS 操作成功，就获取偏向锁成功，执行同步块代码；如果 CAS 操作不成功，表示有竞争，抢锁线程被挂起，撤销占锁线程的偏向锁，然后将偏向锁膨胀为轻量级锁。</strong>。</p>
<h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><ol>
<li>在一个安全点停止拥有锁的线程</li>
<li>遍历线程栈帧，找到并删除栈帧，使其变为无锁状态，修复锁指向的 Mark Word ，并清除锁 Mark Word 中的线程 ID</li>
<li>将当前锁升级为轻量级锁</li>
<li>唤醒当前线程</li>
</ol>
<h2 id="2-6-轻量级锁的原理与实战"><a href="#2-6-轻量级锁的原理与实战" class="headerlink" title="2.6 轻量级锁的原理与实战"></a>2.6 轻量级锁的原理与实战</h2><p>轻量级锁是<strong>一种自旋锁，希望在应用层面通过自旋解决线程同步问题。</strong>轻量级锁的执行过程：</p>
<p>抢锁线程进入临界区之前，如果内置锁没有被锁定，JVM 首先将在抢锁线程的栈帧中创建一个锁记录(Lock Record)，<strong>用于存储对象目前的 Mark Word 的拷贝</strong>。</p>
<p>然后抢锁线程将使用 CAS 自旋操作，尝试<strong>将内置锁对象头的 Mark Word 的ptr_to_lock_record（锁记录指针）更新为抢锁线程栈帧中拷贝的 Mark Word ，如果这个更新执行成功，线程就拥有了这个对象锁，之后会改掉 Mark Word 中的lock 标记为 00,即轻量级锁</strong>。</p>
<blockquote>
<p>为什么要拷贝呢？因为内置锁对象的 Mark Word 结构会有所变化，而不再存着无锁状态下的一些信息，所以要拷贝。</p>
</blockquote>
<h3 id="2-6-3-轻量级锁的分类"><a href="#2-6-3-轻量级锁的分类" class="headerlink" title="2.6.3 轻量级锁的分类"></a>2.6.3 轻量级锁的分类</h3><p>轻量级锁分为 2 种： </p>
<ul>
<li>普通自旋锁： 抢锁线程一直在自旋，而不是被阻塞，直到占有锁的线程释放之后抢锁线程才能获取到锁</li>
<li>自适应自旋锁：自旋次数不是固定的，而是根据系统以前的经验来的。解决的是<strong>锁竞争时间不确定的问题</strong>。</li>
</ul>
<h2 id="2-7-重量级锁的原理与实战"><a href="#2-7-重量级锁的原理与实战" class="headerlink" title="2.7 重量级锁的原理与实战"></a>2.7 重量级锁的原理与实战</h2><p>在 JVM 中，<strong>每个对象都关联一个监视器，这里的对象包括 Object 实例和 Class 实例</strong>。监视器是一个同步工具，相当于一个许可证：拿到许可证的线程可以进入临界区执行，没有拿到的则需要阻塞等待。</p>
<h3 id="2-7-1-重量级锁的核心原理"><a href="#2-7-1-重量级锁的核心原理" class="headerlink" title="2.7.1 重量级锁的核心原理"></a>2.7.1 重量级锁的核心原理</h3><p>HotSpot 虚拟机中，监视器是由 C++ 类 ObjectMonitor 实现的，它有以下几个比较关键的属性：</p>
<p>Owner、WaitSet、Cxq、EntryList ，其中 Owner 所指向的线程为获得锁的线程，WaitSet、Cxq、EntryList 是 3 个队列，用于存放抢夺重量级锁的线程：</p>
<ul>
<li>Cxq：竞争队列(Contention Queue)，所有请求锁的线程首先被放在这个竞争队列中（不是真正的队列，只是由Node及其 next 指针逻辑构成，每次都通过 CAS 操作在头部新增节点，取元素从尾获取，因为只有 Owner 线程才能从队尾获取节点，所以，Cxq 出队无争用操作，是无锁结构）</li>
<li>EntryList： Cxq 中那些有资格成为候选资源的线程被移动到 EntryList。Cxq 会被线程并发访问，为了降低对 Cxq 的争用而建立了 EntryList。在 Owner 线程释放锁时，JVM 会从 Cxq 中迁移线程到 EntryList，并会指定 EntryList 中的某个线程(一般为 Head) 为 Ready Thread。 EntryList 作为候选竞争线程而存在（自己加的：但由于是非公平锁，所以这个 Ready Thread 不一定能得以执行，后续的说明非公平性会提及）。</li>
<li>WaitSet： 某个拥有锁的线程在调用 Object.wait() 方法之后将被阻塞，然后线程将被放置在 WaitSet 链表中。等到执行 Object.notify/notifyAll 唤醒之后，该线程又会<strong>回到 EntryList 中</strong>(注意不是 Cxq 中)。</li>
</ul>
<blockquote>
<p>Synchronized 的不公平性：在线程进入 Cxq 前，抢锁线程会先尝试通过 CAS 自旋获取锁，如果获取到就直接用了；获取不到，才进入 Cxq 队列，这对于已经进入 Cxq 队列的线程是不公平的。但是这由于避免了 Cxq 队列中线程唤醒——内核态到用户态的过程，节省了时间，提升了吞吐率</p>
</blockquote>
<h3 id="2-7-2-重量级锁开销"><a href="#2-7-2-重量级锁开销" class="headerlink" title="2.7.2 重量级锁开销"></a>2.7.2 重量级锁开销</h3><p>处于 Cxq、EntryList 以及 WaitSet 中的线程都处于阻塞状态，<strong>线程的阻塞或者唤醒都需要操作系统来帮忙，需要通过系统调用实现</strong>，进城需要从用户态切换到内核态，这种切换需要消耗很多时间，有可能比用户执行代码的时间还要长。</p>
<p><strong>由于轻量级锁使用 CAS 进行自旋抢锁，而 CAS 操作都处于用户态下，不存在用户态和内核态的切换，因此轻量级锁的开销比较小。</strong></p>
<h2 id="2-8-偏向锁、轻量级锁与重量级锁的对比"><a href="#2-8-偏向锁、轻量级锁与重量级锁的对比" class="headerlink" title="2.8 偏向锁、轻量级锁与重量级锁的对比"></a>2.8 偏向锁、轻量级锁与重量级锁的对比</h2><p>总结一下，synchronized 的执行过程大致如下：</p>
<ol>
<li>线程抢锁时，JVM 首先检测内置锁对象 Mark Word 的biased_lock(偏向锁标识)是否为1，lock (锁标志位)是否为01，如果都满足，说明内置锁对象为可偏向状态</li>
<li>如果内置锁对象为可偏向状态，JVM 检查 Mark Word 中线程 ID 是否为当前抢锁线程的 ID，如果是，标识抢锁线程处于偏向所状态，快速获得锁，开始执行临界区代码</li>
<li>如果Mark Word 中的线程 ID 不是当前抢锁线程，就通过 CAS 竞争锁。如果竞争成功，就将 Mark Word 中的线程 ID 设置为抢锁线程的 ID ，偏向锁标志设为 1 ，锁标志位设为 01,此时内置锁对象处于偏向锁状态，然后开始执行临界区代码</li>
<li>如果 CAS 竞争失败，说明发生了竞争，撤销偏向锁，进而升级为轻量级锁</li>
<li>JVM 使用 CAS 将锁对象的 Mark Word 替换为抢锁线程的锁记录指针，如果成功，抢锁线程就获得锁；如果替换失败，就表示其他线程在竞争锁。那么 JVM 尝试使用 CAS 自旋替换抢锁线程的锁记录指针，如果自旋成功（抢锁成功），那么锁对象依旧处于轻量级锁状态。</li>
<li>如果JVM的CAS 替换锁记录指针自旋失败，轻量级锁就膨胀为重量级锁，后面等待锁的线程也要进入阻塞状态</li>
</ol>
<p>3种锁的优缺点对比和适用场景如下表所示：</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加解锁不需要额外消耗，和执行非同步方法仅存在纳秒级差距</td>
<td>如果线程间存在锁竞争，会带来额外的撤销锁操作</td>
<td>适用于只有一个线程访问的临界区场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>抢不到锁的竞争线程会CAS自旋，消耗CPU</td>
<td>锁占用时间短，吞吐量低</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争无需自旋，不消耗CPU</td>
<td>线程阻塞，响应时间慢</td>
<td>锁占用时间长，吞吐量高</td>
</tr>
</tbody></table>
<h2 id="2-9-线程间通信"><a href="#2-9-线程间通信" class="headerlink" title="2.9 线程间通信"></a>2.9 线程间通信</h2><p>多个线程共同操作共享的资源时，线程间通过某种方法互相告知自己的状态，以避免无效的资源争夺。<strong>线程间通信的方式可以有很多种：等待-通知、共享内存、管道流。</strong></p>
<h3 id="2-9-2-低效的线程轮询"><a href="#2-9-2-低效的线程轮询" class="headerlink" title="2.9.2 低效的线程轮询"></a>2.9.2 低效的线程轮询</h3><p>轮询版本的生产者-消费者模型中，消费者每一轮消费，无论数据区是否为空，都需要进行数据区的询问和判断：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> IGoods <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    IGoods goods = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (amount &lt;= <span class="number">0</span>) {</span><br><span class="line">        Print.tcfo(<span class="string">"队列已经空了！"</span>);</span><br><span class="line">        <span class="comment">//数据区为空，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当数据区为空(amount &lt;= 0)时，消费者无法取出数据，但是仍然做无用的询问工作，浪费了CPU的时间片。同理，对于生产者也会存在这样的问题：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T element)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (amount.get() &gt; MAX_AMOUNT) {</span><br><span class="line">        Print.tcfo(<span class="string">"队列已经满了！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当数据区满时，生产者无法加入数据，这时执行add方法也浪费CPU的时间片。<strong>使用“等待-通知”方式进行生产者与消费者之间的线程通信可以避免这种浪费。</strong></p>
<p>具体方法是：<strong>当数据区满时，给让生产者等待，当可以添加数据时，给生产者发通知，让生产者唤醒；消费者同理。</strong>具体操作为：消费者取出一个数据后，由消费者去唤醒等待的生产者；生产者加入一个数据后，由生产者唤醒等待的消费者。</p>
<h3 id="2-9-3-wait-、notify-方法的原理"><a href="#2-9-3-wait-、notify-方法的原理" class="headerlink" title="2.9.3 wait 、notify 方法的原理"></a>2.9.3 wait 、notify 方法的原理</h3><h5 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait 方法"></a>wait 方法</h5><p>对象的 wait 方法作用就是<strong>让当前线程阻塞并等待被唤醒，wait 方法与对象监视器密切相关，使用时一定要放在同步块中：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(locko) {</span><br><span class="line">    ...</span><br><span class="line">    locko.wait();</span><br><span class="line">    ....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其原理大致如下：</p>
<ul>
<li><p>线程调用了 locko 的wait 方法后，JVM 会将当前线程假如 locko 监视器的 WaitSet(等待集) 中，等待被其他线程唤醒</p>
</li>
<li><p>当前线程会释放 locko 对象监视器 的 Owner 权利，让其他线程可以抢夺 locko 对象的监视器</p>
</li>
<li><p>让当前线程等待，其状态变为 WAITING</p>
</li>
</ul>
<h5 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify 方法"></a>notify 方法</h5><p>notify 方法也需要放在同步块中执行，它有2个版本：</p>
<ul>
<li><p>notify ： 唤醒 locko 监视器等待集中的第一条等待线程，被唤醒的线程进入 EntryList ，状态从 WAITING 变为 BLOCKED</p>
</li>
<li><p>notifyAll： 唤醒 locko 监视器等待集中全部等待线程，所有线程进入 EntryList ，状态从 WAITING 变为 BLOCKED</p>
</li>
</ul>
<p>notify 核心原理如下：</p>
<ul>
<li><p>当线程调用了 locko 的 notify 方法后，JVM 会唤醒 locko 监视器等待集中的第一条等待线程（如果是 notifyAll 则是所有线程），被唤醒的线程进入 EntryList ，状态从 WAITING 变为 BLOCKED，<strong>具备了排队抢夺监视器 Owner权利的资格</strong></p>
</li>
<li><p>EntryList 中的线程抢夺到监视器的 Owner 权利后，线程的状态从 BLOCKED 变成 RUNNABLE，具备重新执行的资格</p>
</li>
</ul>
<h3 id="2-9-5-生产者-消费者之间的线程间通信"><a href="#2-9-5-生产者-消费者之间的线程间通信" class="headerlink" title="2.9.5 生产者-消费者之间的线程间通信"></a>2.9.5 生产者-消费者之间的线程间通信</h3><p>此实现版本大致需要定义以下3个同步对象：</p>
<ul>
<li><p>LOCK_OBJECT：用于临界区同步，临界区资源为数据缓冲区的 dataList 变量和 amount 变量</p>
</li>
<li><p>NOT_FULL：用于数据缓冲区的未满条件等待和通知，生产者在添加元素时需要判定是否已满，如果已满，则进入 NOT_FULL 的同步去等待，只要消费者耗费一个元素，就会通过 NOT_FULL 发送通知。</p>
</li>
<li><p>NOT_EMPTY：同理，这是用于数据缓冲区的非空条件的等待和通知。消费者在消费前需要判断数据区是否空，如果是，消费者就进入 NOT_EMPTY 的同步区等待被通知，只要生产者添加一个元素，生产者就会通过 NOT_EMPTY 发送通知</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommunicatePetStore</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AMOUNT = <span class="number">10</span>; <span class="comment">//数据缓冲区最大长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据缓冲区，类定义</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBuffer</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">        <span class="comment">//保存数据</span></span><br><span class="line">        <span class="keyword">private</span> List&lt;T&gt; dataList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//数据缓冲区长度</span></span><br><span class="line">        <span class="keyword">private</span> Integer amount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object LOCK_OBJECT = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object NOT_FULL = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object NOT_EMPTY = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向数据区增加一个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T element)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">while</span> (amount &gt; MAX_AMOUNT) {</span><br><span class="line">                <span class="keyword">synchronized</span> (NOT_FULL) {</span><br><span class="line">                    Print.tcfo(<span class="string">"队列已经满了！"</span>);</span><br><span class="line">                    <span class="comment">//等待未满通知</span></span><br><span class="line">                    NOT_FULL.wait();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK_OBJECT) {</span><br><span class="line">                dataList.add(element);</span><br><span class="line">                amount++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">synchronized</span> (NOT_EMPTY) {</span><br><span class="line">                <span class="comment">//发送未空通知</span></span><br><span class="line">                NOT_EMPTY.notify();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从数据区取出一个商品</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">while</span> (amount &lt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">synchronized</span> (NOT_EMPTY) {</span><br><span class="line">                    Print.tcfo(<span class="string">"队列已经空了！"</span>);</span><br><span class="line">                    <span class="comment">//等待未空通知</span></span><br><span class="line">                    NOT_EMPTY.wait();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            T element = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK_OBJECT) {</span><br><span class="line">                element = dataList.remove(<span class="number">0</span>);</span><br><span class="line">                amount--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (NOT_FULL) {</span><br><span class="line">                <span class="comment">//发送未满通知</span></span><br><span class="line">                NOT_FULL.notify();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">            InterruptedException </span>{</span><br><span class="line">        Print.cfo(<span class="string">"当前进程的ID是"</span> + JvmUtil.getProcessID());</span><br><span class="line">        System.setErr(System.out);</span><br><span class="line">        <span class="comment">//共享数据区，实例对象</span></span><br><span class="line">        DataBuffer&lt;IGoods&gt; dataBuffer = <span class="keyword">new</span> DataBuffer&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产者执行的动作</span></span><br><span class="line">        Callable&lt;IGoods&gt; produceAction = () -&gt; {</span><br><span class="line">            <span class="comment">//首先生成一个随机的商品</span></span><br><span class="line">            IGoods goods = Goods.produceOne();</span><br><span class="line">            <span class="comment">//将商品加上共享数据区</span></span><br><span class="line">            dataBuffer.add(goods);</span><br><span class="line">            <span class="keyword">return</span> goods;</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//消费者执行的动作</span></span><br><span class="line">        Callable&lt;IGoods&gt; consumerAction = () -&gt; {</span><br><span class="line">            <span class="comment">// 从PetStore获取商品</span></span><br><span class="line">            IGoods goods = <span class="keyword">null</span>;</span><br><span class="line">            goods = dataBuffer.fetch();</span><br><span class="line">            <span class="keyword">return</span> goods;</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> THREAD_TOTAL = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">//线程池，用于多线程模拟测试</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_TOTAL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//假定共11个线程，其中有10个消费者，但是只有1个生产者</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> CONSUMER_TOTAL = <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PRODUCE_TOTAL = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PRODUCE_TOTAL; i++) {</span><br><span class="line">            <span class="comment">//生产者线程每生产一个商品，间隔50毫秒</span></span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> Producer(produceAction, <span class="number">50</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONSUMER_TOTAL; i++) {</span><br><span class="line">            <span class="comment">//消费者线程每消费一个商品，间隔100毫秒</span></span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> Consumer(consumerAction, <span class="number">100</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="2-9-6-需要在synchronized-同步块的内部使用-wait-和notify"><a href="#2-9-6-需要在synchronized-同步块的内部使用-wait-和notify" class="headerlink" title="2.9.6 需要在synchronized 同步块的内部使用 wait 和notify"></a>2.9.6 需要在synchronized 同步块的内部使用 wait 和notify</h3><p>调用 wait 和 notify 方法时，<strong>“当前线程”必须拥有该对象的同步锁，也即wait 和notiry 方法必须在同步块中使用，否则JVM 就会抛出 IllegalMonitorStateException 异常。</strong></p>
<p>这是为什么呢？还得从这 2 个方法的原理说起：</p>
<ul>
<li><p>调用 wait ：JVM 会释放当前线程的对象监视器的 Owner 资格，还会将当前线程移入监视器的 WaitSet 队列，这些操作都是和对象监视器锁相关的，所以，当前线程执行 wait 方法前，必须通过 synchronized 方法称为对象锁的 Owner，要在同步块内调用</p>
</li>
<li><p>同理， 调用 notify 时，JVM 从对象锁的监视器 WaitSet 队列移动线程到其 EntryList 队列，这些操作都与对象锁的监视器有关，所以，也必须先成为对象锁监视器的 Owner，然后在同步块内调用</p>
</li>
</ul>
<h3 id="2-9-7-调用wait、notify方法进行线程间通信的要点（自己加的章节）"><a href="#2-9-7-调用wait、notify方法进行线程间通信的要点（自己加的章节）" class="headerlink" title="2.9.7 调用wait、notify方法进行线程间通信的要点（自己加的章节）"></a>2.9.7 调用wait、notify方法进行线程间通信的要点（自己加的章节）</h3><p>有了以上的知识储备，来说下wait 和 notify 方法进行线程间通信的要点：</p>
<ul>
<li><p>调用某个同步对象 locko 的 wait 和 notify 类型方法前，必须要获得这个锁对象的监视器锁，这2个类型的方法必须放在同步块中执行，否则报错</p>
</li>
<li><p>调用<strong>wait方法是使用while进行条件判断，如果是在某种条件下进行等待，对条件的判断就不能使用if语句做一次性判断，而是使用while 循环进行反复判断</strong>，只有这样才能在线程被唤醒后继续检查wait 条件，并在条件没有满足的情况下继续等待。</p>
</li>
</ul>
<p>正确的条件判断代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">while</span> (amount &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">synchronized</span> (NOT_EMPTY) {</span><br><span class="line">            <span class="comment">//队列空了</span></span><br><span class="line">            NOT_EMPTY.wait();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>错误地使用 if 条件判断：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (amount &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">synchronized</span> (NOT_EMPTY) {</span><br><span class="line">            <span class="comment">//队列空了</span></span><br><span class="line">            NOT_EMPTY.wait();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至于为什么要这样，从之前说的原理我们知道，wait 方法会释放锁。我们考虑这么一种场景：</p>
<ul>
<li><p>假如有 2 个消费者 consumerOne 和 consumerTwo </p>
</li>
<li><p>consumerOne 在判定是空的时候，wait 了，这时候会释放锁；由于释放了锁，consumerTwo 自然就能获取到这个锁，然后发现也是空的，自然也 wait 了</p>
</li>
<li><p>也就是说 consumerOne 和 consumerTwo 都在wait 等待了，这是问题关键</p>
</li>
<li><p>此时，生产者放入一个元素，完了调用 notifyAll ，consumerOne 和 consumerTwo 都被唤醒了，他们会竞争锁</p>
</li>
<li><p>假如 consumerOne 拿到锁了，consumerTwo 还在锁池中继续阻塞，consumerOne 执行wait 后面的代码消费了，接着又会变为空</p>
</li>
<li><p>consumerOne 执行完成后，consumerTwo 拿到锁也接着执行 wait 后面的代码，由于被 consumerOne 消费变为空了之后，consumerTwo 后续的执行以不空作为条件的执行会出现问题</p>
</li>
</ul>
<p>如果不太明白，还可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37430539/article/details/100005522">为什么生产者消费者中模式中要用while作临界判断？_xuwen_chen的博客-CSDN博客</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">161</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共338k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/3/',]
      });
      });
  </script>


</body>
</html>
