<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/3/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">37</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">215</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/17/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/09-Glide-%E7%AC%AC%E4%BA%8C%E8%8A%82%E8%AF%BE(%E6%9C%80%E6%96%B0Glide4.11%20%E4%B8%BB%E7%BA%BF%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/17/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/09-Glide-%E7%AC%AC%E4%BA%8C%E8%8A%82%E8%AF%BE(%E6%9C%80%E6%96%B0Glide4.11%20%E4%B8%BB%E7%BA%BF%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90)/" class="post-title-link" itemprop="url">09-Glide-第二节课(最新Glide4.11 主线流程分析)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-17 21:29:00" itemprop="dateCreated datePublished" datetime="2023-06-17T21:29:00+08:00">2023-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:59:10" itemprop="dateModified" datetime="2023-06-28T22:59:10+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>看源码最重要的 第一步，只管主线，简单走通，不要管支线</p>
<p>面试题：项目中已经大量使用 Glide ，但加载图片还是偶尔会出现内存溢出问题，说明大概原因。</p>
<p>答：可能在 Glide.with 的时候，传入了 Application 的作用域，或者从子线程使用了 Glide 也会导致变为 Application 作用域。在这种作用域下，不会创建空白 Fragment 对绑定页面进行生命周期管理。就会造成内存回收不及时的问题。</p>
<p>into 方法的时候，RequestBuilder 中会根据 ImageView 的 ScaleType 来生成不同的 ScaleType 的对象:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(<span class="meta">@NonNull</span> ImageView view)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!requestOptions.isTransformationSet() &amp;&amp; requestOptions.isTransformationAllowed() &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (view.getScaleType()) {</span><br><span class="line">      <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">      <span class="keyword">case</span> FIT_START:</span><br><span class="line">      <span class="keyword">case</span> FIT_END:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_XY:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER:</span><br><span class="line">      <span class="keyword">case</span> MATRIX:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Do nothing.</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> into(</span><br><span class="line">      glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">      <span class="comment">/*targetListener=*/</span> <span class="keyword">null</span>,</span><br><span class="line">      requestOptions,</span><br><span class="line">      Executors.mainThreadExecutor());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结一下，Glide 中最重要的 3 个分段 with、load、into 的三个作用：</p>
<ul>
<li><p>with：返回 RequestManager ，里面决定是哪种作用域</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(FragemntActivity activity)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(Util.isOnBackgroundThread()) {</span><br><span class="line">        <span class="comment">//子线程，Application </span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">//Activity/Fragment 作用域</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>load：最终返回 RequestBuilder </p>
</li>
<li><p>into ： 最终返回 ImageViewTarget </p>
</li>
</ul>
<p>根据宽高、签名、等等一系列信息，作为某个图片缓存的 key ，在内存缓存和磁盘中获取这些缓存的图片。</p>
<h3 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h3><p>Glide 里面有活动缓存（ActiveResources）和内存缓存（Cache，也叫二级缓存，也叫LRU缓存），他们都在内存里面。那为什么要在内存里面设置 2 级缓存？<strong>Glide 将正在显示的图片都放在活动缓存里面</strong>（活动缓存里面都是使用 WeakReference 来引用图片），然后其他的图片都放在内存缓存里面。这又是什么讲究？内存缓存是 LRUCache 实现的，它可以存储很多图片，假如没有活动缓存这一级，而是直接使用内存缓存的话，那么在缓存的图片数量或者大小超限的时候，正在使用的图片就可能被清除掉，导致崩溃 Bug（比如RecyclerView里面使用，划过来可以，再划回去重新加载的时候被回收了就崩溃了） ，这也是为什么需要设计 2 级缓存。</p>
<blockquote>
<p>当应用需要获取图片的时候，首先从活动缓存中获取，如果没有，则去内存缓存中获取，如果命中了，则将 内存缓存中的图片添加到活动缓存中，并且将图片资源从内存缓存中删除。当引用的页面（Activity/Fragment）关掉之后，活动缓存的图片又可以放入内存缓存中去，如果页面再次打开，就又可能从内存缓存中加载进入活动缓存。活动缓存和内存缓存中只能存在一份缓存，不可能同时在 内存缓存和活动缓存中都存在。活动缓存里面会做引用计数，如果计数为 0 的时候，会将图片放回到内存缓存里面。</p>
</blockquote>
<p>面试官：Glide 源码中到处都是接口，我们应该怎么阅读？</p>
<p>答： 我们要找里面的伏笔。比如，我们 getRequest 的时候，要一直追踪下去，看看到底这个 getRequest 返回的是 Request 的哪个子类。不然很难知道具体是哪个类实现。</p>
<p>面试官：使用 Glide 为什么需要加入网络权限？</p>
<p>答： Glide 中执行图片请求的时候 <strong>有等待队列和运行队列</strong>2个队列，并且有 <strong>活动缓存和内存缓存</strong>2级缓存，如果这2级缓存都没有命中的话，需要通过网络去获取资源。并且，还可以通过 job.get 去判断目前任务是否完成，最终使用 UrlConnection 去完成最终的网络请求。</p>
<p>我们平时使用 Glide 一般都是传入 String 类型的 url ，然后会返回 InputStream 这种流，decode 的作用就是将流转成 Bitmap 。</p>
<p>面试官：使用 Glide 的时候，如果 with 函数在子线程调用，会有什么问题？</p>
<p>答：子线程不会去添加生命周期机制，主线程才会添加空白Fragment 监听 Activity/Fragment 的生命周期变化。</p>
<p>面试官：with 函数传入 Application ，会怎么样？</p>
<p>答：如果传入的是Activity 或者 Fragment ，当它们销毁的时候，Glide 会回收当前页面加载的图片任务和资源，但是如果传入的是 Application ，那么只有当应用结束的时候资源才会跟随销毁了。</p>
<p>如果ImageView 很小，但是图片是个很大的图片，Glide 会给做优化，只会给目标大小的图片就可以了。</p>
<p>最后，以一张Glide 的简化流程图结束：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Glide%E6%95%B4%E4%BD%93%E7%AE%80%E5%8C%96%E5%9B%BE.png" alt="简化的Glide流程图"></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/17/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/09-Glide-%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE(%E6%9C%80%E6%96%B0Glide4.11%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/17/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/09-Glide-%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE(%E6%9C%80%E6%96%B0Glide4.11%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB)/" class="post-title-link" itemprop="url">09-Glide-第一节课(最新Glide4.11源码阅读)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-17 16:09:00" itemprop="dateCreated datePublished" datetime="2023-06-17T16:09:00+08:00">2023-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:55:08" itemprop="dateModified" datetime="2023-06-28T22:55:08+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、为何监听Activity-Fragment-生命周期"><a href="#一、为何监听Activity-Fragment-生命周期" class="headerlink" title="一、为何监听Activity/Fragment 生命周期"></a>一、为何监听Activity/Fragment 生命周期</h2><p>Glide 的使用很简单：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>).load().into(imageView)</span><br></pre></td></tr></tbody></table></figure>

<p>其中的职责很简单：</p>
<ul>
<li><p>with ： 生命周期管理。传入 Activity 或者 Fragment 就会创建一个空白 Fragment 来监听生命周期，传入 Application Context 则不会</p>
</li>
<li><p>load：构建出 RequestBuilder 对象</p>
</li>
<li><p>into ： 做了几件事情：1）运行队列、等待队列 2）活动缓存 3）内存缓存 4）网络模型</p>
</li>
</ul>
<p>面试题：我们使用了 Glide.with(this).load().into 加载图片之后，在 Activity 的 onDestroy 中是不是要调用：<em>Glide.with(this).clear(imageView)</em> 来清理掉不用的 View 呢？</p>
<blockquote>
<p>很多同学可能会回复这是必须的，但是事实上这不是必需的，因为 Glide 内部会有监听机制，在 Activity 的onDestroy 中会自动 clear 掉。</p>
</blockquote>
<h2 id="二、生命周期作用域"><a href="#二、生命周期作用域" class="headerlink" title="二、生命周期作用域"></a>二、生命周期作用域</h2><p>那么 Glide 是怎么做到自动 clear 呢？原理在于<strong>它会创建一个空白的 Fragment 来监控 Activity/Fragment 的生命周期变化</strong>。</p>
<p>你可以发送很多的加载图片的request ，这些统一由 RequestManager 去管理。</p>
<p><strong>如果在子线程使用 Glide 加载图片，即时你传入 Activity ，也是在 Application 作用域，这时候不会给你搞那个空白的 Fragment</strong> 。总结一下各种情况下根据 with 传入的参数而产生的生命周期作用域：</p>
<ul>
<li><p><strong>在子线程</strong>：作用域为 Application</p>
</li>
<li><p>（在主线程）传入 ServiceContext/Application Context： 作用域为 Application</p>
</li>
<li><p>（在主线程）传入View：作用域为 Fragment 或者 Activity</p>
</li>
<li><p>（在主线程）传入 Fragment： 作用域为 Fragment</p>
</li>
<li><p>（在主线程）传入 Activity： 作用域为 Activity</p>
</li>
</ul>
<blockquote>
<p>所以也可以总结说 Application 作用域和非Application 作用域，这是根据是否创建空白 Fragment 监听生命周期这个动作来区分的</p>
</blockquote>
<p>老师说学习开源框架最好的方式就是：先大概看一遍，然后仿照它的 API 开始自己写，把它所有的实现都简化：比如它是工厂模式创建对象，那我就直接 new 出来；假如它有各种判空，直接干掉，假如有复杂的条件判断，先干掉。实现最简单的，这样才能快速理解整个流程。</p>
<p>RequestManager 中，生命周期 onStart 的时候: 运行队列-全部开始执行；等待队列-全部清空；onStop 的时候： 运行队列-全部停止，所有任务添加到等待队列；</p>
<p>Glide 中设计很巧妙的一个点就是：Glide 需要保证一个 Activity 只能有一个空白 Fragment 来监听它的生命周期，那么在 RequestManagerRetriever 这个类中，就会写出看起来匪夷所思的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RequestManagerFragment <span class="title">getRequestManagerFragment</span><span class="params">(FragmentManager fm, Fragment parentHint, <span class="keyword">boolean</span> isParentVisible)</span> </span>{</span><br><span class="line">  RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">  <span class="keyword">if</span> (current == <span class="keyword">null</span>) {</span><br><span class="line">    current = pendingRequestManagerFragments.get(fm);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) {</span><br><span class="line">      current = <span class="keyword">new</span> RequestManagerFragment();</span><br><span class="line">      current.setParentFragmentHint(parentHint);</span><br><span class="line">      <span class="keyword">if</span> (isParentVisible) {</span><br><span class="line">        current.getGlideLifecycle().onStart();</span><br><span class="line">      }</span><br><span class="line">      pendingRequestManagerFragments.put(fm, current);</span><br><span class="line">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">      handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建了这个 fragment 需要将其放入map 中先保存起来，之后再 commit 这个 fragment ；再然后就通过 Handler 移除这个 fragment ，为什么这么做？</p>
<p>这是因为 fragment 做 commit 操作的时候，是通过主线程的 Handler 执行的，最后会体现在handler 往主线程发送了一个 Message，如果这个Message 还没执行，此时来了第二个请求，那么它通过 getTag 去获取这个 Fragment 是获取不到的，那么就会再创建一个，所以这里需要缓存下；那为什么在 commit 之后可以通过（主线程的） Handler 移除缓存的Fragment 呢？那么是因为 ，由于 commit 操作先执行，那么 commit 这个 Message 肯定在后续的移除 fragment 的这个 Message 之后，由于 Handler 是顺序执行这些 Message 的，所以执行移除操作的时候，commit 的那个 message 肯定已经执行过了，所以可以执行！</p>
<p>JetPack 的 Lifecycle 就是 模仿的 Glide 。Glide 的源码太庞大了。</p>
<p>有两个空白 Fragment ，一个是 Androidx 的 Fragment ，一个是 android.app 的 Fragment 。我们要注意区分。</p>
<h2 id="三、生命周期回调"><a href="#三、生命周期回调" class="headerlink" title="三、生命周期回调"></a>三、生命周期回调</h2><p>Fresco 看起来非常舒服，很容易看懂</p>
<p>但是 Glide 可能你看了一周源码，还是找不到网络请求的地方，看懂 Glide 的源码之后，再去看 Fresco 和 Picaso 都是很简单的事情。老师说是要研究半年才能给大家说这个事情。</p>
<p>老师说 RxJava 和 Okhttp 在 Glide 面前是小弟。这个也确实比较复杂</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/16/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/08-Okhttp-%E3%80%90%E4%B8%8B%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/16/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/08-Okhttp-%E3%80%90%E4%B8%8B%E3%80%91/" class="post-title-link" itemprop="url">08-Okhttp-【下】</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-16 16:03:00" itemprop="dateCreated datePublished" datetime="2023-06-16T16:03:00+08:00">2023-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:50:30" itemprop="dateModified" datetime="2023-06-28T22:50:30+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、重试重定向拦截器-重试限制"><a href="#一、重试重定向拦截器-重试限制" class="headerlink" title="一、重试重定向拦截器-重试限制"></a>一、重试重定向拦截器-重试限制</h2><p>首先判断是否取消了，取消了直接抛出异常</p>
<p>之后在 try-catch 代码块里面执行责任链获取 response，并且捕捉 RouteException （路线异常，比如 socket 连接失败）和 IOException （IO 异常），在这 2 种 异常中判断是否需要重试，调用的是 recover 函数：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查是否需要重试</span></span><br><span class="line"><span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) {</span><br><span class="line">    <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">//。。。。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出，检查是否需要重试，如果不需要，直接抛出异常就终止了，否则才继续往后面走重试。那么是否需要重试的条件是什么呢？ 有以下几点：</p>
<ul>
<li><p>OkHttpClient 可以配置是否允许重试，设置为 false 直接不能重试</p>
</li>
<li><p>request body 不允许复用，那就不能重试</p>
</li>
<li><p>产生了 FileNotFoundException 异常，也不用重试了</p>
</li>
<li><p>产生了不允许重试的异常（协议异常-如返回204代表无响应体，但是Content-Lenth 不为0，二者产生冲突，就是协议异常了、证书异常、除连接超时之外的 IO 中断异常）</p>
</li>
<li><p>最后一关，是否有拥有更多路线（设置了代理，DNS 返回了多个 ip -应该重试其他ip），即使上面的判断都通过，只要没有更多路线，都不能重试</p>
</li>
</ul>
<p>重定向限制次数，<strong>20 次</strong></p>
<h2 id="二、重试重定向拦截器-重定向规则"><a href="#二、重试重定向拦截器-重定向规则" class="headerlink" title="二、重试重定向拦截器-重定向规则"></a>二、重试重定向拦截器-重定向规则</h2><p>次数超出 20 次，也抛出异常。</p>
<p>代码中是通过 followUpRequest 方法来确定重定向的，同过 response 的响应码来判断响应码，这个重定向看起来不只是重定向功能，如果只是重定向，可能只需要判断 3xx 这个码就可以了，实际上，这里面判断多个码，包括：</p>
<ul>
<li><p>3xx：重定向</p>
</li>
<li><p>401：服务器需要授权，比如某些接口需要登录</p>
</li>
<li><p>407：代理需要授权，比如付费代理，验证身份</p>
</li>
<li><p>408：请求超时</p>
</li>
<li><p>421：当前客户端所在的ip到服务器的连接数超了</p>
</li>
<li><p>503：服务不可用</p>
</li>
</ul>
<p>个人觉得准备面试的话就记住 3xx、需要授权、连接数超了这几个基本上就可以了</p>
<blockquote>
<p>代理有 2 种，HTTP 代理和 Socket 代理，Http代理代理的是 Http，Socket 代理它代理的是 TCP/IP </p>
</blockquote>
<h2 id="三、桥接拦截器"><a href="#三、桥接拦截器" class="headerlink" title="三、桥接拦截器"></a>三、桥接拦截器</h2><p>桥接拦截器主要功能就是在请求前和请求后做一些通用繁琐处理：</p>
<ul>
<li><p>请求前补全请求头（设置cookie、设置UA、设置Host字段、content-Length 、Content-Type 、Gzip 压缩等）</p>
</li>
<li><p>得到响应后：接收 Cookies 并回调给用户，在下次请求的时候读取相应 cookies 数据设置到请求头；如果有设置 gzip ，则解析 gzip 数据</p>
</li>
</ul>
<h2 id="四、缓存拦截器"><a href="#四、缓存拦截器" class="headerlink" title="四、缓存拦截器"></a>四、缓存拦截器</h2><p>关于缓存的请求头和响应头非常多，所以这里很复杂，Http 的缓存我们可以按照行为分为： <strong>强缓存</strong> 和 <strong>协商缓存</strong>。</p>
<ul>
<li><p>强缓存： 有缓存的时候，直接将缓存给用户，不会发送请求给服务端，可以通过 Cache-Control 和 Expires 来判断缓存过期时间。</p>
</li>
<li><p>协商缓存：请求还是会发给服务端，但是服务端可能会返回 304 （此时没有请求体的），意味着服务端在这段时间没有修改，使用本地的缓存就好。</p>
</li>
</ul>
<p>如果 networkReqeust 存在，则优先发起网络请求，否则使用 cacheResponse 缓存，若都不存在则请求失败。</p>
<h2 id="五、连接拦截器-新建连接"><a href="#五、连接拦截器-新建连接" class="headerlink" title="五、连接拦截器-新建连接"></a>五、连接拦截器-新建连接</h2><p>代码很少，总共就 4 行代码</p>
<p>在这里来判断是 http1 还是 http2。找到连接之后，还需要连接是否健康（未关闭，正常工作），</p>
<p>普通代理：可以想象 Fiddler，它是可以更改你的数据再发送出去的</p>
<p>隧道代理：是无法更改客户端的请求的，将客户端的数据无脑地发送给服务端</p>
<p>Okhttp 支持你创建代理，可以选择是 Http 代理还是 Sockets 代理。老师有写这些代理使用的方式，有现成代码，这里就不贴出来了。</p>
<p>ALPN 是 TLS 的扩展协议，从 与 服务端的 hello 里面可以协商到使用哪一种协议。会存储在 sslSocket 中</p>
<h2 id="六、连接拦截器-连接池"><a href="#六、连接拦截器-连接池" class="headerlink" title="六、连接拦截器-连接池"></a>六、连接拦截器-连接池</h2><p>首先从连接池中获取连接，如果没有，才去做上述的新建连接。</p>
<p>每次put 新的连接到池子里面的时候，都会扔进去一个定时执行的 Task，用于执行 clean 任务，清除不可用的连接，无效的连接。不移走会占用内存。比如，你刚创建的连接，那么5分钟后肯定会过期，如果没有使用的话</p>
<p>连接池最多允许 5 个空闲连接；连接池中闲置的连接最多允许闲置 5 分钟。比如，某个连接 baidu.com 只使用了一次，这样就能将其清理掉。清理的时候，将闲置时长最长的清理掉。 </p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E8%BF%9E%E6%8E%A5%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B.png" alt="连接执行流程"></p>
<h2 id="七、请求服务拦截器与面试总结"><a href="#七、请求服务拦截器与面试总结" class="headerlink" title="七、请求服务拦截器与面试总结"></a>七、请求服务拦截器与面试总结</h2><p>发送很简单，这里就不写了，有个点需要注意下，如果是发送个比较大的文件，是需要与服务端协商的，Okhttp 是这样做的：</p>
<ol>
<li><p>如果服务器允许则返回 100 ，则客户端继续发送请求体</p>
</li>
<li><p>如果服务器不允许就直接返回给用户</p>
</li>
<li><p>如果服务器忽略这个问询的请求头，一直无法读取应答，此时会抛出超时异常</p>
</li>
</ol>
<h3 id="7-1-面试题"><a href="#7-1-面试题" class="headerlink" title="7.1 面试题"></a>7.1 面试题</h3><p>Okhttp 的请求过程</p>
<p>构建 Request ，通过 OkhttpClient 获得 Call （RealCall对象）如果：</p>
<ul>
<li><p>是同步请求，则在发起请求的线程中直接获取结果（调用5个Interceptor）</p>
</li>
<li><p>如果是异步请求，则通过 Dispatcher 分发到线程池中进行请求获取结果（也是调用5个Interceptor）</p>
</li>
</ul>
<p>拦截器如何工作的？</p>
<p>责任链模式将请求者与执行者解耦，请求者只需将请求发送给责任链即可</p>
<p>应用拦截器与网络拦截器的区别？</p>
<ul>
<li><p>他们在 interceptors 中的顺序不一样</p>
</li>
<li><p>网络拦截器不一定执行，因为有可能直接拿了缓存，不需要后续的执行了</p>
</li>
</ul>
<p>Okhttp 如何复用连接？</p>
<p>host 验证规则一样、dns 一样等等，这些属性都一样。当然，也会清理垃圾连接，超过 5 分钟没有使用的连接，超过5个闲置连接后，清理闲置最久的连接</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/15/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/08-Okhttp-%E3%80%90%E4%B8%8A%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/08-Okhttp-%E3%80%90%E4%B8%8A%E3%80%91/" class="post-title-link" itemprop="url">08-Okhttp-【上】</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-15 18:57:00" itemprop="dateCreated datePublished" datetime="2023-06-15T18:57:00+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:49:49" itemprop="dateModified" datetime="2023-06-28T22:49:49+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、Okhttp介绍"><a href="#一、Okhttp介绍" class="headerlink" title="一、Okhttp介绍"></a>一、Okhttp介绍</h2><p>okhttp 4 的源码(4.9.3版本，它的包名还是 okhttp3，还是要注意下)</p>
<p>Retrofit 只是封装 Okhttp ，让其更容易使用</p>
<p>http 2.0 的特性：头部压缩、server push、多路复用</p>
<blockquote>
<p>关于多路复用，其实Http 1.1 也有 keep-alive 这样的标记位来重复使用这条连接，但是这种保持连接只能第一个消息发送完收到 ack 之后，才能发送第二条数据，这种就是串行的；而 http 2.0 可以在第一条还未返回结果的时候就发送第二条，这种才是真正的多路复用。</p>
</blockquote>
<blockquote>
<p>因为 http1.1 用的是文本，必须要按照顺序， hello world，必须要按顺序，但是 http2.0 可以先传 r 再传h再传 d 等，它是基于 fragment 的，fragment 有顺序标识。 </p>
</blockquote>
<p>okhttp 支持 http2.0 可以复用连接，避免每次去连接都要三次握手之类的。Http2 还有个连接池，池子里面有各种连接，比如baidu.com 的连接、taobao.com 的连接，下次需要请求相关域名的时候，直接使用这个池子里面的连接即可。</p>
<p>okhttp 的 post 请求的缓存默认是关闭的，只有 get 请求的缓存开启。如果post 请求想开启缓存，只需要做如下 cache 配置就可以了：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OkhttpClient.Builder().cache(Cache(File(<span class="string">"/xxx"</span>), <span class="number">1024</span>))</span><br></pre></td></tr></tbody></table></figure>

<h2 id="二、Okhttp-的基本使用与请求流程"><a href="#二、Okhttp-的基本使用与请求流程" class="headerlink" title="二、Okhttp 的基本使用与请求流程"></a>二、Okhttp 的基本使用与请求流程</h2><p>Okhttp 的大体流程如下：</p>
<ol>
<li><p>创建一个 OkhttpClient（不管是自己Builder 还是直接new 都可以）</p>
</li>
<li><p>创建一个 Request ，封装请求数据</p>
</li>
<li><p>Request 交给 OkhttpClient  的 newCall 操作得到一个RealCall </p>
</li>
<li><p>之后，不管是通过 execute 还是 enqueue 方法，反正最终是将这个call 交给 Dispatcher 去调度</p>
</li>
<li><p>被调度的时候，经过各种 interceptor 拦截器拦截后，最终可以得到 Response ，流程如下图所示：</p>
</li>
</ol>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/Okhttp%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.jpg" alt="Okhttp的执行流程"></p>
<h2 id="三、分发器异步分发限制"><a href="#三、分发器异步分发限制" class="headerlink" title="三、分发器异步分发限制"></a>三、分发器异步分发限制</h2><p>Dispatchers 里面维护了 3 个队列：</p>
<ul>
<li><p>准备执行的异步请求队列</p>
</li>
<li><p>正在执行的异步请求队列</p>
</li>
<li><p>正在执行的同步请求队列</p>
</li>
</ul>
<p>AsyncCall 在 enqueue 的时候，会判断队列里面（不管是准备执行的还是正在执行的）有没有 call 和目前这个 AsyncCall 的host 是一样的，如果是一样的，那就将自己的 callsPerHost 的属性替换成队列中 Call 的 callsPerHost 属性（我个人理解的是，这样方便计数，所有的 Call 都用这一个AtomicInteger 变量来统计数量，这样，后续判断同一个 Host 最多只能5个来同时请求就比较好判断了，只需要取这个值）</p>
<blockquote>
<p>所以， callsPerHost 表示的是同一个host 有多少个请求在执行</p>
</blockquote>
<p>异步总连接不能超过64个，然后 同一个 host 的请求不能超过5个。</p>
<h2 id="四、分发器异步请求分发流程"><a href="#四、分发器异步请求分发流程" class="headerlink" title="四、分发器异步请求分发流程"></a>四、分发器异步请求分发流程</h2><p>如果所有异步请求数超过 64 个 （或者同一个 host 的请求数超过 5个）的情况下，那么 call 将不会被执行，那么他们在什么时候会被触发去执行呢？其实，在 RealCall 里面的 run 方法里面，会在 try-catch 块去获取请求的 response ：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取response 结果</span></span><br><span class="line">response = getResponseWithInterceptorChain()</span><br></pre></td></tr></tbody></table></figure>

<p>在最终的 finally 中，会执行 client.dispatcher.finished(this) ，告知 Dispatcher 当前 Call 已经结束。之后在 Dispatcher 中会再次激活这个等待队列：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> {</span><br><span class="line">    call.callsPerHost.decrementAndGet()</span><br><span class="line">    finished(runningAsyncCalls, call)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出，首先将 callsPerHost 减1 ，意味着这个 host 在执行的请求数减少一个。在里面还会执行重载的 finished 方法，再次去执行 promoteAndExecute 方法去从队列中获取 Call 去分发执行。所以，整个异步任务执行的工作流程如下所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="异步请求执行的流程"></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>Okhttp 异步连接的线程池初始化很有意思：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">           SynchronousQueue(), threadFactory(<span class="string">"<span class="variable">$okHttpName</span> Dispatcher"</span>, <span class="literal">false</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>它指定 corePollSize 为 0，Keep Alive 的时长是 60s ，无界队列，这其实和我们使用 Executors.newCachedThreadPool 是一样的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这种线程池有什么特点呢？</p>
<ul>
<li><p>核心线程数为 0 ：线程池有个例外的情况，哪怕核心线程数设置为 0 ，在第一个任务的时候，还是会开启线程让执行。</p>
</li>
<li><p>最大线程数设置为 Integer.MAX_VALUE ，几乎不限制任务数量</p>
</li>
<li><p>使用 SynchronousQueue 队列提交任务。提交肯定失败！因为它不存储元素的。那既然提交任务肯定失败，那我们为什么还用这个呢？我们考虑下线程池，如果队列有容量的话，在线程数大于等于corePoolSize 的时候，<strong>新的任务会被添加到等待队列</strong>，只有在往 队列中添加失败的时候，才会去判断如果小于 maximumPoolSize 的时候，新建线程任务。所以，这种线程池可以让任务马上执行，而不是在那里等待。</p>
</li>
</ul>
<p>所以上述线程池，如果设置corePoolSize 为 0 ，再设置个 LinkedBlockingQueue 的话，第一个任务会执行，第二个任务会放在 LinkedBlockingQueue 中。1 完成后，执行2,2执行后才能3等等。</p>
<h2 id="五、分发器处理同步请求"><a href="#五、分发器处理同步请求" class="headerlink" title="五、分发器处理同步请求"></a>五、分发器处理同步请求</h2><p>只需要注意，同步请求执行完成后（finnaly 中也是调用 finish），也会去执行 promoteAndExecute 方法，去重新从等待队列中获取 Call 执行任务。有个细节注意，**同步任务执行完成后，会触发异步任务队列的重新获取！</p>
<h2 id="六、Okhttp拦截器责任链设计模式"><a href="#六、Okhttp拦截器责任链设计模式" class="headerlink" title="六、Okhttp拦截器责任链设计模式"></a>六、Okhttp拦截器责任链设计模式</h2><p>Okhttp 里面会有5个默认的拦截器，并且我们也能通过addInterceptor 和 addNetworkInterceptor 方法添加拦截器，代码如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response {</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    <span class="comment">//添加我们通过 addInterceptor 方法添加的拦截器</span></span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) {</span><br><span class="line">        <span class="comment">//添加我们通过 addNetworkInterceptor 添加的拦截器</span></span><br><span class="line">        interceptors += client.networkInterceptors</span><br><span class="line">    }</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line">    <span class="comment">//省略无关代码。。。。。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从代码可以看出，通过 addInterceptor 添加的拦截器会首先被 add 进 interceptors 列表中，之后依次添加充实、桥、缓存、连接 拦截器，然后如果不是 websocket 的话，就添加通过 addNetworkInterceptor 添加的拦截器，最后添加的是 CallServerInterceptor 拦截器。</p>
<blockquote>
<p>所以，addInterceptor 和 addNetworkInterceptor 方法添加拦截器的区别是什么？在代码中的体现是在 interceptors 数组中的位置不一样，一个是在最开始，一个是在倒是第二个。</p>
</blockquote>
<p>但是这个顺序到底会有什么影响？Okhttp 使用责任链设计模式，在发起请求的时候，是从上往下经过这些 Interceptor ，这样就先经过我们 addInterceptor 添加的拦截器，后续才经过 addNetworkInterceptor 添加的拦截器。但是结果返回的时候，是从后面往前面返回的。</p>
<p>老师在课程里面讲了下如果自己去实现责任链的 Demo ，这个可以模拟下。</p>
<h2 id="七、Okhttp-拦截器功能概述"><a href="#七、Okhttp-拦截器功能概述" class="headerlink" title="七、Okhttp 拦截器功能概述"></a>七、Okhttp 拦截器功能概述</h2><p>首先总体概述一下各种拦截器的含义：</p>
<ul>
<li><p>重试定向拦截器。在交给下一个拦截器之前，判断用户是否取消了请求，如果已经取消了，就不需要将结果交回给用户了。并且，在返回结果之后，根据响应码判断是否需要重定向，如果满足条件就会重启执行所有的拦截器。</p>
</li>
<li><p>桥接拦截器。在交出之前，负责将 HTTP 协议必备的请求头加入（比如host 等），并添加一些默认行为（比如 GZIP 压缩），在获得结果后，调用保存cookie 接口并解析GZIP 数据</p>
</li>
<li><p>缓存拦截器。顾名思义就是交出之前读取并判断是否使用缓存；获得结果后判断是否需要缓存</p>
</li>
<li><p>连接拦截器。从连接池中寻找一个连接，如果没有则创建一个连接，并获得对应的 Socket 流；在获得结果后不进行额外处理</p>
</li>
<li><p>请求服务拦截器。进行真正的服务器通信，向服务器发送数据，解析读取响应数据。</p>
</li>
</ul>
<h3 id="刨根究底-addInterceptor-和-addNetworkInterceptor"><a href="#刨根究底-addInterceptor-和-addNetworkInterceptor" class="headerlink" title="刨根究底 addInterceptor 和 addNetworkInterceptor"></a>刨根究底 addInterceptor 和 addNetworkInterceptor</h3><p>当我们只是需要在请求参数里面添加字段，比如 sign 字段，或者在 response 里面修改一点数据，那么我们使用 addInterceptor 和 addNetworkInterceptor 都是可以的。</p>
<p>但是如果我们打印日志，使用了 httpLogingInterceptor 这个拦截器，打印请求数据和返回数据，<strong>如果你用 addInterceptor 添加拦截器，那么打印出来的是用户写的请求参数，如果使用的是 addNetworkInterceptor ，那么这个请求参数就还包括 Okhttp 自动补全的一些参数</strong> 。</p>
<h2 id="八、Okhttp-相关的面试题"><a href="#八、Okhttp-相关的面试题" class="headerlink" title="八、Okhttp 相关的面试题"></a>八、Okhttp 相关的面试题</h2><p>1、Okhttp 的分发器是如何工作的？</p>
<p>对于同步请求，只是记录一下；对于异步任务，首先添加到 ready 队列中，然后检查所有请求数小于64，以及同 host 请求数小于 5 是否满足，满足执行并添加到 running 队列中。</p>
<p>应用拦截器和网络拦截器有什么区别？</p>
<p>在 interceptors 中的顺序不同。导致接收到的数据完整性是不一样的。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/15/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/07-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/07-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82/" class="post-title-link" itemprop="url">07-网络编程-第二节</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-15 17:00:00" itemprop="dateCreated datePublished" datetime="2023-06-15T17:00:00+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:44:23" itemprop="dateModified" datetime="2023-06-28T22:44:23+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>省略第一节的 NIO ，后续有时间看</p>
<h2 id="NIO之单线程Reactor模式"><a href="#NIO之单线程Reactor模式" class="headerlink" title="NIO之单线程Reactor模式"></a>NIO之单线程Reactor模式</h2><p>略，后续有时间看</p>
<h2 id="网络编程面试-TCP、UDP与HTTP"><a href="#网络编程面试-TCP、UDP与HTTP" class="headerlink" title="网络编程面试-TCP、UDP与HTTP"></a>网络编程面试-TCP、UDP与HTTP</h2><p>DDoS攻击是啥？SYN 洪水攻击？</p>
<p>利用合理的服务请求，占用服务资源：带宽攻击和联通性攻击。带宽攻击需要控制大量的肉鸡，SYN 洪泛攻击属于 连通性攻击，发送半连接。</p>
<p>哪些应用适用 UDP 实现？</p>
<p>DNS，直播，多播，可以上层应用自己实现可靠性传输（新的 UDT 协议可以了解一下，Http3 用 UDT）比如广域网中计算中心光纤连接通信</p>
<p>如果应用场景中大多数是简短信息，那么适合用udp实现。因为 udp 是基于报文段的，直接对上层的应用数据封装成报文段然后丢在网络中，如果信息量太大，在链路层会被分片，影响传输效率</p>
<p>http 和 https 的区别？</p>
<p>http 80端口，https 是443端口</p>
<p>是否需要证书</p>
<p>scheme 不同，http 和 https</p>
<p>如果让你来设计QQ，网络协议上如何设计？</p>
<ul>
<li><p>登录采用 TCP 协议和 Http 协议：client采用 TCP 向 server 发送信息，Http 协议下载信息。登录后，会有一个 TCP 连接来保持在线状态</p>
</li>
<li><p>好友之间发送消息，主要采用 UDP 协议：利用上层应用层来保证可靠传输，如果发送失败，提示用户发送失败，并可以重新发送。</p>
</li>
<li><p>内网传文件采用 P2P 技术。内网里面可以采用 P2P 技术，不需要服务器中转</p>
</li>
</ul>
<h2 id="TCP粘包的解决"><a href="#TCP粘包的解决" class="headerlink" title="TCP粘包的解决"></a>TCP粘包的解决</h2><p>包可能很小，每次都要发送出去得到确认。可以把这些小包合在一起，发送出去，确认一次就行。解决：</p>
<ol>
<li><p>消息头+消息体，消息头用来描述消息的长度，每次读消息先读消息头</p>
</li>
<li><p>消息定长，每个消息都是一样长</p>
</li>
<li><p>特殊的分隔符，比如 Netty使用回车换行符来区分</p>
</li>
</ol>
<blockquote>
<p>这个比较抽象，老师在视频里面讲了个例子，比如从客户端用 for 语句循环 100 次发送  “james,hello,hahah” 等这些字符串，但是服务端可能说只收到 2 次，因为数据可能粘包，很多数据合在一起发送了，这时候我们没法区分这些次数和数据。如果用 natty 来做的话，会在每次发送后插入 回车换行符，这样，在接收的时候就能根据回车换行符分割。</p>
</blockquote>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>阿里的 FastJson 不建议使用，安全问题比较多</p>
<p>ProtocolBuffer  可读性比较差</p>
<p>老师自己平时用的是 Kyro ，说是只能在 Java 语言中使用</p>
<h2 id="select、poll、epoll-的区别"><a href="#select、poll、epoll-的区别" class="headerlink" title="select、poll、epoll 的区别"></a>select、poll、epoll 的区别</h2><p>是不是每次都选择 epoll 才是最好的呢？不是，在连接少，用户都活跃的情况，select 和 poll 可能效率更高</p>
<h2 id="直接内存、零拷贝"><a href="#直接内存、零拷贝" class="headerlink" title="直接内存、零拷贝"></a>直接内存、零拷贝</h2><h3 id="直接内存比堆内存快在哪里？"><a href="#直接内存比堆内存快在哪里？" class="headerlink" title="直接内存比堆内存快在哪里？"></a>直接内存比堆内存快在哪里？</h3><p>任何语言，你通过socket 发送数据，都需要有一个 缓冲区，先把数据写入缓冲区，之后从缓冲区读取数据到内核发送出去。</p>
<p>如果可以选择，先选直接内存缓冲区，因为直接内存的缓冲区比堆内存的缓冲区肯定是要快的。</p>
<p>那么，为什么会快呢？如果你选择堆上的 Buffer ，那么在发送的时候，还会在直接内存上创建一个 Buffer ，这样一来，首先需要将数据拷贝到堆上的buffer，之后拷贝到 直接内存上的 Buffer ，最后才发送出去；如果是Buffer 直接创建在直接内存上，就没有这个步骤，减少一次拷贝，示意图如下：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E7%9B%B4%E6%8E%A5Buffer%E5%92%8C%E5%A0%86%E4%B8%8ABuffer%E5%8C%BA%E5%88%AB.png" alt="直接buffer和堆上buffer"></p>
<p>为什么使用堆 Buffer 的时候需要使用到直接内存的 Buffer 呢？因为堆上有GC机制，在 Socket 过程中，数据是不能变化的，如果在中途堆上的 Buffer 被GC 了，那咋办？所以只能再开一个直接内存的 Buffer ，这样 GC 管不着。</p>
<p>在新生代的 GC 是不会去管直接内存的 Buffer 的，只有 Full GC 的时候，才会顺便去回收直接内存的。</p>
<p>所以堆外内存（DirectBuffer）的优劣势在哪？</p>
<ul>
<li><p>减少GC 带来的 STW ，增强性能</p>
</li>
<li><p>加快复制速度，如果采用堆内 Buffer 的话，还是需要 DirectBuffer 这个环节，使用 DirectBuffer 可以省略这个步骤</p>
</li>
</ul>
<p>劣势：</p>
<ul>
<li><p>产生内存泄漏很难排查</p>
</li>
<li><p>不适合存储很复杂的对象</p>
</li>
</ul>
<h3 id="有哪几种零拷贝方案？"><a href="#有哪几种零拷贝方案？" class="headerlink" title="有哪几种零拷贝方案？"></a>有哪几种零拷贝方案？</h3><p>linux 中有好几种：</p>
<ul>
<li><p>mmap</p>
</li>
<li><p>linux 的 sendFile 函数，如果有硬件支持的话，只需要告诉缓存的开始位置和大小，都不用真正将数据复制到 socket 的缓冲区，就能将数据发送出去</p>
</li>
<li><p>linux 提供的 splice 方案，不需要硬件支持，使用管道（piple line） 就能将数据直接拷贝到 socket 的缓冲区</p>
</li>
</ul>
<p>不过体现在 JDK 里面就 2 种，一种就是 mmap 方案，还有一种就是NIO 提供的  FIleChannel ，它可以转换为 SocketChannel ，直接将文件通过 socket 发送，这样可以利用 linux 的 mmap 方案做到零拷贝。</p>
<h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><p>时间局部性</p>
<p>在一个方法里面使用到了成员变量，在方法里面可能会用局部变量承接这个成员变量，这样就能加快速度</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/14/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%89%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/14/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%89%E8%8A%82/" class="post-title-link" itemprop="url">06-网络编程-第三节</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-14 17:20:00" itemprop="dateCreated datePublished" datetime="2023-06-14T17:20:00+08:00">2023-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:39:52" itemprop="dateModified" datetime="2023-06-28T22:39:52+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、网络通信基本常识"><a href="#一、网络通信基本常识" class="headerlink" title="一、网络通信基本常识"></a>一、网络通信基本常识</h2><p>wireshark 有一本书</p>
<p>操作系统将 TCP 那些细节全部（拆包之类的，传输层以下的所有都封装）封装在 Socket 中了。开发人员只需要关注ip 和端口号就行了。</p>
<p>web服务，比较适合 短连接，这种可以降低服务器的压力。长连接适合连接数不多，并且请求比较频繁的请求。</p>
<h2 id="二、BIO-详解"><a href="#二、BIO-详解" class="headerlink" title="二、BIO 详解"></a>二、BIO 详解</h2><p>BIO 是啥？阻塞式 IO，B 是阻塞 Blocking  的意思，比如 read 方法读取网络数据，如果没有数据，阻塞式网络编程就会阻塞住。</p>
<p>NIO ： IO 多路复用</p>
<p>相对的，AIO 是异步 IO，read 和 write 操作都作为系统调用</p>
<p>ServerSocket.accept() ，socket.connect 、InputStream.readUTF 等方法都是阻塞方法。</p>
<h2 id="三、NIO详解"><a href="#三、NIO详解" class="headerlink" title="三、NIO详解"></a>三、NIO详解</h2><p>NIO ，这个 N 可以作为 New 解释，或者做 no-blocking 解释。</p>
<p>BIO 面向流，阻塞式的</p>
<p>NIO （IO多路复用）面向缓冲区，非阻塞的，一个线程可以服务多个服务端。</p>
<p>BIO 的效率比 NIO 的效率是要高的。</p>
<p>NIO 三大组件：</p>
<ul>
<li><p>Selector</p>
</li>
<li><p>Channel</p>
</li>
<li><p>Buffer</p>
</li>
</ul>
<p>NIO 看了30分钟，后续的就没看了，看得有点蒙，后续再继续</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/14/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/14/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E8%8A%82/" class="post-title-link" itemprop="url">06-网络编程-第二节</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-14 16:08:00" itemprop="dateCreated datePublished" datetime="2023-06-14T16:08:00+08:00">2023-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:38:52" itemprop="dateModified" datetime="2023-06-28T22:38:52+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、TCP-四次挥手"><a href="#一、TCP-四次挥手" class="headerlink" title="一、TCP 四次挥手"></a>一、TCP 四次挥手</h2><p>OSI 虽然很学术，但是 要熟悉，一般工程使用 IEEE 的 TCP/IP 的四层模型。</p>
<p>4G 和 5G 这种事在数据链路层及以下的协议</p>
<p>两端都可能发起分手，分手4个流程如下：</p>
<ol>
<li><p>客户端发送 FIN=1，seq = x ，随后进入 FIN_WAIT_1</p>
</li>
<li><p>服务端收到之后进入 CLOSE_WAIT 状态，随后发送确认 ACK = 1，ack = x + 1，客户端收到之后变为 FINE_WAIT_2 状态</p>
</li>
<li><p>接着服务端也发送 FIN = 1， seq = y ，随后进入  CLOSE 状态</p>
</li>
<li><p>客户端收到之后，变为 TIME_WAITING 状态，随后发送确认 ACK = 1，seq = y +1 ，服务端收到之后变为 CLOSED 状态</p>
</li>
<li><p>最后，客户端在 TIME_WAITING 状态持续了 2* MSL 时长之后，才最终变为 CLOSED 状态</p>
</li>
</ol>
<p>MSL 即 最长报文段寿命，即一个报文在网络上能存活的最长时间，协议规定是 2分钟，一般定义成 30s ，所以 是等待 1~4分钟。</p>
<p>面试官：为什么要 4 次？</p>
<p>因为是TCP 是全双工的，必须要确认双方都没有数据要发送了，才能结束。假如，客户端发送了 FIN 的时候，服务端没有数据了，可以将 ACK 和 FIN 同时发送，所以，这就变成了 3 次了。</p>
<p>为什么 TIME_WAITING ？</p>
<ol>
<li><p>有可能最后一步客户端发送的 ACK 丢失了，这时候服务端以为客户端没收到，可能会重发 FIN 过来，所以必须要等待</p>
</li>
<li><p>A 应用程序用了 123 端口，它关闭了，之后，B应用用了 123 端口，此时 A 应用的服务端还发送了数据，由于是马上重用了 123 端口，所以这个数据很大可能还没过期，此时 B 应用就没法区分了这个数据了。所以TIME_WAITING 可以让数据在网络上过期，便于区分</p>
</li>
</ol>
<h2 id="二、网络工具"><a href="#二、网络工具" class="headerlink" title="二、网络工具"></a>二、网络工具</h2><p>wireshark 目前免费，支持的协议比较多，所以比较推荐使用 wireshark。 wireshark 工具可以查看网络情况，在输入栏里面可以做一些过滤，比如：</p>
<blockquote>
<p>!udp  //不看udp</p>
<p>ip.addr==101.89.23.12  //只看特定的ip</p>
<p>!udp and ip.addr==101.89.23.12  //不看udp 并且 指定ip</p>
</blockquote>
<p>除了 and 还有多种符号，or ，xor（异或） 等等</p>
<h2 id="三、一次完整的-Http-请求的过程"><a href="#三、一次完整的-Http-请求的过程" class="headerlink" title="三、一次完整的 Http 请求的过程"></a>三、一次完整的 Http 请求的过程</h2><p>一次完整的http请求过程，比如在浏览器中输入一个网址，最后怎么出来网页展示出来的？总共大概有 7 个步骤：</p>
<ol>
<li><p>首先 DNS 解析域名（浏览器缓存、操作系统缓存或者 DNS 服务器）</p>
</li>
<li><p>三次握手建立 TCP 连接</p>
</li>
<li><p>客户端发起 Http 请求</p>
</li>
<li><p>服务端响应 Http 请求</p>
</li>
<li><p>客户端解析 Html 代码，<strong>并请求 Html 代码中的资源</strong></p>
</li>
<li><p>客户端渲染展示内容</p>
</li>
<li><p>关闭 TCP 连接</p>
</li>
</ol>
<p>DNS 劫持和 Http劫持：http 劫持是把 html 的内容给替换了，或者http  的请求给你改了，到其他页面了</p>
<p>防止劫持的手段： 用自己的 DNS 不要用点心公司的，使用 https 。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/14/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/07-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%80%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/14/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/07-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%80%E8%8A%82/" class="post-title-link" itemprop="url">07-网络编程-第一节</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-14 13:58:00" itemprop="dateCreated datePublished" datetime="2023-06-14T13:58:00+08:00">2023-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:41:51" itemprop="dateModified" datetime="2023-06-28T22:41:51+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>不知道咋地没内容，下次看</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/14/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%80%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/14/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/06-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%AC%AC%E4%B8%80%E8%8A%82/" class="post-title-link" itemprop="url">06-网络编程-第一节</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-14 09:36:00" itemprop="dateCreated datePublished" datetime="2023-06-14T09:36:00+08:00">2023-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:38:12" itemprop="dateModified" datetime="2023-06-28T22:38:12+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、计算机网络体系结构"><a href="#一、计算机网络体系结构" class="headerlink" title="一、计算机网络体系结构"></a>一、计算机网络体系结构</h2><p>因为最开始是为了在军事上防止一次打击就全部毁灭，所以TCP/IP 设计就是为了去中心化。</p>
<p>OSI 七层模型：应（用层）、表（示层）、会（话层）、传（输层）、网（络层）、数（据链路层）、物（理层）</p>
<p>TCP/IP 四层模型： （应用层）、（传输层）、（网络层）、（数据链路层）</p>
<h2 id="二、TCP-IP协议族（上）"><a href="#二、TCP-IP协议族（上）" class="headerlink" title="二、TCP/IP协议族（上）"></a>二、TCP/IP协议族（上）</h2><p>我们所说的 TCP/IP 其实是个协议族，并不单单说的 tcp 或者 ip 协议。覆盖最上层的 应用层（HTTP、DNS等）一直到 物理层。</p>
<p>严格来讲，3G、4G、5G 是哪一层？物理层</p>
<p>我们平时发送消息给对方整个过程可以用如下的图表示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="网络传输中的数据"></p>
<p>在应用层使用 UDP 自己实现连接和重传，可以加速网络速度，因为系统自带的 TCP 是很保守的。</p>
<h2 id="三、TCP-IP协议族（下）"><a href="#三、TCP-IP协议族（下）" class="headerlink" title="三、TCP/IP协议族（下）"></a>三、TCP/IP协议族（下）</h2><p>端口号是用于区分不同的应用的。属于传输层的东西。</p>
<p>TCP 可靠性是怎么保证的？超时重传，应答确认。正是因为设计之初为了保证若干物理线路被摧毁还能保证正常运行，所以相对而言还是挺复杂的。</p>
<p>流量控制：每次高速对方我最多能接收多少数据。</p>
<p>DNS 主要使用 UDP ，但是有时候也使用 TCP</p>
<h2 id="四、三次握手建立连接"><a href="#四、三次握手建立连接" class="headerlink" title="四、三次握手建立连接"></a>四、三次握手建立连接</h2><p>建立连接的三次握手：</p>
<ol>
<li><p>客户端发起连接，SYN = 1 ，seq = x ，之后进入 SYN_SENT 状态</p>
</li>
<li><p>服务端收到后，返回 SYN = 1，ACK = 1，ack = x +1， seq = y ，之后进入 SYN_RCVD 状态</p>
</li>
<li><p>客户端收到后，返回 ACK = 1，ack = y + 1，之后客户端进入 ESTABLISHED 状态；服务端收到之后，也进入 ESTABLISHED 状态</p>
</li>
</ol>
<blockquote>
<p>其中，大写的 比如 SYN 、ACK 等都表示标记位，小写的如 ack、seq 等表示值</p>
</blockquote>
<p>面试官：为什么是 3 次，不是 2 次或者 4 次？</p>
<p>首先回复三次握手的过程。之后，给出答案：通知对方序列号，并且确保对方已经收到。</p>
<p>SYN 洪泛攻击，虚假ip只发送第一次 syn 连接，由于服务器收到之后就进入到了 SYN_RCVD 状态，并且回复 ack 数据，但是永远得不到回复；所以解决的方案：1）无效连接的监控和释放  2） 防火墙处理，真正连接后才分配资源</p>
<p>抓包的原理： 操作系统允许你越过传输层和网络层，直接获取到 链路层 <strong>原始Socket</strong>的值</p>
<p>如果想了解更多 WebSocket 的内容《Html5 Websocket 权威指南》</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/13/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8810%EF%BC%892021.12.30-%E5%AE%9E%E6%88%98--MVx%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2(1)%20---Allen%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/13/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8810%EF%BC%892021.12.30-%E5%AE%9E%E6%88%98--MVx%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%B2(1)%20---Allen%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（10）2021.12.30-实战--MVx的演进史(1) ---Allen老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-13 15:19:00" itemprop="dateCreated datePublished" datetime="2023-06-13T15:19:00+08:00">2023-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 22:07:30" itemprop="dateModified" datetime="2023-06-28T22:07:30+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>大约 6次课。MVx 的演进史。</p>
<p>MVVM 系列的课程先不听了，先搞面试要紧的，后续听 10~14课</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">215</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共433.2k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/3/',]
      });
      });
  </script>


</body>
</html>
