<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/10/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">158</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2020/01/15/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC13%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/15/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC13%E7%AB%A0/" class="post-title-link" itemprop="url">第13章：热修复原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-15 22:17:00 / 修改时间：22:18:03" itemprop="dateCreated datePublished" datetime="2020-01-15T22:17:00+08:00">2020-01-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>热修复框架的核心技术主要有3类：代码修复、资源修复和动态链接库修复。</p>
<h2 id="资源修复"><a href="#资源修复" class="headerlink" title="资源修复"></a>资源修复</h2><p>很多热修复的框架的资源修复参考了Instant Run的资源修复原理，因此我们首先了解下Instant Run 的原理。Instant Run 的资源修复核心逻辑在MonkeyPatcher 的monkeyPatchExistingResources 方法中，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com/android/tools/fd/runtime/MonkeyPatcher.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">monkeyPatchExistingResources</span><span class="params">(Context context,String externalResourceFile,Collection&lt;Activity&gt; activityes)</span></span>{</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">    <span class="comment">//创建一个新的 AssetManager</span></span><br><span class="line">       AssetManager newAssetManager = (newAssetManager)newAssetManager.class.getConstructor(<span class="keyword">new</span> Class[<span class="number">0</span>]).newInstance(<span class="keyword">new</span> Object[<span class="number">0</span>]);<span class="comment">//1</span></span><br><span class="line">       </span><br><span class="line">       Method mAddAssetPath = AssetManager.class.getDeclareMethod(<span class="string">"addAssetPath"</span>,<span class="keyword">new</span> Class[] {String.class});<span class="comment">//2</span></span><br><span class="line">       </span><br><span class="line">       mAddAssetPath.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">//通过反射调用 addAssetPath 方法加载外部的资源( SD 卡)</span></span><br><span class="line">       <span class="keyword">if</span> (((Integer) mAddAssetPath.invoke(newAssetManager,<span class="keyword">new</span> Object[]{ externalResourceFile})).intValue () == <span class="number">0</span>) {<span class="comment">//3</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not create new AssetManager"</span>);</span><br><span class="line">            </span><br><span class="line">       <span class="keyword">if</span>{activities != <span class="keyword">null</span>){</span><br><span class="line">         <span class="keyword">for</span> (Activity activity : activities) {</span><br><span class="line">         Resources resources= activity.getResources() ;<span class="comment">//4</span></span><br><span class="line">         <span class="keyword">try</span> {</span><br><span class="line">          <span class="comment">//反射得到 Resources 的 AssetManager 类型的 mAssets 字段</span></span><br><span class="line">          Field mAssets = Resources.class.getDeclareField(<span class="string">"mAssets"</span>);<span class="comment">//5</span></span><br><span class="line">          mAssets.setAccessible(<span class="keyword">true</span> );</span><br><span class="line"></span><br><span class="line">          <span class="comment">//将 mAssets 字段的引用替换为新创建的 AssetManager</span></span><br><span class="line">          mAssets.set(resources,newAssetManager) ;<span class="comment">//6</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//得到 Activity 的 Resources.Theme</span></span><br><span class="line">          Resources.Theme theme = activity.getTheme();</span><br><span class="line">          ...</span><br><span class="line">          <span class="comment">//反射得到 Resources.Theme 的 mAssets 字段</span></span><br><span class="line">          Field ma = Resources . Theme.class.getDeclaredField (” mAssets <span class="string">" ) ;</span></span><br><span class="line"><span class="string">          ma.setAccessible(true);</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">          //将 Resources.Theme 的 mAssets 字段替换为 newAssetManager</span></span><br><span class="line"><span class="string">          ma.set(theme,newAssetManager);//7</span></span><br><span class="line"><span class="string">         } catch (Throwable ignore) {</span></span><br><span class="line"><span class="string">         </span></span><br><span class="line"><span class="string">         }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看出，在注释1处创建了一个新的AssetManager，之后通过反射调用 addAssetPath 方法加载外部(SD卡)的资源。在注释4处遍历Activity 列表，得到每个Activity 的Resource ，在5处通过反射得到Resources 的AssetManager 类型的mAsset字段，并在注释6处改写mAssets字段的引用为新的 AssetManager。之后，将AssetManager 类型的mAssets 字段的引用全部替换为新创建的 AssetManager。所以，总共就是两个步骤：</p>
<ul>
<li>创建新的 AssetManager ,通过反射调用 addAssetPath 方法加载外部的资源,这样<br>新创建的 AssetManager 就含有了外部资源。     </li>
<li>将 AssetManager 类型的 rnAssets 字段的引用全部替换为新创建的 AssetManager。</li>
</ul>
<h2 id="代码修复"><a href="#代码修复" class="headerlink" title="代码修复"></a>代码修复</h2><p>先写到这，后续有空再来。。。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/12/06/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/06/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">第5章：理解上下文Context</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-06 19:09:00" itemprop="dateCreated datePublished" datetime="2019-12-06T19:09:00+08:00">2019-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-20 21:53:40" itemprop="dateModified" datetime="2020-02-20T21:53:40+08:00">2020-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Context-的关联类"><a href="#Context-的关联类" class="headerlink" title="Context 的关联类"></a>Context 的关联类</h2><p>开发中经常使用的Context 的使用场景大体分为两类：</p>
<ul>
<li>使用Context 调用方法，比如启动 Activity、访问资源、调用系统服务等。    </li>
<li>调用方法时传入，比如弹出 Toast、创建dialog。    </li>
</ul>
<p>Activity、Service 与 Application 都间接继承 Context，因此可以说一个应用进程的Context 数量 = Activity 数量 + Service 数量 + 1，这个1就是Application数量。Context 的关联类的关系如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC5%E7%AB%A0/Context%E5%85%B3%E8%81%94%E7%B1%BB%E5%85%B3%E7%B3%BB.png" alt="Context关联类关系"></p>
<p>可以看出，ContextWrapper 中包含有 Context 类型的 mBase 对象，mBase 具体指向 ContextImpl，此外，ContextThemeWrapper、Service 和 Application 都继承自 ContextWrapper，这样它们都能通过 mBase 来使用Context 的方法。同时它们也是装饰类，在 ContextWrapper 上又添加了不少功能。比如，ContextThemeWrapper 包含了主题相关的方法(getTheme之类)，因此Activity 继承了ContextThemeWrapper，而Service 不需要主题，因此继承 ContextWrapper。Context 关联类的继承结构有以下优点：</p>
<ul>
<li>使用者能够方便使用Context 的功能。    </li>
<li>如果 ContextImpl 发生了变化，它的装饰类 ContextWrapper 无需做任何修改。    </li>
<li>ContextImpl 的具体实现不会暴露给使用者。     </li>
<li>通过组合而不是继承，拓展 ContextImpl 的功能。运行时选择不同的装饰类，实现不同功能。    </li>
</ul>
<h2 id="Application-Context-的创建过程"><a href="#Application-Context-的创建过程" class="headerlink" title="Application Context 的创建过程"></a>Application Context 的创建过程</h2><p>我们通过 getApplicationContext 来获取应用程序的全局 Application Context，那么 Application Context 是如何创建的呢？在应用程序启动完成后，应用程序就有一个全局的 Application Context，那就从应用程序启动过程着手，Application Context 的创建过程时序图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC5%E7%AB%A0/ApplicationContext%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Application context 的创建时序图"></p>
<p>应用程序进程的主线程管理类 ActivityThread 会调用内部类 ApplicationThread 的 scheduleLaunchActivity 方法来启动Activity，而在scheduleLaunchActivity 中会向 H 发送 LAUNCH_ACTIVITY 类型消息，目的是将启动Activity 的逻辑放在主线程中。在 H 的 handleMessage 方法中最终会调用到 LoadApk 类的  makeApplication 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,Instrumentation nstrumentation)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) {<span class="comment">//l</span></span><br><span class="line">        <span class="keyword">return</span> mApplication;</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">    Application app = <span class="keyword">null</span>;</span><br><span class="line">    String appClass = mApplicationinfo.className;</span><br><span class="line">    <span class="keyword">if</span> (forceDefaultAppClass || (appClass == <span class="keyword">null</span>) ) {</span><br><span class="line">        appClass = <span class="string">"android.app.Application”;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    try {</span></span><br><span class="line"><span class="string">        java.lang.ClassLoader cl= getClassLoader();</span></span><br><span class="line"><span class="string">        if (!mPackageName.equals ("</span>android<span class="string">")){</span></span><br><span class="line"><span class="string">            initializeJavaContextClassLoader ();</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Contextimpl appContext = Contextimpl.createAppContext(mActivityThread,this); //2</span></span><br><span class="line"><span class="string">        app = mActivityThread.rninstrumentation.newApplication(cl, appClass, appContext);//3</span></span><br><span class="line"><span class="string">        appContext. setOUterContext(app) ;//4</span></span><br><span class="line"><span class="string">    }catch (Exception e){</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    mApplication = app;//5</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    return app;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>注释1处，假设是第一次启动应用程序，因此 mApplication 为null，在注释2处通过 Contextimpl 的 createAppContext 方法创建 Contextimpl 的实例，注释3中创建了 Application 对象，注释4处将 Application 对象赋值给 Contextimpl 的成员变量 mOuterContext ，<strong>这样，ContextImpl 中也包含了 Application 的引用。</strong>注释5处的 mApplication 即 LoadedApk 的成员变量 mApplication。来看看注释 3 处Application 是如何创建的（最终调用到如下代码的方法）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/lnstrumentation.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(xxxx)</span></span>{</span><br><span class="line">    Application app = (Application) clazz.newinstance ();</span><br><span class="line">    app.attach(context) ; <span class="comment">//l</span></span><br><span class="line">    <span class="keyword">return</span> app ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注释1处通过反射来创建Application</strong>，并调用其 attach 方法，并且将 ContextImpl 类型的对象传进去：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/Application.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>{</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    mLoadedApk = Contextimpl.getimpl(context).mPackageinfo;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(mBase != <span class="keyword">null</span> ) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException (<span class="string">"Base context already set"</span>);</span><br><span class="line">    }</span><br><span class="line">    mBase = base;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最终，把一路传过来的 ContextImpl 类型的 base 赋值给 Application 的 mBase 。前面讲过，这个歌mBase 是ContextWrapper 的成员变量，因为Application 继承 ContextWrapper ，所以才有这个变量。因此，Application 的attach 方法的作用就是使 Application 可以使用 Context 的方法，这样，Application 才可以用来代表 Application Context。</p>
<h2 id="Application-Context-的获取过程"><a href="#Application-Context-的获取过程" class="headerlink" title="Application Context 的获取过程"></a>Application Context 的获取过程</h2><p>我们通过 getApplicationContext 来获取Application Context，这个方法在 ContextWrapper 中实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/content/ContextWrapper.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">getApplicationContext</span><span class="params">()</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    return mBase.getApplicationContext( )</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从前面我们可知，mBase 指的是 ComtextImpl，具体代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">getApplicationContext</span> <span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (mPackageinfo != <span class="keyword">null</span> ) ? mPackageinfo.getApplication() : mMainThread.getApplication();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果 loadedApk 类型的mPackageinfo 不为 null，则调用其 getApplication 方法，否则调用 ActivityThread 的 getApplication 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"></span><br><span class="line"><span class="function">Application <span class="title">getApplication</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> mApplication ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个 mApplication 应该熟悉，是在前面提到的  LoadedApk 的  makeApplication 方法中注释 5 处被赋值的，是个Application 对象。就这样，我们获取到 Application Context。</p>
<h2 id="Activity-的Context-创建过程"><a href="#Activity-的Context-创建过程" class="headerlink" title="Activity 的Context 创建过程"></a>Activity 的Context 创建过程</h2><p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC5%E7%AB%A0/Activity%E7%9A%84context%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Activity的context创建过程时序图"></p>
<p>应用程序进程的主线程管理类 ActivityThread 会调用内部类 ApplicationThread 的 scheduleLaunchActivity 方法来启动Activity，最终通过 H 类在主线程中处理启动事项，最终调用到 ActivityThread 的 performLaunchActivity 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">perfomLaunchActivity</span><span class="params">(ActivityClientRecord r , Intent customintent)</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);<span class="comment">//l</span></span><br><span class="line">    Activity activity = <span class="keyword">null</span> ;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(cl , <span class="function">component <span class="title">getClassName</span><span class="params">()</span> , r.intent) </span>; <span class="comment">//2</span></span><br><span class="line">        ...</span><br><span class="line">    }<span class="keyword">catch</span>(Exception e){</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(activity != <span class="keyword">null</span>) {</span><br><span class="line">        appContext.<span class="function">setOuterC nte <span class="title">t</span><span class="params">(activity)</span> </span>; <span class="comment">//3</span></span><br><span class="line">        <span class="comment">//4</span></span><br><span class="line">        activity.attach(xxxx,xxxx);</span><br><span class="line">        ...</span><br><span class="line">    }<span class="keyword">catch</span>(Exception e){</span><br><span class="line">        ...</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>在注释2处创建了Activity 的实例，注释1处<strong>通过 createBaseContextForActivity 方法创建 Activity 的 ContextImpl</strong>，并在注释4 处将 ContextImpl 对象传给activity 的attach方法，在注释3处调用了 ContextImpl 的 setOuterContext 方法，将 Activity 的实例赋值给 ContextImpl 的成员变量 mOuterContext ，这样，ContextImpl 也可以访问 Activity 的变量和方法。createBaseContextForActivity 方法中，最终也会调用 ContextWrapper 的 attachBaseContext ，将Activity 中的 ContextImpl 对象赋值给 ContextWrapper 的成员变量 mBase，这样，ContextWrapper 的功能就可以交由 ContextImpl 来处理。</p>
<h2 id="Service-的-Context-创建过程"><a href="#Service-的-Context-创建过程" class="headerlink" title="Service 的 Context 创建过程"></a>Service 的 Context 创建过程</h2><p>Service 的Context 创建过程与 Activity 的Context 创建过程类似，这里先略过，后续有时间再记录。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/28/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC12%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/28/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC12%E7%AB%A0/" class="post-title-link" itemprop="url">第12章：理解ClassLoader</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-28 10:34:00" itemprop="dateCreated datePublished" datetime="2019-11-28T10:34:00+08:00">2019-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-03 21:47:10" itemprop="dateModified" datetime="2019-12-03T21:47:10+08:00">2019-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>热修复和插件化是目前比较热门的技术，想要更好地掌握它们需要先了解ClassLoader。从第11章可知，DVM 和 ART 加载的是dex文件，JVM 加载的是class文件，因此它们的类加载器 ClassLoader 是肯定有区别的。</p>
<h2 id="Java中的ClassLoader"><a href="#Java中的ClassLoader" class="headerlink" title="Java中的ClassLoader"></a>Java中的ClassLoader</h2><p>虚拟机章节提到 <strong>类加载子系统</strong>，它的主要作用就是通过多种类加载器来查找和加载Class文件到Java虚拟机中。Java<strong>系统</strong>中的类加载器主要包括以下：</p>
<ul>
<li>Bootstrap ClassLoader(引导类加载器)：C/C++实现的，用于加载指定的JDK核心类库，比如 java.lang、java.uti等系统类。    </li>
<li>Extensions ClassLoader(拓展类加载器)： Java中的实现类为 ExtClassLoader ，用于加载Java的拓展类，主要包括 $JAVA_HOME/jre/lib/ext 、java.ext.dir 等目录。    </li>
<li>Application ClassLoader(应用程序类加载器)：Java中的实现类为 AppClassLoader，用来加载 1、当前程序的 Classpath 目录 ；2、系统属性 java.class.path指定的目录。    </li>
</ul>
<h3 id="ClassLoader-继承关系"><a href="#ClassLoader-继承关系" class="headerlink" title="ClassLoader 继承关系"></a>ClassLoader 继承关系</h3><p>以下代码可以验证 运行一个Java程序需要用到哪些类加载器：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        ClassLoader loader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        <span class="keyword">while</span> (loader != <span class="keyword">null</span>){</span><br><span class="line">            System.out.println(loader);<span class="comment">//1</span></span><br><span class="line">            loader = loader.getParent();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码可以获得当前类 ClassLoaderTest 的类加载器，接着打印出当前类加载器的父加载器，直到没有父加载器，打印的结果如：</p>
<blockquote>
<p>sun misc Launcher AppClassLoader@75b84c92<br>sun .misc .Launcher$ExtClassLoader@lb6d3586     </p>
</blockquote>
<p>可以看出，<strong>加载 ClassLoaderTest 的加载器是 AppClassLoader</strong>，并且AppClassLoader 的父加载器是 ExtClassLoader。但是这里没有打印出 ExtClassLoader 的父加载器 Bootstrap ClassLoader ，是因为Bootstrap ClassLoader 由 C/C++ 编写，并不是一个Java类，因此我们无法在Java代码中获取。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>所谓的双亲委派模型就是首先判断该Class是否已经加载，如果未加载，则当前加载器委托父加载器进行查找，这样依次地柜，直到委托到最顶层的 Bootstrap ClassLoader，如果Bootstrap ClassLoader 找到了该Class，就直接返回，否则，依次向下查找，如果当前加载器之上的所有加载器都未能加载，则当前加载器自身去查找。</p>
<p>如果要加载一个位于D盘的Class文件，系统所提供的类加载器就不能满足，这时候需要自定义类加载器 CustomClassLoader 继承java.lang.ClassLoader 并覆写findClass方法，加载D盘的Class文件步骤如下：</p>
<ol>
<li>CustomClassLoader 首先从缓存中查找Class文件是否已经加载，已经加载就返回，没有加载就委托给<strong>父加载器(AppClassLoader)</strong>。    </li>
<li>按照双亲委派模型递归。    </li>
<li>一直委托到 Bootstrap ClassLoader ，如果 Bootstrap ClassLoader 也没能加载，则交给子加载器(ExtClassLoader)，以此类推。    </li>
</ol>
<blockquote>
<p>综合以上，ClassLoader的父子关系不是使用继承来实现的，二是使用组合来实现代码复用。</p>
</blockquote>
<p>双亲委派模型的好处：</p>
<ol>
<li>避免重复加载。如果Class已经加载过，就不需要加载，二是直接读取。    </li>
<li>更加安全。如果不使用双亲委派模型，就可以自定义一个String类来替代系统的String类，显然会造成安全隐患。或者自定义一个Object类，有可能会动摇java基础，因为java里面所有类都要继承java的Object(这段是我自己理解添加的)。采用双亲委派模型似的系统的类在Java虚拟机启动时就被加载，也就无法自定义系统类来替代系统。</li>
</ol>
<p>自定义类加载器的代码如下：<br><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC12%E7%AB%A0/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A81.jpeg" alt="自定义类加载器1"><br><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC12%E7%AB%A0/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A82.jpeg" alt="自定义类加载器2"></p>
<h2 id="Android-中的ClassLoader"><a href="#Android-中的ClassLoader" class="headerlink" title="Android 中的ClassLoader"></a>Android 中的ClassLoader</h2><h3 id="ClassLoader-的类型"><a href="#ClassLoader-的类型" class="headerlink" title="ClassLoader 的类型"></a>ClassLoader 的类型</h3><p>Android中系统类加载器也主要包括3种：</p>
<ul>
<li>BootClassLoader： 由Java代码实现，类的访问修饰符是默认的，只有在同一个包中才能访问，用户无法直接调用。Android系统启动时，会使用BootClassLoader 预加载常用类。    </li>
<li>DexClassLoader：可以加在dex文件以及包含dex的压缩文件(apk和jar)，不管加载哪种文件，最终都加载dex文件。    </li>
<li>PathClassLoader：Android使用它来加载系统类和应用程序的类，通常用来加载已经安装的apk的dex文件。</li>
</ul>
<h3 id="ClassLoader的继承关系"><a href="#ClassLoader的继承关系" class="headerlink" title="ClassLoader的继承关系"></a>ClassLoader的继承关系</h3><p>通过前面用于验证java类继承关系的代码，在这里同样可以验证Android中类加载器的继承关系。</p>
<h3 id="ClassLoader-的加载过程"><a href="#ClassLoader-的加载过程" class="headerlink" title="ClassLoader 的加载过程"></a>ClassLoader 的加载过程</h3><p>Android 的 ClassLoader 同样遵循了双亲委派模型，ClassLoader 的加载方法为 loadClass方法，这个方法定义在抽象类 ClassLoader中。ClassLoader的查找流程如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC12%E7%AB%A0/ClassLoader%E7%9A%84%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B.png" alt="ClassLoader的查找流程"></p>
<h3 id="BootClassLoader的创建"><a href="#BootClassLoader的创建" class="headerlink" title="BootClassLoader的创建"></a>BootClassLoader的创建</h3><p>在ZygoteInit的main方法中，调用了Zygote的 preload 方法，preload方法中又调用了 ZygoteInit 的 preloadClasses 方法，preloadClasses用于预加载常用的类，这个预加载属于拿空间换时间的策略。在preloadClasses方法中会创建 BootClassLoader 。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/25/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC4%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/25/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC4%E7%AB%A0/" class="post-title-link" itemprop="url">第4章：四大组件的工作过程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-25 14:09:00" itemprop="dateCreated datePublished" datetime="2019-11-25T14:09:00+08:00">2019-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-09 19:49:06" itemprop="dateModified" datetime="2020-02-09T19:49:06+08:00">2020-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="根Activity的启动过程"><a href="#根Activity的启动过程" class="headerlink" title="根Activity的启动过程"></a>根Activity的启动过程</h2><p>根Activity 是应用程序第一个Activity，相比普通的Activity的启动过程，一般用根Activity 的启动过程来指代应用程序的启动过程，更具有参考意义。根Activity 的启动过程比较复杂，这里分为3个部分来讲：<font color="green">Launcher 请求AMS 过程、AMS 到ApplicaitonThread 的调用过程 以及 ActivityThread 启动Activity</font>。</p>
<h3 id="Launcher-请求AMS-过程"><a href="#Launcher-请求AMS-过程" class="headerlink" title="Launcher 请求AMS 过程"></a>Launcher 请求AMS 过程</h3><p>当我们点击桌面上某个应用的快捷图标时，就会通过Launcher 请求AMS 来启动该应用程序，过程的时序图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/Launcher%E8%B0%83%E7%94%A8AMS%E5%90%AF%E5%8A%A8Activity%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Launcher调用AMS启动Activity时序图"></p>
<p>点击桌面图标，会调用 Launcher 的startActivitySafely方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  packages/apps/Launcher3/src/com/android/launcher3/Launcher.java </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startActivitySafely</span><span class="params">(View v ,Intent intent, Itemlnfo item)</span></span>{</span><br><span class="line">    ...</span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); <span class="comment">//l </span></span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        <span class="keyword">if</span> (xxxx){</span><br><span class="line">            ...</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(user == <span class="keyword">null</span> || user.equals(Process.myUserHandle())){</span><br><span class="line">            startActivity(intent, optsBundle); <span class="comment">//2 </span></span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">catch</span> (ActivityNotFoundExceptionlSecurityException e) {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因为是启动新的应用，所以注释1处将根Activity 在新的任务栈启动，应用启动会执行到注释2处的startActivity 方法，最终会在Activity 中调用  startActivityForResult 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/and oid/app/Activity.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(<span class="meta">@RequiresPermission</span> Intent intent, <span class="keyword">int</span> requestCode, <span class="meta">@Nullable</span> Bundle options)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) {<span class="comment">//1</span></span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">        Instrumentation.ActivityResult ar = minstrumentation.execStartActivity(<span class="keyword">this</span>, mMainThread.getApplicationThread(), mToke,<span class="keyword">this</span>,intent, requestCode , option);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>注释1的mParent 是Activity 类型，表示当前Activity 的父类(个人理解，这里应该说是当前Activity的前一个Activity)，因此mParent == null 成立，最后由 Instrumentation 的execStartActivity方法来执行启动操作。 <strong>Instrumentation 主要用于监控应用程序和系统的交互。</strong>主要代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/android/app/Instrumentation.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who , IBinder contextThread, IBinder token , Activity target, Intent intent ,<span class="keyword">int</span> requestCode ,Bundle options)</span></span>{</span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    intent.migrateExtraStreamToClipData();</span><br><span class="line">    intent.prepareToLeaveProcess(who );</span><br><span class="line">    <span class="keyword">int</span> result = ActivityManager.getService().startActivity(xxx,xxx,xxxx));</span><br><span class="line">    checkStartActivityResult(result, intent);</span><br><span class="line">} <span class="keyword">catch</span> (RemoteException e) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>由代码可知，首先通过 ActivityManager 获取 AMS 的代理对象，接着调用代理对象的 startActivity 方法。AMS 的代理对象是一个 IActivityManager(该类由AIDL在工具编译时自动生成的)对象，这个对象封装了 IBinder 类型的 AMS 的引用。通过一系列进程间通信，最终调用 AMS 的 startActivity 方法。</p>
<h3 id="AMS-到-ApplicationThread-的调用过程"><a href="#AMS-到-ApplicationThread-的调用过程" class="headerlink" title="AMS 到 ApplicationThread 的调用过程"></a>AMS 到 ApplicationThread 的调用过程</h3><p>Launcher 请求进入AMS 后，接着是AMS 到 ApplicationThread 调用流程，时序图如下所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/AMS%E5%88%B0ApplicationThread%E8%B0%83%E7%94%A8.png" alt="Launcher调用AMS启动Activity时序图"></p>
<p>在AMS 的startActivity 会使用 startActivityAsUser 实现功能，并获取UserHandle.getCallingUserld() 即 调用者的UserId 作为参数传入。之后，startActivityAsUser 中会判断调用者进程是否被隔离，如果隔离则抛出<font color="green">SecurityException</font>异常；接着，根据UserId 等参数检查调用者权限，如果没权限也抛出 SecurityException 异常。</p>
<p>AMS 中最终调用ActivityStater 的 startActivityLocked 方法，并且如果有 TaskRecord(代表启动的Activity所在的栈)，则将其也作为参数传入；startActivityLocked 中会收集所有逻辑来决定如何将Intent 和Flags 转换为Activity(生成用于描述Activity 的  ActivityRecord 对象)，并且将Activity 与Task 及 Stack 关联。</p>
<blockquote>
<p>TaskRecord 用于描述一个 Activity 任务栈，Activity 任务栈其实是一个假想模型，并不真实存在。</p>
</blockquote>
<p>最终调用到 ActivityStackSupervisor 的 startSpecificActivityLocked 方法时，会判断要启动的Activity 所在的应用程序进程是否已经运行，已经运行则调用 realStartActivityLocked 方法，并传入代表应用程序进程的 ProcessRecord。之后会调用 ApplicationThread 的 scheduleLaunchActivity 方法。当前代码逻辑运行在AMS所在进程(即SystemServer进程)中，通过 ApplicationThread 进程间通信，将程序执行到应用程序进程，<strong>ApplicationThread是AMS 进程与应用程序进程的通信桥梁</strong>，如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/AMS%E4%B8%8E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.png" alt="AMS与应用程序进程通信"></p>
<h3 id="ActivityThread-启动Activity-的过程"><a href="#ActivityThread-启动Activity-的过程" class="headerlink" title="ActivityThread 启动Activity 的过程"></a>ActivityThread 启动Activity 的过程</h3><p>由前面的知识可知，目前的代码逻辑已经运行到应用程序进程中，先查看下ActivityThread 启动Activity 的时序图：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/ActivityThread%E5%90%AF%E5%8A%A8Activity%E8%BF%87%E7%A8%8B%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="ActivityThread启动Activity过程的时序图"></p>
<p>ApplicationThread 是 ActivityThread 的内部类，前面讲过应用程序进程创建完成后，会运行代表主线程的实例 ActivityThread 。接着上一节的内容查看 ApplicationThread.scheduleLaunchActivity 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(xxx,xx,xxx)</span> </span>{<span class="comment">//参数太多，这里省略了参数</span></span><br><span class="line">    updateProcessState(procState ,<span class="keyword">false</span>);</span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line">    r.token = token;</span><br><span class="line">    r.ident ＝ident;</span><br><span class="line">    r.intent = intent;</span><br><span class="line">    r.referrer = referrer;</span><br><span class="line">    ...</span><br><span class="line">    updatePendingCoηfiguration (curConfig);</span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY ,r);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在把启动Activity 必要的数据封装成 ActivityClientRecord 后，通过 sendMessage 方法将封装的数据以 H.LAUNCH_ACTIVITY 类型发送了出去，这里可以大胆地猜测sendMessage方法是通过handler的 sendMessage 执行的，果不其然,sendMessage 有多个重载方法，最终调用到如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what ,Object obj ,<span class="keyword">int</span> argl ,<span class="keyword">int</span> arg2 ,<span class="keyword">boolean</span> async)</span></span>{</span><br><span class="line">    Message msg = <span class="function">Message <span class="title">obta</span> <span class="params">()</span></span>;</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.ob]= obj;</span><br><span class="line">    msg.argl = argl;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) {</span><br><span class="line">        msg .setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    }</span><br><span class="line">    mH.sendMessage(msg);</span><br></pre></td></tr></tbody></table></figure>

<p>这里的mH指的是 ActivityThread 的内部类 H，前面讲过，这个H是集成Handler，是应用进程中主线程的消息管理类，<strong>因为ApplicationThread 是一个Binder，它的调用逻辑都运行在Binder 线程池中，所以这里需要使用H将代码的逻辑切换到主线程中。</strong>这样一来，我们只需要看 H 的handleMessage 方法即可知道具体的执行操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span> <span class="params">(Message msg )</span> </span>{</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) {</span><br><span class="line">        <span class="keyword">case</span> LAUNCH_ACTIVITY:</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER，<span class="string">"activityStart"</span>);</span><br><span class="line">        <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;<span class="comment">//1</span></span><br><span class="line">        r.packageinfo = getPackageinfoNoCheck(r.activityinfo.applicationinfo, r.compatlnfo); <span class="comment">//2</span></span><br><span class="line">        handleLaunchActivity(r,<span class="keyword">null</span> ,<span class="string">"LAUNCH ACTIVITY"</span>); <span class="comment">//3</span></span><br><span class="line">        Trace.traceEnd (Trace . TRACE TAG ACTIVITY MANAGER);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>在注释1处将传过来的 msg 的成员变量 obj 还原成 ActivityClientRecord，注释2获得LoadApk 类型的对象。<strong>应用程序进程要启动Activity时需要将该Activity 所属的APK 加载进来，而LoadApk 就是用来描述已经加载的APK 文件的。</strong>注释3处调用 handleLaunchActivity 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r ,Intent customintent, String reason)</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">    WindowManagerGlobal.initialize ();</span><br><span class="line">    <span class="comment">//启动 Activity</span></span><br><span class="line">    Activity a = performLaunchActivity(r, customintent);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span>(a != <span class="keyword">null</span>){</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//将 Activity 的状态置为 Resume</span></span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,!r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);<span class="comment">//2</span></span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//停止 Activity 启动</span></span><br><span class="line">        <span class="function">ActivityManager getServ <span class="title">ce</span> <span class="params">()</span> .<span class="title">finishActivity</span><span class="params">(r . token , Activity . RESULT CANCELED , <span class="keyword">null</span> , Activity . DONT_FINISH_TASK_WITH_ACTIVITY)</span> </span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注释1处performLaunchActivity 方法启动了 Activity，注释2处将Activity的状态设置为 Resume ，如果该Activity 为null，则会通知AMS 停止启动Activity。我们来看看 performLaunchActivity 方法做了什么：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r , Intent customintent)</span> </span>{</span><br><span class="line">    <span class="comment">//获取 Activityinfo</span></span><br><span class="line">    Activityinfo ainfo = r.activityinfo;<span class="comment">//l</span></span><br><span class="line">    <span class="keyword">if</span> (r.packageinfo == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">//获取 APK 文件的描述类 LoadedApk</span></span><br><span class="line">        r.packageinfo = getPackageinfo(ainfo.applicationinfo ,r.compatinfo,Context.CONTEXT_INCLUDE_CODE);<span class="comment">//2</span></span><br><span class="line">    }</span><br><span class="line">    ComponentName component= r.intent.getComponent();<span class="comment">//3</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建要启动 Activity 的上下文环境</span></span><br><span class="line">    Contextlmpl appContext = createBaseContextForActivity(r) ; <span class="comment">//4</span></span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        java.lang .ClassLoader cl= appContext.getClassLoader();</span><br><span class="line">        <span class="comment">//用类加载器来创建该 Activity 的实例</span></span><br><span class="line">        activity = <span class="function">mInstrumentation <span class="title">newActivity</span><span class="params">(cl ,component.getClassName()</span> ,r.intent) </span>;<span class="comment">//5</span></span><br><span class="line">        ...</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//创建 Application</span></span><br><span class="line">        Application app = r.packageinfo.makeApplication(<span class="keyword">false</span> ,minstrumentation); <span class="comment">//6</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//初始化Activity，参数太多，省略</span></span><br><span class="line">            activity.attach(....) ;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) {</span><br><span class="line">                minstrumentation.callActivityOnCreate(activity,r.state ,r.persistentState); <span class="comment">//8</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                 <span class="function">minstrumentat on <span class="title">callActivityOnCreate</span><span class="params">(activ ty r .state)</span> </span>;</span><br><span class="line">            }</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">        r.paused = <span class="keyword">true</span> ;</span><br><span class="line">        mActivities.put(r.token,r);</span><br><span class="line">    } <span class="keyword">catch</span> (SuperNotCalledException e) {</span><br><span class="line">        <span class="keyword">throw</span> e ;</span><br><span class="line">    }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br></pre></td></tr></tbody></table></figure>

<p>注释1处获取 Activityinfo，用于存储AndroidManifest 以及 代码中设置的Activity 和 Receiver 节点的信息，比如Activity 的theme 和launchMode 。注释3中获取要启动的Activity 的 <strong>ComponentName 对象，该对象中保存了该Activity 的包名和类名</strong>。注释4中启动了Activity的上下文，注释5根据 Activity 的类名，用类加载器创建该 Activity 的实例。之后，注释6中创建了Application ，并且会调用 Application 的 onCreate方法。注释7中调用 Activity 的attach 方法初始化Activity，并且创建Window 对象(PhoneWindow)与Activity 自身关联。注释8中正式启动Activity，并调用Activity 的onCreate 方法。</p>
<p>至此，根Activity 就启动了，即应用程序启动了。</p>
<h3 id="根Activity-启动过程中涉及的进程"><a href="#根Activity-启动过程中涉及的进程" class="headerlink" title="根Activity 启动过程中涉及的进程"></a>根Activity 启动过程中涉及的进程</h3><p>根Activity 启动过程中涉及的4个进程之间关系如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/%E6%A0%B9Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png" alt="根Activity启动过程中涉及的进程关系"></p>
<p>首先Launcher 进程向 AMS 请求创建根 Activity ，AMS 会判断根Activity 所需要的应用程序进程是否存在，不存在就请求 Zygote 进程创建应用程序进程；之后，AMS 请求创建根Activity。上图中步骤 2 采用Socket 通信，步骤 1 和4采用Binder 通信。</p>
<p>读完书本，虽然各个点清晰，但是未能完整总结，<strong>以下 桌面点击图标 启动流程总结参考自<a target="_blank" rel="noopener" href="http://www.androidos.net.cn/book/android-road/android/advance/app-launch.html">他人博客</a></strong></p>
<ol>
<li>点击桌面图标，Launcher 采用Binder IPC 方式向system_server 发起startActivity 请求。    </li>
<li>system_server 进程接收到请求后，向 zygote 进程发送创建进程请求。    </li>
<li>zygote 进程fork 出新进程，即App进程。    </li>
<li>App 进程通过 Binder IPC 向 system_server 发起 attachApplication 请求。     </li>
<li>system_server收到请求做一系列准备后，通过 Binder IPC 向App 进程发送 scheduleLauncherActivity请求。    </li>
<li>App 进程的Binder 线程(ApplicationThread)收到请求后，通过Handler 向主线程发送 LAUNCH_ACTIVITY 消息。    </li>
<li>主线程收到Message 后，通过反射机制创建目标Activity ，并回调Activity.onCreate 等方法。    </li>
<li>至此，App启动，开始Activity 生命周期。</li>
</ol>
<p>这个过程示意图如下所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Activity启动流程图"></p>
<h2 id="Service-启动过程"><a href="#Service-启动过程" class="headerlink" title="Service 启动过程"></a>Service 启动过程</h2><p>Service 的启动过程和根Activity 的启动过程有部分相似知识点。Service 的启动过程可以分为两个部分讲解：分别是ContextImpl 到ActivityManageService 的调用过程，以及 ActivityThread 启动 Service。</p>
<h3 id="ContextImpl-到-AMS-的调用过程"><a href="#ContextImpl-到-AMS-的调用过程" class="headerlink" title="ContextImpl 到 AMS 的调用过程"></a>ContextImpl 到 AMS 的调用过程</h3><p>首先上时序图：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/ContextImpl%E5%88%B0AMS%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="ContextImpl到AMS的调用过程"></p>
<p>调用startService方法启动service，这个方法在 ContextWrapper 中实现</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/24/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/24/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：应用程序进程启动过程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-24 10:22:00" itemprop="dateCreated datePublished" datetime="2019-11-24T10:22:00+08:00">2019-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-03 21:29:50" itemprop="dateModified" datetime="2019-12-03T21:29:50+08:00">2019-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>AMS启动一个应用程序首先要保证该应用程序的进程已经启动，如果应用程序进程还不存在，则请求 Zygote 进程启动进程。</p>
<p>从前一章内容可知，在Zygote 的Java 框架层会创建Server 端的Socket，用于等待AMS 请求Zygote 创建新的应用程序进程。Zygote 通过fork自身即可创建应用程序进程，这个进程会包含虚拟机实例，并且会创建Binder线程池和消息循环。</p>
<p>本章学习应用程序进程的启动，注意，是应用程序进程而不是应用程序的启动过程。</p>
<h2 id="应用程序进程启动过程介绍"><a href="#应用程序进程启动过程介绍" class="headerlink" title="应用程序进程启动过程介绍"></a>应用程序进程启动过程介绍</h2><p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC3%E7%AB%A0/AMS%E5%8F%91%E9%80%81%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.jpeg" alt="AMS发送启动应用程序进程请求过程的时序图"></p>
<p>AMS 通过调用  startProcessLocked 向 Zygote 进程发送请求， 主要代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="params"><span class="function">String hostingNameStr, String abiOverride ,String entryPoint ,String [] entryPointArgs)</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取要创建的应用程序进程的用户 ID</span></span><br><span class="line">    <span class="keyword">int</span> uid = app.uid; <span class="comment">//1 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> [] gids = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">if</span> (!app.isolated) { </span><br><span class="line">        <span class="comment">//2  gids创建和赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="function">ArrayUtils <span class="title">isEmpty</span><span class="params">(permGids)</span>)</span>{</span><br><span class="line">            gids =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; </span><br><span class="line">        }<span class="keyword">else</span> { </span><br><span class="line">            gids = <span class="keyword">new</span> <span class="keyword">int</span>[permGids.leng + <span class="number">3</span>] ; </span><br><span class="line">            System.arraycopy(permGids, <span class="number">0</span>, gids, <span class="number">3</span>, permGids.length) ; </span><br><span class="line">            gids[O] = UserHandle.getSharedAppGid(UserHandle.getAppid(uid)); </span><br><span class="line">            gids[<span class="number">1</span>] = UserHandle.getCacheAppGid(UserHandle .getAppid(uid)) ; </span><br><span class="line">            gids[<span class="number">2</span>] = UserHandle.getUserGid{UserHandle.getUserid(uid)); </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (entryPoint = <span class="keyword">null</span>) entryPoint = <span class="string">"android.app.ActivityThread"</span>;<span class="comment">//3</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//启动应用程序进程,这里省略不重要的参数</span></span><br><span class="line">    startResult = Process.start(entryPoint,xxx,uid, xxx,gids,xxx,xxx);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>上述代码<strong>首先得到应用程序进程的用户ID</strong>，之后创建用户组ID 并且赋值，在注释3处判断 entryPoint 为null就赋值 “android.app.ActivityThread”，<font color="#008000">这个值就是应用程序进程主线程的类名</font>。在最终调用 Process.start 创建进程时，会将进程的用户ID和用户组ID传入。</p>
<p>Process.start会将实现交给 ZygoteProcess(<strong>ZygoteProcess用于保持与Zygote进程的通信状态</strong>)的start 方法处理，其中首先会执行 openZygoteSocketifNeeded  方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed ()) { </span><br><span class="line"><span class="keyword">try</span> { </span><br><span class="line">    <span class="comment">//与 Zygote 进程建立 Socket 连接</span></span><br><span class="line">    primaryZygoteState = ZygoteState.connect(mSocket);<span class="comment">//1</span></span><br><span class="line">} <span class="keyword">catch</span> (IOException ioe} { </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx (<span class="string">"Error connecting to primary zygote"</span>， ioe)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//连接 Zygote 主模式返回的 ZygoteState 是否与启动应用程序进程所需要的ABI匹配</span></span><br><span class="line"><span class="keyword">if</span> (primaryZygotestate.matches (abi)) {<span class="comment">//2 </span></span><br><span class="line">    <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">／／如果不匹配，则尝试连接 Zygote 辅模式</span><br><span class="line"><span class="keyword">if</span> (secondaryZygoteState ==<span class="keyword">null</span> || secondaryZygoteState.isClosed()) { </span><br><span class="line"><span class="keyword">try</span> { </span><br><span class="line">    secondaryZygoteState = ZygoteState.connect(mSecondarySocket);<span class="comment">//3</span></span><br><span class="line">} <span class="keyword">catch</span> (IOException ioe) { </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx (<span class="string">"Error connecting to secondary zygote"</span>, ioe) ; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">／／连接 Zygote 辅模式返回的 ZygoteState 是否与启动应用程序进程所需要的 ABI 匹配</span><br><span class="line"><span class="keyword">if</span> (secondaryZygoteState.matches(abi)) {<span class="comment">//4 </span></span><br><span class="line">    <span class="keyword">return</span> secondaryZygoteState; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx (<span class="string">"Unsupported zygote ABI :"</span> + abi); </span><br></pre></td></tr></tbody></table></figure>

<p>前面章节提到Zygote的main方法中会创建name为 “zygote” 的server端Socket，注释1就是与Zygote进程建立Socket 连接(name为”zygote”)，并得到 ZygoteState 对象primaryZygoteState；注释2处如果primaryZygoteState 与启动应用程序所需要的 ABI 不匹配，则在注释3处连接name为 “zygote_secondary” 的Socket。如果辅模式返回的 ZygoteState 与进程所需的ABI也不匹配，就抛出异常。</p>
<p>通过 openZygoteSocketifNeeded 获取ZygoteState后，将其作为参数调用 ZygoteProcess的  ZygoteSendArgsAndGetResult 方法 获取Process.ProcessStartResult。</p>
<h3 id="Zygote-接收请求并创建应用程序进程"><a href="#Zygote-接收请求并创建应用程序进程" class="headerlink" title="Zygote 接收请求并创建应用程序进程"></a>Zygote 接收请求并创建应用程序进程</h3><p>执行完以上步骤后，继续执行 argsForZygote 方法即可让Zygote 收到创建新的应用程序进程的请求。Zygote 接收请求并创建应用程序进程的时序图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC3%E7%AB%A0/Zygote%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Zygote接收请求并创建应用程序进程的时序图"></p>
<p>由前面章节我们知道，Zygote 中的Server Socket 的runSelectLoop 方法一直在等待 AMS请求创建新的应用程序进程，runSelectLoop 中是通过 runOnce 来创建进程的，runOnce最终调用到 Zygote 的 forkAndSpecialize 方法创建应用程序进程，并返回pid。forkAndSpecialize 通过fork 当前进程来创建一个子进程。此后，便会在应用程序进程中创建 Binder 线程池，*<em>进一步通过反射 ActivityThread 类的main方法调用，令应用程序进程进入了ActivityThread 的main方法中。此时，应用程序进程创建完毕，并且运行了主线程管理类 ActivityThread *</em>。</p>
<blockquote>
<p>如果pid为0，说明当前代码运行在新创建的子进程中。</p>
</blockquote>
<h3 id="Binder-线程池启动过程"><a href="#Binder-线程池启动过程" class="headerlink" title="Binder 线程池启动过程"></a>Binder 线程池启动过程</h3><p>程序中会检查代码，确保Binder线程池只会被启动一次。</p>
<h3 id="消息循环创建过程"><a href="#消息循环创建过程" class="headerlink" title="消息循环创建过程"></a>消息循环创建过程</h3><p>通过反射方式 invok 执行 ActivityThread 的main方法时，会执行一系列主线程的工作，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{ </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建主线程 Looper</span></span><br><span class="line">    Looper.prepareMainLooper(); <span class="comment">//1 </span></span><br><span class="line">    ActivityThread thread= <span class="keyword">new</span> ActivityThread(); <span class="comment">//2 </span></span><br><span class="line">    thread.attach(<span class="keyword">false</span>) ; </span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span> ) {<span class="comment">//3 </span></span><br><span class="line">    <span class="comment">//创建主线程 H 类</span></span><br><span class="line">    sMainThreadHandler = thread . getHandler ();<span class="comment">//4 </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) { </span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span> LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>）；</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER) ; </span><br><span class="line">    <span class="comment">//Looper 开始工作</span></span><br><span class="line">    Looper.loop (); <span class="comment">//5 </span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ActivityThread类用于管理当前应用程序进程的主线程，上述代码中创建了主线程的消息循环Looper，其中的内部类 H 继承 Handler，在注释 5 处调用Looper.loop ，即使得Looper 开始处理消息，可见，系统在应用程序进程启动完成后，就会创建消息循环。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/23/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/23/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="post-title-link" itemprop="url">面试题-虚拟机知识</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-23 21:40:00" itemprop="dateCreated datePublished" datetime="2019-11-23T21:40:00+08:00">2019-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-12 09:50:33" itemprop="dateModified" datetime="2020-07-12T09:50:33+08:00">2020-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1、对象的内存布局"><a href="#1、对象的内存布局" class="headerlink" title="1、对象的内存布局"></a>1、对象的内存布局</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>分为3个区域：对象头、实例数据 以及 对齐填充</p>
<p><strong>对象头：</strong>包括两部分信息，第一部分：对象自身运行时数据，如hashcode、GC年龄分代、锁状态标志位，官方称为”Mark Word”。第二部分：类型指针，虚拟机通过这个指针确定对象是哪个类的实例。</p>
<p><strong>实例数据：</strong>对象真正存储的有效信息。</p>
<p><strong>对齐填充：</strong>比如HotSpot vm 要求对象起始地址必须是8的整数倍。对齐填充不是必需的。</p>
<p>以下是句柄访问 时，内存布局关系图：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="内存布局关系图"></p>
<blockquote>
<p>以上内容参考自： <a target="_blank" rel="noopener" href="http://www.androidos.net.cn/book/android-road/java/virtual-machine/object.html">对象创建与定位</a></p>
</blockquote>
</details>

<h2 id="2、垃圾收集算法"><a href="#2、垃圾收集算法" class="headerlink" title="2、垃圾收集算法"></a>2、垃圾收集算法</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>标记-清除 算法。不足：1、标记清除效率不高。2、产生内存碎片。    </li>
<li>复制算法。为了解决标记清除的效率问题，将内存划分为大小相等的两块，每次使用一块。不足：可用内存缩小为原来一半。    </li>
<li>标记-整理。不足：复制存货对象耗时过多。    </li>
<li>分代收集算法。 新生代使用复制算法；老年代采用“标记-清除” 或者 “标记-整理”算法。</li>
</ul>
</details>

<blockquote>
<p>以上内容参考自： <a target="_blank" rel="noopener" href="http://www.androidos.net.cn/book/android-road/java/virtual-machine/Garbage-Collector.html">垃圾回收算法</a></p>
</blockquote>
<h2 id="3、说说四大引用？强，软，弱，虚，并说明下合适GC"><a href="#3、说说四大引用？强，软，弱，虚，并说明下合适GC" class="headerlink" title="3、说说四大引用？强，软，弱，虚，并说明下合适GC"></a>3、说说四大引用？强，软，弱，虚，并说明下合适GC</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。</p>
</blockquote>
<blockquote>
<p>软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，只有在内存不足的时候 JVM 才会回收该对象。这一点可以很好地用来解决 OOM 的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>
</blockquote>
<blockquote>
<p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p>
</blockquote>
<blockquote>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。要注意的是，虚引用必须和引用队列关联使用.</p>
</blockquote>
</details>

<h2 id="4、Android中内存分配的执行流程"><a href="#4、Android中内存分配的执行流程" class="headerlink" title="4、Android中内存分配的执行流程"></a>4、Android中内存分配的执行流程</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="铺垫"><a href="#铺垫" class="headerlink" title="铺垫"></a>铺垫</h3><p>Dalvik 虚拟机的Java堆的底层实现是一块共享匿名内存(Ashmem)，并且将其抽象为C库的一个 mspace ，于是，Dalvik 虚拟机就可以利用 C 库里面的 dlmalloc 内存分配器来解决内存碎片问题(这是个成熟的内存分配器，<strong>可以很好地解决内存碎片的问题</strong>)</p>
<h3 id="Android中内存分配的执行流程："><a href="#Android中内存分配的执行流程：" class="headerlink" title="Android中内存分配的执行流程："></a>Android中内存分配的执行流程：</h3><p>流程图如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B.png" alt="dalvik虚拟机内存分配流程"></p>
<ol>
<li>尝试在Java堆上分配指定大小的内存，如果内存充足，就直接分配成功。(不改变java堆当前大小的前提下进行内存分配，属于轻量级的内存分配)      </li>
<li>如果分配失败，就执行一次GC(如果此时有GC在运行，则等待这次GC执行完成)，GC 时设置参数false标记<strong>不要</strong>回收软引用的对象。        </li>
<li>GC 完成后，再次尝试轻量级内存分配操作，如果内存充足，就分配成功了               </li>
<li>如果上一步内存分配失败，就考虑将Java堆的当前大小设置为Dalvik 虚拟机启动时指定的Java堆最大值，再进行内存分配         </li>
<li>如果内存充足，就完成内存的分配       </li>
<li>如果上一步还是分配失败，就再次调用GC，并将参数标记为true，<strong>表示要回收软引用的对象</strong>           </li>
<li>GC完毕后，再次尝试分配，成功就返回；不成功也就抛出OOM了       </li>
</ol>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/luoshengyang/article/details/41688319">老罗的博客</a></p>
</blockquote>
</details>

<h2 id="5、Android-GC-流程"><a href="#5、Android-GC-流程" class="headerlink" title="5、Android GC 流程"></a>5、Android GC 流程</h2><h3 id="Art-虚拟机GC过程"><a href="#Art-虚拟机GC过程" class="headerlink" title="Art 虚拟机GC过程"></a>Art 虚拟机GC过程</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E8%99%9A%E6%8B%9F%E6%9C%BA/Art%E7%9A%84gc%E6%B5%81%E7%A8%8B.jpg" alt="Art的gc流程"></p>
<p>由图可知，非并行GC的过程如下所示：</p>
<ol>
<li>挂起所有的ART运行时线程。      </li>
<li>调用子类实现的成员函数MarkingPhase执行GC标记阶段。          </li>
<li>调用子类实现的成员函数ReclaimPhase执行GC回收阶段。       </li>
<li>恢复第2步挂起的ART运行时线程。          </li>
</ol>
<p>并行GC的过程如下所示：</p>
<ol>
<li>获取用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数MarkingPhase执行GC并行标记阶段。</li>
<li>释放用于访问Java堆的锁。</li>
<li>挂起所有的ART运行时线程。</li>
<li>调用子类实现的成员函数HandleDirtyObjectsPhase处理在GC并行标记阶段被修改的对象。。</li>
<li>恢复第4步挂起的ART运行时线程。</li>
<li>重复第5到第7步，直到所有在GC并行阶段被修改的对象都处理完成。</li>
<li>获取用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数ReclaimPhase执行GC回收阶段。</li>
<li>释放用于访问Java堆的锁。</li>
</ol>
<p>从上面的分析就可以看出，并行GC和非并行GC的区别在于：</p>
<ol>
<li>非并行GC的标记阶段和回收阶段是在挂住所有的ART运行时线程的前提下进行的，因此，只需要执行一次标记。         </li>
<li>并行GC的标记阶段只锁住了Java堆，因此它不能阻止那些不是正在分配对象的ART运行时线程同时运行，而这些同进运行的ART运行时线程可能会引用了一些在之前的标记阶段没有被标记的对象。如果不对这些对象进行重新标记的话，那么就会导致它们被GC回收，造成错误。因此，与非并行GC相比，并行GC多了一个处理脏对象的阶段。所谓的脏对象就是我们前面说的在GC标记阶段同时运行的ART运行时线程访问或者修改过的对象。        </li>
<li>并行GC并不是自始至终都是并行的，例如，处理脏对象的阶段就是需要挂起除GC线程以外的其它ART运行时线程，这样才可以保证标记阶段可以结束。         </li>
</ol>
</details>


<h3 id="Dalvik-虚拟机垃圾收集过程"><a href="#Dalvik-虚拟机垃圾收集过程" class="headerlink" title="Dalvik 虚拟机垃圾收集过程"></a>Dalvik 虚拟机垃圾收集过程</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Dalvik 虚拟机使用 Mark-Sweep 算法来进行垃圾收集<br>Dalvik 执行GC 时会有一些选项：</p>
<ul>
<li>isPartial，为true 时，表示仅仅回收Active 堆的垃圾；为false时，表示同时回收Active 堆和Zygote 堆的垃圾    </li>
<li>isConcurrent：为true时，表示执行并行GC，false时，表示非并行GC    </li>
<li>doPreserve：为true的时候，表示不回收软引用的对象；false的时候，表示回收软引用对象<br>Dalvik在如下几种情况会触发GC：</li>
<li>分配对象时，内存不足触发GC    </li>
<li>已经分配的内存达到一定阈值时触发GC    </li>
<li>调用 System.gc 、VMRuntime.gc 或者收到信号触发 GC    </li>
<li>准备抛出 OOM 前而最后进行的 GC<br>GC线程在空闲达到一定时间后，会调用函数对Java堆进行裁剪，将一些没有用到的内存交还给内核。<br>dalvik 的GC 流程(并行和非并行情况)如下图所示：<br><img src="/assets/%E9%9D%A2%E8%AF%95/java%E8%99%9A%E6%8B%9F%E6%9C%BA/dalvik%E7%9A%84gc%E6%B5%81%E7%A8%8B.jpg" alt="dalvik虚拟机gc流程"></li>
</ul>
<h3 id="哪些对象可以做-GC-Root"><a href="#哪些对象可以做-GC-Root" class="headerlink" title="哪些对象可以做 GC Root"></a>哪些对象可以做 GC Root</h3><ul>
<li>虚拟机栈引用的对象    </li>
<li>本地方法栈引用的对象     </li>
<li>方法区中类静态属性引用的对象     </li>
<li>方法区中常量引用的对象        </li>
<li>Dalvik 虚拟机内部创建的部分异常对象      </li>
<li>Dalvik 虚拟机内部创建的原子类     </li>
<li>注册在调试器的对象</li>
</ul>
</details>

<blockquote>
<p>以上内容参考自以上内容参考自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Luoshengyang/article/details/41822747?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158968621519724843340084%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=158968621519724843340084&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v25-6-41822747.nonecase&amp;utm_term=dalvik">罗升阳的博客</a>  、 <a target="_blank" rel="noopener" href="https://blog.csdn.net/luoshengyang/article/details/42555483">老罗的博客</a></p>
</blockquote>
<h2 id="6、如何理解Java类加载机制"><a href="#6、如何理解Java类加载机制" class="headerlink" title="6、如何理解Java类加载机制"></a>6、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483903&amp;idx=1&amp;sn=c20d3172052bd7db9a1ad6a95f112bc9&amp;chksm=96cda0b2a1ba29a4cc9912cb1bf8a955f97ee45a7b8db48e384f1694ddbabbd4d5e7fa90f880&amp;scene=21#wechat_redirect">如何理解Java类加载机制</a></h2></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/23/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/23/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">面试题-设计模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-23 21:40:00" itemprop="dateCreated datePublished" datetime="2019-11-23T21:40:00+08:00">2019-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-14 16:28:00" itemprop="dateModified" datetime="2021-03-14T16:28:00+08:00">2021-03-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1、mvc、mvp、mvvm"><a href="#1、mvc、mvp、mvvm" class="headerlink" title="1、mvc、mvp、mvvm"></a>1、mvc、mvp、mvvm</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="mvc"><a href="#mvc" class="headerlink" title="mvc"></a>mvc</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvc.png" alt="mvc示意图"></p>
<p><strong>特征：</strong></p>
<ul>
<li>view 接收用户的输入，并且可以通知Controller 更改Model 层数据，如果没有涉及逻辑，还可以直接通知Model 更改数据。    </li>
<li>需要ui变化，但是没有涉及业务数据，直接调用controller 即可(比如用户选择使用用户名/手机号登录)    </li>
<li>model 数据变化时，若需要修改ui，需要通过Controller 来通知更新。</li>
</ul>
<p><strong>在Android中存在问题：</strong></p>
<ul>
<li>Activity 的职责不明，并且臃肿。Activity 除了要展示view (加载view，接收用户操作)，还要承担部分逻辑处理(比如生命周期回调)    </li>
</ul>
<h3 id="mvp"><a href="#mvp" class="headerlink" title="mvp"></a>mvp</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvp.png" alt="mvp示意图"></p>
<p><strong>特点</strong>:</p>
<ul>
<li>View 层接收输入</li>
<li>Presenter 处理业务逻辑，View 与 Model 之间必须经过 Presenter</li>
</ul>
<p><strong>优点(相对MVC)：</strong></p>
<ul>
<li>避免了View、Model 直接联系，更加解耦，通过Presenter 实现两者之间的沟通    </li>
<li>Activity 更加简明，仅仅负责UI上的工作    </li>
</ul>
<h3 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvvm.png" alt="mvvm示意图"></p>
<p>可能主要关注view 通过databinding 与 viewmodel 相互绑定。</p>
<h3 id="mvc-与-mvp-的区别"><a href="#mvc-与-mvp-的区别" class="headerlink" title="mvc 与 mvp 的区别"></a>mvc 与 mvp 的区别</h3><ul>
<li>在mvc 中 Activity 具有 view 的功能，并且兼任部分 controller 功能，而mvp 中Activity 是纯粹的view    </li>
<li>mvc 中view 和model 可以直接沟通(没有逻辑情况下，view直接更改model，当然，有逻辑改动的情况下经过controller)，而mvp中二者沟通必须经过presenter。    </li>
</ul>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/100070713">carson_ho的博客</a></p>
</blockquote>
<h3 id="2、实现一个线程安全的单例模式"><a href="#2、实现一个线程安全的单例模式" class="headerlink" title="2、实现一个线程安全的单例模式"></a>2、实现一个线程安全的单例模式</h3><h3 id="3、观察者模式和回调有什么区别？"><a href="#3、观察者模式和回调有什么区别？" class="headerlink" title="3、观察者模式和回调有什么区别？"></a>3、观察者模式和回调有什么区别？</h3></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/23/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC11%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/23/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC11%E7%AB%A0/" class="post-title-link" itemprop="url">第11章：Dalvik 和 ART</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-23 10:30:00 / 修改时间：11:00:25" itemprop="dateCreated datePublished" datetime="2019-11-23T10:30:00+08:00">2019-11-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Dalvik虚拟机"><a href="#Dalvik虚拟机" class="headerlink" title="Dalvik虚拟机"></a>Dalvik虚拟机</h2><p>Dalvik虚拟机 简称 DVM，第10章提到，它不是一个 jvm，主要原因是它没有遵循jvm规范实现，二者的主要区别有：</p>
<ul>
<li>基于的架构不同</li>
</ul>
<blockquote>
<p>JVM 基于栈，DVM 基于寄存器。基于栈意味着需要去栈中读写数据，所需要的指令更多，并且速度更慢，对于性能优先的移动设备，显然是不合适的。</p>
</blockquote>
<ul>
<li>执行的字节码不同</li>
</ul>
<blockquote>
<p>在Java SE 程序中，Java 类被编译成一个或者多个.class 文件，并被打包成 jar 文件，之后JVM 会通过相应的 .class 和 jar 文件获取相应的字节码；而DVM 会用dx工具将所有的 .class 文件转换为一个 .dex 文件，然后DVM 从该 .dex 文件中读取指令和数据。<br>.jar文件里面包含多个.class 文件，每个.class文件包含了该类的常量池、类信息、属性等，当JVM 加载.jar文件的时候，会加载里面所有的.class文件，JVM 这种加载方式很慢(首先就是很多io操作)，对于内存有限的移动设备并不合适；而.dex文件将所有的.class里面所包含的信息全部整合到一块了，这样再加载就减少了I/O操作，加快查找速度；并且，相对Android而言，.class中有许多冗余信息，dex工具会去掉冗余信息。</p>
</blockquote>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC11%E7%AB%A0/dalvik%E4%B8%8Ejvm%E6%89%A7%E8%A1%8C%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="DVM与JVM执行的字节码不同"></p>
<ul>
<li>DVM 允许在有限的内存中同时运行多个进程</li>
</ul>
<blockquote>
<p>在Android中，每个应用都运行在一个DVM中，每个DVM 实例都运行在一个独立的进程中，这样，某一个虚拟机崩溃的时候不会导致其他app也关闭。</p>
</blockquote>
<ul>
<li>DVM 由Zygote创建和初始化</li>
</ul>
<blockquote>
<p>在第2章有介绍<strong>Zygote，它是一个DVM进程</strong>，当系统需要创建一个应用程序时，Zygote就会fork自身，快速地创建和初始化一个DVM实例。对于一些只读的库，所有的DVM实例都会和Zygote共享一块内存区域，节省内存开销。</p>
</blockquote>
<ul>
<li>DVM 有共享机制</li>
</ul>
<blockquote>
<p>DVM 的共享机制可以使<strong>不同应用之间在运行时可以共享相同的类</strong>，这带来更高的效率；而JVM不具有这种机制，不同的程序，打包以后的程序都是彼此独立的，即便它们在包里使用了同样的类，运行时也是单独加载和运行的。</p>
</blockquote>
<h3 id="DVM-运行时堆"><a href="#DVM-运行时堆" class="headerlink" title="DVM 运行时堆"></a>DVM 运行时堆</h3><p>DVM运行时堆使用标记-清除算法进行GC，它由两个Space以及多个辅助数据结构组成，两个Space分别是：Zygote Space(Zygote Heap) 和 Allocation Space(Active Heap)，前者用于管理Zygote进程在启动过程中预加载和创建的对象，并且Zygote Space不会触发GC，Zygote 进程和应用进程之间会共享Zygote Space。在Zygote 进程fork第一个子进程前，会把Zygote Space 分为两部分，原来已经被使用的部分对仍旧叫做Zygote Space，而未使用的那部分堆叫做 Allocation Space ，以后的对象都会在 Allocation Space上进行分配和释放。</p>
<h2 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h2><p>Android 4.4 的时候发布了ART虚拟机，但是4.4版本默认还是使用DVM，Android 5.0 及以后版本默认采用ART，从此，DVM退出历史舞台。</p>
<h3 id="ART-与-Dalvik-区别"><a href="#ART-与-Dalvik-区别" class="headerlink" title="ART 与 Dalvik 区别"></a>ART 与 Dalvik 区别</h3><p>ART 与 Dalvik 的区别主要有4点：</p>
<ul>
<li>DVM 是为32位CPU涉及的，而ART支持64位并且兼容32位 CPU。    </li>
<li>ART 对垃圾回收机制进行了改进，将 GC 暂停由2次减少为1次，并且频繁执行并行垃圾收集。    </li>
<li>ART 的运行时堆空间划分和DVM不同。    </li>
<li>DVM中应用每次运行时，字节码通过 JIT 编译器编译为机器码，使得应用程序运行效率低下；而在ART中，系统在安装应用程序时会进行一次AOT(ahead of time compilation,预编译)，将字节码预先编译成机器码并存储在本地，这样应用程序每次运行时就不需要执行编译了。</li>
</ul>
<blockquote>
<p>ART也有两个主要缺点：一是AOT使应用安装时间变长，二是预编译的机器码占用的存储空间比较大。为了解决上面的缺点，Android 7.0 版本在ART中加入了JIT编译器，作为AOT的补充：在安装应用时不会将字节码全部编译成机器码，而是在运行中将热点代码编译器机器码，以达到缩短应用安装时间并节省存储空间。</p>
</blockquote>
<p>更详细的内容，可以参考<a target="_blank" rel="noopener" href="https://source.android.google.cn/devices/tech/dalvik/gc-debug">官网上的描述</a></p>
<h3 id="ART-运行时堆"><a href="#ART-运行时堆" class="headerlink" title="ART 运行时堆"></a>ART 运行时堆</h3><p>与DVM 的GC不同的是，ART采用多种垃圾收集方案，每个方案会运行不同的垃圾收集器，默认是采用 CMS(Concurrent Mark-Sweep)方案，主要有sticky-CMS 和 partial-CMS，不同的CMS方案，ART运行时堆得空间划分也不同，默认由4个Space和多个辅助结构组成，采用标记-清除算法时，两种虚拟机运行时堆对比图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC11%E7%AB%A0/dalvik%E4%B8%8Eart%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4.png" alt="两种虚拟机运行时堆对比"></p>
<p>由图可以看到ART的4个Space，其中，Zygote Space 、Allocation Space 和 DVM 中的作用一样，ImageSpace 用来存放一些预加载类，Large Object Space 用来分配一些大对象。其中Zygote Space 与 Image Space 是进程共享的。</p>
<h3 id="ART-的GC-日志"><a href="#ART-的GC-日志" class="headerlink" title="ART 的GC 日志"></a>ART 的GC 日志</h3><ol>
<li>GC Reason<br>ART 虚拟机GC日志中会包含产生这次GC原因，主要会有：</li>
</ol>
<ul>
<li>Concurrent: 并发GC，在后台线程运行GC，不会使App的线程暂停，不会阻止内存分配。    </li>
<li>Alloc： 当堆内存已满，App尝试分配内存而引起的GC，<strong>这个GC发生在正在分配内存的线程中。</strong>    </li>
<li>Explicit： App显式请求垃圾收集，比如 System.gc()。    </li>
<li>NativeAlloc： Native 内存分配时触发的GC。    </li>
</ul>
<ol start="2">
<li>垃圾收集器名称<br>ART 虚拟机GC日志中会包含所使用的收集器名称，主要会有：</li>
</ol>
<ul>
<li>Concurrent Mark Sweep(CMS)： 它是以最短收集暂停时间为目标的收集器，采用标记-清除算法，<strong>能释放除了Image Space外的所有空间</strong>    </li>
<li>Concurrent Partial Mark Sweep： 能释放除了Image Space 和 Zygote space 意外的所有空间    </li>
<li>Concurrent Sticky Mark Sweep： 粘性收集器，<strong>基于分代的垃圾收集思想</strong>，只能释放自上次GC以来分配的对象，这个收集器扫描比较频繁，因为它很快并有很短的暂停时间。    </li>
<li>Marksweep + Semispace：非并发GC，复制GC用于堆转换以及堆碎片整理。    </li>
</ul>
<h2 id="DVM-和-ART-的诞生"><a href="#DVM-和-ART-的诞生" class="headerlink" title="DVM 和 ART 的诞生"></a>DVM 和 ART 的诞生</h2><p>它们是从Zygote进程诞生的，这样，Zygote进程就持有了DVM或者ART的实例，此后，Zygote进程每次fork自身创建新的应用进程时，应用程序进程也就得到了 DVM 或者ART 的实例，即每个应用进程都有一个单独的虚拟机实例。<strong>这样做的好处是，无需在每次启动应用程序进程时都要创建DVM或者ART，从而加快了应用程序进程的启动速度</strong>。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/22/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/22/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：Android系统启动</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-22 15:10:00" itemprop="dateCreated datePublished" datetime="2019-11-22T15:10:00+08:00">2019-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-03 21:22:20" itemprop="dateModified" datetime="2019-12-03T21:22:20+08:00">2019-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="init-进程启动过程"><a href="#init-进程启动过程" class="headerlink" title="init 进程启动过程"></a>init 进程启动过程</h2><p>init进程是Android系统中<strong>用户空间的第一个进程</strong>，进程号为1，它被赋予了很多重要职责，比如创建 Zygote 和属性服务等。</p>
<h3 id="引入init进程"><a href="#引入init进程" class="headerlink" title="引入init进程"></a>引入init进程</h3><p>了解Android系统启动流程的前几步，可以有助于引入init进程：</p>
<ol>
<li>启动电源以及系统启动。当电源按下时，引导芯片代码从预定义的地方(固化在ROM中)开始执行，<strong>加载引导程序到RAM中</strong>，然后执行。    </li>
<li>引导程序BootLoader。它是Android操作系统开始运行前的一个小程序，主要作用是把系统OS拉起来。    </li>
<li>Linux 内核启动。linux内核启动完成系统设置后，<strong>它首先在系统文件中寻找init.rc，并启动init进程。</strong>     </li>
<li>init进程启动。init进程的工作比较多，主要用于初始化、启动属性服务 以及 启动Zygote进程。</li>
</ol>
<h3 id="init进程入口"><a href="#init进程入口" class="headerlink" title="init进程入口"></a>init进程入口</h3><p>在Linux内核加载完成后，首先在系统文件中查找init.rc，并启动init进程。init的main函数中做了很多事情，我们主要了解以下几点：</p>
<ul>
<li>调用property_init 函数对属性初始化，调用 start_property_service函数启动属性服务。    </li>
<li>调用 signal_handler_init <strong>设置子进程信号处理函数，主要用于防止init进程的子进程成为僵尸进程。</strong>为了防止僵尸进程的出现，系统会在子进程暂停和终止的时候发出 SIGCHLD信号，signal_handler_init就是用来接收这个信号的。</li>
</ul>
<blockquote>
<p>僵尸进程：在linux中，父进程使用fork创建子线程，在子线程终止后，如果父进程并不知道子线程终止了，那么还会在系统进程表为它保留一定的信息。僵尸进程主要危害就是占用系统进程表，可能导致系统进程表被耗尽而无法创建新的进程。假设init的子进程Zygote终止了，signal_handler_init 函数会找到Zygote进程并移除所有Zygote进程信息，再重启Zygote。</p>
</blockquote>
<h3 id="解析-init-rc"><a href="#解析-init-rc" class="headerlink" title="解析 init.rc"></a>解析 init.rc</h3><p>init.rc 是一个配置文，是由Android 初始化语言编写的脚本，为了分析如何创建Zygote，我们主要查看其中的Service类型语句，在Android 8.0 及以后，每个Service 都对应一个rc 文件。init.rc 中定义Service 的格式如下：</p>
<blockquote>
<p>service <name> <pathname> [ <argument> ] * //&lt;service 的名字〉〈执行程序路径〉〈传递参数〉</argument></pathname></name></p>
</blockquote>
<p>举个栗子，zygote的Service配置文件就是：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin -- zygote --startsystem- server </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">main</span> </span></span><br><span class="line"><span class="class"><span class="title">priority</span> -20 </span></span><br><span class="line"><span class="class"><span class="title">user</span> <span class="title">root</span> </span></span><br><span class="line"><span class="class"><span class="title">group</span> <span class="title">root</span> <span class="title">readproc</span> </span></span><br></pre></td></tr></tbody></table></figure>

<p>来大概分析代码意思，Service用于通知 init 进程创建名为 zygote 的进程，这个进程执行程序的路径为 /system/bin/app_process64，其中 <font color="#008000">class main</font>指的是Zygote 的classname 为 main。<strong>后面的代码是要传给 app_process64的参数。</strong></p>
<h3 id="解析Service类型语句"><a href="#解析Service类型语句" class="headerlink" title="解析Service类型语句"></a>解析Service类型语句</h3><p>init.rc中Service类型语句使用ServiceParser类来解析，它将init.rc中的service解析生成的Service对象加入到 Service 链表中。</p>
<h3 id="init-启动Zygote"><a href="#init-启动Zygote" class="headerlink" title="init 启动Zygote"></a>init 启动Zygote</h3><p>我们来了解init是如何启动Service的，这里主要讲解 Zygote这个Service。前面提到，在Zygote的启动脚本中描述Zygote的classname为<font color="#008000">main</font>，在init.rc中会遍历 解析Service类型语句 过程生成的Service链表，找到 classname 为main的Zygote，如果Zygote Service 已经运行，则不再启动，否则就调用fork函数创建子进程，并在子进程中调用Service的main函数，Zygote的main函数代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main （<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv []) </span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (zygote) { </span><br><span class="line">        runtime.start （<span class="string">"com.android.internal.os.Zygoteinit”， args, zygote) ; //1</span></span><br><span class="line"><span class="string">    } else if (className) { </span></span><br><span class="line"><span class="string">        runtime .start （” com android nternal.os.Runtimeinit ”， args zygote) ; </span></span><br><span class="line"><span class="string">    } else{</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></tbody></table></figure>

<p>从注释1处可以看到调用runtime的start函数启动了 Zygote 。</p>
<h3 id="属性服务"><a href="#属性服务" class="headerlink" title="属性服务"></a>属性服务</h3><p>Windows上有注册表管理器以键值对的形式记录用户软件的一些使用信息，即使系统或者软件重启，其还是能够根据之前注册表中的记录进行相应初始化工作。Android中也提供了类似机制，叫做<strong>属性服务</strong>。init 进程启动时会启动属性服务，并为其分配内存存储这些属性，如果需要这些属性直接读取即可。启动属性服务的主要代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">property_set_fd =create_socket(PROP_SERVICE_NAME ,SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,<span class="number">0666</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>); <span class="comment">//1</span></span><br><span class="line">...</span><br><span class="line">listen(property_set_fd, <span class="number">8</span>); <span class="comment">//2  </span></span><br><span class="line">register_epoll_handler(property_set_fd , handle_property_set_fd) ; <span class="comment">//3 </span></span><br></pre></td></tr></tbody></table></figure>

<p>由代码可知，首先创建非阻塞的Socket，并对property_set_fd 监听，这样创建的Socket 就成为server，也就是属性服务；listener的参数意味着可以同时为8个试图设置属性的用户服务。最后使用epoll 来监听property_set_fd ：<strong>当property_set_fd中有数据到来时，init进程将调用handle_property_set_fd函数处理。</strong></p>
<blockquote>
<p>epoll是linux下多路复用I/O接口，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU的利用率。</p>
</blockquote>
<p>对属性进行修改时，首先判断属性的合法性，之后查找属性，如果属性存在就更新属性值，否则添加属性。</p>
<h3 id="init进程启动总结"><a href="#init进程启动总结" class="headerlink" title="init进程启动总结"></a>init进程启动总结</h3><p>主要做了3件事：1、创建和挂载启动所需文件目录  2、启动服务属性  3、解析init.rc ，并启动 Zygote 进程。</p>
<h2 id="Zygote进程启动过程"><a href="#Zygote进程启动过程" class="headerlink" title="Zygote进程启动过程"></a>Zygote进程启动过程</h2><p>在Android系统中，DVM(或者ART)、应用程序进程、SystemServer进程等都是由Zygote进程创建的。由于Zygote在启动时会创建 DVM(或者ART)，因此其fork的应用程序进程和SystemServer进程可以在内部获取一个 DVM 或者 ART。</p>
<p>在Zygote 中通过 JNI 调用 ZygoteInit(<font color="#008000">ZygoteInit是由Java编写的</font>)的 main 方法后，Zygote 便进入了Java 框架层，<strong>此前没有任何代码进入Java框架层的。</strong>即Zygote开创了Java框架层。</p>
<p>ZygoteInit的main方法中主要代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/com/android/internal/os/Zygotelnit.java </span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//创建一个 Server 端的 Socket socketName 的值为"zygote"</span></span><br><span class="line">zygoteServer.registerServerSocket(socketName);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//预加载类和资源</span></span><br><span class="line">preload(b otT U.ngsTraceLog);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (startSystemServer) { </span><br><span class="line">    <span class="comment">//启动 SystemServer 进程</span></span><br><span class="line">    startSystermServer(abiList, socketName, zygoteServer);</span><br><span class="line">}</span><br><span class="line">／／等待 AMS 请求</span><br><span class="line">zygoteServer.runSelectLoop(abiList);</span><br></pre></td></tr></tbody></table></figure>

<p>由代码可知，通过 registerServerSocket 方法创建一个Server端的Socket ，<strong><font color="#008000">这个名为 “zygote” 的Socket 用于等待 ActivityManagerService 请求 Zygote 来创建新的应用程序进程</font></strong>。总结一下，ZygoteInit 的main方法总共做了4件事：</p>
<ol>
<li>创建一个Server端的Socket    </li>
<li>预加载类和资源    </li>
<li>启动 SystemServer 进程    </li>
<li>等待 AMS 请求创建新的应用程序进程    </li>
</ol>
<h3 id="Zygote-进程启动总结"><a href="#Zygote-进程启动总结" class="headerlink" title="Zygote 进程启动总结"></a>Zygote 进程启动总结</h3><p>Zygote进程启动共做了以下几件事：</p>
<ol>
<li>创建AppRuntime ，并调用其start方法，启动Zygote 进程    </li>
<li>创建java虚拟机并未Java虚拟机注册 JNI 方法    </li>
<li>通过 JNI 调用ZygoteInit 的main函数进入Zygote 的Java 框架层    </li>
<li>通过 registerServerSocket 创建服务端 Socket ，循环等待AMS 请求来创建新的应用程序进程。    </li>
<li>启动 SystemServer    </li>
</ol>
<h2 id="SystemServer-处理过程"><a href="#SystemServer-处理过程" class="headerlink" title="SystemServer 处理过程"></a>SystemServer 处理过程</h2><p>SystemServer 进程主要用于创建系统服务，如 AMS、WMS、PMS 。在 ZygoteInit.java 中启动了 SystemServer，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span> <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException｛</span></span><br><span class="line"><span class="function">    <span class="comment">//当前运行在 SystemServer 进程中</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(p == <span class="number">0</span>)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) {</span><br><span class="line">            waitForSecondaryZygote (socketName ); </span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//关闭 Zygote 进程创建的 Socket</span></span><br><span class="line">        zygoteServer . closeServerSocket() ; <span class="comment">//1 </span></span><br><span class="line">        handleSystemServerProcess(parsedArgs) ; <span class="comment">//2 </span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>由以上代码可知，SystemServer 进程复制了 Zygote 进程的地址空间，因此也会得到Zygote 创建的 server Socket，这个socket对SystemServer 没有用处，因此在代码 1处将其关闭，之后通过 handleSystemServerProcess 方法启动 SystemServer 进程。接下来，在ZygoteInit中<strong>创建了 PathClassLoader</strong>，并且通过native 方法 ZygoteInit.nativeZygotelnit <strong>启动了Binder线程池</strong>，之后进入 SystemServer 的main 方法。</p>
<p>SystemServer 的run 方法中用  SystemServiceManager 启动了  ActivityManagerService、 PackageManagerService 等服务。在PackageManagerService 创建完成后，将其注册到 ServiceManager 中，<font color="#008000">ServiceManager 用于管理系统中各种Service，用于系统C/S 架构中的Binder 通信机制：Client端要使用某个Service，需要先到 ServiceManager 中查询Service 的相关信息，然后与Service 所在的Server 进程建立通信通路，这样Client就可以使用Service 了</font>。</p>
<h3 id="SystemServer-进程总结"><a href="#SystemServer-进程总结" class="headerlink" title="SystemServer 进程总结"></a>SystemServer 进程总结</h3><p>SystemServer 进程被创建后，主要工作：</p>
<ol>
<li>启动Binder 线程池，这样可以与其他进程通信。    </li>
<li>创建 SystemServiceManager，创建和管理系统服务    </li>
<li>启动各种服务    </li>
</ol>
<h2 id="Launcher-启动过程"><a href="#Launcher-启动过程" class="headerlink" title="Launcher 启动过程"></a>Launcher 启动过程</h2><p>系统启动的最后一步是启动一个应用程序来显示系统中已经安装的应用程序，即 Launcher。Launcher 在启动过程中请求 PackageManagerService 获取系统中已经安装的应用程序信息，并且将信息封装成一个个快捷图标列表显示在系统屏幕上，用户就可以通过点击图标来启动相应的应用程序了。Launcher 的启动过程时序图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC2%E7%AB%A0/Launcher%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE.jpeg" alt="Launcher的启动过程时序图"></p>
<p>启动Launcher的入口方法为AMS 的systemReady 方法，该方法在SystemServer 的startOtherService中被调用，之后调用 ActivityStack 的resumeTopActivityUncheckedLocked 方法，ActivityStack 用于描述Activity 栈的。最终调用到 AMS 的 startHomeActivityLocked 方法，在该方法中，创建了 Launcher 启动所需的 Intent，并且在一系列判断后，将该Intent 的 Action 设置为 Intent.ACTION_MAIN 、Category 为 Intent.CATEGORY_HOME，并且在 Launcher 的AndroidManifest 中也是这么配置的。</p>
<p>经过以上操作，com.android.launcher3.Launcher 的Activity 就成为了主 Activity，此时，如果Launcher 还未启动，AMS 就会调用 ActivityStarter 的 startHomeActivityLocked 来启动 Launcher 。</p>
<h2 id="Android系统启动流程"><a href="#Android系统启动流程" class="headerlink" title="Android系统启动流程"></a>Android系统启动流程</h2><p>结合前面几节内容，可以总结出Android系统启动流程：</p>
<ol>
<li><p>启动电源以及系统启动     </p>
<blockquote>
<p>按下电源键，从预定义地方开始执行，加载BootLoader 到RAM。</p>
</blockquote>
</li>
<li><p>引导程序BootLoader     </p>
<blockquote>
<p>主要作用是拉起系统OS。</p>
</blockquote>
</li>
<li><p>Linux 内核启动      </p>
<blockquote>
<p>内核启动，设置缓存、计划表、加载驱动等，之后寻找 init.rc 文件，并启动init 进程。</p>
</blockquote>
</li>
<li><p>init 进程启动      </p>
<blockquote>
<p>初始化和启动属性服务，并启动 Zygote 进程。</p>
</blockquote>
</li>
<li><p>Zygote进程启动     </p>
<blockquote>
<p>创建Java虚拟机，并未Java虚拟机注册 JNI 方法，创建服务端 Socket 循环等待AMS 请求来创建新的应用程序进程</p>
</blockquote>
</li>
<li><p>SystemServer 进程启动     </p>
<blockquote>
<p>启动Binder 线程池 和 SystemServiceManager ，并启动各种服务。</p>
</blockquote>
</li>
<li><p>Launcher启动   </p>
<blockquote>
<p>SystemServer 进程启动的 AMS 会启动 Launcher，Launcher 会将已安装的应用显示到界面上。</p>
</blockquote>
</li>
</ol>
<p>用图表示就是：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC2%E7%AB%A0/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.jpeg" alt="Android系统启动流程图"></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2019/11/22/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/22/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">面试题-网络知识</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-22 15:00:00" itemprop="dateCreated datePublished" datetime="2019-11-22T15:00:00+08:00">2019-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-25 15:41:11" itemprop="dateModified" datetime="2022-02-25T15:41:11+08:00">2022-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1、TCP-IP-三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）"><a href="#1、TCP-IP-三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）" class="headerlink" title="1、TCP/IP 三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）"></a>1、TCP/IP 三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）</h2><p><strong>首先要会画 三次握手和四次挥手 的图。很重要，画了两次错了</strong></p>
<h3 id="3次握手的示意图如下："><a href="#3次握手的示意图如下：" class="headerlink" title="3次握手的示意图如下："></a>3次握手的示意图如下：</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p>
<p>三次握手过程：TCP发起的一方A，由操作系统生成一个序列号 n，以这个n为原点，对自己每个将要发送的数据进行编号，连接的另一方 B 会对A每次发送的数据进行确认，如果A收到B的确认编号2001，则可以认为 n~2000编号已经全部到达B。</p>
<h3 id="为什么三次握手"><a href="#为什么三次握手" class="headerlink" title="为什么三次握手"></a>为什么三次握手</h3><ol>
<li>首先，三次握手证明双方收发能力正常    </li>
<li>其次，如果只需要两次握手，那第二次(从server发到client端)之后server就分配资源了，但是如果第二次丢失了，那就造成资源浪费    </li>
<li>还有，如果client没有收到确认，就会再次发送握手连接，如果服务端先接到了第二个消息，然后发送返回确认，双方通信完毕，关闭。这时候第一个请求到了服务端，服务端确认，然而客户端已经关闭了，不理睬，这时候服务端只能一直等。    </li>
<li>还有，握手就确认了双方的序列号规则    </li>
</ol>
<h3 id="可以不握手吗？"><a href="#可以不握手吗？" class="headerlink" title="可以不握手吗？"></a>可以不握手吗？</h3><p>tcp实现可靠通信与 报文序号和确认号(ack) 是分不开的，我们知道握手是干的啥，其中就有告知初始序号的功能，所以不能不握手。</p>
<h3 id="4次挥手示意图："><a href="#4次挥手示意图：" class="headerlink" title="4次挥手示意图："></a>4次挥手示意图：</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p>
<p>由上图看出，由client端发起挥手，server给client的2次回复中，一次是确认信息ack，一次是数据的传送，那可不可以只要3次挥手呢？答案是可能的，TCP是全双工的，Client在没有数据需要发送给Server后，就发送FIN告知server，然后终止对server发送消息，但这个时候server还以发送数据给client，这时候需要4次；但是如果server收到client的FIN后再也没有数据要发给client了，那么 对client的ack包和server自己的FIN包就能合并成一个包发送过去，四次挥手变成3次。</p>
<p>了解完挥手完成后，可能还想更深入了解 TIME_WAIT，可以查看<a href="https://glassx.github.io/2018/05/21/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0/">之前写的这篇</a>。</p>
<h2 id="2、延伸-握手可能有什么安全问题"><a href="#2、延伸-握手可能有什么安全问题" class="headerlink" title="2、延伸-握手可能有什么安全问题"></a>2、延伸-握手可能有什么安全问题</h2><p>首先，发起请求时候的序列是随机的，为什么是随机的呢？想想如果是固定的从0开始，那么客户端发送多次握手(重传)，那么，当新连接建立之后，如果上一次的请求再过来了，序列还是 0 ，那就乱了。相反，如果序列不固定，那么上一次的过来，我只要和新连接这里对比下 序列号 就知道是否合法了。</p>
<ul>
<li>client第一个 SYN 包丢失，这个无所谓，后续触发重传机制，隔5s，24s等     </li>
<li>server 收到 SYN ，但是回复的 SYN，ACK 丢失，也会触发重传，可能依次隔 3s,6s,12s 等    </li>
<li>client 最后依次发送的 ACK 丢了，server 因为没收到 ACK 而实现重传，但是client 已经进入 ESTABLISHED 状态了。因为多数情况下，client 发送完最后的 ACK之后，就认为连接建立，开始发送数据。现实中的情况是，在这种情况下 server 收到 client 的数据会进入 ESTABLISH 状态，并会认为数据有效。     </li>
<li>如果client 故意不发最后一次 ACK，那么服务端处于<strong>半连接状态</strong>，如果这种半连接很多的话，server 端很有压力，因为需要一直重传</li>
</ul>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102197175">知乎上的文章</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/85557012">知乎上的文章1</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/53658729/answer/498879547">知乎-泪花的回答</a>     </p>
</blockquote>
<h2 id="3、延伸-三次握手可以携带数据吗？"><a href="#3、延伸-三次握手可以携带数据吗？" class="headerlink" title="3、延伸-三次握手可以携带数据吗？"></a>3、延伸-三次握手可以携带数据吗？</h2><p>第一次、第二次不可以，第三次可以。想想为什么？</p>
<ul>
<li>假如第一次允许带数据，那么攻击者只需要在第一次SYN中放入大量数据，根本不考虑服务器接收能力，这会让server 花费很长时间和很多空间来处理这些报文       </li>
<li>并且，第一次不知道server 是否有接收能力；如果放第二次，server 也不知道clien 是否有接收能力。    </li>
</ul>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102197175">知乎上的文章</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/85557012">知乎上的文章1</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/53658729/answer/498879547">知乎-泪花的回答</a></p>
</blockquote>
<h2 id="4、引申——为什么要等待2MSL？"><a href="#4、引申——为什么要等待2MSL？" class="headerlink" title="4、引申——为什么要等待2MSL？"></a>4、引申——为什么要等待2MSL？</h2><p>原因有二：<strong>保证TCP协议的全双工连接能够可靠关闭</strong> 以及 <strong>保证这次连接的重复数据段从网络中消失</strong></p>
<p>第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p>
<p>第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p>
<h2 id="5、IP地址分类（A-B-C-D类）"><a href="#5、IP地址分类（A-B-C-D类）" class="headerlink" title="5、IP地址分类（A/B/C/D类）"></a>5、IP地址分类（A/B/C/D类）</h2><p>IP地址由四段组成，每个字段是一个字节，即4个字节、 每个字节有8位，最大值是255，IP地址 = 网络号+主机号。分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/ip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" alt="ip地址分类"></p>
<p>由图可知：</p>
<blockquote>
<p>A类：前1个字节(8位)为网络号，后3个字节(24位)为主机号。A类第1位必须是0<br>B类：前2个字节(16位)为网络号，后2个字节(16位)为主机号。B类前两位固定为10<br>C类：前3个字节(24位)为网络号，后1个字节(8位)为主机号。C类前3位固定为110<br>D类： 是多播地址，一般用于多路广播用户。该类IP地址的最前面为1110<br>E类： 是保留地址。该类IP地址的最前面为1111</p>
</blockquote>
<h2 id="6、TCP与UDP区别"><a href="#6、TCP与UDP区别" class="headerlink" title="6、TCP与UDP区别"></a>6、TCP与UDP区别</h2><ol>
<li>UDP发送数据前无需建立连接，TCP需要握手建立连接。    </li>
<li>UDP尽最大努力交付,不保证可靠交付；TCP提供可靠交付。    </li>
<li>UDP面向报文，对应用程序交下来的报文，在添加首部之后就交付给Ip层，不会对报文拆分；TCP面向字节流，会对应用程序的报文进行拆分。    </li>
<li>UDP支持一对一、一对多、多对一和多对一的通信；TCP全双工通信，并且只能点对点通信，允许通信双方在任何时候均能通信。    </li>
<li>UDP首部开销小，TCP开销大（UDP 8个字节，TCP20个字节）。    </li>
<li>UDP没有拥塞控制，在网络条件差的情况下发送端也不会降低发送速率；TCP有拥塞控制，慢开始避免拥塞，快重传、快恢复。  </li>
<li>TCP 通过滑动窗口实现流量控制，UDP 无。  </li>
</ol>
<p>需要参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/108822858">知乎上的讲解</a>)重写一下</p>
<h2 id="7、引申-TCP流量控制"><a href="#7、引申-TCP流量控制" class="headerlink" title="7、引申-TCP流量控制"></a>7、引申-TCP流量控制</h2><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p>
<p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.jpg" alt="tcp流量控制"></p>
<p>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。</p>
<p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p>
<h2 id="8、引申-快重传和快恢复"><a href="#8、引申-快重传和快恢复" class="headerlink" title="8、引申-快重传和快恢复"></a>8、引申-快重传和快恢复</h2><ul>
<li>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</li>
</ul>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E5%BF%AB%E9%87%8D%E4%BC%A0.webp" alt="快重传"></p>
<ul>
<li>快恢复：当发送方连续收到三个重复确认，就开始执行拥塞避免算法，缩小拥塞窗口，随后再使拥塞窗口缓慢地线性增大。</li>
</ul>
<h2 id="9、Http和Https的区别？"><a href="#9、Http和Https的区别？" class="headerlink" title="9、Http和Https的区别？"></a>9、Http和Https的区别？</h2><blockquote>
<p>Https是ssl加密传输，Http是明文传输<br>Https是使用端口443，而Http使用80<br>HttpsSSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比Http协议安全<br>Https协议需要到CA申请证书</p>
</blockquote>
<h2 id="10、中间人攻击"><a href="#10、中间人攻击" class="headerlink" title="10、中间人攻击"></a>10、中间人攻击</h2><p>带着下列问题去了解Https 安全性：</p>
<ul>
<li>为什么用了https 就是安全的？用了https就一定安全吗？    </li>
<li>https 的底层原理如何？    </li>
</ul>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="https的原理"><a href="#https的原理" class="headerlink" title="https的原理"></a>https的原理</h3><p>https的整体过程分为证书验证和数据传输阶段，具体交互如下图：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/https%E6%95%B4%E4%BD%93%E8%BF%87%E7%A8%8B.jpg" alt="https整体过程"></p>
<p>所以证书验证阶段流程就是：</p>
<ol>
<li>客户端发起https 请求     </li>
<li>服务端返回https 证书      </li>
<li>客户端验证证书是否合法</li>
</ol>
<p>数据传输阶段流程就是：</p>
<ol>
<li>证书合法后，在本地生成随机数    </li>
<li>通过公钥加密随机数，并把加密后的随机数传输给服务端    </li>
<li>服务端通过私钥对随机数解密     </li>
<li>服务端<strong>通过客户端传入的随机数构造对称加密算法</strong>，对返回结果内容进行加密后传输</li>
</ol>
<p>那我们再引申一下，为什么后来要使用对称加密传输数据。这是因为：</p>
<ul>
<li>非对称加密的效率低    </li>
<li>https 上述场景中，只有服务端保存了私钥，一对公私钥只能单向加解密，而对称加密可以实现双向的加解密</li>
</ul>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>了解以上原理之后，中间人攻击的具体流程如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="中间人攻击流程图"></p>
<p>主要包括以下步骤：</p>
<ol>
<li>本地请求被劫持(如dns劫持等)，所有请求均发送到中间人的服务器    </li>
<li>中间人<strong>返回自己自己的证书</strong>    </li>
<li>客户端创建随机数并通过中间人的证书公钥加密，之后凭随机数构造对称加密对传输内容加密    </li>
<li>中间人用私钥解密随机数，此时中间人拥有客户端的随机数，所以可以通过对称加密算法解密内容    </li>
<li>中间人再以客户端的请求内容向正规服务器发送请求，此时中间人发起的请求就是正规请求了，数据也是正规数据，所以合法，正规服务器会通过建立的安全通道返回加密数据      </li>
<li>此后流程都是合法化的了，中间人只是做了个转发而已     </li>
</ol>
<p>以上，就是中间人攻击的流程，我们日常使用的fiddler 代理，其实就很好地模拟了中间人攻击。因为我们使用fiddler 代理https 的时候，需要本地信任fiddler 的证书，其实就是中间人返回自己的证书过程，中间人攻击关键也是这一步。</p>
<p>一般客户端会验证证书的合法性，所以中间人的证书没有这么容易被信任，中间人攻击的难点也在这。</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/95293098">知乎-Java面试那些事儿</a></p>
</blockquote>
<h2 id="11、TCP-IP-流量控制，拥塞避免，可以结合这篇文章"><a href="#11、TCP-IP-流量控制，拥塞避免，可以结合这篇文章" class="headerlink" title="11、TCP/IP 流量控制，拥塞避免，可以结合这篇文章"></a>11、TCP/IP 流量控制，拥塞避免，可以结合<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486825&amp;idx=1&amp;sn=db596ed4b69bd9220f6a8ad79ef308db">这篇文章</a></h2><h2 id="12、Session-和-Cookie-的区别？"><a href="#12、Session-和-Cookie-的区别？" class="headerlink" title="12、Session 和 Cookie 的区别？"></a>12、Session 和 Cookie 的区别？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<p>HTTP是一种无状态的协议，为了分辨链接是谁发起的，Session和Cookie就是为解决这个问题而提出来的两个机制。<br><strong>Cookies是服务器下发，存储到本地机器上的一段文本，并随每一个请求发回服务器，是在客户端保持状态的方案。</strong><br>浏览器第一次发送请求时，服务器自动生成了一HashTable和一个Session ID来唯一标识这个HashTable，并将其通过响应发送回浏览器。Session的实现方式和Cookie有一定关系，一般会把session id存在Cookie中（<strong>也可以依赖于url重写</strong>），每次访问的时候将Session id带过去，服务器就根据id查找hashtable就可以识别当前用户状态了。<br>所以可以总结，cookie存在本地，session存在服务器；父路径不能享用子路径的cookies，而同一个session的窗口可以共享session；cookie没有session可靠。</p>
</blockquote>
</details>


<h2 id="13、在浏览器中输入www-baidu-com后执行的全部过程"><a href="#13、在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="13、在浏览器中输入www.baidu.com后执行的全部过程"></a>13、在浏览器中输入<a target="_blank" rel="noopener" href="http://www.baidu.com后执行的全部过程">www.baidu.com后执行的全部过程</a></h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ol>
<li><p>客户端浏览器通过DNS解析到<a target="_blank" rel="noopener" href="http://www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></p>
</li>
<li><p>在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</p>
</li>
<li><p>客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
</li>
<li><p>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p>
</li>
</ol>
</details>

<h2 id="14、HTTP中，POST与GET的区别"><a href="#14、HTTP中，POST与GET的区别" class="headerlink" title="14、HTTP中，POST与GET的区别"></a>14、HTTP中，POST与GET的区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ol>
<li><p>Get是从服务器上获取数据，Post是向服务器传送数据。</p>
</li>
<li><p>Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中科院看到。</p>
</li>
<li><p>Get传送的数据量小，不能大于2KB；post传送的数据量较大，一般被默认为不受限制。</p>
</li>
<li><p>根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p>
</li>
</ol>
</details>

<h2 id="15、http2-与http1-的区别"><a href="#15、http2-与http1-的区别" class="headerlink" title="15、http2 与http1 的区别"></a>15、http2 与http1 的区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>总结一下：1)、新的二进制格式  2)、多路复用   3)、header 压缩   4)、采用新的压缩算法  5)、server push  6)、更安全的SSL</p>
<ul>
<li>新的二进制格式    </li>
</ul>
<p><strong>解释：</strong> http1 设计的时候是基于文本，http2 基于二进制格式。http2 的格式定义更接近tcp层的方式，length 定义了整个frame 的开始到结束，type 定义了frame 的类型，stream id 用作流控制。如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.jpg" alt="http2格式变化"></p>
<p>虽然看上去写一个是和http1完全不同了，实际上并没有改变http1的语义，只是把http1的header 和 body 用frame 重新封装了一层而已。他们的对应关系如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E4%B8%8Ehttp1%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.jpg" alt="http2与http1对应关系"></p>
<p>上述http1的首部信息会封装到 Header 的 frame，而相应的 body 封装到 Data frame。</p>
<ul>
<li>多路复用    </li>
</ul>
<p><strong>解释：</strong>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。一个request对应一个 stream 并分配一个id，这样一个连接上可以有多个stream，每个stream 的frame 可以随机地混杂在一起，接收方可以根据stream id 将各个frame 再归属到不同的request 里面。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E8%BF%9E%E6%8E%A5%E5%85%B1%E4%BA%AB.jpg" alt="http2连接共享"></p>
<p>http 性能优化的关键并不在于<strong>高带宽</strong>，而是<strong>低延迟</strong>，tcp 连接会随着时间进行自我“调谐”，起初会限制最大速度，如果传输成功，会随着时间提高传输的速度，这种调谐称为“慢启动”。http2 通过让所有数据流共用同一个连接，可以更高效地使用TCP。</p>
<p>客户端依据域名来向服务器建立连接，一般pc端浏览器会针对单个域名的server 同时建立 6~8 个连接，<strong>连接无法复用会导致请求要经历三次握手和慢启动</strong>。在http1中，假如有5个连接同时发出，在第一个请求没有收到回复之前，后续从应用层发出的请求只能排队，请求2，3，4，5只能等请求1的response 回来之后才能逐个发出。网络通畅的时候性能影响不大，一旦请求1的request 因为什么原因没有抵达服务器，影响到后续所有的请求，问题就比较严重了。</p>
<ul>
<li>header 压缩    </li>
</ul>
<p><strong>解释：</strong>http2针对header 采用新的压缩方式，高效地压缩算法可以很大地压缩header。并且，通讯双方各自缓存一份 header fields 表，避免重复header 的传输。</p>
<ul>
<li>采用新的压缩算法</li>
</ul>
<p><strong>解释：</strong>http2在采用gzip之外的新的压缩算法，更加安全。</p>
<ul>
<li>server push</li>
</ul>
<p><strong>解释：</strong>http2 能通过push的方式将客户端需要的内容预先推送过去。</p>
<ul>
<li>更安全的SSL</li>
</ul>
<p><strong>解释：</strong>http2.0 对 tls 的安全性做了进一步加强。</p>
</details>
&gt; 以上内容参考自[知乎上的回答](https://www.zhihu.com/question/34074946)

<h2 id="16、网络状态码？以-2、3、4、5-开头的代表什么意思。"><a href="#16、网络状态码？以-2、3、4、5-开头的代表什么意思。" class="headerlink" title="16、网络状态码？以 2、3、4、5 开头的代表什么意思。"></a>16、网络状态码？以 2、3、4、5 开头的代表什么意思。</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="1xx-临时响应"><a href="#1xx-临时响应" class="headerlink" title="1xx-临时响应"></a>1xx-临时响应</h3><p>100： 继续。请求者应当继续提出请求<br>101： 切换协议。请求者要求服务器切换协议，服务器确认并准备切换   </p>
<h3 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx-成功"></a>2xx-成功</h3><p>200： 成功。服务器成功处理请求<br>201： 已创建。请求成功并且服务器创建了新的资源<br>202： 已接受。 服务器接受请求，但是尚未处理<br>203： 非授权信息。服务器成功处理请求，但返回的信息可能来自另一来源<br>204： 无内容。服务器成功处理请求，但是没有返回任何内容<br>205： 重置内容。服务器成功处理请求，但是没有返回任何内容<br>206： 部分内容。服务器成功处理了部分GET请求</p>
<h3 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx-重定向"></a>3xx-重定向</h3><p>300： 多种选择。服务器根据请求者选择一项操作，火提供操作列表供请求者选择<br>301： 永久移动。请求的资源永久移动到新位置了，返回此响应时会自动转到新位置<br>302： 临时移动。从不同位置响应请求，但是后续还是以原来位置继续请求<br>303： 查看其它位置。<br>304： 未修改。自上次请求后，请求的网页未修改过，此时不会返回网页内容<br>305： 使用代理。请求者只能使用代理访问请求的网页。    </p>
<h3 id="4xx-请求错误"><a href="#4xx-请求错误" class="headerlink" title="4xx-请求错误"></a>4xx-请求错误</h3><p>400： 错误请求。服务器不理解请求语法<br>401： 未授权。请求要求身份验证<br>403： 进制。服务器拒绝请求<br>404： 未找到。服务器找不到请求的网页<br>405： 方法禁用。禁用请求中指定的方法<br>408： 请求超时。服务器等候请求时发生超时<br>410： 已删除。请求的资源已永久删除<br>413： 请求实体过大。请求实体过大，服务器无法响应<br>414： 请求的URI过长。请求的URI（通常为网址）过长，无法处理<br>415： 不支持的媒体类型。</p>
<h3 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx-服务器错误"></a>5xx-服务器错误</h3><p>500： 服务器内部错误。服务器遇到错误，无法完成请求<br>501： 尚未实施。服务器不具备完成请求的功能<br>502： 错误网关。<br>503： 服务不可用。暂时地维护或者超载了<br>504： 网关超时。服务器作为网关或者代理，但是没有及时从上游服务器收到请求<br>505： HTTP版本不支持。服务器不支持请求中所用的HTTP协议版本   </p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="http://tool.chinaz.com/pagestatus/">站长工具</a> </p>
</blockquote>
<h2 id="17、HttpDNS"><a href="#17、HttpDNS" class="headerlink" title="17、HttpDNS"></a>17、HttpDNS</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="当前-DNS-系统存在的问题"><a href="#当前-DNS-系统存在的问题" class="headerlink" title="当前 DNS 系统存在的问题"></a>当前 DNS 系统存在的问题</h3><ul>
<li>域名缓存。运营商的 LocalDNS 会缓存域名解析的结果，而不是向权威域名发起递归。运营商缓存dns就可以实现把dns解析结果指向广告</li>
<li>解析转发。运营商自身不进行域名递归解析，而是把它发给其它运营商。一些小运营商就是这样做的。这样，比如说访问的是qq.com，则腾讯的权威dns收到的域名解析请求的来源就变成了其它运营商，最终导致用户流量被导向了错误的IDC，比如明明是广东的用户，被导向去了北京的服务器。    </li>
<li>NAT ，网络地址转换。运营商LocalDNS出口根据权威DNS目标ip进行NAT，导致腾讯权威dns无法正确识别运营商的 LocalDNS 的ip，引发域名解析错误，流量跨网等</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>使用 114 等中立DNS 服务器</p>
</li>
<li><p>使用HttpDNS，HttpDNS 的基本原理如下：</p>
</li>
</ul>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/HttpDNS%E5%8E%9F%E7%90%86.webp" alt="HttpDNS的原理"></p>
<p><strong>注意：HttpDNS主要用于客户端</strong></p>
<p>HttpDNS 的使用过程主要有两步：</p>
<ol>
<li>客户端直接访问HttpDNS 接口，获取Host对应的IP。     </li>
<li>客户端通过IP，向后台发送请求。以Http为例，通过在Header中指定host 字段，向HttpDNS 返回的IP 发送标准的Http请求即可。</li>
</ol>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/u6-53Kp9Jb48dKWzaJOKig">鹅厂网事上的博客</a></p>
</blockquote>
<h2 id="18、https的证书验证"><a href="#18、https的证书验证" class="headerlink" title="18、https的证书验证"></a>18、https的证书验证</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>证书是一级一级的验证的，验证当前的证书时，首先拿上一级的证书的公钥，用上一级的公钥来验证当前证书的签名，验证成功就通过，不成功就报错了。然后一级一级上去，顶级。因为本地(浏览器和操作系统)一般存有信任的根证书，顶级证书一般都能通过本地证书验证。</p>
</details>

<blockquote>
<p>以上内容可以参考<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/37370216">知乎上的内容</a></p>
</blockquote>
<h2 id="19、https的攻击方式"><a href="#19、https的攻击方式" class="headerlink" title="19、https的攻击方式"></a>19、https的攻击方式</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>1、中间人攻击。类似Fiddler 这种方式，前提是黑客通过某种特殊手段在被攻击者的手机上安装了根证书<br>2、Https协议降级攻击。比如说client端仅仅支持某个有漏洞的ssl版本(比如SSLv3.0)，那么服务端只能接收或者直接拒绝。如果接受的话，攻击者就能攻击(应该是 Padding Oracle 攻击)<br>3、使用对称加密的时候破解的对称加密</p>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/22917510">知乎的博客</a>、<a target="_blank" rel="noopener" href="https://blog.fundebug.com/2019/09/17/mitm-for-https/">中间人攻击</a></p>
</blockquote>
<h2 id="20、到底使用什么时候使用-GET-请求，什么时候使用-POST-请求？"><a href="#20、到底使用什么时候使用-GET-请求，什么时候使用-POST-请求？" class="headerlink" title="20、到底使用什么时候使用 GET 请求，什么时候使用 POST 请求？"></a>20、到底使用什么时候使用 GET 请求，什么时候使用 POST 请求？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>当请求无副作用（如搜索）的时候，可以使用 GET 方法；当请求有副作用（如添加数据）的时候，则使用 POST 。不过有个很实际的问题： <strong>GET 方法可能会产生很长的 url ，并且某些浏览器和服务器对 GET 请求的 url 长度是有限制的 ！</strong></p>
<p>若符合下列任一情况，用 POST : </p>
<ul>
<li>请求的结果有持续性的副作用</li>
<li>使用 GET 方法会使 url 过长</li>
<li>要传送的数据不是采用 7 位的 ASCII 编码</li>
</ul>
<p>若符合下列任一情况，用 GET：</p>
<ul>
<li>请求是为了查找资源</li>
<li>请求的结果无持续性副作用</li>
<li>收集的数据及 HTML 表单内输入字段名称的总长度不超过 1024 个字符</li>
</ul>
</details>



<blockquote>
<p>以上内容<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zy20160117/p/10973067.html">参考自 cnblogs 博客</a></p>
</blockquote>
<h2 id="21、TCP相关问题"><a href="#21、TCP相关问题" class="headerlink" title="21、TCP相关问题"></a>21、TCP相关问题</h2><h3 id="粘包处理"><a href="#粘包处理" class="headerlink" title="粘包处理"></a>粘包处理</h3><p>TCP 两端 A、B 建立了连接后，A 端先发送 100 个字节，再发送 100 个字节。那么 B 端会分别收到两次 100 字节吗？ <strong>答案是不一定</strong>。</p>
<p>我们常说 TCP 是一种流式连接，这个流字到底怎么理解？它是指 TCP 的数据传输就像一种水流一样，并不区分不同数据包之间的界限。</p>
<p>看过 TCP 协议内容的人就可以发现，TCP 协议允许发送端将几次发送的数据包缓存起来合成一个数据包发送到网络上去，因为这样可以获得更高的效率，这一行为通常是在操作系统提供的 SOCKET 中实现，所以在应用层对此毫无所觉。 所以我们在程序中调用 send 发送超过 MTU 的数据包时，操作系统提供的 SOCKET 的 send 发送了数据后，操作系统有可能缓存了起来，等待后续的数据一起发送，而不是立即发送出去。</p>
<p>分包发送 网络传输的概念中有 MTU 的概念，也即是网络中一个数据包最大的长度。如果要发送超过这个长度的数据包，就需要分包发送。当调用 SOCKET 的 send 发送超过 MTU 的数据包时，操作系统提供的 SOCKET 实现会自动将这个数据包分割成几个不超过 MTU 的数据包发送。 当出现这些上面这些情况的时候，接收端就会发现接收到的数据和发送的数据的次数不一致。这个就是<strong>粘包现象</strong>。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>当我们传输如文件这种数据时，流式的传输非常适合，但是当我们传输指令之类的数据结构时，流式模型就有一个问题：无法知道指令的结束。<strong>所以粘包问题是必须要解决的</strong>。</p>
<h4 id="粘包问题解决方案"><a href="#粘包问题解决方案" class="headerlink" title="粘包问题解决方案"></a>粘包问题解决方案</h4><ul>
<li>短连接。需要发送数据的时候建立 TCP 连接，发送完一个数据包后就断开 TCP 连接，这样接收端自然就知道数据结束了。这种方案多次建立 TCP 连接，性能低下</li>
<li>长连接。使用长连接能够获得更好的性能但不可避免的会遇到如何判断数据结构的开始与结束的问题。</li>
<li>定长结构。如果发送端发送了一个固定长度的数据结构，接收端必须每次都严格判断接收到额数据的长度，当收到的数据长度不足时，需要再次接收数据，直到满足长度，当收到的数据多于固定长度时，需要截断数据，并将多余的数据缓存起来，视为长度不足需要再次接收处理。 不定长结构<br>定长的数据结构是一种理想的情况，真正的应用中通常使用的都是不定长的数据结构。</li>
<li>不定长结构。<strong>目前最通用的做法是在每次发送的数据的固定偏移位置写入数据包的长度</strong>。<strong>所以对于处理粘包的关键在于提前获取到数据包的长度</strong>。</li>
</ul>
<h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><p>当 TCP 两端 A、B 建立了连接后，如果一端拔掉网线或者拔掉电源，那么另一端能够收到通知吗？</p>
<p><strong>答案是不会</strong></p>
<p>TCP 的建立连接和断开连接都是通过发送数据实现的，也就是我们常说的三次握手、四次挥手。</p>
<p>但是这就说明了一点，如果不发送数据那么是无法断开连接的。正常情况下当 TCP 的一端A调用了 SOCKET 的 close 或者进程结束，操作系统就会按照 TCP 协议发送FIN 数据报文。B 端收到后就会断开连接。但是当出现了上文所说的异常情况时：被拔掉网线或者断掉电源，总结起来就是没有机会发出断开的 FIN 数据报文。那么和 A 直连的路由设备虽然知道 A 设备已经断开了，但是路由设备并没有保存连接的状态信息，所以路由设备也就不可能去通知 B 端 A 端的断开。而 B 端没有收到断开的数据报文就会依然保持连接。<strong>所以 A 端拔掉网线或者断掉电源后 B 端是没办法收到断开连接的通知的。</strong></p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>KEEP_ALIVE</p>
<p>TCP 协议本身就提供了一种这样的机制来探测对端的存活。TCP 协议有一个KEEP_LIVE 开关，只要打开这个开关就会定时发送一些数据长度为零的探测心跳包，发送的频率和次数都可以设置</p>
<h3 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h3><p>TCP 如何保证数据的正确性，保证数据内容不会出错？</p>
<p>大部分人就会开始说丢包重传、接收确认之类的东西，但这些都扯偏了，只要少数人能够正确回答题目要问的问题<strong>：首部校验</strong>。</p>
<p>对于能答上这个问题的人，我会进一步问，这个校验机制能够确保数据传输不会出错吗？</p>
<p><strong>答案是不能</strong>。</p>
<p>TCP 协议中规定，TCP 的首部字段中有一个字段是校验和，发送方将伪首部、TCP 首部、TCP 数据使用累加和校验的方式计算出一个数字，然后存放在首部的校验和字段里，接收者收到 TCP 包后重复这个过程，然后将计算出的校验和和接收到的首部中的校验和比较，如果不一致则说明数据在传输过程中出错。这就是TCP 的数据校验机制。</p>
<p>但是这个机制能够保证检查出一切错误吗？显然不能。因为这种校验方式是累加和，也就是将一系列的数字(TCP 协议规定的是数据中的每 16 个比特位数据作为一个数字)求和后取末位。</p>
<p>但是小学生都知道 A+B=B+A。</p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>在应用层添加一层校验</p>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39705794/article/details/111363610">csdn的博客</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共320.9k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/10/',]
      });
      });
  </script>


</body>
</html>
