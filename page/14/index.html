<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/14/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">37</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">215</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2020/06/27/%E8%AF%BE-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-20%E8%AF%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/27/%E8%AF%BE-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-20%E8%AF%BE/" class="post-title-link" itemprop="url">第20课-UI优化-UI渲染关键概念</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-27 10:32:00" itemprop="dateCreated datePublished" datetime="2020-06-27T10:32:00+08:00">2020-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-05 16:59:16" itemprop="dateModified" datetime="2021-05-05T16:59:16+08:00">2021-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="UI优化-lt-上-gt-20讲"><a href="#UI优化-lt-上-gt-20讲" class="headerlink" title="UI优化<上>-20讲"></a>UI优化&lt;上&gt;-20讲</h2><h3 id="UI渲染的背景知识"><a href="#UI渲染的背景知识" class="headerlink" title="UI渲染的背景知识"></a>UI渲染的背景知识</h3><p>ppi 像素密度，每英寸包含的像素数，这是物理参数，不可改</p>
<p>dpi 像素密度，指的是单位尺寸像素数量。这是可以人为调整的         </p>
<p>density 密度，每平方英寸中包含的像素点数，density = dpi / 160    </p>
<p>dp ： px = dp * density</p>
<h3 id="屏幕适配方案"><a href="#屏幕适配方案" class="headerlink" title="屏幕适配方案"></a>屏幕适配方案</h3><p>使用dp</p>
<p>限制符适配</p>
<h3 id="CPU-与-GPU"><a href="#CPU-与-GPU" class="headerlink" title="CPU 与 GPU"></a>CPU 与 GPU</h3><p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6%E5%92%8C%E7%A1%AC%E4%BB%B6%E7%BB%98%E5%88%B6.png" alt="软件绘制与硬件绘制"></p>
<p>由上面的图可以知道，软件绘制使用的是Skia 库，硬件绘制是通过 open GL 之后在GPU 上实现的        </p>
<p>在Android 7.0以后，添加了对 Vulkan 的支持，它比 OpenGL 功耗和多核优化上更优秀</p>
<h3 id="Android-渲染的演进"><a href="#Android-渲染的演进" class="headerlink" title="Android 渲染的演进"></a>Android 渲染的演进</h3><p>可以通过下图整体看下Android 图形体系：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F.png" alt="Android图形体系"></p>
<p>各个部分的功能可以比喻成以下内容：</p>
<ul>
<li>画笔：Skia 或者 OpenGL 。Skia 使用CPU 绘制，OpenGL 使用 GPU 绘制         </li>
<li>画纸：Surface。所有元素都在 Surface 这张画纸上绘制和渲染。<strong>在Android中，Window 是View的容器，每个Window 都会关联一个Surface</strong>。windowManager 负责管理这些 window ，并且把它们的数据传递给 SurfaceFlinger。   </li>
<li>画板：Graphic Buffer。Graphic Buffer 缓冲用于应用程序图形的绘制，Android 4.1 之前使用的是双缓冲；4.1之后使用三缓冲      </li>
<li>显示：SurfaceFliger 。将WindowManager 提供的所有 Surface ，通过Hardware Composer 合成并输出到显示屏      </li>
</ul>
<h3 id="开启硬件加速"><a href="#开启硬件加速" class="headerlink" title="开启硬件加速"></a>开启硬件加速</h3><p>软件绘制流程图如下：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.png" alt="软件绘制流程"></p>
<ul>
<li>Surface： 每个View 都由某个Window 管理，每个Window 关联一个Surface     </li>
<li>Cavas。通过Surface的lock 函数获得一个Cavas，Cavas 可以理解成Skia 底层接口的封装      </li>
<li>Grapic Buffer。 SurfaceFlinger 帮我们托管 BufferQueue ，我们从BufferQueue 中拿到 Graphic Buffer，然后通过Canvas 和 Skia 将绘制内容栅格化到上面(个人理解为栅格化后的数据保存在这个buffer中)。     </li>
<li>SurfaceFlinger 。通过 Swap Buffer 把 Front Graphic Buffer 的内容交给 SurfaceFlinger ，最后硬件合成器 Hardware Composer 合成并输出到显示屏。      </li>
</ul>
<p>硬件加速绘制流程如下图(3.0以后支持硬件加速)：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E7%A1%AC%E4%BB%B6%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.png" alt="硬件绘制流程"></p>
<p>硬件绘制与软件绘制最核心的区别是<strong>硬件绘制通过GPU完成 Graphic Buffer内容的绘制</strong>，此外，硬件绘制引入了 DisplayList 的概念，<strong>每个View内部都有一个DisplayList，当某个View需要重绘时，将其标记为Dirty，重绘也仅仅只需要重绘一个View的DisplayList</strong>，这样，无需像软件绘制那样向上递归，大大减少绘图的操作数量，提高了渲染效率，更新的过程示意如下：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E7%A1%AC%E4%BB%B6%E7%BB%98%E5%88%B6%E6%9B%B4%E6%96%B0Display.png" alt="硬件绘制更新Display"></p>
<p>硬件加速虽然极大地提高了显示和刷新速度，但是它也存在一些问题，一方面是内存消耗，另一方面是部分绘制函数不支持</p>
<h3 id="Project-Butter-（黄油计划）"><a href="#Project-Butter-（黄油计划）" class="headerlink" title="Project Butter （黄油计划）"></a>Project Butter （黄油计划）</h3><p>4.1的时候，提出黄油计划，主要包括两个方面，一是 VSYNC ,一是 Triple Bufferfing (三缓冲)。</p>
<p>在4.0 及以前，cpu可能在忙别的事情，导致没来得及处理UI 绘制，为了解决这个问题，VSYNC 出现了，它类似于时钟中断，这个信号到来时，CPU立即准备Buffer数据，大部分设备刷新频率都是60Hz，所以一帧数据的准备工作要在 16ms内完成。</p>
<p>4.0及以前，Android使用双缓冲，一般不同的View或者Activity 都会公用一个Window，也就是公用一个Surface，每个Surface 会有一个BufferQueue 缓存队列，这个队列由SurfaceFlinger 管理，<strong>通过匿名共享内存与App应用层交互。</strong>示意图如下：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/app%E4%B8%8Eui%E6%9C%BA%E5%88%B6%E4%BA%A4%E4%BA%92%E5%9B%BE.png" alt="app与ui机制交互图"></p>
<p>整个流程如下：</p>
<p>每个Surface对应的 BufferQueue 内有有两个Graphic Buffer，一个用于绘制，一个用于显示。</p>
<p>同一时刻可能有多个Surface (可能是不同应用的Surface，也可能是同一个应用里面类似SurfaceView 和TexureView ，它们都会有自己单独的Surface)，SurfaceFlinger 把所有的Surface 要显示的内容统一交给 Hardware Composer，它会最终合成屏幕显示的内容。</p>
<p>如果只有两个Buffer，当CPU/GPU 绘制时间过长，则两个缓冲区分别被显示设备和GPU 占用，cpu 无法准备下一帧数据，造成浪费。三个缓冲区的话，cpu、gpu 显示设备都能使用各自的缓冲区工作，个不影响，最大限度利用空闲时间。</p>
<p>在黄油计划之后，Android 5.0 推出了 RenderThread ，将所有GL 命令执行放到 RenderThread 中执行，减轻UI 线程的负担。</p>
<h3 id="数据测量"><a href="#数据测量" class="headerlink" title="数据测量"></a>数据测量</h3><p>可以通过开发者选项中查看过度绘制的情况</p>
<p>还可以使用 Systrace 性能数据采样和分析工具</p>
<p>4.1及以后，可以采用 Tracer for OpenGL ES 逐帧分析</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2020/06/26/%E8%AF%BE-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-18%E3%80%8119%E8%AF%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/26/%E8%AF%BE-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-18%E3%80%8119%E8%AF%BE/" class="post-title-link" itemprop="url">第18课-耗电优化<上></a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-26 17:28:00" itemprop="dateCreated datePublished" datetime="2020-06-26T17:28:00+08:00">2020-06-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-27 10:40:22" itemprop="dateModified" datetime="2020-06-27T10:40:22+08:00">2020-06-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="第18课-耗电优化-lt-上-gt"><a href="#第18课-耗电优化-lt-上-gt" class="headerlink" title="第18课-耗电优化<上>"></a>第18课-耗电优化&lt;上&gt;</h2><p>准确的测量电量并不是那么容易，在<a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/03/11/dianping-shortvideo-battery-testcase.html">《大众点评App的短视频耗电量优化实战》</a>一文中，为我们总结了下面几种电量测试的方法:</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E8%80%97%E7%94%B5%E9%87%8F%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95.png" alt="耗电量测试方法"></p>
<p>当测试反馈耗电问题时，<a target="_blank" rel="noopener" href="https://developer.android.google.cn/studio/debug/bug-report">bug report</a> 结合 <a target="_blank" rel="noopener" href="https://github.com/google/battery-historian">Battery Historian</a> 是最好的排除方法：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//7.0和7.0以后</span><br><span class="line">$ adb bugreport bugreport.zip</span><br><span class="line">//6.0和6.0之前:</span><br><span class="line">$ adb bugreport &gt; bugreport.txt</span><br><span class="line">//通过historian图形化展示结果</span><br><span class="line">python historian.py -a bugreport.txt &gt; battery.html</span><br></pre></td></tr></tbody></table></figure>

<h2 id="19讲-耗电优化-lt-下-gt"><a href="#19讲-耗电优化-lt-下-gt" class="headerlink" title="19讲-耗电优化<下>"></a>19讲-耗电优化&lt;下&gt;</h2><h3 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h3><ul>
<li>耗电优化的第一个优化方向是优化应用后台耗电    </li>
<li>第二个优化方向是符合系统的规则，让系统认为你的耗电是正常的。</li>
</ul>
<p>比如，Android P 通过 Android Vitals 监控后台耗电，所以我们需要符合它的规则，它的规则如下：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android-Vitals%E8%A7%84%E5%88%99.png" alt="Android-Vitals规则"></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2020/06/26/%E8%AF%BE-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-16,17%E8%AF%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/26/%E8%AF%BE-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-16,17%E8%AF%BE/" class="post-title-link" itemprop="url">第16课-网络优化<中></a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-26 11:36:00 / 修改时间：17:39:43" itemprop="dateCreated datePublished" datetime="2020-06-26T11:36:00+08:00">2020-06-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="第16课-网络优化-lt-中-gt"><a href="#第16课-网络优化-lt-中-gt" class="headerlink" title="第16课-网络优化<中>"></a>第16课-网络优化&lt;中&gt;</h2><p>对于速度、弱网络以及安全的优化，该从哪些方面入手，首先我们要弄清楚一个网络请求的整个过程,示意图如下：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B.png" alt="网络请求的完整流程"></p>
<p>可以看出，整个流程分为 发起请求-&gt;DNS解析-&gt;创建连接-&gt;发送/接收数据-&gt;关闭连接    </p>
<h2 id="第17课-网络优化-lt-下-gt-大数据下网络如何监控"><a href="#第17课-网络优化-lt-下-gt-大数据下网络如何监控" class="headerlink" title="第17课-网络优化<下>-大数据下网络如何监控"></a>第17课-网络优化&lt;下&gt;-大数据下网络如何监控</h2><h3 id="插桩"><a href="#插桩" class="headerlink" title="插桩"></a>插桩</h3><p>为了兼容性考虑，首先考虑插桩。如360开源的性能监控工具 ArgusAPM ，就是利用 Aspect 切换插桩，实现监控系统和 OkHttp 网络请求库的请求。</p>
<p>系统网络库的插桩实现可以参考TraceNetTrafficMonitor，主要利用Aspect的切面功能，关于OkHttp的拦截可以参考OkHttp3Aspect，它会更加简单一些，因为OkHttp本身就有代理机制。</p>
<h3 id="Native-Hook"><a href="#Native-Hook" class="headerlink" title="Native Hook"></a>Native Hook</h3><p>hook 本地的代码，需要考虑兼容性</p>
<h3 id="统一网络库"><a href="#统一网络库" class="headerlink" title="统一网络库"></a>统一网络库</h3><p>ios 和Android 都统一使用同一套网络库，统一监控   </p>
<p><strong>小技巧：1、我们可以通过Android官方的 TrafficStats 类来获取整个手机或者某个 UID 从开机算起的网络流量； 2、Android 和 Iphone 都有一个网络测试模式，可以尝试下：</strong></p>
<blockquote>
<p>Android手机：打开拨号界面，输入 <em>#</em>#4636#<em>#</em> ，然后按拨号键（可进入工程测试模式，部分版本可能不支持）<br>iPhone手机：打开拨号界面，输入 <em>3001#12345#</em> ，然后按拨号键。</p>
</blockquote>
<p>自己注：在网上找到的<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/da2a0030962a">微信弱网优化方法</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2020/06/25/%E8%AF%BE-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-13%E8%AF%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/25/%E8%AF%BE-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-13%E8%AF%BE/" class="post-title-link" itemprop="url">第13讲-存储优化<中>-如何优化数据存储</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-25 11:36:00" itemprop="dateCreated datePublished" datetime="2020-06-25T11:36:00+08:00">2020-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-05 17:43:48" itemprop="dateModified" datetime="2021-05-05T17:43:48+08:00">2021-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h3 id="Serializable-的原理"><a href="#Serializable-的原理" class="headerlink" title="Serializable 的原理"></a>Serializable 的原理</h3><p>Serializable 的原理是<strong>通过 ObjectInputStream 和 ObjectOutputStream 来实现的</strong>，通过 Android 6.0 的源码可以看到 ObjectOutPutStream 的部分源码实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeFieldValues</span><span class="params">(Object obj, ObjectStreamClass classDesc)</span>  </span>{</span><br><span class="line">    <span class="keyword">for</span> (ObjectStreamField fieldDesc : classDesc.fields()) {</span><br><span class="line">        ...</span><br><span class="line">        Field field = classDesc.checkAndGetReflectionField(fieldDesc);</span><br><span class="line">        ...</span><br></pre></td></tr></tbody></table></figure>

<p>整个序列化过程使用了大量反射(比如说获取整个类的所有属性，反射意味着效率低)和临时变量(临时变量意味着GC)，并且，<strong>在序列化对象时，不仅会序列化当前对象本身，还需要地柜序列化对象引用的其他对象</strong>，可以参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904049997774856">别人的博客</a>。</p>
<h3 id="Serializable-的进阶"><a href="#Serializable-的进阶" class="headerlink" title="Serializable 的进阶"></a>Serializable 的进阶</h3><p>Serializable 序列化支持使用自定义 writeObject和readObject，他会先反射判断是否存在我们自己实现的 序列化writeObject方法和反序列化readObject 方法。<strong>通过这两个方法，我们可以对某些字段做修改，也能实现序列化的加密功能。</strong></p>
<p>还有，Serializable 的反序列默认是不会执行构造函数的</p>
<h3 id="Parcelable-的永久存储"><a href="#Parcelable-的永久存储" class="headerlink" title="Parcelable 的永久存储"></a>Parcelable 的永久存储</h3><p>一般来说，我们使用 parcelable 只是会在内存中序列化操作，并不会存储到磁盘。其实，我们也可以存储到磁盘的：<strong>通过 Parcel.java 中的 marshall 接口获取byte 数组，然后存在文件中，从而实现 Parcelable 的永久存储。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the raw bytes of the parcel.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] marshall() {</span><br><span class="line">    <span class="keyword">return</span> nativeMarshall(mNativePtr);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Set the bytes in data to be the raw bytes of this Parcel.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unmarshall</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    nativeUnmarshall(mNativePtr, data, offset, length);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不过，一般不推荐这样做，因为可能会有系统版本兼容性问题，因为我们无法保证所有的 Android 版本的 Parcel.cpp 实现完全一致。还有就是数据前后的兼容性，这里并没有类似 Serializable 里面有个 serialVersionUID 来保证版本一致性。</p>
<h2 id="14-数据库优化"><a href="#14-数据库优化" class="headerlink" title="14-数据库优化"></a>14-数据库优化</h2><p>SQLite 默认支持多进程并发操作，它通过文件锁来控制多进程的并发，但是SQLite 的锁粒度并没有非常细，针对的是整个DB文件，简单来说，多进程可以同事获取 SHARED 锁来读取数据，但是只有一个进程可以获取 EXCLUSIVE 锁来写数据库</p>
<p>数据库使用注意：</p>
<ul>
<li>防止注入   </li>
<li>防止窃取      </li>
<li>小表无需维护索引，因为索引是需要一直维护的，有代价        </li>
<li>慎用 “select * “ 需要多少列，就取多少列      </li>
<li>定期删除无用数据             </li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2020/05/30/%E8%AF%BE-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-7,8%E8%AF%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/%E8%AF%BE-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-7,8%E8%AF%BE/" class="post-title-link" itemprop="url">第7、8课-启动优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-30 10:00:00 / 修改时间：10:00:40" itemprop="dateCreated datePublished" datetime="2020-05-30T10:00:00+08:00">2020-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="启动优化-lt-上-gt-第7讲"><a href="#启动优化-lt-上-gt-第7讲" class="headerlink" title="启动优化<上>-第7讲"></a>启动优化&lt;上&gt;-第7讲</h2><h3 id="启动分析"><a href="#启动分析" class="headerlink" title="启动分析"></a>启动分析</h3><p>着手优化之前，首先分析启动过程。</p>
<ol>
<li>首先预览窗口，系统拉起App进程之前，会根据app的Theme属性创建预览窗口。当然，我们禁用预览窗口或者预览窗口为透明时，用户依然可以看到桌面。               </li>
<li>进程和闪屏页创建完毕，可以看到广告图片界面                 </li>
<li>主窗口创建完成可以看到首页了         </li>
<li>首页加载完，才能操作起来            </li>
</ol>
<h3 id="启动遇到的问题"><a href="#启动遇到的问题" class="headerlink" title="启动遇到的问题"></a>启动遇到的问题</h3><ul>
<li>点击图标很久都不响应。可能是禁用了预览窗口或者透明皮肤           </li>
<li>首页显示太慢。闪屏广告、其它准备工作都要在启动阶段完成，如果耗时太多就慢            </li>
<li>首页显示后无法操作。工作异步延后之后，首页就会出现白屏，或者首页出来无法操作         </li>
</ul>
<h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><p>优化工具：综合看来，在卡顿优化中提到的 “systrace + 函数插桩” 是比较理想的方案，而且还能看到一些关键事件：GC、SystemServer 、CPU 调度等       </p>
<p><strong>准确的评估之后，才能指引优化的方向</strong></p>
<h4 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h4><ul>
<li>闪屏优化。今日头条把预览窗口与是县城闪屏效果，用户在很短时间内看到“预览闪屏”，不过这种实现对于低端机型会把总的闪屏时间拉长。所以比较推荐在 6.0及以上的版本才采用“预览闪屏”      </li>
<li>业务梳理。清楚启动过程中每一个运行的模块，哪些是一定需要的，哪些是可以砍掉，可以懒加载的。<strong>还有，懒加载要防止集中化，容易出现首页用户无法操作的情况</strong>。       </li>
<li>线程优化。主要在于减少cpu调度带来的波动，让应用启动更加稳定。具体做法是，一方面控制县城的数量，要有线程池(我们是采用Rxjava，统一管理线程池)；还有一个就是管理线程的锁，比如业务有先后顺序，或者优先级不同，这一点可以采用第三方启动框架来解决，比如<a target="_blank" rel="noopener" href="https://github.com/alibaba/alpha">阿里开源的Alpha</a>、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/6Q818XA5FaHd7jJMFBG60w?">微信内部使用的mmkernel</a>            </li>
</ul>
<h2 id="启动优化-lt-下-gt-第8讲"><a href="#启动优化-lt-下-gt-第8讲" class="headerlink" title="启动优化<下>-第8讲"></a>启动优化&lt;下&gt;-第8讲</h2><h3 id="启动进阶方法"><a href="#启动进阶方法" class="headerlink" title="启动进阶方法"></a>启动进阶方法</h3><p>启动过程不建议出现网络io</p>
<p>还有，就是数据结构选择问题，在启动时，只需要读写很少量的 sp文件，如果与很大的sp文件一起解析，这个解析时间可能就要超过  100ms了(可以说我们的application中的sp解析是花了很长时间的)。</p>
<h3 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h3><p>应用加固对启动速度来说是灾难</p>
<h3 id="启动监控"><a href="#启动监控" class="headerlink" title="启动监控"></a>启动监控</h3><ul>
<li>实验室监控，如果客观地反映启动耗时，视频录制是非常好的选择，尤其是我们拿不到竞品的数据(通过分析竞品，我们制定了秒开的标准，可以取平均值、最大值、最小值)              </li>
<li>线上监控。我们使用talkingdata来监测。(但是我们要注意监测的耗时)，最终衡量指标呢，使用平均法容易忽略掉性能差的手机，可以使用快开慢开比：比如2秒快开比，5秒快开比；另一种就是 90% 用户启动时间，如果90%用户启动时间都小于5秒，那我们90%区间启动耗时就是5秒。                </li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2020/05/27/%E8%AF%BE-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-5,6%E8%AF%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/27/%E8%AF%BE-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-5,6%E8%AF%BE/" class="post-title-link" itemprop="url">第5、6课-卡顿优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-27 21:50:00" itemprop="dateCreated datePublished" datetime="2020-05-27T21:50:00+08:00">2020-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-05 16:58:02" itemprop="dateModified" datetime="2021-05-05T16:58:02+08:00">2021-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="卡顿优化-lt-上-gt"><a href="#卡顿优化-lt-上-gt" class="headerlink" title="卡顿优化<上>"></a>卡顿优化&lt;上&gt;</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>获取cpu信息：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 CPU 核心数</span></span><br><span class="line">cat /sys/devices/system/cpu/possible  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个 CPU 的频率</span></span><br><span class="line">cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq</span><br></pre></td></tr></tbody></table></figure>

<h3 id="卡顿指标"><a href="#卡顿指标" class="headerlink" title="卡顿指标"></a>卡顿指标</h3><p>出现卡顿，首先应该看<strong>cpu使用率</strong>，可以通过 /proc/stat 查看系统的cpu使用情况：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proc/self/stat:</span><br><span class="line">  utime:       用户时间，反应用户代码执行的耗时  </span><br><span class="line">  stime:       系统时间，反应系统调用执行的耗时</span><br><span class="line">  majorFaults：需要硬盘拷贝的缺页次数</span><br><span class="line">  minorFaults：无需硬盘拷贝的缺页次数</span><br></pre></td></tr></tbody></table></figure>

<p>如果cpu使用率长期大于60%，表示系统处于繁忙状态，就需要<strong>进一步分析用户时间和系统时间的比例</strong>。普通应用程序系统时间不会长期高于 30% ，如果高于这个值，就应该检查<strong>是否是I/O过多，还是其他的系统调用问题</strong>。</p>
<p>另外，top 命令可以查看哪个进程是cpu消耗大户。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2020/05/27/%E8%AF%BE-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-3,4%E8%AF%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/27/%E8%AF%BE-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-3,4%E8%AF%BE/" class="post-title-link" itemprop="url">第3、4课-内存优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-27 21:43:00 / 修改时间：21:43:33" itemprop="dateCreated datePublished" datetime="2020-05-27T21:43:00+08:00">2020-05-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="内存优化-lt-上-gt"><a href="#内存优化-lt-上-gt" class="headerlink" title="内存优化<上>"></a>内存优化&lt;上&gt;</h2><h3 id="Android中Bitmap-内存分配的变化过程"><a href="#Android中Bitmap-内存分配的变化过程" class="headerlink" title="Android中Bitmap 内存分配的变化过程"></a>Android中Bitmap 内存分配的变化过程</h3><ol>
<li>3.0以前，Bitmap 对象放在Java堆，像素数据存放在 Native内存中，如果不手动调用 recycle ，那么Native内存中的像素数据完全依赖于 finalize 函数，而这个函数是不可靠的         </li>
<li>3.0~7.0,Bitmap 对象和像素数据统一放到 Java 堆，这样就算不 recycle 操作，像素数据也会随着一起回收，不过，这导致大量内存占用，引起大量GC。一起放在内存也有可能即使系统有大量内存没利用，但是却会导致oom了(比如给分配的最大堆只到 300M，但是用得差不多了，此时系统却还空闲有3G内存，却要引起oom了)       </li>
<li>Android 8.0 中，NativeAllocationRegistry 可以满足Bitmap 对象存放在Java 堆，像素数据在 Native 中，还能实现一并回收对象和像素数据。(8.0还提供硬件位图(Hardware Bitmap)，减少内存占用并提升绘制效率)        </li>
</ol>
<h3 id="关于内存优化的两个误区"><a href="#关于内存优化的两个误区" class="headerlink" title="关于内存优化的两个误区"></a>关于内存优化的两个误区</h3><ul>
<li>内存占用越小越好。不是这样的，更多的内存意味着更好的动画效果和更快的缓存命中，只需要做到系统内存充足时多用，系统内存紧张时少用(释放不是必须的内存)即可                </li>
<li>Native 的内存不用管。其实，当系统内存不足的时候，就会开始依次清理 后台、桌面、服务、前台，一步步来，直到内存足够，最后直到重启手机                  </li>
</ul>
<h3 id="内存观测方法"><a href="#内存观测方法" class="headerlink" title="内存观测方法"></a>内存观测方法</h3><ol>
<li>观察Log，查看GC 回收的原因            </li>
<li>使用如下命令查看：         </li>
</ol>
<blockquote>
<p>adb shell dumpsys meminfo &lt;package_name|pid&gt; [-d]</p>
</blockquote>
<h2 id="内存优化-lt-下-gt"><a href="#内存优化-lt-下-gt" class="headerlink" title="内存优化<下>"></a>内存优化&lt;下&gt;</h2><h3 id="内存优化探讨"><a href="#内存优化探讨" class="headerlink" title="内存优化探讨"></a>内存优化探讨</h3><p>Bigmap 优化、内存泄露优化、设备分级几个层次入手</p>
<p>设备等级就是，在某些低性能的机器上，动画不要了，进程也不预先启动了。安装包大小也是有要求的，比如有很多app就有极速版这个概念，它们的apk很小，动画也不酷炫。apk大小跟内存的关系可以参考如下图：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%B8%8E%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F%E5%85%B3%E7%B3%BB.png" alt="安装包大小和内存关系"></p>
<p>Bitmap 可以用第三方框架来做，比如Fresco，实在要自己管理，可以向后台要求指定宽度，bitmap的inbitMap内存复用，inSample降低采样</p>
<p>内存泄露：使用LeakCanary自动化检测方案，只可以做到Activity和Fragment的泄漏检测，如何检测其他的内存泄露呢？如何监测疑似的内存泄漏呢？</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2020/05/02/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9D%A2-%E7%9C%9F%E9%A2%98/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/02/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E9%9D%A2-%E7%9C%9F%E9%A2%98/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/" class="post-title-link" itemprop="url">他山之石</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-02 21:33:00" itemprop="dateCreated datePublished" datetime="2020-05-02T21:33:00+08:00">2020-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-16 16:09:25" itemprop="dateModified" datetime="2023-04-16T16:09:25+08:00">2023-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="GUOBIN"><a href="#GUOBIN" class="headerlink" title="GUOBIN"></a>GUOBIN</h2><h3 id="GUOBIN-1"><a href="#GUOBIN-1" class="headerlink" title="GUOBIN-1"></a>GUOBIN-1</h3><ol>
<li>项目，做了什么优化</li>
<li>如果有一个首页 横向有很多东西、纵向也有很多东西  你怎么处理？（ViewPager2 + RecyclerView） 我讲了500的首页动态化方案给他听</li>
<li>浏览器输入地址到显示干了什么</li>
<li>https</li>
<li>项目网络框架（视频传输用什么？我说udp，并且给出了原因跟说了下http3）</li>
<li>二叉搜索树的删除</li>
<li>背书 死锁、多线程访问临界资源问题</li>
<li>有一个Button有ABC三种样式 然后屏蔽View的其他方法怎么做（我说了三种方法1. 编译时发现访问了View方法报错  2. 继承并且复写方法为空实现，内部提供super访问方法 3.面向对象思想 返回一个只有ABC三个方法的接口）</li>
<li>逻辑题 烧绳子 1小时得出45分钟     有桶里有3种无限的球 一次拿两个 问至少拿多少次才能出现重复的方案  排列组合共6种  所以至少7次</li>
</ol>
<h3 id="GUOBIN-2"><a href="#GUOBIN-2" class="headerlink" title="GUOBIN-2"></a>GUOBIN-2</h3><ol>
<li>voliate关键字的作用，加上是否能保证原子操作的原子性？如何保证原子性</li>
<li>recyclerview缓存机制</li>
<li>tcp三次握手、项目网络库实现，为什么要用上udp？</li>
<li>hashmap插入操作、什么时候转红黑树，为什么要转？线程安全么？ConcurrentHashMap如何保证安全</li>
<li>binder优点、对比其他IPC机制，为什么要引入binder？</li>
<li>OSI模型，每层作用跟有什么协议</li>
<li>概率题：一个家庭有三个孩子，已知其中一个为男，求另外两个至少有一个女的概率</li>
<li>算法：旋转链表LeetCode 61</li>
</ol>
<h3 id="GUOBIN-3"><a href="#GUOBIN-3" class="headerlink" title="GUOBIN-3"></a>GUOBIN-3</h3><p>https相关<br>项目的mvvm，redux等、为什么不用databinding？（难找问题、编译慢）<br>jni如何获取JNIEnv、Jvm结构体、native如何保持jobject的引用  local  reference需要每次都delete么？<br>项目网络库的实现 为何不用http？对比优缺点、除了C2S 有S2C功能么（push功能）怎么实现的。 保活链接呢，断了怎么办？（我们项目是自研的网络库，使用一个tcp socket、两个udp socket链接，tcp socket使用类似http2<br>的方式发送请求）<br>有没搞过windows开发？<br>有没搞过音频开发？<br>kotlin特点、优缺点、协程怎么实现？为什么不在java实现？协程的含义？dart的协程大致是怎么实现的（跟kotlin差不多）？（java原本是用在服务上的，不是搞移动的）</p>
<h3 id="GUOBIN-4"><a href="#GUOBIN-4" class="headerlink" title="GUOBIN-4"></a>GUOBIN-4</h3><p>（1）自我介绍<br>（2）你主要负责什么模块、奖金优化是什么东西（奖金优化的前提是如果能中奖，中奖金额要怎么样）、如何将所有组合列出来、如何将注数分配出去、奖金范围怎么算的<br>（3）APP的架构是怎么样的，为什么要这样子架构？MVP每块你们是怎么分工的<br>（3）首屏怎么调优的、加快启动速度的，内存泄漏怎么检测，LeakCanary原理是什么<br>（4）HashMap源码相关、为什么要将链转红黑树？红黑树特点、插入删除<br>（5）消息循环源码、如何做到任务切换线程、想要提交一个任务有几种方式<br>（6）Kotlin协程原理，怎么切换线程的，为什么要换Kotlin及其优缺点<br>（6）一个无序、实际上是逆序的数组排序用什么算法好 我说的是快排、实际上应该用归并排序能获得最好的时间复杂度</p>
<h3 id="GUOBIN-5"><a href="#GUOBIN-5" class="headerlink" title="GUOBIN-5"></a>GUOBIN-5</h3><p>（1）还是奖金优化<br>（2）还是性能调优、怎么瘦身、打包流程、模块化<br>（3）开发者GPUInfo中的每条柱状图颜色代表含义、命令dumpsys meminfo中VSS、PSS、GSS、USS代表什么意思<br>（4）Android绘制三部曲、Canvas是怎么最终显示在屏幕中的、是以什么样子的数据结构传输的<br>（5）物理内存与虚拟内存的关系、Android Heap的结构是怎么样的、如果要进行垃圾回收，会收集那些区域<br>（6）binder源码、其原理是什么，发起一次请求的过程，如何根据文件描述符找到对应的binder实体<br>（7）广度、深度搜索，拓朴排序、最短路径算法<br>（8）ELF文件格式、反编译器原理<br>（9）Kotlin优缺点</p>
<h3 id="GUOBIN-6"><a href="#GUOBIN-6" class="headerlink" title="GUOBIN-6"></a>GUOBIN-6</h3><p>（1）项目架构是怎么样的<br>（2）画一下结构图<br>（3）为什么要迁移项目到Kotlin<br>（4）线程 协程 为什么需要线程池 他的状态变化是怎么样的 在Android中的应用<br>（5）如何设计一个App的架构 该考虑什么<br>（6）Flutter怎么从平台到Dart的 如何渲染的<br>（7）你觉得面得怎么样</p>
<h3 id="GUOBIN-7"><a href="#GUOBIN-7" class="headerlink" title="GUOBIN-7"></a>GUOBIN-7</h3><p>讲个项目你负责的模块<br>多个Fragment在销毁后重建之后重叠怎么办<br>设计一个图片缓存框架<br>缓存算法用什么<br>有个ListView快速滑动 如何优化Bitmap的显示<br>Bitmap的复用听过没有<br>如何进行内存优化 减少内存消耗</p>
<h3 id="GUOBIN-8"><a href="#GUOBIN-8" class="headerlink" title="GUOBIN-8"></a>GUOBIN-8</h3><p>讲下项目的架构<br>负责的模块<br>算法 最大子序和<br>try catch finally关于return的执行结果<br>hashmap源码 treemap如何对两个元素进行比较 非compareble对象比较<br>hashcode equals区别<br>object有什么方法<br>讲讲Android存在的设计模式<br>android的消息机制<br>android的事件分发<br>讲个android的源码 自选<br>LeakCanary</p>
<h3 id="GUOBIN-9"><a href="#GUOBIN-9" class="headerlink" title="GUOBIN-9"></a>GUOBIN-9</h3><p>android消息机制<br>android事件分发<br>设计模式讲讲有什么认识的 代理模式优缺点<br>图片 缓存机制<br>首屏调优 内存调优</p>
<h3 id="GUOBIN-SHOPEE"><a href="#GUOBIN-SHOPEE" class="headerlink" title="GUOBIN-SHOPEE"></a>GUOBIN-SHOPEE</h3><p>用https本地证书验证，基于这个点描述下。为什么做？技术方案？业界的技术方案？</p>
<p>新证书放在sp里面，sp在使用的过程中会有什么问题？新证书存进去要进行简单的对称加密？</p>
<p>插件化方案描述一下</p>
<p>React 的原理讲一下？</p>
<p>工作这么长时间，觉得哪些方面对自己挑战比较大？</p>
<p>在团队里面是什么样的角色</p>
<p>除了工作以外，还会接触哪些框架原理之类的，对 Fresco 比较熟是吧，它是怎么做的图片缓存的？</p>
<h4 id="GUOBIN-FUTU"><a href="#GUOBIN-FUTU" class="headerlink" title="GUOBIN-FUTU"></a>GUOBIN-FUTU</h4><p>富途有一个概率问题，3个人去打天上的飞机，每个人打中的概率都是0.6，一起打，飞机被打中的概率是多少</p>
<p>超大图片加载到app预览，占用内存很大，实现方案上需要注意什么，怎么解决这个问题</p>
<p>微信朋友圈刷列表卡顿，让你定位你如何入手，怎么安排怎么开展工作</p>
<p>还一个，一堆钻石，每个大小可能不一样，你一次只能看一个，看完拿了就结束了，没拿就看下一个，不能回头。怎么保证能拿到一个比较大的钻石，钻石数量无限，可以认为是百万级</p>
<p>笔试（1h）:</p>
<p>笔试主要是做一些基础题，主要涉及基础数学、操作系统、算法等基本知识</p>
<p>1：数独游戏，在9*9的数独上填充数字</p>
<p>2：逻辑电路的概率题</p>
<p>3：猴子吃桃问题</p>
<p>4：页面置换算法为FIFO，求缺页中断的次数</p>
<p>5：有7g和2g砝码，如果利用砝码和天平在3次之内将140g的面粉分为90g和50g</p>
<p>第一次：将140g面粉分为70g和70g<br>第二次：将70g面粉分为35g和35g<br>第三次：利用砝码将35g面粉分为20g和15g。由此35+15 = 50g； 35+35+20 = 90g<br>6：编程题 : 根据中序遍历结果和先序遍历结果建树</p>
<p>7:? 编程题：将字符串“l.am.happy”反转为“yapph.ma.I”</p>
<pre><code>/**
 * 两次翻转，先对每个单词进行翻转，再对整体进行翻转 
 */
public String reverseString(String str){

    if(str == null || str.length() == 0){
        return null;
    }
    // 分割单词
    String []wordList = str.split("/.");
    for(int i = 0; i &lt; wordList.length; i++){
        // 对每个单词进行翻转
        wordList[i] = convert(wordList[i]);
    }

    int low = 0;
    int high = wordList.length - 1;
    while(low &lt; high){
        String tmp = wordList[low];
        wordList[low] = wordList[high];
        wordList[high] = tmp;
        low++;
        high--;
    }

    StringBuffer sb = new StringBuffer();
    for(int i = 0; i &lt; wordList.length - 1; i++){
        sb.append(wordList[i]).append(".");
    }
    sb.append(wordList[wordList.length - 1]);
    return sb.toString();
}

// 对单个单词进行翻转
public String convert(String str){
    int low = 0;
    int high = str.length() - 1;
    char[]tmpStr = str.toCharArray();
    while(low &lt; high){
        char temp = tmpStr[low];
        tmpStr[low] = tmpStr[high];
        tmpStr[high] = temp;
        low++;
        high--;
    }
    return String.valueOf(tmpStr);
}</code></pre><p>8:? 编程题：不能使用系统函数，计算任意两个日期的天数差</p>
<p>9:? 推导题：A、B、C、D四个人分别带着一顶帽子。共两顶黑帽子，两顶白帽子。其中D和A、B、C三个隔了一堵不透明的墙。A可以看到B、C帽子的颜色。B可以看到C帽子的颜色。只要能判断自己的帽子颜色，就可以立刻说出来。他们四人沉默了几分钟，这时候一个人说到，它知道自己帽子的颜色是什么了，请问这个人是谁？</p>
<p>答案：应该是B。A能看到B、C两人的帽子。如果B、C两个人的帽子颜色相同，那么A立刻就能说出来自己帽子的颜色。否则，如果A沉默，我们就能断定B、C带了不同颜色的帽子。因为B能看到C帽子的颜色，B和C帽子的颜色不同，所以，我们能够推断出B。</p>
<p>?</p>
<p>一面：</p>
<p>一面主要是针对刚才的笔试题进行提问，以及抓着简历和项目经历来问</p>
<p>1：解释一下MVC、MVP、MVVM架构模式</p>
<p>2：解释一下Android组件化（LiveData + ViewModel）</p>
<p>3:? ?对ios架构有了解吗？(只了解过Viper)</p>
<p>4：Kotlin的特点、优点和缺点</p>
<p>优点:</p>
<p>完全兼容Java<br>Null safe<br>支持lambda表达式（比Java8更好）<br>支持扩展<br>支持高阶函数<br>体验一致的开发工具链<br>代码简洁<br>缺点：</p>
<p>可读性差<br>编译速度慢<br>操作不当容易引出大错误<br>学习资料少<br>IDEA 自动转换工具，把 Java 转换成 Kotlin，转换质量比人工转的要差的多。<br>5:? 抓项目细节，问项目的实现</p>
<p>6：Android如何进行优化，如内存优化、布局优化、性能优化</p>
<p>布局优化：</p>
<p>尽量减少布局文件的层级<br><include>标签，主要用于布局重用，提高布局的复用性<br><merge>标签，一般和<include>标签配合使用，可以减少布局的层级<br><viewstub>标签，提供了按需加载的功能，当需要时才会将ViewStub中的布局加载到内存，这提高了程序的初始化效率<br>绘制优化：</viewstub></include></merge></include></p>
<p>避免在View的onDraw方法中执行大量的操作</p>
<p>onDraw中不要创建新的局部变量，这是因为onDraw方法可能会被频繁的调用，这样就会在一瞬间产生大量的临时对象<br>onDraw方法中不要做耗时的任务，也不能执行成千上万次的循环操作。否则这回导致View的绘制流程不流畅<br>内存优化：</p>
<p>尽量使用Android特有的数据容器。如SparseArray、SparseBooleanArray<br>不要使用过多的枚举类，枚举占用的内存空间比整形大<br>适当使用软引用和弱引用<br>尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄露</p>
<p>二面：</p>
<p>1:? 重载和重写的区别</p>
<p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载是一类中多态性的一种表现。</p>
<p>override（重写）：</p>
<p>　　 1、方法名、参数、返回值相同。</p>
<p>　　 2、子类方法不能缩小父类方法的访问权限。</p>
<p>　　?3、子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</p>
<p>　　 4、存在于父类和子类之间。</p>
<p>　　 5、方法被定义为final不能被重写。</p>
<p>　overload（重载）：</p>
<p>　　1、参数类型、个数、顺序至少有一个不相同。?</p>
<p>　　2、不能重载只有返回值不同的方法名。</p>
<p>　　3、存在于父类和子类、同类中。</p>
<p>2：Android应用的启动过程</p>
<p>时序图</p>
<p>3：TCP建立连接的过程</p>
<p>建立连接：</p>
<p>TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p>
<p>（1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。</p>
<p>（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。</p>
<p>（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</p>
<p>完成三次握手，客户端与服务器开始传送数据</p>
<p>释放链接：</p>
<p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个?FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<p>?CP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<p>（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。?</p>
<p>（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。?</p>
<p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。?</p>
<p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。</p>
<p>4：传输层和网络层的联系</p>
<p>网络层负责ip数据报的产生以及ip数据包在逻辑网络上的路由转发。</p>
<p>传输层提供端到端通信服务层次,提供可靠及非可靠连接。</p>
<p>网络层只是根据网络地址将源结点发出的数据包传送到目的结点（点到点），其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。</p>
<p>而传输层则负责将数据可靠地传送到相应的端口（端到端），传输层提供了主机应用程序进程之间的端到端的服务。传输层利用网络层提供的服务，并通过传输层地址提供给高层用户传输数据的通信端口，使高层用户看到的只是在两个传输实体间的一条端到端的、可由用户控制和设定的、可靠的数据通路。</p>
<p>5：25匹马，5条跑道。要选出最快的前三名，最少要跑几次？</p>
<p>7次。将25匹马分成五批，跑五次，决胜出每批马的第一名。再让每批第一名的马跑一次，决定前三名，设为A,B,C。此时可确认跑得最快的为A，但是第二名和第三名不确定。于是可以让A1,A2, B，B1，C跑一次。（A1代表A组的第二名），决胜出前二名。就是最快的第二和第三名的马。</p>
<p>6：老王卖鞋，一双进价30元，老王赔本卖，只卖20元。有个骗子来买，给老王50元假钞。老王未能识别，又没有零钱，把这假钞拿到隔壁铺子的老李换了50元零钱，回来找了骗子30。隔壁很快发现问题，拿假钞来换，老王只好把自己的家底真钞50元换给隔壁。问老王损失了多少钱？</p>
<p>损失了60元，由题目可知老李没有任何损失。老王找了骗子30元，同时又得到了一双价值30的鞋子。赚了60元，因此可以得出老李亏了60元。</p>
<p>7：死锁产生的必要条件</p>
<p>互斥条件：请求的资源为临界资源<br>请求和保持条件：申请新资源，保持旧资源<br>不剥夺条件：已获得的资源，在使用完之前，不被外力剥夺<br>环路等待条件：互相等待资源<br>8：多少个进程竞争多少个临界资源会产生死锁？</p>
<p>两个或以上进程需要两个或以上资源</p>
<p>9：你怎么规划你以后的发展？</p>
<p>（接下来巴拉巴拉一大堆产品的问题，产品的优势、竞争力等等）</p>
<p>?</p>
<p>Hr面（20min）</p>
<h2 id="cici"><a href="#cici" class="headerlink" title="cici"></a>cici</h2><p>1、数组实现队列</p>
<p>2、gc的流程</p>
<p>点击看答案</p>
<p>可以查看 <a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/23/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a> 第5题</p>
<p>3、java软引用与弱引用区别</p>
<p>点击看答案</p>
<p>参考以前的<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/">读书笔记</a></p>
<p>4、java中的this编译时的原理</p>
<p>点击看答案</p>
<p>我们知道，this关键字主要有三个用途：</p>
<ul>
<li>调用本类中的属性</li>
<li>调用本类中的其他方法</li>
<li>调用本类中的其他构造函数</li>
</ul>
<p>this编译时的原理：</p>
<ol>
<li>this指代的一定是对象(所以静态方法不能使用this)，且该对象的静态类型就是就是当前类</li>
<li>实例方法以及 <strong>构造方法</strong>的第一个参数都是this（在构造方法之前，jvm其实已经给对象在堆中分配好了内存了，构造方法的作用是对类<strong>初始化</strong>）</li>
<li>this一般出现在方法中；如果this出现在方法体外部，如：在类A中定义了成员变量 A a = this;最终这行代码仍然会<strong>被放入 A 类的构造函数中执行</strong>。</li>
</ol>
<p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41920291/article/details/98118035">他人的博客</a></p>
<p>5、final变量用反射修改</p>
<p>6、HashMap的内部结构，给定一个key，如何找到对应的value，使用equal</p>
<p>7、volatile</p>
<p>8、Java线程池有什么作用</p>
<p>9、Java动态代理</p>
<p>10、handler机制</p>
<p>点击看答案</p>
<p>查看<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础</a> 第4题即可</p>
<p>11、android跨进程通信的方式</p>
<p>点击看答案</p>
<p>阅读<a target="_blank" rel="noopener" href="https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/">以前的读书笔记</a></p>
<p>12、自定义控件方式</p>
<p>13、Canvas绘制过什么 手写功能</p>
<p>14、断点续传的实现</p>
<p>15、如何设计图片加载库</p>
<p>16、有看过哪些安卓的源码</p>
<ul>
<li>Activity启动</li>
<li>handler</li>
<li>ThreadHandler</li>
<li>IntentThread</li>
</ul>
<p>17、看过哪些开源项目</p>
<ul>
<li>LeakCanary</li>
<li>Alpha</li>
<li>okhttp</li>
</ul>
<p>18、app 启动速度的优化做过哪些</p>
<p>19、fresco加载图片原理 优势是什么</p>
<p>20、写程序时，堆和栈有什么优化点 内存回收时机 如何判断对象可被回收</p>
<p>21、引用计数法和gc root法</p>
<p>22、事件分发 cancel事件一般在什么时候被触发</p>
<p>点击看答案</p>
<p>参考源码理解中的12、13题</p>
<p>23、touchdelagate 一个父view只能设置一个delegate，如何解决设置多个</p>
<p>24、App整个架构了解么</p>
<p>25、mvvm data binding</p>
<p>26、webview</p>
<p>27、fragment startactivity</p>
<p>28、动画的原理</p>
<p>黄油计划 vsync</p>
<p>设计一个离线视频下载功能</p>
<p>Activity 启动流程</p>
<p>android app签名原理</p>
<p>Android查询资源文件layout原理</p>
<p>设计一个decode bitmap方法</p>
<p>启动Activity A后，按home键，再从桌面启动activity A ， Activity A的生命周期</p>
<p>handler原理</p>
<p>onSaveInstanceState调用时机</p>
<p>Fragment View区别</p>
<p>Java内存管理和内存回收</p>
<p>Android scheme</p>
<p>Activity怎么管理自己的生命周期，ActivityThread怎么运作</p>
<p>消息事件分发</p>
<p>进程之间通讯</p>
<p>线程锁</p>
<p>touch事件分发原理scrollview和viewpager之间的滑动如何防止冲突，里面listitem也需要支持滑动怎么办</p>
<p>插件化的了解情况动态代理实现（自由发挥的）</p>
<p>如何实现一个拥有取出最小值方法的堆栈，要求算法的事件复杂度是O(E)如何算</p>
<p>二叉树节点之间的最小距离</p>
<p>两个链表，可能很长，实现求和（大数求和），结果也是单向链表</p>
<p>ActivityTask的使用</p>
<p>onNewIntent的调用时机</p>
<p>checkbox，up事件和down事件的区别</p>
<p>怎么用Standard方式来实现一个SingleTop启动的Activity</p>
<p>Http文件上传的具体过程</p>
<h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><p>其实证书的本地校验还有一个步骤就是，将获取的新证书与老证书对比下，对比新旧证书</p>
<p>在kotlin中各个部分的执行顺序：</p>
<p>companion &gt; init &gt; constructor</p>
<p>自己写代码如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinTest</span> </span>{</span><br><span class="line">    <span class="keyword">init</span> {</span><br><span class="line">        println(<span class="string">"init"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(){</span><br><span class="line">        println(<span class="string">"constructor init"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> {</span><br><span class="line">        <span class="keyword">init</span>{</span><br><span class="line">            println(<span class="string">"companion init"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>会输出：</p>
<blockquote>
<p>companion init    </p>
<p>init    </p>
<p>constructor init</p>
</blockquote>
<p>对称加密哪些</p>
<p>三次、四次握手</p>
<p>注意postInvalidate的使用</p>
<h2 id="关于如何排查ANR"><a href="#关于如何排查ANR" class="headerlink" title="关于如何排查ANR"></a>关于如何排查ANR</h2><h3 id="获取日志文件"><a href="#获取日志文件" class="headerlink" title="获取日志文件"></a>获取日志文件</h3><p>首先，获取日志文件：</p>
<blockquote>
<p>adb bugreport buglog</p>
</blockquote>
<p>之后，就会显示进度生成，有个时候会生成不成功，没关系，再来一次</p>
<p>生成之后，这个文件被导入到当前项目的路径下，解压这个 buglog.zip 文件即可，打开 [机型]xxx.txt 查看里面的日志。</p>
<h3 id="ANR类型和日志关键字"><a href="#ANR类型和日志关键字" class="headerlink" title="ANR类型和日志关键字"></a>ANR类型和日志关键字</h3><p>KeyDispatchTimeout-主要类型按键或触摸事件,input事件在5S内没有处理完成发生ANR</p>
<p>日志关键字：Reason: Input dispatching timed out xxxx</p>
<p>ServiceTimeout-bind，create，start，unbind等在主线程处理耗时，前台Service在20s内，后台Service在200s内没有处理完成发生ANR</p>
<p>日志关键字：Timeout executing <a href="https://links.jianshu.com/go?to=http%3A%2F%2Fservice%2Fexecuting%2520service" target="_blank">service:/executing service</a> XXX</p>
<p>3）BroadcastTimeout- BroadcastReceiver onReceiver处理事务时前台广播在10S内，后台广播在60s内没有处理完成发生ANR</p>
<p>日志关键字：Timeout of broadcast XXX/Receiver during timeout:XXX/Broadcast of XXX</p>
<p>4）ProcessContentProviderPublishTimedOutLocked-ContentProvider publish在10s内没有处理完成发生ANR<br>日志关键字：timeout publishing content providers</p>
<h3 id="造成ANR的常见原因"><a href="#造成ANR的常见原因" class="headerlink" title="造成ANR的常见原因"></a>造成ANR的常见原因</h3><ul>
<li>主线程耗时操作，如复杂的layout，庞大的for循环，IO等。    </li>
<li>主线程被子线程同步锁block    </li>
<li>主线程被Binder 对端block    </li>
<li>Binder被占满导致主线程无法和SystemServer通信    </li>
<li>得不到系统资源（CPU/Memory/IO）</li>
</ul>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/33d5e48e4a13">简书上的博客</a>、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/082045769443">简书博客二</a></p>
</blockquote>
<h3 id="dayuwuxian"><a href="#dayuwuxian" class="headerlink" title="dayuwuxian"></a>dayuwuxian</h3><p>在目前所在公司主要负责什么？</p>
<p>为什么要重构网络框架？重构后有什么亮点？</p>
<p>OkHttp 里面有哪些比较关键的设计让你觉得挺好的？线程池为什么要这样设计？它有哪些 intercetor ，分别是什么含义 ？这些 interceptor 执行的顺序是什么？</p>
<p>网络防劫持是怎么做的？</p>
<p>设计一个类，有add、remove、dispatch 这 3 个方法，其中add 表示将 listener 添加进来， remove 表示将 listener 移除，dispatch 方法表示遍历目前的listener ，然后调用每个 listener 的 invoke 方法，请问这个类怎么设计？</p>
<p>设计的APM上线了吗，完成度怎么样？为什么要设计这么个APM ？怎么收集卡顿、ANR 呢？</p>
<p>有用kotlin吗？kotlin的 lazy 是怎么实现的？-有很多中模式。这些模式的原理是什么，比如Synchronize 模式的原理是什么？用过协程吗？</p>
<p>有用过 JetPack 吗？用过哪些？</p>
<p>https证书防抓包的原理是什么？证书是双向验证还是单向验证？破解包了替换掉证书还能不能行？怎么更新从后台下载来的证书？怎么做的？</p>
<p>https的请求过程是什么样的，与http有什么区别？</p>
<p>一大堆无序的数字，取出前k个最小的数字</p>
<h2 id="频繁GC、OOM-的排查"><a href="#频繁GC、OOM-的排查" class="headerlink" title="频繁GC、OOM 的排查"></a>频繁GC、OOM 的排查</h2><p>Android 的profile 功能-&gt;memory -&gt; dump ，得到 hprof 文件</p>
<p>AS 现在直接能看到各个对象了，或者按照以前的，将 hprof 文件转一道，使用 MAT 打开</p>
<h2 id="两个人轮流抛硬币，正面朝上的赢，正反面概率一样，你应该先抛还是后抛"><a href="#两个人轮流抛硬币，正面朝上的赢，正反面概率一样，你应该先抛还是后抛" class="headerlink" title="两个人轮流抛硬币，正面朝上的赢，正反面概率一样，你应该先抛还是后抛"></a>两个人轮流抛硬币，正面朝上的赢，正反面概率一样，你应该先抛还是后抛</h2><p>设先抛先吃的概率为p1， 后抛先吃的概率为p2</p>
<p>那么有：</p>
<p>p1 = 1/2 + 1/2 * p2</p>
<p>p1 + p2 = 1</p>
<p>解方程可得，</p>
<p>p1 = 2/3</p>
<blockquote>
<p>参考自<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/6f11c63cb97a4e0884bb40985cf95393?toCommentId=474963">牛客网</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2020/05/01/%E9%9D%A2-%E9%A1%B9%E7%9B%AE/Android%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/01/%E9%9D%A2-%E9%A1%B9%E7%9B%AE/Android%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">Android开发技巧</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-01 09:38:00 / 修改时间：09:40:07" itemprop="dateCreated datePublished" datetime="2020-05-01T09:38:00+08:00">2020-05-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">Android技巧</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="查看运行的service"><a href="#查看运行的service" class="headerlink" title="查看运行的service"></a>查看运行的service</h2><p>如果要查看当前手机上运行有哪些service（不可以先 adb shell 再执行后面的，否则显示的进程就不对了，至少我的是这样的）：</p>
<blockquote>
<p>adb shell dumpsys activity services</p>
</blockquote>
<p>当然，肯定是可以加 grep 关键字过滤的：</p>
<blockquote>
<p>adb shell dumpsys activity services | grep MiniAppPreService</p>
</blockquote>
<p>同理，我们也可以通过 grep 过滤查看当前一组进程(下面示例是过滤出名字中包含 com.example.io 的)：</p>
<blockquote>
<p>adb shell ps | grep com.example.io</p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2020/05/01/%E4%B9%A6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87%E7%AC%AC6%E7%89%88-%E7%AC%AC8%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/01/%E4%B9%A6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87%E7%AC%AC6%E7%89%88-%E7%AC%AC8%E7%AB%A0/" class="post-title-link" itemprop="url">第8章：计算机网络中的安全</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-01 08:56:00 / 修改时间：09:09:01" itemprop="dateCreated datePublished" datetime="2020-05-01T08:56:00+08:00">2020-05-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>8.6 使TCP 连接安全，SSL </p>
<p>SSL （Secure Socket Layer ）安全套接字层， SSL 版本 3的一个稍加修改的版本被称为 TLS(Transport Layer Security)</p>
<p>在 http 之下，tcp 之上，有 ssl 层。</p>
<p>ssl 握手流程：</p>
<p>总体来说，ssl 握手，首先要建立一个tcp 连接 ，其次在验证server 的真实性 ，最后 client 再将对称加密所需要的key通过公钥加密交给server。此后，两端通过对称加密来完成通信。整个过程如下图所示：</p>
<p><img src="/assets/Book-Notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC8%E7%AB%A0/ssl%E6%8F%A1%E6%89%8B.png" alt="ssl握手整体步骤"></p>
<p>抛开tcp连接的建立，详细步骤如下：</p>
<ol>
<li>client发送支持的算法列表以及一个随机数 x      </li>
<li>server 从接收的列表中选择一种对称算法、一种非对称算法 和 一种摘要算法，连同自己的证书 以及 随机数 y 一起返回      </li>
<li>client 验证该证书，提取公钥，并生成一个<strong>前主密钥</strong>，并用服务器的公钥加密这个 前主密钥，之后发送给server      </li>
<li>server 解密获得 主密钥    </li>
<li>client 发送自己这边所有握手的报文的一个 摘要    </li>
<li>server 端发送自己这边握手报文的一个 摘要    </li>
</ol>
<p>最后两个步骤保证了握手免受篡改危害。比如，在观察第一步的时候，客户端提供的算法列表，有些算法强，有些弱，因为还未协商，所以这张列表是以明文发送的。如果中间攻击者从中删除了较强的算法，迫使server 最后只能选择较弱的算法。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">215</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共433.2k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/14/',]
      });
      });
  </script>


</body>
</html>
