<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/5/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">36</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">211</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/24/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8805%EF%BC%892022.1.23-Android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%8C%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/24/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8805%EF%BC%892022.1.23-Android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%8C%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">性能优化-：（05）2022.1.23-Android启动优化，有向无环图任务管理分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-24 09:26:00" itemprop="dateCreated datePublished" datetime="2023-05-24T09:26:00+08:00">2023-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-26 23:34:05" itemprop="dateModified" datetime="2023-05-26T23:34:05+08:00">2023-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>启动优化已经有很多常规手段，如只加载必要模块，延迟加载等，能取得一些效果，为什么还需要启动框架呢？</p>
<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>比如在 Application 中存在很多 SDK，比如20 个，这些 SDK 存在先后顺序，如何保证按照依赖顺序并且高效地执行呢？比如下面的任务：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E4%BB%BB%E5%8A%A1.png" alt="有向无环图任务"></p>
<p>由图我们能看出相互之间的依赖：2 、3 依赖任务 1， 4 依赖任务 2 ，5 依赖 3 和 4。如果使用 Thread 去实现，会变得非常复杂。因此需要框架。</p>
<h2 id="二、有向无环图"><a href="#二、有向无环图" class="headerlink" title="二、有向无环图"></a>二、有向无环图</h2><p>如果任务执行有方向（有序），并且没有环。在凸轮中，这种一个有向图从所有顶点出发，无论经过哪些边都不会回到这些顶点，那么就是有向无环图，简称 DAG 图。在 DAG 中：</p>
<ul>
<li><p>顶点：图中的一个点，比如任务 1 ，任务 2</p>
</li>
<li><p>边：连接2个顶点的线段</p>
</li>
<li><p>入度：代表当前有多少边指向顶点（依赖多少任务）</p>
</li>
<li><p>出度：代表有多少边从顶点出发（被多少任务依赖）</p>
</li>
</ul>
<h2 id="三、拓扑排序"><a href="#三、拓扑排序" class="headerlink" title="三、拓扑排序"></a>三、拓扑排序</h2><p>将我们的启动任务生成 DAG 图后，就要对 DAG 图做 <strong>拓扑排序</strong>，即对我们的任务启动顺序进行排序。对于前面的有向无环图而言，我们只需要保证 2、3 在 1 之后执行5 在 3、4 之后执行即可，因此我们可以得到多种排序结果：</p>
<blockquote>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</p>
<p>1 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5</p>
<p>1 -&gt; 3 -&gt; 2 -&gt; 4 -&gt; 5</p>
</blockquote>
<p>也就是说，<strong>图的拓扑排序不是唯一的！</strong></p>
<p>对 DAG 拓扑排序可以选择 <strong>BFS（广度优先）算法</strong>或者<strong>DFS（深度优先）算法</strong>，BFS 算法排序的过程如下：</p>
<ol>
<li><p>找出图中入度为 0 的顶点</p>
</li>
<li><p>依次在图中删除这些顶点，删除后再找出入度为 0 的顶点</p>
</li>
<li><p>删除后再找出入度为 0 的顶点，重复执行第二步</p>
</li>
</ol>
<p>基于上面的例子的拓扑排序步骤如下：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/dag%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A41.jpg" alt="拓扑排序例子步骤"></p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/dag%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A42.jpg" alt="步骤2"></p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/dag%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A43.jpg" alt="DAG排序步骤3"></p>
<p>代码落地：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Startup</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Dispatcher</span> </span>{</span><br><span class="line">    <span class="comment">//执行初始化任务</span></span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">(Context context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本任务依赖的任务列表（入度）</span></span><br><span class="line">    List&lt;Class&lt;? extends Startup&lt;?&gt;&gt;&gt; dependence();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依赖任务的个数（入度个数）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDependenciesCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，所有的任务都实现 Startup 接口。</p>
<h2 id="四、线程管理"><a href="#四、线程管理" class="headerlink" title="四、线程管理"></a>四、线程管理</h2><p>有些项目写 ConcurrentHashMap 的时候，value 不是直接使用 Object 类型，而是会使用自定义的类似 Result 类型，把原始结果封装了一层。这是什么原因呢？这是因为 ConcurrentHashMap 的 value 不能为 null ，否则会报错。如果我封装一层就能保证 Result 对象是不空的。</p>
<p>CountDownLatch 如果在初始化的时候，传入 0 这个数字，在下面调用 CountDownLatch.await 将不会被阻塞。</p>
<p>SDK中的线程比较多，或者有自己的线程池，那么有几种方法：</p>
<ul>
<li><p>线程池设置成自己的线程池</p>
</li>
<li><p>反射改掉它的线程池</p>
</li>
<li><p>字节码增强技术，通过 gradle 插桩修改 SDK 的代码</p>
</li>
</ul>
<p>如果写的 Builder ，让使用者添加 Task ，这样子在 Task 很少的时候，是很方便的，如果有 20 个，100 个的时候就头大了。这时候有什么好的办法去做？有几个方案：</p>
<ul>
<li><p>使用注解，每个 Task 上都加上这个注解，然后在 </p>
</li>
<li><p>使用 ContentProvider ，在 xml 中把最后的任务写在 data 中</p>
</li>
</ul>
<p>视频中讲解的启动框架源码可以在[github开源项目中看到](<a target="_blank" rel="noopener" href="https://github.com/idisfkj/android-startup/blob/master/README-ch.md">android-startup/README-ch.md at master · idisfkj/android-startup · GitHub</a>)  ，这个项目比课程中的更加完善</p>
<h2 id="五、问题"><a href="#五、问题" class="headerlink" title="五、问题"></a>五、问题</h2><p>有个问题，为什么要先拓扑排序？</p>
<p>假如我们不拓扑排序，会发生什么？假如有task 5 和 6 ，都是在主线程运行，其中 6 是要等 5 结束后才能开始，假如我们不拓扑排序，此时 6 先执行，在这里阻塞了，由于阻塞，此时 5 也不能执行了，又由于在主线程，此时就 ANR 了。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/23/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8804%EF%BC%892022.1.20-Android%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87Application%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%80%97%E6%97%B6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/23/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8804%EF%BC%892022.1.20-Android%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87Application%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%80%97%E6%97%B6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">性能优化-：（04）2022.1.20-Android面试必备Application启动过程与耗时分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-23 09:13:00" itemprop="dateCreated datePublished" datetime="2023-05-23T09:13:00+08:00">2023-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-24 23:07:41" itemprop="dateModified" datetime="2023-05-24T23:07:41+08:00">2023-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>分为三个步骤：</p>
<ol>
<li><p>通过源码分析，知道启动流程（便于启动监控——哪些地方耗时）</p>
</li>
<li><p>阿里的启动优化方案</p>
</li>
<li><p>如何实现高效的 SplashActivity </p>
</li>
</ol>
<h2 id="二、启动流程"><a href="#二、启动流程" class="headerlink" title="二、启动流程"></a>二、启动流程</h2><p>分为三个流程，如下图所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%90%AF%E5%8A%A8%E4%B8%89%E6%B5%81%E7%A8%8B.png" alt="App启动的3个流程"></p>
<p>在第二个阶段中，Application 的启动很关键，其中 Application 中的 attachBaseContext 方法比较关键，很多时候我们会在里面做一些比较前置的任务，诸如：</p>
<ul>
<li><p>对于加固的 App ，这里会做解密的操作</p>
</li>
<li><p>对于热修复而言，第一时间将修复的 dex 给生效</p>
</li>
</ul>
<p>只需要在执行类之前，dex 中包括这个类。所以，理论上我们可以无需一次性将所有的 dex 文件在 attachBaseContext 的时候加载进去。第一个 Activity 启动之后，再将其他的 dex 加载进去。attachBaseContext 阶段可以使用字节的 BoostMultiDex 方案去优化。</p>
<p>只有 window 才能展示出来看到，而目前在 Android 里面就一个 PhoneWindow ，所以，我们看到的第一屏肯定只能是 第一个 Activity 的 PhoneWindow。</p>
<p>那么，在用户点击Launcher 到第一个 Activity 显示出来之前，我们要显示内容，显示什么内容呢？其实显示的是Application 的主题，这个主题里面有个属性：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/Theme.AndroidDemo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">".MainActivity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>application 的 theme 是 @style/Theme.AndroidDemo ，然后我们可以在theme 里面设置  android:windowSplashscreenContent 值：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Theme.AndroidDemo"</span> <span class="attr">parent</span>=<span class="string">"Theme.MaterialComponents.DayNight.DarkActionBar"</span>&gt;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSplashscreenContent"</span>&gt;</span>@drawable/ic_launcher_background<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>当然，以上操作要求 API 版本是 26 ，如果要兼容低的版本，就要设置 background 属性，但是这二者还是有区别的：</p>
<ul>
<li><p>background 只能是图片</p>
</li>
<li><p>windowSplashscreenContent 可以做动画</p>
</li>
</ul>
<p>这是怎么实现的呢？Application 里面压根就没有 Window 啊，其实在startActivity 的时候，Activity 真正启动之前，add 了一个 SplashWindow，WindowManager 通过 addView 的方式将 window 交给 WMS 去展示这个闪屏页了，这个闪屏window 会去解析 windowSplashscreenContent 字段。在第一个 Activity 初始化完，Activity 的 window 也通过 vm.addView 展示的时候，就会覆盖 SplashWindow 。</p>
<p>以上就是黑白屏优化，这其实就是欺骗用户，实际上也没加快启动速度。</p>
<p>所以，我们优化启动速度，优化在哪里呢？其实就是 vm.addView 添加 SplashWindow 和 vm.addView 第一个 Activity 的 window 之间的过程，将这个过程尽量缩短。并且，<strong>这个过程里面会执行 Application.onCreate()</strong>，所以我们需要减少 onCreate 的耗时。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>线程数，有些 SDK 会启动线程，你自己可能压根没创建线程。所以如何控制这个线程数呢？后续再讲，基本上可以通过阿里的 Alpha 。（老师说Android 的 startUp 比较垃圾），这就是 Application 的 onCreate 方法优化方法。</p>
<p>上述的过程还会经历第一个 Activity 的onCreate、onStart、onResume 这些流程</p>
<p>perfomStartActivity 的过程中， Activity.attach 的时候会为Activity创建 Context 、创建 window ，并未 window 设置 WindowManager。为什么这么设计？因为单一职责问题，Activity 是管理生命周期的，Window 是管理 View 的。</p>
<p>我们在 Activity 的 onCreate 中只应该去做 view 的操作，其他的诸如数据库初始化之类的应该放在子线程中异步操作。</p>
<blockquote>
<p>装饰模式是功能增强；代理模式只是代理，没有增强。</p>
</blockquote>
<p>有可能面试官会问，为什么采用 inflater 解析的view ，要比自定义的 view 效率低？这里我们可以看 setContentView 方法，最底层就是使用 inflater 实现的，如果能看到后面就会发现，大量使用反射创建出来 View 。而反射又是比较耗时的，所以总结如下：</p>
<ul>
<li><p>解析 xml 耗时</p>
</li>
<li><p>根据 xml 反射 view 的反射操作耗时</p>
</li>
</ul>
<p>所以，Activity 的 onCreate 怎么优化？如果采用的还是 xml 就没法优化；只能通过减少 xml 中的布局的层级，减少 view 个数，就减少时间；还有就是从上面的原理来说，可以自己去 new 这些view 。不过也可以用 compose ，它没有 xml 了，通过 new 之类的创建出来的。固定测量方式，避免过度渲染，多次测量问题。</p>
<p>onCreate 执行完成后，只是解析完成了 xml ，在 setContentView 的时候会创建 decorView，然后创建了 window ，但是还没有 显示出来，还要在 wm.addView() 才能显示在硬件上。而 handleResume 的时候，先执行了 onResume 回调之后，然后再执行Activity 的wm.addView() 。</p>
<p>所以，Activity 怎么优化，就得onResume() 以及之前的所有方法（onCreate、onStart） 。所以，在 onResume 这里面如果有耗时操作，就要上前面说的阿里的策略了（Alpha）。以及相应的<strong>懒加载</strong>思想（ViewStub、Viewpaget+fragment 等）。</p>
<p>层级，深度遍历，多一层 2的次幂</p>
<p>尽量使用 ConstraintLayout 而不是 Linelayout 这些，会增加嵌套。从观法的数据来看，其渲染速度比 RelativeLayout 要提升 40% 。</p>
<p>Activity 中所有的回调都是在 handler 里面执行的。handler 机制体系里面会有MessageQueue ，message 按照时间排序，如果最开始的那个msg 都要 10ms 后执行，那么线程就会通过 epoll 机制睡眠了。所以我们还是利用 IdelHandler 去让主线程空闲的时候去做。比如说，后台 Service 有些内容是没有必要那么及时的，可以考虑在IdleHandler 中执行。</p>
<blockquote>
<p>GC 会 STW ，所以，我们也能在 IdleHandler 中取做 GC ，这样就不会影响主线程，LeakCanary里面就是这么做的（老师展示的代码是这样的，AndroidWatchExecutor.waitForIdle()  方法。还需要自己确认下）。要注意一点，IdleHandler 中不要做耗时操作，因为它也是个 msg</p>
</blockquote>
<p>当 App 第一个 Activity 的 window 展示将 SplashWindow 覆盖的时候，是在 windowFocusChange 中实现切换的。所以我们一般用 windowFocusChange 来标记新的 window 启动。</p>
<p>每一个 Activity 都会有一个独一无二的 Window </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>启动优化分为几个点：</p>
<ul>
<li><p>黑白屏阶段，使用 manifest 中 theme 的 windowSplashscreenContent 属性</p>
</li>
<li><p>Application 的 attachBaseContext() 回调中，可以用 字节的 BoostMultiDex 方案</p>
</li>
<li><p>Application 的 onCreate 阶段，采用图论原理，将各个任务依次执行，例如阿里的 Alpha 框架</p>
</li>
<li><p>接着就到了Activity 阶段，由于要遭 onResume 之后才会执行 vm.addView 最终展示 window ，所以在 onCreate、onStart 、onResume 这些回调里面都不要执行耗时操作</p>
</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/22/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8803%EF%BC%892022.1.18-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%AF%BE%EF%BC%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%20%E5%86%85%E5%AD%98%E7%AF%87%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/22/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8803%EF%BC%892022.1.18-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%AF%BE%EF%BC%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%20%E5%86%85%E5%AD%98%E7%AF%87%EF%BC%89/" class="post-title-link" itemprop="url">性能优化-：（03）2022.1.18-性能优化第三次课（性能优化 内存篇）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-22 18:50:00" itemprop="dateCreated datePublished" datetime="2023-05-22T18:50:00+08:00">2023-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-24 23:09:16" itemprop="dateModified" datetime="2023-05-24T23:09:16+08:00">2023-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>USS 很重要，因为这是 Uniq 的，每个进程独占的。</p>
<p>USS、PSS、VSS 等波动用来监测内存抖动</p>
<p>oom_adj 相当于进程的优先级，数值越大越容易被回收</p>
<p>GC Roots 有：</p>
<ul>
<li><p>在线程栈中的局部变量（正在被调用的方法的参数和局部变量）</p>
</li>
<li><p>存活的线程对象</p>
</li>
<li><p>JNI引用</p>
</li>
<li><p>Class 对象（在 Android 中 Class 被加载后不会被卸载的）</p>
</li>
<li><p>引用类型的静态变量</p>
</li>
</ul>
<p>自动化监测流程目标</p>
<ul>
<li><p>自动且较为准确监测 Activity 泄漏</p>
</li>
<li><p>自动获取泄漏的 Actiivty 和 冗余Bitmap 对象的引用链</p>
</li>
<li><p>能灵活地扩展 Hprof 的分析逻辑，必要时允许提取 Hprof 文件人工分析</p>
</li>
</ul>
<p>在监测阶段，需要 2 个问题：</p>
<ul>
<li><p>activity 在执行销毁的时候，我们如何得知</p>
</li>
<li><p>如何判断一个 Activity 无法被 GC 机制回收</p>
</li>
</ul>
<blockquote>
<p>可以写自己写过 APM ，或者带几个人做过</p>
</blockquote>
<p>我们之前说在 Activity 的 destroy 时触发GC，但是这样不怎么好，我们需要手动触发 GC ，会导致卡顿。所以，一般不使用 registerActivityCallback ，而是通过 阈值触发（如 count 计数），达到阈值时就触发GC （Koom 就是这么做的）。</p>
<h2 id="常见内存泄漏原因"><a href="#常见内存泄漏原因" class="headerlink" title="常见内存泄漏原因"></a>常见内存泄漏原因</h2><ul>
<li><p>动画问题（在activity销毁时，调用动画的cancel 方法）</p>
</li>
<li><p>匿名内部类</p>
</li>
<li><p>InputStream/OutputStream 、cursor 等没有 close </p>
</li>
<li><p>xxx未完，后续看老师的笔记</p>
</li>
</ul>
<h2 id="Koom-的分析"><a href="#Koom-的分析" class="headerlink" title="Koom 的分析"></a>Koom 的分析</h2><p>如何将 APM 写入简历？</p>
<blockquote>
<p>如果自己做过 APM 就更好，如果没有做过就将 APM 接入自己的项目中，然后收集数据，记住那些数据就OK了——路哥</p>
</blockquote>
<h3 id="1、Native-Heap-泄漏监控："><a href="#1、Native-Heap-泄漏监控：" class="headerlink" title="1、Native Heap 泄漏监控："></a>1、Native Heap 泄漏监控：</h3><p>主要思路是借助 <strong>Tracing Garbage Collection</strong>（一种垃圾回收算法）来进行监控，GC 回收器的 G1 回收器就是基于这个理论。</p>
<p>google 提供了一个 libmemunreachable 库，我们可以把所有的代码拷贝到 NDK 里面，自己打包成 so 库，就能调用这个库发现 Native 的内存泄漏了。它会告知有哪些地址可达和不可达（reachable）。</p>
<p>Koom 的核心监控代码都在各种 monitor 中，比如 LeakMonitor.kt 等。</p>
<p>爱奇艺的 xHook 能够Hook Native 代码，hook 诸如 malloc 等方法，替换成自己的 malloc 函数，这样就能监测Native 的代码行为。一旦调用了 malloc 等函数，就回调出去。</p>
<p>ida 这个工具可以查看某个 so 里面有哪些 api，这样就能查看它所有的方法。 </p>
<p>koom Native 内存泄漏分析的思路：</p>
<ul>
<li><p>hook malloc/free 等内存分配器方法，用于记录 Native 内存分配元数据（大小、堆栈、地址等）</p>
</li>
<li><p>周期性地使用 mark and sweep 分析整个进程 Native Heap，获取不可达的内存块信息（地址、大小）</p>
</li>
<li><p>利用不可达的内存块地址、大小等，从我们之前记录的元数据中获取其分配堆栈，产出泄漏数据（不可达内存地址、分配堆栈、大小等）</p>
</li>
</ul>
<p>APM 在大厂都只会说原理，没法谈实战的。Android 只有APM 这个知识点可以这样。面试官问你 Koom Native层面 怎样 hook ，用 xhook，怎么知道内存泄漏的，google 官方提供的 libmemunreachable 库</p>
<p>profiler 里面也可以选择当前的进程，然后能看到 Leaks 就可以知道哪些泄漏的。</p>
<h3 id="2、Java-内存监测思路"><a href="#2、Java-内存监测思路" class="headerlink" title="2、Java 内存监测思路"></a>2、Java 内存监测思路</h3><p>LeakCanary 采用了弱引用的特性，为Activity 创建了弱引用，但是会在 Activity 的 onDestroy 之后连续触发 2 次 GC，并检查引用队列。但是 GC 会引起用户可感知的卡顿，所以 Koom 采用了<strong>无性能损耗的内存阈值监控</strong>来触发镜像采集。</p>
<p>Koom 的整体流程如下图所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Koom%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Koom整体流程"></p>
<h3 id="3、hprof-文件"><a href="#3、hprof-文件" class="headerlink" title="3、hprof 文件"></a>3、hprof 文件</h3><p>使用以下的命令可以导出 hprof 文件：</p>
<blockquote>
<p>adb shell am dumpheap <processname> <filename></filename></processname></p>
</blockquote>
<p>或者在Android 中采用如下代码（会暂时挂起所有线程）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug.dumpHprofData(fileName)</span><br></pre></td></tr></tbody></table></figure>

<p>由于会暂时挂起所有的线程，所以 LeakCanary 在这个时候会非常非常卡，这也是为什么不能用于线上的一个原因。这个时候面试官可能会问，那怎么解决这个问题呢？开子线程行不行？</p>
<blockquote>
<p>肯定是不行的，因为这时候挂起了所有线程，包括你的这个子线程。</p>
</blockquote>
<p>解决方案：</p>
<ul>
<li><p>fork 子进程去执行 dumpHprofData 方法</p>
</li>
<li><p>fork 进程采用的是 “copy On Write” 技术，只有在进行写入操作时，才会为子进程拷贝分配独立的内存空间。默认情况下，子进程可以和父进程共享同个内存空间。所以，当我们要执行dumpProfData 方法时，可以 fork 一个子进程，它拥有父进程的内存副本，然后在子进程中取执行 dumpProfData 方法，而父进程可以正常继续运行。</p>
</li>
</ul>
<p>这个过程的流程图如下所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/fork%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%8E%B7%E5%8F%96dump%E4%BF%A1%E6%81%AF.png" alt="fork子进程获取内存镜像"></p>
<p>hprof 文件很大，一般可达 1G 的规模，所以不可能直接丢给后台去分析，一般会做以下裁剪。这时候就看你具体要什么，可能不同的公司需要的不一样，但是大体上需要看 bitmap、byte 数组 byte[] 等。有个 shark 工具可以用来分析这个 hprof ，便于后续的裁剪。 我们关注的主要是 三类 信息：</p>
<ul>
<li><p>字符串信息，保存着所有的字符串，在解析时可以通过索引id引用</p>
</li>
<li><p>类的结构信息：包括类内部的变量布局、父类信息等</p>
</li>
<li><p>堆信息：内存占用与对象引用的详细信息</p>
</li>
</ul>
<p>裁剪的主要思路如下：</p>
<ol>
<li><p>读取 Hprof 文件</p>
</li>
<li><p>记录 Bitmap 和 String 类信息</p>
</li>
<li><p>移除 Bitmap buffer 和 String value 之外的基础类型数组</p>
</li>
<li><p>将同一个图片的 Bitmap buffer 指向同一个  buffer id，移除重复的 Bitmap buffer</p>
</li>
<li><p>其他数据原封不动地输出到新文件中</p>
</li>
</ol>
<p>性能优化里面最难的就是 内存，后续的 FPS 之类的就比较简单了。</p>
<h2 id="落脚点"><a href="#落脚点" class="headerlink" title="落脚点"></a>落脚点</h2><p>启动优化</p>
<p>apm 的 demo</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/19/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8802%EF%BC%892022.1.16-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AF%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/19/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8802%EF%BC%892022.1.16-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AF%BE/" class="post-title-link" itemprop="url">性能优化-：（02）2022.1.16-性能优化第二次课</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-19 19:10:00" itemprop="dateCreated datePublished" datetime="2023-05-19T19:10:00+08:00">2023-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-24 23:09:07" itemprop="dateModified" datetime="2023-05-24T23:09:07+08:00">2023-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>LeakCanary 只能在线下，不能用于线上。LeakCanary 有什么缺点？线上怎么做？</p>
<p>只能对 Acitvirty 和 Fragment 去做</p>
<p>强引用：宁愿 OOM 也不会回收的</p>
<p>软引用：内存足够的时候，即时发生GC，也不会被回收，但是内存不足的时候，就回收了</p>
<h2 id="一、OOM-与内存优化"><a href="#一、OOM-与内存优化" class="headerlink" title="一、OOM 与内存优化"></a>一、OOM 与内存优化</h2><p>启动优化，APM 框架</p>
<p>日志系统，使用 mmap  系统崩了也不会丢  </p>
<p>使用  xlog </p>
<p>Linux 内核动态内存分配，所以 MemAvailable 不一定准确</p>
<p>RSS 实际使用的物理内存——包含了 共享库的内存（so动态链接库），所以容易误导</p>
<p>python 做自动化测试，python 不断读取那些数据</p>
<p>Android 会对所有进程分类，每一个类别都有其 oom_adj 的值取值范围， oom_adj 的值越大，说明越不重要。因此，内存不足 kill 进程时，从 oom_adj 高的进程开始杀</p>
<p>如果想要一个服务长期运行，应该将其运行在单独的进程里，即 UI进程与 Service 进程分离，这样就能获得较小的 oom_adj 值，就容易存活。而占有大量内存的 UI 进程会分类为 Cached 进程，能够在需要的时候更快地被回收。</p>
<h2 id="LeakCanary-的源码"><a href="#LeakCanary-的源码" class="headerlink" title="LeakCanary 的源码"></a>LeakCanary 的源码</h2><p>里面注册了 ContentProvider ，为啥？</p>
<h2 id="线上监测"><a href="#线上监测" class="headerlink" title="线上监测"></a>线上监测</h2><ul>
<li><p>端上解析：就是在设备上做引擎解析，自己解析内存泄漏</p>
</li>
<li><p>后台解析： 内存镜像，fork 出当前进程，然后将子进程信息发给后台</p>
</li>
</ul>
<p>监测 Activity 生命周期可以使用 RegisterActivityLifecycleCallback 的方式，然后使用 WeakHashMap 来监测回收，因为 WeakHashMap 它的 Key 是弱引用，它里面有个 ReferenceQueue 。</p>
<p>在 ActivityLifecycleCallback 的 onActivityDestroy 回调中，以 Activity 的方式作为 key ，value 可以使用 activity.getClass().getSimpleName()，在 WeakHashMap 中就可以监听 key 的回收，就能监听 Activity 的回收了。类似于如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakHashMap&lt;Activity, String&gt; datas = 。。。</span><br></pre></td></tr></tbody></table></figure>

<p>然后，在 onActivityStopped 回调中，因为 activity 此时不可见了，可以使用 GC 来找泄漏的 Activity ：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">//申请一个大的 byte 数组，便于后续的 GC 触发</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[N];</span><br><span class="line">    <span class="comment">//延时</span></span><br><span class="line">    SystemClock.sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//GC，使用 runtime的gc 更容易触发 gc 一点</span></span><br><span class="line">    Runtime.getRuntime().gc();</span><br><span class="line">    <span class="comment">//课程里面说用这个来复活，而不是直接用上面的 gc ，没看懂意思，后续深究</span></span><br><span class="line">    <span class="comment">//System.runFinalization();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从之前的 WeakHashMap 中遍历所有的 Activity</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分析内存</span></span><br><span class="line">    Debug.MemoryInfo debug = <span class="keyword">new</span>  Debug.MemoryInfo();</span><br><span class="line">    Debug.getMemoryInfo(debug);</span><br><span class="line">    <span class="comment">//就可以获取很多内存信息了</span></span><br><span class="line">    <span class="keyword">int</span> nativePss = debug.nativePss() &gt;&gt; <span class="number">10</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当然，这里面还需要很多判断，比如判断 Activity 是否在后台。有个同学提出了，如果面试官说这里每次 Activity 的 onStop 都去做这些操作，是否合理？那也确实不合理，假如，只是做了 Activity a 跳转到 Activity b，触发了 a 的 onStop ，这里就有点浪费。所以呢，这里还需要判断 ，其实也是判断 Activity 是否在后台（可能不一定对，听课是这样理解说判断是否在后台）。</p>
<p>这里获取 pss 也能生成曲线图，这个曲线图有什么用呢？就是监测在运行某个功能时，内存占用的问题，就能定向排查问题</p>
<p>爱奇艺的 xhook ，用于 nativeHook</p>
<p>路哥性能优化课程的产出：</p>
<ol>
<li><p>启动优化框架</p>
</li>
<li><p>简单的 APM 框架</p>
</li>
</ol>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/16/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8801%EF%BC%892021.1.13-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AF%BE%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/16/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8801%EF%BC%892021.1.13-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AF%BE%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%89/" class="post-title-link" itemprop="url">性能优化-：（01）2021.1.13-性能优化第一次课（数据结构篇）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-16 19:53:00" itemprop="dateCreated datePublished" datetime="2023-05-16T19:53:00+08:00">2023-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-24 22:52:33" itemprop="dateModified" datetime="2023-05-24T22:52:33+08:00">2023-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>如果想自己写公司的apm，可以参考koom和matrix这2个来源框架</p>
<p>做完a任务和b任务，就可以做c任务，这时候可以用countdownLatch来实现​</p>
<p>做性能优化，很重要的一点就是线上的APM​</p>
<h2 id="二、Java层的实现"><a href="#二、Java层的实现" class="headerlink" title="二、Java层的实现"></a>二、Java层的实现</h2><blockquote>
<p>简历中一定要有指标</p>
</blockquote>
<ul>
<li><p>cpu指标，如负载，线程数等</p>
</li>
<li><p>内存指标</p>
</li>
<li><p>FPS</p>
</li>
<li><p>ANR</p>
</li>
<li><p>卡顿</p>
</li>
<li><p>GC/oom还是和内存相关，gc日志</p>
</li>
<li><p>网络，hook到okhttp</p>
</li>
<li><p>远程下发，日志回捞，下发shell，执行动态代码</p>
</li>
<li><p>crash怎么监测？其实就是监视线程，java层有uncatchexception</p>
</li>
<li><p>anr怎么监测？就是监测文件，file obsever，监测anr文件</p>
</li>
<li><p>用户行为链路，其实就是监测activity和fragment。在application中通过lifecyclecallback即可</p>
</li>
</ul>
<p>可以说我们公司有做了类似头条的 APM，有几个人做，参考了xx，xx框架实现了</p>
<h2 id="三、APM"><a href="#三、APM" class="headerlink" title="三、APM"></a>三、APM</h2><p>首先讲设计思路。</p>
<h3 id="1、配置"><a href="#1、配置" class="headerlink" title="1、配置"></a>1、配置</h3><p>做 APM 肯定是有配置的，类似于:</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] params default {}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[{</span><br><span class="line">    <span class="attr">"clazz"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Test"</span>,</span><br><span class="line">    <span class="attr">"params"</span>: [<span class="string">"a"</span>, <span class="string">"b"</span>]</span><br><span class="line">}]</span><br></pre></td></tr></tbody></table></figure>

<p>配置都是使用 <strong>注解</strong> + <strong>Json</strong> 实现 （课程里面还没说怎么用到的注解）</p>
<h3 id="2、cpu与gc"><a href="#2、cpu与gc" class="headerlink" title="2、cpu与gc"></a>2、cpu与gc</h3><p>使用linux命令​如prco/stat等</p>
<h3 id="3、anr"><a href="#3、anr" class="headerlink" title="3、anr"></a>3、anr</h3><p>面试官问一个问题，首先要回答<strong>有哪些知识点，看过哪些框架</strong>​，比如做性能监测，面试官问你是启动优化吗？可能不那么好回答，但是可以说做了类似抖音，类似快手的APM，别人就明白了。然后就是几个人做，大概做什么我负责哪些部分，我看了哪些框架源码，我自己是怎么想的。</p>
<p>anr监测主要就是文件监听，监听data/anr/trace.txt​</p>
<h3 id="4、fps帧率"><a href="#4、fps帧率" class="headerlink" title="4、fps帧率"></a>4、fps帧率</h3><p>使用 Geographer（单词可能写错，翻译为:编舞者​）</p>
<h2 id="四、如何看项目源码"><a href="#四、如何看项目源码" class="headerlink" title="四、如何看项目源码"></a>四、如何看项目源码</h2><ol>
<li><p>首先看构造函数</p>
</li>
<li><p>其次浏览属性，不一定能全部看懂，粗略知道含义</p>
</li>
<li><p>看其重要的 api 中的具体实现</p>
</li>
</ol>
<p>看代码的时候，需要思考别人为什么这么设计。比如别人使用数据结构是基于什么考虑，空间换时间，还是时间换空间。 老师以 ArrayList 为例分析了这个过程。</p>
<blockquote>
<p> 这里有个知识点，ArrayList 扩容的时候，变成以前的1.5倍</p>
</blockquote>
<p>HashMap 的 getNode() ，这个方法很精华：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(Object key)</span> </span>{</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n, hash; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; (hash = hash(key))]) != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> {</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            } <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>由于在一定时候会将链表转为红黑树，所以在 get 的时候需要判断是树还是链表：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (first <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br></pre></td></tr></tbody></table></figure>

<p>这个判断是否是树，是树就从红黑树中获取，是链表就do-while 遍历链表，直至找到或者遍历到最后一个结点为止。</p>
<p>这里面有个值得注意的点，用 &amp; 符做求余的操作，根据 hash 值求 index  ：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; (hash = hash(key))]) != <span class="keyword">null</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>通过 (n - 1) &amp; (hash = hash(key)) 确定当前 key 应该在 HashMap 中数组的位置。注意一下，只有当 n 是 2 的 多少次方的情形才适用，采用 &amp; 操作进行求余的原理可以参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33728584/article/details/114623109">java取余位运算_使用位运算&amp;取余_陈安研究员的博客-CSDN博客</a></p>
<h2 id="五、代码性能评测"><a href="#五、代码性能评测" class="headerlink" title="五、代码性能评测"></a>五、代码性能评测</h2><p>在公司证明自己做的事情需要做测试数据，比如说 SparseArray 、ArrayMap 来替换 HashMap ，怎么证明性能更高？那就适用 几个，几千，几万个数据，然后通过 Android Studio 的 Profiler 去可视化查看Memory 指标中 Java 方面占用的空间。</p>
<p>老师解析 SparseArray 源码的时候，put 操作值得关注：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) {</span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        i = ~i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) {</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) {</span><br><span class="line">            gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search again because indices may have changed.</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果已经存在key-value了，那就直接覆盖，否则，看起来通过</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = ~i;</span><br></pre></td></tr></tbody></table></figure>

<p>即对 i 取反操作就能获取到要存入的位置，这是什么原理？其实这是个技巧，避免了再次计算一次 index ，总而言之就是<strong>取反操作(~) 的性质</strong>：</p>
<ul>
<li><p>当 n 为正数时， ~(n) = -(n + 1)</p>
</li>
<li><p>当 n 为负数时， ~n = (-n) - 1 </p>
</li>
</ul>
<p>所以，上述判断 i 的逻辑就比较通顺了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">0</span>) {</span><br><span class="line">    mValues[i] = value;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    i = ~i;</span><br><span class="line">    <span class="comment">//。。。。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>如果找到位置当前有值了，直接覆盖；否则，取反得到真正的 index ，然后根据判断将 key 和 value 存入。附 binarySearch （<strong>二分查找</strong>）的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> size, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) {</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> midVal = array[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; value) {</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; value) {</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// value found</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ~lo;  <span class="comment">// value not present</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="1、SparseArray-和-HashMap-比较："><a href="#1、SparseArray-和-HashMap-比较：" class="headerlink" title="1、SparseArray 和 HashMap 比较："></a>1、SparseArray 和 HashMap 比较：</h3><ul>
<li><p>2个数组key数组和value数组</p>
</li>
<li><p>默认是10的大小，hashmap为16</p>
</li>
<li><p>不需要包装</p>
</li>
<li><p>二分查找，稍微低了点点，HashMap 的hash算法效率高</p>
</li>
</ul>
<p>所以，SparseArray 的主要优势是节省内存。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>本质：二叉树来维护一维数组</p>
<p>堆它和树有什么区别？堆不用指针（Node），树会有指针，所以堆更省内存。</p>
<p>二叉树最后一个非叶子节点：(length - 1) /2，排序首先动这个结点。</p>
<p>《算法导论》太难就看《算法4》</p>
<p>opencv 和 ffmpeg 不建议去做，深入太难了</p>
<p>flutter 也不要去写 API ，要去架构，引擎的东西</p>
<p>路哥活得很通透：</p>
<p>大起大落，讲课的时候失去了所有，名言：</p>
<ul>
<li><p>人总要失去些什么才能成长</p>
</li>
<li><p>除了生与死，其他的都是小事</p>
</li>
</ul>
<p>算法不用怕，早晚半个小事，坚持3年，大厂没问题</p>
<p>总要去做架构，假如以后的部门黄了</p>
<p>vulcan 是 openGL 的升级版</p>
<p>录音分析，自己面试为什么会失败，一句话一句话听</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/15/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A%EF%BC%8816%EF%BC%892021.8.27Java%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6-Json%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/15/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A%EF%BC%8816%EF%BC%892021.8.27Java%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6-Json%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Java筑基-：（16）2021.8.27Java基础进阶-Json解析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-15 19:58:00" itemprop="dateCreated datePublished" datetime="2023-05-15T19:58:00+08:00">2023-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-17 22:52:57" itemprop="dateModified" datetime="2023-05-17T22:52:57+08:00">2023-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>json 的 key 必须是 String 类型，因此不能是 null。</p>
<p>json中的数字支持正/负数，还支持以 e 表示的方式</p>
<p>Gson 中 @SerializedName 表示的是转换为json 的时候的名字，和目前的本身的名字没什么关系。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SerializedName("sex")</span></span><br><span class="line"><span class="keyword">public</span> String a;</span><br></pre></td></tr></tbody></table></figure>



<p>Gson 普通使用一般都是使用反射去做，不能自定义序列化过程，我们可以设置 JsonAdapter ，自己控制序列化过程。GsonBuilder 去设置：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> GsonBuilder().xxxxx.create();</span><br></pre></td></tr></tbody></table></figure>

<p>使用 Gson 解析字符串的时候，碰到类似：</p>
<blockquote>
<p>expected BEGIN_ARRAY but was STRING </p>
</blockquote>
<p>之类的错误，可以通过自定义 TypeAdapter 或者 JsonDeserializer 的方式去解决。这里面注意，在使用 GsonBuilder 构建的时候，可以关注 serializeNulls</p>
<p>Gson 是基于事件驱动的解析方式，它可以不要求一次性将数据全部加入内存。它的工作流程是：</p>
<ul>
<li><p>假如解析加载的数据碰到 “{“ ，那就说明碰到 jsonObject 了，则现将 “{“ 入栈，然后等待后续的  “}” 的时候再一起出栈组这个 jsonObject</p>
</li>
<li><p>其他的诸如碰到 “[“ 也是一样的，都是先压栈，等配套的符号来了之后再一起出栈</p>
</li>
</ul>
<p>JsonElement 有 4 种实现类，分别是：</p>
<ul>
<li><p>JsonNull</p>
</li>
<li><p>JsonObject</p>
</li>
<li><p>JsonArray</p>
</li>
<li><p>JsonPrimitive：Json基本类型，比如 String 、int、number等</p>
</li>
</ul>
<p><font color="#ff0000">Gson 源码解析这次就不看了，下次。</font></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/11/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A%EF%BC%8814%EF%BC%892021.8.25%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%9302/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/11/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A%EF%BC%8814%EF%BC%892021.8.25%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%9302/" class="post-title-link" itemprop="url">Java筑基-：（14）2021.8.25 深入理解并发编程和归纳总结02</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-11 19:20:00" itemprop="dateCreated datePublished" datetime="2023-05-11T19:20:00+08:00">2023-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-17 22:42:28" itemprop="dateModified" datetime="2023-05-17T22:42:28+08:00">2023-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、synchronized-的实现原理"><a href="#一、synchronized-的实现原理" class="headerlink" title="一、synchronized 的实现原理"></a>一、synchronized 的实现原理</h2><p>如果在方法里面使用 synchronized(obj) 这种用法，那么 javac 在编译的时候会插入 monitorenter 和 monitorexit 字节码。规则如下：</p>
<ul>
<li><p>monitorenter 指令是在编译后插入到同步代码开始的位置；而monitorexit是插入到方法结束处和<strong>异常处</strong></p>
</li>
<li><p>每个monitorenter 必须要有对应的 monitorexit 配对</p>
</li>
<li><p>任何对象都有一个 monitor 与之关联</p>
</li>
</ul>
<p>示意图如下所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/synchronized%E5%9C%A8%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8.png" alt="在方法里面使用"></p>
<p>如果在使用 synchronized doSomething() 这种方式的话，会在字节码上的 flag 上添加 ACC_SYNCHRONIZED 标记，不过底层原理还是 monitor 这套。示意图如下：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/synchronized%E7%9B%B4%E6%8E%A5%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95.png" alt="synchronized直接修饰方法"></p>
<p>一般的 Java 对象头（除了对象体和数据外的部分）会包括 2 个部分，如果是数组对象就会新增数组长度：</p>
<ul>
<li><p>MarkWord： GC 信息、 hashCode、<strong>锁信息</strong> 等</p>
</li>
<li><p>KlassPoint： 对象所属的类</p>
</li>
<li><p>ArrayLen（是我自己写的英语，不一定是这个）： 数组长度</p>
</li>
</ul>
<p>上述说的锁信息，包括锁状态、是否偏向、锁标志位等，当然，需要注意一点的是，对象头的锁信息不是一成不变的。如：偏向锁时，存放的是偏向线程的 id；轻量级锁的时候，存放了栈中锁记录的指针；重量级锁的时候，存放互斥量（重量级锁）的指针。</p>
<h2 id="二、一线大厂的面试题"><a href="#二、一线大厂的面试题" class="headerlink" title="二、一线大厂的面试题"></a>二、一线大厂的面试题</h2><h4 id="1、synchronized-修饰普通方法和静态方法有什么区别？"><a href="#1、synchronized-修饰普通方法和静态方法有什么区别？" class="headerlink" title="1、synchronized 修饰普通方法和静态方法有什么区别？"></a>1、synchronized 修饰普通方法和静态方法有什么区别？</h4><p>synchronized 锁一定是和某个对象相关联的，加锁要加在具体地对象上。普通方法修饰当前对象，静态修饰class 对象。思考下：同时存在被 synchronized 修饰的普通方法和 静态方法，这二者能不能同时执行？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">normalMethod</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>答案是肯定能够同时执行的，因为这二者压根锁的不是同一个对象，是2个不同的锁，所以肯定可以同时执行。</p>
<h4 id="2、什么是可见性"><a href="#2、什么是可见性" class="headerlink" title="2、什么是可见性"></a>2、什么是可见性</h4><p>这涉及到工作内存和主内存。多个线程共享一个变量，如果一个对象更改了这个共享值，其他线程也能立即看到修改值。那如何保证可见性呢？采用 volatile 和 加锁</p>
<h4 id="3、锁的分类"><a href="#3、锁的分类" class="headerlink" title="3、锁的分类"></a>3、锁的分类</h4><p>根据不同的场景可以将锁分为多类，如下图所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/%E9%94%81%E5%88%86%E7%B1%BB.png" alt="锁的分类"></p>
<h4 id="3、CAS的原理"><a href="#3、CAS的原理" class="headerlink" title="3、CAS的原理"></a>3、CAS的原理</h4><p>主要利用现代CPU提供的 比较并交换（CAS）指令，这个指令具有原子性。CAS 存在的问题：</p>
<ul>
<li><p>ABA问题</p>
</li>
<li><p>开销问题</p>
</li>
<li><p>只能适应简单变量问题</p>
</li>
</ul>
<h4 id="4、ReentrantLock-实现原理"><a href="#4、ReentrantLock-实现原理" class="headerlink" title="4、ReentrantLock 实现原理"></a>4、ReentrantLock 实现原理</h4><p>进入一次锁，state 就加 1 ，退出一次锁，就减 1 。当然，底层是采用 AQS 实现的</p>
<h4 id="5、AQS-原理"><a href="#5、AQS-原理" class="headerlink" title="5、AQS 原理"></a>5、AQS 原理</h4><p>可重入锁、CountDownLatch 、读写锁 等都是使用 AQS </p>
<p>如果需要自己定义一种锁，只需要创建静态内部类，继承 AQS ，这是模板类，只需要实现几个关键方法如  tryAcquire 即可</p>
<h4 id="6、Synchronized-原理"><a href="#6、Synchronized-原理" class="headerlink" title="6、Synchronized 原理"></a>6、Synchronized 原理</h4><p>Synchronized(obj) 的形式是基于 monitorenter 和 monitorexit 字段</p>
<p>修饰的是方法的话，在字节码中的Flag 字段中会添加  ACC_SYNCHRONIZED 标记</p>
<h4 id="7、synchronized-和-ReentrantLock-区别"><a href="#7、synchronized-和-ReentrantLock-区别" class="headerlink" title="7、synchronized 和 ReentrantLock 区别"></a>7、synchronized 和 ReentrantLock 区别</h4><p>一个是显式锁，一个是关键字，内置所</p>
<p>synchronized 是非公平锁，ReentrantLock 可以公平和非公平</p>
<h4 id="8、锁的优化"><a href="#8、锁的优化" class="headerlink" title="8、锁的优化"></a>8、锁的优化</h4><p>偏向锁</p>
<p>轻量级锁</p>
<p>锁消除（与后续的逃逸分析联系比较紧密）</p>
<p>锁粗化</p>
<p>逃逸分析</p>
<h4 id="9、volatile-在-DCL上的作用"><a href="#9、volatile-在-DCL上的作用" class="headerlink" title="9、volatile 在 DCL上的作用"></a>9、volatile 在 DCL上的作用</h4><p>new 一个对象会有3个步骤：</p>
<ul>
<li><p>分配内存</p>
</li>
<li><p>初始化空间</p>
</li>
<li><p>赋值给引用</p>
</li>
</ul>
<p>但是会有指令重排序，上述的 3 个步骤不一定按顺序完成，如果分配内存、赋值引用执行了，但是初始化空间还没完成，这时候双重检查的单例方式可能会使用初始化一半的对象，使用就会报错。</p>
<p>所以需要 volatile 关键字修饰</p>
<h4 id="10、如何退出一个线程"><a href="#10、如何退出一个线程" class="headerlink" title="10、如何退出一个线程"></a>10、如何退出一个线程</h4><p>采用线程的 interrupt 方法，利用中断机制来退出线程。</p>
<h4 id="11、线程池原理"><a href="#11、线程池原理" class="headerlink" title="11、线程池原理"></a>11、线程池原理</h4><p>为什么要用线程池：</p>
<ul>
<li><p>降低资源消耗</p>
</li>
<li><p>提高响应速度</p>
</li>
<li><p>提升线程的可管理性</p>
</li>
</ul>
<p>再讲一讲线程池里面各个参数的含义。后续的线程拒绝策略，系统提供的4种拒绝策略</p>
<h4 id="12、t1、t2、t3-三个线程，如何保证按顺序执行"><a href="#12、t1、t2、t3-三个线程，如何保证按顺序执行" class="headerlink" title="12、t1、t2、t3 三个线程，如何保证按顺序执行"></a>12、t1、t2、t3 三个线程，如何保证按顺序执行</h4><p>采用 join 方法嘛</p>
<h2 id="三、了解synchronized升级过程"><a href="#三、了解synchronized升级过程" class="headerlink" title="三、了解synchronized升级过程"></a>三、了解synchronized升级过程</h2><p>通过CAS操作来加锁和解锁。采用自旋锁方式获取锁，万一其他线程很快释放锁呢。避免阻塞。</p>
<p>oracle 发现在很多情况下，1个锁在很多情况下都是同一个线程来获取的，所以这时候 CAS 操作都不想做了，这时候就产生了 偏向锁。（不过markword的字段更改的时候还是得用CAS操作的）</p>
<p>synchronized 整个的升级过程如下图所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png" alt="synchronized升级过程"></p>
<p>偏向锁和轻量级锁的对象头是完全不一样的，所以在撤销偏向锁改为轻量级锁的时候，需要替换 markword 。</p>
<p>但是撤销偏向锁的时候，会 STW ，撤销偏向锁的时候，需要修改线程 1 的堆栈内容的。markword 会存放在 线程 1 的堆栈里面，线程 2 要跨线程把线程1的堆栈的数据改过来。所以需要 Stop The World </p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A%EF%BC%8813%EF%BC%892021.8.24%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%9301/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A%EF%BC%8813%EF%BC%892021.8.24%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%9301/" class="post-title-link" itemprop="url">Java筑基-：（13）2021.8.24 深入理解并发编程和归纳总结01</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-10 20:50:00" itemprop="dateCreated datePublished" datetime="2023-05-10T20:50:00+08:00">2023-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-17 22:36:27" itemprop="dateModified" datetime="2023-05-17T22:36:27+08:00">2023-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、AQS的基本思想CLH队列锁"><a href="#一、AQS的基本思想CLH队列锁" class="headerlink" title="一、AQS的基本思想CLH队列锁"></a>一、AQS的基本思想CLH队列锁</h2><p>维护了一个链表，每个节点包含以下几个属性： 当前线程本身、我的前驱结点 以及 locked 标记（默认为true，当为false的时候，意味着释放锁了），示意图如下：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/CLH%E9%98%9F%E5%88%97%E9%94%81%E7%BB%93%E7%82%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="CLH队列锁结点示意图"></p>
<p>当有线程需要获取锁的时候，便构造一个QNode类型结点 ，通过 CAS 操作将这个结点接入到链表尾部，同时将结点的前驱指向之前的尾部结点，自己则成为新的尾部结点（tailNode）。</p>
<p>获取锁的阶段：每个结点不断轮询前驱节点的 locked 是否为 false ，否的话，则 yield 等待下一次判断；如果是的话，则意味着前驱结点已经释放了锁，接下来该自己获取锁了。当然，实际操作可能还需要额外操作（比如公平锁时还需要判断自己当前是否是头结点）</p>
<p>CLH队列锁提供了一个很好的思路，但是一直自旋会消耗资源，因此，AQS 在这个思路上做了一些改进：</p>
<ul>
<li><p>链表改为了双向链表，而不是之前的单向</p>
</li>
<li><p>控制自旋次数（一般2到3次），当自旋到一定次数后，就会阻塞挂起</p>
</li>
</ul>
<h2 id="二、公平锁和非公平锁"><a href="#二、公平锁和非公平锁" class="headerlink" title="二、公平锁和非公平锁"></a>二、公平锁和非公平锁</h2><p>我们以 ReentrantLock 为例，看下它在公平锁和非公平锁时的代码实现，首先是非公平锁：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initialTryLock</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) { <span class="comment">// first attempt is unguarded</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (getExclusiveOwnerThread() == current) {</span><br><span class="line">            <span class="keyword">int</span> c = getState() + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>公平锁的实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initialTryLock</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedThreads() &amp;&amp; compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) {</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (getExclusiveOwnerThread() == current) {</span><br><span class="line">            <span class="keyword">if</span> (++c &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出二者并没有什么区别，只有在 if 条件里面，公平锁多了 一个 ！hasQueuedPredecessors() 判断，这个方法的含义是这样的：</p>
<blockquote>
<p>Queries whether any threads have been waiting to acquire longer than the current thread.</p>
</blockquote>
<p>这也就是公平的含义了，要判断是否有其他线程比当前这个线程等待时间更久。</p>
<h2 id="三、可重入"><a href="#三、可重入" class="headerlink" title="三、可重入"></a>三、可重入</h2><p>假如有 2 个成员方法，a() 和 b() ，都使用 synchronized 关键字修饰，其中 a 方法里面 调用了 b 方法，因为 synchronized 关键字的锁是可重入的，所以能够正常执行，但是，如果锁是不可重入的话，会发生什么？</p>
<p>答案是会发生死锁，自己把自己给锁死了。因为 b 方法获取锁执行 compareAndSetState(0, acquires) 的时候肯定是不成功的，因为 a 方法的时候已经将这个值设置为 1 了。</p>
<h3 id="1、实现"><a href="#1、实现" class="headerlink" title="1、实现"></a>1、实现</h3><p>可重入锁是怎么实现的呢？还是在上述代码中，我们能看到这样的判断：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (getExclusiveOwnerThread() == current)</span><br></pre></td></tr></tbody></table></figure>

<p>也就是当前获得锁的线程是否就是自己，如果是自己的话，就直接进入了！这就是可重入锁的奥秘。</p>
<blockquote>
<p>这里聊下为什么用 ++state  操作来标记重入锁的这个 state 状态，这主要是因为方便释放锁，退出一个同步块 的时候只需要将 state 减去 1 即可，一直减到 0 就释放了最外层的锁了</p>
</blockquote>
<h2 id="四、JMM（Java-内存模型：Java-Memory-Model）"><a href="#四、JMM（Java-内存模型：Java-Memory-Model）" class="headerlink" title="四、JMM（Java 内存模型：Java Memory Model）"></a>四、JMM（Java 内存模型：Java Memory Model）</h2><p>看下 Google 大牛做的报告：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%A7%8D%E9%80%9F%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5-google%E5%A4%A7%E7%89%9B%E7%9A%84%E6%8A%A5%E5%91%8A.png" alt="速度概念"></p>
<p>如果要做 a + b 的操作，CPU 读取 a 和 b 这 2 个值花费了 200ns ，而真正的计算只花了 0.6ns ，所以需要cpu里面需要高速缓存。</p>
<p>工作内存和主内存是抽象概念，工作内存可能是寄存器、cpu高速缓存等，主内存可能主要指内存条。每个线程里面的工作内存是<strong>独享</strong>的，不能访问其他线程的工作内存。</p>
<h2 id="五、volatile-详解"><a href="#五、volatile-详解" class="headerlink" title="五、volatile 详解"></a>五、volatile 详解</h2><p>只保证可见性和有序性（禁止指令重排），对于复合指令（如 i ++）是没有原子性的。怎么做到的呢？</p>
<p>volatile 变量修饰的共享变量在进行写操作的时候会适用 CPU 提供的 lock 前缀指令，它的作用是：</p>
<ul>
<li><p>将当前处理器缓存行的数据写回系统内存</p>
</li>
<li><p>写回内存的操作同时让其他 cpu 缓存的该变量数据失效</p>
</li>
</ul>
<p>适用的场景：</p>
<ul>
<li><p>一个线程写，多个线程读</p>
</li>
<li><p>多个线程写没有关联</p>
</li>
</ul>
<blockquote>
<p> 比如 count = count + 1 那么，这个 count 是跟以前的值是有关联的。而 count = 5 之类的操作是没有关联的</p>
</blockquote>
<p>一般可以用 volatile + CAS 操作来替换 synchronized 来提升效率， 如 ConcurrentHashMap </p>
<h2 id="刚野课看到的"><a href="#刚野课看到的" class="headerlink" title="刚野课看到的"></a><font color="#ff0000">刚野课看到的</font></h2><p>RecycleView用了自定义View ，View 里面有动画，动画的 update 里面执行了 invalidate ，这就会触发 draw 方法，而 draw 方法里面new 了 多个 Path ，造成内存抖动。会引起动画的卡顿</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(10-1)%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(10-1)%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">Java筑基-：线程基本使用入门（2）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-10 19:25:00" itemprop="dateCreated datePublished" datetime="2023-05-10T19:25:00+08:00">2023-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-17 22:13:34" itemprop="dateModified" datetime="2023-05-17T22:13:34+08:00">2023-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、分而治之思想"><a href="#一、分而治之思想" class="headerlink" title="一、分而治之思想"></a>一、分而治之思想</h2><p>算法中分而治之思想和动态规划思想有点类似，要注意区分：</p>
<ul>
<li><p><strong>分而治之:</strong> 将一个任务分割成很多小任务，并且各个任务之间无关联</p>
</li>
<li><p><strong>动态规划：</strong> 将一个任务 A 分割成很多小任务，比如 a1、a2、a3 ，假如存在 a1 执行完成才能执行a3，那就是小任务有关联性了，这就是动态规划思想了</p>
</li>
</ul>
<blockquote>
<p> 快排，归并，二分都是分而治之的思想。</p>
</blockquote>
<p>在 Java 7 中提供了 Fork/Join 工具（Fork：将任务拆分成很多独立的子任务；Join：将所有的子任务结果合并）来让分而治之的思想并发执行起来。当然，我们也可以不使用这个框架，自己将任务分成很多小任务，然后用多线程去执行。不过呢，Java 的 ForkJoin 给提供了<strong>工作窃取（work-stealing）</strong> 算法，能够让执行更高效。</p>
<h3 id="2-1-工作窃取"><a href="#2-1-工作窃取" class="headerlink" title="2.1 工作窃取"></a>2.1 工作窃取</h3><p><strong>工作窃取（work-stealing）</strong> 简单来说就是空闲线程试图从繁忙线程的 deques 中窃取工作。</p>
<p>默认情况下，每个工作线程从自己的双端队列中获取任务，但如果自己队列中任务已经执行完成，队列为空时，它就会从另一个繁忙线程的双端队列尾部或者全局入口队列中获取任务，因为这是最大概率可能找到工作的地方。</p>
<blockquote>
<p>为什么会有任务先执行完成呢？因为工作量的划分不一定均等。即使是相同数量的数字相加，比如，每个任务都是10个数字相加，如果数字很大的话，耗时也会很长。</p>
</blockquote>
<h2 id="二、Java-提供的-ForkJoin"><a href="#二、Java-提供的-ForkJoin" class="headerlink" title="二、Java 提供的 ForkJoin"></a>二、Java 提供的 ForkJoin</h2><p>Java 提供分而治之的框架： ForkJoin。既然是要提交任务，我们需要对任务进行封装，ForkJoin 提供了 ForkJoinTask<v> 来包装任务：</v></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>不过一般不直接使用它，而是用它的 2 个主要的子类：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">RecursiveAction</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>从这 2 个子类我们能看出，RecursiveTask 更适合有返回值的情形；RecursiveAction 适合没有返回值的情形。ForkJoinTask 它有2种使用方法：</p>
<ul>
<li><p>同步用法：采用 invoke 来提交任务</p>
</li>
<li><p>异步用法：采用submit 或者 execute 方法来提交任务</p>
</li>
</ul>
<p>使用 ForkJoin 的方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] src = MakeArray.makeArray();</span><br><span class="line">    <span class="comment">//第一步，创建池子</span></span><br><span class="line">    ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    <span class="comment">//第二步：构建任务</span></span><br><span class="line">    SumTask innerFind = <span class="keyword">new</span> SumTask(src, <span class="number">0</span>, src.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//第三步、提交，invoke 意味着同步执行</span></span><br><span class="line">    pool.invoke(innerFind);</span><br><span class="line">    <span class="comment">//第四步、获取结果</span></span><br><span class="line">    System.out.println(<span class="string">"the result is "</span> + innerFind.join() +</span><br><span class="line">            <span class="string">"，spend time："</span> + (System.currentTimeMillis() - start));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中，makeArray 只是用来生成一个数组：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeArray</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_LENGTH = <span class="number">4000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> THRESHOLD = <span class="number">47</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] makeArray() {</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[ARRAY_LENGTH];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_LENGTH; i++) {</span><br><span class="line">            result[i] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>真正的任务代码，由于我们需要有返回值，所以我们继承了 RecursiveTask ：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREASHOLD = MakeArray.ARRAY_LENGTH / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] src;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fromIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> toIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.src = src;</span><br><span class="line">        <span class="keyword">this</span>.fromIndex = fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.toIndex = toIndex;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//判定任务大小是否合适</span></span><br><span class="line">        <span class="keyword">if</span> (toIndex - fromIndex &lt; THREASHOLD) {</span><br><span class="line">            <span class="comment">//满足要求，计算结果</span></span><br><span class="line">            System.out.println(<span class="string">"from index = "</span> + fromIndex + <span class="string">"，toIndex = "</span> + toIndex);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt;= toIndex; i++) {</span><br><span class="line">                <span class="comment">//Thread.sleep(1);</span></span><br><span class="line">                count = count + src[i];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//还不满足要求，则继续拆分任务</span></span><br><span class="line">            <span class="keyword">int</span> mid = (fromIndex + toIndex) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//拆分出左边的任务</span></span><br><span class="line">            SumTask left = <span class="keyword">new</span> SumTask(src, fromIndex, mid);</span><br><span class="line">            <span class="comment">//拆分出右边的任务</span></span><br><span class="line">            SumTask right = <span class="keyword">new</span> SumTask(src, mid + <span class="number">1</span>, toIndex);</span><br><span class="line">            <span class="comment">//提交到我们创建的 pool 中</span></span><br><span class="line">            invokeAll(left, right);</span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在重写的 compute 方法中，我们不断拆分任务，直至任务满足我们定义的阈值位置。计算量越大，中途 IO 操作越多 或者 休眠时间越多， ForkJoin 的优势越明显。如果只是少量数据，那么由于：</p>
<ol>
<li><p>ForkJoin 的递归调用</p>
</li>
<li><p>ForkJoin 多线程切换</p>
</li>
</ol>
<p>反而导致还没单线程那么快。但是当计算过程中有IO 操作或者休眠时间时，ForkJoin 在大量数据情况下的优势就会显示出来。我们注意上述代码中注释的代码 ： Thread.sleep(1); 如果在单线程计算和 ForkJoin 计算过程中都休眠 1ms ，后续导致的耗时差异是很大的，这个可以自行验证。</p>
<p>上面我们看了同步的操作，接下来看下如果进行异步操作，以下代码将根据指定的文件中，所有的 txt 文件，有可能文件下还有目录：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">        FindDirFiles task = <span class="keyword">new</span> FindDirFiles(<span class="keyword">new</span> File(<span class="string">"D:/"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步提交</span></span><br><span class="line">        pool.execute(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程做自己的事情</span></span><br><span class="line">        System.out.println(<span class="string">"Task isRuning"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"doing other works"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取结果，这是一个阻塞方法</span></span><br><span class="line">        task.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于上述join 是阻塞方法，所以一定得有结果之后，才会打印下面的 task end</span></span><br><span class="line">        System.out.println(<span class="string">"task end"</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>首先 main 方法中调用与上述的同步差不多，只不过在使用 execute 异步调用后，主线程的日志和子线程的日志同时在打，最后，我们会调用 task.join 阻塞方法，这也导致当所有文件遍历完成后，才会在main 线程中 输出最后的 task end 语句。我们看下 FindDirFiles 的实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindDirFiles</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> File path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FindDirFiles</span><span class="params">(File path)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>{</span><br><span class="line">        List&lt;FindDirFiles&gt; subTasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        File[] files = path.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">for</span> (File file : files) {</span><br><span class="line">                <span class="keyword">if</span> (file.isDirectory()) {</span><br><span class="line">                    <span class="comment">//对每个子目录新建一个子任务</span></span><br><span class="line">                    subTasks.add(<span class="keyword">new</span> FindDirFiles(file));</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">//遇到文件，检查</span></span><br><span class="line">                    <span class="keyword">if</span> (file.getAbsolutePath().endsWith(<span class="string">"txt"</span>)) {</span><br><span class="line">                        System.out.println(<span class="string">"文件："</span> + file.getAbsolutePath());</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!subTasks.isEmpty()) {</span><br><span class="line">                <span class="comment">//在当前的 ForkJoinPool 上调度所有的子任务</span></span><br><span class="line">                <span class="keyword">for</span> (FindDirFiles subTask : invokeAll(subTasks)) {</span><br><span class="line">                    subTask.join();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于不需要返回结果，所以我们继承 RecursiveAction 即可，在 compute 中，我们将为每个目录创建一个 Task 加入 list 中，最后一并 invokeAll 执行。</p>
<h2 id="三、CountDownLatch"><a href="#三、CountDownLatch" class="headerlink" title="三、CountDownLatch"></a>三、CountDownLatch</h2><p>它的作用是等待一个线程或者多个线程执行完成后再执行后续的操作。比如说要等所有的初始化工作（多个子线程）执行完成之后，才进入主线程执行。</p>
<p>对于 CountDownLatch 而言，计数器和线程数量是没关系的，有可能在同一个线程中做 2 个任务执行  2 次 countDown 操作。</p>
<p>线程做完 countDown 操作之后，能够继续执行，并不是说一定就要关闭之类的。</p>
<p>CountdownLatch 的 await 方法（即等待所有的扣减到 0 后才能执行的地方）可以在多个地方使用，比如同时在 主线程调用 countDownLatch.await() 以及在某个子线程中调用 countDownLatch.await() ，当 countDownLatch 计数器减为 0 的时候，主线程和那个子线程都会被唤醒接着执行。</p>
<h2 id="四、CyclicBarrier"><a href="#四、CyclicBarrier" class="headerlink" title="四、CyclicBarrier"></a>四、CyclicBarrier</h2><p>它的主要思想是，在某个点设置一个屏障， 比如 3 个线程，如果 A 线程先执行完成，它会 await 在那里等待；同样 B 线程也会这样，一直到 C 线程也执行完成，此时，3个线程才一起执行。它有 2 个主要构造方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parties 表示操控的线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以及：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中第二个 构造方法的 barrierAction 表示的是，当所有的操控的线程都执行到这个屏障的时候，此时优先执行一下这个 Rnnable ，之后三个线程才继续执行。这样做的一个好处就是：</p>
<p>举个例子吧，如果3 个线程计算一个任务的 3 个部分，这时候，我们可以用设置这个 Runnable 来合并这 3 部分结果，之后，这 3 个线程都拿着合并后的结果执行后面的操作。</p>
<h2 id="五、CountDownLatch-与-CyclicBarrier-的区别"><a href="#五、CountDownLatch-与-CyclicBarrier-的区别" class="headerlink" title="五、CountDownLatch 与  CyclicBarrier 的区别"></a>五、CountDownLatch 与  CyclicBarrier 的区别</h2><p>虽然二者在功能上很相似，但其实是有很大区别的，主要体现在：</p>
<ul>
<li><p>CountDownLatch 定义的数字只能扣减一次，CyclicBarrier 能多次调用 await ，后续的 await 还都能触发 barrierAction 的执行</p>
</li>
<li><p>CountDownLatch 用外部线程协调；而 CyclicBarrier 本身相互协调</p>
</li>
<li><p>CountDownLatch 扣减数和线程数不一样，比如一个线程可以 countdown 多次；但 CyclicBarrier 初始化时传入的 数量必须是管控的线程数量</p>
</li>
<li><p>这点没大听懂，大体是说 CountDownLatch 运行中不允许其他线程执行；而CyclicBarrier 可以通过 barrierAction 执行其他线程任务。<font color="#ff0000">还需要额外确认这点</font></p>
</li>
</ul>
<h2 id="六、Semaphore"><a href="#六、Semaphore" class="headerlink" title="六、Semaphore"></a>六、Semaphore</h2><p>主要用于<strong>流控</strong>的场景。比如，数据库最多只能有 10 个连接，那么我们可以通过 Semaphore 发放 10 个 <strong>许可证</strong>。在正常使用的时候通过 acquire 和 release  来控制获取和释放操作。还是看如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionImpl</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>{</span><br><span class="line">    。。。省略实现</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>{</span><br><span class="line">    <span class="comment">//许可证数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> POOL_SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2个新号指示器，分别表示 池子还有可用的连接 / 已用的连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore useful, uselessful;</span><br><span class="line">    <span class="comment">//存放资源的池子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="comment">//初始化放入资源</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) {</span><br><span class="line">            pool.addLast(<span class="keyword">new</span> ConnectionImpl());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SemaphoreDemo</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.useful = <span class="keyword">new</span> Semaphore(POOL_SIZE);</span><br><span class="line">        <span class="keyword">this</span>.uselessful = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归还连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnConnection</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"当前有"</span> + useful.getQueueLength() + <span class="string">"个线程等待连接，"</span></span><br><span class="line">                    + <span class="string">"可用连接数："</span> + useful.availablePermits());</span><br><span class="line">            <span class="comment">//通过 uselessful 的 acquire 来获取空位</span></span><br><span class="line">            <span class="keyword">synchronized</span> (pool) {</span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//许可证释放</span></span><br><span class="line">            useful.release();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">takeConnect</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//获取许可，如果没有许可可能阻塞</span></span><br><span class="line">        useful.acquire();</span><br><span class="line">        Connection connection;</span><br><span class="line">        <span class="comment">//拿到许可，为什么还需要同步？</span></span><br><span class="line">        <span class="comment">//这是因为如果有 4 个许可，那么可能同时有 4 个线程过来取值，所以，还需要对池子同步</span></span><br><span class="line">        <span class="keyword">synchronized</span> (pool) {</span><br><span class="line">            connection = pool.removeFirst();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//空位释放</span></span><br><span class="line">        uselessful.release();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来就是编写 Demo 使用：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusiThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SemaphoreDemo semaphoreDemo = <span class="keyword">new</span> SemaphoreDemo();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="comment">//随机，让每个线程持有的连接时间不一样</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Connection connection = semaphoreDemo.takeConnect();</span><br><span class="line">            System.out.println(<span class="string">"Thread_"</span> + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">"获取数据库连共耗时【"</span> + (System.currentTimeMillis() - start) + <span class="string">"】ms"</span>);</span><br><span class="line">            <span class="comment">//模拟业务操作</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span> + r.nextInt(<span class="number">100</span>));</span><br><span class="line">            System.out.println(<span class="string">"查询数据完成，归还连接"</span>);</span><br><span class="line">            semaphoreDemo.returnConnection(connection);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) {</span><br><span class="line">        Thread t = <span class="keyword">new</span> BusiThread();</span><br><span class="line">        t.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码会显示出前面 10 个线程几乎是 0ms 就获取到资源，而后续的会等待：</p>
<blockquote>
<p>Thread_Thread-1获取数据库连共耗时【0】ms<br>Thread_Thread-0获取数据库连共耗时【0】ms<br>Thread_Thread-2获取数据库连共耗时【0】ms<br>Thread_Thread-3获取数据库连共耗时【0】ms<br>Thread_Thread-4获取数据库连共耗时【0】ms<br>Thread_Thread-5获取数据库连共耗时【0】ms<br>Thread_Thread-6获取数据库连共耗时【0】ms<br>Thread_Thread-7获取数据库连共耗时【0】ms<br>Thread_Thread-8获取数据库连共耗时【0】ms<br>Thread_Thread-9获取数据库连共耗时【1】ms<br>查询数据完成，归还连接<br>当前有40个线程等待连接，可用连接数：0<br>Thread_Thread-10获取数据库连共耗时【113】ms<br>查询数据完成，归还连接<br>当前有39个线程等待连接，可用连接数：0<br>Thread_Thread-11获取数据库连共耗时【124】ms<br>查询数据完成，归还连接<br>当前有38个线程等待连接，可用连接数：0<br>Thread_Thread-12获取数据库连共耗时【141】ms</p>
<p>。。。省略一部分运行数据</p>
</blockquote>
<p>这里可能大家有个疑问，为什么需要定义 2 个 Semaphore： useful, uselessful。其中 前者是代表可用的许可，后者代表空位。为什么这么设计？还得从 Semaphore 的机制说起：即使没有调用 acquire ，而是直接调用 release ，这样也是可以的，<strong>可以在release 的时候传入一个 new 出来的Connection 对象 ！！！</strong>，假如出现这种情况的话，我们的许可证会越来越多，而不是我们初衷的限制了。</p>
<p>acquire 只是做流控，但是不能做同步操作，比如，它有 4 个许可证，意味着可以允许 4 个线程同时去取资源，这时候我们还是需要对存储资源的池子做同步的。 所以，我们上述的代码 takeConnect() 方法中，在 acquire 之后，还需要 synchronized (pool) 操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">takeConnect</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">//获取许可，如果没有许可可能阻塞</span></span><br><span class="line">    useful.acquire();</span><br><span class="line">    <span class="comment">//省略无关代码。。。</span></span><br><span class="line">    <span class="keyword">synchronized</span> (pool) {</span><br><span class="line">        connection = pool.removeFirst();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//省略无关代码。。。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="七、Exchange"><a href="#七、Exchange" class="headerlink" title="七、Exchange"></a>七、Exchange</h2><p>Exchange 的使用场景很少。它的含义是：两个线程 A 和 B，在某一位置设定一个点，当某个先执行完了，就会等待另一个线程。当 2 个线程都执行到这个点时，二者交换数据，然后接着继续执行，没错，只是交换数据。</p>
<h2 id="八、Callable-、Task"><a href="#八、Callable-、Task" class="headerlink" title="八、Callable 、Task"></a>八、Callable 、Task</h2><p>我们前面说了开启一个线程有 2 种方式：new Thread 和 new Runnable 。但是，由于 Runnable 类的 run 方法是 void 类型的，没有返回值：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因此 Java 中给准备了 Callable 这样的类，让方法有返回值：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于Thread 中只能接收 Runnable 参数，因此 Callable 不能直接传入使用，因此就有了 Task 这种类型，可能课程中的这张图更形象一点：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/Runnable%E5%92%8CCallable%E5%92%8CFuture.png" alt="Runnable和Callable和Future"></p>
<p>关于 Callable 的使用，我们可以参考下面的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            System.out.println(<span class="string">"Callable 子线程开始计算"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5000</span>;i++) {</span><br><span class="line">                sum += i;</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"Callable 子线程计算结束，结果："</span> + sum);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">        UseCallable useCallable = <span class="keyword">new</span> UseCallable();</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(useCallable);</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        System.out.println(<span class="string">"main 方法中获取结果："</span> + task.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不过，需要注意的是，我们如果想取消 Task ，可以直接调用 task.cancel(true); ，其中传入的 true 是中断线程的标志，前面章节有说我们不建议使用 volatile 类型的变量去停止线程，还是希望使用 interrupt 去停止。所以，我们光调用 task.cancel(true);还不行，还得在线程中配合中断操作，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5000</span>;i++) {</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//删除无关代码</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/04/20/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(09-1)%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/20/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/java%E7%AD%91%E5%9F%BA/Java%E7%AD%91%E5%9F%BA-%EF%BC%9A(09-1)%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8-1/" class="post-title-link" itemprop="url">Java筑基-：(09-1)线程基本使用入门-1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-20 22:01:00" itemprop="dateCreated datePublished" datetime="2023-04-20T22:01:00+08:00">2023-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-17 22:38:20" itemprop="dateModified" datetime="2023-05-17T22:38:20+08:00">2023-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、错误加锁的问题"><a href="#一、错误加锁的问题" class="headerlink" title="一、错误加锁的问题"></a>一、错误加锁的问题</h2><p>Java 的 Object 类中有 hashCode() 方法，它是用对象在内存中的地址来产生这个哈希值，当然，我们可以重写 hashCode() 方法。如果在重写了 hashCode() 方法之后还想获取到这个由内存中地址产生的哈希值，可以使用 identityHashCode() 方法。</p>
<p>在使用 synchronized 关键字去做同步的时候，要确保 synchronized 里面的对象是同一个对象，否则会达不到效果，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Work work = <span class="keyword">new</span> Work(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        <span class="keyword">new</span> Thread(work).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    Integer i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(Integer integer)</span> </span>{</span><br><span class="line">        i = integer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (i) {</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(<span class="string">"当前 i = "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>本来预期输出 2~6 的值，但是这段代码输出的数字是不可控的。这是为什么呢？问题就在 i ++ 上， 反编译可以看到， i ++ 之后就会生成新的 Integer 对象，这样一来，导致后续的程序获取的 Integer 就不是同一个对象了。</p>
<blockquote>
<p>改进方法可以是自己创建一个 Object obj = new Object() ；因为这个对象不会改变，所以我们可以用它来作为锁对象。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) {</span><br><span class="line">            <span class="comment">//省略代码。。。</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="二、volatile-关键字"><a href="#二、volatile-关键字" class="headerlink" title="二、volatile 关键字"></a>二、volatile 关键字</h2><p>比较简单，略</p>
<h2 id="三、ThreadLocal-使用"><a href="#三、ThreadLocal-使用" class="headerlink" title="三、ThreadLocal 使用"></a>三、ThreadLocal 使用</h2><p>Spring 在事务中用到了 ThreadLocal ，为什么要这么做？这是因为我们想要为每个线程保存自己的数据库 connection （连接）。这样比较容易控制事务的边界。</p>
<p>关于 ThreadLocal 需要注意的有 2 点：</p>
<ul>
<li><p>ThreadLocal 能够给初始值</p>
</li>
<li><p>每个线程单独操作自己的线程中的ThreadLocalMap ，所以压根不会有冲突</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal 给初始值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; num = <span class="keyword">new</span> ThreadLocal&lt;&gt;(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="四、ThreadLocal-的实现"><a href="#四、ThreadLocal-的实现" class="headerlink" title="四、ThreadLocal 的实现"></a>四、ThreadLocal 的实现</h2><p>如果要理解 ThreadLocal 的原理，就从它最简单的 get() 方法开始看(以下代码是基于我本地的 JDK 20 ，不过和前面版本相差也不太大)：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//Thread.currentThread() 表示当前线程</span></span><br><span class="line">    <span class="keyword">return</span> get(Thread.currentThread());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">get</span><span class="params">(Thread t)</span> </span>{</span><br><span class="line">    <span class="comment">//根据当前线程，获得 ThreadLocalMap 对象</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//。。。 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里getEntry 传入了 this ，也就是以 ThreadLocal 本身为 key</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">    T result = (T) e.value;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>也就是说，首先根据当前线程的 thread 对象 获得 ThreadLocalMap 对象 map ，之后，以ThreadLocal 自身（那个this） 为 key ，从 map 中取出 value ，这个 value 就是我们想要的值了，来看下 getMap 的实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里直接返回了 Thread.threadLocals，这意味着 ThreadLocalMap 类型的 map 是 Thread 的成员变量 ！那就没什么好说的了，每个 thread 对象自己都有这么个成员变量，每次操作的时候都是对线程对象 thread 自己的 ThreadLocalMap 类型的成员变量 threadLocals 进行操作，当然不会有线程问题了。</p>
<p>这里还有个问题需要澄清，就是如果定义了多个 ThreadLocal 对象 threadLocal1、threadLocal2… ，那么又是怎么保存的呢？我们来看下 ThreadLocal 的内部类 ThreadLocalMap 就知道了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="comment">// 。。。 省略无关代码</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>{</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>{</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//The initial capacity -- MUST be a power of two.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ThreadLocal.ThreadLocalMap.Entry[] table;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 。。。 省略无关代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ThreadLocal 中有个 ThreadLocalMap 类，并且 ThreadLocalMap 中有个 Entry [] 数组类型的 table ，用来存放所有的 Entry 。</p>
<blockquote>
<p>这里有个细节， Entry [] 数组的初始大小是16，并且官方建议这个值应该是 2^n 这样的值</p>
</blockquote>
<p>上面看到 ThreadLocal 的 get() 方法最终会调用 ThreadLocalMap 的 getEntry 方法，看ThreadLocalMap.getEntry 应该更能理解：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ThreadLocalMap 类</span><br><span class="line"><span class="keyword">private</span> ThreadLocal.ThreadLocalMap.<span class="function">Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>{</span><br><span class="line">    <span class="comment">//根据 key 获取 在数组 table 中的index </span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//根据 index 获取 table[index]</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry e = table[i];</span><br><span class="line">    <span class="comment">//处理可能的 hash 冲突和空值</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.refersTo(key))</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看了 get() 方法之后，ThreadLocal 的 set 的逻辑应该也能很容易理解了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># java.lang.<span class="function">ThreadLocal </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>{</span><br><span class="line">        <span class="comment">//将当前线程传过去</span></span><br><span class="line">        set(Thread.currentThread(), value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Thread t, T value)</span> </span>{</span><br><span class="line">        <span class="comment">//根据当前线程获取它的 ThreadLocalMap 对象</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//。。。省略无关代码</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//ThreadLocalMap 对象不空，调用其 set 方法，以ThreadLocal 本身作为 key</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//如果 ThreadLocalMap 对象还是空的，就创建个</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>最后调用到 ThreadLocalMap 的 set 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>{</span><br><span class="line">    <span class="comment">//前面说的 Entry[] 数组</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">    <span class="comment">//通过某种方式获取到即将插在数组中的位置 i</span></span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略无关代码。。。</span></span><br><span class="line">    <span class="comment">//可能位置 i 会有冲突，就 nextIndex，也有可能直接覆盖之前的值</span></span><br><span class="line">    <span class="comment">//nextIndex 其实就是 + 1 操作，如果超出了数组长度，就又从 0 开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Entry 对象，存入value，然后放入 tab[i] 中</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略无关代码。。。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>就是经过某种方法计算出在数组中的位置 i （可能会有位置冲突，就需要重新计算，或者之前有设置过了，就需要覆盖），然后创建 Entry 实体，存入 table[i] 中。</p>
<p>经过以上代码就整个流程能够串起来了：</p>
<ol>
<li><p>ThreadLocalMap 是 ThreadLocal 的内部类，ThreadLocalMap 中有一个 Entry[] 数组，用于存放（该线程）所有使用 ThreadLocal 存放的值（以 ThreadLocal 对象本身为key ，得出 index， 再根据 index 从 Entry 数组中取值）</p>
</li>
<li><p>每个线程对象 thread 都有一个 ThreadLocalMap 对象 threadLocals</p>
</li>
<li><p>当创建一个 ThreadLocal 对象，调用其 set 方法时，首先检测当前线程是否存在threadLocals，不存在就创建</p>
</li>
<li><p>然后以 ThreadLocal 对象本身为 key ，设置的值为 value ，存入ThreadLocalMap 中的 Entry[] 数组中（会有冲突处理过程）</p>
</li>
<li><p>当从某个线程中 get 某个 ThreadLocal 对象的值时，首先获取到该线程，然后取其 threadLocals 对象</p>
</li>
<li><p>之后以 ThreadLocal 对象本身作为 key ，调用 threadLocals 对象的 getEntry 方法</p>
</li>
<li><p>根据 key 计算该 Entry 在 table 数组中可能的位置 index ，这个 index 可能会冲突， 如果冲突了就会做前面说的 nextIndex 操作（其实就是 + 1 操作，如果超出了数组长度，就又从 0 开始），重新获取新的 index 再次尝试</p>
</li>
<li><p>最后，通过获取的 index 从 Entry[] 数组类型的变量 table 中获取 Entry： Entry entry = table[index]</p>
</li>
</ol>
<h2 id="五、ThreadLocal-可能造成内存泄漏"><a href="#五、ThreadLocal-可能造成内存泄漏" class="headerlink" title="五、ThreadLocal 可能造成内存泄漏"></a>五、ThreadLocal 可能造成内存泄漏</h2><p>ThreadLocal 用不好会造成内存泄露。</p>
<p>在使用完后，需要调用remove方法将其Entry移除，否则会导致内存泄露，直到线程对象 thread 被销毁才能被回收。首先看下 ThreadLocal 的原理图 ：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/01-java%E7%AD%91%E5%9F%BA/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ThreadLocal内存泄漏示意图"></p>
<p>结合源码我们知道，Entry类是继承WeakReference的，当 ThreadLocal 对象没有被引用之后，可能就被回收了，所以 Entry 中的key就成为了 null ，不可能再被使用到了。</p>
<p>但是，由于我们没有调用 remove 方法（事实上，get和set方法调用过程也可能触发清理 key 为 null 的 Entry），这个 Entry 实例还是存在的，虽然 key 没有了，value 还是在的，所以造成了泄露。</p>
<blockquote>
<p>在ThreadLocal 新增或者删除一个元素的时候，会触发这种 key 为 null 的 Entry 扫描操作，这也是不断添加 ThreadLocal 对象并不断移除这些 ThreadLocal 对象时查看内存变化会维持在一个不高不低的阶段的原因。</p>
</blockquote>
<h2 id="六、ThreadLocal-可能引发线程不安全"><a href="#六、ThreadLocal-可能引发线程不安全" class="headerlink" title="六、ThreadLocal 可能引发线程不安全"></a>六、ThreadLocal 可能引发线程不安全</h2><p>当 ThreadLocal 中使用的是一个静态变量时，可能产生线程不安全的情况，因为各个线程大家的value都是指向同一份引用，比如如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUnsafe</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Number number = <span class="keyword">new</span> Number(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        number.value = number.value + <span class="number">1</span>;</span><br><span class="line">        threadLocal.set(number);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"中 integer 的值 为："</span> + threadLocal.get().value);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Number&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">5</span>;i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadLocalUnsafe()).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>{</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Number</span><span class="params">(<span class="keyword">int</span> num)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>.value = num;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在我运行后，输出全部是 5 ：</p>
<blockquote>
<p>Thread-4中 integer 的值 为：5<br>Thread-0中 integer 的值 为：5<br>Thread-3中 integer 的值 为：5<br>Thread-2中 integer 的值 为：5<br>Thread-1中 integer 的值 为：5</p>
</blockquote>
<p>一般来说，number 初始值是 0 ，每个线程给它 + 1 操作后存入 ThreadLocal 中，后续通过 threadLocal 取出来的时候值应该不一样才对，但是我们看到的是各个线程的值都是一样的。这是因为 ThreadLocal 在存入 value 的时候，存入的都是 number 这同一个对象，所以只要一处改了，就到处都改了，这种情况要注意。</p>
<h2 id="七、线程配合"><a href="#七、线程配合" class="headerlink" title="七、线程配合"></a>七、线程配合</h2><p>wait 和 notify 都要在同步代码块中使用，他们有标准的使用范式，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wait 过程</span></span><br><span class="line"><span class="keyword">synchronized</span> (对象) {</span><br><span class="line">    <span class="keyword">while</span> (条件不满足) {</span><br><span class="line">        对象.wait();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//业务逻辑</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//notify 过程</span></span><br><span class="line"><span class="keyword">synchronized</span> (对象) {</span><br><span class="line">    <span class="comment">//业务逻辑改变条件</span></span><br><span class="line">    对象.notifyAll();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>wait在休眠之前就会释放锁，而notify 与notifyAll不会，他调用了之后，还要等同步区间执行完了，才释放锁。</p>
<p>范式中间为什么要用while循环而不是if判断条件？</p>
<blockquote>
<p>如果对象执行 notifyAll ，那么很多线程都会被唤醒，比如是 5 个线程在等待打印机，当某个线程打印完成 notifyAll 的时候，这 5 个线程都被唤醒，由于是使用 if 语句判断的，唤醒之后直接执行后续的代码了，即业务逻辑（打印）了，此时就会出问题。但是如果是while 循环的话，唤醒之后还会判断条件是否满足（打印机是否被别人占了），这样逻辑才正确。</p>
</blockquote>
<h2 id="八、等待超时处理"><a href="#八、等待超时处理" class="headerlink" title="八、等待超时处理"></a>八、等待超时处理</h2><p>线程等待超时处理，比如使用池化技术的时候，我们去从 pool 中获取资源，但是会有超时提醒，这时候就能用 wait/notify 去做这样的事情。视频中的例子主要需要注意 remain 时长计算，因为唤醒一次就要重新计算等待时长，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (pool) {</span><br><span class="line">        <span class="keyword">if</span> (mills &lt; <span class="number">0</span>) {<span class="comment">//永不超时</span></span><br><span class="line">            <span class="keyword">while</span>(pool.isEmpty()) {</span><br><span class="line">                wait();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> pool.removeFirst();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//超时时刻</span></span><br><span class="line">            <span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">            <span class="comment">//等待时长</span></span><br><span class="line">            <span class="keyword">long</span> remain = mills;</span><br><span class="line">            <span class="keyword">while</span>(pool.isEmpty() &amp;&amp; remain &gt; <span class="number">0</span>) {</span><br><span class="line">                wait(remain);</span><br><span class="line">                <span class="comment">//重新计算等待时长</span></span><br><span class="line">                remain = future - System.currentTimeMillis();</span><br><span class="line">            }</span><br><span class="line">            Connection connection = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!pool.isEmpty()) {</span><br><span class="line">                connection = pool.removeFirst();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> connection;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>为什么需要重新计算？因为唤醒后可能抢不到锁，还会在while中接着等待。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">211</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共394.1k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/5/',]
      });
      });
  </script>


</body>
</html>
