<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.2">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.2" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.2">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta name="keywords" content="glassx,码农">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https:&#x2F;&#x2F;glassx.gitee.io&#x2F;page&#x2F;5&#x2F;index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.gitee.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">57</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/22/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%85%AB%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/22/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%85%AB%E7%AB%A0/" class="post-title-link" itemprop="url">第8章：丰富你的程序-使用手机多媒体</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-22 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-22T08:00:00+08:00">2018-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-05-01 16:44:22" itemprop="dateModified" datetime="2019-05-01T16:44:22+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="使用通知"><a href="#使用通知" class="headerlink" title="使用通知"></a>使用通知</h2><p>我们可以在Activity中、BroadcastReceiver以及Service中创建通知，不论在哪里创建，整体步骤是相同的，下面通过示例演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、需要NotificationManager管理通知，通过调用Context的getSystemService方法获得</span></span><br><span class="line">NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、创建一个延迟意图（PendingIntent），标明点击notification时的响应，这里可以启动Activity，Broadcast以及service等</span></span><br><span class="line"><span class="comment">//PendingIntent有点类似于Intent，不过前者倾向于在某个合适的时机去执行某个动作，而后者倾向于立即执行某个动作</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line"><span class="comment">//根据启动的对象（Activity、Broadcast或service），可以使用getActivity()/getBroadcast()/getService()</span></span><br><span class="line">PendingIntent pi = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,intent,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、通过Builder构造器创建Notification对象，几乎Android每个版本都会对通知这部分进行修改，因此我们需要使用</span></span><br><span class="line"><span class="comment">//support-v4包提供的NotificationCompat类来兼容性地实现，保证在各个版本上都能正常使用通知</span></span><br><span class="line">Notification notification = <span class="keyword">new</span> NotificationCompat.Builder(context)</span><br><span class="line">			.setContentTitle(<span class="string">"title"</span>)</span><br><span class="line">			.setContentText(<span class="string">"content"</span>)</span><br><span class="line">			.setSound(Uri.from(<span class="string">""</span>))<span class="comment">//控制通知的声音</span></span><br><span class="line">			<span class="comment">//设置通知来的时候震动，数组中的值为时长，单位为毫秒，下标0表示手机静止时长，下标1为手机震动时长，下标2为手机静止</span></span><br><span class="line">			<span class="comment">//时长，以此类推，这就实现了通知来时立刻震动1秒，静止1秒，再震动1秒</span></span><br><span class="line">			<span class="comment">//注意震动需要权限 &lt;uses-permission android:name="android.permission.VIBRATE"&gt;</span></span><br><span class="line">			.setVibrate(<span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">0</span>,<span class="number">1000</span>,<span class="number">1000</span>,<span class="number">1000</span>&#125;)</span><br><span class="line">			.setWhen(System.currentMillis())<span class="comment">//指定通知被创建的时间，下拉时这个时间会显示在通知上</span></span><br><span class="line">			.setSmallIcon(R.drawable.small_icon)<span class="comment">//显示在顶部状态栏上的图标</span></span><br><span class="line">			.setLargeIcon(BitmapFactory.decodeResource(gerResources(),R.drawable.large_icon))<span class="comment">//下拉时显示在通知左边</span></span><br><span class="line">			.setContentIntent(pi)<span class="comment">//指明点击之后的意图</span></span><br><span class="line">			<span class="comment">//通知自动消失,第二种取消方式是，将notification的id传入SecondActivity中，在进入到SecondActivity后，在SecondActivity</span></span><br><span class="line">			<span class="comment">//的onCreate方法中重新获取manager，并且关闭这个通知：</span></span><br><span class="line">			<span class="comment">//NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);  manager.cancel(id);</span></span><br><span class="line">			.setLights(Color.GREEN,<span class="number">1000</span>,<span class="number">1000</span>)<span class="comment">//设置灯光绿色和一闪一闪的效果</span></span><br><span class="line">			.setAutoCancel(<span class="keyword">true</span>)</span><br><span class="line">			<span class="comment">//设置style，一般通知只会显示很短的内容文字，但如果真的非常需要长文字，也是支持的，这样设置style，如果要显示一张大图片，</span></span><br><span class="line">			<span class="comment">//以下换成NotificationCompat.BigTextStyle().bigPicture(bitmap)即可</span></span><br><span class="line">			.setStyle(<span class="keyword">new</span> NotificationCompat.BigTextStyle().bigText(<span class="string">"fdasfdsafdsafdafdasfsdafadsfdsfasdffasdfdsfdsfsda"</span>))</span><br><span class="line">			<span class="comment">//设置通知优先级，如果设置为最高的话，即要求用户立刻看，不会像普通通知只在状态栏显示一个图标，而是弹出一个横幅</span></span><br><span class="line">			<span class="comment">//不论你当前在玩游戏还是看电影，这个横幅都会弹</span></span><br><span class="line">			.setPriority(NotificationCompat.PRIORITY_MAX)</span><br><span class="line">			.build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、发出通知</span></span><br><span class="line">manager.notify(<span class="number">1</span>,notification);<span class="comment">//第一个参数指定notification的id</span></span><br></pre></td></tr></table></figure>


<h2 id="调用摄像头和相册"><a href="#调用摄像头和相册" class="headerlink" title="调用摄像头和相册"></a>调用摄像头和相册</h2><p>平时使用QQ或者微信的时候经常要别人分享图片，这些图片可以使手机摄像头拍摄也可以从相册中选取，这种功能非常普遍。</p>
<h3 id="摄像头拍照"><a href="#摄像头拍照" class="headerlink" title="摄像头拍照"></a>摄像头拍照</h3><p>直接上代码展示可能更加清晰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">takePhoto.setOnclickListener(<span class="keyword">new</span> View.OnclickListener()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建File对象，用于存储拍照后的图片</span></span><br><span class="line">		File outputImage = <span class="keyword">new</span> File(getExternalCacheDir(),<span class="string">"output.jpg"</span>);</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(outputImage.exists())&#123;<span class="comment">//存在了</span></span><br><span class="line">				outputImage.delete();</span><br><span class="line">			&#125;</span><br><span class="line">			outputImage.createNewFile();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= <span class="number">24</span>)&#123;</span><br><span class="line">			imageUri = FileProvider.getUriForFile(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">				<span class="string">"com.example.fileprovider"</span>,outputImage);</span><br><span class="line"></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			imageUri = Uri.fromFile(outputImage);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//启动相机</span></span><br><span class="line">		Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.media.action.IMAGE_CAPTURE"</span>);</span><br><span class="line">		intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);</span><br><span class="line">		startActivityForResult(intent,TAKE_PHOTO);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode,<span class="keyword">int</span> resultCode,Intent data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(requestCode)&#123;</span><br><span class="line">		<span class="keyword">case</span> TAKE_PHOTO:</span><br><span class="line">			<span class="keyword">if</span>(resultCode == RESULT_OK)&#123;</span><br><span class="line">				<span class="keyword">try</span>&#123;</span><br><span class="line">					<span class="comment">//将拍摄的照片显示出来</span></span><br><span class="line">					Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver()</span><br><span class="line">						.openInputStream(imageUri));</span><br><span class="line">					ivPic.setImageBitmap(bitmap);</span><br><span class="line">				&#125;<span class="keyword">catch</span> (FileNotFoundException e)&#123;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们用了内容提供器，因此还需要在AndroidManifest.xml中声明这个提供器(<strong>有一点要注意的是,在4.4以前（4.4及以后不需要）访问SD卡得应用关联目录也是要声明权限的，为了兼容老版本的手机，需要声明 WRITE_EXTERNAL_STORAGE 权限</strong>)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">users-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">...</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">privider</span></span></span><br><span class="line">		&lt;!--这里，android:name属性的值是固定的，android:authorities属性的值必须要和刚才FileProvider.getUriForFile()--&gt;</span><br><span class="line">		<span class="comment">&lt;!--方法中的第二个参数一致，另外，meta-data中用resource指定了Uri的共享路径--&gt;</span></span><br><span class="line">		android:name="android.support.v4.content.FileProvider"</span><br><span class="line">		android:authorities="com.example.fileprovider"</span><br><span class="line">		android:exported="false"</span><br><span class="line">		android:grantUriPermissions="true"&gt;</span><br><span class="line">		<span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，provider声明中使用了@xml/file_paths资源，这个资源我们还没创建，因此在res目录下可以创建这么个xml，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"&gt;</span></span><br><span class="line"><span class="meta">&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt;</span></span><br><span class="line"><span class="meta">	&lt;!--这里面external-path指定Uri共享的，name属性随便填，path属性表示共享的具体路径，这里设置空值就表示将整个SD卡进行共享--&gt;</span></span><br><span class="line"><span class="meta">	&lt;!--当然，你可以仅仅共享我们存放output.jpg这张图片的路径--&gt;</span></span><br><span class="line"><span class="meta">	&lt;external-path name="my_images" path=""&gt;</span></span><br><span class="line"><span class="meta">&lt;/paths&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上整个代码首先创建了一个File对象，用于存放摄像头拍下的图片，我们将其命名为output.jpg，并将它存放在手机SD卡的应用关联缓存目录（指SD卡中专门用于存放当前应用缓存数据的位置，路径为/sdcard/Android/data/<package name>/cache，调用getExternalCacheDir()方法就可以得到这个目录）下。<strong>为什么使用应用关联缓存目录来存放图片呢？因为从Android 6.0开始，读写SD卡被列为危险权限，如果将图片存放SD卡得任何其他目录，都要进行运行时权限处理才行，而使用应用关联目录则可以跳过这一步</strong>。  </p>
<p>接着会判断如果设备版本低于7.0，就调用Uri.fromFile()方法将File对象转换为Uri对象，这个Uri标识着图片的本地真实路径。否则就调用FileProvider的getUriForFile()方法获得Uri对象。之所以这样是因为从7.0开始，直接使用本地真实路径的Uri被认为是不安全的，会抛出异常，而FileProvider则是一种特殊的内容提供器，可以选择性地将封装过的Uri共享给外部，提高应用安全性。  </p>
<p>最后就是启动摄像头拍照并且回调获取图片了。</p>
<h3 id="从相册中选择照片"><a href="#从相册中选择照片" class="headerlink" title="从相册中选择照片"></a>从相册中选择照片</h3><p>直接选取一张现有图片比打开相机拍一张照片更加常用，一个优秀的应用应该将这两种方式都提供给用户。废话不多说直接上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">chooseFromAlbum.setOnclickListener(<span class="keyword">new</span> View.OnclickListener()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(ContextCompat.checkSelfPermission(MainActivity.<span class="keyword">this</span>,Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line"></span><br><span class="line">			ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>,<span class="keyword">new</span> String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			openAlbum();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openAlbum</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.intent.action.GET_CONTENT"</span>);</span><br><span class="line">	intent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">	startActivityForResult(intent,CHOOSE_PHOTO);<span class="comment">//打开相册</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode,String[] permissions,<span class="keyword">int</span>[] grantResults)</span></span>&#123;</span><br><span class="line">	swithc(requestCode)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">if</span>(grantResults.lenght &gt; <span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">				openAlbum();</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				Toast.makeText(<span class="keyword">this</span>,<span class="string">"you denied the permission"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode,<span class="keyword">int</span> resultCode,Intent data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(requestCode)&#123;</span><br><span class="line">		<span class="keyword">case</span> CHOOSE_PHOTO:</span><br><span class="line">			<span class="keyword">if</span>(resultCode == RESULT_OK)&#123;</span><br><span class="line">				<span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= <span class="number">19</span>)&#123;<span class="comment">//4.4及以上</span></span><br><span class="line">					handleImageOnKitKat(data);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;<span class="comment">//4.4以下</span></span><br><span class="line">					handleImageBeforeKitKat(data);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.4及以上处理方式</span></span><br><span class="line"><span class="meta">@TargetApi</span>(<span class="number">19</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleImageOnKitKat</span><span class="params">(Intent data)</span></span>&#123;</span><br><span class="line">	String imagePath = <span class="keyword">null</span>;</span><br><span class="line">	Uri uri = data.getData();</span><br><span class="line">	<span class="comment">//如果是document类型Uri，则通过document id处理</span></span><br><span class="line">	<span class="keyword">if</span>(DocumentsContract.isDocumentUri(<span class="keyword">this</span>,uri))&#123;</span><br><span class="line">		String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">"com.android.providers.media.documents"</span>.equals(uri.getAuthority())&#123;</span><br><span class="line">			<span class="comment">//解析出数字格式的id</span></span><br><span class="line">			String selection = MediaStore.Images.Media._ID + <span class="string">"="</span> + id;</span><br><span class="line">			imagePath = getImagePaht(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,selection);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"com.android.providers.downloads.documents"</span>.equals(uri.getAuthority()))&#123;</span><br><span class="line">			Uri contentUri = ContentUris.withAppendedId(Uri.parse(<span class="string">"content://downloads/public_downloads"</span>),Long.valueOf(docId));</span><br><span class="line">			imagePath = getImagePath(contentUri,<span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"content"</span>.equalsIgnoreCase(uri.getScheme()))&#123;<span class="comment">//如果是content类型的uri，则使用普通方式处理</span></span><br><span class="line">		imagePath = getImagePath(uri,<span class="keyword">null</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"file"</span>.eualsIgnoreCase(uri.getScheme()))&#123;<span class="comment">//如果是file类型的uri，直接获取推按路径即可</span></span><br><span class="line">		imagePath = uri.getPath();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据路径显示图片</span></span><br><span class="line">	displayImage(imagePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.4以前处理方式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleImageBeforeKitKat</span><span class="params">(Intent data)</span></span>&#123;</span><br><span class="line">	Uri uri = data.getData();</span><br><span class="line">	<span class="comment">//因为他的Uri没有封装过的，不需要任何解析直接去获取真实路径即可</span></span><br><span class="line">	String imagePath = getImagePath(uri,<span class="keyword">null</span>);</span><br><span class="line">	displayImage(imagePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Uri和selection来获取真实的图片路径</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getImagePath</span><span class="params">(Uri uri,String selection)</span></span>&#123;</span><br><span class="line">	String path = <span class="keyword">null</span>;</span><br><span class="line">	Cursor cursor = getContentResolver().query(uri,<span class="keyword">null</span>,selection,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">if</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(cursor.moveToFirst())&#123;</span><br><span class="line">			path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));</span><br><span class="line">		&#125;</span><br><span class="line">		cursor.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据路径显示图片</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String imagePath)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(imagePath != <span class="keyword">null</span>)&#123;</span><br><span class="line">		Bitmap bitmap  = BitmapFactory.decodeFile(imagePath);</span><br><span class="line">		ivPicture.setImageBitmap(bitmap);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		Toast.makeText(<span class="keyword">this</span>,<span class="string">"failed to get image"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>因为照片是存在SD卡上的，所以我们首先进行权限处理，WRITE_EXTERNAL_STORAGE表示授予了对SD卡的读和写的能力。在onActivityResult回调中针对不同版本使用不同方式处理图片，因为从4.4开始，选取相册中的图片不再返回真实的Uri了，而是一个封装过的Uri，因此必须对这个Uri解析才行，在handleImageOnKitKat()方法中，如果返回的Uri是document类型的话，就取出document id进行处理，如果Uri的authority是media格式的话，document id还需要进行一次解析，要通过字符串分割的方式取出后半部分才能得到真正的数字id。</p>
<h2 id="播放多媒体文件"><a href="#播放多媒体文件" class="headerlink" title="播放多媒体文件"></a>播放多媒体文件</h2><p>播放音频和视频比较简单，没有兼容性等复杂问题，仅仅只需要记住：</p>
<ol>
<li><p>申请 WRITE_EXTENAL_STORAGE 权限</p>
</li>
<li><p>使用 MediaPlayer 播放音频结束时，在 onDestroy方法中要进行 MediaPlayer.stop() 和 MediaPlayer.release() ，将资源释放掉;</p>
</li>
<li><p>使用 VideoView 播放视频结束时，在 onDestroy方法中要进行 VideoView.suspend() ，将资源释放掉;</p>
</li>
</ol>
<p>其他内容略过。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/21/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%83%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/21/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%83%E7%AB%A0/" class="post-title-link" itemprop="url">第7章： 数据存储全方案——跨程序共享数据：探究内容提供器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-21 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-21T08:00:00+08:00">2018-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-05-01 16:43:42" itemprop="dateModified" datetime="2019-05-01T16:43:42+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>可能你会有些疑惑，为什么要将我们程序中的数据共享给其他程序呢？当然，这是视情况而定的，比如账号密码之类的隐私数据显然是不能共享给其他程序的，不过一些可以让其他程序进行二次开发的基础性数据，我们还是可以选择共享。例如联系人程序、短信程序、多媒体库等，它们的数据库中保存了很多基础数据，如果不允许其他应用进行访问，则方便性就会大打折扣。</p>
<h3 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h3><p>Android的权限机制在一开始就存在，但是在6.0以前保护隐私方面比较有限，因为像微信这种大家都离不开的软件，容易“店大欺客”，不同意它所有的权限只能不安装，这并不合理。</p>
<h4 id="权限机制详解"><a href="#权限机制详解" class="headerlink" title="权限机制详解"></a>权限机制详解</h4><p>开发者在AndroidManifest.xml中声明权限，一种情况是，用户如果在低于6.0的系统上安装该程序，会在安装时列出该应用所需要的权限，从而决定是否要安装这个程序，并且在用户安装成功之后，还能在<strong>设置</strong>中查看程序所申请的权限，但是对于那些离不开的程序（比如微信）来说，要么全部同意它申请的权限，要么不安装，这不太合理；如果在6.0及以上的系统中安装，则用户不必在安装时一次性授权所有申请的权限，而是在软件使用的过程中再对<strong>危险权限</strong>进行授权，就算拒绝了这个权限，仍然可以使用应用的其他功能，而不是以前那样直接无法安装。</p>
<p>Android 6.0 及以上将所有权限分为两类，<strong>普通权限和危险权限</strong>，普通权限是指不会直接威胁用户的安全和隐私的权限，这部分权限系统自动帮我们授权，避免用户不停地手动授权；危险权限则表示会触及用户隐私或者设备安全性的权限，如获取联系人、定位设备位置等，必须由程序员动态申请，由用户手动点击授权才可以，否则无法使用相应功能。目前为止，Android中的危险权限有9组共24个权限，如下列表所示（图片来自<a href="https://developer.android.google.cn/guide/topics/security/permissions#normal-dangerous" target="_blank" rel="noopener">官网</a>）：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-7/%E5%9B%BE1.png" alt="危险权限列表"></p>
<p>这张表格无需记住，在使用的时候作为参照，如果权限在这张表中，则进行运行时处理就好。<strong>另外注意一下，表格中每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权了，那么该权限对应的权限组中所有的其他权限也会同时被授权</strong>。</p>
<h3 id="在程序运行时申请权限"><a href="#在程序运行时申请权限" class="headerlink" title="在程序运行时申请权限"></a>在程序运行时申请权限</h3><p>以拨打电话的权限为例来说明权限的申请，点击一个按钮，就拨打指定的号码，在6.0以前可能是这样实现的：</p>
<ol>
<li>在AndroidManifest.xml中申请权限：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CALL_PHONE"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>在代码中实现：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">btnCall.setOnclickListener(<span class="keyword">new</span> View.OnclickListener()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">		Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CALL);</span><br><span class="line">		intent.setData(Uri.parse(<span class="string">"tel:10086"</span>));</span><br><span class="line">		startActivity(Intent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在6.0以下系统上能正常拨打电话，但是在6.0或者以上系统运行，会报错<strong>Permission Denial</strong>，可以看出是由于权限被禁止导致的，因此我们应该尝试使用以下方式来申请权限：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">btnCall.setOnclickListener(<span class="keyword">new</span> View.OnclickListener()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(ContextCompat.checkSelfPermission(MainActivity.<span class="keyword">this</span>,Manifest.permission.CALL_PHONE) !=   </span><br><span class="line">		PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">			ActivityCompat.requestPermission(MainActivity.<span class="keyword">this</span>,<span class="keyword">new</span> </span><br><span class="line">			String[]&#123;Manifest.permission.CALL_PHONE&#125;,<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			call();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CALL);</span><br><span class="line">	intent.setData(Uri.parse(<span class="string">"tel:10086"</span>));</span><br><span class="line">	startActivity(Intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionResult</span><span class="params">(<span class="keyword">int</span> requestCode,String[] permissions,<span class="keyword">int</span>[] grantResults)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(requestCode)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">if</span>(grantResults.lenght &gt; <span class="number">0</span> &amp;&amp; grantResults(<span class="number">0</span>) == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">				call();</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				Toast.makeText(<span class="keyword">this</span>,<span class="string">"You denied the permission"</span>,Toast.LEGHTH_SHORT).show();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述第一步先判断用户是不是已经给我们授权了，使用的是<strong>ContextCompat.checkSelfPermission</strong>，如果已经授权，直接拨打电话，否则调用<strong>ActivityCompat.requestPermission</strong>方法向用户申请授权，这时候用户可以选择同意或者拒绝我们的申请，不论哪种结果，都会通过回调<strong>onRequestPermissionResult</strong>告知，在回调中根据不同的结果做不同的处理。<strong>记住，在动态声明权限后，AndroidManifest中还得添加<uses-permission android:name="android.permission.CALL_PHONE"/> 声明</strong>。</p>
<h3 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h3><p>内容提供器的用法一般有两种，一是使用现有的内容提供器来读取和操作响应程序中的数据，另一种是创建自己的内容提供器给我们的数据提供外部访问接口。</p>
<h4 id="ContentResolver的基本使用"><a href="#ContentResolver的基本使用" class="headerlink" title="ContentResolver的基本使用"></a>ContentResolver的基本使用</h4><p>如果想要访问内容提供器共享的数据，就一定要借助ContentResolver类，可以通过Context中的getContentResolver方法获取到该类的实例。可以对内容进行CRUD操作，不同于SQLiteDatabase，ContentResolver增删改查不接收表名参数，而是使用Uri参数代替，该Uri主要由两部分组成：<strong>authority和path</strong>，前者用于对不同的应用程序做区分，一般采用程序包名形式，如某个程序的包名是com.example.app，那么对应的authority就可以命名为com.example.app.provider；path则是对同一应用程序中不同表做区分的，通常会添加到authority后面，所以内容Uri的形式一般如下所示(带协议声明)：</p>
<blockquote>
<p>content://com.example.app.provicer/table1<br>content://com.example.app.provicer/table2</p>
</blockquote>
<p>正式查询的时候，将Uri作为参数传入，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">"content://com.example.app.provicer/table1"</span>);</span><br><span class="line">Cuisor cursor = getContentResolver().query(uri,projection,selection,selectionArgs,sortOrder);</span><br></pre></td></tr></table></figure>

<p>其中，query方法中各个参数对应的含义如下所示：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-7/%E5%9B%BE2.png" alt="参数对应的含义"></p>
<p>接下来便可以进行相应的增删改查操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查</span></span><br><span class="line"><span class="keyword">if</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">	<span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">		String colomn1 = cursor.getString(cursor.getColumnIndex(<span class="string">"column1"</span>));</span><br><span class="line">		<span class="keyword">int</span> colomn2 = cursor.getInt(cursor.getColumnIndex(<span class="string">"column2"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增</span></span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"column1"</span>,<span class="string">"text"</span>);</span><br><span class="line">values.put(<span class="string">"column2"</span>,<span class="number">1</span>);</span><br><span class="line">getContentResolver().insert(uri,values);</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改，把column1的值清空</span></span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"column1"</span>,<span class="string">""</span>);</span><br><span class="line">getContentResolver().update(uri,values,<span class="string">"column1 = ? and column2 = ?"</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"text"</span>,<span class="string">"1"</span>&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line">getContentResolver().delete(uri,<span class="string">"column2 = ?"</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>其实整体就相当于sql语句，因此并不太难。</p>
<h3 id="创建自己的内容提供器"><a href="#创建自己的内容提供器" class="headerlink" title="创建自己的内容提供器"></a>创建自己的内容提供器</h3><p>因为基本上没有这样的需求，暂时略后续补上</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/11/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/11/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%85%AD%E7%AB%A0/" class="post-title-link" itemprop="url">第6章：数据存储全方案：详解持久化技术</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-11 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-11T08:00:00+08:00">2018-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-05-01 16:44:30" itemprop="dateModified" datetime="2019-05-01T16:44:30+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Android系统主要提供了3种方式用于简单地实现数据持久化功能——文件存储、SharedPreference存储以及数据库存储。</p>
<h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>文件存储是Android中最基本的存储方式，它不对存储内容进行任何的格式化处理，因而比较适合用于存储一些<strong>简单的文本数据</strong>或者<strong>二进制数据</strong>。</p>
<h3 id="将数据存储到文件"><a href="#将数据存储到文件" class="headerlink" title="将数据存储到文件"></a>将数据存储到文件</h3><p>Context类提供了一个openFileOutput()方法，可以用于将数据存储到指定文件，需要两个参数，第一个参数是文件名，纯粹的名称，不可以包含路径，因为所有的文件都是默认存储到<strong>/data/data/<packagename>/files/</strong>目录下；还有个参数是操作模式，主要有两种（其他2种在4.2被废弃了）：</p>
<ul>
<li>MODE_PRIVATE:默认的操作模式，表示当指定同样文件名的时候，所写入的内容将会覆盖原来文件中的内容。</li>
<li>MODE_APPEND:表示如果该文件已经存在，就往文件里面追加内容，不存在就创建新文件。</li>
</ul>
<p>保存文件的一般如以下代码操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String dataStr = <span class="string">"data to save"</span>;</span><br><span class="line">	FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">	BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="comment">//文件名是data</span></span><br><span class="line">		out = openFileOutput(<span class="string">"data"</span>,Context.MODE_PRIVATE);</span><br><span class="line">		writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out));</span><br><span class="line">		writer.write(dataStr);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;finnaly&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(writer != <span class="keyword">null</span>)&#123;</span><br><span class="line">				writer.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储成功后，可以通过Android Device Monitor 进入File Explorer标签，在目录中/data/data/<packagename>/files/中就能找到 data 文件。同理，读取存到文件中的代码应如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">()</span></span>&#123;</span><br><span class="line">	FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">	BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">	StringBuilder content = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		in = openFileInput(<span class="string">"data"</span>);</span><br><span class="line">		reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">		String line = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">while</span>((line = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">			content.append(line);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;finnaly&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(reader != <span class="keyword">null</span>)&#123;</span><br><span class="line">				reader.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> content.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SharedPreference"><a href="#SharedPreference" class="headerlink" title="SharedPreference"></a>SharedPreference</h2><p>SharedPreference是使用键值对的方式来存储数据的，保存一条数据的时候，需要给这条数据提供一个对应的键，读取数据时通过这个键把对应的值读取出来，SharedPreference文件都是存放在/data/data/<packagename>/shared_prefs目录下。要想存储数据，首先要获取到SharedPreference对象，Android主要提供了3中方式：</p>
<ul>
<li><p>Context类中的getSharedPreference()方法：此方法接收两个参数，第一个用于指定文件名称，第二个用于指定操作模式，目前只有MODE_PRIVATE可选（其他的几种在4.2或者6.0版本被废弃了），并且是默认的操作模式，表示只有当前应用程序才可以对这个文件进行读写。</p>
</li>
<li><p>Activity中的getPreferences()方法：和Context类中的getSharedPreference()方法类似，只不过它只接受一个操作模式参数，因为使用这个方法时会自动将当前Activity的类名作为SharedPreference的文件名。</p>
</li>
<li><p>PreferenceManager类中的getDefaultSharedPreferences()方法：它接受一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreference文件。</p>
</li>
</ul>
<p>获取到SharedPreference对象之后，就可以开始存储数据了，主要分为3步实现：</p>
<ol>
<li>调用SharedPreference对象的edit()方法获取SharedPreference.Editor对象</li>
<li>向SharedPreference.Editor对象添加数据。</li>
<li>调用apply()方法提交，从而完成存储操作。</li>
</ol>
<p>代码形式应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences.Editor editor = getSharedPreferences(<span class="string">"data"</span>,MODE_PRIVATE).edit();</span><br><span class="line">editor.putString(<span class="string">"name"</span>,<span class="string">"Tom"</span>);</span><br><span class="line">editor.apply();</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储完成后，读取数据</span></span><br><span class="line">SharedPreferences pref = getSharedPreferences(<span class="string">"data"</span>,MODE_PRIVATE);</span><br><span class="line">String name = pref.getString(<span class="string">"name"</span>,<span class="string">""</span>);</span><br></pre></td></tr></table></figure>

<h2 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a>SQLite数据库存储</h2><p>文件存储和SharedPrefrences存储只适用于保存一些简单的数据和键值对，要存储大量复杂的关系型数据的时候，有点难以应付了。</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>Android为了让我们更方便地管理数据库，专门提供了一个SQLiteOpenHelper抽象类，要想使用的话，我们就需要创建一个自己的类去继承它，它有两个抽象方法，onCreate和onUpgrade用来创建和升级数据库，其它两个重要的实例方法：getReadableDatabase和getWritableDatabase，他们都可以创建或者打开一个现有的数据库（没有就创建），在数据库不可写入的时候（如磁盘满了），前者以只读的形式打开数据库，后者会出现异常。它有两个构造方法可重写，一般使用哪个参数较少的即可，总共4个参数，第一个context，第二个是数据库名，第三个是自定义的Cursor，一般传null，第四个表示当前的数据库版本号，用于对数据库进行升级操作。一般代码如下图所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CREATE_BOOK = <span class="string">"create table Book ("</span></span><br><span class="line">		+ <span class="string">"id integer primary key autoincrement,"</span></span><br><span class="line">		+ <span class="string">"author text,"</span></span><br><span class="line">		+ <span class="string">"price real,"</span></span><br><span class="line">		+ <span class="string">"pages integer,"</span></span><br><span class="line">		+<span class="string">"name text)"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span>&#123;</span><br><span class="line">			db.exeSQL(CREATE_BOOK);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候应该是这样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>,<span class="string">"BookStore.db"</span>,<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//就会创建成功了</span></span><br><span class="line">dbHelper.getWritableDatabase();</span><br></pre></td></tr></table></figure>

<p>上例创建了一个Book表，使用primary key 将id设置为主键，并用autoincrement关键字表示id是自增长的。可以使用</p>
<blockquote>
<p>adb shell</p>
</blockquote>
<p>命令，之后cd到/data/data/<packagename>/databases/目录下用<strong>ls</strong>列出该目录的文件，可以看到BookStore.db文件，以及BookStore.db-journal文件，后者是数据库的临时文件。SQLite没有其他数据库一样有很多繁杂的数据类型，它的数据类型很简单：<strong>integer表示整型，real表示浮点型，text表示文本，blob表示二进制类型</strong>；</p>
<h3 id="升级数据库"><a href="#升级数据库" class="headerlink" title="升级数据库"></a>升级数据库</h3><p>此时项目中有一张Book表用于存放输的各种详细数据了，但是如果再想添加一张Category表用于记录图书的分类，如果仅仅直接在MyDatabaseHelper的onCreate中写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span>&#123;</span><br><span class="line">	db.exeSQL(CREATE_BOOK);</span><br><span class="line">	db.exeSQL(CREATE_CATEGORY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是行不通的，因为使用的时候先初始化helper：<strong>dbHelper = new MyDatabaseHelper(this,”BookStore.db”,null,1)</strong>再获取数据库：<strong>dbHelper.getWritableDatabase()</strong>，而由于此时已经存在数据库BookStore.db了，因此不会再执行helper的onCreate方法了。此时清除app数据可以做到创建Category表，但是这在实际应用中不合理，而我们可以用<strong>onUpgrade</strong>方法来解决，我们前面构造了MyDatabaseHelper，第4个参数是版本号，我们目前是1，所以只要传入的值大于当前版本号1，onUpgrade方法就可以执行，因此我们可以这样增加Category表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db,<span class="keyword">int</span> oldVersion,<span class="keyword">int</span> newVersion)</span></span>&#123;</span><br><span class="line">		db.exeSQL(<span class="string">"drop table if exists Book"</span>);</span><br><span class="line">		db.exeSQL(<span class="string">"drop table if exists Category"</span>);</span><br><span class="line">		onCreate(db);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码执行了两条drop语句，发现数据库已经存在Book表和Category表了就删除，然后调用onCreate方法重新创建，因此在onCreate中也得写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span>&#123;</span><br><span class="line">	db.exeSQL(CREATE_BOOK);</span><br><span class="line">	db.exeSQL(CREATE_CATEGORY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时候也得升级版本号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>,<span class="string">"BookStore.db"</span>,<span class="keyword">null</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//就会创建成功了</span></span><br><span class="line">dbHelper.getWritableDatabase();</span><br></pre></td></tr></table></figure>

<p>获取到数据库，接下来可以对其CRUD操作，其中C代表添加（Create），R代表查询（retrieve），U代表更新（Update），D代表删除（Delete）。Android开发者水平参差不齐，并非每一个都会SQL语言，Android提供了一系列的辅助性方法，是的在Android中即使不去编写SQL语句，也能轻松完成所有CRUD操作。getReadableDatabase与getWriteableDatabase方法不仅可以用来创建和升级数据库，他们还会返回一个SQLiteDatabase对象，借助这个对象就可以轻松CRUD：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**添加数据**/</span></span><br><span class="line">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"name"</span>,<span class="string">"thinking in java"</span>);</span><br><span class="line">values.put(<span class="string">"price"</span>,<span class="number">16.96</span>);</span><br><span class="line">values.put(<span class="string">"pages"</span>,<span class="number">512</span>);</span><br><span class="line"><span class="comment">//插入时指定表名为"Book"</span></span><br><span class="line">db.insert(<span class="string">"Book"</span>,<span class="keyword">null</span>,values);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**以下是更新**/</span></span><br><span class="line">values.clear();</span><br><span class="line">values.put(<span class="string">"price"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//第三个参数对应SQL语句中的where部分，表示更新所有name等于?的行，而?是一个占位符，</span></span><br><span class="line"><span class="comment">//可以通过第四个参数提供的一个字符串数组为第三个参数中的每个占位符指定相应内容</span></span><br><span class="line">db.update(<span class="string">"Book"</span>,values,<span class="string">"name=?"</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"thinking in java"</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**以下是删除**/</span></span><br><span class="line"><span class="comment">//表示删除pages的值大于500的数据</span></span><br><span class="line">db.delete(<span class="string">"Book"</span>,<span class="string">"pages &gt; ?"</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"500"</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**以下是查询**/</span></span><br><span class="line">Cursor cusor = db.query(<span class="string">"Book"</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span>(cursor.moveToFirst())&#123;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		String name = cursor.getString(cursor.getColumnIndex(<span class="string">"name"</span>));</span><br><span class="line">		String pages = cursor.Double(cursor.getColumnIndex(<span class="string">"price"</span>));</span><br><span class="line">	&#125;<span class="keyword">while</span>(cursor.moveToNext());</span><br><span class="line">&#125;</span><br><span class="line">cusor.close();</span><br></pre></td></tr></table></figure>

<p>当然，可以直接使用SQL语句直接完成上述操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//添加</span><br><span class="line">db.execSQL("<span class="keyword">insert</span> <span class="keyword">into</span> Book (<span class="keyword">name</span>,pages,price) <span class="keyword">values</span>(?,?,?)<span class="string">",new String[]&#123;"</span>thinking <span class="keyword">in</span> <span class="keyword">java</span><span class="string">","</span><span class="number">512</span><span class="string">","</span><span class="number">20</span><span class="string">"&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//升级</span></span><br><span class="line"><span class="string">db.execSQL("</span><span class="keyword">update</span> Book <span class="keyword">set</span> price = ? <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">",new String[]&#123;"</span><span class="number">20</span><span class="string">","</span>thinking <span class="keyword">in</span> <span class="keyword">java</span><span class="string">"&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//删除</span></span><br><span class="line"><span class="string">db.execSQL("</span><span class="keyword">delete</span> <span class="keyword">from</span> Book <span class="keyword">where</span> pages &gt; ?<span class="string">",new String[]&#123;"</span><span class="number">500</span><span class="string">"&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//查询</span></span><br><span class="line"><span class="string">db.execSQL("</span><span class="keyword">select</span> * <span class="keyword">from</span> Book<span class="string">",null);</span></span><br></pre></td></tr></table></figure>



<h2 id="使用LitePal"><a href="#使用LitePal" class="headerlink" title="使用LitePal"></a>使用LitePal</h2><p><strong>略</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/10/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/10/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%94%E7%AB%A0/" class="post-title-link" itemprop="url">第5章： 全局大喇叭：详解广播机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-10 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-10T08:00:00+08:00">2018-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-05-01 16:44:14" itemprop="dateModified" datetime="2019-05-01T16:44:14+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="广播机制介绍"><a href="#广播机制介绍" class="headerlink" title="广播机制介绍"></a>广播机制介绍</h3><p>Android中广播分为<strong>标准广播</strong>和<strong>有序广播</strong>，标准广播是一种完全异步执行的广播，广播发出后，所有广播接收器机会会在同一时刻接收到广播，但同时意味着它也是无法被截断的。有序广播是一种同步执行的广播，同一时刻只有一个广播接收器能收到这条消息，当这个广播接收器的逻辑执行完毕之后才会继续传递，优先级高的广播接收器可以先收到广播，并且还可以阶段正在传递的广播，这样后面的广播接收器就收不到这条广播消息。</p>
<h4 id="动态注册和静态注册广播"><a href="#动态注册和静态注册广播" class="headerlink" title="动态注册和静态注册广播"></a>动态注册和静态注册广播</h4><p>动态注册一般在Activity的onCreate方法中写上类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">receiver = <span class="keyword">new</span> MyReceiver();</span><br><span class="line">registerReceiver(receiver,filter);</span><br></pre></td></tr></table></figure>

<p>并且在onDestroy方法中注销广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; unregisterReceiver(receiver);</span><br></pre></td></tr></table></figure>

<p>然后，完善一般是内部类的MyReceiver：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context,Intent intent)</span></span>&#123;</span><br><span class="line">		Toast.makeText(context,<span class="string">"receive the broadcast"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后得在适当的时候发送广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p><strong>当然，如果你是用广播在APP中实现强制退出登录（如QQ账号在另一台设备上登录了），那你只需要在当前Activity上弹一个窗提示已经被强制下线即可，因此有必要将广播在BaseActivity中注册，并且在BaseActivity的onPause方法（注意不是onDestroy方法了，因为我们只需要栈顶的Activity能够响应就行）中注销广播即可。如果是接收系统级广播，可能还得在AndroidManife.xml中声明相关权限</strong>。APP中实现强制退出登录时的广播接收器可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForceOfflineReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(<span class="keyword">final</span> Context context,Intent intent)</span></span>&#123;</span><br><span class="line">		AltertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(context);</span><br><span class="line">		builder.setTitle(<span class="string">"warning"</span>);</span><br><span class="line">		builder.setMessage(<span class="string">"force offline"</span>);</span><br><span class="line">		builder.setCancelable(<span class="keyword">false</span>);</span><br><span class="line">		builder.setPositiveButton(<span class="string">"ok"</span>,<span class="keyword">new</span> DialogInterface.OnclickListener()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onclick</span><span class="params">(DialogInterface dialog,<span class="keyword">int</span> which)</span></span>&#123;</span><br><span class="line">				ActivityCollector.finishAll();<span class="comment">//销毁所有活动</span></span><br><span class="line">				Intent intent = <span class="keyword">new</span> Intent(context,LoginActivity.class);</span><br><span class="line">				context.startActivity(intent);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>静态注册广播是在AndroidManife.xml中做如下的声明，<strong>其中MyReceiver类一般不是内部类，因为即使app未启动也能接收广播</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:label</span>=<span class="string">"@string/appname"</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:name</span>=<span class="string">".MyReceiver"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.MyReceiver"</span></span></span><br><span class="line"> &lt;/receiver&gt;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果要发送有序广播，只需要将以上发送广播的代码<strong>sendBroadcast(intent)</strong>替换成<strong>sendOrderedBroadcast(intent,null);</strong>即可。设置广播的优先级只需要设置intentFilter的priority属性即可（AndroidManifest文件中是intent-filter属性）。</p>
<h3 id="使用本地广播"><a href="#使用本地广播" class="headerlink" title="使用本地广播"></a>使用本地广播</h3><p>前面发送的广播属于系统全局广播，发出的广播可以被任何应用接收到，并且我们也可以接受来自其它任何应用发出的广播，这容易引起安全性问题，比如关键数据广播被其他应用截获，或者其他应用发送各种垃圾广播。本地广播的发送有些不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalBroadcastManager manager = LocalBroadcastManager.getInstance(<span class="keyword">this</span>);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">manager.sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p>注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">localReceiver = <span class="keyword">new</span> LocalReceiver();</span><br><span class="line">manager.registerReceiver(localReceiver,filter);</span><br></pre></td></tr></table></figure>
<p>同样注销广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager.unregisterReceiver(localReceiver);</span><br></pre></td></tr></table></figure>

<p>本地广播的几点优势：</p>
<ul>
<li>可以明确地知道正在发送的广播不会离开我们的程序，因此不必担心机密数据泄露。</li>
<li>其他的程序无法将广播发送到我们程序内部，因此不用担心会有安全漏洞隐患。</li>
<li>发送本地广播比发送系统全局广播更加高效。</li>
</ul>
<p><strong>另有一点需要说明：本地广播是无法通过静态注册方式来接收的，其实这也完全可以理解，因为静态注册主要就是为了让程序在未启动的情况下也能接收广播，而发送本地广播时，我们的程序肯定是已经启动了；此外，不要再onReceive方法中添加过多的逻辑或者进行任何耗时的操作，因为广播接收器中是不允许开启线程的，当onReceive方法运行了较长时间而没有结束时，程序就会报错。因此它更多的知识扮演一种打开程序其他组件的角色，如弹一条通知，或者启动一个服务等。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">第4章：手机平板要兼顾：探究fragment</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-09 16:00:00" itemprop="dateCreated datePublished" datetime="2018-06-09T16:00:00+08:00">2018-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-05-01 16:44:57" itemprop="dateModified" datetime="2019-05-01T16:44:57+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这一章前面部分主要讲解Fragment的基本使用，这点我觉得官方文档关于fragment的知识可能会更好一些，以下是官方的阐述：</p>
<p>主要是平时使用Fragment时，对其使用方法有疑惑，以下或许能解释部分：</p>
<h3 id="为什么使用Fragment"><a href="#为什么使用Fragment" class="headerlink" title="为什么使用Fragment"></a>为什么使用Fragment</h3><p><strong>参考自官方</strong>：主要是为了在大屏幕手机（如平板电脑）上更加零落的UI设计，可以更方便地组合和交换UI组件。</p>
<h3 id="Fragment的创建"><a href="#Fragment的创建" class="headerlink" title="Fragment的创建"></a>Fragment的创建</h3><p>想为Fragment提供布局，则必须实现onCreateView()回调，可以通过xml定义布局资源，为此，onCreateView()提供了一个LayoutInflater对象：</p>
<pre><code>public static class ExampleFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.example_fragment, container, false);
    }
}</code></pre><h3 id="向Activity中添加Fragment"><a href="#向Activity中添加Fragment" class="headerlink" title="向Activity中添加Fragment"></a>向Activity中添加Fragment</h3><h4 id="1、在Activity的布局文件中声明："><a href="#1、在Activity的布局文件中声明：" class="headerlink" title="1、在Activity的布局文件中声明："></a>1、在Activity的布局文件中声明：</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;horizontal&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;fragment android:name=&quot;com.example.ListFragment&quot;
            android:id=&quot;@+id/list&quot;
            android:layout_weight=&quot;1&quot;
            android:layout_width=&quot;0dp&quot;
            android:layout_height=&quot;match_parent&quot; /&gt;

    &lt;fragment android:name=&quot;com.example.AticleFragment&quot;
            android:id=&quot;@+id/viewer&quot;
            android:layout_weight=&quot;2&quot;
            android:layout_width=&quot;0dp&quot;
            android:layout_height=&quot;match_parent&quot; /&gt;
&lt;/LinearLayout&gt;</code></pre><blockquote>
<p><strong>官方解释</strong>:Activity初始化布局时，会实例化布局中指定的每个fragment，并为每个Fragment调用onCreateView()方法，系统会直接插入Fragment返回的View来替代<fragment>元素。</p>
</blockquote>
<h4 id="2、通过编程方式将Fragment添加到某个现有的ViewGroup："><a href="#2、通过编程方式将Fragment添加到某个现有的ViewGroup：" class="headerlink" title="2、通过编程方式将Fragment添加到某个现有的ViewGroup："></a>2、通过编程方式将Fragment添加到某个现有的ViewGroup：</h4><p>可以在Activity运行期间将Fragment添加进去，你只需要指定Fragment要放入哪个ViewGroup，这需要使用FragmentTransaction：</p>
<pre><code>FragmentManager fragmentManager = getFragmentManager();
FragmentTransaction transaction = fragmentManager.beginTransaction();</code></pre><p>然后，你可以使用add()方法添加一个fragment：</p>
<pre><code>ExampleFragment fragment = new ExampleFragment();
transaction.add(R.id.fragment_container,fragment);
transaction.commit();</code></pre><blockquote>
<p>一旦通过FragmentTransaction做出了更改，就必须commit以使更改生效。</p>
</blockquote>
<h4 id="3、添加没有UI的Fragment："><a href="#3、添加没有UI的Fragment：" class="headerlink" title="3、添加没有UI的Fragment："></a>3、添加没有UI的Fragment：</h4><p>你可以使用Fragment为Activity提供后台行为，而不显示额外的UI。使用函数：</p>
<pre><code>add(Fragment,String)</code></pre><p>String类型参数为Fragment提供一个唯一的字符串标记，由于Fragment没有雨Activity中的视图关联，因此不会收到onCreate()调用，因此你可以不实现这个方法。如果你稍后想从Activity中获取到这个Fragment，可以使用findFragmentByTag()。</p>
<blockquote>
<p>可以在SDK的sample中查看具体用法：<sdk_root>/APIDemos/app/src/main/java/com/example/android/apis/app/FragmentRetainInstance.java </p>
</blockquote>
<h3 id="执行Fragment事务"><a href="#执行Fragment事务" class="headerlink" title="执行Fragment事务"></a>执行Fragment事务</h3><p>需要使用FragmentTransaction，可以使用：</p>
<pre><code>add() 、remove() 、replace()</code></pre><p>等方法设置想要执行的更改，然后commit生效。</p>
<p>不过在commit之前你可能想调用 addToBackStack()将其添加到Fragment事务返回栈，允许用户按返回键返回上一Fragment状态。</p>
<p>来个例子：</p>
<pre><code>/**create new fragment and transaction**/

Fragment newFragment = new ExampleFragment();
FragmentTransaction transaction = getFragment().beginTransaction();

/**Replace whatever is in the fragment_container view with this fragment
and add the transaction to the back stack**/

transaction.replace(R.id.fragment_container,newFragment);
transaction.addToBackStack(null);

//commit the transaction
transaction.commit();</code></pre><p>向FragmentTransaction添加更改的顺序无关紧要，但有一些注意事项：</p>
<blockquote>
<p>commit操作不会立即执行，而是等主线程认为可以执行的时候再运行，不过，如果有必要，你也可以从主线程调用executePendingTransactions() 以立即执行commit。</p>
</blockquote>
<blockquote>
<p>最后必须调用commit，而且只能在用户离开Activity之前commit，否则会引发异常，如果对于需要commit的更改无关紧要，可以使用commitAllowingStateLoss()。</p>
</blockquote>
<blockquote>
<p>可以向同一个容器中添加多个fragment，你添加的顺序决定他们在视图层次结构中出现的顺序。</p>
</blockquote>
<h3 id="管理Fragment"><a href="#管理Fragment" class="headerlink" title="管理Fragment"></a>管理Fragment</h3><p>需要使用FragmentManager，你可以使用它执行以下操作：</p>
<ul>
<li><p>findFragmentById() （<strong>对于在Activity布局中提供UI的Fragment</strong>）或者findFragmentByTag()（<strong>对于提供或者不提供UI的Fragment都可</strong>）。</p>
</li>
<li><p>popBackStack() (<strong>模拟用户发出的返回命令</strong>)，将Fragment从返回栈中弹出。</p>
</li>
<li><p>addOnBackStackChangedListener() 监听返回栈变化</p>
</li>
</ul>
<h3 id="与Activity通信"><a href="#与Activity通信" class="headerlink" title="与Activity通信"></a>与Activity通信</h3><p>Fragment可以通过getActivity()访问Activity实例，并轻松执行诸如在Activity布局中查找视图等任务：</p>
<pre><code>View listView = getActivity().findViewById(R.id.list);</code></pre><p>同样，Activity也可以使用findFragmentById 或者 findFragmentByTag,通过从FragmentManager获取Fragment的引用来调用Fragment中的方法：</p>
<pre><code>ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);</code></pre><h3 id="一个应用场景例子"><a href="#一个应用场景例子" class="headerlink" title="一个应用场景例子"></a>一个应用场景例子</h3><p>一个新闻应用中Activity两个Fragment，Fragment A放列表list，Fragment B 放对应内容，那么A在列表项选定后，告诉Activity，以便Activity通知B显示该新闻。其方案可以这样设计：</p>
<p>在A中声明接口OnArticleSelectedListener ：</p>
<pre><code>public static class FragmentA extends ListFragment {
    ...
    // Container Activity must implement this interface
    public interface OnArticleSelectedListener {
        public void onArticleSelected(Uri articleUri);
    }
    ...
}</code></pre><p>同事在Activity中实现接口OnArticleSelectedListener，在A的onAttach方法时判断Activity是否这样做了：</p>
<pre><code>public static class FragmentA extends ListFragment {
    OnArticleSelectedListener mListener;
    ...
    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        try {
            mListener = (OnArticleSelectedListener) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException(activity.toString() + &quot; must implement OnArticleSelectedListener&quot;);
        }
    }
    ...
}</code></pre><p>当有点击事件的时候，A看起来是这样子的：</p>
<pre><code>public static class FragmentA extends ListFragment {
    OnArticleSelectedListener mListener;
    ...
    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        // Append the clicked item&apos;s row ID with the content provider Uri
        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);
        // Send the event and Uri to the host activity
        mListener.onArticleSelected(noteUri);
    }
    ...
}</code></pre><p>Fragment的生命周期如下图：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-4/fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="fragment生命周期"></p>
<p>其中将fragment进行至fragment的resume状态（即可以跟用户交互）的核心序列如下：</p>
<ul>
<li><p>onAttach(Activity) ：activity与fragment关联的时候调用.</p>
</li>
<li><p>onCreate(Bundle) ：fragment初始化的时候调用.</p>
</li>
<li><p>onCreateView(LayoutInflater, ViewGroup, Bundle) ：为fragment创建返回view界面.</p>
</li>
<li><p>onActivityCreated(Bundle): 通知fragment它绑定的那个Activity已经执行完了onCreate()操作.</p>
</li>
<li><p>onViewStateRestored(Bundle)： 通知fragment它保存的view state已经被恢复了.</p>
</li>
<li><p>onStart()： fragment对用户可见 (还要取决于包含这个fragment的activity是否已经启动了).</p>
</li>
<li><p>onResume()： 使fragment可以和用户交互了 (还要取决于包含这个fragment的activity是否已经resume了).<br>如果一个fragment不再使用了，它会执行一系列相反的过程:</p>
</li>
<li><p>onPause()： fragment不能与用户交互（可能是由于activity的pause）。 </p>
</li>
<li><p>onStop()： fragment不可见了（可能是由于activitystop了）。</p>
</li>
<li><p>onDestroyView()：通知fragment清理与它相关的view资源。</p>
</li>
<li><p>onDestroy()：在完全清理fragment的状态时调用。</p>
</li>
<li><p>onDetach()：当fragment与activity解除绑定时调用。</p>
</li>
</ul>
<h3 id="动态加载布局的技巧"><a href="#动态加载布局的技巧" class="headerlink" title="动态加载布局的技巧"></a>动态加载布局的技巧</h3><h4 id="使用限定符"><a href="#使用限定符" class="headerlink" title="使用限定符"></a>使用限定符</h4><p>如果使用平板就会发现里面的应用基本上是双页模式，但是在手机上限于屏幕大小，都是单页模式。如果判断该使用双页模式还是单页模式，这就要借助<strong>限定符（qualifiers）</strong>来实现了，我们可以有两个布局文件，一个 layout_single.xml 单页模式布局放在layout目录，一个 layout_double.xml 双页模式布局放在 layout-large 目录，其中的large是个限定符。Android中常用限定符如下：<br><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-4/%E9%99%90%E5%AE%9A%E7%AC%A61.png" alt="android限定符1"><br><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-4/%E9%99%90%E5%AE%9A%E7%AC%A62.png" alt="android限定符2"></p>
<h4 id="使用最小限定符"><a href="#使用最小限定符" class="headerlink" title="使用最小限定符"></a>使用最小限定符</h4><p>前面解决了单页双页模式，但是到底怎么才算large，我们需要更精确地控制的话，需要最小限定符。我们新建layout-600dp文件夹，将双页布局文件放入其中，这样就会意味着，当程序运行在宽度小于600dp的设备上时，显示的是单页布局，否则使用的是双页布局。</p>
<p>以上两种技巧可以将手机版和pad版都使用同一个app，避免维护多个app，一处改动，需要在两个app中同步改动。注意在代码中区别目前是双页模式还是单页模式，可以用以下方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(findViewById(R.id.anotherpageid) == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//单页</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//双页</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中R.id.anotherpageid是在单页中所没有的那个布局的id。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%89%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%89%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：软件和也要拼脸蛋</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-09 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-09T08:00:00+08:00">2018-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-05-01 16:43:52" itemprop="dateModified" datetime="2019-05-01T16:43:52+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>布局文件中如果添加Button，并指定其text为”button”的话，但是显示的是”BUTTON”，全部变为大写了，要去掉这一效果，可以添加属性<strong>android:textAllCaps=”false”</strong></p>
<p>RelativeLayout 中还有另外一组对于控件进行定位的属性，android:layout_alignLeft表示让一个控件的左边缘和另一个控件的左边缘对齐，同理，还有android:layout_alignRight、Top、Bottom 。</p>
<h3 id="创建自定义控件"><a href="#创建自定义控件" class="headerlink" title="创建自定义控件"></a>创建自定义控件</h3><p>我们所用的所有控件都是直接或者间接继承自View的，所有的布局都是直接或者间接继承ViewGroup，View是Android中最基本的一种UI组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是在View的基础上添加各自特有功能；而ViewGroup则是一种特殊的View，它可以包含很多子View和子ViewGroup，是一个防止控件和布局的容器。常用控件和布局的继承结构如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-3/%E5%9B%BE1.png" alt="view继承关系"></p>
<p>App中的标题栏几乎在每个界面都是一样的，除了标题不一样，其他的诸如左边按钮点击就finish当前页面，右边的是菜单按钮，这些功能基本上一样，如果在每个页面都单独为这些按钮重复添加相同的监听，比较繁琐。所以可以将标题栏单独封装成单独的一个TitleLayout的，每次只需要引入到布局中即可。</p>
<h3 id="使用listview"><a href="#使用listview" class="headerlink" title="使用listview"></a>使用listview</h3><p>可以继承ArrayAdapter简化操作，类似如下(当然，这里在getView的时候没有进行复用优化，仅仅只是示例)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Fruit</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> resourceId;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FruitAdapter</span><span class="params">(Context context,<span class="keyword">int</span> resourceId,List&lt;Fruit&gt; objects)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(context,resourceId,objects);</span><br><span class="line">		<span class="keyword">this</span>.resourceId = resourceId;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position,View convertView,ViewGroup parent)</span></span>&#123;</span><br><span class="line">		Fruit fruit = getItemt(position);</span><br><span class="line">		View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,<span class="keyword">false</span>);</span><br><span class="line">		ImageView ivFruit = view.findViewById(R.id.img);</span><br><span class="line">		TextView tvFruit = view.findViewById(R.id.txt);</span><br><span class="line">		ivFruit.setImageResource(fruit.getImageId());</span><br><span class="line">		tvFruit.setText(fruit.getName());</span><br><span class="line">		<span class="keyword">return</span> view;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用更强大的RecyclerView"><a href="#使用更强大的RecyclerView" class="headerlink" title="使用更强大的RecyclerView"></a>使用更强大的RecyclerView</h3><p>在设置LayoutManager的时候，可以指定排布的方向比如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinearLayoutManager manager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">manager.setOrientation(LinearLayoutManager.HORIZONTAL);<span class="comment">//平时一般使用竖直方向，这里特意指定横向</span></span><br></pre></td></tr></table></figure>

<p>为什么Listview很难或者根本无法实现这种效果呢，其实这主要得益于RecyclerView的出色设计，ListView的布局排列是由自身去管理的，，而RecyclerView则将这个工作交给了LayoutManager，LayoutManager指定了一套可扩展的布局排列接口，自雷只要按照接口的规范来实现，就能定制出不同排列方式的布局了。</p>
<p>实现点击事件，可以在Adapter中的<strong>onCreateViewHolder</strong>方法中来做到，诸如以下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent,<span class="keyword">int</span> viewType)</span></span>&#123;</span><br><span class="line">	View view = LayoutInflater.from(parent.getContext).inflate(R.layout.fruit_item,parent,<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">final</span> ViewHolder holder = <span class="keyword">new</span> ViewHolder(view);</span><br><span class="line">	holder.ivFruit.setOnclickListener(<span class="keyword">new</span> View.OnclickListener()&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">			<span class="keyword">int</span> postion = holder.getAdapterPosition();</span><br><span class="line">			<span class="comment">//doSomeThing you want</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/07/Intent%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/07/Intent%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7/" class="post-title-link" itemprop="url">Intent 传递的数据过大</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-07 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-07T08:00:00+08:00">2018-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-06-11 08:43:20" itemprop="dateModified" datetime="2018-06-11T08:43:20+08:00">2018-06-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这个问题源于最近做的项目中出现的bug，一个Activity A通过startActivity(intent)的方式（intent中携带了String类型的data）启动另一个Activity B时，发生了崩溃，查看错误日志如下：</p>
<p><img src="/assets/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/intent%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97.png" alt="启动Activity时的错误日志"></p>
<p>可以看到，这是 <strong>android.os.TransactionTooLargeException</strong> ，字面意思是事务太大。这就很好理解了，因为笔者使用了intent携带数据，在事后分析这个data在传入的时候大约50k，因此导致了这个问题。后来使用<strong>SharedPreference</strong>将数据捎带过去解决了问题，这个bug本身看懂了报错就很简单，因此不再赘述。后面有空有兴趣之后再补上分析Intent传递数据到底是多大的限制。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/05/listview%E6%90%AD%E9%85%8Dcheckbox%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/05/listview%E6%90%AD%E9%85%8Dcheckbox%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Listview 中 CheckBox 状态错误问题原因及解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-05 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-05T08:00:00+08:00">2018-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-06-11 08:48:06" itemprop="dateModified" datetime="2018-06-11T08:48:06+08:00">2018-06-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在开发过程中碰到很多问题，有些问题在锤子便签中记录了一个概要，有的问题甚至连记录都没有，此次开个头，将碰到的问题记录下来。</p>
<p>今天要写的问题跟Listview有关，顺便复习下ListView的相关复用机制，以及Listview的Adapter中getView方法为什么需要ViewHolder，是怎么提高加载效率的。下面开始进入回忆状态，事情的经过是这样的：</p>
<p>在平时的 Android 开发过程中，我们可能需要去实现以下效果：</p>
<p><img src="/assets/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/listview%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98/%E5%9C%BA%E6%99%AF.png" alt="使用场景"></p>
<p>在 Listview 中使用CheckBox，但是会碰到 CheckBox 选中/非选中 这种状态错乱的问题，笔者最近在项目中就碰到了，比如我选中了 id0、id1、id2 三个 CheckBox ，再想选择 id15 ，这就要求滑动 Listview 了，滑到 id15 CheckBox 将其选中，再滑动到顶部，握草，发现 id0、id1、id2 已经变成 非选中 状态了，莫非是我记错了？再重新来一次，还是一样！这就不科学了，一定是哪里出了问题，我当时的代码是这样的：</p>
<pre><code>@Override
public View getView(final int i, View view, ViewGroup viewGroup) {
    ViewHolder viewHolder = null;
    if(view == null){
        viewHolder = new ViewHolder();
        view = LayoutInflater.from(context).inflate(R.layout.layout,null);
        viewHolder.cb = (CheckBox) view.findViewById(R.id.select_cb);
        viewHolder.tvName = (TextView) view.findViewById(R.id.name_tv);
        view.setTag(viewHolder);
    }else{
        viewHolder = (ViewHolder) view.getTag();
    }
    viewHolder.cb.setChecked(data.get(i).isSlected());
    viewHolder.tvName.setText(data.get(i).getName());
    viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
        @Override
        public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked)     {
            data.get(i).setSlected(isChecked);
        }
    });
    return view;
}</code></pre><p>脑子里第一反应是各处的 item 串了，联想到使用 viewholder 来复用 item ，于是就去了解了一番 Listview 对 item 的复用机制。</p>
<h3 id="复用机制"><a href="#复用机制" class="headerlink" title="复用机制"></a>复用机制</h3><p>我们知道，listview 需要承载大量的数据，并且需要写一个 Adapter 与其适配，这样数据就能展现出来了，但是不知道大家有没有仔细想过，为什么需要 Adapter 这个东西，它到底起了个什么作用。</p>
<h5 id="从-Adapter-说起"><a href="#从-Adapter-说起" class="headerlink" title="从 Adapter 说起"></a>从 Adapter 说起</h5><p>说到底，Android 中控件就是为了展示数据以及交互用，只不过Listview特殊些，它用于展示大量的信息的，但是 Listview 只承担交互和展示工作的，至于数据来自哪里，它不care。这样，listview工作最基本需要一个 Listview 控件和一个数据源，但是数据源可能是数组，可能是集合，甚至可能是数据库表中查询出来的游标，如果 Listview 要去为每一种数据源进行匹配的话，它一定会变得非常臃肿了，于是 Adapter 出现了。</p>
<p>顾名思义，Adapter 是适配器的意思，它在 Listview 与数据源之间起了一个桥梁作用，与之前的情况不同的是，Adapter 的接口都是统一的，因此 Listview 不需要担心任何适配问题。而 Adapter 是个接口（interface），它可以有各种子类，比如 ArrayAdapter 可用于数组和 List 类型的数据源匹配，SimpleCursorAdapter 可以用于游标类型的数据源匹配，这样把适配问题解决了，并且扩展性不错。</p>
<h5 id="RecycleBin-类"><a href="#RecycleBin-类" class="headerlink" title="RecycleBin 类"></a>RecycleBin 类</h5><p>在解释复用机制之前，还有必要说一下 RecycleBin 类，因为它是 Listview 能够展现成百上千条数据并且不会 OOM 的关键，RecycleBin 是 AbsListview 的一个内部类，其主要代码如下：</p>
<pre><code>/**
 * The RecycleBin facilitates reuse of views across layouts. The RecycleBin
 * has two levels of storage: ActiveViews and ScrapViews. ActiveViews are
 * those views which were onscreen at the start of a layout. By
 * construction, they are displaying current information. At the end of
 * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews
 * are old views that could potentially be used by the adapter to avoid
 * allocating views unnecessarily.
 */
class RecycleBin {
    private RecyclerListener mRecyclerListener;

    /**
     * The position of the first view stored in mActiveViews.
     */
    private int mFirstActivePosition;

    /**
     * Views that were on screen at the start of layout. This array is
     * populated at the start of layout, and at the end of layout all view
     * in mActiveViews are moved to mScrapViews. Views in mActiveViews
     * represent a contiguous range of Views, with position of the first
     * view store in mFirstActivePosition.
     */
    private View[] mActiveViews = new View[0];

    /**
     * Unsorted views that can be used by the adapter as a convert view.
     */
    private ArrayList&lt;View&gt;[] mScrapViews;

    private int mViewTypeCount;

    private ArrayList&lt;View&gt; mCurrentScrap;

    /**
     * Fill ActiveViews with all of the children of the AbsListView.
     * 
     * @param childCount
     *            The minimum number of views mActiveViews should hold
     * @param firstActivePosition
     *            The position of the first view that will be stored in
     *            mActiveViews
     */
    void fillActiveViews(int childCount, int firstActivePosition) {
        if (mActiveViews.length &lt; childCount) {
            mActiveViews = new View[childCount];
        }
        mFirstActivePosition = firstActivePosition;
        final View[] activeViews = mActiveViews;
        for (int i = 0; i &lt; childCount; i++) {
            View child = getChildAt(i);
            AbsListView.LayoutParams lp = (AbsListView.LayoutParams)     child.getLayoutParams();
            // Don&apos;t put header or footer views into the scrap heap
            if (lp != null &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                // Note: We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in
                // active views.
                // However, we will NOT place them into scrap views.
                activeViews[i] = child;
            }
        }
    }

    /**
     * Get the view corresponding to the specified position. The view will
     * be removed from mActiveViews if it is found.
     * 
     * @param position
     *            The position to look up in mActiveViews
     * @return The view if it is found, null otherwise
     */
    View getActiveView(int position) {
        int index = position - mFirstActivePosition;
        final View[] activeViews = mActiveViews;
        if (index &gt;= 0 &amp;&amp; index &lt; activeViews.length) {
            final View match = activeViews[index];
            activeViews[index] = null;
            return match;
        }
        return null;
    }

    /**
     * Put a view into the ScapViews list. These views are unordered.
     * 
     * @param scrap
     *            The view to add
     */
    void addScrapView(View scrap) {
        AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
        if (lp == null) {
            return;
        }
        // Don&apos;t put header or footer views or views that should be ignored
        // into the scrap heap
        int viewType = lp.viewType;
        if (!shouldRecycleViewType(viewType)) {
            if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                removeDetachedView(scrap, false);
            }
            return;
        }
        if (mViewTypeCount == 1) {
            dispatchFinishTemporaryDetach(scrap);
            mCurrentScrap.add(scrap);
        } else {
            dispatchFinishTemporaryDetach(scrap);
            mScrapViews[viewType].add(scrap);
        }

        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }

    /**
     * @return A view from the ScrapViews collection. These are unordered.
     */
    View getScrapView(int position) {
        ArrayList&lt;View&gt; scrapViews;
        if (mViewTypeCount == 1) {
            scrapViews = mCurrentScrap;
            int size = scrapViews.size();
            if (size &gt; 0) {
                return scrapViews.remove(size - 1);
            } else {
                return null;
            }
        } else {
            int whichScrap = mAdapter.getItemViewType(position);
            if (whichScrap &gt;= 0 &amp;&amp; whichScrap &lt; mScrapViews.length) {
                scrapViews = mScrapViews[whichScrap];
                int size = scrapViews.size();
                if (size &gt; 0) {
                    return scrapViews.remove(size - 1);
                }
            }
        }
        return null;
    }

    public void setViewTypeCount(int viewTypeCount) {
        if (viewTypeCount &lt; 1) {
            throw new IllegalArgumentException(&quot;Can&apos;t have a viewTypeCount &lt; 1&quot;);
        }
        // noinspection unchecked
        ArrayList&lt;View&gt;[] scrapViews = new ArrayList[viewTypeCount];
        for (int i = 0; i &lt; viewTypeCount; i++) {
            scrapViews[i] = new ArrayList&lt;View&gt;();
        }
        mViewTypeCount = viewTypeCount;
        mCurrentScrap = scrapViews[0];
        mScrapViews = scrapViews;
    }

}</code></pre><ul>
<li><p>注释说 RecycleBin 用于view的reuse，它维持了两个存储空间，ActiveViews 和 ScrapViews，前者存放显示在屏幕上的view，到列表最后的时候，它里面的view都会去到 ScrapViews 中。而后者用于存放 old views ，这些view可能可以直接以convertView的形式直接利用，避免没必要的 allocat 内存，这就是Adapter中convertView的由来。</p>
</li>
<li><p>fillActiveViews() :这个方法会根据传入的参数来将 Listview 中指定的元素存储到 mActiveViews 数组中。</p>
</li>
<li><p>getActiveView() :跟 fillActiveViews 方法对应，用于从 mActiveViews 中获取数据，需要注意的是，一旦第 position 个数据被获取成功之后，该view就会从 mActiveViews 中移除，下次再获取第position个位置将会返回 null，也就是说mActiveViews不能复用。</p>
</li>
<li><p>addScrapView() :用于将一个废弃的view进行缓存，当一个view要废弃的时候（比如滚出屏幕），就调用该方法缓存，以便下次使用。</p>
</li>
<li><p>getScrapView() :从 ScrapViews 中取出一个view，这些废弃缓存中的view是没有顺序可言的，因此取的算法也非常简单，获取尾部的就行。</p>
</li>
<li><p>setViewTypeCount() :我们知道在 adapter 中我们可以重写 getViewTypeCount() 来表示Listview中有几种类型的数据项，而setViewTypeCount()的作用就是为每种类型的数据项都单独启用一个 RecycleBin 缓存机制。</p>
</li>
</ul>
<h5 id="扯点view的绘制"><a href="#扯点view的绘制" class="headerlink" title="扯点view的绘制"></a>扯点view的绘制</h5><p>Listview 再牛逼，也是继承自view的，而view的执行流程就是3步，onMeasure() 用于测量 view 的大小，onLayout() 用于确定 View 的布局，onDraw() 用于将 view 绘制到界面上。</p>
<p>Listview 最特殊的地方在于 onLayout() ,而这是在它父类 AbsListview 中实现的，它主要就一个重要判断：如果 Listview 的大小或者位置发生了变化，那就要求所有子布局强制重绘。而 layoutchildren() 方法是用来进行子元素布局的，具体由 Listview 自己实现，可以解析下。</p>
<p>刚开始，Listview 中没有任何子view，因此会去调用 fillActiveViews() 方法，这是为了将 Listview 中的子 view 进行缓存的，由于此时子 view 为空，因此会调用 fillFromTop() ，最终调用到 fillDown() 方法，进行 Listview 的填充操作。fillDown() 中有个while循环，当遍历完从 Listview 顶部到底部的距离的item或者 adapter 中的数据遍历结束，while就跳出。在while中，执行 makeAndAddView() ，它会尝试从 RecycleBin 中快速获取 active view ，但此时 RecycleBin 中还未缓存任何view，因此获得null，所以就会尝试调用 obtainView() ，它是可以保证返回一个 view 的，于是将获取到的view立刻传入到了 setupChild() 中。</p>
<p>那到底 obtainView() 怎么保证获取到view的？不夸张地说，Listview 中最重要的内容都在 obtainView() 中了，该方法里首先调用了 RecycleBin 的 getScrapView() 方法尝试获取一个废弃缓存中的 view ，当然这时候是获取不到的，得到null，之后再调用 mAdapter 的 getView() 方法来获取一个 view ，这时候似曾相识了，有 adapter 和 getView() 方法了，对，就是我们平常写的那个 adapter，然后重写的那个 getView(),这时候会传入 position，convertView (此时为null)，parent (当然是 this 了)。</p>
<h5 id="捋一下item的复用"><a href="#捋一下item的复用" class="headerlink" title="捋一下item的复用"></a>捋一下item的复用</h5><p>一切从 onLayout 开始，当大小或者位置发生了变化，就会调用onLayout，onLayout完毕之后，就剩下 ondraw 去绘制了。onLayout中，（为了叙述方便，不考虑数据不足以填满Listview的情况），首先要拿item的view放到Listview中，先从ActiveViews中拿，如果为空，则打算从 ScrapViews 中拿，还是为空，则利用 adapter 去创造，创造一屏 itemview 填充于 ActiveViews 中，之后 Listview 从 ActiveViews 中取出 itemview ，ActiveViews 删除该 itemview ，如果 itemview 滑动隐藏了，就会丢弃到 ScrapViews 中，这样滑动的时候触发 onLayout ，onLayout 再去找 itemview 填充，如果有现成的就用，没有就创造。 </p>
<h3 id="分析源码谈原因"><a href="#分析源码谈原因" class="headerlink" title="分析源码谈原因"></a>分析源码谈原因</h3><p>再来看源码，为了更方便，加上toast提示：</p>
<pre><code>@Override
public View getView(final int i, View view, ViewGroup viewGroup) {
    ViewHolder viewHolder = null;
    if(view == null){
        viewHolder = new ViewHolder();
        view = LayoutInflater.from(context).inflate(R.layout.layout,null);
        viewHolder.cb = (CheckBox) view.findViewById(R.id.select_cb);
        viewHolder.tvName = (TextView) view.findViewById(R.id.name_tv);
        view.setTag(viewHolder);
    }else{
        viewHolder = (ViewHolder) view.getTag();
    }
    viewHolder.cb.setChecked(data.get(i).isSlected());
    viewHolder.tvName.setText(data.get(i).getName());
    viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
        @Override
        public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked)     {

        Toast.makeText(context,&quot;这是点击了第&quot; + i + &quot;个&quot; ,Toast.LENGTH_SHORT).show();
            data.get(i).setSlected(isChecked);
        }
    });
    return view;
}</code></pre><p>运行之后我们看到整个列表，选中第1个，会弹toast “这是点击了第0个” 接着往上慢慢滑动，直至将第一个item隐藏的时候，发现 toast 弹出来了，显示 <strong>这是点击了第0个</strong>！而这个时候最下面之前被第一条隐藏的item也展现出来了，综合上面的知识，可以知道，这个隐藏的item是复用了第1个item的view，复用view的时候，由于该隐藏item是<strong>未checked</strong>，而第一条item是<strong>已经checked</strong>，因此它执行     </p>
<blockquote>
<p>viewHolder.cb.setChecked(data.get(i).isSlected());</p>
</blockquote>
<p>的时候，会触发 OnCheckedChangeListener ，由于之前第一个 item 设置了监听：</p>
<pre><code>viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            @Override
            public void onCheckedChanged(CompoundButton compoundButton, boolean     isChecked)     {

            Toast.makeText(context,&quot;这是点击了第&quot; + i + &quot;个&quot; ,Toast.LENGTH_SHORT).show();
                data.get(i).setSlected(isChecked);
            }
        });</code></pre><p>这时候就触发了监听事件，因此toast就弹出来了，并且把第一条item的数据也由checked改成unchecked，因此你下次再见到第一个item的时候，状态就变成unchecked了。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>最后可以说结论了，这个现象是由于listview中item复用导致，如果你不用viewholder是不会有这问题的，其实这个结论并不重要，重要的是理解这里面的发生机制。当然，说了问题起因，当然得给个解决方案，方法不止一种，我个人用的一种方法是在</p>
<blockquote>
<p>viewHolder.cb.setChecked(data.get(i).isSlected());</p>
</blockquote>
<p>之前添加一句：</p>
<blockquote>
<p>viewHolder.cb.setOnCheckedChangeListener(null);</p>
</blockquote>
<p>我想你肯定知道为什么。</p>
<p><strong>注：参考（引用）以下博客劳动成果：</strong></p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/44996879" target="_blank" rel="noopener">郭霖 ： Android ListView工作原理完全解析，带你从源码的角度彻底理解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/06/01/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/01/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%8C%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：先从看得到的入手</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-01 08:00:00" itemprop="dateCreated datePublished" datetime="2018-06-01T08:00:00+08:00">2018-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-05-01 16:44:06" itemprop="dateModified" datetime="2019-05-01T16:44:06+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Intent使用"><a href="#Intent使用" class="headerlink" title="Intent使用"></a>Intent使用</h2><p>显式地就不说了，使用隐式的Intent时并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，并帮我们找出合适的活动去启动。</p>
<h3 id="普通的隐式Intent使用"><a href="#普通的隐式Intent使用" class="headerlink" title="普通的隐式Intent使用"></a>普通的隐式Intent使用</h3><p>比如在AndroidManifest.xml中声明activity的时候，可以添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.ACTION_START"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在代码中就能以下面代码来启动这个activity了（由于category是DEFAULT，所以在intent中并未指定category了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.ACTION_START"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>如果在AndroidManifest.xml中声明activity的时候同时指定了<strong>action</strong>和<strong>category</strong>，那么必须要在Intent中严格匹配才能打开，否则可能报错，比如写成：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.ACTION_START"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"com.example.MY_CATEGORY"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>则代码中必须添加以下代码才能正确运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.ACTION_START"</span>);</span><br><span class="line">**intent.addCategory(<span class="string">"com.example.MY_CATEGORY"</span>);**</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h3 id="更多隐式Intent用法"><a href="#更多隐式Intent用法" class="headerlink" title="更多隐式Intent用法"></a>更多隐式Intent用法</h3><p>使用隐式的Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，比如说要在应用程序中点击一个按钮，然后要在浏览器中打开一个网页，则使用以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"http://www.baidu.com"</span>));</span><br><span class="line">startActivity(Intent);</span><br></pre></td></tr></table></figure>

<p>这里面，setData()接收一个Uri对象，主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传入到Uri.parse()方法中解析产生的。那如果我们要自己写个浏览器应用，让其它应用也能像这样利用我们的APP打开网页，又该怎么做呢，这就要求在<intent-filter>中添加一个&lt;data标签&gt;，用于更精确地指定当前活动能够响应什么类型的数据。<data>标签中可以配置以下内容：</p>
<ul>
<li>android:scheme。用于指定数据的协议部分，例如上例中的http部分。</li>
<li>android:host。用于指定数据的主机名部分，如上例中的<a href="http://www.baidu.com。" target="_blank" rel="noopener">www.baidu.com。</a></li>
<li>android:port。用于指定数据的端口部分。</li>
<li>android:path。用于指定主机名和端口之后的部分。</li>
</ul>
<p>所以，如果我们要做一个浏览器，至少要在AndroidManifest.xml对主activity声明：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.ACTION_START"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下次其他APP需要用http协议打开网页时，我们的APP也会在候选列表中了。除了http协议意外，我们还可以指定很多其他协议，比如<strong>geo</strong>表示地理位置、<strong>tel</strong>表示拨打电话。</p>
<h2 id="活动的生命周期"><a href="#活动的生命周期" class="headerlink" title="活动的生命周期"></a>活动的生命周期</h2><ul>
<li>onCreate()，活动第一次被创建的时候调用，应该在这里面完成活动的初始化操作。</li>
<li>onStart()，在活动由不可见变为课件的时候调用。</li>
<li>onResume()，在活动准备好和用户进行交互的时候调用，此时活动一定位于返回栈的栈顶，并且处于运行状态。</li>
<li>onPause()，在系统准备去启动或者恢复另一个活动的时候调用，通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但是工作不能太多，不然会影响下一个Activity的使用。</li>
<li>onStop(),活动完全不可见的时候调用，它和onPause主要的区别在于，如果启动的新活动是一个对话框式的活动，那么onPause方法会得到执行，而onStop不会执行。</li>
<li>onDestroy()，活动晓辉之前调用。</li>
<li>onRestart()，由停止状态变为运行状态之前调用。一般是由上一个活动返回到当前活动。</li>
</ul>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-2/%E5%9B%BE1.png" alt="Activity声明周期"></p>
<h3 id="活动回收了怎么办"><a href="#活动回收了怎么办" class="headerlink" title="活动回收了怎么办"></a>活动回收了怎么办</h3><p>想象以下场景，应用中有活动A，在A的基础上启动活动B，活动A此时进入了停止状态，此时由于内存不足，将活动A回收了，然后用户按Back键返回活动A，会出现什么情况呢？其实还是会正常显示A，只不过这是并不会执行onRestart方法，而是会执行活动A的onCreate方法，因为活动A在这种情况下会被重新创建一次。</p>
<p>如果A进程中有输入框，并且已经输入了一些文字了，如果回收被重新创建，那么会丢失输入的信息，影响用户体验。Activity中还提供了一个onSaveInstanceState()回调方法，这个方法可以保证在活动回收之前一定会被调用，这个方法会携带一个Bundle类型的参数，它允许以key-value的形式存取值，我们可以这样将要保存的数据存下来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">        outState.putString(<span class="string">"name"</span>,<span class="string">"glassx"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>数据已经保存下来了，但是在哪里恢复呢？其实我们一直使用的onCreate方法其实也有一个Bundle类型的参数，这个参数一般情况下是null，如果在活动呗系统回收之前有通过onSaveInstanceState保存的话，这个参数就会带有之前所保存的全部数据，因此通过以下方法取即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(savedInstanceState != <span class="keyword">null</span>)&#123;</span><br><span class="line">        	String name = savedInstanceState.getString(<span class="string">"glassx"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h2><p>在实际项目中我们应该根据特定的需求为每个活动指定恰当的启动模式，启动模式一种四种：<strong>standard、singleTop、singleTask、singleInstance</strong>。</p>
<ul>
<li><p>standard是默认的启动模式。每次启动都会创建一个新的实例。</p>
</li>
<li><p>singleTop：有些情况下，可能会觉得standard不太合理，活动明明已经在栈顶了，为毛还要再创建新的实例呢？singleTop模式可以解决这个问题，当活动以该模式启动时，如果发现返回栈的栈顶已经是该活动，那就直接使用它，不创建新的实例，并且调用栈顶实例的<strong>onNewIntent</strong>方法；如果栈顶不是该活动，就创建该活动的新的实例。</p>
</li>
<li><p>singleTask：如果活动的启动模式指定为singleTask，那么每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果有，把这个活动之上的所有活动统统出栈，并且直接使用该实例，并调用该实例的<strong>onNewIntent</strong>方法？？（存疑，等会实践下）。反之没有的话就创建该活动的实例。</p>
</li>
<li><p>singleInstance：指定为singleInstance模式的活动会启用一个新的返回栈来管理这个活动（其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈）。</p>
<blockquote>
<p>那么这样做有什么意义呢？想象以下场景，我们的程序中有一个活动是允许其他程序调用的，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，应该如何实现呢？前面3中模式做不到，因为每个应用程序都会有自己的返回栈，同一个活动在不同的返回栈中入栈必然是创建了新的实例。而使用singleInstance模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活动，不管哪个应用来访问这个活动，都公用一个返回栈，也就解决了共享活动实例的问题。</p>
</blockquote>
</li>
</ul>
<p><strong>注意：如果三个活动，A和C都是standard模式，B是singleInstance模式，那么A启动B，B启动C后，在C界面按返回键是回退到A，再按返回键回退到B，接着按返回键才会退出应用，因为A和C是同一个回退栈中，B单独在一个栈中，可以用如下图来理解这一过程</strong>。</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-2/%E5%9B%BE2.png" alt="Activity声明周期"></p>
<h2 id="活动的最佳实践"><a href="#活动的最佳实践" class="headerlink" title="活动的最佳实践"></a>活动的最佳实践</h2><h3 id="知晓当前是在哪一个活动"><a href="#知晓当前是在哪一个活动" class="headerlink" title="知晓当前是在哪一个活动"></a>知晓当前是在哪一个活动</h3><p>建一个BaseActivity，在onCreate的时候打印出来当前实例的类名，之后其他的activity都继承这个activity即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        </span><br><span class="line">        Log.d(<span class="string">"BaseActivity"</span>,getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="随时随地退出app"><a href="#随时随地退出app" class="headerlink" title="随时随地退出app"></a>随时随地退出app</h3><p>如果你在第三个activity界面，这个时候想要退出App是非常不方便的，可以新建一个类来管理所有Activity：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityController</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Activity&gt; activities = <span class="keyword">new</span> ArrayList&lt;Activity&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addActivity</span><span class="params">(Activity ac)</span></span>&#123;</span><br><span class="line">		activities.add(ac);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeActivity</span><span class="params">(Activity ac)</span></span>&#123;</span><br><span class="line">		activities.remove(ac);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finishAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Activity ac : activities)&#123;</span><br><span class="line">			ac.finish();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样只需要在BaseActivity的onCreate里面执行ActivityController的<strong>addActivity</strong>方法，即可把Activity添加进去，在BaseActivity的onDestroy方法中执行<strong>removeActivity</strong>，将其移除，在需要退出app的时候，只需要执行finishAll即可。</p>
<h3 id="启动活动最佳写法"><a href="#启动活动最佳写法" class="headerlink" title="启动活动最佳写法"></a>启动活动最佳写法</h3><p>每个Activity中都写上启动自己的方法：</p>
<pre><code class="Java">
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span></span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">actionStart</span><span class="params">(Context context,String name,String sex)</span></span>{
        Intent intent  = <span class="keyword">new</span> Intent(context,TestActivity.class);
        intent.putExtra(<span class="string">"name"</span>,name);
        intent.putExtra(<span class="string">"sex"</span>,sex);
        context.startActivity(intent);
    }
}</code></pre>
<p>这样做的一个好处就是，启动这个activity所需要的参数一目了然，而无需阅读这个activity的源码就可以直接调用方法就能避免漏掉参数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2018/05/31/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/31/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">第1章：开启启程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-31 18:00:00" itemprop="dateCreated datePublished" datetime="2018-05-31T18:00:00+08:00">2018-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-05-01 16:43:32" itemprop="dateModified" datetime="2019-05-01T16:43:32+08:00">2019-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h4><ol>
<li><p>最底层是Linux内核层。</p>
<blockquote>
<p>为Android设备各种硬件提供了底层驱动，如显示驱动，音频驱动等。</p>
</blockquote>
</li>
<li><p>系统运行库层。</p>
<blockquote>
<p>这层通过一些C/C++库来为Android系统提供主要的特性支持。如Sqlite库提供了数据库支持，OpenGL|ES提供提供3D绘图等。</p>
</blockquote>
</li>
<li><p>应用框架层。</p>
<blockquote>
<p>主要提供了构建应用程序可能用到的各种API。</p>
</blockquote>
</li>
<li><p>应用层。</p>
<blockquote>
<p>所有安装在手机上的应用程序都属于这一层。比如系统自带的联系人、短信等程序，自己开发的应用。</p>
</blockquote>
</li>
</ol>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-1/%E5%9B%BE1.png" alt="Android系统层次"></p>
<h3 id="Android应用开发特色"><a href="#Android应用开发特色" class="headerlink" title="Android应用开发特色"></a>Android应用开发特色</h3><h4 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h4><p>四大组件分别是活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）和内容提供器（Content Provider）</p>
<p>build.gradle 文件中，<strong>compileSdkVersion</strong>用于指定项目的编译版本；<strong>buildToolsVersion</strong>用于指定项目构建工具的版本；<strong>applicationId</strong>用于指定项目的包名，并且它的优先级高于在 AndroidManifest.xml<br>中指定的包名；<strong>minSdkVersion</strong>用于指定项目最低兼容的Android版本;<strong>targetSdkVersion</strong>表明你在该目标版本上做过了充分的测试，系统将为你的应用程序启用一些最新的功能和特性。比如说Android6.0 系统中引入了运行时权限这个功能，如果你将targetSdkVersion指定成23或者更高，那么系统就会为你的程序启用运行时权限功能；否则就不会启用运行时权限功能。</p>
<p>而在build.gradle的<strong>dependencies</strong>闭包中，声明了当前项目所有的依赖关系，Android studio 项目一共有3中依赖方式，本地依赖、库依赖和远程依赖，本地依赖可以对本地的jar包或者目录添加依赖关系，形式如：<strong>compile fileTree(dir: ‘libs’, include: [‘*.jar’])</strong>；库依赖可以对项目中的库模块添加依赖关系，如<strong>compile(name: ‘testsdk’, ext: ‘aar’)</strong>；远程依赖则可以对jcenter库上的开源项目添加依赖关系，如<strong>compile ‘com.android.support.constraint:constraint-layout:1.0.2’</strong>，其中，com.android.support.constraint是域名，用于和其他公司的库作区分，constraint-layout是组名称，用于和同一个公司其他库作区分。</p>
<p><strong>关于日志：</strong>不用System.out.println()，因为Log系统可以对日志分级，可以展示打印时间，可以添加过滤器等等。<strong>Log快捷键：如果要打Log.d，则输入logd，按tab键即可，同理Log.i只需要logi之后按Tab键，以此类推，四种级别的日志都能快捷打出来。还有，如果在oncreate方法外面输入logt，然后按下Tab键，就会以当前的类名作为值自动生成一个类似下面的TAG常量：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"HelloWorldActivity"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="glassx"
    src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail &amp;rarr; mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo &amp;rarr; https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.2"></script><script src="/js/motion.js?v=7.4.2"></script>
<script src="/js/schemes/pisces.js?v=7.4.2"></script>
<script src="/js/next-boot.js?v=7.4.2"></script>



  






  <script src="/js/local-search.js?v=7.4.2"></script>













  

  

  

</body>
</html>

<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
