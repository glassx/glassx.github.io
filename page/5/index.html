<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/5/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">148</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/08/12/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/12/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：面向对象</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-12 10:25:00 / 修改时间：18:21:29" itemprop="dateCreated datePublished" datetime="2021-08-12T10:25:00+08:00">2021-08-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h2><h3 id="Kotlin-中的类及接口"><a href="#Kotlin-中的类及接口" class="headerlink" title="Kotlin 中的类及接口"></a>Kotlin 中的类及接口</h3><p> Kotlin中的类与Java的很像：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> weight: <span class="built_in">Double</span> = <span class="number">500.0</span></span><br><span class="line">	<span class="keyword">val</span> color: String = <span class="string">"blue"</span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>反编译成Java的版本：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> double weight = <span class="number">500.0D</span>;</span><br><span class="line">	<span class="meta">@NotNull</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String color = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> double getWeight() {</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@NotNull</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> String getColor() {</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> void fly() {</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由此可以看出，虽然声明方式很像，但是也存在很多不同：</p>
<ul>
<li>属性默认值。Kotlin中，除非显式声明延迟初始化，不然就需要指定默认值。</li>
<li>不同的可访问修饰符。Kotlin类中的成员默认是全局可见的(public)，而Java默认可见域是包作用域。  </li>
<li>方法默认是final修饰的。意味着不能覆写(这条是自己添加的)。</li>
</ul>
<p><strong>可带有属性和默认方法的接口</strong></p>
<p>我们知道，Java 8 之后，接口支持<strong>默认实现</strong>，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flayer</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">kind</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>{</span><br><span class="line">	    System.out.println(<span class="string">"I can fly"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来看下Kotlin的接口实现：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> speed: <span class="built_in">Int</span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> {</span><br><span class="line">	    println(<span class="string">"I can fly"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同样，<strong>我们可以用Kotlin 定义一个带有方法实现的接口</strong>，同时，它还支持抽象属性（如例子中的speed属性），然而，Kotlin是基于Java6实现的，那它是如何支持的呢？转换为Java代码看下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getSpeed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">kind</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultImpls</span> </span>{</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(Flyer $<span class="keyword">this</span>)</span> </span>{</span><br><span class="line">	        String var1 = <span class="string">"I can fly"</span>;</span><br><span class="line">	        System.out.println(var1);</span><br><span class="line">	    }</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由此我们发现，Kotlin编译器<strong>通过定义一个静态内部类 DefaultImpls 来提供fly方法的默认实现</strong>。同时，<strong>抽象属性是通过一个get方法来实现的！</strong>所以呢，我们不能像Java一样，为属性直接赋值，如下这样是错误的：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> height = <span class="number">1000</span>;<span class="comment">//error Property initializers are not allowed in interfaces</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是Kotlin 提供了另外一种方式来实现这种效果：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> height</span><br><span class="line">	    <span class="keyword">get</span>() = <span class="number">1000</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="更简洁地构造类的对象"><a href="#更简洁地构造类的对象" class="headerlink" title="更简洁地构造类的对象"></a>更简洁地构造类的对象</h3><p>如果要在Java中实现参数个数不同的构造方法，那我们就要重载很多个构造方法，这种方式主要存在2个缺点：</p>
<ul>
<li>如果要支持任意参数组合来创建对象，那么需要实现的构造方法非常多</li>
<li>每个构造方法中的代码都会冗余，如在构造方法中可能都需要对 age 和color 进行相同的赋值操作。</li>
</ul>
<p>Kotlin 通过引入新的构造语法来解决这些问题。比如我们可以用一行代码来表示复杂的构造方式：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span> = <span class="number">0.00</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">0</span>, <span class="keyword">val</span> color: String = <span class="string">"blue"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>如果用Java实现这种参数任意组合的效果，那是非常复杂的。但是如果不写入全部的参数，而只用其中某些参数的时候，需要写参数名，否则会报错：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的</span></span><br><span class="line"><span class="keyword">val</span> bird1 = Bird(<span class="number">1000.00</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确示例</span></span><br><span class="line"><span class="keyword">val</span> bird2 = Bird(weight = <span class="number">1000.00</span>, color = <span class="string">"black"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>init方法：事实上，<strong>我们的构造方法可以拥有多个 init，他们会在对象创建时按照类中从上到下的顺序先后执行</strong></p>
<p><strong>延迟初始化： by lazy 和 lateinit</strong></p>
<p>在Kotlin中，主要使用lateinit 和 by lazy 这两种语法来实现延迟初始化的效果。如果这是一个用 val 声明的变量，我们用 by lazy 来修饰：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> color: String) {</span><br><span class="line">	<span class="keyword">val</span> sex: String <span class="keyword">by</span> lazy {</span><br><span class="line">	    <span class="keyword">if</span>(color == <span class="string">"yellow"</span>) <span class="string">"male"</span> <span class="keyword">else</span> <span class="string">"female"</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结 by lazy 语法的特点如下：</p>
<ul>
<li>该变量必须是引用不可变的，而不能通过var声明</li>
<li>被首次调用时，才会进行赋值操作，一旦赋值，后续将不能更改。</li>
</ul>
<p>需要注意的是，系统会给 lazy属性默认加上同步锁，也就是 LazyThreadSafetyMode.SYNCHRONIZED ，它在同一时刻只允许一个线程对lazy属性初始化，<strong>所以，lazy是线程安全的</strong>。当然，你可以自己给lazy指定参数，如： <code>val sex: String by lazy(LazyThreadSafetyMode.NONE)</code>。</p>
<p>与lazy 不同，<strong>lateinit 主要用于 var 声明的变量，然而它不能用于基本数据类型，如 Int、Long 等</strong>，我们需要使用Integet这种包装类作为替代。lateinit 的用法如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> color: String) {</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> sex: String</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">printSex</span><span class="params">()</span></span> {</span><br><span class="line">	    sex = <span class="keyword">if</span>(color == <span class="string">"yellow"</span>) <span class="string">"male"</span> <span class="keyword">else</span> <span class="string">"female"</span></span><br><span class="line">	    println(sex)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Kotlin只用一个构造方法实现了Java中需要重载才能实现的功能，那么，Kotlin中是否真的只需要一个构造方法呢？</p>
<h3 id="主从构造方法"><a href="#主从构造方法" class="headerlink" title="主从构造方法"></a>主从构造方法</h3><p>前面似乎遗漏了一些情况，简化前面的Bird类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(age: <span class="built_in">Int</span>) {</span><br><span class="line">	<span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">init</span> {</span><br><span class="line">	    <span class="keyword">this</span>.age = age</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>假设当前我们知道鸟的生日，希望可以通过生日来得到鸟的年龄，然后创建一个Bird对象，如何实现？有一种方案就是在别处定义一个工厂方法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Bird</span><span class="params">(birth: <span class="type">DateTme</span>)</span></span> = Bird(getAgeByBirth(birth))</span><br></pre></td></tr></tbody></table></figure>

<p>在哪声明这个工厂方法呢？这种方式的缺点在于，Bird 方法与Bird类在代码层面的分离不够直观。其实我们可以像Java那样新增一个构造方法来解决，Kotlin 也支持多构造方法，与Java的区别是，<strong>Kotlin中多个构造方法之间存在主从关系</strong>：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(age: <span class="built_in">Int</span>) {</span><br><span class="line">	<span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">init</span> {</span><br><span class="line">	    <span class="keyword">this</span>.age = age</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">constructor</span>(birth: DateTime) : <span class="keyword">this</span>(getAgeByBirth(birth)){</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码的运作方式是：</p>
<ul>
<li>通过constructor方法定义一个新的构造方法，称为<strong>从构造方法</strong>。相应地，我们熟悉的构造方法叫做<strong>主构造方法</strong>，每个类最多存在一个主构造方法，但是可以存在多个从构造方法</li>
<li>如果一个类存在主构造方法，那么每个从构造方法都要直接或间接地委托给它。</li>
</ul>
<h2 id="不同的访问控制原则"><a href="#不同的访问控制原则" class="headerlink" title="不同的访问控制原则"></a>不同的访问控制原则</h2><p>构造完对象，就要考虑访问控制了。</p>
<h3 id="限制修饰符"><a href="#限制修饰符" class="headerlink" title="限制修饰符"></a>限制修饰符</h3><p>我们知道，Kotlin中的类和方法默认实现反编译成 Java的时候，会被final修饰，所以，类默认是不能被继承的，方法默认也不能被覆写的，如果要实现继承，类之前需要用open修饰： <code>open class Bird {}</code> ，方法也需要使用open 修饰： <code>open fun fly()</code> </p>
<h4 id="类默认final-真的好吗？"><a href="#类默认final-真的好吗？" class="headerlink" title="类默认final 真的好吗？"></a>类默认final 真的好吗？</h4><p>网上有很多人认为默认final有很多缺点，那为什么Kotlin要设计成默认final呢？主要有2个原因：</p>
<ul>
<li>Kotlin 当前是一门以Android为平台的开发语言，在开发中，我们很少会频繁继承一个类，默认final会更加安全。</li>
<li>Kotlin的扩展手段更加丰富。不像Java，Kotlin 可以通过多种方式去扩展，而不是通过原始类的手段，典型的莫过于 Android 的Kotlin 扩展库 android-ktx，Google就是通过Kotlin的扩展语法而不是继承来实现。</li>
</ul>
<p>此外，Kotlin还可以利用<strong>密封类</strong>来限制一个类的继承，如下所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> = <span class="string">"I can fly"</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Eagle</span>: <span class="type">Bird</span></span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Kotlin通过 <strong>sealed 关键字</strong>来修饰一个类为密封类，<strong>若要继承则需要将子类定义在同一个文件中，其他文件中的类将无法继承它</strong>。但是这种方式有它的局限性，即它不能被初始化，为什么呢？<strong>这是因为它是基于抽象类实现的</strong>，我们看反编译后的Java代码就知道了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Bird</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(DefaultConstructorMarker $constrctor_maker)</span> </span>{</span><br><span class="line">	    <span class="keyword">this</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Eagle</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">Eagle</span><span class="params">()</span> </span>{</span><br><span class="line">	        <span class="keyword">super</span>((DefaultConstructorMarker)<span class="keyword">null</span>)</span><br><span class="line">	    }</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>密封类的使用场景优先，它其实可以看成一种功能更强大的枚举，所以它在模式匹配中可以起到很大的作用</strong>。</p>
<h3 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h3><p>除了限制类修饰符外，还有一种可见性修饰符。Kotlin与Java的不同在于：</p>
<ul>
<li>默认修饰符不同，Kotlin是public，而Java是default</li>
<li>Kotlin中有一个独特的 internal    </li>
<li>Java类只有内部类可以用private修饰，其他类不允许；而Kotlin可以</li>
<li>protected访问范围不同。<strong>Java中是包、类及子类可访问，而Kotlin只有类和子类可以访问</strong>。</li>
</ul>
<p>说下Kotlin 独特的 internal 修饰符，它的作用域被称作<strong>模块内访问</strong>，那到底什么是模块？以下几种情况可以算作一个模块：</p>
<ul>
<li>一个Eclipse项目</li>
<li>一个 Intellij IDEA项目</li>
<li>一个Maven项目</li>
<li>一个Gradle项目</li>
<li>一组由一次Ant任务执行编译的代码</li>
</ul>
<p>那为什么要这种修饰符呢？Java的包内访问不好吗？Java包内访问确实是有问题的，举个例子，你再Java项目中定义了一个类，默认修饰符，那就是包私有的，其他地方将无法访问。然后你id啊宝诚一个类库，供三方使用。但如果有个开发者想使用这个类，除了copy源码以外，还有一个方式就是<strong>在程序中创建一个与该类相同名字的包，那么这个包下面的其他类就能直接使用我们前面定义的类了！</strong></p>
<p>而Kotlin这种，模块内可见指的是该类只对一起编译的其他Kotlin文件可见，开发工程与第三方类库不属于同一模块，这时候如果还想用，就只能复制源码了。</p>
<p>Java中我们很少见到private修饰的类，因为Java中的类或者方法没有单独属于某个文件的概念。若要用provate修饰，那么这个只能是其他类的内部类，而Kotlin中则可以用private给单独的类修饰，它的作用域就是当前这个Kotlin文件：</p>
<h2 id="解决多继承问题"><a href="#解决多继承问题" class="headerlink" title="解决多继承问题"></a>解决多继承问题</h2><p>Java和Kotlin都不支持多继承。为什么这样呢？是因为多继承会导致继承关系语义上的混淆。</p>
<h3 id="骡子的多继承困惑"><a href="#骡子的多继承困惑" class="headerlink" title="骡子的多继承困惑"></a>骡子的多继承困惑</h3><p>C++支持多继承，然而C++中存在一个经典的<strong>钻石问题</strong>。假如我们有个抽象的 Animal 类，它有个 run() 方法，Horse （马） 和 Donkey（驴） 都继承了Animal，假如支持多继承，Mule（驴）继承了 Horse 和 Donkey ，那么，在 Mule 中的 run() 到底是继承了谁的呢？这就是典型的钻石问题，因为继承关系像个钻石图，如下：</p>
<p><img src="/assets/Book-Notes/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0/%E9%92%BB%E7%9F%B3%E9%97%AE%E9%A2%98.png" alt="钻石问题"></p>
<h3 id="接口实现多继承"><a href="#接口实现多继承" class="headerlink" title="接口实现多继承"></a>接口实现多继承</h3><p>在Java中我们经常提及使用接口来实现多继承，其实，如果多个接口中都存在同样的方法，比如上述的 run() ，同样也会导致钻石问题。不过，<strong>Kotlin 通过提供 super 关键字来指定继承那个父接口的方法，从而解决了这个问题</strong>，如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="string">"flying animals"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="string">"flying animals"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(): Flyer, Animal {</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="keyword">super</span>&lt;Flyer&gt;.kind()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过 <code>super&lt;Flyer&gt;.kind()</code>来指定继承哪个父接口的方法！当然，子类也可以自己实现这个方法，不用父类的，完全没问题。</p>
<h3 id="内部类解决多继承问题"><a href="#内部类解决多继承问题" class="headerlink" title="内部类解决多继承问题"></a>内部类解决多继承问题</h3><p>Kotlin的内部类的定义方式和Java 还不一样，如果我们按照Java的习惯来定义 Kotlin中的内部类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterKotlin</span> </span>{</span><br><span class="line">  <span class="keyword">val</span> name = <span class="string">"not kotlin inner class"</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ErrorInnerKotlin</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span> {</span><br><span class="line">      print(<span class="string">"thie name is <span class="variable">$name</span>"</span>)<span class="comment">//报错，不能访问name</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>报错了，和Java 还真不一样。其实，我们这样声明的是Kotlin 的 <strong>嵌套类</strong>，并非内部类。如果要在Kotlin中声明一个内部类，必须在这个类前面加一个 inner 关键字，即这样子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterKotlin</span> </span>{</span><br><span class="line">  <span class="keyword">val</span> name = <span class="string">"kotlin inner class"</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerKotlin</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span> {</span><br><span class="line">      print(<span class="string">"thie name is <span class="variable">$name</span>"</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>我们知道，Java中在内部类的语法上增加一个 static 关键字，就可以变成 嵌套类；Kotlin则是相反的思路，默认是嵌套类，必须加上 inner 关键字才是一个内部类。</p>
</blockquote>
<p>了解内部类之后，可以通过内部类实现上述的骡子类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mule</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">runFast</span><span class="params">()</span></span> {</span><br><span class="line">    HorseC().runFast()</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">runSlow</span><span class="params">()</span></span> {</span><br><span class="line">    DonkeyC().runSlow()</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseC</span>: <span class="type">Horse</span></span>()</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">DonkeyC</span>: <span class="type">Donkey</span></span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用委托代替多继承"><a href="#使用委托代替多继承" class="headerlink" title="使用委托代替多继承"></a>使用委托代替多继承</h3><p><strong>Kotlin中的委托只需要通过 by 关键字就可以实现，比如之前学习的 by lazy 语法，其实就是利用了委托实现了延迟初始化</strong>。我们看下如何通过委托代替多继承需求：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Caneat</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyer</span>: <span class="type">CanFly {</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> {</span><br><span class="line">    println(<span class="string">"I can fly"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> : <span class="type">CanEat {</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    println(<span class="string">"I can eat"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(flyer: Flyer, animal: Animal): CanFly <span class="keyword">by</span> flyer, CanEat <span class="keyword">by</span> animal {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">  <span class="keyword">val</span> fyler = Flyer()</span><br><span class="line">  <span class="keyword">val</span> animal = Animal()</span><br><span class="line">  <span class="keyword">val</span> b = Bird(flyer, animal)</span><br><span class="line">  b.fly()</span><br><span class="line">  b.eat()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="真正的数据类"><a href="#真正的数据类" class="headerlink" title="真正的数据类"></a>真正的数据类</h2><h3 id="繁琐的JavaBean"><a href="#繁琐的JavaBean" class="headerlink" title="繁琐的JavaBean"></a>繁琐的JavaBean</h3><p>JavaBean中需要各种setter和getter，如果要支持对象值的比较，还得重写hashCode 和 equals 等方法。</p>
<h3 id="用data-class创建数据类"><a href="#用data-class创建数据类" class="headerlink" title="用data class创建数据类"></a>用data class创建数据类</h3><p>data class 顾名思义就是<strong>数据类</strong>，这不是Kotlin首创，在Scala等语言中也有。一般我们只需要如下定义即可：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">var</span> weight: <span class="built_in">Double</span>, <span class="keyword">var</span> age: <span class="built_in">Int</span>, <span class="keyword">var</span> color: String)</span><br></pre></td></tr></tbody></table></figure>

<p>这么一行代码，编译器为我们做了很多事情，来看看反编译后的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">double</span> var1)</span> </span>{</span><br><span class="line">      <span class="keyword">this</span>.weight = var1;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>{</span><br><span class="line">      <span class="keyword">this</span>.age = var1;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getColor</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="meta">@NotNull</span> String var1)</span> </span>{</span><br><span class="line">      Intrinsics.checkNotNullParameter(var1, <span class="string">"&lt;set-?&gt;"</span>);</span><br><span class="line">      <span class="keyword">this</span>.color = var1;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(<span class="keyword">double</span> weight, <span class="keyword">int</span> age, <span class="meta">@NotNull</span> String color)</span> </span>{</span><br><span class="line">      Intrinsics.checkNotNullParameter(color, <span class="string">"color"</span>);</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.weight = weight;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">      <span class="keyword">this</span>.color = color;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">component1</span><span class="params">()</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">component2</span><span class="params">()</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">component3</span><span class="params">()</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Bird <span class="title">copy</span><span class="params">(<span class="keyword">double</span> weight, <span class="keyword">int</span> age, <span class="meta">@NotNull</span> String color)</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      Intrinsics.checkNotNullParameter(color, <span class="string">"color"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Bird(weight, age, color);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Bird copy$<span class="keyword">default</span>(Bird var0, <span class="keyword">double</span> var1, <span class="keyword">int</span> var3, String var4, <span class="keyword">int</span> var5, Object var6) {</span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">1</span>) != <span class="number">0</span>) {</span><br><span class="line">         var1 = var0.weight;<span class="comment">//copy时，若未指定具体属性的值，则使用被copy对象的属性值，这是浅拷贝</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">2</span>) != <span class="number">0</span>) {</span><br><span class="line">         var3 = var0.age;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">4</span>) != <span class="number">0</span>) {</span><br><span class="line">         var4 = var0.color;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var0.copy(var1, var3, var4);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Bird(weight="</span> + <span class="keyword">this</span>.weight + <span class="string">", age="</span> + <span class="keyword">this</span>.age + <span class="string">", color="</span> + <span class="keyword">this</span>.color + <span class="string">")"</span>;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">int</span> var10000 = (Double.hashCode(<span class="keyword">this</span>.weight) * <span class="number">31</span> + Integer.hashCode(<span class="keyword">this</span>.age)) * <span class="number">31</span>;</span><br><span class="line">      String var10001 = <span class="keyword">this</span>.color;</span><br><span class="line">      <span class="keyword">return</span> var10000 + (var10001 != <span class="keyword">null</span> ? var10001.hashCode() : <span class="number">0</span>);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="meta">@Nullable</span> Object var1)</span> </span>{</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> != var1) {</span><br><span class="line">         <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Bird) {</span><br><span class="line">            Bird var2 = (Bird)var1;</span><br><span class="line">            <span class="keyword">if</span> (Double.compare(<span class="keyword">this</span>.weight, var2.weight) == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.age == var2.age &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.color, var2.color)) {</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这就和JavaBean很相似了，同时还有 equals 和 hashCode 的实现。同时，我们发现里面有几个JavaBean中没有的方法，比如 copy、component1、component2、component3。下一节来介绍它们。</p>
<h3 id="copy-、componentN-与-结构"><a href="#copy-、componentN-与-结构" class="headerlink" title="copy 、componentN 与 结构"></a>copy 、componentN 与 结构</h3><p>上上述代码可以看到，两个copy方法，可以传入响应的参数来生成不同的对象；同时，如果你未指定具体属性的值，那么新生成的对象的属性值将使用被copy对象的属性值，这就是我们常说的浅拷贝。看个例子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果Bird的属性是var，即可变的</span></span><br><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>,<span class="number">1</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="keyword">val</span> b2 = b1</span><br><span class="line">b2.age = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果Bird的属性是val，不可变的，那么更改属性只能通过copy</span></span><br><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>,<span class="number">1</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="keyword">val</span> b2 = b1.copy(age = <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>



<p><strong>注意，Kotlin提供的上述copy方法是浅拷贝的，所以我们要注意使用场景。</strong>因为数据类的属性可以被修饰为var，所以不能保证不会出现引用被修改的情况。</p>
<p>接下来看 componentN (其中N为1，2，3…，根据参数个数来定)，这个设计到底有什么用？我们或多或少直到怎么将属性绑定到类上，但是对于如何将类的属性绑定到响应变量上却不是很熟悉，比如：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>,<span class="number">1</span>, <span class="string">"blue"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通常方法，也符合Java的思维逻辑</span></span><br><span class="line"><span class="keyword">val</span> weight = b1.weight</span><br><span class="line"><span class="keyword">val</span> age = b1.age</span><br><span class="line"><span class="keyword">val</span> color = b1.color</span><br><span class="line"></span><br><span class="line"><span class="comment">//Kotlin 进阶方法</span></span><br><span class="line"><span class="keyword">val</span> (weight, age, color) = b1</span><br></pre></td></tr></tbody></table></figure>

<p>看到进阶方法的时候，一定感到兴奋了吧，普通方法确实很繁琐。还有一种情形，看Java的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String birdInfo = <span class="string">"20.0,1, blue"</span>;</span><br><span class="line"><span class="comment">//如果要把值取出来，就得split</span></span><br><span class="line">String[] temps = birdInfo(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">double</span> weight = Double.valueOf(temps[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> age = Integer.valueOf(temps[<span class="number">1</span>]);</span><br><span class="line">String color = temps[<span class="number">2</span>];</span><br></pre></td></tr></tbody></table></figure>

<p>在我们明明直到值得情况下，还需要这样分割，很繁琐，好在Kotlin提供了更优雅的做法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (weight, age, color) = birdInfo.split(<span class="string">","</span>)</span><br></pre></td></tr></tbody></table></figure>



<p>这个语法也很简洁和直观，其原理也很简单，就是 <strong>解构</strong>，通过编译器的约定实现解构。当然，<strong>Kotlin对于解构也有限制，在数组中它默认最多允许赋值5个变量，因为如果变量过多，效果反而会适得其反，因为到后期你都搞不清哪个值要赋给哪个变量了</strong>。除了利用编译器自动生成的 componentN之外，你还可以实现自己的 componentN，比如：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">var</span> weight: <span class="built_in">Double</span>, <span class="keyword">var</span> age: <span class="built_in">Int</span>, <span class="keyword">var</span> color: String) {</span><br><span class="line">  <span class="keyword">var</span> sex = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> component4: <span class="built_in">Int</span> {//注意 <span class="keyword">operator</span> 关键字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sex</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(weight: <span class="built_in">Double</span>, age: <span class="built_in">Int</span>, color: String, sex: <span class="built_in">Int</span>) : <span class="keyword">this</span>(weight, age, color) {</span><br><span class="line">    <span class="keyword">this</span>.sex = sex</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//使用</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">    <span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>, <span class="number">1</span>, <span class="string">"blue"</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> (weight, age, color, sex) = b1</span><br><span class="line">    ...</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>除了数组支持解构外，Kotlin也提供了其他常用数据类型，分别是 Pair 和 Triple 前者是二元组，后者是 三元组，，我们可以</p>
<p>用类似以下方法来使用它们：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pair = Pair(<span class="number">20.0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">//利用属性顺序获取</span></span><br><span class="line"><span class="keyword">val</span> weightP = pair.first</span><br><span class="line"><span class="keyword">val</span> ageP = pair.second</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用解构</span></span><br><span class="line"><span class="keyword">val</span> (weightP, ageP) = Pair(<span class="number">20.0</span>,<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>



<h2 id="从static-到-object"><a href="#从static-到-object" class="headerlink" title="从static 到 object"></a>从static 到 object</h2><p>Kotlin中告别了static，因为有了 object 关键字，除了替代static外，它还有更多的功能实现，比如单例对象以及简化匿名表达式等。</p>
<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>看一段常见的Java代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prize</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> TYPE_REDPACK = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRedpack</span><span class="params">(Prize prize)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> prize.type == TYPE_REDPACK;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这个类中既有静态变量、静态方法，也有普通变量、普通方法，然而，静态变量和静态方法是属于类的，普通变量和普通方法是属于具体对象的，所以在代码解构上职能并不清晰。Kotlin中利用 companion object 两个关键字引入伴生对象来清晰区分。</p>
<blockquote>
<p>顾名思义，“伴生”即伴随某个类的对象，它属于这个类所有，全局只有一个单例，因此伴生对象跟Java中static修饰的效果一样，<strong>在类装载的时候被初始化</strong>。</p>
</blockquote>
<p>companion object 用花括号包裹了所有静态属性和方法，使得将普通方法和属性清晰区分开来。此外，伴生对象很适合作为工厂，这里就不展开。</p>
<h3 id="天生的单例：-object"><a href="#天生的单例：-object" class="headerlink" title="天生的单例： object"></a>天生的单例： object</h3><p>单例模式最大的一个特点就是在系统中只能存在一个实例对象，所以在java中我们必须通过设置构造方法私有化，以及提供静态方法创建实例的方式来创建单例。在Kotlin中，由于object的存在，我们可以直接用它来实现单例，如下所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DatabaseConfig {</span><br><span class="line">  <span class="keyword">var</span> host: String = <span class="string">"127.0.0.1"</span></span><br><span class="line">  <span class="keyword">var</span> port: <span class="built_in">Int</span> = <span class="number">3306</span></span><br><span class="line">  <span class="keyword">var</span> userName: String = <span class="string">"root"</span></span><br><span class="line">  <span class="keyword">var</span> password: String = <span class="string">""</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>由于object全局声明的对象只有一个，所以它并不用语法上的初始化，甚至都不需要构造方法，因此，我们可以说object创造的是天生的单例</strong>。此外，由于 DatabaseConfig 的属性是 var 声明的属性，我们还能修改它们： </p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatabaseConfig.host = <span class="string">"localhost"</span></span><br><span class="line">DatabaseConfig.port = <span class="number">3307</span></span><br></pre></td></tr></tbody></table></figure>



<p>由于<strong>单例也可以和普通类一样实现接口和继承类</strong>，所以可以将其看成一种不需要主动初始化的类，它也<strong>可以拥有扩展方法</strong>，<strong>单例对象会在系统加载的时候初始化</strong>。</p>
<h3 id="object-表达式"><a href="#object-表达式" class="headerlink" title="object 表达式"></a>object 表达式</h3><p>主要说的是，利用object来完善匿名内部类，这里不展开说。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/08/10/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/10/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：基础语法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-10 15:54:00" itemprop="dateCreated datePublished" datetime="2021-08-10T15:54:00+08:00">2021-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-29 09:42:42" itemprop="dateModified" datetime="2022-10-29T09:42:42+08:00">2022-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="不一样的类型声明"><a href="#不一样的类型声明" class="headerlink" title="不一样的类型声明"></a>不一样的类型声明</h2><p>Kotlin 采用的是与 Java 相反的类型声明方式，类型名通常在变量名的后面： <code>val a: String = "I am Kotlin"</code>为什么采用这种风格呢？Kotlin官方的FAQ的回答是这样的：</p>
<blockquote>
<p>我们相信这样可以使得代码的可读性更好。同时，<strong>这也有利于使用一些良好的语法特性，比如省略类型声明</strong>。Scala的经验表明，这不是一个错误的选择。</p>
</blockquote>
<p>所以，类型放在变量后面的其中一个原因是为了<strong>类型省略</strong>，这个类型省略其实就是类型推导。</p>
<h3 id="增强的类型推导"><a href="#增强的类型推导" class="headerlink" title="增强的类型推导"></a>增强的类型推导</h3><p>类型推导是Kotlin在Java的基础上增强的语言特性之一，即编译器可以在不显式声明类型的情况下，自动推导出它所需要的类型，如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> string = <span class="string">"I am Kotlin"</span></span><br><span class="line"><span class="keyword">val</span> int = <span class="number">1314</span></span><br><span class="line"><span class="keyword">val</span> long = <span class="number">1314L</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们打印以上的变量类型，如： println(int.javaClass.name),将会获得如下结果： </span></span><br><span class="line"><span class="comment">//java.lang.String</span></span><br><span class="line"><span class="comment">//int</span></span><br><span class="line"><span class="comment">//long</span></span><br></pre></td></tr></tbody></table></figure>

<p>类型推导很大程度上提高了Kotlin这种<strong>静态类型语言</strong>的开发效率，虽然静态类型语言有很多优点，然而在编码过程中却需要书写大量的类型。</p>
<h3 id="声明函数返回值类型"><a href="#声明函数返回值类型" class="headerlink" title="声明函数返回值类型"></a>声明函数返回值类型</h3><p>虽然支持类型推导，但是函数返回值类型必须要显式声明，比如：</p>
<p><code>fun sum(x: Int, y: Int): Int { return x + y }</code></p>
<p>此时也许与Java的区别不大，其实Kotlin进一步增强了函数语法，我们可以把 {} 去掉，用等号来定义一个函数：</p>
<p><code>fun sum(x: Int, y: Int) = x + y</code></p>
<p>Kotlin支持的这种单行表达式与等号的语法定义的函数，叫做<strong>表达式函数体</strong>，作为区分，普通的函数声明叫做<strong>代码块函数体</strong>。但是别高兴太早，我们再来看一段递归程序：</p>
<p><code>fun foo(n: Int) = if(n == 0) 1 else n * foo(n - 1)</code></p>
<p>这种情况下，编译器并不能针对递归函数的情况推导类型，因此这里会报错。所以，在一些诸如递归等复杂条件下，及时用表达式定义函数，我们也必须显式声明类型，才能让程序正常工作，代码如下：</p>
<p><code>fun foo(n: Int): Int = if(n == 0) 1 else n * foo(n - 1)</code></p>
<h2 id="val-和-var-的使用规则"><a href="#val-和-var-的使用规则" class="headerlink" title="val 和 var 的使用规则"></a>val 和 var 的使用规则</h2><p>Kotlin声明变量时，引入了 val 和 var 的概念。var 容易理解，就是变量，在JavaScript 中也有用到，但是 val 是什么呢？如果在 IDEA 中反编译 val 的实现成Java代码就能发现，<strong>它是通过 final 这一特性实现的</strong>。 </p>
<h3 id="优先使用val避免副作用"><a href="#优先使用val避免副作用" class="headerlink" title="优先使用val避免副作用"></a>优先使用val避免副作用</h3><p><strong>Kotlin支持一开始不定义 val 变量的取值，随后再进行赋值</strong>，然而，因为引用不可变，所以val声明的变量只能被赋值一次，<strong>并且声明时不能省略变量类型</strong>，如下所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">  <span class="keyword">val</span> a: <span class="built_in">Int</span></span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  println(a)<span class="comment">//输出1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于不可变性，我们可以直到 val 变量在并发环境更安全。</p>
<h3 id="var-的适用场景"><a href="#var-的适用场景" class="headerlink" title="var 的适用场景"></a>var 的适用场景</h3><p>既然 val 那么好，为什么要 var 呢？首先，Kotlin 要兼容Java ，这就注定 必须有 var 的存在；其次有一些场景如果不适用 var 就必须得用到 递归 才能实现了，所以var需要存在。</p>
<h2 id="高阶函数和Lambda"><a href="#高阶函数和Lambda" class="headerlink" title="高阶函数和Lambda"></a>高阶函数和Lambda</h2><p>Kotlin 天然支持了部分<strong>函数式特性</strong>，函数式语言的一个典型特征在于<strong>函数式头等公民</strong>——我们不仅可以像类一样在顶层直接定义一个函数，<strong>也可以在函数内部定义一个局部函数</strong>！如下所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(x: <span class="type">Int</span>)</span></span> {</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(y: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> {</span><br><span class="line">    <span class="keyword">return</span> y * <span class="number">2</span></span><br><span class="line">  }</span><br><span class="line">  println(double(x))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此外，Kotlin还能直接将函数像普通变量一样传递给另一个函数，或在其他函数中被返回，如何理解这个特性？</p>
<h3 id="抽象和高阶函数"><a href="#抽象和高阶函数" class="headerlink" title="抽象和高阶函数"></a>抽象和高阶函数</h3><p>概念东西，略</p>
<h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><p>在Kotlin中，函数类型的格式非常简单，举个例子：<code>(Int) -&gt; Unit</code>，我们可以发现，Kotlin中的函数类型需要遵循以下几点：</p>
<ul>
<li>通过 -&gt; 符号来组织参数类型和返回值类型，左边是参数类型，右边是返回值类型</li>
<li>必须用一个括号来包裹参数类型，如果多个参数，可以用逗号分割，如： <code>(Int， String?) -&gt; Unit</code></li>
<li>返回值<strong>即使是 Unit ，也必须显式声明</strong>    </li>
</ul>
<p>此外，Kotlin 还支持为声明参数指定名字：<code>(errCode: Int， errMsg: String?) -&gt; Unit</code> 这还没完，<strong>高阶函数还支持返回另一个函数</strong>，所以还能这么做：</p>
<figure class="highlight k"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(Int) -&gt; ((Int) -&gt; Unit)</span><br><span class="line"><span class="comment">//如果把后半部分括号省略，可以写成：</span></span><br><span class="line">(Int) -&gt; Int -&gt; Unit</span><br></pre></td></tr></tbody></table></figure>

<h3 id="方法和成员引用"><a href="#方法和成员引用" class="headerlink" title="方法和成员引用"></a>方法和成员引用</h3><p>Kotlin 存在一种特殊的语法，<strong>通过两个冒号来四号线对于某个类的方法进行引用</strong>。假如有一个CountryTest 类的对象实例 countryTest ，如果要引用它的 isBigEuropeanCountry 方法，就可以这么写： </p>
<p><code>countryTest::isBigEuropeanCountry</code></p>
<p>此外，我们还可以直接通过这种语法，来定义一个类的构造方法引用变量：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">    <span class="keyword">val</span> getBook = ::Book</span><br><span class="line">    println(getBook(<span class="string">"Dive into Kotlin"</span>).name)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以发现，getBook 的类型为 (name: String) -&gt; Book 。类似的道理，如果我们要引用某个类中的成员变量，比如Book类中的name，就可以这样引用： <code>Book:name</code> ，以上 Book::name 的类型为 (Book) -&gt; String 。当我们在对Book 类对象的集合应用一些函数式API的时候，就会显得格外有用，比如：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">    <span class="keyword">val</span> bookNames = listOf(</span><br><span class="line">        Book(<span class="string">"Thinking in Java"</span>)</span><br><span class="line">        Book(<span class="string">"Dive into Kotlin"</span>)</span><br><span class="line">    ).map(Book::name)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>略</p>
<h3 id="Lambda-是语法糖"><a href="#Lambda-是语法糖" class="headerlink" title="Lambda 是语法糖"></a>Lambda 是语法糖</h3><p>Kotlin 在JVM 层设计了 Function 类型 (Function0，Function1…Function22)来兼容Java的Lambda表达式，其中后缀数字代表了 Lambda 参数的数量。比如，Function1在源码中就是如下表示的：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Function1</span>&lt;<span class="type">in P1, out R</span>&gt;: <span class="type">kotlin.Function</span>&lt;<span class="type">R</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(p1: <span class="type">P1</span>)</span></span>: R</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可见每个Function 类型都有一个invoke方法，设计Function类型的目的之一就是要兼容Java ，实现在Kotlin 中也能调用Java的Lambda。<strong>在 Java 中，实际上不支持把函数作为参数，而是通过函数式接口来实现这一特性。</strong></p>
<h3 id="函数、Lambda和闭包"><a href="#函数、Lambda和闭包" class="headerlink" title="函数、Lambda和闭包"></a>函数、Lambda和闭包</h3><p>略</p>
<h3 id="“柯里化”风格、扩展函数"><a href="#“柯里化”风格、扩展函数" class="headerlink" title="“柯里化”风格、扩展函数"></a>“柯里化”风格、扩展函数</h3><p>柯里化略</p>
<p>在我们介绍的Lambda的表达式中，还存在一种特殊的语法，如果一个函数只有一个参数，且该参数为函数类型，那么在调用该函数时，外面的括号就可以省略，例子如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">omit</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> {</span><br><span class="line">  block</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么我们在调用的时候，可以写成</span></span><br><span class="line">omit {</span><br><span class="line">  println(<span class="string">"parentheses is omitted"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>另一项特性 扩展函数，允许我们在不修改已有类的前提下，给它增加新的方法，示例如下：</p>
<figure class="highlight k"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun View.invisible() {</span><br><span class="line">    this.visibility = View.INVISIBLE</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上述例子中，类型View被称为<strong>接收者类型</strong>，this对应的是这个类型锁创建的<strong>接收者对象</strong>，this也能被省略，就像这样：</p>
<figure class="highlight k"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun View.invisible() {</span><br><span class="line">    visibility = View.INVISIBLE</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="面向表达式编程"><a href="#面向表达式编程" class="headerlink" title="面向表达式编程"></a>面向表达式编程</h2><p>现在，罗列下我们已经提及的表达式概念：</p>
<ul>
<li>if表达式</li>
<li>函数体表达式</li>
<li>Lambda表达式</li>
<li>函数引用表达式</li>
</ul>
<h3 id="Unit类型：让函数调用皆为表达式"><a href="#Unit类型：让函数调用皆为表达式" class="headerlink" title="Unit类型：让函数调用皆为表达式"></a>Unit类型：让函数调用皆为表达式</h3><p>之所有不能说Java中的函数调用皆是表达式，是因为存在特例 void，在Java中如果声明的函数没有返回值，那么它就要用void修饰：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">()</span> </span>{</span><br><span class="line">  System.out.println(<span class="string">"hahah"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所以foo就不具有值和类型信息，就不能算作一个表达式。函数式语言在所有的情况下都具有返回类型，所以kotlin引入了 Unit 来替代 void 关键字。如何理解 Unit ？其实与 int 一样，都是一种类型，然而它不代表任何信息，它就是一个单例，它的实例只有一个 ，可以写为 () 。</p>
<h3 id="for循环和范围表达式"><a href="#for循环和范围表达式" class="headerlink" title="for循环和范围表达式"></a>for循环和范围表达式</h3><p>在Java中，经常在for来构建循环体：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) {</span><br><span class="line">  System.out.println(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是kotlin会简单很多：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i in 1..10) println(i)  </span><br><span class="line">//当然也能把大括号和i的类型加上</span><br><span class="line">for (i:Int in 1..10) {</span><br><span class="line">  println(i) </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>范围表达式，1..10 这种语法是<strong>范围表达式</strong>(range) 。</p>
<blockquote>
<p>官网的表述是：Range表达式是通过rangeTo 函数实现的，通过 .. 操作符与某种类型的对象组成，除了整形的基本类型外，该类型需要实现 java.lang.Comparable 接口</p>
</blockquote>
<p>举个例子，由于 String类实现了 Comparable 接口，字符串之间可以比较大小，所以我们可以创建一个字符串区间，如 <code>"abc".."xyz"</code> 。</p>
<p>另外，kotlin 还提供了步长和倒序以及半开区间：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步长</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> step <span class="number">2</span>) print(i) <span class="comment">//输出 1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//倒序</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">1</span> step <span class="number">2</span>) print(i) <span class="comment">//输出： 10 8 6 4 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//半开区间</span></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">10</span>) print(i)  <span class="comment">//输出 123456789</span></span><br></pre></td></tr></tbody></table></figure>

<p>用 in 来检查成员关系，，在Kotlin中我们可以用 in 关键字来检查一个元素是否是一个区间或者集合中的成员，比如：<code>"a" in  listOf ("b" , "c")</code> ，会返回 false ；在 in 之前加上叹号就是相反结果： <code>"a" !in  listOf ("b" , "c")</code> 返回true。更多的应用场景如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结合范围表达式</span></span><br><span class="line"><span class="string">"kot"</span> <span class="keyword">in</span> <span class="string">"abc"</span>..<span class="string">"xyz"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//还能通过withIndex 提供键值元祖</span></span><br><span class="line"><span class="keyword">for</span> ((index,value) <span class="keyword">in</span> array.withIndex) {</span><br><span class="line">  println(<span class="string">"the element at <span class="variable">$index</span> is <span class="variable">$value</span>"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><p>前面见识过 in、step、downTo、until 这些写法，都不需要通过点号，而是用<strong>中缀表达式</strong>来被调用，从而语法更直观。这是如何实现的呢？看下标准库中类似的方法 to 的设计：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A,B&gt;</span> A.<span class="title">to</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="函数可变参数"><a href="#函数可变参数" class="headerlink" title="函数可变参数"></a>函数可变参数</h4><p>Java 中采用 “…” 来表示可变参数，<strong>Kotlin中通过 varargs 关键字实现可变参数…</strong>。需要注意的是，<strong>Java 中的可变参数必须是最后一个参数，Ktolin中没有这个限制</strong>，但两者都可以在函数体中以数组方式来使用可变参数变量：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printLetters</span><span class="params">(varargs letters: <span class="type">String</span>, count: <span class="type">Int</span>)</span></span> {</span><br><span class="line">  print(<span class="string">"<span class="subst">${count}</span> letters are "</span>)</span><br><span class="line">  <span class="keyword">for</span> (letter <span class="keyword">in</span> letters) print(letter) <span class="comment">// 输出 3 letters are abc</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//此外，我们还能使用星号(*)来传入外部的变量作为可变参数的变量：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> letters = arrayOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line">printLetters(*letters, count = <span class="number">3</span>) <span class="comment">//同样会输出 3 letters are abc</span></span><br></pre></td></tr></tbody></table></figure>

<p>由于to会返回 Pair 这种键值对的结构数据，因此我们经常会把它与map结合在一起使用，如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mapOf(</span><br><span class="line">    <span class="number">1</span> to <span class="string">"one"</span>,</span><br><span class="line">    <span class="number">2</span> to <span class="string">"two"</span>,</span><br><span class="line">    <span class="number">3</span> to <span class="string">"three"</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="字符串的定义和操作"><a href="#字符串的定义和操作" class="headerlink" title="字符串的定义和操作"></a>字符串的定义和操作</h2><p>kotlin 中有丰富的API，比如： <code>"abcdefg".filter {c -&gt; c in 'a'..'d'}</code> //输出 abcd</p>
<h3 id="定义原生字符串"><a href="#定义原生字符串" class="headerlink" title="定义原生字符串"></a>定义原生字符串</h3><p>Java 对原生字符串只能通过转义字符的方法支持。然而，在Kotlin中已经支持直接写原生字符串，使用3个引号的方式(“””)，体验下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rawString = <span class="string">"""</span></span><br><span class="line"><span class="string">    \n Kotlin is awesonme.</span></span><br><span class="line"><span class="string">    \n Kotlin is a better Java. """</span></span><br><span class="line"></span><br><span class="line">print(rawString)</span><br><span class="line"></span><br><span class="line"><span class="comment">//会打印：</span></span><br><span class="line">\n Kotlin <span class="keyword">is</span> awesonme.</span><br><span class="line">\n Kotlin <span class="keyword">is</span> a better Java.</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到非常简洁，如果用Java 来表示会非常复杂，尤其是 Html 代码。</p>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>略</p>
<h3 id="字符串判等"><a href="#字符串判等" class="headerlink" title="字符串判等"></a>字符串判等</h3><p>Kotlin 中判等性有两种类型：</p>
<ul>
<li>结构相等。 通过 == 来判定两个对象的内容是否相等</li>
<li>引用相等。通过 === 来判断两个对象的引用是否一样，与之相反的操作是 !== ，</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/08/10/%E4%B9%A6-ReactNative%E7%B2%BE%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/ReactNative%E7%B2%BE%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98-%E7%AC%AC1%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/10/%E4%B9%A6-ReactNative%E7%B2%BE%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/ReactNative%E7%B2%BE%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98-%E7%AC%AC1%E7%AB%A0/" class="post-title-link" itemprop="url">第1章：React 与 React Native 简介</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-10 15:30:00 / 修改时间：15:30:21" itemprop="dateCreated datePublished" datetime="2021-08-10T15:30:00+08:00">2021-08-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="React简介"><a href="#React简介" class="headerlink" title="React简介"></a>React简介</h2><p>React 只专注于 MVC 框架设计模式中的 View 层面的实现。为了大大减少传统前端直接操作DOM 的昂贵花费，React 使用Virtual DOM （虚拟DOM）进行DOM的更新，实现了单向数据流传递。下图清晰地描述了 React 底层与前端浏览器的沟通机制。</p>
<p><img src="" alt="Ract框架结构"></p>
<h3 id="React的底层特性"><a href="#React的底层特性" class="headerlink" title="React的底层特性"></a>React的底层特性</h3><p>传统<strong>HTML页面</strong>需要更新页面元素时，<strong>都是将整个页面重新加载实现重绘</strong>，这个代价非常昂贵。后来有了 AJAX 这样的局部更新技术，实现了页面的异步更新，不过AJAX代码编写、维护、性能及更新粒度上还是不够完美。</p>
<p>文档对象模型(Document Object Model， DOM) 是 W3C 组织推荐的处理可扩展标志语言的标准编程接口，<strong>在 HTML 网页上，将构成页面的对象元素组织在一个树形的结构中，用来表示文档中对象的标准模型就称为 DOM</strong>。</p>
<p>React 在底层设计了虚拟DOM，虚拟DOM 与真实 DOM 相互映射，当业务逻辑修改了 Reat 组件中的 state ，<strong>React 框架diff算法会通过比较虚拟 DOM 与 真实DOM 之间的差异，找出哪些部分被修改了，最终只更新差异部分</strong>。这样实现了React 在前端中的高性能表现。</p>
<p>其实，React 并不会在state 更改的第一时间去执行 diff 算法并立即更新页面，而是将多次操作汇聚成一次批量操作，这样再次提升页面更新重绘的效率。</p>
<h2 id="React-Native-简介"><a href="#React-Native-简介" class="headerlink" title="React Native 简介"></a>React Native 简介</h2><p>第3章：React Native 工作原理与生命周期</p>
<h3 id="React-Native框架及工作原理"><a href="#React-Native框架及工作原理" class="headerlink" title="React Native框架及工作原理"></a>React Native框架及工作原理</h3><p>因为 React Native 底层为React 框架，所以，如果是UI层的变更，那么就<strong>映射为虚拟DOM后，调用diff算法计算出变动后的 JSON 映射文件，最终由Native 层将此 JSON 文件映射渲染到原生App的页面元素上</strong>，实现了在项目中只需要控制state 以及 props的变更来引起 ios /Android 平台的 UI 变更。</p>
<p>编写的 RN 代码最终会打包成 main.bundle.js 文件供App 加载，此文件可以存在App本地或者服务器上更新。</p>
<h3 id="RN-与原生平台通信"><a href="#RN-与原生平台通信" class="headerlink" title="RN 与原生平台通信"></a>RN 与原生平台通信</h3><p>RN 与原生的通信如下图所示，采用了 JavaScriptCore 作为 JS VM，中间通过 JSON 文件与 Bridge 进行通信。若使用 Chrome 进行调试，那么所有的 JavaScript 代码都将运行在 Chrome 的 V8 引擎，与原生代码通过 WebSocket 进行通信。</p>
<p><img src="" alt="RN与原生平台通信"></p>
<h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><ol>
<li><p>父子组件之间的通信</p>
<p>在RN中，可以通过 props 的形式实现父组件向子组件传递值，如下例子展示父组件通过调用子组件并赋值子组件的 name 为 React，子组件通过 this.props.name 获取父组件传递过来的 name 字符串 React：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*父子组件通信，在父组件中调用子组件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;ChildComponent name=<span class="string">'React'</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*子组件实现，通过props获取父组件传递的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildComponent</span> <span class="title">extentds</span> <span class="title">Component</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Text</span>&gt;</span> Hello {this.props.name}!<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
<ol start="2">
<li><p>子父组件通信</p>
<p>先略了</p>
</li>
</ol>
<h2 id="React-Native-中的生命周期"><a href="#React-Native-中的生命周期" class="headerlink" title="React Native 中的生命周期"></a>React Native 中的生命周期</h2><p><strong>在 RN 程序启动时，内部的虚拟 DOM 开始建立，生命周期时建立在此虚拟DOM 的整个声明周期之中</strong>，从虚拟DOM 的初始化到虚拟DOM 的卸载 ，RN 为组件的不同状态建立了不同的生命周期。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/05/05/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%95%AA%E5%A4%96%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/05/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%95%AA%E5%A4%96%E7%AF%87/" class="post-title-link" itemprop="url">番外篇：Activity LaunchMode原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-05 16:13:00 / 修改时间：16:48:52" itemprop="dateCreated datePublished" datetime="2021-05-05T16:13:00+08:00">2021-05-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>番外篇主要是看到<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/09365022adac">一篇简书上的博客</a>后，对LauncherMode的一点补充。本文只是复制这篇博客的内容，防止这篇文章被简书屏蔽(因为他有一篇文章就已经是一直审核状态了)。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道Activity的start是走到Instrumentation的execStartActivity方法中，而这里是调用了ActivityManagerNative的getDefault方法 来获得一个ActivityManagerService(以下简称AMS)的远程代理对象，要走到AMS的startActivity方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br></pre></td></tr></tbody></table></figure>

<p>这里先解释一下startActivity方法里的一些参数:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>whoThread    IApplicationThread的binder对象</td>
<td>用于AMS进行进程间通信</td>
</tr>
<tr>
<td>who    上下文对象</td>
<td>其实就是Activity</td>
</tr>
<tr>
<td>intent</td>
<td>目标intent</td>
</tr>
<tr>
<td>intent.resolveTypeIfneed</td>
<td>若没有在Manifest文件里面注明Activity的mime类型，返回null</td>
</tr>
<tr>
<td>token    Binder对象</td>
<td>通过它可以获得Activity的相关信息 后边会保存到sourceRecord这个对象里面</td>
</tr>
<tr>
<td>target</td>
<td>我们调用的Activity</td>
</tr>
<tr>
<td>requestCode</td>
<td>若没有设置结果就是小于0</td>
</tr>
<tr>
<td>0</td>
<td>flags</td>
</tr>
<tr>
<td>ProfilerInfo</td>
<td>null</td>
</tr>
<tr>
<td>options</td>
<td>是一个bunder对象，记录用intent传递的信息</td>
</tr>
</tbody></table>
<p>这里对应着AMS 中startactivity的参数</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="params"><span class="function">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">        resultWho, requestCode, startFlags, profilerInfo, options,</span><br><span class="line">        UserHandle.getCallingUserId());</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="params"><span class="function">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options, <span class="keyword">int</span> userId)</span> </span>{</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line">    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</span><br><span class="line">            <span class="keyword">false</span>, ALLOW_FULL_ONLY, <span class="string">"startActivity"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">    <span class="keyword">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent,</span><br><span class="line">            resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">            profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, options, userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后会调用ActivityStackSupervisor的startActivityMayWait方法，而ActivityStackSupervisor 就是专门管理activity的堆栈的类</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-d2e1e1e2859b5c86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/726/format/webp" alt="startActivityMayWait方法"></p>
<p>这里会先解析我们的intent来获取信息，通过调用函数resoleActivity方法获取ActivityInfo，这里主要是activity在AndroidManifest.xml里的信息</p>
<p>再往下看，进入到startActivityLocked 方法中</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-e50075b5c4539486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/777/format/webp" alt="startActivityMayWait方法"></p>
<blockquote>
<p>另提一下activity 在 AMS 中的形式是 ActivityRecord,task 在 AMS 中的形式为TaskRecord,进程在 AMS 中的管理形式为 ProcessRecord</p>
</blockquote>
<p> 我们发现这里有两个ActivityRecord对象 有sourceRecord 和resultRecord</p>
<blockquote>
<p>sourceRecord 代表的是最开始的activity<br>这就是通过resultTo这个binder对象获得Mainactivity的相关信息然后保存到这个对象中<br>resultRecord 代表的是接受启动结果的Activity<br>因为requestcode==-1 所以这里resultRecord==null</p>
</blockquote>
<p>final int launchFlags = intent.getFlags();<br>这里获取Intent的启动Flag 就是我们在Intent.setFlag里面设置的标志<br>这个函数的主要作用就是处理sourceRecord和resultRecord两个对象<br>在这里sourceRecord和resultRecord指向的应该是同一个activity</p>
<p>然后调用startActivityUncheckedLocked来处理本次的启动Activity的请求</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-59cc775b23e884c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-39391603929ddcc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p>从这里我们可以看到 获取了activity的launchModel ，也就是对launchModel的判断处理应该是在这里<br>这里先判断是否FLAG_ACTIVITY_NEW_DOCUMENT，这个平时用的比较少，在android5.0上主要是决定你的task和activity是如何展现在overview screen 中的，详细请看Android 5.0 Overview Screen–总览画面<br>再往下看</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-056e3a3f60d6acbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p>startFlags == 0 所以此时不会进入这个判断，没有设置这个FLAG_ACTIVITY_PREVIOUS_IS_TOP，所以我们的notTop==null<br>接着 系统默认addingToTask= false 默认是开启新的Task，从后面的判断也可以看出来</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-1c643a3c8fae5e94.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p>之前说过 sourceRecord就是最开始的activity 所以它不会为null，这样就到了else 中 inTask = null；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-2419c6b8b3f4c7e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/755/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p> 在这里判断了启动模式，判断当前activity的启动模式和要启动的activity的启动模式，根据相应的启动模式设置launchFlags</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-888c5f5346d10e05.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-c6f1382d01eeca2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p>这里目的是判断启动的activity是否在堆栈里存在，如果存在就直接在进行相应的操作<br>在文章开头 resultRecord 默认为null而且requestCode假如没有设置的话，requestCode小于0，所以resultRecord没有被赋值，所以我们构造ActivityRecord 时传入的是null，也就是可以进入这个if判断里<br>再往里看</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-2eb788c2a9a3dd9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/577/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p>这里会判断启动的activity是否是SingleInstance，根据此进入不同的方法，目的是找到activity，如果有就返回，如果没有就返回null，先来看findTaskLocked方法</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-ea3170a8c0b3a0b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="findTaskLocked方法"></p>
<p>stack里的findTaskLocked方法比较长，顶部activity，如果没有就返回null，从注释上来看就是返回堆栈里的activity,简单说一下就是返回发起请求的activity，也是这个函数返回的activity</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the top activity in any existing task matching the given</span></span><br><span class="line"><span class="comment">     * Intent.  Returns null if no such task is found.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ActivityRecord <span class="title">findTaskLocked</span><span class="params">(ActivityRecord target)</span> </span>{</span><br><span class="line">        Intent intent = target.intent;</span><br><span class="line">        ActivityInfo info = target.info;</span><br><span class="line">        ComponentName cls = intent.getComponent();</span><br><span class="line">        <span class="keyword">if</span> (info.targetActivity != <span class="keyword">null</span>) {</span><br><span class="line">            cls = <span class="keyword">new</span> ComponentName(info.packageName, info.targetActivity);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(info.applicationInfo.uid);</span><br><span class="line">        <span class="keyword">boolean</span> isDocument = intent != <span class="keyword">null</span> &amp; intent.isDocument();</span><br><span class="line">        <span class="comment">// If documentData is non-null then it must match the existing task data.</span></span><br><span class="line">        Uri documentData = isDocument ? intent.getData() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Looking for task of "</span> + target + <span class="string">" in "</span> + <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> taskNdx = mTaskHistory.size() - <span class="number">1</span>; taskNdx &gt;= <span class="number">0</span>; --taskNdx) {</span><br><span class="line">            <span class="keyword">final</span> TaskRecord task = mTaskHistory.get(taskNdx);</span><br><span class="line">            <span class="keyword">if</span> (task.voiceSession != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// We never match voice sessions; those always run independently.</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Skipping "</span> + task + <span class="string">": voice session"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (task.userId != userId) {</span><br><span class="line">                <span class="comment">// Looking for a different task.</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Skipping "</span> + task + <span class="string">": different user"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">final</span> ActivityRecord r = task.getTopActivity();</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span> || r.finishing || r.userId != userId ||</span><br><span class="line">                    r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Skipping "</span> + task + <span class="string">": mismatch root "</span> + r);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Intent taskIntent = task.intent;</span><br><span class="line">            <span class="keyword">final</span> Intent affinityIntent = task.affinityIntent;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> taskIsDocument;</span><br><span class="line">            <span class="keyword">final</span> Uri taskDocumentData;</span><br><span class="line">            <span class="keyword">if</span> (taskIntent != <span class="keyword">null</span> &amp;&amp; taskIntent.isDocument()) {</span><br><span class="line">                taskIsDocument = <span class="keyword">true</span>;</span><br><span class="line">                taskDocumentData = taskIntent.getData();</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (affinityIntent != <span class="keyword">null</span> &amp;&amp; affinityIntent.isDocument()) {</span><br><span class="line">                taskIsDocument = <span class="keyword">true</span>;</span><br><span class="line">                taskDocumentData = affinityIntent.getData();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                taskIsDocument = <span class="keyword">false</span>;</span><br><span class="line">                taskDocumentData = <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Comparing existing cls="</span></span><br><span class="line">                    + taskIntent.getComponent().flattenToShortString()</span><br><span class="line">                    + <span class="string">"/aff="</span> + r.task.rootAffinity + <span class="string">" to new cls="</span></span><br><span class="line">                    + intent.getComponent().flattenToShortString() + <span class="string">"/aff="</span> + info.taskAffinity);</span><br><span class="line">            <span class="keyword">if</span> (!isDocument &amp;&amp; !taskIsDocument &amp;&amp; task.rootAffinity != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (task.rootAffinity.equals(target.taskAffinity)) {</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Found matching affinity!"</span>);</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (taskIntent != <span class="keyword">null</span> &amp;&amp; taskIntent.getComponent() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    taskIntent.getComponent().compareTo(cls) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    Objects.equals(documentData, taskDocumentData)) {</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Found matching class!"</span>);</span><br><span class="line">                <span class="comment">//dump();</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"For Intent "</span> + intent + <span class="string">" bringing to top: "</span></span><br><span class="line">                        + r.intent);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (affinityIntent != <span class="keyword">null</span> &amp;&amp; affinityIntent.getComponent() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    affinityIntent.getComponent().compareTo(cls) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    Objects.equals(documentData, taskDocumentData)) {</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Found matching class!"</span>);</span><br><span class="line">                <span class="comment">//dump();</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"For Intent "</span> + intent + <span class="string">" bringing to top: "</span></span><br><span class="line">                        + r.intent);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_TASKS) {</span><br><span class="line">                Slog.d(TAG, <span class="string">"Not a match: "</span> + task);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里简单说一下，先是从mTaskHistory中遍历得到一个任务Task，并根据userid找到当前的task ，找到这个任务的顶部activity，并且保证它启动模式不是singleInstance，都满足了返回以下条件的activity</p>
<p>再回到刚才的方法往下看</p>
<p>这里先去activitystack里的moveToFront()方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the caller has requested that the target task be</span></span><br><span class="line"><span class="comment">// reset, then do so.</span></span><br><span class="line"><span class="keyword">if</span> ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != <span class="number">0</span>) {</span><br><span class="line">    intentActivity = targetStack.resetTaskIfNeededLocked(intentActivity, r);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">// We don't need to start a new activity, and</span></span><br><span class="line">    <span class="comment">// the client said not to do anything if that</span></span><br><span class="line">    <span class="comment">// is the case, so this is it!  And for paranoia, make</span></span><br><span class="line">    <span class="comment">// sure we have correctly resumed the top activity.</span></span><br><span class="line">    <span class="keyword">if</span> (doResume) {</span><br><span class="line">        resumeTopActivitiesLocked(targetStack, <span class="keyword">null</span>, options);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        ActivityOptions.abort(options);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ActivityManager.START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> ((launchFlags &amp;</span><br><span class="line">        (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK))</span><br><span class="line">        == (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK)) {</span><br><span class="line">    <span class="comment">// The caller has requested to completely replace any</span></span><br><span class="line">    <span class="comment">// existing task with its new activity.  Well that should</span></span><br><span class="line">    <span class="comment">// not be too hard...</span></span><br><span class="line">    reuseTask = intentActivity.task;</span><br><span class="line">    reuseTask.performClearTaskLocked();</span><br><span class="line">    reuseTask.setIntent(r);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> ((launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != <span class="number">0</span></span><br><span class="line">        || launchSingleInstance || launchSingleTask) {</span><br><span class="line">    <span class="comment">// In this situation we want to remove all activities</span></span><br><span class="line">    <span class="comment">// from the task up to the one being started.  In most</span></span><br><span class="line">    <span class="comment">// cases this means we are resetting the task to its</span></span><br><span class="line">    <span class="comment">// initial state.</span></span><br><span class="line">    ActivityRecord top =</span><br><span class="line">            intentActivity.task.performClearTaskLocked(r, launchFlags);</span><br><span class="line">    <span class="keyword">if</span> (top != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (top.frontOfTask) {</span><br><span class="line">            <span class="comment">// Activity aliases may mean we use different</span></span><br><span class="line">            <span class="comment">// intents for the top activity, so make sure</span></span><br><span class="line">            <span class="comment">// the task now has the identity of the new</span></span><br><span class="line">            <span class="comment">// intent.</span></span><br><span class="line">            top.task.setIntent(r);</span><br><span class="line">        }</span><br><span class="line">        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,</span><br><span class="line">                r, top.task);</span><br><span class="line">        top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// A special case: we need to</span></span><br><span class="line">        <span class="comment">// start the activity because it is not currently</span></span><br><span class="line">        <span class="comment">// running, and the caller has asked to clear the</span></span><br><span class="line">        <span class="comment">// current task to have this activity at the top.</span></span><br><span class="line">        addingToTask = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// Now pretend like this activity is being started</span></span><br><span class="line">        <span class="comment">// by the top of its task, so it is put in the</span></span><br><span class="line">        <span class="comment">// right place.</span></span><br><span class="line">        sourceRecord = intentActivity;</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (r.realActivity.equals(intentActivity.task.realActivity)) {</span><br><span class="line">    <span class="comment">// In this case the top activity on the task is the</span></span><br><span class="line">    <span class="comment">// same as the one being launched, so we take that</span></span><br><span class="line">    <span class="comment">// as a request to bring the task to the foreground.</span></span><br><span class="line">    <span class="comment">// If the top activity in the task is the root</span></span><br><span class="line">    <span class="comment">// activity, deliver this new intent to it if it</span></span><br><span class="line">    <span class="comment">// desires.</span></span><br><span class="line">    <span class="keyword">if</span> (((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span> || launchSingleTop)</span><br><span class="line">            &amp;&amp; intentActivity.realActivity.equals(r.realActivity)) {</span><br><span class="line">        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r,</span><br><span class="line">                intentActivity.task);</span><br><span class="line">        <span class="keyword">if</span> (intentActivity.frontOfTask) {</span><br><span class="line">            intentActivity.task.setIntent(r);</span><br><span class="line">        }</span><br><span class="line">        intentActivity.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!r.intent.filterEquals(intentActivity.task.intent)) {</span><br><span class="line">        <span class="comment">// In this case we are launching the root activity</span></span><br><span class="line">        <span class="comment">// of the task, but with a different intent.  We</span></span><br><span class="line">        <span class="comment">// should start a new instance on top.</span></span><br><span class="line">        addingToTask = <span class="keyword">true</span>;</span><br><span class="line">        sourceRecord = intentActivity;</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">// In this case an activity is being launched in to an</span></span><br><span class="line">    <span class="comment">// existing task, without resetting that task.  This</span></span><br><span class="line">    <span class="comment">// is typically the situation of launching an activity</span></span><br><span class="line">    <span class="comment">// from a notification or shortcut.  We want to place</span></span><br><span class="line">    <span class="comment">// the new activity on top of the current task.</span></span><br><span class="line">    addingToTask = <span class="keyword">true</span>;</span><br><span class="line">    sourceRecord = intentActivity;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (!intentActivity.task.rootWasReset) {</span><br><span class="line">    <span class="comment">// In this case we are launching in to an existing task</span></span><br><span class="line">    <span class="comment">// that has not yet been started from its front door.</span></span><br><span class="line">    <span class="comment">// The current task has been brought to the front.</span></span><br><span class="line">    <span class="comment">// Ideally, we'd probably like to place this new task</span></span><br><span class="line">    <span class="comment">// at the bottom of its stack, but that's a little hard</span></span><br><span class="line">    <span class="comment">// to do with the current organization of the code so</span></span><br><span class="line">    <span class="comment">// for now we'll just drop it.</span></span><br><span class="line">    intentActivity.task.setIntent(r);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!addingToTask &amp;&amp; reuseTask == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="comment">// We didn't do anything...  but it was needed (a.k.a., client</span></span><br><span class="line">    <span class="comment">// don't use that intent!)  And for paranoia, make</span></span><br><span class="line">    <span class="comment">// sure we have correctly resumed the top activity.</span></span><br><span class="line">    <span class="keyword">if</span> (doResume) {</span><br><span class="line">        targetStack.resumeTopActivityLocked(<span class="keyword">null</span>, options);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        ActivityOptions.abort(options);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ActivityManager.START_TASK_TO_FRONT;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里主要看</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-89af170c52d6ebd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/612/format/webp" alt="代码片段"></p>
<p>这里走到了ActivityStack的performClearTaskLocked方法里</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Perform clear operation as requested by</span></span><br><span class="line"><span class="comment">    * {<span class="doctag">@link</span> Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the</span></span><br><span class="line"><span class="comment">    * stack to the given task, then look for</span></span><br><span class="line"><span class="comment">    * an instance of that activity in the stack and, if found, finish all</span></span><br><span class="line"><span class="comment">    * activities on top of it and return the instance.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> newR Description of the new activity being started.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> Returns the old activity that should be continued to be used,</span></span><br><span class="line"><span class="comment">    * or null if none was found.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> ActivityRecord <span class="title">performClearTaskLocked</span><span class="params">(ActivityRecord newR, <span class="keyword">int</span> launchFlags)</span> </span>{</span><br><span class="line">       <span class="keyword">int</span> numActivities = mActivities.size();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> activityNdx = numActivities - <span class="number">1</span>; activityNdx &gt;= <span class="number">0</span>; --activityNdx) {</span><br><span class="line">           ActivityRecord r = mActivities.get(activityNdx);</span><br><span class="line">           <span class="keyword">if</span> (r.finishing) {</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">if</span> (r.realActivity.equals(newR.realActivity)) {</span><br><span class="line">               <span class="comment">// Here it is!  Now finish everything in front...</span></span><br><span class="line">               <span class="keyword">final</span> ActivityRecord ret = r;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> (++activityNdx; activityNdx &lt; numActivities; ++activityNdx) {</span><br><span class="line">                   r = mActivities.get(activityNdx);</span><br><span class="line">                   <span class="keyword">if</span> (r.finishing) {</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   }</span><br><span class="line">                   ActivityOptions opts = r.takeOptionsLocked();</span><br><span class="line">                   <span class="keyword">if</span> (opts != <span class="keyword">null</span>) {</span><br><span class="line">                       ret.updateOptionsLocked(opts);</span><br><span class="line">                   }</span><br><span class="line">                   <span class="keyword">if</span> (stack.finishActivityLocked(r, Activity.RESULT_CANCELED, <span class="keyword">null</span>, <span class="string">"clear"</span>,</span><br><span class="line">                           <span class="keyword">false</span>)) {</span><br><span class="line">                       --activityNdx;</span><br><span class="line">                       --numActivities;</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Finally, if this is a normal launch mode (that is, not</span></span><br><span class="line">               <span class="comment">// expecting onNewIntent()), then we will finish the current</span></span><br><span class="line">               <span class="comment">// instance of the activity so a new fresh one can be started.</span></span><br><span class="line">               <span class="keyword">if</span> (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE</span><br><span class="line">                       &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) == <span class="number">0</span>) {</span><br><span class="line">                   <span class="keyword">if</span> (!ret.finishing) {</span><br><span class="line">                       stack.finishActivityLocked(ret, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                               <span class="string">"clear"</span>, <span class="keyword">false</span>);</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> ret;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<p>这里就是根据ID找到等于参数taskId的任务，然后在这个任务中查找是否已经存在即将要启动的Activity的实例，如果存在，就会把这个Actvity实例上面直到任务堆栈顶端的Activity通过调用finishActivityLocked函数将它们结束掉。</p>
<blockquote>
<p>在这里便引出了manifest文件中<activity>的一个重要属性，taskAffinity。在官方文档中可以得到关于taskAffinity的以下信息</activity></p>
</blockquote>
<ul>
<li>taskAffinity表示当前activity具有亲和力的一个任务（原句为The task that the activity has an affinity for.），大致可以这样理解，这个 taskAffinity表示一个任务，这个任务就是当前activity所在的任务。     </li>
</ul>
<blockquote>
<p>在概念上，具有相同的affinity的activity（即设置了相同taskAffinity属性的activity）属于同一个任务。    </p>
</blockquote>
<ul>
<li>一个任务的affinity决定于这个任务的根activity（root activity）的taskAffinity。     </li>
<li>这个属性决定两件事：当activity被re-parent时，它可以被re-paren哪个任务中；当activity以FLAG_ACTIVITY_NEW_TASK标志启动时，它会被启动到哪个任务中。（这个比较 难以理解，请结合<activity>中的属性allowTaskReparenting和Intent中的标志 FLAG_ACTIVITY_NEW_TASK加以理解）</activity></li>
<li>默认情况下，一个应用中的所有activity具有相同的taskAffinity，即应用程序的包名。我们可以通过设置不同的taskAffinity属性给应用中的activity分组，也可以把不同的 应用中的activity的taskAffinity设置成相同的值。<br>为一个activity的taskAffinity设置一个空字符串，表明这个activity不属于任何task。<br>回到前面的startActivityUncheckedLocked函数中，这里的变量top就为null了，于是执行下面的else语句</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-0cc6029d58f8217d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/538/format/webp" alt="代码片段"></p>
<p>所以 此时将addintToTask=true 并且sourceRecord = 我们的activity，再往下看</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r.packageName != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="comment">// If the activity being launched is the same as the one currently</span></span><br><span class="line">    <span class="comment">// at the top, then we need to check if it should only be launched</span></span><br><span class="line">    <span class="comment">// once.</span></span><br><span class="line">    ActivityStack topStack = getFocusedStack();</span><br><span class="line">    ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(notTop);</span><br><span class="line">    <span class="keyword">if</span> (top != <span class="keyword">null</span> &amp;&amp; r.resultTo == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) {</span><br><span class="line">            <span class="keyword">if</span> (top.app != <span class="keyword">null</span> &amp;&amp; top.app.thread != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span></span><br><span class="line">                    || launchSingleTop || launchSingleTask) {</span><br><span class="line">                    ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, top,</span><br><span class="line">                            top.task);</span><br><span class="line">                    <span class="comment">// For paranoia, make sure we have correctly</span></span><br><span class="line">                    <span class="comment">// resumed the top activity.</span></span><br><span class="line">                    topStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (doResume) {</span><br><span class="line">                        resumeTopActivitiesLocked();</span><br><span class="line">                    }</span><br><span class="line">                    ActivityOptions.abort(options);</span><br><span class="line">                    <span class="keyword">if</span> ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) {</span><br><span class="line">                        <span class="comment">// We don't need to start a new activity, and</span></span><br><span class="line">                        <span class="comment">// the client said not to do anything if that</span></span><br><span class="line">                        <span class="comment">// is the case, so this is it!</span></span><br><span class="line">                        <span class="keyword">return</span> ActivityManager.START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">                    }</span><br><span class="line">                    top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                    <span class="keyword">return</span> ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">if</span> (r.resultTo != <span class="keyword">null</span>) {</span><br><span class="line">        r.resultTo.task.stack.sendActivityResultLocked(-<span class="number">1</span>, r.resultTo, r.resultWho,</span><br><span class="line">                r.requestCode, Activity.RESULT_CANCELED, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    ActivityOptions.abort(options);</span><br><span class="line">    <span class="keyword">return</span> ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>根据注释我们能看出这个方法是检查当前任务的顶端是否是我们要启动的activity，接着往下看，便是启动activity</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">boolean</span> newTask = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> keepCurTransition = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    TaskRecord taskToAffiliate = launchTaskBehind &amp;&amp; sourceRecord != <span class="keyword">null</span> ?</span><br><span class="line">            sourceRecord.task : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Should this be considered a new task?</span></span><br><span class="line">    <span class="keyword">if</span> (r.resultTo == <span class="keyword">null</span> &amp;&amp; inTask == <span class="keyword">null</span> &amp;&amp; !addingToTask</span><br><span class="line">            &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (isLockTaskModeViolation(reuseTask)) {</span><br><span class="line">            Slog.e(TAG, <span class="string">"Attempted Lock Task Mode violation r="</span> + r);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">        }</span><br><span class="line">        newTask = <span class="keyword">true</span>;</span><br><span class="line">        targetStack = adjustStackFocus(r, newTask);</span><br><span class="line">        <span class="keyword">if</span> (!launchTaskBehind) {</span><br><span class="line">            targetStack.moveToFront();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (reuseTask == <span class="keyword">null</span>) {</span><br><span class="line">            r.setTask(targetStack.createTaskRecord(getNextTaskId(),</span><br><span class="line">                    newTaskInfo != <span class="keyword">null</span> ? newTaskInfo : r.info,</span><br><span class="line">                    newTaskIntent != <span class="keyword">null</span> ? newTaskIntent : intent,</span><br><span class="line">                    voiceSession, voiceInteractor, !launchTaskBehind <span class="comment">/* toTop */</span>),</span><br><span class="line">                    taskToAffiliate);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_TASKS) Slog.v(TAG, <span class="string">"Starting new activity "</span> + r + <span class="string">" in new task "</span> +</span><br><span class="line">                    r.task);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            r.setTask(reuseTask, taskToAffiliate);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!movedHome) {</span><br><span class="line">            <span class="keyword">if</span> ((launchFlags &amp;</span><br><span class="line">                    (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_TASK_ON_HOME))</span><br><span class="line">                    == (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {</span><br><span class="line">                <span class="comment">// Caller wants to appear on home activity, so before starting</span></span><br><span class="line">                <span class="comment">// their own activity we will bring home to the front.</span></span><br><span class="line">                r.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">final</span> TaskRecord sourceTask = sourceRecord.task;</span><br><span class="line">        <span class="keyword">if</span> (isLockTaskModeViolation(sourceTask)) {</span><br><span class="line">            Slog.e(TAG, <span class="string">"Attempted Lock Task Mode violation r="</span> + r);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">        }</span><br><span class="line">        targetStack = sourceTask.stack;</span><br><span class="line">        targetStack.moveToFront();</span><br><span class="line">        <span class="keyword">final</span> TaskRecord topTask = targetStack.topTask();</span><br><span class="line">        <span class="keyword">if</span> (topTask != sourceTask) {</span><br><span class="line">            targetStack.moveTaskToFrontLocked(sourceTask, r, options);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            mWindowManager.moveTaskToTop(topTask.taskId);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// In this case, we are adding the activity to an existing</span></span><br><span class="line">            <span class="comment">// task, but the caller has asked to clear that task if the</span></span><br><span class="line">            <span class="comment">// activity is already running.</span></span><br><span class="line">            ActivityRecord top = sourceTask.performClearTaskLocked(r, launchFlags);</span><br><span class="line">            keepCurTransition = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (top != <span class="keyword">null</span>) {</span><br><span class="line">                ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);</span><br><span class="line">                top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                <span class="comment">// For paranoia, make sure we have correctly</span></span><br><span class="line">                <span class="comment">// resumed the top activity.</span></span><br><span class="line">                targetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (doResume) {</span><br><span class="line">                    targetStack.resumeTopActivityLocked(<span class="keyword">null</span>);</span><br><span class="line">                }</span><br><span class="line">                ActivityOptions.abort(options);</span><br><span class="line">                <span class="keyword">return</span> ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!addingToTask &amp;&amp;</span><br><span class="line">                (launchFlags&amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// In this case, we are launching an activity in our own task</span></span><br><span class="line">            <span class="comment">// that may already be running somewhere in the history, and</span></span><br><span class="line">            <span class="comment">// we want to shuffle it to the front of the stack if so.</span></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord top = sourceTask.findActivityInHistoryLocked(r);</span><br><span class="line">            <span class="keyword">if</span> (top != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">final</span> TaskRecord task = top.task;</span><br><span class="line">                task.moveActivityToFrontLocked(top);</span><br><span class="line">                ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, task);</span><br><span class="line">                top.updateOptionsLocked(options);</span><br><span class="line">                top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                targetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (doResume) {</span><br><span class="line">                    targetStack.resumeTopActivityLocked(<span class="keyword">null</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// An existing activity is starting this new activity, so we want</span></span><br><span class="line">        <span class="comment">// to keep the new one in the same task as the one that is starting</span></span><br><span class="line">        <span class="comment">// it.</span></span><br><span class="line">        r.setTask(sourceTask, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_TASKS) Slog.v(TAG, <span class="string">"Starting new activity "</span> + r</span><br><span class="line">                + <span class="string">" in existing task "</span> + r.task + <span class="string">" from source "</span> + sourceRecord);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (inTask != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// The calling is asking that the new activity be started in an explicit</span></span><br><span class="line">        <span class="comment">// task it has provided to us.</span></span><br><span class="line">        <span class="keyword">if</span> (isLockTaskModeViolation(inTask)) {</span><br><span class="line">            Slog.e(TAG, <span class="string">"Attempted Lock Task Mode violation r="</span> + r);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">        }</span><br><span class="line">        targetStack = inTask.stack;</span><br><span class="line">        targetStack.moveTaskToFrontLocked(inTask, r, options);</span><br><span class="line">        targetStack.moveToFront();</span><br><span class="line">        mWindowManager.moveTaskToTop(inTask.taskId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check whether we should actually launch the new activity in to the task,</span></span><br><span class="line">        <span class="comment">// or just reuse the current activity on top.</span></span><br><span class="line">        ActivityRecord top = inTask.getTopActivity();</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="keyword">null</span> &amp;&amp; top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) {</span><br><span class="line">            <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span></span><br><span class="line">                    || launchSingleTop || launchSingleTask) {</span><br><span class="line">                ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task);</span><br><span class="line">                <span class="keyword">if</span> ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// We don't need to start a new activity, and</span></span><br><span class="line">                    <span class="comment">// the client said not to do anything if that</span></span><br><span class="line">                    <span class="comment">// is the case, so this is it!</span></span><br><span class="line">                    <span class="keyword">return</span> ActivityManager.START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">                }</span><br><span class="line">                top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                <span class="keyword">return</span> ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!addingToTask) {</span><br><span class="line">            <span class="comment">// We don't actually want to have this activity added to the task, so just</span></span><br><span class="line">            <span class="comment">// stop here but still tell the caller that we consumed the intent.</span></span><br><span class="line">            ActivityOptions.abort(options);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_TASK_TO_FRONT;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        r.setTask(inTask, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_TASKS) Slog.v(TAG, <span class="string">"Starting new activity "</span> + r</span><br><span class="line">                + <span class="string">" in explicit task "</span> + r.task);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// This not being started from an existing activity, and not part</span></span><br><span class="line">        <span class="comment">// of a new task...  just put it in the top task, though these days</span></span><br><span class="line">        <span class="comment">// this case should never happen.</span></span><br><span class="line">        targetStack = adjustStackFocus(r, newTask);</span><br><span class="line">        targetStack.moveToFront();</span><br><span class="line">        ActivityRecord prev = targetStack.topActivity();</span><br><span class="line">        r.setTask(prev != <span class="keyword">null</span> ? prev.task : targetStack.createTaskRecord(getNextTaskId(),</span><br><span class="line">                        r.info, intent, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">true</span>), <span class="keyword">null</span>);</span><br><span class="line">        mWindowManager.moveTaskToTop(r.task.taskId);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_TASKS) Slog.v(TAG, <span class="string">"Starting new activity "</span> + r</span><br><span class="line">                + <span class="string">" in new guessed "</span> + r.task);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName,</span><br><span class="line">            intent, r.getUriPermissionsLocked(), r.userId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span> &amp;&amp; sourceRecord.isRecentsActivity()) {</span><br><span class="line">        r.task.setTaskToReturnTo(RECENTS_ACTIVITY_TYPE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (newTask) {</span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, r.userId, r.task.taskId);</span><br><span class="line">    }</span><br><span class="line">    ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task);</span><br><span class="line">    targetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">    targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</span><br><span class="line">    <span class="keyword">if</span> (!launchTaskBehind) {</span><br><span class="line">        <span class="comment">// Don't set focus on an activity that's going to the back.</span></span><br><span class="line">        mService.setFocusedActivityLocked(r);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ActivityManager.START_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先将newTask变量初始化为false，表示不要在新的任务中启动Activity。由于前面的已经把addingToTask设置为true，因此，这里会执行中间的else if语句，即这里会把r.task设置为sourceRecord.task，即把即将启动的Activity放在原Activity所在的任务中启动。最后，就是调用startActivityLocked函数继续进行启动Activity的操作了</p>
<p>声明： 以上内容拷贝自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/09365022adac">简书作者jiantao的文章，供自己学习使用</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/04/06/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC22%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/06/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC22%E7%AB%A0/" class="post-title-link" itemprop="url">第22章：插件化技术总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-06 21:52:00" itemprop="dateCreated datePublished" datetime="2021-04-06T21:52:00+08:00">2021-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-08 10:13:41" itemprop="dateModified" datetime="2022-06-08T10:13:41+08:00">2022-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>这章是重新梳理插件化技术的整体思路</p>
<h2 id="插件的工程化"><a href="#插件的工程化" class="headerlink" title="插件的工程化"></a>插件的工程化</h2><p>插件化技术分为宿主App 和 插件Plugin1这两个 apk，有时候还有 MyPluginLibrary ，宿主和插件都要引用它。</p>
<h2 id="加载插件中的类"><a href="#加载插件中的类" class="headerlink" title="加载插件中的类"></a>加载插件中的类</h2><p>宿主App 想要使用 Plugin1 中的类，还使用 宿主App 中的 ClassLoder 是不行的，由此缠身很多种解决方案：</p>
<ul>
<li>最直接的就是，在反射插件中的类时，使用 Plugin1.apk 对应的 ClassLoader (参考第6章)    </li>
<li>无论是宿主还是插件，他们各自的 ClassLoader 都对应一个 dex 数组，把这些插件的dex数组都合并到宿主的 dex 数组中，那么，宿主App就可以加载任何类(参考9.3节)。     </li>
<li>自定义一个ClassLoader，取代原先宿主的ClassLoader 。同时在自定义的 ClassLoader 中放一个集合，承载所有插件的 ClassLoader 。那么自定义的 ClassLoader 在加载任何一个类的时候，无论是插件还是宿主的类，都会现在宿主中找，如果没有，再遍历 ClassLoader 集合，看哪个 ClassLoader 能加载这个类(参考9.36节)。    </li>
</ul>
<h2 id="哪些地方可以Hook"><a href="#哪些地方可以Hook" class="headerlink" title="哪些地方可以Hook"></a>哪些地方可以Hook</h2><p>关于Hook 的技术可以参考第4章，Hook可以分为三类：</p>
<ul>
<li>在 App 中使用的类，可以Hook。Android 系统源码中被标记为hide的方法和类，<strong>我们可以通过反射使用它们，但是不能Hook</strong>。还有一些类，比如 Instrumentation 和 Callback ，在App中也能用，因此可以Hook替换。             </li>
<li>实现了接口的类，可以Hook。虽然大部分类和方法都标记为hide，但是<strong>只要合格类实现了一个接口，我们就可以借助 Proxy.newProxyInstance 方法去截获它的方法</strong>，比较典型的是 IActivityManager 接口，以及实现这个接口的 AMN 。    </li>
<li>集合。 没办法Hook一个标记为hide 的类，但是如果Android源码中某个类<strong>拥有集合变量的时候，我们可以反射构造出一个对象，然后还是通过反射添加到这个集合中</strong>。典型的是，穿件一个 LoadedApk ，把它事先放在 mPackages 缓存中，这样就能直接命中缓存(参考9.2节)。</li>
</ul>
<h2 id="Activity-的插件化解决方案"><a href="#Activity-的插件化解决方案" class="headerlink" title="Activity 的插件化解决方案"></a>Activity 的插件化解决方案</h2><p>从大方向来讲，分为动态替换和静态代理两种：</p>
<ul>
<li>动态替换：这是“占位”思想。宿主App中声明一个用于占位的 StubActivity ，启动插件中的ActivityA，但是告诉AMS启动的是 StubActivity ，欺骗成功之后，在即将启动Activity时，再把 StubActivity 换回 ActivityA(参考第9章)。      </li>
<li>静态代理。这是一种牵线木偶的思想，在宿主App中设计一个 ProxyActivity ，由他来决定启动插件中的哪个 Activity。<strong>插件中的Activity都是没有生命的，得在ProxyActivity 生命周期中，调用插件Activity 的生命周期函数</strong>(参考9.5节)。</li>
</ul>
<p>此外，还需要解决 LaunchMode 问题，解决方案参考 9.5 节。</p>
<h2 id="资源的解决方案"><a href="#资源的解决方案" class="headerlink" title="资源的解决方案"></a>资源的解决方案</h2><p>资源主要为Activity 服务。主要有两种解决方案：</p>
<ul>
<li>进入Plugin1 ，则加载Plugin1的资源，反射调用 AssetManager 的 addAssetPath 方法，参数是 Plugin1.apk 的路径。每次进入或者离开插件，都要切换资源。这是一件很繁琐的事情(参考第7章)。      </li>
<li>事先把 宿主App的资源以及所有插件的资源都通过 AssetManager 的 addAssetPath 方法添加到一个全局变量中。这样，在插件 Activity 的基类中，重写 Activity 的 getResource 方法，从这个全局变量中提取资源。</li>
</ul>
<p>针对方案2，由于资源合并到一起，就可能发生资源id冲突，由此产生多种解决方案：</p>
<ol>
<li>修改aapt，更改id的前缀(参考15.2节)    </li>
<li>修改resources.arsc，在 aapt 执行完成后，修改生成的文件(参考21章)    </li>
<li>通过 public.xml 固定 plugin1 中所有的资源。这种方案不现实，针对固定一个资源的id还是很好的解决方案。</li>
</ol>
<h2 id="Fragment是哪个门派"><a href="#Fragment是哪个门派" class="headerlink" title="Fragment是哪个门派"></a>Fragment是哪个门派</h2><p>Fragment 与Activity 的最大区别，就是后者的一举一动需要和 AMS 交互，而Fragment不用。这种方案整个应用只有一个Activity ，Fragment 可以在 宿主App 中或者 插件中，只要使用合适的 ClassLoader 加载插件中的类，使用合适的 AssetManager 加载插件中的资源，就是一个完美的解决方案。可以参考 16 章。</p>
<h2 id="Service、ContentProvider-和-BroadcastReceiver-插件化通用方案"><a href="#Service、ContentProvider-和-BroadcastReceiver-插件化通用方案" class="headerlink" title="Service、ContentProvider 和 BroadcastReceiver 插件化通用方案"></a>Service、ContentProvider 和 BroadcastReceiver 插件化通用方案</h2><p>因为这三者的数量并不多，插件化中也不会动态新增一个组件，所以最简单的方案是：在 宿主App 的 AndroidManifest 文件中事先声明这些组件。缺点是不能动态新增一个组件。参考 8.1节。</p>
<h2 id="特定于Service-的插件化解决方案"><a href="#特定于Service-的插件化解决方案" class="headerlink" title="特定于Service 的插件化解决方案"></a>特定于Service 的插件化解决方案</h2><p>如果不事先在宿主App中声明插件的Service，那么Service 也有自己的解决方案：</p>
<ul>
<li>动态代理。也是欺上瞒下的思路。Service 不同于 Activity ，一个StubActivity 可以对应多个插件Activity，但是StubService 和插件Service 只能一一对应，所以应该在 宿主App 中声明多个 StubService。参考第10章。</li>
<li>静态代理，牵线木偶思想。创建一个ProxyService，由 ProxyService 来启动插件中的Service，缺点是插件中有几个Service，宿主App 中就要有相同数量的 ProxyService。，参见 14.1和 14.2.</li>
<li>结合前两种，能否在 宿主App中只声明一个Stubservice。参考 14.4</li>
</ul>
<h2 id="特定于BroadcastReceiver-的插件化解决方案"><a href="#特定于BroadcastReceiver-的插件化解决方案" class="headerlink" title="特定于BroadcastReceiver 的插件化解决方案"></a>特定于BroadcastReceiver 的插件化解决方案</h2><p>它的插件化解决方案是把静态的Receiver 转换为动态的Receiver。</p>
<h2 id="特定于ContentProvider-的插件化解决方案"><a href="#特定于ContentProvider-的插件化解决方案" class="headerlink" title="特定于ContentProvider 的插件化解决方案"></a>特定于ContentProvider 的插件化解决方案</h2><p>占位思想。宿主App 中由 StubContentProvider 来欺骗 AMS，而实际执行的是 插件中的 ContentProvider 。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/04/06/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC15%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/06/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC15%E7%AB%A0/" class="post-title-link" itemprop="url">第15章：再谈资源</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-06 21:29:00 / 修改时间：22:05:51" itemprop="dateCreated datePublished" datetime="2021-04-06T21:29:00+08:00">2021-04-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Android-App-打包流程"><a href="#Android-App-打包流程" class="headerlink" title="Android App 打包流程"></a>Android App 打包流程</h2><p>早期Android打包都是基于Ant来做，为此我们需要熟悉Android App 打包的每一个过程。随着Gradle的问世，打包简化为几行配置代码。一套完整的Android App 打包流程如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8C%87%E5%8D%97/%E7%AC%AC15%E7%AB%A0/Android%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B.png" alt="Android打包流程图"></p>
<p>介绍下各部分的作用：</p>
<ul>
<li>aapt： 为res目录下的资源生成 R.java 文件，<strong>同时为AndroidManifest生成Manifest.java文件</strong>     </li>
<li>aidl： 把项目中自定义的aidl文件生成相应的java代码文件    </li>
<li>javac： 把项目中所有的Java 代码编译成 class 文件。包括3部分： 自己写的代码；aapt生成的代码；aidl生成的Java文件    </li>
<li>proguard： 混淆的同时生成proguardMapping.txt，这个步骤是可选的    </li>
<li>dex： 把所有的class文件(包括第三方库的class 文件)转换为dex文件      </li>
<li>aapt： 这里还是使用aapt，这里是它的另一个功能：打包。即将res目录下的资源、assets下的文件，打包成一个 .ap_ 文件     </li>
<li>apkbuilder：将所有的dex、ap_文件、AndroidManifest.xml 打包为.apk文件，此时未签名       </li>
<li>jarsigner： 签名    </li>
<li>zipalign： 对齐，以便运行时节省内存           </li>
</ul>
<h2 id="资源冲突解决方案一：修改AAPT"><a href="#资源冲突解决方案一：修改AAPT" class="headerlink" title="资源冲突解决方案一：修改AAPT"></a>资源冲突解决方案一：修改AAPT</h2><p>插件中的资源id可能会和宿主资源id是同一个值，为了解决资源id冲突，有3中解决方案：</p>
<ul>
<li>修改打包流程中的aapt命令，为插件资源id指定 0x71 之类的前缀，就可以避免冲突     </li>
<li>仍然是将插件资源的id前缀改为 0x71，但是在Android打包生成 resources.arsc 文件后，对这个文件进行修改(具体可见21.2节)       </li>
<li>进入到哪个插件，就为这个插件生成新的 AssetManager 和 Resources 对象，使用这两个新对象加载资源，就只能是插件中的资源，永远不会和宿主中冲突(详见 7.2)</li>
</ul>
<h3 id="修改并生成新的aapt命令"><a href="#修改并生成新的aapt命令" class="headerlink" title="修改并生成新的aapt命令"></a>修改并生成新的aapt命令</h3><p>R文件中有十六进制整数变量，内容如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码</span></span><br></pre></td></tr></tbody></table></figure>

<p>这些十六进制的变量，由三部分组成： packageId(apk包id，默认 0x7f) + typeId(资源类型，如attr=0x01，drawable=0x02，还有layout、string等) + entryId(typeId下的资源编码，从0开始递增)。以 0x7f0b006d 为例，packageId 为 0x7f，typeId为 0b，entryId 为 006d。</p>
<p>插件中为防止资源冲突，会为每个插件设置不同的packageId，比如游戏大厅中，斗地主插件可能是 0x71开头，斗牛可能是 0x72。为asset 生成 R 文件 是通过 aapt 完成的，为了实现上述目的，我们要修改 aapt 源码，定位到 Android SDK，找到 aapt 目录，里面有一堆 C 代码， 命令行工具就是用这些代码编译成的，可以在这个目录直接搜索 0x7f，在 ResourcesTable.cpp 中可以找到如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br></pre></td></tr></tbody></table></figure>

<p>在 ResourcesTable 的构造函数中，有一个 Bundle 类型的参数，其次，判断 mPackageType 如果是 App，则都是 0x7f，此外 0x01 和 0x00 都被系统占用了，所以我们不要将这两个值设置为插件的 id前缀(事实上，有些手机厂商会占用其他的一些值，为了保险，我们一般只使用 0x71~0xff 作为插件的前缀)。修改 AAPT 的代码，基本思路如下：</p>
<ol>
<li>在 aapt 的命令行参数中传递打包时的前缀   </li>
<li>把这个值设置给 Bundle 实体的 mApkModule 字段，作为 ResourcesTable 的构造函数参数传入        </li>
<li>在 ResourcesTable 构造函数读取 mApkModule 值，也就是前缀值，设置给 packageId    </li>
</ol>
<p>实现代码： 略</p>
<h3 id="在插件化项目中使用新的aapt命令"><a href="#在插件化项目中使用新的aapt命令" class="headerlink" title="在插件化项目中使用新的aapt命令"></a>在插件化项目中使用新的aapt命令</h3><p>现在，可以用我们修改的aapt文件替换sdk下的aapt 命令，但是如果这么做，每当Android系统更新，我们都要替换一次aapt命令。一种可行的做法是，我们把这个新的 aapt 工具命名为 aapt_mac ，放到项目的根目录下：</p>
<p><img src="" alt="自定义的aapt放置"></p>
<p>之后，修改项目中 gradle 文件：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>上述脚本通过反射，<strong>把aapt的路径临时修改为指向当前App根目录下的aapt_mac</strong>。此外，我们将App的资源前缀设置为 0x71 ，这样在打包后，R文件中的资源就以 0x71 作为前缀了。</p>
<h2 id="public-xml-固定资源id值"><a href="#public-xml-固定资源id值" class="headerlink" title="public.xml 固定资源id值"></a>public.xml 固定资源id值</h2><p>如下场景：多个插件都需要<strong>同一个</strong>自定义控件，于是我们把这个自定义控件卸载宿主 App，插件调用宿主的Java 代码，使用宿主的资源(有控件肯定有资源)。考虑到App在每次打包后，随着资源的增减，同一个资源id的值可能会发生变化。为避免这种情况，我们可以<strong>把公用的资源id值固定写死</strong>，如下public.xml文件所示（注意，type和id后面的空格不可省略）：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"&gt;</span></span><br><span class="line"><span class="meta">&lt;resources&gt;</span></span><br><span class="line"><span class="meta">    &lt;public type="string" name="string1" id="0x7f050024"/&gt;</span></span><br><span class="line"><span class="meta">&lt;/resources&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>之后，把public.xml放到 res/values 目录下，R.string.string1 这个资源就会固定成 0x7f050024。当然，还可以指定资源值的一个区间,将上述代码中间那行改成如下代码即可：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">public-padding</span> <span class="attr">name</span>=<span class="string">"my_"</span> <span class="attr">end</span>=<span class="string">"0x7f02000f"</span> <span class="attr">start</span>=<span class="string">"0x7f020001"</span> <span class="attr">type</span>=<span class="string">"drawable"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是从gradle 1.3开始，就忽略 public.xml了，因此需要我们自己使用gradle 脚本来实现，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>之后，打包宿主 ActivityHost1 ，使用Jadx-GUI 查看资源id，可以看到 R.string.string1 的值永远是 2131034148(也即十六进制0x7f050024)。</p>
<h2 id="插件使用宿主的资源"><a href="#插件使用宿主的资源" class="headerlink" title="插件使用宿主的资源"></a>插件使用宿主的资源</h2><p>宿主资源值固定了，但是插件怎么访问宿主中的资源呢？如果插件内部能保持一个对宿主项目的引用，那就可以随便访问宿主的任何资源了。<strong>我们需要编写gradle脚本，把宿主打包成 jar 包。之后设置插件的gradle文件，通过provided来引用这个jar包</strong>。之前介绍过，provided方式引用只在编码时候有用，正式打包的时候不会被引用进去。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章给出插件化中资源id冲突的解决方案：</p>
<ul>
<li>把宿主和插件的资源都合并到一起，通过AssetManager的addAssetPath 来实现。只不过，<strong>这种方案会产生资源id冲突的问题</strong>      </li>
<li>如果不事先合并资源，那就为每个插件创建一个 AssetManager，每个 AssetManager 都是通过反射调用 addAssetPath 方法，把插件资源加进去。当宿主进入一个插件时，就把 AssetManager 切换为 插件的AssetManager ；反之，当从插件回到宿主的时候，再把 AssetManager 切换回宿主的 AssetManager(详见第5章的loadResource方法)。</li>
</ul>
<p>第一种方案，主要缺陷是资源冲突，并且资源id的前缀是有限的，也就256个值，如果超过256个插件，就要使用方案2了。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/03/28/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC12%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/28/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC12%E7%AB%A0/" class="post-title-link" itemprop="url">第12章：ContentProvider的插件化解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-28 17:29:00 / 修改时间：17:43:57" itemprop="dateCreated datePublished" datetime="2021-03-28T17:29:00+08:00">2021-03-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="ContentProvider基本概念"><a href="#ContentProvider基本概念" class="headerlink" title="ContentProvider基本概念"></a>ContentProvider基本概念</h2><p>ContentProvider 就是一个SQLite 数据库，数据提供方A和数据使用方B是通过<strong>匿名共享内存</strong>来传输数据的。B告诉A，“你把数据写在这个内存地址上”；B准备好数据，写到A要求的内存地址上，A就可以直接使用这些数据了。当数据量非常大的时候，这个数据传递速度是非常快的。</p>
<p>并不是所有数据传递都需要ContentProvider，比如，Activity 跳转时，数据的传递就用的 Binder，一般来说，传输的数据量不超过 1 M 时，使用Binder；否则，此时需要ContentProvider 。</p>
<h2 id="ContentProvider-插件化"><a href="#ContentProvider-插件化" class="headerlink" title="ContentProvider 插件化"></a>ContentProvider 插件化</h2><p>前面介绍了 BroadCastReceiver 的插件化解决方案，即把插件中的静态广播都转换为动态广播，然后手动注册到宿主App的广播中。</p>
<p>其实，ContentProvider 也能这么做，这时候不叫“注册”，而叫“安装”。安装当前Apk中所有的ContentProvider 的方法位于 ActivityThread 的 installContentProviders方法中：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码略</span></span><br></pre></td></tr></tbody></table></figure>

<p>我么你只需要手动执行这个方法，把插件中的ContentProvider 集合作为第二个参数填进去即可。如此一来，我们得到了ContentProvider 插件化的解决方案：</p>
<ol>
<li>沿用Activity插件化的第二种方案，将宿主App和插件App的dex合并到一起     </li>
<li>借助PackageParse的parsePackage方法，读取插件中的ContentProvider信息，然后把得到的Package对象转换为我们需要的 ProviderInfo类型对象     </li>
<li>将ContentProvider 的packageName 设置为当前apk的packageName，之后把插件中的 ContentProvider 放入宿主中     </li>
<li>通过反射执行 ActivityThread 的 installContentProviders 方法，把ContentProvider 作为插件的参数，相当于把插件 ContentProvider “安装” 到宿主App中     </li>
</ol>
<h2 id="执行这段Hook代码的时机"><a href="#执行这段Hook代码的时机" class="headerlink" title="执行这段Hook代码的时机"></a>执行这段Hook代码的时机</h2><p>ContentProvider 这个组件，往往是提供给外界使用的，如果插件中的ContentProvider 还没安装到宿主App中，第三方就来调用了，那就要等很久了，所以安装插件 ContentProvider 的过程越早越好。<strong>App安装自身的 ContentProvider 是在ActivityThread 执行 installContentProviders 方法中，这个方法比Application 的onCreate 要早，但是会晚于 Application 的 attachBaseContent 方法，所以，我们可以在 attachBaseContent 方法中，手动执行 ActivityThread 的 installContentProviders</strong> 。</p>
<h2 id="ContentProvider-的转发机制"><a href="#ContentProvider-的转发机制" class="headerlink" title="ContentProvider 的转发机制"></a>ContentProvider 的转发机制</h2><p>让外界App直接调用当前App的插件里定义的ContentProvider ，并不是理想的解决方案。最好的是在宿主App中定义一个 StubContentProvider 作为中转，让外界调用当前App的 StubContentProvider ，然后在 StubContentProvider 中再调用插件里的 ContentProvider：</p>
<p><img src="/assets/Book-Notes/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8C%87%E5%8D%97/%E7%AC%AC12%E7%AB%A0/ContentProvider%E6%8F%92%E4%BB%B6%E5%8C%96%E5%88%86%E5%8F%91%E6%80%9D%E6%83%B3.png" alt="ContentProvider插件化分发思想"></p>
<p>ContentProvider 插件化的精髓在于分发，外界使用 App 提供的 ContentProviderA 时，只知道发送给一个宿主AndroidManifest 中声明锅的 ContentProviderA，而受到请求后，再做二次转发。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/03/28/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC11%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/28/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC11%E7%AB%A0/" class="post-title-link" itemprop="url">第11章：BroadcastReceiver的插件化解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-28 11:41:00 / 修改时间：17:03:38" itemprop="dateCreated datePublished" datetime="2021-03-28T11:41:00+08:00">2021-03-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Receiver概述"><a href="#Receiver概述" class="headerlink" title="Receiver概述"></a>Receiver概述</h2><p>Receiver分为动态和静态两种，简单讨论下区别：</p>
<ul>
<li>静态广播在 AndroidManifest 中注册，因为Android系统重启时，PMS都会解析App中的AndroidManifest，所以<strong>静态广播都存在于 PMS 中</strong>      </li>
<li>动态广播通过 Context 的registerReceiver 方法最终调用 AMN.getDefault().registerReceiver 方法，所以，<strong>动态广播的注册信息存在于 AMS 中</strong>       </li>
</ul>
<p>除了注册方式不一样，后续发送和接收的过程就一样了。整个过程简单如下：1、Context 发送广播，最终通过 AMN.getDefault().broadcastIntent，把要发送的广播告诉AMS。2、AMS收到消息后，根据intent-filter 筛选 PMS 和 AMS (即静态广播和动态广播)中符合条件的接收器，通知App进程启动这些广播(调用这些广播的 onReceive)。</p>
<h2 id="动态广播的插件化解决方案"><a href="#动态广播的插件化解决方案" class="headerlink" title="动态广播的插件化解决方案"></a>动态广播的插件化解决方案</h2><p>对于动态广播，我们只需要确保宿主App能加载插件中的这个动态广播类就行(因为这里并不需要直接与AMS打交道，只是个类而已)。通过9.3节的dex合并技术，就能做到了。</p>
<h2 id="静态广播解决方案"><a href="#静态广播解决方案" class="headerlink" title="静态广播解决方案"></a>静态广播解决方案</h2><p>静态广播无法像Activity那样，即使没在AndroidManifest 中注册也能生效，因为无论是注册还是发送广播，都必须有 IntentFilter，其中的action是可以随意设置的，所以我们对于 Receiver 压根就不能通过类似 Activity 的插桩方式。只有另辟蹊径。</p>
<h3 id="静态广播当做动态广播处理"><a href="#静态广播当做动态广播处理" class="headerlink" title="静态广播当做动态广播处理"></a>静态广播当做动态广播处理</h3><p>具体分为两步：</p>
<ol>
<li>PMS 只能读取宿主 App 的AndroidManifest 文件，读取其中的静态广播并注册。我们可以反射，手动控制PMS读取插件AndroidManifest 中声明的静态广播列表。     </li>
<li>遍历这个静态广播列表，使用 classLoader 加载列表中每个广播类，实例化成一个对象，<strong>然后作为动态广播注册到AMS中</strong>           </li>
</ol>
<h3 id="静态广播的插件化终极解决方案"><a href="#静态广播的插件化终极解决方案" class="headerlink" title="静态广播的插件化终极解决方案"></a>静态广播的插件化终极解决方案</h3><p>上述静态广播当做动态广播的方案，这丧失了静态广播的特性——不需要启动App就可以启动一个静态广播。所以我们仍要探寻如何不启动App也能和插件中的静态广播通信。</p>
<p>回忆一下前面介绍的Activity 和 Service 插件化的占位思想：</p>
<ul>
<li>Activity 只需要一个占位 StubActivity 就能面对大部分插件Activity了，对于LaunchMode 的其他三种形式，则需要更多的占位 StubActivity 应对     </li>
<li>Service 也需要占位 StubService ，但是一个 StubService 只能对应一个插件中的Service，所以我们需要在宿主App中占位多个 StubService，通过json来配置映射关系。    </li>
</ul>
<p>如果也用占位的思想，每个静态广播需要携带一个或者多个Action，StubReceiver 也不例外，如果 StubReceiver 和插件中的静态广播是一对多的关系，那么从外界发送一个广播到App，<strong>就会触发插件中的所有静态广播</strong>。由此得出：<strong>StubReceiver 和插件中的广播只能是一对一的关系</strong>。</p>
<p>不过，我们可以为一个广播设置多个Action，这样我们就不需要预先创建很多个StubReceiver用来面对插件中的静态广播了，只需要一个 StubReceiver ，为它配置很多个 action 即可。这样，插件中的静态广播就要和这些 action 建立一对一的关系，还是以前的思路，使用<strong>Json配置映射关系就行</strong>。</p>
<p>还有，AndroidManifest 中<strong>支持为每个组件配置 metadata</strong>，利用这个特性，为插件中每个静态广播配置对应的 StubReceiver 中的 action ，如下所示：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyReceiver"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">baobao/</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"oldAction"</span> <span class="attr">android:value</span>=<span class="string">"jianqiang1"</span>&gt;</span><span class="tag">&lt;/<span class="name">meta-data</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyReceiver2"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span> &gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"baobao2"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"oldAction"</span> <span class="attr">android:value</span>=<span class="string">"jianqiang2"</span>&gt;</span>&lt;/meta-data&gt; </span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>解析插件中的 AndroidManifest 文件，可以借助11.3章节介绍的ReceiverHelper 类的 preLoadReceiver 方法，在遍历插件中的每个静态的 Receiver 时，去除Receiver 的metadata 数据，根据oldAction值，对应到Receiver，比如 MyReceiver 对应 jianqiang1，MyReceiver2 对应 jianqiang2 。</p>
<p>之后，把插件中的Receiver 手动注册为动态广播。宿主中定义的<strong>StubReceiver占位广播的作用是分发</strong>。</p>
<p>这就解决了静态广播的问题，<strong>我们可以在App没启动的时候，就启动插件中的静态广播</strong>(我其实还是没看懂怎么在没有启动App的情况，就能启动这个静态广播，后续长丝下)。美中不足的是，这个StubReceiver 需要配置很多个 Action 。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/03/27/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC10%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC10%E7%AB%A0/" class="post-title-link" itemprop="url">第10章：Service的插件化解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-27 21:29:00" itemprop="dateCreated datePublished" datetime="2021-03-27T21:29:00+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 22:16:28" itemprop="dateModified" datetime="2021-03-29T22:16:28+08:00">2021-03-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Android界的荀彧和荀攸：Service和Activity"><a href="#Android界的荀彧和荀攸：Service和Activity" class="headerlink" title="Android界的荀彧和荀攸：Service和Activity"></a>Android界的荀彧和荀攸：Service和Activity</h2><p>根据Context的族谱，Service 是 Activity 的叔叔，结合作用来看，二者有太多相似，但是备份不同，类似三国时期的荀彧和荀攸。不过，二者的区别也挺明显：</p>
<ul>
<li>Activity 是面向用户的，有大量的用户交互的方法，而Service 是后台运行的，生命周期函数很少    </li>
<li>Activity 中有LaunchMode 的概念，每个Activity启动时都会放在栈顶，根据不同的 LaunchMode 可能会有复用以前的实例或者不复用以前的实例。但是Service不同，<strong>同一个 Service 调用多次startService并不会启动多个实例，只会有一个实例</strong>，所以，只用一个StubActivity 是应付不了多个插件的Service 的     </li>
<li>ActivityThread 最终通过Instrumentation 启动一个Activity。而ActivityThread 启动Service 并不借助于 Instrumentation ，而是直接把Service 反射出来就启动了    </li>
</ul>
<p>注意一点，Service 有两种形式： 由 startService 启动的服务；由 bindService 绑定的服务。二者的区别在于：startService 以及对应的 stopService ，就是简单地启动和停止 Service ；bindService 执行时会传递一个 ServiceConnection 对象给 AMS ，接下来 Service 在执行 onBind 时，可以把生成的 binder 对象返回给 App 调用端，这个值存于 ServiceConnection 对象的 onServiceConnected 回调函数的第二个参数中。       </p>
<h2 id="预先占位"><a href="#预先占位" class="headerlink" title="预先占位"></a>预先占位</h2><p>前面说过，Service 与 Activity 不一样，它只会存在一个实例，所以只用一个StubService 是应付不了多个插件Service 的。考虑到在绝大部分App中Service 数据不会超过10个，所以我们完全可以在宿主App 中创建 10 个 StubService ，StubService1，StubService2…StubService10 ，每个 StubService 只对应插件中的一个Service，如下图：</p>
<p><img src="/assets/Book-Notes/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8C%87%E5%8D%97/%E7%AC%AC10%E7%AB%A0/StubService%E5%8D%A0%E4%BD%8D%E7%A4%BA%E6%84%8F.png" alt="StubService占位示意"></p>
<p>接下来就是让每个插件Service匹配一个宿主中的 StubService 了，有两种匹配方式：</p>
<ul>
<li>服务器下发一个 JSON 字符串，给出二者的一一对应关系     </li>
<li>在每个插件 App 的 assets 目录中，创建一个 plugin_config 配置文件，把这个 JSON 字符串放进去</li>
</ul>
<p>第2种做法更自然，不需要和服务器交互，json文件解析类似如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String strJson = Utils.readZipFileString(dexFile.getAbsolutePath(), <span class="string">"assets/plugin_config.json"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strJson == <span class="keyword">null</span> || TextUtils.isEmpty(strJson)) {</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">JSONObject jobject = <span class="keyword">new</span> JSONObject(strJson.replaceAll(<span class="string">"\r|\n"</span>, <span class="string">""</span>));</span><br><span class="line">JSONArray jsonArray = jobject.getJSONArray(<span class="string">"plugins"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; jsonArray.length(); i++) {</span><br><span class="line">    JSONObject jsonObject = (JSONObject) jsonArray.get(i);</span><br><span class="line">    UPFApplication.pluginServices.put(</span><br><span class="line">        jsonObject.optString(<span class="string">"PluginService"</span>),</span><br><span class="line">        jsonObject.optString(<span class="string">"StubService"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们将 JSON 转化为一个 HashMap ，<strong>以插件的类名作为key，以宿主的替身作为value</strong>，这个HashMap 存放在宿主App 的 UPFApplication 的 plutinServices 中，是一个全局变量。</p>
<h2 id="startService-的解决方案"><a href="#startService-的解决方案" class="headerlink" title="startService 的解决方案"></a>startService 的解决方案</h2><p>Service 的插件化机制和Activity 很像，因为它们是亲戚。我们首先从简单的startService 和 stopService 的插件化做起。</p>
<p>首先，把插件和宿主的dex合并，之前有封装过 BaseDexClassLoaderHookHelper 类，合并后才能随心所欲加载类；其次，采用“欺骗AMS”方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即 Hook AMN 的 gDefault，它是一个Singleton 对象，之后创建它的代理对象 MockClass1 ，然后替换这个字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//之后，再Hook 到 Handler 类型的 H 类的 mCallback 字段，替换为 MockClass2</span></span><br></pre></td></tr></tbody></table></figure>

<p>主要流程分析一下：</p>
<ol>
<li><p>Hook AMN，让 AMS 启动 StubService，这次要拦截的是 startServcie 和 stopService 这两个方法(也即在AMN中就拦截这两个方法，将要操作的目标Service替换成相应的StubService)。不过，这次不再需要把 Intent 缓存了，因为有了 UPFApplication 中的 plutinServices ，我们可以根据插件 Service 找到对应的 StubService，也可以根据 StubService 反向找到 Service</p>
</li>
<li><p>AMS 被“欺骗”之后，它原本会通知App启动StubService，而我们要Hook掉ActivityThread 的 mH 对象的 mCallback 对象，仍然截获它的 handleMessage 方法，只不过这次截获的是 “CREATE_SERVICE” 分支，这个分支执行 ActivityThread 的 handleCreateService 方法。在 handleCreateService 中，并不能获取到 App 发送给 AMS 的 Intent，AMS 要启动那个Service ，这个信息是存在 handleCreateService 方法的 dat 参数中，是 CreateServiceData 类型的。Android系统的实现如下：   </p>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span> <span class="params">(CreateServiceData data)</span> </span>{ </span><br><span class="line">    LoadedApk packageinfo = getPackageinfoNoCheck(data.info.applicationinfo, data.compatInfo);</span><br><span class="line">    Service service = <span class="keyword">null</span>; </span><br><span class="line">    java.lang.ClassLoader cl= packageinfo.getClassLoader(); </span><br><span class="line">    service = (Service) cl.loadClass(data.info.name).newinstance(); </span><br><span class="line">    <span class="comment">//省略无关代码</span></span><br><span class="line">    service . onCreate ();</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码中，data.info.name 就是Service 的名称，<strong>所以我们只需要将这个值 Hook 为插件的Service即可</strong>。至此，一个支持 startService 的插件化框架就完成了。</p>
<h2 id="bindService-的解决方案"><a href="#bindService-的解决方案" class="headerlink" title="bindService 的解决方案"></a>bindService 的解决方案</h2><p>有了前面的基础，Service 的 bind 与 unbind 就非常简单了，只要在 AMN 的Hook 中添加一个分支，在 “bindService” 的时候 “欺骗AMS” 就行：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (”bindService”.equals(method . getName())) { </span><br><span class="line">    <span class="comment">//找到参数里面的第一个 Intent 对象</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (inti= <span class="number">0</span>; i &lt; args . length ; i++) { </span><br><span class="line">        <span class="keyword">if</span> (args [i) <span class="keyword">instanceof</span> Intent) { </span><br><span class="line">            index = i ; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Intent rawintent = (Intent) args[index); </span><br><span class="line">    String rawServiceName = rawintent.getComponent().getClassName(); </span><br><span class="line">    String stubServiceName = UPFApplication.pluginServces.get(rawServiceName)</span><br><span class="line">    <span class="comment">//替换 Plugin Service of StubService </span></span><br><span class="line">    ComponentName componentName =<span class="keyword">new</span> ComponentName(stubPackage, stubServiceName); </span><br><span class="line">    Intent newintent = <span class="keyword">new</span> Intent(); </span><br><span class="line">    newintent.setComponet(componentName);</span><br><span class="line">    <span class="comment">//替换 Intent ，欺骗 AMS</span></span><br><span class="line">    args[index] = newintent ; </span><br><span class="line">    Log.d(TAG, ” hook success <span class="string">"); </span></span><br><span class="line"><span class="string">    return method.invoke(mBase , args);</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个过程就完成了，接下来就是使用：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unbind</span></span><br><span class="line">btnBind.setOnClickListener(<span class="keyword">new</span> View.OnclickListener(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> Intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"jianqiang.com.testservice1"</span>), <span class="string">"jianqiang.com.testservice1.MyService2"</span>);</span><br><span class="line">        bindService(intent, conn, Service.BIND_AUTO_CREATE);</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">//unbind</span></span><br><span class="line">btnUnbind.setOnClickListener(<span class="keyword">new</span> View.OnclickListener(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{</span><br><span class="line">        unbindService(conn);</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>看了上面的使用方法，可能会有疑惑了：</p>
<ul>
<li>上半场，对于unbind行为，为什么不像bind一样在 unbind 的时候做“欺骗AMS”？    </li>
<li>下半场，为什么不用在MockClass2中写代码，把StubService2 换回 MyService2？        </li>
</ul>
<p>关于第一个问题，因为我们 unbind 的语法是这样的 <em>unbindService(conn)</em> ，只需要一个 ServiceConnection 类型的参数 conn 即可，这个 conn 在前面的bindService 时用到了，<strong>AMS 会根据这个conn 来找到对应的Service，所以并不需要在unbind的时候去做欺骗</strong>。</p>
<p>第二个问题，这要从Android 系统源码说起，bindService 过程在 AMS通知 App 下半场的流程图如下所示：</p>
<p><img src="/assets/Book-Notes/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8C%87%E5%8D%97/%E7%AC%AC10%E7%AB%A0/bindService%E8%BF%87%E7%A8%8BAMS%E9%80%9A%E7%9F%A5App%E8%BF%99%E4%B8%8B%E5%8D%8A%E5%9C%BA.png" alt="bindService过程AMS通知App这下半场"></p>
<p>也就是说，bindService 先走114(handleCreateSrvice)分支，再走 121 (handleBindService) ，在 handleCreateSrvice 中已经把我们要启动的 MyService2 放到了 mService 这个集合中了，那么，在 handleBindService 和 handleUnbindService 中，都会从 mService 集合中找到 Service2 。在之前章节，为了解决 createService ，已经拦截了 114 分支把 StubService2 换回了 MyService2 了，所以我们不需要要拦截 121 和 122 了， 无需再MockClass2 添加额外代码。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里给出Service第一种解决方案——预先占位，在宿主中预先声明若干个StubService。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/03/27/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC9%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/27/%E4%B9%A6-Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC9%E7%AB%A0/" class="post-title-link" itemprop="url">第9章：Activity的插件化解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-27 20:05:00" itemprop="dateCreated datePublished" datetime="2021-03-27T20:05:00+08:00">2021-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 22:17:24" itemprop="dateModified" datetime="2021-03-29T22:17:24+08:00">2021-03-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>Activity的插件化需要解决3方面的技术问题：</p>
<ul>
<li>宿主App可以加载插件App中的类         </li>
<li>宿主App可以加载插件中的App资源           </li>
<li>宿主App可以加载插件中的Activity          </li>
</ul>
<h2 id="启动没有在AndroidManifest中声明的插件Activity"><a href="#启动没有在AndroidManifest中声明的插件Activity" class="headerlink" title="启动没有在AndroidManifest中声明的插件Activity"></a>启动没有在AndroidManifest中声明的插件Activity</h2><p>在5.4节介绍了启动没有在AndroidManifest 中声明的 Activity，借助宿主App中的StubActivity ，在 AMN 中欺骗，在ActivityThread 中欺骗。这种方式的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码可以参见： https://github.com/BaoBaoJianqiang/ActivityHook1</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="基于动态替换的Activity插件化解决方案"><a href="#基于动态替换的Activity插件化解决方案" class="headerlink" title="基于动态替换的Activity插件化解决方案"></a>基于动态替换的Activity插件化解决方案</h2><p>这章节好混乱，压根就没说这里解决的是什么问题</p>
<h2 id="加载插件中类的方案2：-合并多个dex"><a href="#加载插件中类的方案2：-合并多个dex" class="headerlink" title="加载插件中类的方案2： 合并多个dex"></a>加载插件中类的方案2： 合并多个dex</h2><h2 id="对LaunchMode的支持"><a href="#对LaunchMode的支持" class="headerlink" title="对LaunchMode的支持"></a>对LaunchMode的支持</h2><p>前面介绍的 Activity 插件化技术，对于LaunchMode 都是standard的情况是完全适用的。对于 SingleTop、SingleTask 和 SingleInstance 需要重新考虑。</p>
<p>解决LaunchMode 的问题，适用的还是 <strong>占位Activity</strong> 的思想，即实现为这3种 LaunchMode 创建很多StubActivity，如下图所示：</p>
<p><img src="" alt="占位思想解决LaunchMode问题"></p>
<p>我们可以从服务端下载一个Json，指定插件中的Activity 对应哪种 StubActivity ，写Demo的时候，可以直接在本地 Mock 这些数据，保存在 MyApplication 中，然后再 Mock1Class 接货 startActivity 的时候，如果发现要启动的Activity 在 MyApplication 的 pluginActivities 集合中，那就使用这个插件 Activity 对应的占位 StubActivity，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码参见： https://github.com/BaoBaoJianqiang/ZeusStudy1.3</span></span><br></pre></td></tr></tbody></table></figure>

<p>接下来可以测试下。这里有个小bug，无论singleTop还是singleTask，再回到这个Activity时，并不会触发它的onCreate，而是会触发它的onNewIntent(其实这里说的bug我并没有明白，等测试后再说)。为此，我们需要在MockClass2 中，拦截onNewIntent方法，把占位 StubActivity 替换回插件Activity，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码可以参考上面的链接</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="加载插件中类的方案3：修改App原生的ClassLoader"><a href="#加载插件中类的方案3：修改App原生的ClassLoader" class="headerlink" title="加载插件中类的方案3：修改App原生的ClassLoader"></a>加载插件中类的方案3：修改App原生的ClassLoader</h2><p>..</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">148</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共343.8k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/5/',]
      });
      });
  </script>


</body>
</html>
