<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/page/5/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">39</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">223</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/12/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8806%EF%BC%892021.12.21-WindowManager%E5%AF%B9%E7%AA%97%E5%8F%A3%E7%9A%84%E6%93%8D%E4%BD%9C---Colin%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/12/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8806%EF%BC%892021.12.21-WindowManager%E5%AF%B9%E7%AA%97%E5%8F%A3%E7%9A%84%E6%93%8D%E4%BD%9C---Colin%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（06）2021.12.21-WindowManager对窗口的操作---Colin老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-12 09:55:00" itemprop="dateCreated datePublished" datetime="2023-06-12T09:55:00+08:00">2023-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:59:33" itemprop="dateModified" datetime="2023-06-28T21:59:33+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、Window-总览"><a href="#一、Window-总览" class="headerlink" title="一、Window 总览"></a>一、Window 总览</h2><p>window 是屏幕上一块区域，但不是实实在在的，实际显示的是 View 。WMS、WindowManager 以及 Window 之间的关系如下：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/window%E7%9B%B8%E5%85%B3%E6%96%B9%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="Window相关方的关系"></p>
<ul>
<li><p>Window： 窗口的概念，Android 中所有的师徒都依赖于 Window 显示</p>
</li>
<li><p>WindowManager ： 管理 Window ，包括 增、删、更新 等操作，类似一个代理的概念，最终要丢给 WMS 去实际操作。</p>
</li>
<li><p>WMS ： Window 最终管理者，负责 window 的启动、添加、删除，Window 的大小和层级也是 WMS 管理的</p>
</li>
</ul>
<h3 id="1-1-Window-分类"><a href="#1-1-Window-分类" class="headerlink" title="1.1 Window 分类"></a>1.1 Window 分类</h3><p>Application Window</p>
<p>xxxx</p>
<p>statusBar 和 searchBar 等居然也都是 System Window 。</p>
<p>打电话时，脸靠近手机的时候，黑屏 以及 脸不能按屏幕上的按钮，这些都是 Window 的标记来实现的。</p>
<h2 id="二、WindowManager"><a href="#二、WindowManager" class="headerlink" title="二、WindowManager"></a>二、WindowManager</h2><p>WindowManager 在应用层。WindowManager 是继承了 ViewManager 的，这里发散以下， ViewGroup 也是实现了 ViewManager ，联动一下。</p>
<p>Activity 的 attach 方法里面，会创建 Window ，以及 绑定到 WindowManager 。</p>
<p>Activity 中 Window 下最直接管理的 View 是 DecorView ，示意图如下：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/DecorView.png" alt="DecorView"></p>
<p>注意，我们平时在代码中调用 setContentView 是我们上图蓝色部分的 ContentView 吗？答案不是的，我们 setContentView 的 View 到时候会作为上述 蓝色 ContentView 的子 View 。</p>
<p>我们都说onResume 的时候，是可见可操作的。这里其实应该是Activity 可见 ，就是 Activity 已经创建好了！但其实里面的元素还是不可见的，因为 performResume 之后，才会执行 window.addView 将 View 添加进去，所以，要注意区分。</p>
<p>WindowManagerGlobal 主要的职责是：</p>
<ul>
<li><p>设置view的参数（layoutparams）</p>
</li>
<li><p>创建 ViewRootImpl </p>
</li>
</ul>
<p>其中，WindowManagerGlobal 的 addView 方法中会创建 ViewRootImpl 的对象。</p>
<p>总结一下各方关系就是：每个 Activity 都有一个 PhoneWindow ，每个 PhoneWindow 中有个根 View——DecorView ，并且PhoneWindow 中有个 WindowManagerImpl 用于管理 Activity 中 VIew 的细节，然后 WindowManagerGlobal 用于全局管理所有的 WindowManagerImpl ，示意图如下所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/WindowManagerGlobal.png" alt="Window各方关系如下"></p>
<h2 id="三、绘制流程"><a href="#三、绘制流程" class="headerlink" title="三、绘制流程"></a>三、绘制流程</h2><p>在 ViewRootImpl 中，接收到同步信号的时候，就会触发 performTraversalses() 方法，在里面会执行 performMeasure、performLayout、performDraw 等，</p>
<h3 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h3><p>ViewRootImpl 的功能主要体现在如下几个方面：</p>
<ul>
<li><p>作为 View 树的树根（注意，它自己并不是View，只是树根的意思而已）并管理 View 树</p>
</li>
<li><p>触发 View的测量、布局和绘制</p>
</li>
<li><p>输入响应的中转站</p>
</li>
<li><p>负责与 WMS 进行进程间通信</p>
</li>
</ul>
<p>关于输入响应的中转站，我们可以看如下图：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B.png" alt="ViewRootImpl是输入的中转站"></p>
<p>事件产生后，会传递到 ViewRootImpl 中，之后被传递给 DecorView ，我们根据这个步骤可以看到，这里面传递很弯弯绕绕，DecorView 传递给Acitivty ，第 3 步的时候，又回到了 DecorView 中。</p>
<p>为什么要这么设计呢？省略中间商赚差价直接到 ViewGroup 行不行？答案是不行。因为诸如打电话脸贴到屏幕上时需要黑屏，点击操作不能响应等操作， View 和 ViewGroup 上面没有相关的处理机制的，都在 PhoneWindow 里面，所以必须经过 PhoneWindow 。</p>
<p>view 或者 Window 的刷新都依赖于 ViewRootImpl 中的 scheduleTraversals 方法。</p>
<h3 id="UI刷新"><a href="#UI刷新" class="headerlink" title="UI刷新"></a>UI刷新</h3><p>以 2 个问题开始：</p>
<ul>
<li><p>TextView 连续 2 次setTextView ，那么会触发几次重绘？</p>
</li>
<li><p>Android 为什么要求帧率是 60？</p>
</li>
</ul>
<p>答案：UI必须等待 16ms 的间隔才会绘制下一帧，所以连续2次 setTextView 只会触发一次重绘。同时必须每秒 60 帧（电影是 24 帧）用户才不会感觉卡顿，所以就 16ms 就要一帧。</p>
<p>关于刷新的整体流程我们可以参考如下图：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/UI%E5%88%B7%E6%96%B0.png" alt="刷新整体流程"></p>
<p>从图可以看出，setText 之后，就会触发 invalidate ，由于 View 自己不能刷新，需要向上请示老大，一直到 ViewRootImpl ，而 ViewRootImpl 自己也不能刷新，只能插入同步栅栏，等待下一次的 Vsync 信号（通过编舞者postcallback）来了之后再绘制。<strong>等到 Vsync 信号来了之后，我们会把同步栅栏给移除掉</strong>。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总结一下主要有几点需要注意：</p>
<ul>
<li><p>Android 一般是 60FPS ，是 VSYNC 决定的，每 16ms 最多一帧</p>
</li>
<li><p>VSYNC 要客户端主动申请，才又 VSYNC 到来才会刷新</p>
</li>
<li><p>UI没有更改的话，不会请求 VSYNC 也就不会有刷新</p>
</li>
<li><p>UI局部重绘其实只会去重绘有更新的 View</p>
</li>
</ul>
<h3 id="SurfaceFlinger"><a href="#SurfaceFlinger" class="headerlink" title="SurfaceFlinger"></a>SurfaceFlinger</h3><p>SurfaceFlinger 是整个 Android 系统渲染的核心进程，整个流程是这样的：每个 DecorView 对应一个 Surface ，每个 Surface 里面包含一个 canvas ，每个 surface 对应一个 layer（图层）， SurfaceFlinger 将各类的图层合成。</p>
<p>SurfaceFlinger 的整体流程如下图所示：</p>
<p><img src="" alt="SurfaceFlinger整体流程"></p>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>onResume 里面度量的宽高有效吗？</p>
<p>分情况。Activity 第一次调用 onResume 的时候是无效的，从 Activity A 跳转到 B 再返回来，这时候 A 的onResume 中是有效的。因为 onResume 的时候，还没有 执行 window.addView 呢。</p>
<p>Activity 、Window、view 三者的联系和区别。</p>
<p>先整体，再细节。所以先讲这3个是啥，Activity 是xxx，window 是xxx，View 是xxx。Activity 没有界面，委托给 Window 展示，</p>
<p>首次 View 的绘制流程是什么时候触发的？</p>
<p>WindowManagerImpl.addView -&gt; WindowManagerGlobal.addView</p>
<p>ViewRootImpl.setView -&gt; ViewRootImpl.requestLayout</p>
<p>ViewRootImpl.scheduleTraversals  </p>
<p>这时候就触发了首次绘制</p>
<p>我们调用 invalidate() 之后会马上进行屏幕刷新吗？</p>
<p>一定不。需要等到下一个 Vsync 信号来了才会</p>
<p>我们说丢帧是因为主线程做了耗时操作，为什么做了耗时操作就会引起丢帧？</p>
<p>一言以蔽之：主线程的耗时操作会影响下一帧的绘制。我们知道有以下信息：</p>
<ul>
<li><p>在 ViewRootImpl 的 scheduleTravesals 方法中会去发送同步屏障，接着发送异步 Message，用于处理 UI 更新</p>
</li>
<li><p>在Handler 机制中碰到 target == null 这种 Message 的时候，就知道这是同步屏障了，此后，就只执行异步 Message</p>
</li>
<li><p>我们知道主线程耗时操作的体现形式也是 Message</p>
</li>
<li><p>如果有耗时操作之前的消息有耗时操作，那么可能耗时导致推迟执行 同步屏障那个 Message ，也就推迟了后续的 异步 Message的执行，也就影响了下一帧的绘制</p>
</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8805%EF%BC%892021.12.19-%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%B3%A8%E5%86%8C%E7%9A%84Activity---leo%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8805%EF%BC%892021.12.19-%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%B3%A8%E5%86%8C%E7%9A%84Activity---leo%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（05）2021.12.19-如何启动一个没注册的Activity---leo老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-10 15:20:00" itemprop="dateCreated datePublished" datetime="2023-06-10T15:20:00+08:00">2023-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:52:52" itemprop="dateModified" datetime="2023-06-28T21:52:52+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、前情回顾"><a href="#一、前情回顾" class="headerlink" title="一、前情回顾"></a>一、前情回顾</h2><p>init 操作主要是解析 init.rc 文件，它是用户空间的鼻祖。</p>
<p>zygote 是 Java 进程的鼻祖，系统启动的过程在 zygote 之前都是运行在 c/c++ ，初始化运行环境  Android RunTime ，zygote 开始才进入 Java。</p>
<p>zygote 通过 fork 创建 SystemServer 进程，这里面有各种 Android 的服务，比如 AMS 等</p>
<p>Activity 启动通信过程中需要注意一点：Launcher 进程获取通信代理对象（下图第1步）在 10.0 之前  是 AMS ，在 10.0 之后获取到的是 ATMS ，老师说在面试的时候要说下，整个流程如下图所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Activity%E5%90%AF%E5%8A%A8%E5%9B%BE.jpg" alt="Activity启动通信图"></p>
<h3 id="1-1-Activity-的管理"><a href="#1-1-Activity-的管理" class="headerlink" title="1.1 Activity 的管理"></a>1.1 Activity 的管理</h3><p>在哪里对 Activity 的栈进行管理，Activity 信息的管理？</p>
<p>答案是在 ActivityStarter 这个类当中（com.android.server.wm 这个包名下的）。在 AMS里面会执行 ActivityStarter.execute() 方法，在 execute 方法里面，会调用 ActivityStarter 的内部类 Request 的 resolveActivity ，在这里面<strong>首先获取到 ResolveInfo 数据，之后根据 ResolveInfo 数据获取到 activityInfo 数据**</strong>，至此 Activity 信息就获取到了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activityInfo = supervisor.resolveActivity(intent, resolveInfo, startFlags, profilerInfo);</span><br></pre></td></tr></tbody></table></figure>

<p>App 层面的一个 Activity 对应在 AMS 中的 一个 ActivityRecord 对象。 还有个细节，在 ActivityStarter 类里面，会通过 <em>computeLaunchingTaskFlags</em> 方法计算 Activity 的启动模式。还有个关键点，ActivityStarter 中会通过 <em>recycleTask</em> 方法清除要启动的 Activity 上面的那些 Activity （比如 SingleTask 模式下）。</p>
<h3 id="1-2-任务栈"><a href="#1-2-任务栈" class="headerlink" title="1.2 任务栈"></a>1.2 任务栈</h3><p>如果你指定了 taskAffinity ，想让某个 Activity 运行在指定的任务栈，但是如果没有在 Intent 里面指定 FLAG_ACTIVITY_NEW_TASK 这个 flag 的话，还是会在默认的栈里面（与启动这个 Activity 的 Activity 是同一个栈），不会在指定的栈里面。其他的诸如两个 App 之间通过隐式启动另一个 App 中的 Activity 时，最好也使用 FLAG_ACTIVITY_NEW_TASK，不然还是在当前 App 的任务栈中。</p>
<blockquote>
<p>小知识，如果项目里面有多个任务栈，那么在按任务键 的时候，就能看到有多个缩略图（自己可以写demo试试），另外如果需要对比添加 FLAG_ACTIVITY_NEW_TASK 和不添加 FLAG_ACTIVITY_NEW_TASK 的情形的效果，需要卸载App 重新安装，课程里面就出现了这样的小插曲，不生效。</p>
</blockquote>
<p>单独任务栈有什么作用？就比如你的图库，需要在单独的任务栈中，这样与普通业务不影响，我个人理解的是在诸如 singleTask 等模式下，假如需要清理掉栈顶那些 Activity 时，不会被清除掉。</p>
<p>任务栈在数据层面表现就是 ActivityStack ，它管理 ActivityRecord 。</p>
<h3 id="1-3-FLAG-ACTIVITY-FORWARD-RESULT"><a href="#1-3-FLAG-ACTIVITY-FORWARD-RESULT" class="headerlink" title="1.3 FLAG_ACTIVITY_FORWARD_RESULT"></a>1.3 FLAG_ACTIVITY_FORWARD_RESULT</h3><p>FLAG_ACTIVITY_FORWARD_RESULT 的作用是当前 Activity 忽略 ActivityResult ，这样就会将结果传给上一级。举个例子，Activity  A启动 B ，B 启动 C ，我们想在 C 结束的时候，将结果跳过 B 传递给 A ，此时我们只需要在 B 启动 C 的时候，在intent 中添加这个flag 就行(表示忽略那个结果)：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(BBActivity.<span class="keyword">this</span>, CCActivity.class);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></tbody></table></figure>

<p>注意最后一行的 startActivity ，这里不能用 startActivityForResult 的，FLAG_ACTIVITY_FORWARD_RESULT 本来是忽略结果，startActivityForResult 是要结果，如果同时使用会报错。自己写的测试代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity A</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_a);</span><br><span class="line"></span><br><span class="line">    mButton = (Button) findViewById(R.id.btn);</span><br><span class="line">    mButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(AAActivity.<span class="keyword">this</span>, BBActivity.class);</span><br><span class="line">            startActivityForResult(intent, <span class="number">100</span>);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    Log.e(<span class="string">"forwardresult"</span>,<span class="string">"AAActivity requestCode:"</span> + requestCode + <span class="string">", resultCode:"</span> + resultCode + <span class="string">"data = "</span> + data.getStringExtra(<span class="string">"haha"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_b);</span><br><span class="line"></span><br><span class="line">    mButton = (Button) findViewById(R.id.btn);</span><br><span class="line">    mButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(BBActivity.<span class="keyword">this</span>, CCActivity.class);</span><br><span class="line">            intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_c);</span><br><span class="line"></span><br><span class="line">    mButton = findViewById(R.id.btn);</span><br><span class="line">    mButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">            intent.putExtra(<span class="string">"haha"</span>, <span class="string">"我是c的数据"</span>);</span><br><span class="line">            setResult(RESULT_OK, intent);</span><br><span class="line"></span><br><span class="line">            finish();</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样，当 Activity B 结束的时候，A 就能收到 C 关闭时候的数据 “我是c的数据” 了。注意：<strong>C 结束后，就显示出 B 了，只有手动关闭 B 页面后，数据才会传给 A 。</strong></p>
<p>关于这个标志位，更多内容可以参考 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f7d2a597536e">FLAG_ACTIVITY_FORWARD_RESULT的使用 - 简书 (jianshu.com)</a></p>
<h2 id="二、启动未注册的-Activity"><a href="#二、启动未注册的-Activity" class="headerlink" title="二、启动未注册的 Activity"></a>二、启动未注册的 Activity</h2><p>启动未注册的 Activity 会报错，那么这个报错是在哪个地方报出来的？我们看到 Instrumentation 这个类，看到其中的 execStartActivity 这个方法，在里面会有启动 Activity 并对启动结果进行检查的逻辑：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = ActivityTaskManager.getService().startActivity(whoThread,</span><br><span class="line">        who.getBasePackageName(), who.getAttributionTag(), intent,</span><br><span class="line">        intent.resolveTypeIfNeeded(who.getContentResolver()), token,</span><br><span class="line">        target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">checkStartActivityResult(result, intent);</span><br></pre></td></tr></tbody></table></figure>

<p>在 ActivityStarter 类中，执行 executeRequest 方法时，如果有错误，就会将错误结果体现到上述的 result 里面。最后，在 checkStartActivityResult 中通过 switch-case 去处理各种异常和正常结果。</p>
<p>Hook 目的就是为了改变原有流程。不管你是通过反射还是插桩都行。</p>
<h3 id="2-1-思路"><a href="#2-1-思路" class="headerlink" title="2.1 思路"></a>2.1 思路</h3><p>实现未注册的 Activity 的启动的思路如下图所示：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E5%90%AF%E5%8A%A8%E6%9C%AA%E6%B3%A8%E5%86%8CActivity%E6%80%9D%E8%B7%AF.png" alt="实现未注册的Activity 的启动思路"></p>
<p>找Hook点的原则（尽量）：</p>
<ul>
<li><p>找静态变量或者单例，这种可以直接用反射，还不轻易改变</p>
</li>
<li><p>public 修饰的，也不容易改变</p>
</li>
</ul>
<p>一个原则： 在 startActivity 之后，AMS 检测之前将 目标Activity 替换成占位 Activity。在 AMS 检测之后，Activity 创建出来之前（感觉老师说的Activity生命周期之前是有问题的），将占位 Activity 替换回 目标 Activity。</p>
<h3 id="2-2-实践"><a href="#2-2-实践" class="headerlink" title="2.2 实践"></a>2.2 实践</h3><p>通过 AMS 启动 Activity 的时候，getService 获取 AMS 的代理的时候，是静态的的，并且 IActivityManager 是一个接口，所以可以使用动态代理。</p>
<p>前面说的 10 之前是 AMS ，10之后是 ATMS ，所以要注意适配。</p>
<p>还有个点需要注意，使用动态代理的时候，需要传入 ClassLoader </p>
<p>，可以使用当前线程的 ClassLoader ：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></tbody></table></figure>

<p>ActivityThread 中 H 类handler 本身的 callback 是 null ，又 Handler 中 dispatchMessage 的时候，msg 的callback 存在的话，就执行 msg 的callback ，其他的就不执行了；如果 msg.callback 是空的话，则先执行 Handler 本身的 callback.handlerMessage (msg) ，只有当这个返回true 的时候，才不会执行我们自定义的 handleMessage；false 的话，还是会继续执行 handleMessage 的，所以我们可以强行new 出来一个 Handler 的 callback ，只不过 callbac.handleMessage 返回false 即可。之后将这个 callback 通过 Hook 设置给 H 类即可。</p>
<blockquote>
<p>这样 Hook 是没有风险的，因为流程并没有改变，，Handler 的callback 本身就是空的，我们 Hook 之后，handleMessage 还是会执行</p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8804%EF%BC%892021.12.16-AMS%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3--leo%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/10/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8804%EF%BC%892021.12.16-AMS%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3--leo%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（04）2021.12.16-AMS的核心原理讲解--leo老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-10 10:12:00" itemprop="dateCreated datePublished" datetime="2023-06-10T10:12:00+08:00">2023-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:48:04" itemprop="dateModified" datetime="2023-06-28T21:48:04+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>ZygoteInit.main 方法执行会进入 Java 层</p>
<p>forkSystemServer 方法：</p>
<p>在 fork 之前会给一些 args ，比如很有意思的一个名字 –nice-name ，就是指的进程名，这里的值时 ： system_server 。</p>
<p>Zygote.forkSystemServer 返回值问题：因为 fork 操作返回的就是 子进程的 pid ，所以，在父进程（Zygote 进程）中，返回的是 SystemServer 这个进程的 id ，假如是 6000 （反正肯定是 大于0的）；而在 SystemServer 中而言，由于它没有子进程，所以它返回的是 0 。</p>
<p>所以，在 Zygote 执行 Zygote.forkSystemServer 之后，需要判断 if (pid == 0) 去区分当前是 SystemServer 进程，然后才执行 handleSystemServer 这个方法，这里面会执行 SystemServer 进程的 main 方法。</p>
<blockquote>
<p>还记得前面说的，所有的进程开始执行的时候都是执行其 main 方法的</p>
</blockquote>
<p>handleSystemServer 最终会调用到 ZygoteInit.java 类中的 zygoteInit 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges, String[] argv, ClassLoader classLoader)</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>在这个方法里面会执行 ZygoteInit.nativeZygoteInit(); 方法去启动 Binder  线程池，在 native 层最终执行的代码是这样的：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc -&gt; startThreadPool();</span><br></pre></td></tr></tbody></table></figure>

<p>这也从侧面说明了， Zygote 进程 fork 出来的进程都会去创建 Binder 线程池。</p>
<p>获取到 SystemServer 的 Class ，然后通过反射调用其 main() 方法。这样就把 SystemServer 进程给启动起来了。</p>
<p>在 SystemServer 的 main 方法中，主要执行其 run 方法，主要操作是：</p>
<ul>
<li><p>创建 SystemServiceManager 对象</p>
</li>
<li><p>startBootstrapServices  //启动引导服务 —— AMS 等</p>
</li>
<li><p>startCoreService  //核心服务</p>
</li>
<li><p>startOtherService  //其他服务，如 WMS 等</p>
</li>
</ul>
<p>一个 App 可以有多个进程？那肯定可以，我们平时一个 App 就可以开启多个进程； 那么一个进程可以有多个 App 吗？ 答案当然也是可以！<strong>我们可以用 sharedId 去实现 。</strong></p>
<p>在 SystemServer 的 main 方法中，最终会创建 ActivityThread 对象，看到这里我蒙了。。。不是只有 App 的进程才会创建 ActivityThread 对象么？ 不过呢，我们能从 ActivityThread 的 attach 方法中看到端倪，在里面会判断是否是 system（也就是是否是系统），在 SystemServer.main 里面这种情况下，我们肯定是 system 的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!system) {</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//省略无关代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>SystemServer 的main 方法执行的时候，会有创建和创建 Application 的 Context 以及创建 ActivityThread 的操作，和我们的 App 进程创建有点类似，老师的解释是，SystemServer 进程中有 App ，至于这个 App 是什么 App ，老师也说不知道。</p>
<h2 id="SystemServerManager"><a href="#SystemServerManager" class="headerlink" title="SystemServerManager"></a>SystemServerManager</h2><p>startService </p>
<p>四大组件管理者以前说的都是 AMS ，但是 ANdroid 10 之后，这么说就不准确的，新增了一个 ATMS （ActivityTaskManagerService）， 其中 ATMS 专门管理 Activity ， AMS 管理其他三个以及其他的。 </p>
<p>这里要注意 2  个概念， SystemServerManager 和 ServiceManager 的区别：</p>
<ul>
<li><p>SystemServerManager ： 主要负责 Service 的生命周期，比如 Service 的 onCreate、onStart 等</p>
</li>
<li><p>ServiceManager ： 负责 Service 的管理，Service 创建后，要添加到 ServiceManager 中来，也就是注册。</p>
</li>
</ul>
<p>SystemServer 中 startOtherService 中有几个值得注意的：</p>
<ul>
<li><p>mActivityManagerService.systemReady 方法会启动 Launcher </p>
</li>
<li><p>startSystemUi 方法</p>
</li>
</ul>
<p>ActivityStater.execute 里面会执行到 executeRequest 方法，这些方法非常重要，我们说的是 Activity 的栈管理 就是在 ActivityStarter 这个类里面。启动 Activity 的时候，一般会有 2 个 AcitivityRecord ，一个是启动 Activity 的信息，另一个是待启动的 Activity 的信息，比如 Activity A 启动 Activity B 。</p>
<p>Activity 启动过程中，会经过 ActivityStackSupervisor.java  的 startSpecificActivity 方法，这个方法很关键，会在里面判断是否存在目标Activity 所在的进程，如果存在才执行 realStartActivityLocked ；否则，启动 App 的进程（AMS 通过 socket 通知 zygote 创建进程）。</p>
<p>有个 主 zygote 和 从 zygote 的概念，这个需要理解下，因为之前我们讲过系统启动的时候，有几种配置，是 32 位 或者 64位，还是说32_64 （先尝试32位不行再 64位），以及 64_32（先尝试64位不行再 32位）</p>
<p>启动 Launcher 的时候，会执行到 ActivityThread.main 方法（其实和普通的App一样，Launcher也是个 App），在 ActivityThread.main 方法中也会调用到 attachApplication 方法，这是<strong>将App 的句柄发送给AMS</strong>，方便后续 AMS 向 App 发送消息。这个句柄是 ApplicationThread ，他是个 Binder 。</p>
<p>一定要自己去看源码，画时序图和流程图：</p>
<ul>
<li><p>时序图，哪个类的方法到哪个类的方法</p>
</li>
<li><p>流程图： 整个过程做的重要事情</p>
</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/09/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8803%EF%BC%892021.12.14-Android%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B---Leo%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/09/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8803%EF%BC%892021.12.14-Android%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B---Leo%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（03）2021.12.14-Android的启动流程---Leo老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-09 15:11:00" itemprop="dateCreated datePublished" datetime="2023-06-09T15:11:00+08:00">2023-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:46:39" itemprop="dateModified" datetime="2023-06-28T21:46:39+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、粗略过一遍"><a href="#一、粗略过一遍" class="headerlink" title="一、粗略过一遍"></a>一、粗略过一遍</h2><p>在内核里面没有进程和线程的区分的。</p>
<p>init 是用户空间鼻祖。zygote 是Java 进程的鼻祖，此前一直在 native 层。</p>
<p>Systemserver 进程里面大约有 90 多个进程。</p>
<p>init 进程中，做挂载、创建文件夹之类的操作</p>
<p>SetupSelinux 里面实现了 linux 这块的安全策略，</p>
<p>native 层这些知识，比如 init.rc 的解析等，看刘望舒的书籍就可以了，所以这里大概略过，总结一下init处理的重要事情：</p>
<ol>
<li><p>挂载文件</p>
</li>
<li><p>设置 selinux –&gt; 安全策略</p>
</li>
<li><p>开启属性服务，注册到 epoll 机制</p>
</li>
<li><p>解析 init.rc 文件</p>
</li>
<li><p>循环处理脚本，启动zygote 进程</p>
</li>
<li><p>循环等待，主要就是接受子进程的 SIGCHLD 信号，防止子进程变为僵尸进程</p>
</li>
</ol>
<p>linux 中一切接文件，输入输出也是，在代码中写 system.out.println() 也是将内容写入到某个目录，然后再显示出来。</p>
<h2 id="二、Zygote"><a href="#二、Zygote" class="headerlink" title="二、Zygote"></a>二、Zygote</h2><p>Zygote 有一部分运行在 native 层，有一部分运行在 Java 层，从这里开始，我们后续的代码就进入了 java 层运行。</p>
<blockquote>
<p> adb shell</p>
</blockquote>
<blockquote>
<p>kill 9 6158</p>
</blockquote>
<p>上述命令就可以将 zygote 进程（其中6158是zygote 进程的进程号，需要确认下是不是这个）杀掉，然后 Android 就崩了。说明 Android 的关键进程是不能被结束的</p>
<p>每一个进程启动的时候，都是执行 main 方法</p>
<p>Android的运行环境（Android RunTime）是 zygote 给启动的，调用的是 runTime.start(xx,xx,xx) 方法，在 runtime.start()方法中，做了几件事情：</p>
<ul>
<li><p>通过 startVM 就是启动虚拟机</p>
</li>
<li><p>之后通过 startReg 来注册 JNI ，</p>
</li>
</ul>
<p>从上面看出来，我们在 zygote 进程中startVM 启动了虚拟机，虚拟机的作用： 进程管理。所以，直播课学员问的，先有进程还是先有VM 虚拟机，答案就明确了：先有进程，VM 只是进程里面的一段功能代码而已；如果从内核空间和用户空间来讲，<strong>VM 显然是在用户空间</strong>。</p>
<p>每个 App 的内核空间，在物理上都对应同一块地方。</p>
<h3 id="2-1-注册-JNI？"><a href="#2-1-注册-JNI？" class="headerlink" title="2.1 注册 JNI？"></a>2.1 注册 JNI？</h3><p>Java 与 Native 代码互相调用， 注册 JNI 就是将 Java 的本地方法和 native 方法关联起来。</p>
<p>进程是没有 Java进程 和 Native进程 的区分的，所以，zygote 执行的时候，不论是在 Native 层还是 Java 层，我们都说是在 Zygote 进程。看源码的时候，如何判断是否进入到了其他进程，就看是否 fork 了。</p>
<h3 id="2-2-zygoteServer"><a href="#2-2-zygoteServer" class="headerlink" title="2.2 zygoteServer"></a>2.2 zygoteServer</h3><p>它是一个 Socket ，为什么要用 Socket 而不用 Binder 进程间通信？</p>
<p>因为 Binder 是多线程的，fork 可能会导致死锁，所以这里用 Socket</p>
<p>Zygote 的 preload 加载资源啊（Android内部的资源com.android.internal.R.xx 之类的）、类啊（有个文件配置了需要预加载哪些类），这样在fork出来的 App 进程中不用去加载了，加快速度</p>
<p>关于预加载，老师的一张图很有说明性，复制下：</p>
<p><img src="/assets/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%BA%AB%E5%AD%A6Android%E7%AC%AC%E4%B8%89%E6%9C%9FVip/06-FrameWork%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Android%E5%BA%94%E7%94%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%9B%BE.jpg" alt="Android应用进程共享内存图"></p>
<h3 id="2-3-总结：zygote-进程启动干了什么事情？"><a href="#2-3-总结：zygote-进程启动干了什么事情？" class="headerlink" title="2.3 总结：zygote 进程启动干了什么事情？"></a>2.3 总结：zygote 进程启动干了什么事情？</h3><h4 id="native-层面："><a href="#native-层面：" class="headerlink" title="native 层面："></a>native 层面：</h4><ul>
<li><p>初始化运行环境，创建vm</p>
</li>
<li><p>注册jni</p>
</li>
<li><p>调用 zygoteinit.main 进入 Java 环境</p>
</li>
</ul>
<h4 id="Java-层面"><a href="#Java-层面" class="headerlink" title="Java 层面"></a>Java 层面</h4><ul>
<li><p>预加载–加快APp进程启动</p>
</li>
<li><p>创建 server 类型的 socket 接收fork 新进程的信息</p>
</li>
<li><p>通过 fork 创建 SystemServer 进程</p>
</li>
<li><p>循环等待，等待 SystemServer 进程的 fork 其你去</p>
</li>
</ul>
<h2 id="三、fork-（老师发的资料里面的补充内容）"><a href="#三、fork-（老师发的资料里面的补充内容）" class="headerlink" title="三、fork （老师发的资料里面的补充内容）"></a>三、fork （老师发的资料里面的补充内容）</h2><h3 id="3-1-fork-如何导致死锁"><a href="#3-1-fork-如何导致死锁" class="headerlink" title="3.1 fork 如何导致死锁"></a>3.1 fork 如何导致死锁</h3><p>在 POSIX 标准中，fork 行为是这样的：复制整个用户空间的数据（通常使用 copy-on-write 策略）以及所有系统对象，然后<strong>仅仅复制当前线程到子进程</strong>，这就意味着，所有父进程中其他线程，到了子进程中都是突然政法掉了。</p>
<blockquote>
<p>所以，如果非当前线程获取到了锁，fork完成后，当前线程去获取锁，会发现一直占用，无法获取到</p>
</blockquote>
<h3 id="3-2-fork-返回值"><a href="#3-2-fork-返回值" class="headerlink" title="3.2 fork 返回值"></a>3.2 fork 返回值</h3><ul>
<li><p>返回 0 表示成功创建子进程，并且接下来进入子进程</p>
</li>
<li><p>返回 pid &gt; 0 ，表示成功创建子进程，并且继续执行父进程流程</p>
</li>
<li><p>返回 pid &lt; 0 创建子进程失败（可能内存不足等原因）</p>
</li>
</ul>
<h3 id="3-3-孤儿进程、僵尸进程"><a href="#3-3-孤儿进程、僵尸进程" class="headerlink" title="3.3 孤儿进程、僵尸进程"></a>3.3 孤儿进程、僵尸进程</h3><p>fork 调用后，父子进程交替执行，执行顺序不定：</p>
<ul>
<li><p>如果父进程先退出，子进程还没退出，则子进程的父进程会变为init进程（托孤，因为任何一个进程都必须有父进程）</p>
</li>
<li><p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕捉到了子进程的退出状态才真正结束，否则这个子进程会变为僵尸进程（只保留一些退出信息供父进程查询）</p>
</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/09/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8802%EF%BC%892021.12.12-Binder%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B2%E8%A7%A3---Leo%E8%80%81%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/09/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8802%EF%BC%892021.12.12-Binder%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B2%E8%A7%A3---Leo%E8%80%81%E5%B8%88/" class="post-title-link" itemprop="url">（02）2021.12.12-Binder机制与常见面试题讲解---Leo老师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-09 10:20:00" itemprop="dateCreated datePublished" datetime="2023-06-09T10:20:00+08:00">2023-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:42:22" itemprop="dateModified" datetime="2023-06-28T21:42:22+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="一、储备知识"><a href="#一、储备知识" class="headerlink" title="一、储备知识"></a>一、储备知识</h2><p>很多同学回答 Binder 是什么的时候，只会说 Binder 是一种进程间通信机制，这是不完善的，我们要说出以下 3 个点才算完整：</p>
<ul>
<li>机制：Binder 是一个进程间通信机制</li>
<li>驱动： Binder 是一个虚拟物理设备驱动</li>
<li>应用层：Binder 是一个能发起通信的 Java 类（Service里面就有用到Binder类）</li>
</ul>
<p>Linux 一切皆文件 </p>
<p>多进程的好处？</p>
<ul>
<li>突破内存限制，如图库内存占用过多</li>
<li>功能稳定性，比如长连接，独立进程</li>
<li>规避内存泄漏，比如 webview 正常使用会有内存泄漏</li>
<li>隔离风险： 不稳定的功能放入独立的进程，比如dump 内存</li>
</ul>
<p>为什么Android采用 Binder：</p>
<ul>
<li>性能： 只需要一次</li>
<li>特点：基于C/S，易用性高（如共享内存使用很复杂，参考多线程共享变量，涉及的线程安全加锁）</li>
<li>安全性，为每个App分配 UID，同时支持匿名和实名。公交车，只要能到那里，都能坐车；Binder 既有实名又有匿名，实名的服务是大家都可以访问，比如 AMS、WMS ，匿名服务，类似滴滴打车，你是不能直接联系到司机的，只能通过滴滴给你虚拟号。匿名服务只能通过代理去真正获取服务。（实名和匿名的区别在于是否注册）。</li>
</ul>
<blockquote>
<p>自己写的服务可以实名吗？是可以的，调用 API 即可</p>
</blockquote>
<p>一个进程会分为 用户空间和内核空间。如果是 32位系统（总共有 2^32 这么大，即 4G），那么用户空间一般 3G，内核空间 1G </p>
<p>所有进程的内核空间都是映射到物理内存上是同一块空间，</p>
<p>内核空间是地球仪，物理内存是地球；进程1的用户空间是 月球仪器，对应的物理内存是月球；进程2的用户空间是火星仪，对应的物理内存是火星。</p>
<p>我们平时说的拷贝次数，指的就是 copy_from_user 或者 copy_to_user 这种系统调用，每调用一次就是所说的类似 Binder 只用拷贝一次这种说法。</p>
<blockquote>
<p>为什么只关心这个系统的调用呢？这是因为在用户态和内核态切换非常耗时，它有上下文切换的，需要保存当前运行状态。</p>
</blockquote>
<p>传统的IPC就是 copy_from_user ，接着再 copy_to_user ，2次</p>
<p>服务端和内核端，google 已经实现了，所以开发者只要开发 客户端。降低 Binder 的使用难度</p>
<p>为什么不从两个应用之间映射？还需要经过内核？</p>
<p>老师说的是，如果直接2个应用之间，就变成了 内存共享，google 做 Binder 就是因为内存共享比较难控制，所以宁愿用 Binder 来浪费一次性能。感觉说服力不够，得自己想想。</p>
<h2 id="二、Binder"><a href="#二、Binder" class="headerlink" title="二、Binder"></a>二、Binder</h2><p>MMKV 也是使用 mmap 实现的。</p>
<h3 id="2-1-AIDL-生成的类细节"><a href="#2-1-AIDL-生成的类细节" class="headerlink" title="2.1 AIDL 生成的类细节"></a>2.1 AIDL 生成的类细节</h3><p>AIDL 类似黄牛，帮我们代办一些事情，降低办事的复杂度。帮我们生成 Java 代码。AIDL 生成的 Java 代码，我们自己去手写也是一样的。</p>
<p>Proxy 是给客户端使用的，Stub 服务端使用。asInterface 判断如果是跨进程，那么返回的是代理对象，否则，返回的是本身。Binder 通信会创建 2个 Parcel  ，一个是数据包，一个是结果包。</p>
<p>ServiceManager 也是个服务，它的 handle 句柄是固定的： 0 。Service 创建之后，可以去 ServiceManager 中注册，建立 Service 和 handle 句柄的映射关系。</p>
<p>客户端调用 transact 方法的时候，服务端那边就会响应 onTransact 方法。我们一般调用一个类的方法，可以写明全路径，比如一般是： com.xx.haha.Demo ，但是在 Binder 中，觉得传全路径过去占用的空间比较大，所以对方法做了精简，比如，用 1 代表 addPerson、2代表getPersonList 等，节约空间。这个体现在 Stub 中的那些静态常量。</p>
<p>onTransact 中，如果调用的方法没有返回值，则执行完就完了；否则，将执行结果写到 reply 中。 客户端调用服务端一般是同步的，所以计算过程客户端会挂起，所以一般要在子线程去做这种Binder 调用。<strong>如果要使用异步调用，就使用 oneWay</strong></p>
<h3 id="2-2-Intent-为什么不能传送大的数据"><a href="#2-2-Intent-为什么不能传送大的数据" class="headerlink" title="2.2 Intent 为什么不能传送大的数据"></a>2.2 Intent 为什么不能传送大的数据</h3><p>为什么只能 1M - 8k ？这是因为 Binder 是一个驱动，通过 mmap 创建的空间大小就是 1M - 8k （就是 1M - 2 * pageSize ，pageSize 是 4k），如果是异步的话 ，则是 (1M - 8k)/2 。</p>
<p>至于为什么是 1M - 8k ，那总得给个数字，不可能无限大。可能是为了充分利用存储空间。</p>
<p>mmp 最开始只会给 1 页，也就是 4k ，如果有需要才会扩充，最大就是上面说的 1M - 8k （oneWay 就减半）。</p>
<blockquote>
<p>其实还有一个打包需要占用空间，所以真正可用的空间还不到 1M - 8k</p>
</blockquote>
<p><font color="#ff0000">补充视频里面有代码的详细讲解，不过目前面试用不到，先不看</font></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/08/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8801%EF%BC%892021.12.9-Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90---Alvin%E8%80%81%E5%B8%88%EF%BC%883%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/08/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8801%EF%BC%892021.12.9-Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90---Alvin%E8%80%81%E5%B8%88%EF%BC%883%EF%BC%89/" class="post-title-link" itemprop="url">（01）2021.12.9-Handler源码分析---Alvin老师（3）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-08 17:00:00" itemprop="dateCreated datePublished" datetime="2023-06-08T17:00:00+08:00">2023-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:39:59" itemprop="dateModified" datetime="2023-06-28T21:39:59+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>线程的跨越是怎么实现的？</p>
<p>内存是不分线程的，可以在子线程和主线程都使用。</p>
<p>在子线程里面执行某个函数（比如调用 Handler 的 sendMessage 方法），这个函数就在子线程里面</p>
<p>事件变为内存了，MessageQueue.enqueueMessage(msg) 将这一块内存放入了 MessageQueue 了。 </p>
<p>Looper.loop 是在主线程中，所以取出来的 Message 是通过 dispatchMessage 放在 主线程执行的</p>
<p>所以上述就是子线程切换到主线程的流程。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>有学员问存在以下几个条件：</p>
<ol>
<li><p>所有 Looper 对象（不论主线程还是子线程的）中放 Looper 对象的 ThreadLocal 都是同一个对象</p>
<blockquote>
<p>这个没问题，因为 Looper 类中的 用于存放Looper 对象的 ThreadLocal 是 static final 的，整个 App 只有一个</p>
</blockquote>
</li>
<li><p>那么看起来，所有线程也都公用同一个 Looper 对象了啊</p>
</li>
</ol>
<p>看下 Looper 的源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></tbody></table></figure>

<p>所以学员说得没错， sThreadLocal 是整个 App 唯一的。但是，如果我们了解 ThreadLocal 的源码的话，就能得出如下的式子：</p>
<blockquote>
<p>Thread1 -&gt; 有自己的 ThreadLocalMap1 -&gt; 存储的键值对样式 &lt;sThreadLocal, Looper1&gt;</p>
</blockquote>
<blockquote>
<p>Thread2 -&gt; 有自己的 ThreadLocalMap2 -&gt; 存储的键值对样式&lt;sThreadLocal, Looper2&gt;</p>
</blockquote>
<p>能看到，在线程1中键值对存在ThreadLocalMap1 这个map 对象中， 样式是 &lt;sThreadLocal, Looper1&gt; ；线程2 中键值对存在 ThreadLocalMap2 这个 map 对象中，的样式是 &lt;sThreadLocal, Looper2&gt;</p>
<p>所以，根本原因在于： <strong>每个线程都有自己的 ThreadLocalMap</strong>，虽然所有的线程中的不一样的 Looper 对象都有同一个 ThreadLocal 对象，但是这些线程有不一样的 ThreadLocalMap ，所以用同一个 ThreadLocal 对象作为 key 在不同的 ThreadLocalMap 中取值，取到的肯定是不同的 Looper ，这下明白了。</p>
<h3 id="如何获取-Message"><a href="#如何获取-Message" class="headerlink" title="如何获取 Message"></a>如何获取 Message</h3><p>使用 Message.obtain() ，因为 Message 使用完成后，都会回收，所以我们可以一直使用，这是享元设计模式。这样就维持一个池子，避免内存抖动，防止 OOM。new 了必然会回收，回收了就可能有碎片。</p>
<p>在 Looper.loop 方法里面，msg.target.dispathcMessage(msg) 执行完后，在 for(; ;) 死循环最后一句的时候会调用 msg.recycleUnchecked(); 进行回收，将回收的msg 插入到池子的<strong>头部</strong>。</p>
<h3 id="Looper-死循环不会-ANR-？"><a href="#Looper-死循环不会-ANR-？" class="headerlink" title="Looper 死循环不会 ANR ？"></a>Looper 死循环不会 ANR ？</h3><p>不是同一个层面的东西。毫不相关的问题。点击 5秒没响应 ANR ，其实这个点击事件它也是一个 Message。</p>
<h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>HandlerThread 存在的意义：</p>
<ul>
<li><p>方便使用</p>
</li>
<li><p>线程安全，getLooper 的线程安全问题</p>
</li>
</ul>
<p>wait 会释放锁，这样其他的函数才能获取到锁执行 notify 操作。notify 不会释放锁， 要等 synchronized 代码全部执行完才释放锁（notify操作可能不在synchronized 代码块最后 ）。</p>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>处理后台耗时任务。一个任务分为多个子任务，子任务按照顺序执行完成后，任务才能算完成，这时候可以使用 IntentService ，这样可以保证所有的子任务在同一线程执行。关于要执行的多个任务，代码写法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求1</span></span><br><span class="line">Intent i = <span class="keyword">new</span> Intent(<span class="string">"cn.scu.finch"</span>);</span><br><span class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle.putString(<span class="string">"taskName"</span>, <span class="string">"task1"</span>);</span><br><span class="line">i.putExtras(bundle);</span><br><span class="line">startService(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求2</span></span><br><span class="line">Intent i2 = <span class="keyword">new</span> Intent(<span class="string">"cn.scu.finch"</span>);</span><br><span class="line">Bundle bundle2 = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle2.putString(<span class="string">"taskName"</span>, <span class="string">"task2"</span>);</span><br><span class="line">i2.putExtras(bundle2);</span><br><span class="line">startService(i2);</span><br><span class="line"></span><br><span class="line">startService(i);  <span class="comment">//多次启动</span></span><br></pre></td></tr></tbody></table></figure>

<p> 具体可以参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1963339">Android多线程：IntentService使用教程(含实例讲解)-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p>类似的思想也体现在 Fragment 的管理上，：</p>
<p>在 FragmentPagerAdapter 中，会有 instantiateItem 方法。里面会执行 mCurTrasaction.attach(fragment) ，去 attach fragment ，但是这个 attach 方法会立即执行么？ 不会的，这时候只会加入list 中，等 commit 的时候才会一起执行。</p>
<p>并且可以保证 attach 一定是在 detach 后面执行，也是用 msg 来实现</p>
<p><strong>具体得自己再去看下源码</strong>，老师讲得不详细。</p>
<h4 id="glide-中的巧妙使用"><a href="#glide-中的巧妙使用" class="headerlink" title="glide 中的巧妙使用"></a>glide 中的巧妙使用</h4><p>假设有这样一段代码：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">with</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">val</span> fragmentManager = supportFragmentManager</span><br><span class="line">    <span class="keyword">val</span> f: MyFragment? = fragmentManager.findFragmentByTag(<span class="string">"tag"</span>) <span class="keyword">as</span> MyFragment?</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>) {</span><br><span class="line">        fragmentManager.beginTransaction()</span><br><span class="line">            .add(MyFragment(), <span class="string">"tag"</span>)</span><br><span class="line">            .commitAllowingStateLoss()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过某种途径得到commit 时候用到的 handler </span></span><br><span class="line">        <span class="comment">//handler.sendMessage(removeFragmentMessage)</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果连续调用 2 次，会怎样？可能你会想，第一次已经创建了 MyFragment 实例了，第二次直接通过 findFragmentByTag 就能找出来了。但是不是的，可能会创建 2 次 MyFragment 。这是因为最后在 commitAllowingStateLoss 的时候，最终是将这个操作作为一个 msg 扔到 Handler 里面。所以，<strong>第二次调用 with 的时候，第一次不一定执行完</strong>!所以，可能执行 2 次。 这个在 glide 的源码中有体现：</p>
<ol>
<li><p>创建一个 HashMap ，以 tag 为key ，第一次的时候，首先从 hashmap中获取，如果没有，再从 fragmentManager 中获取，如果还没有，就创建一个，然后将其加入到 HashMap 中</p>
</li>
<li><p>第二次的时候，首先判断 HashMap 里面有没有，如果有的话，就忽略，因为这个 Fragment 最终肯定会被创建出来，此时应该是commit 的中提交到 handler 中的 msg 还没执行。</p>
</li>
<li><p>在上述代码的注释部分，可以看到最终通过handler 发送一个消息，这个消息用于将 fragment 从 HashMap 中移除 Fragment ，防止内存泄漏。</p>
</li>
</ol>
<blockquote>
<p>第三点为什么可以这么做呢？因为同一个handler ，commit 的时候发的消息，肯定在前面，后续用于移除 msg 的 msg 肯定在后面，这样很巧妙地保证了用完fragmengt 就从 HashMap 中移除。</p>
</blockquote>
<p>上述代码其实就是 glide 中的一段代码设计思想，具体可以参考 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/317b2d6bde1b">Glide生命周期管理 - 简书 (jianshu.com)</a>    中  2.0.1 <strong>创建RequestManagerFragment</strong>  这个章节。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/02/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8801%EF%BC%892021.12.9-Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90---Alvin%E8%80%81%E5%B8%88%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/02/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8801%EF%BC%892021.12.9-Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90---Alvin%E8%80%81%E5%B8%88%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">（01）2021.12.9-Handler源码分析---Alvin老师（2）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-02 18:24:00" itemprop="dateCreated datePublished" datetime="2023-06-02T18:24:00+08:00">2023-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:39:37" itemprop="dateModified" datetime="2023-06-28T21:39:37+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>避免内存抖动：共享内存池。</p>
<p>ActivityThread 的 main 函数不会退出，这是因为 Looper.loop </p>
<p>ActivityThread 扮演后台的角色，Looper.loop 扮演的是心跳的角色</p>
<p>Android 中 App 的所有事务都是 Message ，所以，当我们碰到异常的时候，看到的 Log 都是从 ActivityThread 中的 loop 处开始的</p>
<p>我们根据 Looper.loop 中打印日志的时间，来判断每个 Message 的执行耗时，这是 BlackCanary 的原理，能判断卡顿</p>
<p>没有 Msg 的时候，就休眠了，此时 ANR ？其实是混淆概念，这是2个事情， ANR 的含义是事务在定时范围内没有完成，执行事务前埋雷，执行完成后挖出雷，就不会爆炸；如果到了时间还没挖雷，雷就爆了。</p>
<p>什么是 epoll ？</p>
<p>上层有 n 个 I/O 事件，要如何才能去处理多个流。其实系统底层用一个线程死循环，去判断（多线程去判断更慢）。</p>
<p>epoll 与线程之间的数量没有对应关系，不用搞混。epoll 机制是需要注册的，要说明针对哪个事件去 阻塞和唤醒。</p>
<h2 id="同步屏障（消息屏障）"><a href="#同步屏障（消息屏障）" class="headerlink" title="同步屏障（消息屏障）"></a>同步屏障（消息屏障）</h2><p>屏障消息就是target 为 null 的消息。一般的消息都是通过 Handler 放到 MessageQuue 。消息有 3 种 ：</p>
<ul>
<li>同步消息</li>
<li>异步消息：async 标记为 true ，普通的同步msg 没人设置 async 标记</li>
<li>同步屏障消息</li>
</ul>
<p>如果打印出 skip 30 frames ，the Application may be doing too many work …. 之类的错误，那就说明在主线程阻塞了，某个 msg 耗时过长，导致里面 30 个异步消未能执行。</p>
<p>在 ViewRootImpl 类的 scheduleTraversals 方法中，执行了 mHandler.getQueue().postSyncBarrier() 方法，在 MessageQueue 中添加了同步屏障。接着，在这个方法里面最终会执行到 performMeasure 、performLayout 和 performDraw 方法，这就很熟悉了，就是平时说view 绘制的步骤，或者说自定义View 尤其要关注的回调。</p>
<p>post 同步屏障的时候，会把屏障消息放到 MessageQueue 的最前面吗？不是的，只是普通的以当前时刻放入</p>
<p>一个线程一个 Looper 是由 static final 的 ThreadLocal  保证的，并且prepare 只能搞一次，第二次判断有 looper 的时候就报错了，不能多次 prepare 。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/06/02/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8801%EF%BC%892021.12.9-Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90---Alvin%E8%80%81%E5%B8%88%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/02/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/Framework%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%EF%BC%8801%EF%BC%892021.12.9-Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90---Alvin%E8%80%81%E5%B8%88%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">（01）2021.12.9-Handler源码分析---Alvin老师（1）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-02 09:15:00" itemprop="dateCreated datePublished" datetime="2023-06-02T09:15:00+08:00">2023-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-28 21:38:51" itemprop="dateModified" datetime="2023-06-28T21:38:51+08:00">2023-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>每个安卓应用都有自己的 vm，所以，每个应用也都有自己的main函数，那么这个 main 函数在哪里呢？在 ActivityThread 里面（省略部分无关代码）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span> <span class="keyword">implements</span> <span class="title">ActivityThreadInternal</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//省略无关代码</span></span><br><span class="line">        <span class="comment">// Install selective syscall interception</span></span><br><span class="line">        AndroidOs.install();</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) {</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Looper.loop是个死循环，如何才能终止呢？通过MessageQueue.next获取到一个null类型的Message，就退出了​，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfsda</span><br></pre></td></tr></tbody></table></figure>

<p>messagequeue.quit 也可以达到退出 Looper.loop 死循环的效果。</p>
<p>Message 就是一块内存，内存不分线程（只区分进程吧），因此 Handler  这个过程可以看做是内存共享， 不同线程之间的共享 Msg 这块内存。因此某种程度上，可以</p>
<p>单链表实现的优先级队列</p>
<p>为什么要把 Looper 的初始化只能在 prepare() 方法中进行，而不能让人 new Looper() ？</p>
<p>为什么一个线程只能有一个 Looper ，因为 Looper 存储在 ThreadLocal 中，而我们知道key 是 ThreadLocal 的对象，是唯一的，所以 value 也是唯一的。并且，prepare 的时候，首先通过 threadLocal.get 去获取 Looper ，发现不空就报错，只能 Looper 为空的时候才能 prepare 。</p>
<p>Looper 维持一个 MessageQueue 。一个线程只能创建一个 Looper ，一个 Looper 创建一个 MessageQueue。</p>
<p>Handler 内存泄漏问题的原因？为什么其他内部类没有说有这个问题？比如说 RecyclerView 的 Adapter 里面一般会有一个 ViewHolder 内部类，它为什么不会内存泄漏？</p>
<p>内存泄漏的原因是生命周期不一致。</p>
<p>msg delay 了 20s 才执行，msg 持有的了handler ，handler 是非静态内部类，持有外部对象，所以可能导致内存泄漏。</p>
<p>子线程new handler 要做什么准备？</p>
<p>需要prepare ，有 Looper 才行。</p>
<p>子线程中维护 Looper，消息队列无消息的时候的处理方案是什么？有什么用？</p>
<p>需要调用 MessageQueue.quit， 这时候会将 mQuitting 标志位置为 true 。由于之前已经没有消息了，那么此时应该是处于 nativePollOnce 无限睡眠阶段，quit 方法同样会去调用 nativeWake 方法唤醒，这样就会继续 loope 方法，在里面判断到 mQuitting 为true ，于是return 了一个 null 类型的 Msg ，从而导致 Looper.loop 退出死循环</p>
<p>MessageQueue 为什么不设置容量上限？如果设置了，那么系统的消息都不能进去了，整个系统就死掉了。</p>
<p>两个方面的阻塞：</p>
<ul>
<li><p>Message 还不到时间，时间到了会自动唤醒</p>
</li>
<li><p>MessageQueue 为空，nextPollTimeoutMillis 值为 -1 ，就会进入 nativePollOnce 的无限睡眠了。在enqueueMessage （有新的 Msg 加入的时候）的时候，才会被唤醒（调用nativeWake）</p>
</li>
</ul>
<p>线程阻塞了，所以cpu 就不会来调度它了，节省了cpu 性能。</p>
<p>既然可以存在多个 Handler 往 MessageQueue 中添加数据（发消息的时候，各个Handler 可能在不同的线程），那么它的内部是如何保证线程安全的？</p>
<ul>
<li><p>首先，1个线程只有一个 MessageQueue </p>
</li>
<li><p>其次，MessageQueue 操作加锁了。在 MessageQueue 中，不论是 enqueue 方法，还是 next 方法，都会在里面锁代码块：</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>{</span><br><span class="line">     <span class="comment">//省略无关代码</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">         <span class="comment">//省略无关代码</span></span><br><span class="line">     }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">     <span class="comment">//省略无关代码</span></span><br><span class="line">     <span class="keyword">for</span> (;;) {</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">         <span class="comment">//省略无关代码</span></span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line">}        </span><br></pre></td></tr></tbody></table></figure>

<p>从代码可以看出，锁的是整个 MessageQueue 对象，所以，对于同一个 MessageQueue 来说，每次只能一个线程存/取。</p>
<p>为什么取的时候也要加锁？明明都是从头取？</p>
<p>这是因为你取的时候，我这边有线程正在加入新的 Msg ，此时就存在同步问题。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/24/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8807%EF%BC%892022.2.10-%E5%8D%A1%E9%A1%BF%E5%92%8C%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/24/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8807%EF%BC%892022.2.10-%E5%8D%A1%E9%A1%BF%E5%92%8C%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">性能优化-：（07）2022.2.10-卡顿和布局优化---路哥</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-24 19:00:00" itemprop="dateCreated datePublished" datetime="2023-05-24T19:00:00+08:00">2023-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-26 23:31:18" itemprop="dateModified" datetime="2023-05-26T23:31:18+08:00">2023-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>一、前情回顾</p>
<p>GC 的时候，Java 线程、Native 线程都会中断，中断就会卡顿，会影响性能。</p>
<p>上节课提到，执行一次 GC 后，间隔5s 或者 500ms 再次执行一下GC ，这样基本上能触发 GC ，这是什么原理呢？在 Android 5.0 以前，System.gc() 基本上就能触发 GC 行为，它的代码是这样的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates to the VM that it would be a good time to run the</span></span><br><span class="line"><span class="comment"> * garbage collector. Note that this is a hint only. There is no guarantee</span></span><br><span class="line"><span class="comment"> * that the garbage collector will actually be run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>{</span><br><span class="line">    Runtime.getRuntime().gc();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是在 5.0 及以后，调用 System.gc 或者 runTime.gc 不一定会触发 GC 了，这是因为在 5.0 及以后的 gc 方法里面会有标记判断：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates to the VM that it would be a good time to run the</span></span><br><span class="line"><span class="comment"> * garbage collector. Note that this is a hint only. There is no guarantee</span></span><br><span class="line"><span class="comment"> * that the garbage collector will actually be run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> shouldRunGC;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) {</span><br><span class="line">        shouldRunGC = justRanFinalization;</span><br><span class="line">        <span class="keyword">if</span> (shouldRunGC) {</span><br><span class="line">            justRanFinalization = <span class="keyword">false</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            runGC = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (shouldRunGC) {</span><br><span class="line">        Runtime.getRuntime().gc();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，是否执行 gc 还有赖于 justRanFinalization 变量，这个变量在哪里赋值为true 呢？是在 runFinalization 方法中：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provides a hint to the VM that it would be useful to attempt</span></span><br><span class="line"><span class="comment"> * to perform any outstanding object finalization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runFinalization</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> shouldRunGC;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) {</span><br><span class="line">        shouldRunGC = runGC;</span><br><span class="line">        runGC = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (shouldRunGC) {</span><br><span class="line">        Runtime.getRuntime().gc();</span><br><span class="line">    }</span><br><span class="line">    Runtime.getRuntime().runFinalization();</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) {</span><br><span class="line">        justRanFinalization = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从上述代码可以看出，我们直接调用 System.gc 并不会调用到 Runtime.getRunTime().gc() ，只是做了个标记将 runGc 设置为 true ，然后在下一次 GC 的时候，就能真正 GC 了。那为什么要间隔5s 或者 500ms 呢？这个跟线程调度、线程的中断状态有关。</p>
<p>所以，上一节课也提到，内存监控自己做 GC 的时候，也可以使用 runFinalization() + runTime.gc 的方式去GC，这样也是可以的。</p>
<p>由于路哥在课程里面对这个讲得不是太清晰，更详细的内容可以参考</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/225751">提升Android下内存的使用意识和排查能力-阿里云开发者社区 (aliyun.com)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/225755">再谈Finalizer对象–大型App中内存与性能的隐性杀手-阿里云开发者社区 (aliyun.com)</a></p>
</li>
</ul>
<h2 id="二、-Alpha-源码讲解"><a href="#二、-Alpha-源码讲解" class="headerlink" title="二、 Alpha 源码讲解"></a>二、 Alpha 源码讲解</h2><p>面试中怎么讲：</p>
<ul>
<li><p>Executor ：线程池，调用方可以自己实现，也可以使用默认的，参数怎么设置</p>
</li>
<li><p>Task ： 是个线程，有任务自己的状态、有自己的子任务</p>
</li>
<li><p>接口： 执行前、执行后、失败</p>
</li>
</ul>
<p>仿照 Alpha 的框架没有实现 DAG 算法，是个弊端</p>
<h3 id="1、主要要实现的功能"><a href="#1、主要要实现的功能" class="headerlink" title="1、主要要实现的功能"></a>1、主要要实现的功能</h3><p>线程池、线程等待、线程切换、主进程/子进程</p>
<h2 id="三、总结之前的启动框架"><a href="#三、总结之前的启动框架" class="headerlink" title="三、总结之前的启动框架"></a>三、总结之前的启动框架</h2><p>内存、ANR 、启动，这3个点，性能优化就能把握了</p>
<h2 id="四、卡顿"><a href="#四、卡顿" class="headerlink" title="四、卡顿"></a>四、卡顿</h2><p>根据前面说的，能够在 Activity 的 onWindowFocusChanged 方法中停止方法的采集，因为这个时候恰好是 window 切换，要么是新的 window 启动了，要么是关闭了某个 window，所以，如果我们要监测到第一个 Activity 的耗时，可以从Application 的 onCreate 中去start，在 MainActivity 中去 stop 这个 trace 去实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Application</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> : <span class="title">Application</span> </span>{</span><br><span class="line">    <span class="function">override fun <span class="title">onCreate</span><span class="params">(xx)</span> </span>{</span><br><span class="line">        Debug.startMethodTracingSampling(tracePath, bufferSize, untervalUs)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//MainActivity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="title">Activity</span> </span>{</span><br><span class="line">    <span class="function">override fun <span class="title">onWindowFocusChanged</span><span class="params">(hasFocus)</span> </span>{</span><br><span class="line">        Debug.stopMethodTracing()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你可以获取到更细粒度更精准的耗时，比如在 ListView 中 getView 方法，在方法调用前start ，在调用完成之后，调用 stop 。</p>
<p>根据上述获取的 trace 文件，拖到 AS 中就能看到方法的耗时，线程相关内容等。</p>
<p>systrace 比上面的方法更加精准。systrace 就是个 shell 脚本嘛，他需要使用 python 执行，比如定位到 SDK 目录下（platform-tools）的 systrace 时，调用 python systrace.py 即可。systrace 可以在 chrome 上打开，使用地址：</p>
<blockquote>
<p>chrome://tracing</p>
</blockquote>
<p>线上如何做卡顿。卡顿的原理。自己定义阈值，超过某个值就说是卡顿，比如 1000ms ，</p>
<p>CountDownLatch 实现让主线程等待所有的初始化完成才继续执行的。</p>
<p>第一个版本仿照 Alpha ，怎么保证顺序？</p>
<p>第二个版本 DAG （有向无环图）保证顺序</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/05/24/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8806%EF%BC%892022.1.25-%E5%9F%BA%E4%BA%8EAutoService%E5%92%8CCompose%E7%9A%84App%E5%90%AF%E5%8A%A8%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/24/%E4%BA%AB%E5%AD%A6%E8%AF%BE%E5%A0%82Android%E4%B8%89%E6%9C%9FVip/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%EF%BC%8806%EF%BC%892022.1.25-%E5%9F%BA%E4%BA%8EAutoService%E5%92%8CCompose%E7%9A%84App%E5%90%AF%E5%8A%A8%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">性能优化-：（06）2022.1.25-基于AutoService和Compose的App启动架构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-24 15:15:00 / 修改时间：23:09:21" itemprop="dateCreated datePublished" datetime="2023-05-24T15:15:00+08:00">2023-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">听课笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>今天主要从<strong>组件化</strong> + <strong>责任链</strong> 的角度去讲启动。主要讲代码的可维护性、解耦，跟启动速度没什么关系</p>
<p>有些错误的做法是 在宿主的 Application 中初始化所有的组件。</p>
<p>app 启动包括三个部分： Application 过程、 Splash 过程、 Mainactivity 过程（第一个 Activity）</p>
<p>有可能在 Application 中用户同意了某些条款和不同意的情况下初始化还不一样。工信部要求App 这样。所以可能宿App 中定义一个 BaseApplication 接口，除了其他方法之外，在其中至少定义几个方法：</p>
<ul>
<li><p>不论同不同意用户协议都需要执行的方法</p>
</li>
<li><p>用户同意了协议才执行的方法</p>
</li>
<li><p>用户拒绝后执行的方法</p>
</li>
</ul>
<p>然后，让每个组件去实现这个接口，实现上述的方法，自己实现各自的逻辑。可以利用 autoService 将这些组件的 Application 注册到宿主中，并不需要自己去遍历添加到list 里面。这是在编译期间将这些组件的 Application 添加到宿主的list 中的，所以对于运行效率是没有影响的。</p>
<blockquote>
<p>在 autoService 的 gradle 中实现的，可以看看他的 gradle 文件</p>
</blockquote>
<p>compose 是一套新的 UI 体系，和以前的 View 和 ViewGroup 有啥区别？</p>
<blockquote>
<p>前者是声明式的，数据驱动的，后者是命令驱动的</p>
</blockquote>
<p>compose 和 databinding 的区别：</p>
<ul>
<li><p>databinding ： 只能绑定属性，只能绑定xml 属性中的值</p>
</li>
<li><p>compose 可以根据数据的变化改变视图的结构</p>
</li>
</ul>
<p>只有在主进程才需要执行我们的逻辑，有些SDK 可能会开启自己的进程，所以需要判断下。</p>
<p>老师说写 SplashActivity ，在 manifest 中给这个 SplashActivity 设置 theme ，在 theme 里面设置 background ，但是其实前面说启动优化的时候，给整个 App 设置 theme ，然后设置 android:windowSplashscreenContent 属性就好了，注意区分和甄别。</p>
<p>SplashActivity 启动 MainActivity ，那么 SplashActivity 在什么时候可以结束？我们知道，在启动过程肯定是 SplashActivity.onPause -&gt; MainActivity.onCreate -&gt; MainActivity.onResume -&gt; SplashActivity.onStop  这样的顺序执行的，当然，MainActivity的其他无关的回调省略了。所以，在 SplashActivity 的 onStop 的时候， SplashActivity 就没有什么意义了，所以可以在 SplashActivity 的 onStop 回调中执行 finish 结束。</p>
<blockquote>
<p>为什么这样做呢？因为如果在 SplashActivity 中 start MainActivity的时候直接 finish SplashActivity ，某种情况就可能会出现白屏，或者 MainActivity 崩溃了，就看不到我们 App 了</p>
</blockquote>
<p>讲到 1 小时40分钟的时候直接听不懂了，放弃，后续有时间看</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">223</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共444.1k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/page/5/',]
      });
      });
  </script>


</body>
</html>
