<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.gitee.io/page/5/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.gitee.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">112</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2020/03/08/%E9%9D%A2-%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/08/%E9%9D%A2-%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">面试题-算法-概念</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-08 12:55:00" itemprop="dateCreated datePublished" datetime="2020-03-08T12:55:00+08:00">2020-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-08 23:52:03" itemprop="dateModified" datetime="2020-05-08T23:52:03+08:00">2020-05-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="二叉查找树-也称二叉搜索树"><a href="#二叉查找树-也称二叉搜索树" class="headerlink" title="二叉查找树(也称二叉搜索树)"></a>二叉查找树(也称二叉搜索树)</h2><ul>
<li>左子树上的节点值都<strong>小于等于</strong>根节点的值    </li>
<li>右子树上的节点值都<strong>大于等于</strong>根节点的值    </li>
<li>左右子树也是二叉搜索树    </li>
</ul>
<p>它是基于二分查找的思想，<strong>查找最大的次数为二叉树高度</strong>     </p>
<h3 id="查找代价"><a href="#查找代价" class="headerlink" title="查找代价"></a>查找代价</h3><ul>
<li>当左右子树高度大致平衡时，时间复杂度在 O(logN)     </li>
<li>当先后插入的关键字<strong>有序</strong>时，退化成链表，查找的时间复杂度就在 O(N)了     </li>
</ul>
<h3 id="插入代价"><a href="#插入代价" class="headerlink" title="插入代价"></a>插入代价</h3><p>新节点插入到树的叶子节点上，因此，插入节点和查找一个不存在的数据的代价相同    </p>
<h3 id="删除代价"><a href="#删除代价" class="headerlink" title="删除代价"></a>删除代价</h3><ul>
<li>如果被删除的节点左、右 有一个为null时，代价仅为 O(1)      </li>
<li>如果左右子树都存在，时间复杂度最大也不会超过O(logN)      </li>
</ul>
<p>缺陷：</p>
<p>极端情况可能退化成链表，时间复杂度为  n。这主要是由于树不平衡导致的</p>
<h2 id="平衡二叉查找树-平衡二叉搜索树"><a href="#平衡二叉查找树-平衡二叉搜索树" class="headerlink" title="平衡二叉查找树(平衡二叉搜索树)"></a>平衡二叉查找树(平衡二叉搜索树)</h2><p>是严格的平衡二叉树，它是空树或者左右两个子树的高度差 <strong>小于等于1</strong>，同时，左右两个子树也是平衡二叉搜索树</p>
<h3 id="查找代价-1"><a href="#查找代价-1" class="headerlink" title="查找代价"></a>查找代价</h3><p>时间很稳定，查找效率最好最坏都是  O(logN)</p>
<h3 id="插入代价-1"><a href="#插入代价-1" class="headerlink" title="插入代价"></a>插入代价</h3><p>由于要保证严格的平衡，插入时可能要进行再平衡(最多旋转一次)，因此插入的整体代价还在 O(logN)</p>
<h3 id="删除代价-1"><a href="#删除代价-1" class="headerlink" title="删除代价"></a>删除代价</h3><p>和插入一样，要考虑再平衡，但是最多需要O(logN)次旋转，所以时间复杂度为  O(2logN)</p>
<h2 id="红黑树-Red-Black-Tree"><a href="#红黑树-Red-Black-Tree" class="headerlink" title="红黑树(Red-Black Tree)"></a>红黑树(Red-Black Tree)</h2><p>它并不严格地平衡，最长路径长度不超过最短路径长度的2倍。它删除和插入引起平衡性改变的概率要远低于平衡二叉搜索树</p>
<h3 id="查找代价-2"><a href="#查找代价-2" class="headerlink" title="查找代价"></a>查找代价</h3><p>查找代价基本上维持在 O(logN) 级别，最差情况下肯定比平衡二叉搜索树要差，因为没有那么平衡</p>
<h3 id="插入代价-2"><a href="#插入代价-2" class="headerlink" title="插入代价"></a>插入代价</h3><p>不容易引起失衡，整体代价和平衡二叉搜索树差不多，也是 O(logN) 级别(虽然涉及变色，但是变色的代价很小)</p>
<h3 id="删除代价-2"><a href="#删除代价-2" class="headerlink" title="删除代价"></a>删除代价</h3><p>相对平衡二叉搜索树，不容易引起失衡，时间复杂度也在 O(logN) 级别</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>平衡二叉搜索树由于插入和删除，会引起需要调整，可以通过 ：变色、左旋转、右旋转  三种方式调整。是否需要调整要根据红黑树的特性：</p>
<ul>
<li>节点是红色或黑色    </li>
<li>根节点是黑色    </li>
<li>叶子节点都是黑色的空节点    </li>
<li>红色节点的两个子节点都是黑的(红节点不能连续出现)    </li>
<li>任一点到每个叶子节点的路径包含相同数目的黑节点    </li>
</ul>
<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54084335">zhihu</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/z702143700/article/details/49079107">csdn</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31805309">知乎</a></p>
</blockquote>
<h2 id="B-树和B-树"><a href="#B-树和B-树" class="headerlink" title="B-树和B+ 树"></a>B-树和B+ 树</h2><p>我们所谓的B-树，其实并不是B减树，中间是横线，不是减号；B + 就是 B加树了</p>
<p>如 os 的文件目录存储、数据库中的索引结构的存储，不可能在内存中建立查找结构，必须在磁盘中建立好结构。</p>
<p>在磁盘组织结构下，从任何一个节点指向其他节点都可能读取一次磁盘，再将数据写入内存比较。这回带来大量的IO操作，所以我们需要新的数据结构，即 B树和B+树。</p>
<p>B树是一种<strong>多路平衡查找树</strong>，每个节点最多包含k个孩子，k称为B树的阶。K大小取决于<strong>磁盘页的大小</strong>。</p>
<h2 id="一些算法上的概念"><a href="#一些算法上的概念" class="headerlink" title="一些算法上的概念"></a>一些算法上的概念</h2><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>理解平衡二叉树后，就会更好理解后续的B树。</p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树是一棵二叉树，每个节点的左边节点小于当前节点的值，右边节点的值大于当前节点的值。</p>
<p>因为二叉树的遍历性能和树的层级成反比，层级h越小查询越快，为了保证树的结构左右两端数据大致平衡以降低二叉树高度，一般会采用算法机制实现节点的平衡，如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B3%E8%A1%A1.jpg" alt="平衡树的高度"></p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h4><p>当上述的平衡二叉树深度很深无法存储所有的节点数据时，需要读取磁盘。从而树的深度越大，需要的I/O操作次数越多，因此效率也越低，因此我们需要想办法降低树的高度。</p>
<p>B 树的思路和平衡二叉树一样，但是采用了多叉的方式降低了高度。</p>
<p>B树的具体实现比较难描述，看下面的参考链接更清晰，就不赘述。</p>
<blockquote>
<p>以上内容参考自： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27700617">勤劳的小手</a>、<a target="_blank" rel="noopener" href="http://www.androidos.net.cn/book/android-road/data-structure/tree/b-tree.html">B树概念</a></p>
</blockquote>
<h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><p>主要是利用KMP算法，这个很令人头大，这里贴出算法代码，如果需要详细了解，可以去查看<a target="_blank" rel="noopener" href="https://blog.csdn.net/v_july_v/article/details/7041827">July大神的这篇文章</a>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String str, String dest,<span class="keyword">int</span>[] next)</span></span>{<span class="comment">//str文本串  dest 模式串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str.length(); i++){</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; str.charAt(i) != dest.charAt(j)){</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == dest.charAt(j)){</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(j == dest.length()){</span><br><span class="line">                <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] kmpnext(String dest){</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[dest.length()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>; i &lt; dest.length(); i++){</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(j) != dest.charAt(i)){</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(dest.charAt(i) == dest.charAt(j)){</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            next[i] = j;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>next数组的计算主要跟模式串有关，与文本串并没有关系，因为，模式串前后公共最长子序列。这样才会让我们跳过大量的重复计算</p>
<h3 id="数字排列"><a href="#数字排列" class="headerlink" title="数字排列"></a>数字排列</h3><p>题目：用1，2，2，3，4，5 这6个数字，写一个方法，打印出所有不同的排列，如 512234、412235等，要求4不能再第三位，3与5不能相连。</p>
<blockquote>
<p>思路：问题可以归结为<strong>图的遍历</strong>，实际上6个数字就是6个结点，把6个结点连成无向连通图，对于每个结点求这个图形的遍历路径，所有结点的遍历路径就是最后对这6个数字的排列组合结果集。当然，这样获取的结果集未达到题目要求：<br>（1）3与5不能相连，这个可以在构造图的时候就满足条件；<br>（2）不能重复，有两个2，明显会存在重复结果，得最后去重（可以放在treeSet中）；<br>（3）4不能排在第三位，这个仍旧在结果集中排除即可。</p>
</blockquote>
<p>具体代码略。</p>
<h3 id="手写算法题。猫扑素数；1到n，求1的个数；单词反转。"><a href="#手写算法题。猫扑素数；1到n，求1的个数；单词反转。" class="headerlink" title="手写算法题。猫扑素数；1到n，求1的个数；单词反转。"></a>手写算法题。猫扑素数；1到n，求1的个数；单词反转。</h3><h3 id="算法：排序、二叉树遍历、红黑树了解。常见的数据结构主要有数组、链表、栈、队列、二叉堆、树、图等，红黑树和BL树的区别"><a href="#算法：排序、二叉树遍历、红黑树了解。常见的数据结构主要有数组、链表、栈、队列、二叉堆、树、图等，红黑树和BL树的区别" class="headerlink" title="算法：排序、二叉树遍历、红黑树了解。常见的数据结构主要有数组、链表、栈、队列、二叉堆、树、图等，红黑树和BL树的区别"></a>算法：排序、二叉树遍历、红黑树了解。常见的数据结构主要有数组、链表、栈、队列、二叉堆、树、图等，红黑树和BL树的区别</h3><h3 id="快速排序底层原理简单描述。"><a href="#快速排序底层原理简单描述。" class="headerlink" title="快速排序底层原理简单描述。"></a>快速排序底层原理简单描述。</h3></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2020/02/27/%E9%97%AE-%E6%8A%80%E5%B7%A7/Android%E8%8E%B7%E5%8F%96debug%E5%8C%85%E7%9A%84cookies%E7%9A%84db%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/%E9%97%AE-%E6%8A%80%E5%B7%A7/Android%E8%8E%B7%E5%8F%96debug%E5%8C%85%E7%9A%84cookies%E7%9A%84db%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">Android获取debug包的cookies的db文件</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-27 08:00:00" itemprop="dateCreated datePublished" datetime="2020-02-27T08:00:00+08:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-03 21:29:59" itemprop="dateModified" datetime="2020-03-03T21:29:59+08:00">2020-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">问题</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在项目中，用户登录后，需要为白名单中的 host 注入特定的cookies，在用户退出登录的时候，需要将注入的 cookies 清除(只清除app自己注入的cookies，h5 注入的cookies不要清除)。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Android 的webview 并没有提供针对单个host 清除cookies的方法，只有全部清除，因此主要思路是将需要删除的cookies 设置为过期，再删除过期的即可，具体可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/turkeycock/article/details/53091103">Android清除单个域名的cookie</a></p>
<p>当然，设置cookies过期有两种方法:</p>
<blockquote>
<p>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</p>
</blockquote>
<p>使用Cookie的: Expires 属性. 它可以设置cookie的过期时间. 下面的代码表示id这条cookie的过期时间是2015年10月21日早上7点28分;</p>
<blockquote>
<p>Set-Cookie: id=a3fWa; Max-Age=86400</p>
</blockquote>
<p>使用Cookie的: Max-Age 属性. 它可以指定从现在开始Cookie存在的秒数. 秒数过完则cookie过期</p>
<p>参考 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/aisowe/p/11566073.html">aisowe</a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>但是在清理的时候，发现总是不能清除掉指定cookie，打印出来发现：同一个host，比如 baidu.com ，它的cookie里面有2个key是一样的，但是值不一样，清理的时候，指定host 为baidu.com ，但是只能清除一个，另一个怎么也清理不掉。</p>
<p>这就很奇怪了，能想到的就是可能在多个不同的host下都注入了这个key，于是想办法要把它存储cookies的文件取出来看下。</p>
<p>我们知道，cookies 文件存储在 /data/data/<package>/app_webview，文件名是Cookies ，但是这个路径是一个app内部空间，普通情况下是没办法将这个文件获取出来的，除非是在虚拟机或者root过后，安装特定的文件管理器。</package></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>不过我们安装Debug 的包的情况下，可能会有解决办法。因为 PackageManager 会检查 AndroidManifest.xml 中 isDebuggable 是不是false，这个值在我们打包的时候会根据你是打release包还是debug包而是不同的值，debug情况下是 isDebuggable = true，release 情况下是 true。</p>
<p>这样，我们将手机通过Android Studio 安装上debug包，进入shell：</p>
<blockquote>
<p>adb shell    </p>
</blockquote>
<p>进入app 空间：</p>
<blockquote>
<p>run-as <package>    </package></p>
</blockquote>
<p>这样就能进入到app的内部空间，当然，也可以参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/SZ2015/p/4750051.html">不root情况下读取data数据</a> ,此时我们再通过命令：</p>
<blockquote>
<p>cd app_webview/</p>
</blockquote>
<p>就能进到存放cookies的目录了，通过 ls 命令就能看到 Cookies 这个文件，这个文件是个数据库文件，可以使用sqlite3 打开。此时我们不能直接将其copy到我们电脑上，只能将其复制到我们的 sdcard 中：</p>
<blockquote>
<p>cp Cookies /sdcard</p>
</blockquote>
<p>此时，Cookies 文件已经被赋值到 sdcard，通过两次 exit 命令，就能退出 shell 模式，再通过 adb pull 命令，就能将其复制到电脑上了。</p>
<h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>在命令行打开Cookies 文件：</p>
<blockquote>
<p>sqlite3 /desktop/Cookies<br>.dump cookies</p>
</blockquote>
<p>就能看到cookies的数据了，这时候才发现，原来两个host都注入了这个key的cookie，一个是  baidu.com  一个是 .baidu.com，而后者是h5页面自己注入的，接下来问题就很明了了，将需要清除的cookies 按照前面的方法添加过期时间就ok，再手动执行删除过期cookies的操作，任务就完成了。</p>
<p>该篇文章旨在记录问题解决过程，详细过程这里略过。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2020/01/15/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC13%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/15/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC13%E7%AB%A0/" class="post-title-link" itemprop="url">第13章：热修复原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-15 22:17:00 / 修改时间：22:18:03" itemprop="dateCreated datePublished" datetime="2020-01-15T22:17:00+08:00">2020-01-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>热修复框架的核心技术主要有3类：代码修复、资源修复和动态链接库修复。</p>
<h2 id="资源修复"><a href="#资源修复" class="headerlink" title="资源修复"></a>资源修复</h2><p>很多热修复的框架的资源修复参考了Instant Run的资源修复原理，因此我们首先了解下Instant Run 的原理。Instant Run 的资源修复核心逻辑在MonkeyPatcher 的monkeyPatchExistingResources 方法中，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com/android/tools/fd/runtime/MonkeyPatcher.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">monkeyPatchExistingResources</span><span class="params">(Context context,String externalResourceFile,Collection&lt;Activity&gt; activityes)</span></span>{</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">    <span class="comment">//创建一个新的 AssetManager</span></span><br><span class="line">       AssetManager newAssetManager = (newAssetManager)newAssetManager.class.getConstructor(<span class="keyword">new</span> Class[<span class="number">0</span>]).newInstance(<span class="keyword">new</span> Object[<span class="number">0</span>]);<span class="comment">//1</span></span><br><span class="line">       </span><br><span class="line">       Method mAddAssetPath = AssetManager.class.getDeclareMethod(<span class="string">"addAssetPath"</span>,<span class="keyword">new</span> Class[] {String.class});<span class="comment">//2</span></span><br><span class="line">       </span><br><span class="line">       mAddAssetPath.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">//通过反射调用 addAssetPath 方法加载外部的资源( SD 卡)</span></span><br><span class="line">       <span class="keyword">if</span> (((Integer) mAddAssetPath.invoke(newAssetManager,<span class="keyword">new</span> Object[]{ externalResourceFile})).intValue () == <span class="number">0</span>) {<span class="comment">//3</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not create new AssetManager"</span>);</span><br><span class="line">            </span><br><span class="line">       <span class="keyword">if</span>{activities != <span class="keyword">null</span>){</span><br><span class="line">         <span class="keyword">for</span> (Activity activity : activities) {</span><br><span class="line">         Resources resources= activity.getResources() ;<span class="comment">//4</span></span><br><span class="line">         <span class="keyword">try</span> {</span><br><span class="line">          <span class="comment">//反射得到 Resources 的 AssetManager 类型的 mAssets 字段</span></span><br><span class="line">          Field mAssets = Resources.class.getDeclareField(<span class="string">"mAssets"</span>);<span class="comment">//5</span></span><br><span class="line">          mAssets.setAccessible(<span class="keyword">true</span> );</span><br><span class="line"></span><br><span class="line">          <span class="comment">//将 mAssets 字段的引用替换为新创建的 AssetManager</span></span><br><span class="line">          mAssets.set(resources,newAssetManager) ;<span class="comment">//6</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//得到 Activity 的 Resources.Theme</span></span><br><span class="line">          Resources.Theme theme = activity.getTheme();</span><br><span class="line">          ...</span><br><span class="line">          <span class="comment">//反射得到 Resources.Theme 的 mAssets 字段</span></span><br><span class="line">          Field ma = Resources . Theme.class.getDeclaredField (” mAssets <span class="string">" ) ;</span></span><br><span class="line"><span class="string">          ma.setAccessible(true);</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">          //将 Resources.Theme 的 mAssets 字段替换为 newAssetManager</span></span><br><span class="line"><span class="string">          ma.set(theme,newAssetManager);//7</span></span><br><span class="line"><span class="string">         } catch (Throwable ignore) {</span></span><br><span class="line"><span class="string">         </span></span><br><span class="line"><span class="string">         }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看出，在注释1处创建了一个新的AssetManager，之后通过反射调用 addAssetPath 方法加载外部(SD卡)的资源。在注释4处遍历Activity 列表，得到每个Activity 的Resource ，在5处通过反射得到Resources 的AssetManager 类型的mAsset字段，并在注释6处改写mAssets字段的引用为新的 AssetManager。之后，将AssetManager 类型的mAssets 字段的引用全部替换为新创建的 AssetManager。所以，总共就是两个步骤：</p>
<ul>
<li>创建新的 AssetManager ,通过反射调用 addAssetPath 方法加载外部的资源,这样<br>新创建的 AssetManager 就含有了外部资源。     </li>
<li>将 AssetManager 类型的 rnAssets 字段的引用全部替换为新创建的 AssetManager。</li>
</ul>
<h2 id="代码修复"><a href="#代码修复" class="headerlink" title="代码修复"></a>代码修复</h2><p>先写到这，后续有空再来。。。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/12/06/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/06/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">第5章：理解上下文Context</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-06 19:09:00" itemprop="dateCreated datePublished" datetime="2019-12-06T19:09:00+08:00">2019-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-20 21:53:40" itemprop="dateModified" datetime="2020-02-20T21:53:40+08:00">2020-02-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Context-的关联类"><a href="#Context-的关联类" class="headerlink" title="Context 的关联类"></a>Context 的关联类</h2><p>开发中经常使用的Context 的使用场景大体分为两类：</p>
<ul>
<li>使用Context 调用方法，比如启动 Activity、访问资源、调用系统服务等。    </li>
<li>调用方法时传入，比如弹出 Toast、创建dialog。    </li>
</ul>
<p>Activity、Service 与 Application 都间接继承 Context，因此可以说一个应用进程的Context 数量 = Activity 数量 + Service 数量 + 1，这个1就是Application数量。Context 的关联类的关系如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC5%E7%AB%A0/Context%E5%85%B3%E8%81%94%E7%B1%BB%E5%85%B3%E7%B3%BB.png" alt="Context关联类关系"></p>
<p>可以看出，ContextWrapper 中包含有 Context 类型的 mBase 对象，mBase 具体指向 ContextImpl，此外，ContextThemeWrapper、Service 和 Application 都继承自 ContextWrapper，这样它们都能通过 mBase 来使用Context 的方法。同时它们也是装饰类，在 ContextWrapper 上又添加了不少功能。比如，ContextThemeWrapper 包含了主题相关的方法(getTheme之类)，因此Activity 继承了ContextThemeWrapper，而Service 不需要主题，因此继承 ContextWrapper。Context 关联类的继承结构有以下优点：</p>
<ul>
<li>使用者能够方便使用Context 的功能。    </li>
<li>如果 ContextImpl 发生了变化，它的装饰类 ContextWrapper 无需做任何修改。    </li>
<li>ContextImpl 的具体实现不会暴露给使用者。     </li>
<li>通过组合而不是继承，拓展 ContextImpl 的功能。运行时选择不同的装饰类，实现不同功能。    </li>
</ul>
<h2 id="Application-Context-的创建过程"><a href="#Application-Context-的创建过程" class="headerlink" title="Application Context 的创建过程"></a>Application Context 的创建过程</h2><p>我们通过 getApplicationContext 来获取应用程序的全局 Application Context，那么 Application Context 是如何创建的呢？在应用程序启动完成后，应用程序就有一个全局的 Application Context，那就从应用程序启动过程着手，Application Context 的创建过程时序图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC5%E7%AB%A0/ApplicationContext%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Application context 的创建时序图"></p>
<p>应用程序进程的主线程管理类 ActivityThread 会调用内部类 ApplicationThread 的 scheduleLaunchActivity 方法来启动Activity，而在scheduleLaunchActivity 中会向 H 发送 LAUNCH_ACTIVITY 类型消息，目的是将启动Activity 的逻辑放在主线程中。在 H 的 handleMessage 方法中最终会调用到 LoadApk 类的  makeApplication 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,Instrumentation nstrumentation)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) {<span class="comment">//l</span></span><br><span class="line">        <span class="keyword">return</span> mApplication;</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">    Application app = <span class="keyword">null</span>;</span><br><span class="line">    String appClass = mApplicationinfo.className;</span><br><span class="line">    <span class="keyword">if</span> (forceDefaultAppClass || (appClass == <span class="keyword">null</span>) ) {</span><br><span class="line">        appClass = <span class="string">"android.app.Application”;</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    try {</span></span><br><span class="line"><span class="string">        java.lang.ClassLoader cl= getClassLoader();</span></span><br><span class="line"><span class="string">        if (!mPackageName.equals ("</span>android<span class="string">")){</span></span><br><span class="line"><span class="string">            initializeJavaContextClassLoader ();</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Contextimpl appContext = Contextimpl.createAppContext(mActivityThread,this); //2</span></span><br><span class="line"><span class="string">        app = mActivityThread.rninstrumentation.newApplication(cl, appClass, appContext);//3</span></span><br><span class="line"><span class="string">        appContext. setOUterContext(app) ;//4</span></span><br><span class="line"><span class="string">    }catch (Exception e){</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    mApplication = app;//5</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    return app;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>注释1处，假设是第一次启动应用程序，因此 mApplication 为null，在注释2处通过 Contextimpl 的 createAppContext 方法创建 Contextimpl 的实例，注释3中创建了 Application 对象，注释4处将 Application 对象赋值给 Contextimpl 的成员变量 mOuterContext ，<strong>这样，ContextImpl 中也包含了 Application 的引用。</strong>注释5处的 mApplication 即 LoadedApk 的成员变量 mApplication。来看看注释 3 处Application 是如何创建的（最终调用到如下代码的方法）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/lnstrumentation.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(xxxx)</span></span>{</span><br><span class="line">    Application app = (Application) clazz.newinstance ();</span><br><span class="line">    app.attach(context) ; <span class="comment">//l</span></span><br><span class="line">    <span class="keyword">return</span> app ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注释1处通过反射来创建Application</strong>，并调用其 attach 方法，并且将 ContextImpl 类型的对象传进去：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/Application.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>{</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    mLoadedApk = Contextimpl.getimpl(context).mPackageinfo;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(mBase != <span class="keyword">null</span> ) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException (<span class="string">"Base context already set"</span>);</span><br><span class="line">    }</span><br><span class="line">    mBase = base;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最终，把一路传过来的 ContextImpl 类型的 base 赋值给 Application 的 mBase 。前面讲过，这个歌mBase 是ContextWrapper 的成员变量，因为Application 继承 ContextWrapper ，所以才有这个变量。因此，Application 的attach 方法的作用就是使 Application 可以使用 Context 的方法，这样，Application 才可以用来代表 Application Context。</p>
<h2 id="Application-Context-的获取过程"><a href="#Application-Context-的获取过程" class="headerlink" title="Application Context 的获取过程"></a>Application Context 的获取过程</h2><p>我们通过 getApplicationContext 来获取Application Context，这个方法在 ContextWrapper 中实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/content/ContextWrapper.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">getApplicationContext</span><span class="params">()</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    return mBase.getApplicationContext( )</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从前面我们可知，mBase 指的是 ComtextImpl，具体代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">getApplicationContext</span> <span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (mPackageinfo != <span class="keyword">null</span> ) ? mPackageinfo.getApplication() : mMainThread.getApplication();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果 loadedApk 类型的mPackageinfo 不为 null，则调用其 getApplication 方法，否则调用 ActivityThread 的 getApplication 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"></span><br><span class="line"><span class="function">Application <span class="title">getApplication</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> mApplication ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个 mApplication 应该熟悉，是在前面提到的  LoadedApk 的  makeApplication 方法中注释 5 处被赋值的，是个Application 对象。就这样，我们获取到 Application Context。</p>
<h2 id="Activity-的Context-创建过程"><a href="#Activity-的Context-创建过程" class="headerlink" title="Activity 的Context 创建过程"></a>Activity 的Context 创建过程</h2><p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC5%E7%AB%A0/Activity%E7%9A%84context%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Activity的context创建过程时序图"></p>
<p>应用程序进程的主线程管理类 ActivityThread 会调用内部类 ApplicationThread 的 scheduleLaunchActivity 方法来启动Activity，最终通过 H 类在主线程中处理启动事项，最终调用到 ActivityThread 的 performLaunchActivity 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">perfomLaunchActivity</span><span class="params">(ActivityClientRecord r , Intent customintent)</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);<span class="comment">//l</span></span><br><span class="line">    Activity activity = <span class="keyword">null</span> ;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(cl , <span class="function">component <span class="title">getClassName</span><span class="params">()</span> , r.intent) </span>; <span class="comment">//2</span></span><br><span class="line">        ...</span><br><span class="line">    }<span class="keyword">catch</span>(Exception e){</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(activity != <span class="keyword">null</span>) {</span><br><span class="line">        appContext.<span class="function">setOuterC nte <span class="title">t</span><span class="params">(activity)</span> </span>; <span class="comment">//3</span></span><br><span class="line">        <span class="comment">//4</span></span><br><span class="line">        activity.attach(xxxx,xxxx);</span><br><span class="line">        ...</span><br><span class="line">    }<span class="keyword">catch</span>(Exception e){</span><br><span class="line">        ...</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>在注释2处创建了Activity 的实例，注释1处<strong>通过 createBaseContextForActivity 方法创建 Activity 的 ContextImpl</strong>，并在注释4 处将 ContextImpl 对象传给activity 的attach方法，在注释3处调用了 ContextImpl 的 setOuterContext 方法，将 Activity 的实例赋值给 ContextImpl 的成员变量 mOuterContext ，这样，ContextImpl 也可以访问 Activity 的变量和方法。createBaseContextForActivity 方法中，最终也会调用 ContextWrapper 的 attachBaseContext ，将Activity 中的 ContextImpl 对象赋值给 ContextWrapper 的成员变量 mBase，这样，ContextWrapper 的功能就可以交由 ContextImpl 来处理。</p>
<h2 id="Service-的-Context-创建过程"><a href="#Service-的-Context-创建过程" class="headerlink" title="Service 的 Context 创建过程"></a>Service 的 Context 创建过程</h2><p>Service 的Context 创建过程与 Activity 的Context 创建过程类似，这里先略过，后续有时间再记录。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/28/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC12%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/28/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC12%E7%AB%A0/" class="post-title-link" itemprop="url">第12章：理解ClassLoader</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-28 10:34:00" itemprop="dateCreated datePublished" datetime="2019-11-28T10:34:00+08:00">2019-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-03 21:47:10" itemprop="dateModified" datetime="2019-12-03T21:47:10+08:00">2019-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>热修复和插件化是目前比较热门的技术，想要更好地掌握它们需要先了解ClassLoader。从第11章可知，DVM 和 ART 加载的是dex文件，JVM 加载的是class文件，因此它们的类加载器 ClassLoader 是肯定有区别的。</p>
<h2 id="Java中的ClassLoader"><a href="#Java中的ClassLoader" class="headerlink" title="Java中的ClassLoader"></a>Java中的ClassLoader</h2><p>虚拟机章节提到 <strong>类加载子系统</strong>，它的主要作用就是通过多种类加载器来查找和加载Class文件到Java虚拟机中。Java<strong>系统</strong>中的类加载器主要包括以下：</p>
<ul>
<li>Bootstrap ClassLoader(引导类加载器)：C/C++实现的，用于加载指定的JDK核心类库，比如 java.lang、java.uti等系统类。    </li>
<li>Extensions ClassLoader(拓展类加载器)： Java中的实现类为 ExtClassLoader ，用于加载Java的拓展类，主要包括 $JAVA_HOME/jre/lib/ext 、java.ext.dir 等目录。    </li>
<li>Application ClassLoader(应用程序类加载器)：Java中的实现类为 AppClassLoader，用来加载 1、当前程序的 Classpath 目录 ；2、系统属性 java.class.path指定的目录。    </li>
</ul>
<h3 id="ClassLoader-继承关系"><a href="#ClassLoader-继承关系" class="headerlink" title="ClassLoader 继承关系"></a>ClassLoader 继承关系</h3><p>以下代码可以验证 运行一个Java程序需要用到哪些类加载器：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        ClassLoader loader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        <span class="keyword">while</span> (loader != <span class="keyword">null</span>){</span><br><span class="line">            System.out.println(loader);<span class="comment">//1</span></span><br><span class="line">            loader = loader.getParent();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码可以获得当前类 ClassLoaderTest 的类加载器，接着打印出当前类加载器的父加载器，直到没有父加载器，打印的结果如：</p>
<blockquote>
<p>sun misc Launcher AppClassLoader@75b84c92<br>sun .misc .Launcher$ExtClassLoader@lb6d3586     </p>
</blockquote>
<p>可以看出，<strong>加载 ClassLoaderTest 的加载器是 AppClassLoader</strong>，并且AppClassLoader 的父加载器是 ExtClassLoader。但是这里没有打印出 ExtClassLoader 的父加载器 Bootstrap ClassLoader ，是因为Bootstrap ClassLoader 由 C/C++ 编写，并不是一个Java类，因此我们无法在Java代码中获取。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>所谓的双亲委派模型就是首先判断该Class是否已经加载，如果未加载，则当前加载器委托父加载器进行查找，这样依次地柜，直到委托到最顶层的 Bootstrap ClassLoader，如果Bootstrap ClassLoader 找到了该Class，就直接返回，否则，依次向下查找，如果当前加载器之上的所有加载器都未能加载，则当前加载器自身去查找。</p>
<p>如果要加载一个位于D盘的Class文件，系统所提供的类加载器就不能满足，这时候需要自定义类加载器 CustomClassLoader 继承java.lang.ClassLoader 并覆写findClass方法，加载D盘的Class文件步骤如下：</p>
<ol>
<li>CustomClassLoader 首先从缓存中查找Class文件是否已经加载，已经加载就返回，没有加载就委托给<strong>父加载器(AppClassLoader)</strong>。    </li>
<li>按照双亲委派模型递归。    </li>
<li>一直委托到 Bootstrap ClassLoader ，如果 Bootstrap ClassLoader 也没能加载，则交给子加载器(ExtClassLoader)，以此类推。    </li>
</ol>
<blockquote>
<p>综合以上，ClassLoader的父子关系不是使用继承来实现的，二是使用组合来实现代码复用。</p>
</blockquote>
<p>双亲委派模型的好处：</p>
<ol>
<li>避免重复加载。如果Class已经加载过，就不需要加载，二是直接读取。    </li>
<li>更加安全。如果不使用双亲委派模型，就可以自定义一个String类来替代系统的String类，显然会造成安全隐患。或者自定义一个Object类，有可能会动摇java基础，因为java里面所有类都要继承java的Object(这段是我自己理解添加的)。采用双亲委派模型似的系统的类在Java虚拟机启动时就被加载，也就无法自定义系统类来替代系统。</li>
</ol>
<p>自定义类加载器的代码如下：<br><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC12%E7%AB%A0/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A81.jpeg" alt="自定义类加载器1"><br><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC12%E7%AB%A0/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A82.jpeg" alt="自定义类加载器2"></p>
<h2 id="Android-中的ClassLoader"><a href="#Android-中的ClassLoader" class="headerlink" title="Android 中的ClassLoader"></a>Android 中的ClassLoader</h2><h3 id="ClassLoader-的类型"><a href="#ClassLoader-的类型" class="headerlink" title="ClassLoader 的类型"></a>ClassLoader 的类型</h3><p>Android中系统类加载器也主要包括3种：</p>
<ul>
<li>BootClassLoader： 由Java代码实现，类的访问修饰符是默认的，只有在同一个包中才能访问，用户无法直接调用。Android系统启动时，会使用BootClassLoader 预加载常用类。    </li>
<li>DexClassLoader：可以加在dex文件以及包含dex的压缩文件(apk和jar)，不管加载哪种文件，最终都加载dex文件。    </li>
<li>PathClassLoader：Android使用它来加载系统类和应用程序的类，通常用来加载已经安装的apk的dex文件。</li>
</ul>
<h3 id="ClassLoader的继承关系"><a href="#ClassLoader的继承关系" class="headerlink" title="ClassLoader的继承关系"></a>ClassLoader的继承关系</h3><p>通过前面用于验证java类继承关系的代码，在这里同样可以验证Android中类加载器的继承关系。</p>
<h3 id="ClassLoader-的加载过程"><a href="#ClassLoader-的加载过程" class="headerlink" title="ClassLoader 的加载过程"></a>ClassLoader 的加载过程</h3><p>Android 的 ClassLoader 同样遵循了双亲委派模型，ClassLoader 的加载方法为 loadClass方法，这个方法定义在抽象类 ClassLoader中。ClassLoader的查找流程如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC12%E7%AB%A0/ClassLoader%E7%9A%84%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B.png" alt="ClassLoader的查找流程"></p>
<h3 id="BootClassLoader的创建"><a href="#BootClassLoader的创建" class="headerlink" title="BootClassLoader的创建"></a>BootClassLoader的创建</h3><p>在ZygoteInit的main方法中，调用了Zygote的 preload 方法，preload方法中又调用了 ZygoteInit 的 preloadClasses 方法，preloadClasses用于预加载常用的类，这个预加载属于拿空间换时间的策略。在preloadClasses方法中会创建 BootClassLoader 。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/25/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC4%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/25/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC4%E7%AB%A0/" class="post-title-link" itemprop="url">第4章：四大组件的工作过程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-25 14:09:00" itemprop="dateCreated datePublished" datetime="2019-11-25T14:09:00+08:00">2019-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-09 19:49:06" itemprop="dateModified" datetime="2020-02-09T19:49:06+08:00">2020-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="根Activity的启动过程"><a href="#根Activity的启动过程" class="headerlink" title="根Activity的启动过程"></a>根Activity的启动过程</h2><p>根Activity 是应用程序第一个Activity，相比普通的Activity的启动过程，一般用根Activity 的启动过程来指代应用程序的启动过程，更具有参考意义。根Activity 的启动过程比较复杂，这里分为3个部分来讲：<font color="green">Launcher 请求AMS 过程、AMS 到ApplicaitonThread 的调用过程 以及 ActivityThread 启动Activity</font>。</p>
<h3 id="Launcher-请求AMS-过程"><a href="#Launcher-请求AMS-过程" class="headerlink" title="Launcher 请求AMS 过程"></a>Launcher 请求AMS 过程</h3><p>当我们点击桌面上某个应用的快捷图标时，就会通过Launcher 请求AMS 来启动该应用程序，过程的时序图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/Launcher%E8%B0%83%E7%94%A8AMS%E5%90%AF%E5%8A%A8Activity%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Launcher调用AMS启动Activity时序图"></p>
<p>点击桌面图标，会调用 Launcher 的startActivitySafely方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  packages/apps/Launcher3/src/com/android/launcher3/Launcher.java </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startActivitySafely</span><span class="params">(View v ,Intent intent, Itemlnfo item)</span></span>{</span><br><span class="line">    ...</span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); <span class="comment">//l </span></span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        <span class="keyword">if</span> (xxxx){</span><br><span class="line">            ...</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(user == <span class="keyword">null</span> || user.equals(Process.myUserHandle())){</span><br><span class="line">            startActivity(intent, optsBundle); <span class="comment">//2 </span></span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">catch</span> (ActivityNotFoundExceptionlSecurityException e) {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因为是启动新的应用，所以注释1处将根Activity 在新的任务栈启动，应用启动会执行到注释2处的startActivity 方法，最终会在Activity 中调用  startActivityForResult 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/and oid/app/Activity.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(<span class="meta">@RequiresPermission</span> Intent intent, <span class="keyword">int</span> requestCode, <span class="meta">@Nullable</span> Bundle options)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) {<span class="comment">//1</span></span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">        Instrumentation.ActivityResult ar = minstrumentation.execStartActivity(<span class="keyword">this</span>, mMainThread.getApplicationThread(), mToke,<span class="keyword">this</span>,intent, requestCode , option);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>注释1的mParent 是Activity 类型，表示当前Activity 的父类(个人理解，这里应该说是当前Activity的前一个Activity)，因此mParent == null 成立，最后由 Instrumentation 的execStartActivity方法来执行启动操作。 <strong>Instrumentation 主要用于监控应用程序和系统的交互。</strong>主要代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/android/app/Instrumentation.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who , IBinder contextThread, IBinder token , Activity target, Intent intent ,<span class="keyword">int</span> requestCode ,Bundle options)</span></span>{</span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    intent.migrateExtraStreamToClipData();</span><br><span class="line">    intent.prepareToLeaveProcess(who );</span><br><span class="line">    <span class="keyword">int</span> result = ActivityManager.getService().startActivity(xxx,xxx,xxxx));</span><br><span class="line">    checkStartActivityResult(result, intent);</span><br><span class="line">} <span class="keyword">catch</span> (RemoteException e) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>由代码可知，首先通过 ActivityManager 获取 AMS 的代理对象，接着调用代理对象的 startActivity 方法。AMS 的代理对象是一个 IActivityManager(该类由AIDL在工具编译时自动生成的)对象，这个对象封装了 IBinder 类型的 AMS 的引用。通过一系列进程间通信，最终调用 AMS 的 startActivity 方法。</p>
<h3 id="AMS-到-ApplicationThread-的调用过程"><a href="#AMS-到-ApplicationThread-的调用过程" class="headerlink" title="AMS 到 ApplicationThread 的调用过程"></a>AMS 到 ApplicationThread 的调用过程</h3><p>Launcher 请求进入AMS 后，接着是AMS 到 ApplicationThread 调用流程，时序图如下所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/AMS%E5%88%B0ApplicationThread%E8%B0%83%E7%94%A8.png" alt="Launcher调用AMS启动Activity时序图"></p>
<p>在AMS 的startActivity 会使用 startActivityAsUser 实现功能，并获取UserHandle.getCallingUserld() 即 调用者的UserId 作为参数传入。之后，startActivityAsUser 中会判断调用者进程是否被隔离，如果隔离则抛出<font color="green">SecurityException</font>异常；接着，根据UserId 等参数检查调用者权限，如果没权限也抛出 SecurityException 异常。</p>
<p>AMS 中最终调用ActivityStater 的 startActivityLocked 方法，并且如果有 TaskRecord(代表启动的Activity所在的栈)，则将其也作为参数传入；startActivityLocked 中会收集所有逻辑来决定如何将Intent 和Flags 转换为Activity(生成用于描述Activity 的  ActivityRecord 对象)，并且将Activity 与Task 及 Stack 关联。</p>
<blockquote>
<p>TaskRecord 用于描述一个 Activity 任务栈，Activity 任务栈其实是一个假想模型，并不真实存在。</p>
</blockquote>
<p>最终调用到 ActivityStackSupervisor 的 startSpecificActivityLocked 方法时，会判断要启动的Activity 所在的应用程序进程是否已经运行，已经运行则调用 realStartActivityLocked 方法，并传入代表应用程序进程的 ProcessRecord。之后会调用 ApplicationThread 的 scheduleLaunchActivity 方法。当前代码逻辑运行在AMS所在进程(即SystemServer进程)中，通过 ApplicationThread 进程间通信，将程序执行到应用程序进程，<strong>ApplicationThread是AMS 进程与应用程序进程的通信桥梁</strong>，如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/AMS%E4%B8%8E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.png" alt="AMS与应用程序进程通信"></p>
<h3 id="ActivityThread-启动Activity-的过程"><a href="#ActivityThread-启动Activity-的过程" class="headerlink" title="ActivityThread 启动Activity 的过程"></a>ActivityThread 启动Activity 的过程</h3><p>由前面的知识可知，目前的代码逻辑已经运行到应用程序进程中，先查看下ActivityThread 启动Activity 的时序图：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/ActivityThread%E5%90%AF%E5%8A%A8Activity%E8%BF%87%E7%A8%8B%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="ActivityThread启动Activity过程的时序图"></p>
<p>ApplicationThread 是 ActivityThread 的内部类，前面讲过应用程序进程创建完成后，会运行代表主线程的实例 ActivityThread 。接着上一节的内容查看 ApplicationThread.scheduleLaunchActivity 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(xxx,xx,xxx)</span> </span>{<span class="comment">//参数太多，这里省略了参数</span></span><br><span class="line">    updateProcessState(procState ,<span class="keyword">false</span>);</span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line">    r.token = token;</span><br><span class="line">    r.ident ＝ident;</span><br><span class="line">    r.intent = intent;</span><br><span class="line">    r.referrer = referrer;</span><br><span class="line">    ...</span><br><span class="line">    updatePendingCoηfiguration (curConfig);</span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY ,r);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在把启动Activity 必要的数据封装成 ActivityClientRecord 后，通过 sendMessage 方法将封装的数据以 H.LAUNCH_ACTIVITY 类型发送了出去，这里可以大胆地猜测sendMessage方法是通过handler的 sendMessage 执行的，果不其然,sendMessage 有多个重载方法，最终调用到如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what ,Object obj ,<span class="keyword">int</span> argl ,<span class="keyword">int</span> arg2 ,<span class="keyword">boolean</span> async)</span></span>{</span><br><span class="line">    Message msg = <span class="function">Message <span class="title">obta</span> <span class="params">()</span></span>;</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.ob]= obj;</span><br><span class="line">    msg.argl = argl;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) {</span><br><span class="line">        msg .setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    }</span><br><span class="line">    mH.sendMessage(msg);</span><br></pre></td></tr></tbody></table></figure>

<p>这里的mH指的是 ActivityThread 的内部类 H，前面讲过，这个H是集成Handler，是应用进程中主线程的消息管理类，<strong>因为ApplicationThread 是一个Binder，它的调用逻辑都运行在Binder 线程池中，所以这里需要使用H将代码的逻辑切换到主线程中。</strong>这样一来，我们只需要看 H 的handleMessage 方法即可知道具体的执行操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span> <span class="params">(Message msg )</span> </span>{</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) {</span><br><span class="line">        <span class="keyword">case</span> LAUNCH_ACTIVITY:</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER，<span class="string">"activityStart"</span>);</span><br><span class="line">        <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;<span class="comment">//1</span></span><br><span class="line">        r.packageinfo = getPackageinfoNoCheck(r.activityinfo.applicationinfo, r.compatlnfo); <span class="comment">//2</span></span><br><span class="line">        handleLaunchActivity(r,<span class="keyword">null</span> ,<span class="string">"LAUNCH ACTIVITY"</span>); <span class="comment">//3</span></span><br><span class="line">        Trace.traceEnd (Trace . TRACE TAG ACTIVITY MANAGER);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>在注释1处将传过来的 msg 的成员变量 obj 还原成 ActivityClientRecord，注释2获得LoadApk 类型的对象。<strong>应用程序进程要启动Activity时需要将该Activity 所属的APK 加载进来，而LoadApk 就是用来描述已经加载的APK 文件的。</strong>注释3处调用 handleLaunchActivity 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r ,Intent customintent, String reason)</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">    WindowManagerGlobal.initialize ();</span><br><span class="line">    <span class="comment">//启动 Activity</span></span><br><span class="line">    Activity a = performLaunchActivity(r, customintent);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span>(a != <span class="keyword">null</span>){</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//将 Activity 的状态置为 Resume</span></span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,!r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);<span class="comment">//2</span></span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//停止 Activity 启动</span></span><br><span class="line">        <span class="function">ActivityManager getServ <span class="title">ce</span> <span class="params">()</span> .<span class="title">finishActivity</span><span class="params">(r . token , Activity . RESULT CANCELED , <span class="keyword">null</span> , Activity . DONT_FINISH_TASK_WITH_ACTIVITY)</span> </span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注释1处performLaunchActivity 方法启动了 Activity，注释2处将Activity的状态设置为 Resume ，如果该Activity 为null，则会通知AMS 停止启动Activity。我们来看看 performLaunchActivity 方法做了什么：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r , Intent customintent)</span> </span>{</span><br><span class="line">    <span class="comment">//获取 Activityinfo</span></span><br><span class="line">    Activityinfo ainfo = r.activityinfo;<span class="comment">//l</span></span><br><span class="line">    <span class="keyword">if</span> (r.packageinfo == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">//获取 APK 文件的描述类 LoadedApk</span></span><br><span class="line">        r.packageinfo = getPackageinfo(ainfo.applicationinfo ,r.compatinfo,Context.CONTEXT_INCLUDE_CODE);<span class="comment">//2</span></span><br><span class="line">    }</span><br><span class="line">    ComponentName component= r.intent.getComponent();<span class="comment">//3</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建要启动 Activity 的上下文环境</span></span><br><span class="line">    Contextlmpl appContext = createBaseContextForActivity(r) ; <span class="comment">//4</span></span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        java.lang .ClassLoader cl= appContext.getClassLoader();</span><br><span class="line">        <span class="comment">//用类加载器来创建该 Activity 的实例</span></span><br><span class="line">        activity = <span class="function">mInstrumentation <span class="title">newActivity</span><span class="params">(cl ,component.getClassName()</span> ,r.intent) </span>;<span class="comment">//5</span></span><br><span class="line">        ...</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//创建 Application</span></span><br><span class="line">        Application app = r.packageinfo.makeApplication(<span class="keyword">false</span> ,minstrumentation); <span class="comment">//6</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//初始化Activity，参数太多，省略</span></span><br><span class="line">            activity.attach(....) ;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) {</span><br><span class="line">                minstrumentation.callActivityOnCreate(activity,r.state ,r.persistentState); <span class="comment">//8</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                 <span class="function">minstrumentat on <span class="title">callActivityOnCreate</span><span class="params">(activ ty r .state)</span> </span>;</span><br><span class="line">            }</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">        r.paused = <span class="keyword">true</span> ;</span><br><span class="line">        mActivities.put(r.token,r);</span><br><span class="line">    } <span class="keyword">catch</span> (SuperNotCalledException e) {</span><br><span class="line">        <span class="keyword">throw</span> e ;</span><br><span class="line">    }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br></pre></td></tr></tbody></table></figure>

<p>注释1处获取 Activityinfo，用于存储AndroidManifest 以及 代码中设置的Activity 和 Receiver 节点的信息，比如Activity 的theme 和launchMode 。注释3中获取要启动的Activity 的 <strong>ComponentName 对象，该对象中保存了该Activity 的包名和类名</strong>。注释4中启动了Activity的上下文，注释5根据 Activity 的类名，用类加载器创建该 Activity 的实例。之后，注释6中创建了Application ，并且会调用 Application 的 onCreate方法。注释7中调用 Activity 的attach 方法初始化Activity，并且创建Window 对象(PhoneWindow)与Activity 自身关联。注释8中正式启动Activity，并调用Activity 的onCreate 方法。</p>
<p>至此，根Activity 就启动了，即应用程序启动了。</p>
<h3 id="根Activity-启动过程中涉及的进程"><a href="#根Activity-启动过程中涉及的进程" class="headerlink" title="根Activity 启动过程中涉及的进程"></a>根Activity 启动过程中涉及的进程</h3><p>根Activity 启动过程中涉及的4个进程之间关系如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/%E6%A0%B9Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png" alt="根Activity启动过程中涉及的进程关系"></p>
<p>首先Launcher 进程向 AMS 请求创建根 Activity ，AMS 会判断根Activity 所需要的应用程序进程是否存在，不存在就请求 Zygote 进程创建应用程序进程；之后，AMS 请求创建根Activity。上图中步骤 2 采用Socket 通信，步骤 1 和4采用Binder 通信。</p>
<p>读完书本，虽然各个点清晰，但是未能完整总结，<strong>以下 桌面点击图标 启动流程总结参考自<a target="_blank" rel="noopener" href="http://www.androidos.net.cn/book/android-road/android/advance/app-launch.html">他人博客</a></strong></p>
<ol>
<li>点击桌面图标，Launcher 采用Binder IPC 方式向system_server 发起startActivity 请求。    </li>
<li>system_server 进程接收到请求后，向 zygote 进程发送创建进程请求。    </li>
<li>zygote 进程fork 出新进程，即App进程。    </li>
<li>App 进程通过 Binder IPC 向 system_server 发起 attachApplication 请求。     </li>
<li>system_server收到请求做一系列准备后，通过 Binder IPC 向App 进程发送 scheduleLauncherActivity请求。    </li>
<li>App 进程的Binder 线程(ApplicationThread)收到请求后，通过Handler 向主线程发送 LAUNCH_ACTIVITY 消息。    </li>
<li>主线程收到Message 后，通过反射机制创建目标Activity ，并回调Activity.onCreate 等方法。    </li>
<li>至此，App启动，开始Activity 生命周期。</li>
</ol>
<p>这个过程示意图如下所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Activity启动流程图"></p>
<h2 id="Service-启动过程"><a href="#Service-启动过程" class="headerlink" title="Service 启动过程"></a>Service 启动过程</h2><p>Service 的启动过程和根Activity 的启动过程有部分相似知识点。Service 的启动过程可以分为两个部分讲解：分别是ContextImpl 到ActivityManageService 的调用过程，以及 ActivityThread 启动 Service。</p>
<h3 id="ContextImpl-到-AMS-的调用过程"><a href="#ContextImpl-到-AMS-的调用过程" class="headerlink" title="ContextImpl 到 AMS 的调用过程"></a>ContextImpl 到 AMS 的调用过程</h3><p>首先上时序图：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/ContextImpl%E5%88%B0AMS%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="ContextImpl到AMS的调用过程"></p>
<p>调用startService方法启动service，这个方法在 ContextWrapper 中实现</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/24/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/24/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：应用程序进程启动过程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-24 10:22:00" itemprop="dateCreated datePublished" datetime="2019-11-24T10:22:00+08:00">2019-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-03 21:29:50" itemprop="dateModified" datetime="2019-12-03T21:29:50+08:00">2019-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>AMS启动一个应用程序首先要保证该应用程序的进程已经启动，如果应用程序进程还不存在，则请求 Zygote 进程启动进程。</p>
<p>从前一章内容可知，在Zygote 的Java 框架层会创建Server 端的Socket，用于等待AMS 请求Zygote 创建新的应用程序进程。Zygote 通过fork自身即可创建应用程序进程，这个进程会包含虚拟机实例，并且会创建Binder线程池和消息循环。</p>
<p>本章学习应用程序进程的启动，注意，是应用程序进程而不是应用程序的启动过程。</p>
<h2 id="应用程序进程启动过程介绍"><a href="#应用程序进程启动过程介绍" class="headerlink" title="应用程序进程启动过程介绍"></a>应用程序进程启动过程介绍</h2><p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC3%E7%AB%A0/AMS%E5%8F%91%E9%80%81%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.jpeg" alt="AMS发送启动应用程序进程请求过程的时序图"></p>
<p>AMS 通过调用  startProcessLocked 向 Zygote 进程发送请求， 主要代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="params"><span class="function">String hostingNameStr, String abiOverride ,String entryPoint ,String [] entryPointArgs)</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取要创建的应用程序进程的用户 ID</span></span><br><span class="line">    <span class="keyword">int</span> uid = app.uid; <span class="comment">//1 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> [] gids = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">if</span> (!app.isolated) { </span><br><span class="line">        <span class="comment">//2  gids创建和赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="function">ArrayUtils <span class="title">isEmpty</span><span class="params">(permGids)</span>)</span>{</span><br><span class="line">            gids =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; </span><br><span class="line">        }<span class="keyword">else</span> { </span><br><span class="line">            gids = <span class="keyword">new</span> <span class="keyword">int</span>[permGids.leng + <span class="number">3</span>] ; </span><br><span class="line">            System.arraycopy(permGids, <span class="number">0</span>, gids, <span class="number">3</span>, permGids.length) ; </span><br><span class="line">            gids[O] = UserHandle.getSharedAppGid(UserHandle.getAppid(uid)); </span><br><span class="line">            gids[<span class="number">1</span>] = UserHandle.getCacheAppGid(UserHandle .getAppid(uid)) ; </span><br><span class="line">            gids[<span class="number">2</span>] = UserHandle.getUserGid{UserHandle.getUserid(uid)); </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (entryPoint = <span class="keyword">null</span>) entryPoint = <span class="string">"android.app.ActivityThread"</span>;<span class="comment">//3</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//启动应用程序进程,这里省略不重要的参数</span></span><br><span class="line">    startResult = Process.start(entryPoint,xxx,uid, xxx,gids,xxx,xxx);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>上述代码<strong>首先得到应用程序进程的用户ID</strong>，之后创建用户组ID 并且赋值，在注释3处判断 entryPoint 为null就赋值 “android.app.ActivityThread”，<font color="#008000">这个值就是应用程序进程主线程的类名</font>。在最终调用 Process.start 创建进程时，会将进程的用户ID和用户组ID传入。</p>
<p>Process.start会将实现交给 ZygoteProcess(<strong>ZygoteProcess用于保持与Zygote进程的通信状态</strong>)的start 方法处理，其中首先会执行 openZygoteSocketifNeeded  方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed ()) { </span><br><span class="line"><span class="keyword">try</span> { </span><br><span class="line">    <span class="comment">//与 Zygote 进程建立 Socket 连接</span></span><br><span class="line">    primaryZygoteState = ZygoteState.connect(mSocket);<span class="comment">//1</span></span><br><span class="line">} <span class="keyword">catch</span> (IOException ioe} { </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx (<span class="string">"Error connecting to primary zygote"</span>， ioe)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//连接 Zygote 主模式返回的 ZygoteState 是否与启动应用程序进程所需要的ABI匹配</span></span><br><span class="line"><span class="keyword">if</span> (primaryZygotestate.matches (abi)) {<span class="comment">//2 </span></span><br><span class="line">    <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">／／如果不匹配，则尝试连接 Zygote 辅模式</span><br><span class="line"><span class="keyword">if</span> (secondaryZygoteState ==<span class="keyword">null</span> || secondaryZygoteState.isClosed()) { </span><br><span class="line"><span class="keyword">try</span> { </span><br><span class="line">    secondaryZygoteState = ZygoteState.connect(mSecondarySocket);<span class="comment">//3</span></span><br><span class="line">} <span class="keyword">catch</span> (IOException ioe) { </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx (<span class="string">"Error connecting to secondary zygote"</span>, ioe) ; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">／／连接 Zygote 辅模式返回的 ZygoteState 是否与启动应用程序进程所需要的 ABI 匹配</span><br><span class="line"><span class="keyword">if</span> (secondaryZygoteState.matches(abi)) {<span class="comment">//4 </span></span><br><span class="line">    <span class="keyword">return</span> secondaryZygoteState; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx (<span class="string">"Unsupported zygote ABI :"</span> + abi); </span><br></pre></td></tr></tbody></table></figure>

<p>前面章节提到Zygote的main方法中会创建name为 “zygote” 的server端Socket，注释1就是与Zygote进程建立Socket 连接(name为”zygote”)，并得到 ZygoteState 对象primaryZygoteState；注释2处如果primaryZygoteState 与启动应用程序所需要的 ABI 不匹配，则在注释3处连接name为 “zygote_secondary” 的Socket。如果辅模式返回的 ZygoteState 与进程所需的ABI也不匹配，就抛出异常。</p>
<p>通过 openZygoteSocketifNeeded 获取ZygoteState后，将其作为参数调用 ZygoteProcess的  ZygoteSendArgsAndGetResult 方法 获取Process.ProcessStartResult。</p>
<h3 id="Zygote-接收请求并创建应用程序进程"><a href="#Zygote-接收请求并创建应用程序进程" class="headerlink" title="Zygote 接收请求并创建应用程序进程"></a>Zygote 接收请求并创建应用程序进程</h3><p>执行完以上步骤后，继续执行 argsForZygote 方法即可让Zygote 收到创建新的应用程序进程的请求。Zygote 接收请求并创建应用程序进程的时序图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC3%E7%AB%A0/Zygote%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Zygote接收请求并创建应用程序进程的时序图"></p>
<p>由前面章节我们知道，Zygote 中的Server Socket 的runSelectLoop 方法一直在等待 AMS请求创建新的应用程序进程，runSelectLoop 中是通过 runOnce 来创建进程的，runOnce最终调用到 Zygote 的 forkAndSpecialize 方法创建应用程序进程，并返回pid。forkAndSpecialize 通过fork 当前进程来创建一个子进程。此后，便会在应用程序进程中创建 Binder 线程池，*<em>进一步通过反射 ActivityThread 类的main方法调用，令应用程序进程进入了ActivityThread 的main方法中。此时，应用程序进程创建完毕，并且运行了主线程管理类 ActivityThread *</em>。</p>
<blockquote>
<p>如果pid为0，说明当前代码运行在新创建的子进程中。</p>
</blockquote>
<h3 id="Binder-线程池启动过程"><a href="#Binder-线程池启动过程" class="headerlink" title="Binder 线程池启动过程"></a>Binder 线程池启动过程</h3><p>程序中会检查代码，确保Binder线程池只会被启动一次。</p>
<h3 id="消息循环创建过程"><a href="#消息循环创建过程" class="headerlink" title="消息循环创建过程"></a>消息循环创建过程</h3><p>通过反射方式 invok 执行 ActivityThread 的main方法时，会执行一系列主线程的工作，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{ </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建主线程 Looper</span></span><br><span class="line">    Looper.prepareMainLooper(); <span class="comment">//1 </span></span><br><span class="line">    ActivityThread thread= <span class="keyword">new</span> ActivityThread(); <span class="comment">//2 </span></span><br><span class="line">    thread.attach(<span class="keyword">false</span>) ; </span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span> ) {<span class="comment">//3 </span></span><br><span class="line">    <span class="comment">//创建主线程 H 类</span></span><br><span class="line">    sMainThreadHandler = thread . getHandler ();<span class="comment">//4 </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) { </span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span> LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>）；</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER) ; </span><br><span class="line">    <span class="comment">//Looper 开始工作</span></span><br><span class="line">    Looper.loop (); <span class="comment">//5 </span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ActivityThread类用于管理当前应用程序进程的主线程，上述代码中创建了主线程的消息循环Looper，其中的内部类 H 继承 Handler，在注释 5 处调用Looper.loop ，即使得Looper 开始处理消息，可见，系统在应用程序进程启动完成后，就会创建消息循环。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/23/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/23/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">面试题-设计模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-23 21:40:00" itemprop="dateCreated datePublished" datetime="2019-11-23T21:40:00+08:00">2019-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-14 16:28:00" itemprop="dateModified" datetime="2021-03-14T16:28:00+08:00">2021-03-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1、mvc、mvp、mvvm"><a href="#1、mvc、mvp、mvvm" class="headerlink" title="1、mvc、mvp、mvvm"></a>1、mvc、mvp、mvvm</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="mvc"><a href="#mvc" class="headerlink" title="mvc"></a>mvc</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvc.png" alt="mvc示意图"></p>
<p><strong>特征：</strong></p>
<ul>
<li>view 接收用户的输入，并且可以通知Controller 更改Model 层数据，如果没有涉及逻辑，还可以直接通知Model 更改数据。    </li>
<li>需要ui变化，但是没有涉及业务数据，直接调用controller 即可(比如用户选择使用用户名/手机号登录)    </li>
<li>model 数据变化时，若需要修改ui，需要通过Controller 来通知更新。</li>
</ul>
<p><strong>在Android中存在问题：</strong></p>
<ul>
<li>Activity 的职责不明，并且臃肿。Activity 除了要展示view (加载view，接收用户操作)，还要承担部分逻辑处理(比如生命周期回调)    </li>
</ul>
<h3 id="mvp"><a href="#mvp" class="headerlink" title="mvp"></a>mvp</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvp.png" alt="mvp示意图"></p>
<p><strong>特点</strong>:</p>
<ul>
<li>View 层接收输入</li>
<li>Presenter 处理业务逻辑，View 与 Model 之间必须经过 Presenter</li>
</ul>
<p><strong>优点(相对MVC)：</strong></p>
<ul>
<li>避免了View、Model 直接联系，更加解耦，通过Presenter 实现两者之间的沟通    </li>
<li>Activity 更加简明，仅仅负责UI上的工作    </li>
</ul>
<h3 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvvm.png" alt="mvvm示意图"></p>
<p>可能主要关注view 通过databinding 与 viewmodel 相互绑定。</p>
<h3 id="mvc-与-mvp-的区别"><a href="#mvc-与-mvp-的区别" class="headerlink" title="mvc 与 mvp 的区别"></a>mvc 与 mvp 的区别</h3><ul>
<li>在mvc 中 Activity 具有 view 的功能，并且兼任部分 controller 功能，而mvp 中Activity 是纯粹的view    </li>
<li>mvc 中view 和model 可以直接沟通(没有逻辑情况下，view直接更改model，当然，有逻辑改动的情况下经过controller)，而mvp中二者沟通必须经过presenter。    </li>
</ul>
</details>

<blockquote>
<p>以上内容参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/100070713">carson_ho的博客</a></p>
</blockquote>
<h3 id="2、实现一个线程安全的单例模式"><a href="#2、实现一个线程安全的单例模式" class="headerlink" title="2、实现一个线程安全的单例模式"></a>2、实现一个线程安全的单例模式</h3><h3 id="3、观察者模式和回调有什么区别？"><a href="#3、观察者模式和回调有什么区别？" class="headerlink" title="3、观察者模式和回调有什么区别？"></a>3、观察者模式和回调有什么区别？</h3></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/23/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/23/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="post-title-link" itemprop="url">面试题-虚拟机知识</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-23 21:40:00" itemprop="dateCreated datePublished" datetime="2019-11-23T21:40:00+08:00">2019-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-12 09:50:33" itemprop="dateModified" datetime="2020-07-12T09:50:33+08:00">2020-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="1、对象的内存布局"><a href="#1、对象的内存布局" class="headerlink" title="1、对象的内存布局"></a>1、对象的内存布局</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>分为3个区域：对象头、实例数据 以及 对齐填充</p>
<p><strong>对象头：</strong>包括两部分信息，第一部分：对象自身运行时数据，如hashcode、GC年龄分代、锁状态标志位，官方称为”Mark Word”。第二部分：类型指针，虚拟机通过这个指针确定对象是哪个类的实例。</p>
<p><strong>实例数据：</strong>对象真正存储的有效信息。</p>
<p><strong>对齐填充：</strong>比如HotSpot vm 要求对象起始地址必须是8的整数倍。对齐填充不是必需的。</p>
<p>以下是句柄访问 时，内存布局关系图：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="内存布局关系图"></p>
<blockquote>
<p>以上内容参考自： <a target="_blank" rel="noopener" href="http://www.androidos.net.cn/book/android-road/java/virtual-machine/object.html">对象创建与定位</a></p>
</blockquote>
</details>

<h2 id="2、垃圾收集算法"><a href="#2、垃圾收集算法" class="headerlink" title="2、垃圾收集算法"></a>2、垃圾收集算法</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>标记-清除 算法。不足：1、标记清除效率不高。2、产生内存碎片。    </li>
<li>复制算法。为了解决标记清除的效率问题，将内存划分为大小相等的两块，每次使用一块。不足：可用内存缩小为原来一半。    </li>
<li>标记-整理。不足：复制存货对象耗时过多。    </li>
<li>分代收集算法。 新生代使用复制算法；老年代采用“标记-清除” 或者 “标记-整理”算法。</li>
</ul>
</details>

<blockquote>
<p>以上内容参考自： <a target="_blank" rel="noopener" href="http://www.androidos.net.cn/book/android-road/java/virtual-machine/Garbage-Collector.html">垃圾回收算法</a></p>
</blockquote>
<h2 id="3、说说四大引用？强，软，弱，虚，并说明下合适GC"><a href="#3、说说四大引用？强，软，弱，虚，并说明下合适GC" class="headerlink" title="3、说说四大引用？强，软，弱，虚，并说明下合适GC"></a>3、说说四大引用？强，软，弱，虚，并说明下合适GC</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。</p>
</blockquote>
<blockquote>
<p>软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，只有在内存不足的时候 JVM 才会回收该对象。这一点可以很好地用来解决 OOM 的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>
</blockquote>
<blockquote>
<p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p>
</blockquote>
<blockquote>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。要注意的是，虚引用必须和引用队列关联使用.</p>
</blockquote>
</details>

<h2 id="4、Android中内存分配的执行流程"><a href="#4、Android中内存分配的执行流程" class="headerlink" title="4、Android中内存分配的执行流程"></a>4、Android中内存分配的执行流程</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="铺垫"><a href="#铺垫" class="headerlink" title="铺垫"></a>铺垫</h3><p>Dalvik 虚拟机的Java堆的底层实现是一块共享匿名内存(Ashmem)，并且将其抽象为C库的一个 mspace ，于是，Dalvik 虚拟机就可以利用 C 库里面的 dlmalloc 内存分配器来解决内存碎片问题(这是个成熟的内存分配器，<strong>可以很好地解决内存碎片的问题</strong>)</p>
<h3 id="Android中内存分配的执行流程："><a href="#Android中内存分配的执行流程：" class="headerlink" title="Android中内存分配的执行流程："></a>Android中内存分配的执行流程：</h3><p>流程图如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B.png" alt="dalvik虚拟机内存分配流程"></p>
<ol>
<li>尝试在Java堆上分配指定大小的内存，如果内存充足，就直接分配成功。(不改变java堆当前大小的前提下进行内存分配，属于轻量级的内存分配)      </li>
<li>如果分配失败，就执行一次GC(如果此时有GC在运行，则等待这次GC执行完成)，GC 时设置参数false标记<strong>不要</strong>回收软引用的对象。        </li>
<li>GC 完成后，再次尝试轻量级内存分配操作，如果内存充足，就分配成功了               </li>
<li>如果上一步内存分配失败，就考虑将Java堆的当前大小设置为Dalvik 虚拟机启动时指定的Java堆最大值，再进行内存分配         </li>
<li>如果内存充足，就完成内存的分配       </li>
<li>如果上一步还是分配失败，就再次调用GC，并将参数标记为true，<strong>表示要回收软引用的对象</strong>           </li>
<li>GC完毕后，再次尝试分配，成功就返回；不成功也就抛出OOM了       </li>
</ol>
<blockquote>
<p>以上内容参考自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/luoshengyang/article/details/41688319">老罗的博客</a></p>
</blockquote>
</details>

<h2 id="5、Android-GC-流程"><a href="#5、Android-GC-流程" class="headerlink" title="5、Android GC 流程"></a>5、Android GC 流程</h2><h3 id="Art-虚拟机GC过程"><a href="#Art-虚拟机GC过程" class="headerlink" title="Art 虚拟机GC过程"></a>Art 虚拟机GC过程</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E8%99%9A%E6%8B%9F%E6%9C%BA/Art%E7%9A%84gc%E6%B5%81%E7%A8%8B.jpg" alt="Art的gc流程"></p>
<p>由图可知，非并行GC的过程如下所示：</p>
<ol>
<li>挂起所有的ART运行时线程。      </li>
<li>调用子类实现的成员函数MarkingPhase执行GC标记阶段。          </li>
<li>调用子类实现的成员函数ReclaimPhase执行GC回收阶段。       </li>
<li>恢复第2步挂起的ART运行时线程。          </li>
</ol>
<p>并行GC的过程如下所示：</p>
<ol>
<li>获取用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数MarkingPhase执行GC并行标记阶段。</li>
<li>释放用于访问Java堆的锁。</li>
<li>挂起所有的ART运行时线程。</li>
<li>调用子类实现的成员函数HandleDirtyObjectsPhase处理在GC并行标记阶段被修改的对象。。</li>
<li>恢复第4步挂起的ART运行时线程。</li>
<li>重复第5到第7步，直到所有在GC并行阶段被修改的对象都处理完成。</li>
<li>获取用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数ReclaimPhase执行GC回收阶段。</li>
<li>释放用于访问Java堆的锁。</li>
</ol>
<p>从上面的分析就可以看出，并行GC和非并行GC的区别在于：</p>
<ol>
<li>非并行GC的标记阶段和回收阶段是在挂住所有的ART运行时线程的前提下进行的，因此，只需要执行一次标记。         </li>
<li>并行GC的标记阶段只锁住了Java堆，因此它不能阻止那些不是正在分配对象的ART运行时线程同时运行，而这些同进运行的ART运行时线程可能会引用了一些在之前的标记阶段没有被标记的对象。如果不对这些对象进行重新标记的话，那么就会导致它们被GC回收，造成错误。因此，与非并行GC相比，并行GC多了一个处理脏对象的阶段。所谓的脏对象就是我们前面说的在GC标记阶段同时运行的ART运行时线程访问或者修改过的对象。        </li>
<li>并行GC并不是自始至终都是并行的，例如，处理脏对象的阶段就是需要挂起除GC线程以外的其它ART运行时线程，这样才可以保证标记阶段可以结束。         </li>
</ol>
</details>


<h3 id="Dalvik-虚拟机垃圾收集过程"><a href="#Dalvik-虚拟机垃圾收集过程" class="headerlink" title="Dalvik 虚拟机垃圾收集过程"></a>Dalvik 虚拟机垃圾收集过程</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Dalvik 虚拟机使用 Mark-Sweep 算法来进行垃圾收集<br>Dalvik 执行GC 时会有一些选项：</p>
<ul>
<li>isPartial，为true 时，表示仅仅回收Active 堆的垃圾；为false时，表示同时回收Active 堆和Zygote 堆的垃圾    </li>
<li>isConcurrent：为true时，表示执行并行GC，false时，表示非并行GC    </li>
<li>doPreserve：为true的时候，表示不回收软引用的对象；false的时候，表示回收软引用对象<br>Dalvik在如下几种情况会触发GC：</li>
<li>分配对象时，内存不足触发GC    </li>
<li>已经分配的内存达到一定阈值时触发GC    </li>
<li>调用 System.gc 、VMRuntime.gc 或者收到信号触发 GC    </li>
<li>准备抛出 OOM 前而最后进行的 GC<br>GC线程在空闲达到一定时间后，会调用函数对Java堆进行裁剪，将一些没有用到的内存交还给内核。<br>dalvik 的GC 流程(并行和非并行情况)如下图所示：<br><img src="/assets/%E9%9D%A2%E8%AF%95/java%E8%99%9A%E6%8B%9F%E6%9C%BA/dalvik%E7%9A%84gc%E6%B5%81%E7%A8%8B.jpg" alt="dalvik虚拟机gc流程"></li>
</ul>
<h3 id="哪些对象可以做-GC-Root"><a href="#哪些对象可以做-GC-Root" class="headerlink" title="哪些对象可以做 GC Root"></a>哪些对象可以做 GC Root</h3><ul>
<li>虚拟机栈引用的对象    </li>
<li>本地方法栈引用的对象     </li>
<li>方法区中类静态属性引用的对象     </li>
<li>方法区中常量引用的对象        </li>
<li>Dalvik 虚拟机内部创建的部分异常对象      </li>
<li>Dalvik 虚拟机内部创建的原子类     </li>
<li>注册在调试器的对象</li>
</ul>
</details>

<blockquote>
<p>以上内容参考自以上内容参考自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Luoshengyang/article/details/41822747?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158968621519724843340084%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=158968621519724843340084&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v25-6-41822747.nonecase&amp;utm_term=dalvik">罗升阳的博客</a>  、 <a target="_blank" rel="noopener" href="https://blog.csdn.net/luoshengyang/article/details/42555483">老罗的博客</a></p>
</blockquote>
<h2 id="6、如何理解Java类加载机制"><a href="#6、如何理解Java类加载机制" class="headerlink" title="6、如何理解Java类加载机制"></a>6、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483903&amp;idx=1&amp;sn=c20d3172052bd7db9a1ad6a95f112bc9&amp;chksm=96cda0b2a1ba29a4cc9912cb1bf8a955f97ee45a7b8db48e384f1694ddbabbd4d5e7fa90f880&amp;scene=21#wechat_redirect">如何理解Java类加载机制</a></h2></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2019/11/23/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC11%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/23/%E4%B9%A6-Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC11%E7%AB%A0/" class="post-title-link" itemprop="url">第11章：Dalvik 和 ART</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-11-23 10:30:00 / 修改时间：11:00:25" itemprop="dateCreated datePublished" datetime="2019-11-23T10:30:00+08:00">2019-11-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Dalvik虚拟机"><a href="#Dalvik虚拟机" class="headerlink" title="Dalvik虚拟机"></a>Dalvik虚拟机</h2><p>Dalvik虚拟机 简称 DVM，第10章提到，它不是一个 jvm，主要原因是它没有遵循jvm规范实现，二者的主要区别有：</p>
<ul>
<li>基于的架构不同</li>
</ul>
<blockquote>
<p>JVM 基于栈，DVM 基于寄存器。基于栈意味着需要去栈中读写数据，所需要的指令更多，并且速度更慢，对于性能优先的移动设备，显然是不合适的。</p>
</blockquote>
<ul>
<li>执行的字节码不同</li>
</ul>
<blockquote>
<p>在Java SE 程序中，Java 类被编译成一个或者多个.class 文件，并被打包成 jar 文件，之后JVM 会通过相应的 .class 和 jar 文件获取相应的字节码；而DVM 会用dx工具将所有的 .class 文件转换为一个 .dex 文件，然后DVM 从该 .dex 文件中读取指令和数据。<br>.jar文件里面包含多个.class 文件，每个.class文件包含了该类的常量池、类信息、属性等，当JVM 加载.jar文件的时候，会加载里面所有的.class文件，JVM 这种加载方式很慢(首先就是很多io操作)，对于内存有限的移动设备并不合适；而.dex文件将所有的.class里面所包含的信息全部整合到一块了，这样再加载就减少了I/O操作，加快查找速度；并且，相对Android而言，.class中有许多冗余信息，dex工具会去掉冗余信息。</p>
</blockquote>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC11%E7%AB%A0/dalvik%E4%B8%8Ejvm%E6%89%A7%E8%A1%8C%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="DVM与JVM执行的字节码不同"></p>
<ul>
<li>DVM 允许在有限的内存中同时运行多个进程</li>
</ul>
<blockquote>
<p>在Android中，每个应用都运行在一个DVM中，每个DVM 实例都运行在一个独立的进程中，这样，某一个虚拟机崩溃的时候不会导致其他app也关闭。</p>
</blockquote>
<ul>
<li>DVM 由Zygote创建和初始化</li>
</ul>
<blockquote>
<p>在第2章有介绍<strong>Zygote，它是一个DVM进程</strong>，当系统需要创建一个应用程序时，Zygote就会fork自身，快速地创建和初始化一个DVM实例。对于一些只读的库，所有的DVM实例都会和Zygote共享一块内存区域，节省内存开销。</p>
</blockquote>
<ul>
<li>DVM 有共享机制</li>
</ul>
<blockquote>
<p>DVM 的共享机制可以使<strong>不同应用之间在运行时可以共享相同的类</strong>，这带来更高的效率；而JVM不具有这种机制，不同的程序，打包以后的程序都是彼此独立的，即便它们在包里使用了同样的类，运行时也是单独加载和运行的。</p>
</blockquote>
<h3 id="DVM-运行时堆"><a href="#DVM-运行时堆" class="headerlink" title="DVM 运行时堆"></a>DVM 运行时堆</h3><p>DVM运行时堆使用标记-清除算法进行GC，它由两个Space以及多个辅助数据结构组成，两个Space分别是：Zygote Space(Zygote Heap) 和 Allocation Space(Active Heap)，前者用于管理Zygote进程在启动过程中预加载和创建的对象，并且Zygote Space不会触发GC，Zygote 进程和应用进程之间会共享Zygote Space。在Zygote 进程fork第一个子进程前，会把Zygote Space 分为两部分，原来已经被使用的部分对仍旧叫做Zygote Space，而未使用的那部分堆叫做 Allocation Space ，以后的对象都会在 Allocation Space上进行分配和释放。</p>
<h2 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h2><p>Android 4.4 的时候发布了ART虚拟机，但是4.4版本默认还是使用DVM，Android 5.0 及以后版本默认采用ART，从此，DVM退出历史舞台。</p>
<h3 id="ART-与-Dalvik-区别"><a href="#ART-与-Dalvik-区别" class="headerlink" title="ART 与 Dalvik 区别"></a>ART 与 Dalvik 区别</h3><p>ART 与 Dalvik 的区别主要有4点：</p>
<ul>
<li>DVM 是为32位CPU涉及的，而ART支持64位并且兼容32位 CPU。    </li>
<li>ART 对垃圾回收机制进行了改进，将 GC 暂停由2次减少为1次，并且频繁执行并行垃圾收集。    </li>
<li>ART 的运行时堆空间划分和DVM不同。    </li>
<li>DVM中应用每次运行时，字节码通过 JIT 编译器编译为机器码，使得应用程序运行效率低下；而在ART中，系统在安装应用程序时会进行一次AOT(ahead of time compilation,预编译)，将字节码预先编译成机器码并存储在本地，这样应用程序每次运行时就不需要执行编译了。</li>
</ul>
<blockquote>
<p>ART也有两个主要缺点：一是AOT使应用安装时间变长，二是预编译的机器码占用的存储空间比较大。为了解决上面的缺点，Android 7.0 版本在ART中加入了JIT编译器，作为AOT的补充：在安装应用时不会将字节码全部编译成机器码，而是在运行中将热点代码编译器机器码，以达到缩短应用安装时间并节省存储空间。</p>
</blockquote>
<p>更详细的内容，可以参考<a target="_blank" rel="noopener" href="https://source.android.google.cn/devices/tech/dalvik/gc-debug">官网上的描述</a></p>
<h3 id="ART-运行时堆"><a href="#ART-运行时堆" class="headerlink" title="ART 运行时堆"></a>ART 运行时堆</h3><p>与DVM 的GC不同的是，ART采用多种垃圾收集方案，每个方案会运行不同的垃圾收集器，默认是采用 CMS(Concurrent Mark-Sweep)方案，主要有sticky-CMS 和 partial-CMS，不同的CMS方案，ART运行时堆得空间划分也不同，默认由4个Space和多个辅助结构组成，采用标记-清除算法时，两种虚拟机运行时堆对比图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC11%E7%AB%A0/dalvik%E4%B8%8Eart%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4.png" alt="两种虚拟机运行时堆对比"></p>
<p>由图可以看到ART的4个Space，其中，Zygote Space 、Allocation Space 和 DVM 中的作用一样，ImageSpace 用来存放一些预加载类，Large Object Space 用来分配一些大对象。其中Zygote Space 与 Image Space 是进程共享的。</p>
<h3 id="ART-的GC-日志"><a href="#ART-的GC-日志" class="headerlink" title="ART 的GC 日志"></a>ART 的GC 日志</h3><ol>
<li>GC Reason<br>ART 虚拟机GC日志中会包含产生这次GC原因，主要会有：</li>
</ol>
<ul>
<li>Concurrent: 并发GC，在后台线程运行GC，不会使App的线程暂停，不会阻止内存分配。    </li>
<li>Alloc： 当堆内存已满，App尝试分配内存而引起的GC，<strong>这个GC发生在正在分配内存的线程中。</strong>    </li>
<li>Explicit： App显式请求垃圾收集，比如 System.gc()。    </li>
<li>NativeAlloc： Native 内存分配时触发的GC。    </li>
</ul>
<ol start="2">
<li>垃圾收集器名称<br>ART 虚拟机GC日志中会包含所使用的收集器名称，主要会有：</li>
</ol>
<ul>
<li>Concurrent Mark Sweep(CMS)： 它是以最短收集暂停时间为目标的收集器，采用标记-清除算法，<strong>能释放除了Image Space外的所有空间</strong>    </li>
<li>Concurrent Partial Mark Sweep： 能释放除了Image Space 和 Zygote space 意外的所有空间    </li>
<li>Concurrent Sticky Mark Sweep： 粘性收集器，<strong>基于分代的垃圾收集思想</strong>，只能释放自上次GC以来分配的对象，这个收集器扫描比较频繁，因为它很快并有很短的暂停时间。    </li>
<li>Marksweep + Semispace：非并发GC，复制GC用于堆转换以及堆碎片整理。    </li>
</ul>
<h2 id="DVM-和-ART-的诞生"><a href="#DVM-和-ART-的诞生" class="headerlink" title="DVM 和 ART 的诞生"></a>DVM 和 ART 的诞生</h2><p>它们是从Zygote进程诞生的，这样，Zygote进程就持有了DVM或者ART的实例，此后，Zygote进程每次fork自身创建新的应用进程时，应用程序进程也就得到了 DVM 或者ART 的实例，即每个应用进程都有一个单独的虚拟机实例。<strong>这样做的好处是，无需在每次启动应用程序进程时都要创建DVM或者ART，从而加快了应用程序进程的启动速度</strong>。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共262.1k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.gitee.io/page/5/',]
      });
      });
  </script>


</body>
</html>
