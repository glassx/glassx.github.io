<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.gitee.io/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.gitee.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">112</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/08/24/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/RecyclerView%E7%9A%84notifyItemChanged%E5%BC%95%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/24/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/RecyclerView%E7%9A%84notifyItemChanged%E5%BC%95%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">RecyclerView的notifyItemChanged引出的问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-24 16:07:00 / 修改时间：16:07:34" itemprop="dateCreated datePublished" datetime="2021-08-24T16:07:00+08:00">2021-08-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%97%AE%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">问题</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>   因项目要求，设计类似抖音的视频列表播放功能。在权衡之后，采用ViewPager2 + ExoPlayer 来实现，由于直接这样使用会引起视频播放混乱的问题，即划入下一个视频的时候，上一个视频还在播放，导致同一时刻多个视频同时播放。因此，我们设定一个单例的 mPlayer ，动态地设置给 PlayView，通过在onPageSelected 回调中，调用 notifyItemChanged 方法，刷新当前的item ，让它的标志 play = true，这样让它获取单例的 player ，从而实现播放。</p>
<p>  还有，在每个 item 里面需要有个dialog，点击这个item上的某个位置就弹出来，并且，如果第 0 个item 符合某个条件，那么进入视频列表页面就会弹出dialog。这时候，诡异的问题就来了，在某个测试版本，进入视频列表页面之后，弹出了一个dialog，但是感觉这个dialog上面会有一个蒙层，点击之后，这个蒙层才会消失，之后，该页面的所有按钮才能点击 ！也就是测试所提出的，按钮需要点击两次才有效！这就奇怪了，通过LayoutInspector 也只能看到一个dialog浮在内容上(事实上这是使用不熟导致的，因为看起来，比如 ActivityA 中有3个dialog，那么在选择process的时候，会有3个 ActivityA 在那，所以应该是每有一个window都会展示一下这个activity，所以那时候应该是选了Activity，但是由于内容是一样的，所以看不出来)。</p>
<p>  但是通过打断点，发现同一个视频 id 生成了，在 itemView 中setData 3次，其实 2次是可以理解的 （数据刚加载的时候一次，在 notifyItemChanged 的一次）；与此同时，发现同一个视频 id 出现在两个 itemView 中，这就很奇怪了，并且，前两次 是 itemView1 ，在 notifyItemChanged 之后，id 就出现在了 itemViewB 中了！如果没有看过源码的话，这时候应该颠覆了认知了，因为 notifyItemChanged 应该只刷新当前 item 才对，怎么会创建了一个新的 itemView 呢？</p>
<p>  这个问题到这里，其实可以解释得通了：由于第0个视频满足刚进入页面就需要弹dialog，所以弹了一次；这时候，由于第 0 个视频又被承载到了新的 itemView 上，创建了新的View ，所以又 弹出来了一次，也就是说，上面那个阴影是一个dialog。  </p>
<p>  找到问题之后，再搜了下，发现如果 RecyclerView 默认带有动画的情况下，notifyItemChanged 会创建一个新的ViewHolder ！难怪，那理论上，如果我去掉RecyclerView的动画，应该问题就解决了，于是有了如下代码：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Adapter</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttachedToRecyclerView</span><span class="params">(rv: <span class="type">RecyclerView</span>)</span></span> {</span><br><span class="line">  <span class="keyword">super</span>.onAttachedToRecyclerView(rv)</span><br><span class="line">  rv.itemAnimator = <span class="literal">null</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>果然可以了！现在来总结以下问题：</p>
<blockquote>
<p>由于默认的动画导致刷新单个item的时候创建了新的ViewHolder， 从而引起 Dialog 再弹了一次，两个重叠在一起了，解决方案就是将 RecyclerView 的动画去掉</p>
</blockquote>
<p>以上内容参考资料<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/ask/38077">腾讯云</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/OneDeveloper/article/details/79721284">csdn的博客</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/08/18/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E8%87%AA%E5%B7%B1%E5%8A%A0%E7%9A%84%E7%89%B9%E5%88%AB%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/18/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E8%87%AA%E5%B7%B1%E5%8A%A0%E7%9A%84%E7%89%B9%E5%88%AB%E7%AF%87/" class="post-title-link" itemprop="url">自己编的-特殊函数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-18 17:25:00 / 修改时间：17:35:59" itemprop="dateCreated datePublished" datetime="2021-08-18T17:25:00+08:00">2021-08-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h3 id="run-函数"><a href="#run-函数" class="headerlink" title="run()函数"></a>run()函数</h3><p>它的实现如下，<strong>其实就是调用传入的block参数(一般是个Lambda代码块)</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> inline fun &lt;R&gt; run(block: () -&gt; R): R { </span><br><span class="line">    contract { </span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE) </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> block() </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">run {</span><br><span class="line">    myFun()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="apply-函数"><a href="#apply-函数" class="headerlink" title="apply() 函数"></a>apply() 函数</h3><p>实现如下，主要看后面两行，先是调用了block函数（block里面可以直接使用this？），然后再返回当前调用者this。即执行完block后返回当前的调用者：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T { </span><br><span class="line">    contract { </span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    }</span><br><span class="line">    block() </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法</span></span><br><span class="line">val a = ArrayList&lt;String&gt;().apply {</span><br><span class="line">    add(<span class="string">"A"</span>)</span><br><span class="line">    add(<span class="string">"B"</span>)</span><br><span class="line">    add(<span class="string">"C"</span>)</span><br><span class="line">    println(<span class="keyword">this</span>)<span class="comment">//打印 [A,B,C]</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">println(a)<span class="comment">//同样打印 [A,B,C]</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="let函数"><a href="#let函数" class="headerlink" title="let函数"></a>let函数</h3><p>只需要看源代码最后一行即可：意思是把当前调用对象作为参数传入block代码块(意味着一定要用it访问调用对象，能不能this?),最后，返回block执行结果，即作用域中的最后一个对象：：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R { </span><br><span class="line">    contract { </span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE) </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>) </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="also-函数"><a href="#also-函数" class="headerlink" title="also() 函数"></a>also() 函数</h3><p>源码先调用block(this) ，但是最后返回值是this，也就是，将当前调用者传入block，执行完后返回调用者。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T { </span><br><span class="line">    contract { </span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE) </span><br><span class="line">    }</span><br><span class="line">    block(<span class="keyword">this</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">val a = <span class="string">"ABC"</span>.also{</span><br><span class="line">    println(it)<span class="comment">//输出 ABC</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pintln(a);<span class="comment">//输出 ABC</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="with-函数"><a href="#with-函数" class="headerlink" title="with() 函数"></a>with() 函数</h3><p>源码传入一个接收者对象 reciver，然后使用该对象去调用传入的Lambda代码块： receiver.block()</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R { </span><br><span class="line">    contract { </span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE) </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> receiver.block() </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">whith(ArrayList&lt;String&gt;()) {</span><br><span class="line">    add(<span class="string">"A"</span>)</span><br><span class="line">    add(<span class="string">"B"</span>)</span><br><span class="line">    add(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="keyword">this</span>)<span class="comment">//ABC</span></span><br><span class="line">}.let {</span><br><span class="line">    println(it)<span class="comment">//kotlin.Unit</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="run、let-与-also-对比"><a href="#run、let-与-also-对比" class="headerlink" title="run、let 与 also 对比"></a>run、let 与 also 对比</h3><p>由下面代码可能更好理解run实现中 return block() 、let实现中的  return block(this)  ，以及 also 源码中的 return this ：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//run提供了一个单独的作用域，并且会返回在这个作用域当中的最后一个对象</span></span><br><span class="line"><span class="comment">//例如现在有这么一个场景，用户领取app的奖励，如果用户没有登录弹出登录dialog，如果已经登录则弹出领取奖励的dialog。我们可以使用以下代码来处理这个逻辑</span></span><br><span class="line">run {</span><br><span class="line">    <span class="keyword">if</span> (islogin) loginDialog <span class="keyword">else</span> getAwardDialog</span><br><span class="line">}.show()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">val original = <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line">original.let {</span><br><span class="line">    println(<span class="string">"The original String is $it"</span>) <span class="comment">// "abc"</span></span><br><span class="line">    it.reversed() </span><br><span class="line">}.let {</span><br><span class="line">    println(<span class="string">"The reverse String is $it"</span>) <span class="comment">// "cba"</span></span><br><span class="line">    it.length  </span><br><span class="line">}.let {</span><br><span class="line">    println(<span class="string">"The length of the String is $it"</span>) <span class="comment">// 3</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">original.also {</span><br><span class="line">    println(<span class="string">"The original String is $it"</span>) <span class="comment">// "abc"</span></span><br><span class="line">    it.reversed() </span><br><span class="line">}.also {</span><br><span class="line">    println(<span class="string">"The reverse String is ${it}"</span>) <span class="comment">// "abc"</span></span><br><span class="line">    it.length  </span><br><span class="line">}.also {</span><br><span class="line">    println(<span class="string">"The length of the String is ${it}"</span>) <span class="comment">// "abc"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>run是直接提供一个作用域，并返回作用域里面最后一个对象</li>
<li>let 将this传入block中，并且返回 block(this)，也就是作用域最后一个对象</li>
<li>also 将this传入block中，但是返回的是 this，也就是调用者本身</li>
<li>with 呢，是以 with(T) 的形式使用(但是它貌似不能判断null？)</li>
<li>apply没有传入this，但是直接返回this</li>
</ul>
<p>最后，按需使用的情景：</p>
<p><img src="https://img-blog.csdn.net/20180316005903782?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2xqZDIwMzg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="场景"></p>
<blockquote>
<p>有些内容参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/ljd2038/article/details/79576091">无嘴小呆子</a></p>
</blockquote>
<p>无需写interface，直接写个高阶函数？这个地方是不是高阶函数？</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/08/12/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/12/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：面向对象</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-12 10:25:00 / 修改时间：18:21:29" itemprop="dateCreated datePublished" datetime="2021-08-12T10:25:00+08:00">2021-08-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h2><h3 id="Kotlin-中的类及接口"><a href="#Kotlin-中的类及接口" class="headerlink" title="Kotlin 中的类及接口"></a>Kotlin 中的类及接口</h3><p> Kotlin中的类与Java的很像：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> weight: <span class="built_in">Double</span> = <span class="number">500.0</span></span><br><span class="line">	<span class="keyword">val</span> color: String = <span class="string">"blue"</span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>反编译成Java的版本：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> double weight = <span class="number">500.0D</span>;</span><br><span class="line">	<span class="meta">@NotNull</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String color = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> double getWeight() {</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@NotNull</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> String getColor() {</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> void fly() {</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由此可以看出，虽然声明方式很像，但是也存在很多不同：</p>
<ul>
<li>属性默认值。Kotlin中，除非显式声明延迟初始化，不然就需要指定默认值。</li>
<li>不同的可访问修饰符。Kotlin类中的成员默认是全局可见的(public)，而Java默认可见域是包作用域。  </li>
<li>方法默认是final修饰的。意味着不能覆写(这条是自己添加的)。</li>
</ul>
<p><strong>可带有属性和默认方法的接口</strong></p>
<p>我们知道，Java 8 之后，接口支持<strong>默认实现</strong>，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flayer</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">kind</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>{</span><br><span class="line">	    System.out.println(<span class="string">"I can fly"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来看下Kotlin的接口实现：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> speed: <span class="built_in">Int</span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> {</span><br><span class="line">	    println(<span class="string">"I can fly"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同样，<strong>我们可以用Kotlin 定义一个带有方法实现的接口</strong>，同时，它还支持抽象属性（如例子中的speed属性），然而，Kotlin是基于Java6实现的，那它是如何支持的呢？转换为Java代码看下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getSpeed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">kind</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultImpls</span> </span>{</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(Flyer $<span class="keyword">this</span>)</span> </span>{</span><br><span class="line">	        String var1 = <span class="string">"I can fly"</span>;</span><br><span class="line">	        System.out.println(var1);</span><br><span class="line">	    }</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由此我们发现，Kotlin编译器<strong>通过定义一个静态内部类 DefaultImpls 来提供fly方法的默认实现</strong>。同时，<strong>抽象属性是通过一个get方法来实现的！</strong>所以呢，我们不能像Java一样，为属性直接赋值，如下这样是错误的：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> height = <span class="number">1000</span>;<span class="comment">//error Property initializers are not allowed in interfaces</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是Kotlin 提供了另外一种方式来实现这种效果：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> height</span><br><span class="line">	    <span class="keyword">get</span>() = <span class="number">1000</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="更简洁地构造类的对象"><a href="#更简洁地构造类的对象" class="headerlink" title="更简洁地构造类的对象"></a>更简洁地构造类的对象</h3><p>如果要在Java中实现参数个数不同的构造方法，那我们就要重载很多个构造方法，这种方式主要存在2个缺点：</p>
<ul>
<li>如果要支持任意参数组合来创建对象，那么需要实现的构造方法非常多</li>
<li>每个构造方法中的代码都会冗余，如在构造方法中可能都需要对 age 和color 进行相同的赋值操作。</li>
</ul>
<p>Kotlin 通过引入新的构造语法来解决这些问题。比如我们可以用一行代码来表示复杂的构造方式：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span> = <span class="number">0.00</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">0</span>, <span class="keyword">val</span> color: String = <span class="string">"blue"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>如果用Java实现这种参数任意组合的效果，那是非常复杂的。但是如果不写入全部的参数，而只用其中某些参数的时候，需要写参数名，否则会报错：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的</span></span><br><span class="line"><span class="keyword">val</span> bird1 = Bird(<span class="number">1000.00</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确示例</span></span><br><span class="line"><span class="keyword">val</span> bird2 = Bird(weight = <span class="number">1000.00</span>, color = <span class="string">"black"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>init方法：事实上，<strong>我们的构造方法可以拥有多个 init，他们会在对象创建时按照类中从上到下的顺序先后执行</strong></p>
<p><strong>延迟初始化： by lazy 和 lateinit</strong></p>
<p>在Kotlin中，主要使用lateinit 和 by lazy 这两种语法来实现延迟初始化的效果。如果这是一个用 val 声明的变量，我们用 by lazy 来修饰：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> color: String) {</span><br><span class="line">	<span class="keyword">val</span> sex: String <span class="keyword">by</span> lazy {</span><br><span class="line">	    <span class="keyword">if</span>(color == <span class="string">"yellow"</span>) <span class="string">"male"</span> <span class="keyword">else</span> <span class="string">"female"</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结 by lazy 语法的特点如下：</p>
<ul>
<li>该变量必须是引用不可变的，而不能通过var声明</li>
<li>被首次调用时，才会进行赋值操作，一旦赋值，后续将不能更改。</li>
</ul>
<p>需要注意的是，系统会给 lazy属性默认加上同步锁，也就是 LazyThreadSafetyMode.SYNCHRONIZED ，它在同一时刻只允许一个线程对lazy属性初始化，<strong>所以，lazy是线程安全的</strong>。当然，你可以自己给lazy指定参数，如： <code>val sex: String by lazy(LazyThreadSafetyMode.NONE)</code>。</p>
<p>与lazy 不同，<strong>lateinit 主要用于 var 声明的变量，然而它不能用于基本数据类型，如 Int、Long 等</strong>，我们需要使用Integet这种包装类作为替代。lateinit 的用法如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> color: String) {</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> sex: String</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">printSex</span><span class="params">()</span></span> {</span><br><span class="line">	    sex = <span class="keyword">if</span>(color == <span class="string">"yellow"</span>) <span class="string">"male"</span> <span class="keyword">else</span> <span class="string">"female"</span></span><br><span class="line">	    println(sex)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Kotlin只用一个构造方法实现了Java中需要重载才能实现的功能，那么，Kotlin中是否真的只需要一个构造方法呢？</p>
<h3 id="主从构造方法"><a href="#主从构造方法" class="headerlink" title="主从构造方法"></a>主从构造方法</h3><p>前面似乎遗漏了一些情况，简化前面的Bird类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(age: <span class="built_in">Int</span>) {</span><br><span class="line">	<span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">init</span> {</span><br><span class="line">	    <span class="keyword">this</span>.age = age</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>假设当前我们知道鸟的生日，希望可以通过生日来得到鸟的年龄，然后创建一个Bird对象，如何实现？有一种方案就是在别处定义一个工厂方法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Bird</span><span class="params">(birth: <span class="type">DateTme</span>)</span></span> = Bird(getAgeByBirth(birth))</span><br></pre></td></tr></tbody></table></figure>

<p>在哪声明这个工厂方法呢？这种方式的缺点在于，Bird 方法与Bird类在代码层面的分离不够直观。其实我们可以像Java那样新增一个构造方法来解决，Kotlin 也支持多构造方法，与Java的区别是，<strong>Kotlin中多个构造方法之间存在主从关系</strong>：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(age: <span class="built_in">Int</span>) {</span><br><span class="line">	<span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">init</span> {</span><br><span class="line">	    <span class="keyword">this</span>.age = age</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">constructor</span>(birth: DateTime) : <span class="keyword">this</span>(getAgeByBirth(birth)){</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码的运作方式是：</p>
<ul>
<li>通过constructor方法定义一个新的构造方法，称为<strong>从构造方法</strong>。相应地，我们熟悉的构造方法叫做<strong>主构造方法</strong>，每个类最多存在一个主构造方法，但是可以存在多个从构造方法</li>
<li>如果一个类存在主构造方法，那么每个从构造方法都要直接或间接地委托给它。</li>
</ul>
<h2 id="不同的访问控制原则"><a href="#不同的访问控制原则" class="headerlink" title="不同的访问控制原则"></a>不同的访问控制原则</h2><p>构造完对象，就要考虑访问控制了。</p>
<h3 id="限制修饰符"><a href="#限制修饰符" class="headerlink" title="限制修饰符"></a>限制修饰符</h3><p>我们知道，Kotlin中的类和方法默认实现反编译成 Java的时候，会被final修饰，所以，类默认是不能被继承的，方法默认也不能被覆写的，如果要实现继承，类之前需要用open修饰： <code>open class Bird {}</code> ，方法也需要使用open 修饰： <code>open fun fly()</code> </p>
<h4 id="类默认final-真的好吗？"><a href="#类默认final-真的好吗？" class="headerlink" title="类默认final 真的好吗？"></a>类默认final 真的好吗？</h4><p>网上有很多人认为默认final有很多缺点，那为什么Kotlin要设计成默认final呢？主要有2个原因：</p>
<ul>
<li>Kotlin 当前是一门以Android为平台的开发语言，在开发中，我们很少会频繁继承一个类，默认final会更加安全。</li>
<li>Kotlin的扩展手段更加丰富。不像Java，Kotlin 可以通过多种方式去扩展，而不是通过原始类的手段，典型的莫过于 Android 的Kotlin 扩展库 android-ktx，Google就是通过Kotlin的扩展语法而不是继承来实现。</li>
</ul>
<p>此外，Kotlin还可以利用<strong>密封类</strong>来限制一个类的继承，如下所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> = <span class="string">"I can fly"</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Eagle</span>: <span class="type">Bird</span></span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Kotlin通过 <strong>sealed 关键字</strong>来修饰一个类为密封类，<strong>若要继承则需要将子类定义在同一个文件中，其他文件中的类将无法继承它</strong>。但是这种方式有它的局限性，即它不能被初始化，为什么呢？<strong>这是因为它是基于抽象类实现的</strong>，我们看反编译后的Java代码就知道了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Bird</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(DefaultConstructorMarker $constrctor_maker)</span> </span>{</span><br><span class="line">	    <span class="keyword">this</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Eagle</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">Eagle</span><span class="params">()</span> </span>{</span><br><span class="line">	        <span class="keyword">super</span>((DefaultConstructorMarker)<span class="keyword">null</span>)</span><br><span class="line">	    }</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>密封类的使用场景优先，它其实可以看成一种功能更强大的枚举，所以它在模式匹配中可以起到很大的作用</strong>。</p>
<h3 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h3><p>除了限制类修饰符外，还有一种可见性修饰符。Kotlin与Java的不同在于：</p>
<ul>
<li>默认修饰符不同，Kotlin是public，而Java是default</li>
<li>Kotlin中有一个独特的 internal    </li>
<li>Java类只有内部类可以用private修饰，其他类不允许；而Kotlin可以</li>
<li>protected访问范围不同。<strong>Java中是包、类及子类可访问，而Kotlin只有类和子类可以访问</strong>。</li>
</ul>
<p>说下Kotlin 独特的 internal 修饰符，它的作用域被称作<strong>模块内访问</strong>，那到底什么是模块？以下几种情况可以算作一个模块：</p>
<ul>
<li>一个Eclipse项目</li>
<li>一个 Intellij IDEA项目</li>
<li>一个Maven项目</li>
<li>一个Gradle项目</li>
<li>一组由一次Ant任务执行编译的代码</li>
</ul>
<p>那为什么要这种修饰符呢？Java的包内访问不好吗？Java包内访问确实是有问题的，举个例子，你再Java项目中定义了一个类，默认修饰符，那就是包私有的，其他地方将无法访问。然后你id啊宝诚一个类库，供三方使用。但如果有个开发者想使用这个类，除了copy源码以外，还有一个方式就是<strong>在程序中创建一个与该类相同名字的包，那么这个包下面的其他类就能直接使用我们前面定义的类了！</strong></p>
<p>而Kotlin这种，模块内可见指的是该类只对一起编译的其他Kotlin文件可见，开发工程与第三方类库不属于同一模块，这时候如果还想用，就只能复制源码了。</p>
<p>Java中我们很少见到private修饰的类，因为Java中的类或者方法没有单独属于某个文件的概念。若要用provate修饰，那么这个只能是其他类的内部类，而Kotlin中则可以用private给单独的类修饰，它的作用域就是当前这个Kotlin文件：</p>
<h2 id="解决多继承问题"><a href="#解决多继承问题" class="headerlink" title="解决多继承问题"></a>解决多继承问题</h2><p>Java和Kotlin都不支持多继承。为什么这样呢？是因为多继承会导致继承关系语义上的混淆。</p>
<h3 id="骡子的多继承困惑"><a href="#骡子的多继承困惑" class="headerlink" title="骡子的多继承困惑"></a>骡子的多继承困惑</h3><p>C++支持多继承，然而C++中存在一个经典的<strong>钻石问题</strong>。假如我们有个抽象的 Animal 类，它有个 run() 方法，Horse （马） 和 Donkey（驴） 都继承了Animal，假如支持多继承，Mule（驴）继承了 Horse 和 Donkey ，那么，在 Mule 中的 run() 到底是继承了谁的呢？这就是典型的钻石问题，因为继承关系像个钻石图，如下：</p>
<p><img src="/assets/Book-Notes/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0/%E9%92%BB%E7%9F%B3%E9%97%AE%E9%A2%98.png" alt="钻石问题"></p>
<h3 id="接口实现多继承"><a href="#接口实现多继承" class="headerlink" title="接口实现多继承"></a>接口实现多继承</h3><p>在Java中我们经常提及使用接口来实现多继承，其实，如果多个接口中都存在同样的方法，比如上述的 run() ，同样也会导致钻石问题。不过，<strong>Kotlin 通过提供 super 关键字来指定继承那个父接口的方法，从而解决了这个问题</strong>，如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="string">"flying animals"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="string">"flying animals"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(): Flyer, Animal {</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="keyword">super</span>&lt;Flyer&gt;.kind()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过 <code>super&lt;Flyer&gt;.kind()</code>来指定继承哪个父接口的方法！当然，子类也可以自己实现这个方法，不用父类的，完全没问题。</p>
<h3 id="内部类解决多继承问题"><a href="#内部类解决多继承问题" class="headerlink" title="内部类解决多继承问题"></a>内部类解决多继承问题</h3><p>Kotlin的内部类的定义方式和Java 还不一样，如果我们按照Java的习惯来定义 Kotlin中的内部类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterKotlin</span> </span>{</span><br><span class="line">  <span class="keyword">val</span> name = <span class="string">"not kotlin inner class"</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ErrorInnerKotlin</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span> {</span><br><span class="line">      print(<span class="string">"thie name is <span class="variable">$name</span>"</span>)<span class="comment">//报错，不能访问name</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>报错了，和Java 还真不一样。其实，我们这样声明的是Kotlin 的 <strong>嵌套类</strong>，并非内部类。如果要在Kotlin中声明一个内部类，必须在这个类前面加一个 inner 关键字，即这样子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterKotlin</span> </span>{</span><br><span class="line">  <span class="keyword">val</span> name = <span class="string">"kotlin inner class"</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerKotlin</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span> {</span><br><span class="line">      print(<span class="string">"thie name is <span class="variable">$name</span>"</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>我们知道，Java中在内部类的语法上增加一个 static 关键字，就可以变成 嵌套类；Kotlin则是相反的思路，默认是嵌套类，必须加上 inner 关键字才是一个内部类。</p>
</blockquote>
<p>了解内部类之后，可以通过内部类实现上述的骡子类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mule</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">runFast</span><span class="params">()</span></span> {</span><br><span class="line">    HorseC().runFast()</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">runSlow</span><span class="params">()</span></span> {</span><br><span class="line">    DonkeyC().runSlow()</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseC</span>: <span class="type">Horse</span></span>()</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">DonkeyC</span>: <span class="type">Donkey</span></span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用委托代替多继承"><a href="#使用委托代替多继承" class="headerlink" title="使用委托代替多继承"></a>使用委托代替多继承</h3><p><strong>Kotlin中的委托只需要通过 by 关键字就可以实现，比如之前学习的 by lazy 语法，其实就是利用了委托实现了延迟初始化</strong>。我们看下如何通过委托代替多继承需求：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Caneat</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyer</span>: <span class="type">CanFly {</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> {</span><br><span class="line">    println(<span class="string">"I can fly"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> : <span class="type">CanEat {</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    println(<span class="string">"I can eat"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(flyer: Flyer, animal: Animal): CanFly <span class="keyword">by</span> flyer, CanEat <span class="keyword">by</span> animal {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">  <span class="keyword">val</span> fyler = Flyer()</span><br><span class="line">  <span class="keyword">val</span> animal = Animal()</span><br><span class="line">  <span class="keyword">val</span> b = Bird(flyer, animal)</span><br><span class="line">  b.fly()</span><br><span class="line">  b.eat()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="真正的数据类"><a href="#真正的数据类" class="headerlink" title="真正的数据类"></a>真正的数据类</h2><h3 id="繁琐的JavaBean"><a href="#繁琐的JavaBean" class="headerlink" title="繁琐的JavaBean"></a>繁琐的JavaBean</h3><p>JavaBean中需要各种setter和getter，如果要支持对象值的比较，还得重写hashCode 和 equals 等方法。</p>
<h3 id="用data-class创建数据类"><a href="#用data-class创建数据类" class="headerlink" title="用data class创建数据类"></a>用data class创建数据类</h3><p>data class 顾名思义就是<strong>数据类</strong>，这不是Kotlin首创，在Scala等语言中也有。一般我们只需要如下定义即可：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">var</span> weight: <span class="built_in">Double</span>, <span class="keyword">var</span> age: <span class="built_in">Int</span>, <span class="keyword">var</span> color: String)</span><br></pre></td></tr></tbody></table></figure>

<p>这么一行代码，编译器为我们做了很多事情，来看看反编译后的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">double</span> var1)</span> </span>{</span><br><span class="line">      <span class="keyword">this</span>.weight = var1;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>{</span><br><span class="line">      <span class="keyword">this</span>.age = var1;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getColor</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="meta">@NotNull</span> String var1)</span> </span>{</span><br><span class="line">      Intrinsics.checkNotNullParameter(var1, <span class="string">"&lt;set-?&gt;"</span>);</span><br><span class="line">      <span class="keyword">this</span>.color = var1;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(<span class="keyword">double</span> weight, <span class="keyword">int</span> age, <span class="meta">@NotNull</span> String color)</span> </span>{</span><br><span class="line">      Intrinsics.checkNotNullParameter(color, <span class="string">"color"</span>);</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.weight = weight;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">      <span class="keyword">this</span>.color = color;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">component1</span><span class="params">()</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">component2</span><span class="params">()</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">component3</span><span class="params">()</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Bird <span class="title">copy</span><span class="params">(<span class="keyword">double</span> weight, <span class="keyword">int</span> age, <span class="meta">@NotNull</span> String color)</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      Intrinsics.checkNotNullParameter(color, <span class="string">"color"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Bird(weight, age, color);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Bird copy$<span class="keyword">default</span>(Bird var0, <span class="keyword">double</span> var1, <span class="keyword">int</span> var3, String var4, <span class="keyword">int</span> var5, Object var6) {</span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">1</span>) != <span class="number">0</span>) {</span><br><span class="line">         var1 = var0.weight;<span class="comment">//copy时，若未指定具体属性的值，则使用被copy对象的属性值，这是浅拷贝</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">2</span>) != <span class="number">0</span>) {</span><br><span class="line">         var3 = var0.age;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">4</span>) != <span class="number">0</span>) {</span><br><span class="line">         var4 = var0.color;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var0.copy(var1, var3, var4);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Bird(weight="</span> + <span class="keyword">this</span>.weight + <span class="string">", age="</span> + <span class="keyword">this</span>.age + <span class="string">", color="</span> + <span class="keyword">this</span>.color + <span class="string">")"</span>;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">int</span> var10000 = (Double.hashCode(<span class="keyword">this</span>.weight) * <span class="number">31</span> + Integer.hashCode(<span class="keyword">this</span>.age)) * <span class="number">31</span>;</span><br><span class="line">      String var10001 = <span class="keyword">this</span>.color;</span><br><span class="line">      <span class="keyword">return</span> var10000 + (var10001 != <span class="keyword">null</span> ? var10001.hashCode() : <span class="number">0</span>);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="meta">@Nullable</span> Object var1)</span> </span>{</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> != var1) {</span><br><span class="line">         <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Bird) {</span><br><span class="line">            Bird var2 = (Bird)var1;</span><br><span class="line">            <span class="keyword">if</span> (Double.compare(<span class="keyword">this</span>.weight, var2.weight) == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.age == var2.age &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.color, var2.color)) {</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这就和JavaBean很相似了，同时还有 equals 和 hashCode 的实现。同时，我们发现里面有几个JavaBean中没有的方法，比如 copy、component1、component2、component3。下一节来介绍它们。</p>
<h3 id="copy-、componentN-与-结构"><a href="#copy-、componentN-与-结构" class="headerlink" title="copy 、componentN 与 结构"></a>copy 、componentN 与 结构</h3><p>上上述代码可以看到，两个copy方法，可以传入响应的参数来生成不同的对象；同时，如果你未指定具体属性的值，那么新生成的对象的属性值将使用被copy对象的属性值，这就是我们常说的浅拷贝。看个例子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果Bird的属性是var，即可变的</span></span><br><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>,<span class="number">1</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="keyword">val</span> b2 = b1</span><br><span class="line">b2.age = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果Bird的属性是val，不可变的，那么更改属性只能通过copy</span></span><br><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>,<span class="number">1</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="keyword">val</span> b2 = b1.copy(age = <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>



<p><strong>注意，Kotlin提供的上述copy方法是浅拷贝的，所以我们要注意使用场景。</strong>因为数据类的属性可以被修饰为var，所以不能保证不会出现引用被修改的情况。</p>
<p>接下来看 componentN (其中N为1，2，3…，根据参数个数来定)，这个设计到底有什么用？我们或多或少直到怎么将属性绑定到类上，但是对于如何将类的属性绑定到响应变量上却不是很熟悉，比如：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>,<span class="number">1</span>, <span class="string">"blue"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通常方法，也符合Java的思维逻辑</span></span><br><span class="line"><span class="keyword">val</span> weight = b1.weight</span><br><span class="line"><span class="keyword">val</span> age = b1.age</span><br><span class="line"><span class="keyword">val</span> color = b1.color</span><br><span class="line"></span><br><span class="line"><span class="comment">//Kotlin 进阶方法</span></span><br><span class="line"><span class="keyword">val</span> (weight, age, color) = b1</span><br></pre></td></tr></tbody></table></figure>

<p>看到进阶方法的时候，一定感到兴奋了吧，普通方法确实很繁琐。还有一种情形，看Java的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String birdInfo = <span class="string">"20.0,1, blue"</span>;</span><br><span class="line"><span class="comment">//如果要把值取出来，就得split</span></span><br><span class="line">String[] temps = birdInfo(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">double</span> weight = Double.valueOf(temps[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> age = Integer.valueOf(temps[<span class="number">1</span>]);</span><br><span class="line">String color = temps[<span class="number">2</span>];</span><br></pre></td></tr></tbody></table></figure>

<p>在我们明明直到值得情况下，还需要这样分割，很繁琐，好在Kotlin提供了更优雅的做法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (weight, age, color) = birdInfo.split(<span class="string">","</span>)</span><br></pre></td></tr></tbody></table></figure>



<p>这个语法也很简洁和直观，其原理也很简单，就是 <strong>解构</strong>，通过编译器的约定实现解构。当然，<strong>Kotlin对于解构也有限制，在数组中它默认最多允许赋值5个变量，因为如果变量过多，效果反而会适得其反，因为到后期你都搞不清哪个值要赋给哪个变量了</strong>。除了利用编译器自动生成的 componentN之外，你还可以实现自己的 componentN，比如：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">var</span> weight: <span class="built_in">Double</span>, <span class="keyword">var</span> age: <span class="built_in">Int</span>, <span class="keyword">var</span> color: String) {</span><br><span class="line">  <span class="keyword">var</span> sex = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> component4: <span class="built_in">Int</span> {//注意 <span class="keyword">operator</span> 关键字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sex</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(weight: <span class="built_in">Double</span>, age: <span class="built_in">Int</span>, color: String, sex: <span class="built_in">Int</span>) : <span class="keyword">this</span>(weight, age, color) {</span><br><span class="line">    <span class="keyword">this</span>.sex = sex</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//使用</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">    <span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>, <span class="number">1</span>, <span class="string">"blue"</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> (weight, age, color, sex) = b1</span><br><span class="line">    ...</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>除了数组支持解构外，Kotlin也提供了其他常用数据类型，分别是 Pair 和 Triple 前者是二元组，后者是 三元组，，我们可以</p>
<p>用类似以下方法来使用它们：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pair = Pair(<span class="number">20.0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">//利用属性顺序获取</span></span><br><span class="line"><span class="keyword">val</span> weightP = pair.first</span><br><span class="line"><span class="keyword">val</span> ageP = pair.second</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用解构</span></span><br><span class="line"><span class="keyword">val</span> (weightP, ageP) = Pair(<span class="number">20.0</span>,<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>



<h2 id="从static-到-object"><a href="#从static-到-object" class="headerlink" title="从static 到 object"></a>从static 到 object</h2><p>Kotlin中告别了static，因为有了 object 关键字，除了替代static外，它还有更多的功能实现，比如单例对象以及简化匿名表达式等。</p>
<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>看一段常见的Java代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prize</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> TYPE_REDPACK = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRedpack</span><span class="params">(Prize prize)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> prize.type == TYPE_REDPACK;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这个类中既有静态变量、静态方法，也有普通变量、普通方法，然而，静态变量和静态方法是属于类的，普通变量和普通方法是属于具体对象的，所以在代码解构上职能并不清晰。Kotlin中利用 companion object 两个关键字引入伴生对象来清晰区分。</p>
<blockquote>
<p>顾名思义，“伴生”即伴随某个类的对象，它属于这个类所有，全局只有一个单例，因此伴生对象跟Java中static修饰的效果一样，<strong>在类装载的时候被初始化</strong>。</p>
</blockquote>
<p>companion object 用花括号包裹了所有静态属性和方法，使得将普通方法和属性清晰区分开来。此外，伴生对象很适合作为工厂，这里就不展开。</p>
<h3 id="天生的单例：-object"><a href="#天生的单例：-object" class="headerlink" title="天生的单例： object"></a>天生的单例： object</h3><p>单例模式最大的一个特点就是在系统中只能存在一个实例对象，所以在java中我们必须通过设置构造方法私有化，以及提供静态方法创建实例的方式来创建单例。在Kotlin中，由于object的存在，我们可以直接用它来实现单例，如下所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DatabaseConfig {</span><br><span class="line">  <span class="keyword">var</span> host: String = <span class="string">"127.0.0.1"</span></span><br><span class="line">  <span class="keyword">var</span> port: <span class="built_in">Int</span> = <span class="number">3306</span></span><br><span class="line">  <span class="keyword">var</span> userName: String = <span class="string">"root"</span></span><br><span class="line">  <span class="keyword">var</span> password: String = <span class="string">""</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>由于object全局声明的对象只有一个，所以它并不用语法上的初始化，甚至都不需要构造方法，因此，我们可以说object创造的是天生的单例</strong>。此外，由于 DatabaseConfig 的属性是 var 声明的属性，我们还能修改它们： </p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatabaseConfig.host = <span class="string">"localhost"</span></span><br><span class="line">DatabaseConfig.port = <span class="number">3307</span></span><br></pre></td></tr></tbody></table></figure>



<p>由于<strong>单例也可以和普通类一样实现接口和继承类</strong>，所以可以将其看成一种不需要主动初始化的类，它也<strong>可以拥有扩展方法</strong>，<strong>单例对象会在系统加载的时候初始化</strong>。</p>
<h3 id="object-表达式"><a href="#object-表达式" class="headerlink" title="object 表达式"></a>object 表达式</h3><p>主要说的是，利用object来完善匿名内部类，这里不展开说。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/08/10/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/10/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第2章：基础语法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-10 15:54:00" itemprop="dateCreated datePublished" datetime="2021-08-10T15:54:00+08:00">2021-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-11 17:47:39" itemprop="dateModified" datetime="2021-08-11T17:47:39+08:00">2021-08-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="不一样的类型声明"><a href="#不一样的类型声明" class="headerlink" title="不一样的类型声明"></a>不一样的类型声明</h2><p>Kotlin 采用的是与 Java 相反的类型声明方式，类型名通常在变量名的后面： <code>val a: String = "I am Kotlin"</code>为什么采用这种风格呢？Kotlin官方的FAQ的回答是这样的：</p>
<blockquote>
<p>我们相信这样可以使得代码的可读性更好。同时，<strong>这也有利于使用一些良好的语法特性，比如省略类型声明</strong>。Scala的经验表明，这不是一个错误的选择。</p>
</blockquote>
<p>所以，类型放在变量后面的其中一个原因是为了<strong>类型省略</strong>，这个类型省略其实就是类型推导。</p>
<h3 id="增强的类型推导"><a href="#增强的类型推导" class="headerlink" title="增强的类型推导"></a>增强的类型推导</h3><p>类型推导是Kotlin在Java的基础上增强的语言特性之一，即编译器可以在不显式声明类型的情况下，自动推导除它所需要的类型，如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> string = <span class="string">"I am Kotlin"</span></span><br><span class="line"><span class="keyword">val</span> int = <span class="number">1314</span></span><br><span class="line"><span class="keyword">val</span> long = <span class="number">1314L</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们打印以上的变量类型，如： println(int.javaClass.name),将会获得如下结果： </span></span><br><span class="line"><span class="comment">//java.lang.String</span></span><br><span class="line"><span class="comment">//int</span></span><br><span class="line"><span class="comment">//long</span></span><br></pre></td></tr></tbody></table></figure>

<p>类型推导很大程度上提高了Kotlin这种<strong>静态类型语言</strong>的开发效率，虽然静态类型语言有很多优点，然而在编码过程中却需要书写大量的类型。</p>
<h3 id="声明函数返回值类型"><a href="#声明函数返回值类型" class="headerlink" title="声明函数返回值类型"></a>声明函数返回值类型</h3><p>虽然支持类型推导，但是函数返回值类型必须要显式声明，比如：</p>
<p><code>fun sum(x: Int, y: Int): Int { return x + y }</code></p>
<p>此时也许与Java的区别不大，其实Kotlin进一步增强了函数语法，我们可以把 {} 去掉，用等号来定义一个函数：</p>
<p><code>fun sum(x: Int, y: Int) = x + y</code></p>
<p>Kotlin支持的这种单行表达式与等号的语法定义的函数，叫做<strong>表达式函数体</strong>，作为区分，普通的函数声明叫做<strong>代码块函数体</strong>。但是别高兴太早，我们再来看一段递归程序：</p>
<p><code>fun foo(n: Int) = if(n == 0) 1 else n * foo(n - 1)</code></p>
<p>这种情况下，编译器并不能针对递归函数的情况推导类型，因此这里会报错。所以，在一些诸如递归等复杂条件下，及时用表达式定义函数，我们也必须显式声明类型，才能让程序正常工作，代码如下：</p>
<p><code>fun foo(n: Int): Int = if(n == 0) 1 else n * foo(n - 1)</code></p>
<h2 id="val-和-var-的使用规则"><a href="#val-和-var-的使用规则" class="headerlink" title="val 和 var 的使用规则"></a>val 和 var 的使用规则</h2><p>Kotlin声明变量时，引入了 val 和 var 的概念。var 容易理解，就是变量，在JavaScript 中也有用到，但是 val 是什么呢？如果在 IDEA 中反编译 val 的实现成Java代码就能发现，<strong>它是通过 final 这一特性实现的</strong>。 </p>
<h3 id="优先使用val避免副作用"><a href="#优先使用val避免副作用" class="headerlink" title="优先使用val避免副作用"></a>优先使用val避免副作用</h3><p><strong>Kotlin支持一开始不定义 val 变量的取值，随后再进行赋值</strong>，然而，因为引用不可变，所以val声明的变量只能被赋值一次，<strong>并且声明时不能省略变量类型</strong>，如下所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">  <span class="keyword">val</span> a: <span class="built_in">Int</span></span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  println(a)<span class="comment">//输出1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于不可变性，我们可以直到 val 变量在并发环境更安全。</p>
<h3 id="var-的适用场景"><a href="#var-的适用场景" class="headerlink" title="var 的适用场景"></a>var 的适用场景</h3><p>既然 val 那么好，为什么要 var 呢？首先，Kotlin 要兼容Java ，这就注定 必须有 var 的存在；其次有一些场景如果不适用 var 就必须得用到 递归 才能实现了，所以var需要存在。</p>
<h2 id="高阶函数和Lambda"><a href="#高阶函数和Lambda" class="headerlink" title="高阶函数和Lambda"></a>高阶函数和Lambda</h2><p>Kotlin 天然支持了部分<strong>函数式特性</strong>，函数式语言的一个典型特征在于<strong>函数式头等公民</strong>——我们不仅可以像类一样在顶层直接定义一个函数，<strong>也可以在函数内部定义一个局部函数</strong>！如下所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(x: <span class="type">Int</span>)</span></span> {</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(y: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> {</span><br><span class="line">    <span class="keyword">return</span> y * <span class="number">2</span></span><br><span class="line">  }</span><br><span class="line">  println(double(x))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此外，Kotlin还能直接将函数像普通变量一样传递给另一个函数，或在其他函数中被返回，如何理解这个特性？</p>
<h3 id="抽象和高阶函数"><a href="#抽象和高阶函数" class="headerlink" title="抽象和高阶函数"></a>抽象和高阶函数</h3><p>概念东西，略</p>
<h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><p>在Kotlin中，函数类型的格式非常简单，举个例子：<code>(Int) -&gt; Unit</code>，我们可以发现，Kotlin中的函数类型需要遵循以下几点：</p>
<ul>
<li>通过 -&gt; 符号来组织参数类型和返回值类型，左边是参数类型，右边是返回值类型</li>
<li>必须用一个括号来包裹参数类型，如果多个参数，可以用逗号分割，如： <code>(Int， String?) -&gt; Unit</code></li>
<li>返回值<strong>即使是 Unit ，也必须显式声明</strong>    </li>
</ul>
<p>此外，Kotlin 还支持为声明参数指定名字：<code>(errCode: Int， errMsg: String?) -&gt; Unit</code> 这还没完，<strong>高阶函数还支持返回另一个函数</strong>，所以还能这么做：</p>
<figure class="highlight k"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(Int) -&gt; ((Int) -&gt; Unit)</span><br><span class="line"><span class="comment">//如果把后半部分括号省略，可以写成：</span></span><br><span class="line">(Int) -&gt; Int -&gt; Unit</span><br></pre></td></tr></tbody></table></figure>



<h3 id="方法和成员引用"><a href="#方法和成员引用" class="headerlink" title="方法和成员引用"></a>方法和成员引用</h3><p>Kotlin 存在一种特殊的语法，<strong>通过两个冒号来四号线对于某个类的方法进行引用</strong>。假如有一个CountryTest 类的对象实例 countryTest ，如果要引用它的 isBigEuropeanCountry 方法，就可以这么写： </p>
<p><code>countryTest::isBigEuropeanCountry</code></p>
<p>此外，我们还可以直接通过这种语法，来定义一个类的构造方法引用变量：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>(<span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">	<span class="keyword">val</span> getBook = ::Book</span><br><span class="line">	println(getBook(<span class="string">"Dive into Kotlin"</span>).name)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以发现，getBook 的类型为 (name: String) -&gt; Book 。类似的道理，如果我们要引用某个类中的成员变量，比如Book类中的name，就可以这样引用： <code>Book:name</code> ，以上 Book::name 的类型为 (Book) -&gt; String 。当我们在对Book 类对象的集合应用一些函数式API的时候，就会显得格外有用，比如：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">	<span class="keyword">val</span> bookNames = listOf(</span><br><span class="line">	    Book(<span class="string">"Thinking in Java"</span>)</span><br><span class="line">	    Book(<span class="string">"Dive into Kotlin"</span>)</span><br><span class="line">	).map(Book::name)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>略</p>
<h3 id="Lambda-是语法糖"><a href="#Lambda-是语法糖" class="headerlink" title="Lambda 是语法糖"></a>Lambda 是语法糖</h3><p>Kotlin 在JVM 层设计了 Function 类型 (Function0，Function1…Function22)来兼容Java的Lambda表达式，其中后缀数字代表了 Lambda 参数的数量。比如，Function1在源码中就是如下表示的：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Function1</span>&lt;<span class="type">in P1, out R</span>&gt;: <span class="type">kotlin.Function</span>&lt;<span class="type">R</span>&gt; </span>{</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(p1: <span class="type">P1</span>)</span></span>: R</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可见每个Function 类型都有一个invoke方法，设计Function类型的目的之一就是要兼容Java ，实现在Kotlin 中也能调用Java的Lambda。<strong>在 Java 中，实际上不支持把函数作为参数，而是通过函数式接口来实现这一特性。</strong></p>
<h3 id="函数、Lambda和闭包"><a href="#函数、Lambda和闭包" class="headerlink" title="函数、Lambda和闭包"></a>函数、Lambda和闭包</h3><p>略</p>
<h3 id="“柯里化”风格、扩展函数"><a href="#“柯里化”风格、扩展函数" class="headerlink" title="“柯里化”风格、扩展函数"></a>“柯里化”风格、扩展函数</h3><p>柯里化略</p>
<p>在我们介绍的Lambda的表达式中，还存在一种特殊的语法，如果一个函数只有一个参数，且该参数为函数类型，那么在调用该函数时，外面的括号就可以省略，例子如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">omit</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> {</span><br><span class="line">  block</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么我们在调用的时候，可以写成</span></span><br><span class="line">omit {</span><br><span class="line">  println(<span class="string">"parentheses is omitted"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>另一项特性 扩展函数，允许我们在不修改已有类的前提下，给它增加新的方法，示例如下：</p>
<figure class="highlight k"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun View.invisible() {</span><br><span class="line">    this.visibility = View.INVISIBLE</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>在上述例子中，类型View被称为<strong>接收者类型</strong>，this对应的是这个类型锁创建的<strong>接收者对象</strong>，this也能被省略，就像这样：</p>
<figure class="highlight k"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun View.invisible() {</span><br><span class="line">    visibility = View.INVISIBLE</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="面向表达式编程"><a href="#面向表达式编程" class="headerlink" title="面向表达式编程"></a>面向表达式编程</h2><p>现在，罗列下我们已经提及的表达式概念：</p>
<ul>
<li>if表达式</li>
<li>函数体表达式</li>
<li>Lambda表达式</li>
<li>函数引用表达式</li>
</ul>
<h3 id="Unit类型：让函数调用皆为表达式"><a href="#Unit类型：让函数调用皆为表达式" class="headerlink" title="Unit类型：让函数调用皆为表达式"></a>Unit类型：让函数调用皆为表达式</h3><p>之所有不能说Java中的函数调用皆是表达式，是因为存在特例 void，在Java中如果声明的函数没有返回值，那么它就要用void修饰：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">()</span> </span>{</span><br><span class="line">  System.out.println(<span class="string">"hahah"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所以foo就不具有值和类型信息，就不能算作一个表达式。函数式语言在所有的情况下都具有返回类型，所以kotlin引入了 Unit 来替代 void 关键字。如何理解 Unit ？其实与 int 一样，都是一种类型，然而它不代表任何信息，它就是一个单例，它的实例只有一个 ，可以写为 () 。</p>
<h3 id="for循环和范围表达式"><a href="#for循环和范围表达式" class="headerlink" title="for循环和范围表达式"></a>for循环和范围表达式</h3><p>在Java中，经常在for来构建循环体：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) {</span><br><span class="line">  System.out.println(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是kotlin会简单很多：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i in 1..10) println(i)  </span><br><span class="line">//当然也能把大括号和i的类型加上</span><br><span class="line">for (i:Int in 1..10) {</span><br><span class="line">  println(i) </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>范围表达式，1..10 这种语法是<strong>范围表达式</strong>(range) 。</p>
<blockquote>
<p>官网的表述是：Range表达式是通过rangeTo 函数实现的，通过 .. 操作符与某种类型的对象组成，除了整形的基本类型外，该类型需要实现 java.lang.Comparable 接口</p>
</blockquote>
<p>举个例子，由于 String类实现了 Comparable 接口，字符串之间可以比较大小，所以我们可以创建一个字符串区间，如 <code>"abc".."xyz"</code> 。</p>
<p>另外，kotlin 还提供了步长和倒序以及半开区间：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步长</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> step <span class="number">2</span>) print(i) <span class="comment">//输出 1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//倒序</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">1</span> step <span class="number">2</span>) print(i) <span class="comment">//输出： 10 8 6 4 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//半开区间</span></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">10</span>) print(i)  <span class="comment">//输出 123456789</span></span><br></pre></td></tr></tbody></table></figure>



<p>用 in 来检查成员关系，，在Kotlin中我们可以用 in 关键字来检查一个元素是否是一个区间或者集合中的成员，比如：<code>"a" in  listOf ("b" , "c")</code> ，会返回 false ；在 in 之前加上叹号就是相反结果： <code>"a" !in  listOf ("b" , "c")</code> 返回true。更多的应用场景如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结合范围表达式</span></span><br><span class="line"><span class="string">"kot"</span> <span class="keyword">in</span> <span class="string">"abc"</span>..<span class="string">"xyz"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//还能通过withIndex 提供键值元祖</span></span><br><span class="line"><span class="keyword">for</span> ((index,value) <span class="keyword">in</span> array.withIndex) {</span><br><span class="line">  println(<span class="string">"the element at <span class="variable">$index</span> is <span class="variable">$value</span>"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><p>前面见识过 in、step、downTo、until 这些写法，都不需要通过点号，而是用<strong>中缀表达式</strong>来被调用，从而语法更直观。这是如何实现的呢？看下标准库中类似的方法 to 的设计：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;A,B&gt;</span> A.<span class="title">to</span><span class="params">(that: <span class="type">B</span>)</span></span>: Pair&lt;A, B&gt;</span><br></pre></td></tr></tbody></table></figure>



<h4 id="函数可变参数"><a href="#函数可变参数" class="headerlink" title="函数可变参数"></a>函数可变参数</h4><p>Java 中采用 “…” 来表示可变参数，<strong>Kotlin中通过 varargs 关键字实现可变参数…</strong>。需要注意的是，<strong>Java 中的可变参数必须是最后一个参数，Ktolin中没有这个限制</strong>，但两者都可以在函数体中以数组方式来使用可变参数变量：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printLetters</span><span class="params">(varargs letters: <span class="type">String</span>, count: <span class="type">Int</span>)</span></span> {</span><br><span class="line">  print(<span class="string">"<span class="subst">${count}</span> letters are "</span>)</span><br><span class="line">  <span class="keyword">for</span> (letter <span class="keyword">in</span> letters) print(letter) <span class="comment">// 输出 3 letters are abc</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//此外，我们还能使用星号(*)来传入外部的变量作为可变参数的变量：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> letters = arrayOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line">printLetters(*letters, count = <span class="number">3</span>) <span class="comment">//同样会输出 3 letters are abc</span></span><br></pre></td></tr></tbody></table></figure>

<p>由于to会返回 Pair 这种键值对的结构数据，因此我们经常会把它与map结合在一起使用，如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mapOf(</span><br><span class="line">    <span class="number">1</span> to <span class="string">"one"</span>,</span><br><span class="line">    <span class="number">2</span> to <span class="string">"two"</span>,</span><br><span class="line">    <span class="number">3</span> to <span class="string">"three"</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>



<h2 id="字符串的定义和操作"><a href="#字符串的定义和操作" class="headerlink" title="字符串的定义和操作"></a>字符串的定义和操作</h2><p>kotlin 中有丰富的API，比如： <code>"abcdefg".filter {c -&gt; c in 'a'..'d'}</code> //输出 abcd</p>
<h3 id="定义原生字符串"><a href="#定义原生字符串" class="headerlink" title="定义原生字符串"></a>定义原生字符串</h3><p>Java 对原生字符串只能通过转义字符的方法支持。然而，在Kotlin中已经支持直接写原生字符串，使用3个引号的方式(“””)，体验下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rawString = <span class="string">"""</span></span><br><span class="line"><span class="string">    \n Kotlin is awesonme.</span></span><br><span class="line"><span class="string">    \n Kotlin is a better Java. """</span></span><br><span class="line"></span><br><span class="line">print(rawString)</span><br><span class="line"></span><br><span class="line"><span class="comment">//会打印：</span></span><br><span class="line">\n Kotlin <span class="keyword">is</span> awesonme.</span><br><span class="line">\n Kotlin <span class="keyword">is</span> a better Java.</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到非常简洁，如果用Java 来表示会非常复杂，尤其是 Html 代码。</p>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>略</p>
<h3 id="字符串判等"><a href="#字符串判等" class="headerlink" title="字符串判等"></a>字符串判等</h3><p>Kotlin 中判等性有两种类型：</p>
<ul>
<li>结构相等。 通过 == 来判定两个对象的内容是否相等</li>
<li>引用相等。通过 === 来判断两个对象的引用是否一样，与之相反的操作是 !== ，</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/08/10/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC1%E3%80%812%E3%80%813%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/10/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC1%E3%80%812%E3%80%813%E7%AB%A0/" class="post-title-link" itemprop="url">第1、2、3章：异步程序设计介绍</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-10 15:46:00 / 修改时间：15:48:59" itemprop="dateCreated datePublished" datetime="2021-08-10T15:46:00+08:00">2021-08-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="异步程序设计的关键问题"><a href="#异步程序设计的关键问题" class="headerlink" title="异步程序设计的关键问题"></a>异步程序设计的关键问题</h2><ul>
<li>结果传递——异步（数据未准备好）或者同步（数据已经准备好）</li>
<li>异常处理，一旦异步调用，异常处理变得复杂。（执行前错误，执行时错误、数据错误等）</li>
<li>取消响应</li>
<li>‘复杂分支（比如涉及同步）</li>
</ul>
<h2 id="常见的异步程序设计思路"><a href="#常见的异步程序设计思路" class="headerlink" title="常见的异步程序设计思路"></a>常见的异步程序设计思路</h2><ul>
<li><p>Future，没有偏离主流程，但是一旦调用get就会阻塞</p>
</li>
<li><p>CompletableFuture，get调用之后，不会阻塞主调用流程，但是整体偏离了主流程</p>
</li>
<li><p>Promise 与 async/await， 在JS、C#等语言中实现</p>
</li>
<li><p>响应式编程，比如 RxJava 就是这种思想，注重描述数据输入和输出之间的关系，因此很容易奇幻线程</p>
</li>
<li><p>Kotlin 协程，只用了一个关键字suspend表示挂起点，包含了异步调用和回调两层含义。在挂起点我们可以做很多事情，既可以像async/await异步回调，也能添加调度器来处理线程切换</p>
<blockquote>
<p>如果说kotlin协程只是一个“线程框架”，那就有点“一叶障目不见泰山”了，</p>
</blockquote>
</li>
</ul>
<p>我们来看一个Kotlin协程处理异步调用的例子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">bitmapSuspendable</span><span class="params">(url: <span class="type">String</span>)</span></span>: Bitmap = </span><br><span class="line">    suspendCoroutin&lt;Bitmap&gt; { continuation -&gt;</span><br><span class="line">      thread {</span><br><span class="line">        continuation.resume(download(url))</span><br><span class="line">      } <span class="keyword">catch</span> (e: Exception) {</span><br><span class="line">        continuation.resumeWithException(e)</span><br><span class="line">      }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<p>我们用标准库 API suspendCoroutin<t> 的返回值作为挂起函数 bitmapSuspendable 的返回值类型，也就是反省参数T的实参 Bitmap，这个函数除了确定返回值类型外，还能帮我们拿到一个Continuation的实例，负责保存和恢复挂起状态。<strong>suspend 函数只能在 其他suspend函数或者协程体中调用</strong>。</t></p>
<p>ConcurrentHashMap 的value不能为null</p>
<p>———第2章：协程的基本概念</p>
<h2 id="协程是什么"><a href="#协程是什么" class="headerlink" title="协程是什么"></a>协程是什么</h2><p>线程与协程的最大区别：从任务的角度看，线程一旦开始就不会暂停，直到任务结束，这个过程是连续的，线程之间是抢占调度的，因此不存在协作。而协程会自己处理挂起和恢复来实现协作调度。</p>
<h2 id="协程的分类"><a href="#协程的分类" class="headerlink" title="协程的分类"></a>协程的分类</h2><h3 id="按照调用栈分"><a href="#按照调用栈分" class="headerlink" title="按照调用栈分"></a>按照调用栈分</h3><p>通常说的调用栈，指的是<strong>函数调用栈</strong>，是用来保存函数调用时的状态信息的数据结构。线程会因为CPU调度权的切换而被中断，它的中断状态会保存在调用栈中，因而，协程也能按照是否开辟相应的调用栈来分类：</p>
<ul>
<li>有栈协程，这就类似线程了，与线程的不同体现在调度上</li>
<li>无栈协程，没有自己的调用栈，挂起点的状态通过<strong>状态机</strong>或者<strong>闭包</strong>等语法来实现</li>
</ul>
<p>有栈协程的优点是<strong>可以在任意函数调用层级的任意位置挂起，并转移调度权</strong>，无栈协程的优点那就是<strong>节省了这块栈内存</strong>。一般来说，<strong>Kotlin 属于 无栈协程</strong>，它依靠对协程体本身编译生成的状态机的状态流转实现，变量的保存也是通过闭包语法实现。</p>
<h3 id="按调度方式分类"><a href="#按调度方式分类" class="headerlink" title="按调度方式分类"></a>按调度方式分类</h3><p>根据协程调度权的转移目标的不同，又可以将协程分为以下两种：</p>
<ul>
<li>对称协程，每个协程都是相互独立且平等的，调度权可以在任意协程之间转移    </li>
<li>非对称协程，协程出让调度权的目标只能是它的<strong>调用者</strong>，也即协程之间存在调用和被调用的关系</li>
</ul>
<p>对称协程接近线程的样子了，而非对称协程更符合我们的思维习惯。非对称协程的一个例子就是：async/await ，await时，将调度权转移到异步调用中，异步调用返回结果或者抛出异常时，总是将调度权转移回await 的位置。至于Kotlin协程，书中没有具体分类，不过从言语中可以<strong>推断出Kotlin协程属于 非对称协程</strong>。</p>
<h3 id="协程的实现举例"><a href="#协程的实现举例" class="headerlink" title="协程的实现举例"></a>协程的实现举例</h3><p>简略写下：</p>
<ul>
<li>Python的Generator 通过在函数中调用  yield 来实现当前函数调用的挂起 ，yield 的参数作为对下一次调用的返回值   </li>
<li>Lua 就提供了几个API ，让开发者灵活调用： create创建、yield 挂起、resume 恢复</li>
</ul>
<p>————–第3章：Kotlin协程的基础设施</p>
<h2 id="协程的构造"><a href="#协程的构造" class="headerlink" title="协程的构造"></a>协程的构造</h2><p>要想进入协程的世界，首先需要构造出一个协程实例。</p>
<h3 id="协程创建"><a href="#协程创建" class="headerlink" title="协程创建"></a>协程创建</h3><p>标准库中提供了一个createCoroutin 函数，我们可以通过它来创建协程：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> continuation = <span class="keyword">suspend</span> {</span><br><span class="line">    println(<span class="string">"In Coroutine."</span>)</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">}.createCoroutine(<span class="keyword">object</span> : Continuation&lt;<span class="built_in">Int</span>&gt; {</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">        println(<span class="string">"Coroutine End: <span class="variable">$result</span>"</span>)</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>



<p>不过这个协程不会立即执行，我们来看这个 createCoroutine 函数的声明：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>其中，</p>
<ul>
<li>suspend () -&gt; T 是 createCoroutine 函数的 Receiver ，<strong>是一个被suspend 修饰的挂起函数</strong>，这也是协程的执行体，不妨称之为协程体</li>
<li>参数 completion 会在协程执行完成后调用，协程的<strong>完成回调</strong></li>
<li>返回值是一个 Continuation 对象，由于现在协程仅仅被创建出来，因此<strong>需要通过这个值在之后出发协程的启动</strong></li>
</ul>
<h3 id="协程的启动"><a href="#协程的启动" class="headerlink" title="协程的启动"></a>协程的启动</h3><p>调用 continuation.resume(Unit) 之后，协程会立即开始执行。为什么触发返回的 Continuation 的resume 就会触发携程体呢？通过阅读源码我们直到，返回的 Continuation 是 SafeContinuation 的实例。</p>
<p>我们的协程体，也就是那个用于创建协程的 suspend Lambda 表达式（应该是这一截：suspend () -&gt; T），编译器在它编译之后会将其封装成一个 <strong>实现了 Continuation 接口的实现类SuspendLambda</strong>！Continuation接口里面有个 invokeSuspend 抽象函数，编译生成的匿名内部类中的这个函数的实现就是我们的协程体！</p>
<p>这样看来就很清晰了，<strong>创建协程返回的 Continuation 实例就是套了几层马甲的协程体，因而调用它的resume就能触发协程体的运行</strong>。</p>
<h3 id="协程体的Receiver（个人理解是提供了个作用域）"><a href="#协程体的Receiver（个人理解是提供了个作用域）" class="headerlink" title="协程体的Receiver（个人理解是提供了个作用域）"></a>协程体的Receiver（个人理解是提供了个作用域）</h3><p>除之前介绍的，还有另一种创建协程的方法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> R.()</span></span> -&gt; T).createCoroutine(</span><br><span class="line">    receiver: R,</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，与之前的方法对比，这个创建方法主要多了个 Receiver 类型 R  ，这个R 提供了一个作用域，<strong>在协程体内我们可以直接使用作用域内提供的函数或者状态等</strong>。为了使用方便，我们封装一个采用这种方法启动协程的方法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">launchCoroutine</span><span class="params">(receiver: <span class="type">R</span>, block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span>)</span></span> {</span><br><span class="line">  block.startCoroutine(receiver, <span class="keyword">object</span>: Continuation&lt;T&gt; {</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt; {</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">println</span>("<span class="type">Coroutin</span> <span class="type">End</span>: $"<span class="type">result</span>")</span></span></span><br><span class="line"><span class="params"><span class="function">    }</span></span></span><br><span class="line"><span class="params"><span class="function">              </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">override</span> <span class="type">val</span> <span class="type">context</span> = EmptyCoroutinContext</span></span></span><br><span class="line"><span class="params"><span class="function">      </span></span></span><br><span class="line"><span class="params"><span class="function">  })</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来，我们用一个例子来使用这个方法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerScope</span>&lt;<span class="type">T</span>&gt; </span>{</span><br><span class="line">  <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">(value: <span class="type">T</span>)</span></span> { ... }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callLaunchCoroutin</span><span class="params">()</span></span> {</span><br><span class="line">  launchCoroutine(ProducerScope&lt;<span class="built_in">Int</span>&gt;()) {</span><br><span class="line">    println(<span class="string">"In Coroutine."</span>)</span><br><span class="line">    produce(<span class="number">1024</span>)<span class="comment">//注意，这里调用 ProducerScope 里面的方法，也就是这个域里面的方法</span></span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    produce(<span class="number">2048</span>)<span class="comment">//注意，这里调用 ProducerScope 里面的方法，也就是这个域里面的方法</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于添加了作用域 ProducerScope 作为Receiver，示例中我们可以在协程体中直接调用 produce 函数；delay 是在协程体外定义的挂起函数，在协程体内也能直接调用。作用域可以用来提供函数支持，自然也能用来增加限制，如果我们为 Receiver 对应的类型增加一个 RestrictsSuspension 注解，那么在它的作用下，协程体内就无法调用协程体外的挂起函数：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestrictsSuspension</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerScope</span>&lt;<span class="type">T</span>&gt; </span>{</span><br><span class="line">  <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">(value: <span class="type">T</span>)</span></span> { ... }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callLaunchCoroutin</span><span class="params">()</span></span> {</span><br><span class="line">  launchCoroutine(ProducerScope&lt;<span class="built_in">Int</span>&gt;()) {</span><br><span class="line">    println(<span class="string">"In Coroutine."</span>)</span><br><span class="line">    produce(<span class="number">1024</span>)</span><br><span class="line">    delay(<span class="number">1000</span>)<span class="comment">//错误，不能调用外部的挂起函数</span></span><br><span class="line">    produce(<span class="number">2048</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="可挂起的main-函数"><a href="#可挂起的main-函数" class="headerlink" title="可挂起的main 函数"></a>可挂起的main 函数</h3><p>从Kotlin 1.3 开始，main 可以直接被声明为挂起函数，只需要在main函数的声明前添加一个 suspend 关键字。这意味着从程序入口就能获得一个协程。我们直到，main是程序入口，所以呢，这个加了 suspend 的main函数不可能是真正的程序入口，不然 JVM 不可能认识。所以呢，无非是 编译器帮我们生成了一个真正的main方法，里面调用了一个叫做 runSuspend 函数来执行可挂起的main函数。</p>
<h2 id="函数的挂起"><a href="#函数的挂起" class="headerlink" title="函数的挂起"></a>函数的挂起</h2></body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/08/10/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/ReactNative%E7%B2%BE%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98-%E7%AC%AC1%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/10/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/ReactNative%E7%B2%BE%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98-%E7%AC%AC1%E7%AB%A0/" class="post-title-link" itemprop="url">第1章：React 与 React Native 简介</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-10 15:30:00 / 修改时间：15:30:21" itemprop="dateCreated datePublished" datetime="2021-08-10T15:30:00+08:00">2021-08-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="React简介"><a href="#React简介" class="headerlink" title="React简介"></a>React简介</h2><p>React 只专注于 MVC 框架设计模式中的 View 层面的实现。为了大大减少传统前端直接操作DOM 的昂贵花费，React 使用Virtual DOM （虚拟DOM）进行DOM的更新，实现了单向数据流传递。下图清晰地描述了 React 底层与前端浏览器的沟通机制。</p>
<p><img src="" alt="Ract框架结构"></p>
<h3 id="React的底层特性"><a href="#React的底层特性" class="headerlink" title="React的底层特性"></a>React的底层特性</h3><p>传统<strong>HTML页面</strong>需要更新页面元素时，<strong>都是将整个页面重新加载实现重绘</strong>，这个代价非常昂贵。后来有了 AJAX 这样的局部更新技术，实现了页面的异步更新，不过AJAX代码编写、维护、性能及更新粒度上还是不够完美。</p>
<p>文档对象模型(Document Object Model， DOM) 是 W3C 组织推荐的处理可扩展标志语言的标准编程接口，<strong>在 HTML 网页上，将构成页面的对象元素组织在一个树形的结构中，用来表示文档中对象的标准模型就称为 DOM</strong>。</p>
<p>React 在底层设计了虚拟DOM，虚拟DOM 与真实 DOM 相互映射，当业务逻辑修改了 Reat 组件中的 state ，<strong>React 框架diff算法会通过比较虚拟 DOM 与 真实DOM 之间的差异，找出哪些部分被修改了，最终只更新差异部分</strong>。这样实现了React 在前端中的高性能表现。</p>
<p>其实，React 并不会在state 更改的第一时间去执行 diff 算法并立即更新页面，而是将多次操作汇聚成一次批量操作，这样再次提升页面更新重绘的效率。</p>
<h2 id="React-Native-简介"><a href="#React-Native-简介" class="headerlink" title="React Native 简介"></a>React Native 简介</h2><p>第3章：React Native 工作原理与生命周期</p>
<h3 id="React-Native框架及工作原理"><a href="#React-Native框架及工作原理" class="headerlink" title="React Native框架及工作原理"></a>React Native框架及工作原理</h3><p>因为 React Native 底层为React 框架，所以，如果是UI层的变更，那么就<strong>映射为虚拟DOM后，调用diff算法计算出变动后的 JSON 映射文件，最终由Native 层将此 JSON 文件映射渲染到原生App的页面元素上</strong>，实现了在项目中只需要控制state 以及 props的变更来引起 ios /Android 平台的 UI 变更。</p>
<p>编写的 RN 代码最终会打包成 main.bundle.js 文件供App 加载，此文件可以存在App本地或者服务器上更新。</p>
<h3 id="RN-与原生平台通信"><a href="#RN-与原生平台通信" class="headerlink" title="RN 与原生平台通信"></a>RN 与原生平台通信</h3><p>RN 与原生的通信如下图所示，采用了 JavaScriptCore 作为 JS VM，中间通过 JSON 文件与 Bridge 进行通信。若使用 Chrome 进行调试，那么所有的 JavaScript 代码都将运行在 Chrome 的 V8 引擎，与原生代码通过 WebSocket 进行通信。</p>
<p><img src="" alt="RN与原生平台通信"></p>
<h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><ol>
<li><p>父子组件之间的通信</p>
<p>在RN中，可以通过 props 的形式实现父组件向子组件传递值，如下例子展示父组件通过调用子组件并赋值子组件的 name 为 React，子组件通过 this.props.name 获取父组件传递过来的 name 字符串 React：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*父子组件通信，在父组件中调用子组件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;ChildComponent name=<span class="string">'React'</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*子组件实现，通过props获取父组件传递的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildComponent</span> <span class="title">extentds</span> <span class="title">Component</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Text</span>&gt;</span> Hello {this.props.name}!<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
<ol start="2">
<li><p>子父组件通信</p>
<p>先略了</p>
</li>
</ol>
<h2 id="React-Native-中的生命周期"><a href="#React-Native-中的生命周期" class="headerlink" title="React Native 中的生命周期"></a>React Native 中的生命周期</h2><p><strong>在 RN 程序启动时，内部的虚拟 DOM 开始建立，生命周期时建立在此虚拟DOM 的整个声明周期之中</strong>，从虚拟DOM 的初始化到虚拟DOM 的卸载 ，RN 为组件的不同状态建立了不同的生命周期。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/05/05/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%95%AA%E5%A4%96%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/05/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%95%AA%E5%A4%96%E7%AF%87/" class="post-title-link" itemprop="url">番外篇：Activity LaunchMode原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-05 16:13:00 / 修改时间：16:48:52" itemprop="dateCreated datePublished" datetime="2021-05-05T16:13:00+08:00">2021-05-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>番外篇主要是看到<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/09365022adac">一篇简书上的博客</a>后，对LauncherMode的一点补充。本文只是复制这篇博客的内容，防止这篇文章被简书屏蔽(因为他有一篇文章就已经是一直审核状态了)。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道Activity的start是走到Instrumentation的execStartActivity方法中，而这里是调用了ActivityManagerNative的getDefault方法 来获得一个ActivityManagerService(以下简称AMS)的远程代理对象，要走到AMS的startActivity方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br></pre></td></tr></tbody></table></figure>

<p>这里先解释一下startActivity方法里的一些参数:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>whoThread    IApplicationThread的binder对象</td>
<td>用于AMS进行进程间通信</td>
</tr>
<tr>
<td>who    上下文对象</td>
<td>其实就是Activity</td>
</tr>
<tr>
<td>intent</td>
<td>目标intent</td>
</tr>
<tr>
<td>intent.resolveTypeIfneed</td>
<td>若没有在Manifest文件里面注明Activity的mime类型，返回null</td>
</tr>
<tr>
<td>token    Binder对象</td>
<td>通过它可以获得Activity的相关信息 后边会保存到sourceRecord这个对象里面</td>
</tr>
<tr>
<td>target</td>
<td>我们调用的Activity</td>
</tr>
<tr>
<td>requestCode</td>
<td>若没有设置结果就是小于0</td>
</tr>
<tr>
<td>0</td>
<td>flags</td>
</tr>
<tr>
<td>ProfilerInfo</td>
<td>null</td>
</tr>
<tr>
<td>options</td>
<td>是一个bunder对象，记录用intent传递的信息</td>
</tr>
</tbody></table>
<p>这里对应着AMS 中startactivity的参数</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="params"><span class="function">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">        resultWho, requestCode, startFlags, profilerInfo, options,</span><br><span class="line">        UserHandle.getCallingUserId());</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="params"><span class="function">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options, <span class="keyword">int</span> userId)</span> </span>{</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line">    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</span><br><span class="line">            <span class="keyword">false</span>, ALLOW_FULL_ONLY, <span class="string">"startActivity"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">    <span class="keyword">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent,</span><br><span class="line">            resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">            profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, options, userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后会调用ActivityStackSupervisor的startActivityMayWait方法，而ActivityStackSupervisor 就是专门管理activity的堆栈的类</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-d2e1e1e2859b5c86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/726/format/webp" alt="startActivityMayWait方法"></p>
<p>这里会先解析我们的intent来获取信息，通过调用函数resoleActivity方法获取ActivityInfo，这里主要是activity在AndroidManifest.xml里的信息</p>
<p>再往下看，进入到startActivityLocked 方法中</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-e50075b5c4539486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/777/format/webp" alt="startActivityMayWait方法"></p>
<blockquote>
<p>另提一下activity 在 AMS 中的形式是 ActivityRecord,task 在 AMS 中的形式为TaskRecord,进程在 AMS 中的管理形式为 ProcessRecord</p>
</blockquote>
<p> 我们发现这里有两个ActivityRecord对象 有sourceRecord 和resultRecord</p>
<blockquote>
<p>sourceRecord 代表的是最开始的activity<br>这就是通过resultTo这个binder对象获得Mainactivity的相关信息然后保存到这个对象中<br>resultRecord 代表的是接受启动结果的Activity<br>因为requestcode==-1 所以这里resultRecord==null</p>
</blockquote>
<p>final int launchFlags = intent.getFlags();<br>这里获取Intent的启动Flag 就是我们在Intent.setFlag里面设置的标志<br>这个函数的主要作用就是处理sourceRecord和resultRecord两个对象<br>在这里sourceRecord和resultRecord指向的应该是同一个activity</p>
<p>然后调用startActivityUncheckedLocked来处理本次的启动Activity的请求</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-59cc775b23e884c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-39391603929ddcc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p>从这里我们可以看到 获取了activity的launchModel ，也就是对launchModel的判断处理应该是在这里<br>这里先判断是否FLAG_ACTIVITY_NEW_DOCUMENT，这个平时用的比较少，在android5.0上主要是决定你的task和activity是如何展现在overview screen 中的，详细请看Android 5.0 Overview Screen–总览画面<br>再往下看</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-056e3a3f60d6acbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p>startFlags == 0 所以此时不会进入这个判断，没有设置这个FLAG_ACTIVITY_PREVIOUS_IS_TOP，所以我们的notTop==null<br>接着 系统默认addingToTask= false 默认是开启新的Task，从后面的判断也可以看出来</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-1c643a3c8fae5e94.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p>之前说过 sourceRecord就是最开始的activity 所以它不会为null，这样就到了else 中 inTask = null；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-2419c6b8b3f4c7e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/755/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p> 在这里判断了启动模式，判断当前activity的启动模式和要启动的activity的启动模式，根据相应的启动模式设置launchFlags</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-888c5f5346d10e05.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-c6f1382d01eeca2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p>这里目的是判断启动的activity是否在堆栈里存在，如果存在就直接在进行相应的操作<br>在文章开头 resultRecord 默认为null而且requestCode假如没有设置的话，requestCode小于0，所以resultRecord没有被赋值，所以我们构造ActivityRecord 时传入的是null，也就是可以进入这个if判断里<br>再往里看</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-2eb788c2a9a3dd9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/577/format/webp" alt="startActivityUncheckedLocked方法"></p>
<p>这里会判断启动的activity是否是SingleInstance，根据此进入不同的方法，目的是找到activity，如果有就返回，如果没有就返回null，先来看findTaskLocked方法</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-ea3170a8c0b3a0b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="findTaskLocked方法"></p>
<p>stack里的findTaskLocked方法比较长，顶部activity，如果没有就返回null，从注释上来看就是返回堆栈里的activity,简单说一下就是返回发起请求的activity，也是这个函数返回的activity</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the top activity in any existing task matching the given</span></span><br><span class="line"><span class="comment">     * Intent.  Returns null if no such task is found.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ActivityRecord <span class="title">findTaskLocked</span><span class="params">(ActivityRecord target)</span> </span>{</span><br><span class="line">        Intent intent = target.intent;</span><br><span class="line">        ActivityInfo info = target.info;</span><br><span class="line">        ComponentName cls = intent.getComponent();</span><br><span class="line">        <span class="keyword">if</span> (info.targetActivity != <span class="keyword">null</span>) {</span><br><span class="line">            cls = <span class="keyword">new</span> ComponentName(info.packageName, info.targetActivity);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(info.applicationInfo.uid);</span><br><span class="line">        <span class="keyword">boolean</span> isDocument = intent != <span class="keyword">null</span> &amp; intent.isDocument();</span><br><span class="line">        <span class="comment">// If documentData is non-null then it must match the existing task data.</span></span><br><span class="line">        Uri documentData = isDocument ? intent.getData() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Looking for task of "</span> + target + <span class="string">" in "</span> + <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> taskNdx = mTaskHistory.size() - <span class="number">1</span>; taskNdx &gt;= <span class="number">0</span>; --taskNdx) {</span><br><span class="line">            <span class="keyword">final</span> TaskRecord task = mTaskHistory.get(taskNdx);</span><br><span class="line">            <span class="keyword">if</span> (task.voiceSession != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// We never match voice sessions; those always run independently.</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Skipping "</span> + task + <span class="string">": voice session"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (task.userId != userId) {</span><br><span class="line">                <span class="comment">// Looking for a different task.</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Skipping "</span> + task + <span class="string">": different user"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">final</span> ActivityRecord r = task.getTopActivity();</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span> || r.finishing || r.userId != userId ||</span><br><span class="line">                    r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Skipping "</span> + task + <span class="string">": mismatch root "</span> + r);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Intent taskIntent = task.intent;</span><br><span class="line">            <span class="keyword">final</span> Intent affinityIntent = task.affinityIntent;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> taskIsDocument;</span><br><span class="line">            <span class="keyword">final</span> Uri taskDocumentData;</span><br><span class="line">            <span class="keyword">if</span> (taskIntent != <span class="keyword">null</span> &amp;&amp; taskIntent.isDocument()) {</span><br><span class="line">                taskIsDocument = <span class="keyword">true</span>;</span><br><span class="line">                taskDocumentData = taskIntent.getData();</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (affinityIntent != <span class="keyword">null</span> &amp;&amp; affinityIntent.isDocument()) {</span><br><span class="line">                taskIsDocument = <span class="keyword">true</span>;</span><br><span class="line">                taskDocumentData = affinityIntent.getData();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                taskIsDocument = <span class="keyword">false</span>;</span><br><span class="line">                taskDocumentData = <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Comparing existing cls="</span></span><br><span class="line">                    + taskIntent.getComponent().flattenToShortString()</span><br><span class="line">                    + <span class="string">"/aff="</span> + r.task.rootAffinity + <span class="string">" to new cls="</span></span><br><span class="line">                    + intent.getComponent().flattenToShortString() + <span class="string">"/aff="</span> + info.taskAffinity);</span><br><span class="line">            <span class="keyword">if</span> (!isDocument &amp;&amp; !taskIsDocument &amp;&amp; task.rootAffinity != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (task.rootAffinity.equals(target.taskAffinity)) {</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Found matching affinity!"</span>);</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (taskIntent != <span class="keyword">null</span> &amp;&amp; taskIntent.getComponent() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    taskIntent.getComponent().compareTo(cls) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    Objects.equals(documentData, taskDocumentData)) {</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Found matching class!"</span>);</span><br><span class="line">                <span class="comment">//dump();</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"For Intent "</span> + intent + <span class="string">" bringing to top: "</span></span><br><span class="line">                        + r.intent);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (affinityIntent != <span class="keyword">null</span> &amp;&amp; affinityIntent.getComponent() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    affinityIntent.getComponent().compareTo(cls) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    Objects.equals(documentData, taskDocumentData)) {</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Found matching class!"</span>);</span><br><span class="line">                <span class="comment">//dump();</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"For Intent "</span> + intent + <span class="string">" bringing to top: "</span></span><br><span class="line">                        + r.intent);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_TASKS) {</span><br><span class="line">                Slog.d(TAG, <span class="string">"Not a match: "</span> + task);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里简单说一下，先是从mTaskHistory中遍历得到一个任务Task，并根据userid找到当前的task ，找到这个任务的顶部activity，并且保证它启动模式不是singleInstance，都满足了返回以下条件的activity</p>
<p>再回到刚才的方法往下看</p>
<p>这里先去activitystack里的moveToFront()方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the caller has requested that the target task be</span></span><br><span class="line"><span class="comment">// reset, then do so.</span></span><br><span class="line"><span class="keyword">if</span> ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != <span class="number">0</span>) {</span><br><span class="line">    intentActivity = targetStack.resetTaskIfNeededLocked(intentActivity, r);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">// We don't need to start a new activity, and</span></span><br><span class="line">    <span class="comment">// the client said not to do anything if that</span></span><br><span class="line">    <span class="comment">// is the case, so this is it!  And for paranoia, make</span></span><br><span class="line">    <span class="comment">// sure we have correctly resumed the top activity.</span></span><br><span class="line">    <span class="keyword">if</span> (doResume) {</span><br><span class="line">        resumeTopActivitiesLocked(targetStack, <span class="keyword">null</span>, options);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        ActivityOptions.abort(options);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ActivityManager.START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> ((launchFlags &amp;</span><br><span class="line">        (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK))</span><br><span class="line">        == (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK)) {</span><br><span class="line">    <span class="comment">// The caller has requested to completely replace any</span></span><br><span class="line">    <span class="comment">// existing task with its new activity.  Well that should</span></span><br><span class="line">    <span class="comment">// not be too hard...</span></span><br><span class="line">    reuseTask = intentActivity.task;</span><br><span class="line">    reuseTask.performClearTaskLocked();</span><br><span class="line">    reuseTask.setIntent(r);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> ((launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != <span class="number">0</span></span><br><span class="line">        || launchSingleInstance || launchSingleTask) {</span><br><span class="line">    <span class="comment">// In this situation we want to remove all activities</span></span><br><span class="line">    <span class="comment">// from the task up to the one being started.  In most</span></span><br><span class="line">    <span class="comment">// cases this means we are resetting the task to its</span></span><br><span class="line">    <span class="comment">// initial state.</span></span><br><span class="line">    ActivityRecord top =</span><br><span class="line">            intentActivity.task.performClearTaskLocked(r, launchFlags);</span><br><span class="line">    <span class="keyword">if</span> (top != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (top.frontOfTask) {</span><br><span class="line">            <span class="comment">// Activity aliases may mean we use different</span></span><br><span class="line">            <span class="comment">// intents for the top activity, so make sure</span></span><br><span class="line">            <span class="comment">// the task now has the identity of the new</span></span><br><span class="line">            <span class="comment">// intent.</span></span><br><span class="line">            top.task.setIntent(r);</span><br><span class="line">        }</span><br><span class="line">        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,</span><br><span class="line">                r, top.task);</span><br><span class="line">        top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// A special case: we need to</span></span><br><span class="line">        <span class="comment">// start the activity because it is not currently</span></span><br><span class="line">        <span class="comment">// running, and the caller has asked to clear the</span></span><br><span class="line">        <span class="comment">// current task to have this activity at the top.</span></span><br><span class="line">        addingToTask = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// Now pretend like this activity is being started</span></span><br><span class="line">        <span class="comment">// by the top of its task, so it is put in the</span></span><br><span class="line">        <span class="comment">// right place.</span></span><br><span class="line">        sourceRecord = intentActivity;</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (r.realActivity.equals(intentActivity.task.realActivity)) {</span><br><span class="line">    <span class="comment">// In this case the top activity on the task is the</span></span><br><span class="line">    <span class="comment">// same as the one being launched, so we take that</span></span><br><span class="line">    <span class="comment">// as a request to bring the task to the foreground.</span></span><br><span class="line">    <span class="comment">// If the top activity in the task is the root</span></span><br><span class="line">    <span class="comment">// activity, deliver this new intent to it if it</span></span><br><span class="line">    <span class="comment">// desires.</span></span><br><span class="line">    <span class="keyword">if</span> (((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span> || launchSingleTop)</span><br><span class="line">            &amp;&amp; intentActivity.realActivity.equals(r.realActivity)) {</span><br><span class="line">        ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r,</span><br><span class="line">                intentActivity.task);</span><br><span class="line">        <span class="keyword">if</span> (intentActivity.frontOfTask) {</span><br><span class="line">            intentActivity.task.setIntent(r);</span><br><span class="line">        }</span><br><span class="line">        intentActivity.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!r.intent.filterEquals(intentActivity.task.intent)) {</span><br><span class="line">        <span class="comment">// In this case we are launching the root activity</span></span><br><span class="line">        <span class="comment">// of the task, but with a different intent.  We</span></span><br><span class="line">        <span class="comment">// should start a new instance on top.</span></span><br><span class="line">        addingToTask = <span class="keyword">true</span>;</span><br><span class="line">        sourceRecord = intentActivity;</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">// In this case an activity is being launched in to an</span></span><br><span class="line">    <span class="comment">// existing task, without resetting that task.  This</span></span><br><span class="line">    <span class="comment">// is typically the situation of launching an activity</span></span><br><span class="line">    <span class="comment">// from a notification or shortcut.  We want to place</span></span><br><span class="line">    <span class="comment">// the new activity on top of the current task.</span></span><br><span class="line">    addingToTask = <span class="keyword">true</span>;</span><br><span class="line">    sourceRecord = intentActivity;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (!intentActivity.task.rootWasReset) {</span><br><span class="line">    <span class="comment">// In this case we are launching in to an existing task</span></span><br><span class="line">    <span class="comment">// that has not yet been started from its front door.</span></span><br><span class="line">    <span class="comment">// The current task has been brought to the front.</span></span><br><span class="line">    <span class="comment">// Ideally, we'd probably like to place this new task</span></span><br><span class="line">    <span class="comment">// at the bottom of its stack, but that's a little hard</span></span><br><span class="line">    <span class="comment">// to do with the current organization of the code so</span></span><br><span class="line">    <span class="comment">// for now we'll just drop it.</span></span><br><span class="line">    intentActivity.task.setIntent(r);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!addingToTask &amp;&amp; reuseTask == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="comment">// We didn't do anything...  but it was needed (a.k.a., client</span></span><br><span class="line">    <span class="comment">// don't use that intent!)  And for paranoia, make</span></span><br><span class="line">    <span class="comment">// sure we have correctly resumed the top activity.</span></span><br><span class="line">    <span class="keyword">if</span> (doResume) {</span><br><span class="line">        targetStack.resumeTopActivityLocked(<span class="keyword">null</span>, options);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        ActivityOptions.abort(options);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ActivityManager.START_TASK_TO_FRONT;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里主要看</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-89af170c52d6ebd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/612/format/webp" alt="代码片段"></p>
<p>这里走到了ActivityStack的performClearTaskLocked方法里</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Perform clear operation as requested by</span></span><br><span class="line"><span class="comment">    * {<span class="doctag">@link</span> Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the</span></span><br><span class="line"><span class="comment">    * stack to the given task, then look for</span></span><br><span class="line"><span class="comment">    * an instance of that activity in the stack and, if found, finish all</span></span><br><span class="line"><span class="comment">    * activities on top of it and return the instance.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> newR Description of the new activity being started.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> Returns the old activity that should be continued to be used,</span></span><br><span class="line"><span class="comment">    * or null if none was found.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> ActivityRecord <span class="title">performClearTaskLocked</span><span class="params">(ActivityRecord newR, <span class="keyword">int</span> launchFlags)</span> </span>{</span><br><span class="line">       <span class="keyword">int</span> numActivities = mActivities.size();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> activityNdx = numActivities - <span class="number">1</span>; activityNdx &gt;= <span class="number">0</span>; --activityNdx) {</span><br><span class="line">           ActivityRecord r = mActivities.get(activityNdx);</span><br><span class="line">           <span class="keyword">if</span> (r.finishing) {</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">if</span> (r.realActivity.equals(newR.realActivity)) {</span><br><span class="line">               <span class="comment">// Here it is!  Now finish everything in front...</span></span><br><span class="line">               <span class="keyword">final</span> ActivityRecord ret = r;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> (++activityNdx; activityNdx &lt; numActivities; ++activityNdx) {</span><br><span class="line">                   r = mActivities.get(activityNdx);</span><br><span class="line">                   <span class="keyword">if</span> (r.finishing) {</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   }</span><br><span class="line">                   ActivityOptions opts = r.takeOptionsLocked();</span><br><span class="line">                   <span class="keyword">if</span> (opts != <span class="keyword">null</span>) {</span><br><span class="line">                       ret.updateOptionsLocked(opts);</span><br><span class="line">                   }</span><br><span class="line">                   <span class="keyword">if</span> (stack.finishActivityLocked(r, Activity.RESULT_CANCELED, <span class="keyword">null</span>, <span class="string">"clear"</span>,</span><br><span class="line">                           <span class="keyword">false</span>)) {</span><br><span class="line">                       --activityNdx;</span><br><span class="line">                       --numActivities;</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Finally, if this is a normal launch mode (that is, not</span></span><br><span class="line">               <span class="comment">// expecting onNewIntent()), then we will finish the current</span></span><br><span class="line">               <span class="comment">// instance of the activity so a new fresh one can be started.</span></span><br><span class="line">               <span class="keyword">if</span> (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE</span><br><span class="line">                       &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) == <span class="number">0</span>) {</span><br><span class="line">                   <span class="keyword">if</span> (!ret.finishing) {</span><br><span class="line">                       stack.finishActivityLocked(ret, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                               <span class="string">"clear"</span>, <span class="keyword">false</span>);</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> ret;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<p>这里就是根据ID找到等于参数taskId的任务，然后在这个任务中查找是否已经存在即将要启动的Activity的实例，如果存在，就会把这个Actvity实例上面直到任务堆栈顶端的Activity通过调用finishActivityLocked函数将它们结束掉。</p>
<blockquote>
<p>在这里便引出了manifest文件中<activity>的一个重要属性，taskAffinity。在官方文档中可以得到关于taskAffinity的以下信息</activity></p>
</blockquote>
<ul>
<li>taskAffinity表示当前activity具有亲和力的一个任务（原句为The task that the activity has an affinity for.），大致可以这样理解，这个 taskAffinity表示一个任务，这个任务就是当前activity所在的任务。     </li>
</ul>
<blockquote>
<p>在概念上，具有相同的affinity的activity（即设置了相同taskAffinity属性的activity）属于同一个任务。    </p>
</blockquote>
<ul>
<li>一个任务的affinity决定于这个任务的根activity（root activity）的taskAffinity。     </li>
<li>这个属性决定两件事：当activity被re-parent时，它可以被re-paren哪个任务中；当activity以FLAG_ACTIVITY_NEW_TASK标志启动时，它会被启动到哪个任务中。（这个比较 难以理解，请结合<activity>中的属性allowTaskReparenting和Intent中的标志 FLAG_ACTIVITY_NEW_TASK加以理解）</activity></li>
<li>默认情况下，一个应用中的所有activity具有相同的taskAffinity，即应用程序的包名。我们可以通过设置不同的taskAffinity属性给应用中的activity分组，也可以把不同的 应用中的activity的taskAffinity设置成相同的值。<br>为一个activity的taskAffinity设置一个空字符串，表明这个activity不属于任何task。<br>回到前面的startActivityUncheckedLocked函数中，这里的变量top就为null了，于是执行下面的else语句</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1212336-0cc6029d58f8217d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/538/format/webp" alt="代码片段"></p>
<p>所以 此时将addintToTask=true 并且sourceRecord = 我们的activity，再往下看</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r.packageName != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="comment">// If the activity being launched is the same as the one currently</span></span><br><span class="line">    <span class="comment">// at the top, then we need to check if it should only be launched</span></span><br><span class="line">    <span class="comment">// once.</span></span><br><span class="line">    ActivityStack topStack = getFocusedStack();</span><br><span class="line">    ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(notTop);</span><br><span class="line">    <span class="keyword">if</span> (top != <span class="keyword">null</span> &amp;&amp; r.resultTo == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) {</span><br><span class="line">            <span class="keyword">if</span> (top.app != <span class="keyword">null</span> &amp;&amp; top.app.thread != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span></span><br><span class="line">                    || launchSingleTop || launchSingleTask) {</span><br><span class="line">                    ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, top,</span><br><span class="line">                            top.task);</span><br><span class="line">                    <span class="comment">// For paranoia, make sure we have correctly</span></span><br><span class="line">                    <span class="comment">// resumed the top activity.</span></span><br><span class="line">                    topStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (doResume) {</span><br><span class="line">                        resumeTopActivitiesLocked();</span><br><span class="line">                    }</span><br><span class="line">                    ActivityOptions.abort(options);</span><br><span class="line">                    <span class="keyword">if</span> ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) {</span><br><span class="line">                        <span class="comment">// We don't need to start a new activity, and</span></span><br><span class="line">                        <span class="comment">// the client said not to do anything if that</span></span><br><span class="line">                        <span class="comment">// is the case, so this is it!</span></span><br><span class="line">                        <span class="keyword">return</span> ActivityManager.START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">                    }</span><br><span class="line">                    top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                    <span class="keyword">return</span> ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">if</span> (r.resultTo != <span class="keyword">null</span>) {</span><br><span class="line">        r.resultTo.task.stack.sendActivityResultLocked(-<span class="number">1</span>, r.resultTo, r.resultWho,</span><br><span class="line">                r.requestCode, Activity.RESULT_CANCELED, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    ActivityOptions.abort(options);</span><br><span class="line">    <span class="keyword">return</span> ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>根据注释我们能看出这个方法是检查当前任务的顶端是否是我们要启动的activity，接着往下看，便是启动activity</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">boolean</span> newTask = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> keepCurTransition = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    TaskRecord taskToAffiliate = launchTaskBehind &amp;&amp; sourceRecord != <span class="keyword">null</span> ?</span><br><span class="line">            sourceRecord.task : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Should this be considered a new task?</span></span><br><span class="line">    <span class="keyword">if</span> (r.resultTo == <span class="keyword">null</span> &amp;&amp; inTask == <span class="keyword">null</span> &amp;&amp; !addingToTask</span><br><span class="line">            &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (isLockTaskModeViolation(reuseTask)) {</span><br><span class="line">            Slog.e(TAG, <span class="string">"Attempted Lock Task Mode violation r="</span> + r);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">        }</span><br><span class="line">        newTask = <span class="keyword">true</span>;</span><br><span class="line">        targetStack = adjustStackFocus(r, newTask);</span><br><span class="line">        <span class="keyword">if</span> (!launchTaskBehind) {</span><br><span class="line">            targetStack.moveToFront();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (reuseTask == <span class="keyword">null</span>) {</span><br><span class="line">            r.setTask(targetStack.createTaskRecord(getNextTaskId(),</span><br><span class="line">                    newTaskInfo != <span class="keyword">null</span> ? newTaskInfo : r.info,</span><br><span class="line">                    newTaskIntent != <span class="keyword">null</span> ? newTaskIntent : intent,</span><br><span class="line">                    voiceSession, voiceInteractor, !launchTaskBehind <span class="comment">/* toTop */</span>),</span><br><span class="line">                    taskToAffiliate);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_TASKS) Slog.v(TAG, <span class="string">"Starting new activity "</span> + r + <span class="string">" in new task "</span> +</span><br><span class="line">                    r.task);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            r.setTask(reuseTask, taskToAffiliate);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!movedHome) {</span><br><span class="line">            <span class="keyword">if</span> ((launchFlags &amp;</span><br><span class="line">                    (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_TASK_ON_HOME))</span><br><span class="line">                    == (Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_TASK_ON_HOME)) {</span><br><span class="line">                <span class="comment">// Caller wants to appear on home activity, so before starting</span></span><br><span class="line">                <span class="comment">// their own activity we will bring home to the front.</span></span><br><span class="line">                r.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">final</span> TaskRecord sourceTask = sourceRecord.task;</span><br><span class="line">        <span class="keyword">if</span> (isLockTaskModeViolation(sourceTask)) {</span><br><span class="line">            Slog.e(TAG, <span class="string">"Attempted Lock Task Mode violation r="</span> + r);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">        }</span><br><span class="line">        targetStack = sourceTask.stack;</span><br><span class="line">        targetStack.moveToFront();</span><br><span class="line">        <span class="keyword">final</span> TaskRecord topTask = targetStack.topTask();</span><br><span class="line">        <span class="keyword">if</span> (topTask != sourceTask) {</span><br><span class="line">            targetStack.moveTaskToFrontLocked(sourceTask, r, options);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            mWindowManager.moveTaskToTop(topTask.taskId);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// In this case, we are adding the activity to an existing</span></span><br><span class="line">            <span class="comment">// task, but the caller has asked to clear that task if the</span></span><br><span class="line">            <span class="comment">// activity is already running.</span></span><br><span class="line">            ActivityRecord top = sourceTask.performClearTaskLocked(r, launchFlags);</span><br><span class="line">            keepCurTransition = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (top != <span class="keyword">null</span>) {</span><br><span class="line">                ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);</span><br><span class="line">                top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                <span class="comment">// For paranoia, make sure we have correctly</span></span><br><span class="line">                <span class="comment">// resumed the top activity.</span></span><br><span class="line">                targetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (doResume) {</span><br><span class="line">                    targetStack.resumeTopActivityLocked(<span class="keyword">null</span>);</span><br><span class="line">                }</span><br><span class="line">                ActivityOptions.abort(options);</span><br><span class="line">                <span class="keyword">return</span> ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!addingToTask &amp;&amp;</span><br><span class="line">                (launchFlags&amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// In this case, we are launching an activity in our own task</span></span><br><span class="line">            <span class="comment">// that may already be running somewhere in the history, and</span></span><br><span class="line">            <span class="comment">// we want to shuffle it to the front of the stack if so.</span></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord top = sourceTask.findActivityInHistoryLocked(r);</span><br><span class="line">            <span class="keyword">if</span> (top != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">final</span> TaskRecord task = top.task;</span><br><span class="line">                task.moveActivityToFrontLocked(top);</span><br><span class="line">                ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r, task);</span><br><span class="line">                top.updateOptionsLocked(options);</span><br><span class="line">                top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                targetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (doResume) {</span><br><span class="line">                    targetStack.resumeTopActivityLocked(<span class="keyword">null</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// An existing activity is starting this new activity, so we want</span></span><br><span class="line">        <span class="comment">// to keep the new one in the same task as the one that is starting</span></span><br><span class="line">        <span class="comment">// it.</span></span><br><span class="line">        r.setTask(sourceTask, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_TASKS) Slog.v(TAG, <span class="string">"Starting new activity "</span> + r</span><br><span class="line">                + <span class="string">" in existing task "</span> + r.task + <span class="string">" from source "</span> + sourceRecord);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (inTask != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// The calling is asking that the new activity be started in an explicit</span></span><br><span class="line">        <span class="comment">// task it has provided to us.</span></span><br><span class="line">        <span class="keyword">if</span> (isLockTaskModeViolation(inTask)) {</span><br><span class="line">            Slog.e(TAG, <span class="string">"Attempted Lock Task Mode violation r="</span> + r);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">        }</span><br><span class="line">        targetStack = inTask.stack;</span><br><span class="line">        targetStack.moveTaskToFrontLocked(inTask, r, options);</span><br><span class="line">        targetStack.moveToFront();</span><br><span class="line">        mWindowManager.moveTaskToTop(inTask.taskId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check whether we should actually launch the new activity in to the task,</span></span><br><span class="line">        <span class="comment">// or just reuse the current activity on top.</span></span><br><span class="line">        ActivityRecord top = inTask.getTopActivity();</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="keyword">null</span> &amp;&amp; top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) {</span><br><span class="line">            <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span></span><br><span class="line">                    || launchSingleTop || launchSingleTask) {</span><br><span class="line">                ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task);</span><br><span class="line">                <span class="keyword">if</span> ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// We don't need to start a new activity, and</span></span><br><span class="line">                    <span class="comment">// the client said not to do anything if that</span></span><br><span class="line">                    <span class="comment">// is the case, so this is it!</span></span><br><span class="line">                    <span class="keyword">return</span> ActivityManager.START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">                }</span><br><span class="line">                top.deliverNewIntentLocked(callingUid, r.intent);</span><br><span class="line">                <span class="keyword">return</span> ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!addingToTask) {</span><br><span class="line">            <span class="comment">// We don't actually want to have this activity added to the task, so just</span></span><br><span class="line">            <span class="comment">// stop here but still tell the caller that we consumed the intent.</span></span><br><span class="line">            ActivityOptions.abort(options);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_TASK_TO_FRONT;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        r.setTask(inTask, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_TASKS) Slog.v(TAG, <span class="string">"Starting new activity "</span> + r</span><br><span class="line">                + <span class="string">" in explicit task "</span> + r.task);</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// This not being started from an existing activity, and not part</span></span><br><span class="line">        <span class="comment">// of a new task...  just put it in the top task, though these days</span></span><br><span class="line">        <span class="comment">// this case should never happen.</span></span><br><span class="line">        targetStack = adjustStackFocus(r, newTask);</span><br><span class="line">        targetStack.moveToFront();</span><br><span class="line">        ActivityRecord prev = targetStack.topActivity();</span><br><span class="line">        r.setTask(prev != <span class="keyword">null</span> ? prev.task : targetStack.createTaskRecord(getNextTaskId(),</span><br><span class="line">                        r.info, intent, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">true</span>), <span class="keyword">null</span>);</span><br><span class="line">        mWindowManager.moveTaskToTop(r.task.taskId);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_TASKS) Slog.v(TAG, <span class="string">"Starting new activity "</span> + r</span><br><span class="line">                + <span class="string">" in new guessed "</span> + r.task);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName,</span><br><span class="line">            intent, r.getUriPermissionsLocked(), r.userId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span> &amp;&amp; sourceRecord.isRecentsActivity()) {</span><br><span class="line">        r.task.setTaskToReturnTo(RECENTS_ACTIVITY_TYPE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (newTask) {</span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, r.userId, r.task.taskId);</span><br><span class="line">    }</span><br><span class="line">    ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task);</span><br><span class="line">    targetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">    targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</span><br><span class="line">    <span class="keyword">if</span> (!launchTaskBehind) {</span><br><span class="line">        <span class="comment">// Don't set focus on an activity that's going to the back.</span></span><br><span class="line">        mService.setFocusedActivityLocked(r);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ActivityManager.START_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>首先将newTask变量初始化为false，表示不要在新的任务中启动Activity。由于前面的已经把addingToTask设置为true，因此，这里会执行中间的else if语句，即这里会把r.task设置为sourceRecord.task，即把即将启动的Activity放在原Activity所在的任务中启动。最后，就是调用startActivityLocked函数继续进行启动Activity的操作了</p>
<p>声明： 以上内容拷贝自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/09365022adac">简书作者jiantao的文章，供自己学习使用</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/04/06/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC22%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/06/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC22%E7%AB%A0/" class="post-title-link" itemprop="url">第22章：插件化技术总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-06 21:52:00 / 修改时间：21:53:29" itemprop="dateCreated datePublished" datetime="2021-04-06T21:52:00+08:00">2021-04-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>这章是重新梳理插件化技术的整体思路</p>
<h2 id="插件的工程化"><a href="#插件的工程化" class="headerlink" title="插件的工程化"></a>插件的工程化</h2><p>插件化技术分为宿主HostApp 和 插件Plugin1这两个 apk，有时候还有 MyPluginLibrary ，宿主和插件都要引用它。</p>
<h2 id="加载插件中的类"><a href="#加载插件中的类" class="headerlink" title="加载插件中的类"></a>加载插件中的类</h2><p>HostApp 想要使用 Plugin1 中的类，还使用 HostApp 中的 ClassLoder 是不行的，由此缠身很多种解决方案：</p>
<ul>
<li>最直接的就是，在反射插件中的类时，使用 Plugin1.apk 对应的 ClassLoader (参考第6章)    </li>
<li>无论是宿主还是插件，他们各自的 ClassLoader 都对应一个 dex 数组，把这些插件的dex数组都合并到宿主的 dex 数组中，那么，宿主App就可以加载任何类(参考9.3节)。     </li>
<li>自定义一个ClassLoader，取代原先宿主的ClassLoader 。同时在自定义的 ClassLoader 中放一个集合，承载所有插件的 ClassLoader 。那么自定义的 ClassLoader 在加载任何一个类的时候，无论是插件还是宿主的类，都会现在宿主中找，如果没有，再遍历 ClassLoader 集合，看哪个 ClassLoader 能加载这个类(参考9.36节)。    </li>
</ul>
<h2 id="哪些地方可以Hook"><a href="#哪些地方可以Hook" class="headerlink" title="哪些地方可以Hook"></a>哪些地方可以Hook</h2><p>关于Hook 的技术可以参考第4章，Hook可以分为三类：</p>
<ul>
<li>在 App 中使用的类，可以Hook。Android 系统源码中被标记为hide的方法和类，<strong>我们可以通过反射使用它们，但是不能Hook</strong>。还有一些类，比如 Instrumentation 和 Callback ，在App中也能用，因此可以Hook替换。             </li>
<li>实现了接口的类，可以Hook。虽然大部分类和方法都标记为hide，但是<strong>只要合格类实现了一个接口，我们就可以借助 Proxy.newProxyInstance 方法去截获它的方法</strong>，比较典型的是 IActivityManager 接口，以及实现这个接口的 AMN 。    </li>
<li>集合。 没办法Hook一个标记为hide 的类，但是如果Android源码中某个类<strong>拥有集合变量的时候，我们可以反射构造出一个对象，然后还是通过反射添加到这个集合中</strong>。典型的是，穿件一个 LoadedApk ，把它事先放在 mPackages 缓存中，这样就能直接命中缓存(参考9.2节)。</li>
</ul>
<h2 id="Activity-的插件化解决方案"><a href="#Activity-的插件化解决方案" class="headerlink" title="Activity 的插件化解决方案"></a>Activity 的插件化解决方案</h2><p>从大方向来讲，分为动态替换和静态代理两种：</p>
<ul>
<li>动态替换：这是“占位”思想。HostApp中声明一个用于占位的 StubActivity ，启动插件中的ActivityA，但是告诉AMS启动的是 StubActivity ，欺骗成功之后，在即将启动Activity时，再把 StubActivity 换回 ActivityA(参考第9章)。      </li>
<li>静态代理。这是一种牵线木偶的思想，在HostApp中设计一个 ProxyActivity ，由他来决定启动插件中的哪个 Activity。<strong>插件中的Activity都是没有生命的，得在ProxyActivity 生命周期中，调用插件Activity 的生命周期函数</strong>(参考9.5节)。</li>
</ul>
<p>此外，还需要解决 LaunchMode 问题，解决方案参考 9.5 节。</p>
<h2 id="资源的解决方案"><a href="#资源的解决方案" class="headerlink" title="资源的解决方案"></a>资源的解决方案</h2><p>资源主要为Activity 服务。主要有两种解决方案：</p>
<ul>
<li>进入Plugin1 ，则加载Plugin1的资源，反射调用 AssetManager 的 addAssetPath 方法，参数是 Plugin1.apk 的路径。每次进入或者离开插件，都要切换资源。这是一件很繁琐的事情(参考第7章)。      </li>
<li>事先把 HostApp的资源以及所有插件的资源都通过 AssetManager 的 addAssetPath 方法添加到一个全局变量中。这样，在插件 Activity 的基类中，重写 Activity 的 getResource 方法，从这个全局变量中提取资源。</li>
</ul>
<p>针对方案2，由于资源合并到一起，就可能发生资源id冲突，由此产生多种解决方案：</p>
<ol>
<li>修改aapt，更改id的前缀(参考15.2节)    </li>
<li>修改resources.arsc，在 aapt 执行完成后，修改生成的文件(参考21章)    </li>
<li>通过 public.xml 固定 plugin1 中所有的资源。这种方案不现实，针对固定一个资源的id还是很好的解决方案。</li>
</ol>
<h2 id="Fragment是哪个门派"><a href="#Fragment是哪个门派" class="headerlink" title="Fragment是哪个门派"></a>Fragment是哪个门派</h2><p>Fragment 与Activity 的最大区别，就是后者的一举一动需要和 AMS 交互，而Fragment不用。这种方案整个应用只有一个Activity ，Fragment 可以在 Host 中或者 插件中，只要使用合适的 ClassLoader 加载插件中的类，使用合适的 AssetManager 加载插件中的资源，就是一个完美的解决方案。可以参考 16 章。</p>
<h2 id="Service、ContentProvider-和-BroadcastReceiver-插件化通用方案"><a href="#Service、ContentProvider-和-BroadcastReceiver-插件化通用方案" class="headerlink" title="Service、ContentProvider 和 BroadcastReceiver 插件化通用方案"></a>Service、ContentProvider 和 BroadcastReceiver 插件化通用方案</h2><p>因为这三者的数量并不多，插件化中也不会动态新增一个组件，所以最简单的方案是：在HostApp 的 AndroidManifest 文件中事先声明这些组件。缺点是不能动态新增一个组件。参考 8.1节。</p>
<h2 id="特定于Service-的插件化解决方案"><a href="#特定于Service-的插件化解决方案" class="headerlink" title="特定于Service 的插件化解决方案"></a>特定于Service 的插件化解决方案</h2><p>如果不事先在HostApp中声明插件的Service，那么Service 也有自己的解决方案：</p>
<ul>
<li>动态代理。也是欺上瞒下的思路。Service 不同于 Activity ，一个StubActivity 可以对应多个插件Activity，但是StubService 和插件Service 只能一一对应，所以应该在HostApp 中声明多个 StubService。参考第10章。</li>
<li>静态代理，牵线木偶思想。创建一个ProxyService，由 ProxyService 来启动插件中的Service，缺点是插件中有几个Service，HostApp 中就要有相同数量的 ProxyService。，参见 14.1和 14.2.</li>
<li>结合前两种，能否在HostApp中只声明一个Stubservice。参考 14.4</li>
</ul>
<h2 id="特定于BroadcastReceiver-的插件化解决方案"><a href="#特定于BroadcastReceiver-的插件化解决方案" class="headerlink" title="特定于BroadcastReceiver 的插件化解决方案"></a>特定于BroadcastReceiver 的插件化解决方案</h2><p>它的插件化解决方案是把静态的Receiver 转换为动态的Receiver。</p>
<h2 id="特定于ContentProvider-的插件化解决方案"><a href="#特定于ContentProvider-的插件化解决方案" class="headerlink" title="特定于ContentProvider 的插件化解决方案"></a>特定于ContentProvider 的插件化解决方案</h2><p>占位思想。HostApp 中由 StubContentProvider 来欺骗 AMS，而实际执行的是 插件中的 ContentProvider 。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/04/06/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC15%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/06/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC15%E7%AB%A0/" class="post-title-link" itemprop="url">第15章：再谈资源</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-06 21:29:00 / 修改时间：22:05:51" itemprop="dateCreated datePublished" datetime="2021-04-06T21:29:00+08:00">2021-04-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Android-App-打包流程"><a href="#Android-App-打包流程" class="headerlink" title="Android App 打包流程"></a>Android App 打包流程</h2><p>早期Android打包都是基于Ant来做，为此我们需要熟悉Android App 打包的每一个过程。随着Gradle的问世，打包简化为几行配置代码。一套完整的Android App 打包流程如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8C%87%E5%8D%97/%E7%AC%AC15%E7%AB%A0/Android%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B.png" alt="Android打包流程图"></p>
<p>介绍下各部分的作用：</p>
<ul>
<li>aapt： 为res目录下的资源生成 R.java 文件，<strong>同时为AndroidManifest生成Manifest.java文件</strong>     </li>
<li>aidl： 把项目中自定义的aidl文件生成相应的java代码文件    </li>
<li>javac： 把项目中所有的Java 代码编译成 class 文件。包括3部分： 自己写的代码；aapt生成的代码；aidl生成的Java文件    </li>
<li>proguard： 混淆的同时生成proguardMapping.txt，这个步骤是可选的    </li>
<li>dex： 把所有的class文件(包括第三方库的class 文件)转换为dex文件      </li>
<li>aapt： 这里还是使用aapt，这里是它的另一个功能：打包。即将res目录下的资源、assets下的文件，打包成一个 .ap_ 文件     </li>
<li>apkbuilder：将所有的dex、ap_文件、AndroidManifest.xml 打包为.apk文件，此时未签名       </li>
<li>jarsigner： 签名    </li>
<li>zipalign： 对齐，以便运行时节省内存           </li>
</ul>
<h2 id="资源冲突解决方案一：修改AAPT"><a href="#资源冲突解决方案一：修改AAPT" class="headerlink" title="资源冲突解决方案一：修改AAPT"></a>资源冲突解决方案一：修改AAPT</h2><p>插件中的资源id可能会和宿主资源id是同一个值，为了解决资源id冲突，有3中解决方案：</p>
<ul>
<li>修改打包流程中的aapt命令，为插件资源id指定 0x71 之类的前缀，就可以避免冲突     </li>
<li>仍然是将插件资源的id前缀改为 0x71，但是在Android打包生成 resources.arsc 文件后，对这个文件进行修改(具体可见21.2节)       </li>
<li>进入到哪个插件，就为这个插件生成新的 AssetManager 和 Resources 对象，使用这两个新对象加载资源，就只能是插件中的资源，永远不会和宿主中冲突(详见 7.2)</li>
</ul>
<h3 id="修改并生成新的aapt命令"><a href="#修改并生成新的aapt命令" class="headerlink" title="修改并生成新的aapt命令"></a>修改并生成新的aapt命令</h3><p>R文件中有十六进制整数变量，内容如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码</span></span><br></pre></td></tr></tbody></table></figure>

<p>这些十六进制的变量，由三部分组成： packageId(apk包id，默认 0x7f) + typeId(资源类型，如attr=0x01，drawable=0x02，还有layout、string等) + entryId(typeId下的资源编码，从0开始递增)。以 0x7f0b006d 为例，packageId 为 0x7f，typeId为 0b，entryId 为 006d。</p>
<p>插件中为防止资源冲突，会为每个插件设置不同的packageId，比如游戏大厅中，斗地主插件可能是 0x71开头，斗牛可能是 0x72。为asset 生成 R 文件 是通过 aapt 完成的，为了实现上述目的，我们要修改 aapt 源码，定位到 Android SDK，找到 aapt 目录，里面有一堆 C 代码， 命令行工具就是用这些代码编译成的，可以在这个目录直接搜索 0x7f，在 ResourcesTable.cpp 中可以找到如下代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br></pre></td></tr></tbody></table></figure>

<p>在 ResourcesTable 的构造函数中，有一个 Bundle 类型的参数，其次，判断 mPackageType 如果是 App，则都是 0x7f，此外 0x01 和 0x00 都被系统占用了，所以我们不要将这两个值设置为插件的 id前缀(事实上，有些手机厂商会占用其他的一些值，为了保险，我们一般只使用 0x71~0xff 作为插件的前缀)。修改 AAPT 的代码，基本思路如下：</p>
<ol>
<li>在 aapt 的命令行参数中传递打包时的前缀   </li>
<li>把这个值设置给 Bundle 实体的 mApkModule 字段，作为 ResourcesTable 的构造函数参数传入        </li>
<li>在 ResourcesTable 构造函数读取 mApkModule 值，也就是前缀值，设置给 packageId    </li>
</ol>
<p>实现代码： 略</p>
<h3 id="在插件化项目中使用新的aapt命令"><a href="#在插件化项目中使用新的aapt命令" class="headerlink" title="在插件化项目中使用新的aapt命令"></a>在插件化项目中使用新的aapt命令</h3><p>现在，可以用我们修改的aapt文件替换sdk下的aapt 命令，但是如果这么做，每当Android系统更新，我们都要替换一次aapt命令。一种可行的做法是，我们把这个新的 aapt 工具命名为 aapt_mac ，放到项目的根目录下：</p>
<p><img src="" alt="自定义的aapt放置"></p>
<p>之后，修改项目中 gradle 文件：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>上述脚本通过反射，<strong>把aapt的路径临时修改为指向当前App根目录下的aapt_mac</strong>。此外，我们将App的资源前缀设置为 0x71 ，这样在打包后，R文件中的资源就以 0x71 作为前缀了。</p>
<h2 id="public-xml-固定资源id值"><a href="#public-xml-固定资源id值" class="headerlink" title="public.xml 固定资源id值"></a>public.xml 固定资源id值</h2><p>如下场景：多个插件都需要<strong>同一个</strong>自定义控件，于是我们把这个自定义控件卸载宿主 App，插件调用宿主的Java 代码，使用宿主的资源(有控件肯定有资源)。考虑到App在每次打包后，随着资源的增减，同一个资源id的值可能会发生变化。为避免这种情况，我们可以<strong>把公用的资源id值固定写死</strong>，如下public.xml文件所示（注意，type和id后面的空格不可省略）：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"&gt;</span></span><br><span class="line"><span class="meta">&lt;resources&gt;</span></span><br><span class="line"><span class="meta">    &lt;public type="string" name="string1" id="0x7f050024"/&gt;</span></span><br><span class="line"><span class="meta">&lt;/resources&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>之后，把public.xml放到 res/values 目录下，R.string.string1 这个资源就会固定成 0x7f050024。当然，还可以指定资源值的一个区间,将上述代码中间那行改成如下代码即可：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">public-padding</span> <span class="attr">name</span>=<span class="string">"my_"</span> <span class="attr">end</span>=<span class="string">"0x7f02000f"</span> <span class="attr">start</span>=<span class="string">"0x7f020001"</span> <span class="attr">type</span>=<span class="string">"drawable"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是从gradle 1.3开始，就忽略 public.xml了，因此需要我们自己使用gradle 脚本来实现，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>之后，打包宿主 ActivityHost1 ，使用Jadx-GUI 查看资源id，可以看到 R.string.string1 的值永远是 2131034148(也即十六进制0x7f050024)。</p>
<h2 id="插件使用宿主的资源"><a href="#插件使用宿主的资源" class="headerlink" title="插件使用宿主的资源"></a>插件使用宿主的资源</h2><p>宿主资源值固定了，但是插件怎么访问宿主中的资源呢？如果插件内部能保持一个对宿主项目的引用，那就可以随便访问宿主的任何资源了。<strong>我们需要编写gradle脚本，把宿主打包成 jar 包。之后设置插件的gradle文件，通过provided来引用这个jar包</strong>。之前介绍过，provided方式引用只在编码时候有用，正式打包的时候不会被引用进去。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章给出插件化中资源id冲突的解决方案：</p>
<ul>
<li>把宿主和插件的资源都合并到一起，通过AssetManager的addAssetPath 来实现。只不过，<strong>这种方案会产生资源id冲突的问题</strong>      </li>
<li>如果不事先合并资源，那就为每个插件创建一个 AssetManager，每个 AssetManager 都是通过反射调用 addAssetPath 方法，把插件资源加进去。当宿主进入一个插件时，就把 AssetManager 切换为 插件的AssetManager ；反之，当从插件回到宿主的时候，再把 AssetManager 切换回宿主的 AssetManager(详见第5章的loadResource方法)。</li>
</ul>
<p>第一种方案，主要缺陷是资源冲突，并且资源id的前缀是有限的，也就256个值，如果超过256个插件，就要使用方案2了。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.gitee.io/2021/03/28/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC12%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/28/%E4%B8%8D%E5%8F%91%E5%B8%83%E7%9A%84%E6%96%87%E4%BB%B6/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC12%E7%AB%A0/" class="post-title-link" itemprop="url">第12章：ContentProvider的插件化解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-28 17:29:00 / 修改时间：17:43:57" itemprop="dateCreated datePublished" datetime="2021-03-28T17:29:00+08:00">2021-03-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="ContentProvider基本概念"><a href="#ContentProvider基本概念" class="headerlink" title="ContentProvider基本概念"></a>ContentProvider基本概念</h2><p>ContentProvider 就是一个SQLite 数据库，数据提供方A和数据使用方B是通过<strong>匿名共享内存</strong>来传输数据的。B告诉A，“你把数据写在这个内存地址上”；B准备好数据，写到A要求的内存地址上，A就可以直接使用这些数据了。当数据量非常大的时候，这个数据传递速度是非常快的。</p>
<p>并不是所有数据传递都需要ContentProvider，比如，Activity 跳转时，数据的传递就用的 Binder，一般来说，传输的数据量不超过 1 M 时，使用Binder；否则，此时需要ContentProvider 。</p>
<h2 id="ContentProvider-插件化"><a href="#ContentProvider-插件化" class="headerlink" title="ContentProvider 插件化"></a>ContentProvider 插件化</h2><p>前面介绍了 BroadCastReceiver 的插件化解决方案，即把插件中的静态广播都转换为动态广播，然后手动注册到宿主App的广播中。</p>
<p>其实，ContentProvider 也能这么做，这时候不叫“注册”，而叫“安装”。安装当前Apk中所有的ContentProvider 的方法位于 ActivityThread 的 installContentProviders方法中：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码略</span></span><br></pre></td></tr></tbody></table></figure>

<p>我么你只需要手动执行这个方法，把插件中的ContentProvider 集合作为第二个参数填进去即可。如此一来，我们得到了ContentProvider 插件化的解决方案：</p>
<ol>
<li>沿用Activity插件化的第二种方案，将宿主App和插件App的dex合并到一起     </li>
<li>借助PackageParse的parsePackage方法，读取插件中的ContentProvider信息，然后把得到的Package对象转换为我们需要的 ProviderInfo类型对象     </li>
<li>将ContentProvider 的packageName 设置为当前apk的packageName，之后把插件中的 ContentProvider 放入宿主中     </li>
<li>通过反射执行 ActivityThread 的 installContentProviders 方法，把ContentProvider 作为插件的参数，相当于把插件 ContentProvider “安装” 到宿主App中     </li>
</ol>
<h2 id="执行这段Hook代码的时机"><a href="#执行这段Hook代码的时机" class="headerlink" title="执行这段Hook代码的时机"></a>执行这段Hook代码的时机</h2><p>ContentProvider 这个组件，往往是提供给外界使用的，如果插件中的ContentProvider 还没安装到宿主App中，第三方就来调用了，那就要等很久了，所以安装插件 ContentProvider 的过程越早越好。<strong>App安装自身的 ContentProvider 是在ActivityThread 执行 installContentProviders 方法中，这个方法比Application 的onCreate 要早，但是会晚于 Application 的 attachBaseContent 方法，所以，我们可以在 attachBaseContent 方法中，手动执行 ActivityThread 的 installContentProviders</strong> 。</p>
<h2 id="ContentProvider-的转发机制"><a href="#ContentProvider-的转发机制" class="headerlink" title="ContentProvider 的转发机制"></a>ContentProvider 的转发机制</h2><p>让外界App直接调用当前App的插件里定义的ContentProvider ，并不是理想的解决方案。最好的是在宿主App中定义一个 StubContentProvider 作为中转，让外界调用当前App的 StubContentProvider ，然后在 StubContentProvider 中再调用插件里的 ContentProvider：</p>
<p><img src="/assets/Book-Notes/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8C%87%E5%8D%97/%E7%AC%AC12%E7%AB%A0/ContentProvider%E6%8F%92%E4%BB%B6%E5%8C%96%E5%88%86%E5%8F%91%E6%80%9D%E6%83%B3.png" alt="ContentProvider插件化分发思想"></p>
<p>ContentProvider 插件化的精髓在于分发，外界使用 App 提供的 ContentProviderA 时，只知道发送给一个宿主AndroidManifest 中声明锅的 ContentProviderA，而受到请求后，再做二次转发。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共262.1k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.gitee.io/',]
      });
      });
  </script>


</body>
</html>
