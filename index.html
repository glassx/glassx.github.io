<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">31</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">9</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">139</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/26/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC8%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/26/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC8%E7%AB%A0/" class="post-title-link" itemprop="url">第8章：JUC容器类</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-26 09:12:00" itemprop="dateCreated datePublished" datetime="2023-02-26T09:12:00+08:00">2023-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-21 22:34:05" itemprop="dateModified" datetime="2023-02-21T22:34:05+08:00">2023-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>高并发场景下常见的设计模式可能存在线程安全问题，比如传统的单例模式就是典型。本章介绍几种高并发场景下常用的几种模式：<strong>线程安全的单例模式、ForkJoin模式、生产者-消费者模式、Master-Worker模式和 Future模式。</strong></p>
<h2 id="8-1-线程安全的单例模式"><a href="#8-1-线程安全的单例模式" class="headerlink" title="8.1 线程安全的单例模式"></a>8.1 线程安全的单例模式</h2><p>没有volatile 情况下的双重检查实现的单例模式，可能会存在问题，可以看到下面这句代码：</p>
<blockquote>
<p>instance = new Singleton();</p>
</blockquote>
<p>转换成（具有原子性的）汇编指令大致会分为 3个：</p>
<ol>
<li><p>分派一块内存 M</p>
</li>
<li><p>在 M 上初始化 Singleton 对象</p>
</li>
<li><p>M 的地址赋值给 instance 变量</p>
</li>
</ol>
<p>但是，以前说过可能会进行重排序，上面 3 个指令优化之后可能会变为：</p>
<ol>
<li><p>分派一块内存 M</p>
</li>
<li><p>M 的地址赋值给 instance 变量</p>
</li>
<li><p>在 M 上初始化 Singleton 对象</p>
</li>
</ol>
<p>指令重排后，获取单例可能导致问题发生，假设 A 、B线程过来获取单例：</p>
<ol>
<li><p>A 通过 getInstance() 方法，执行到分配一块内存并将地址赋值给 instance，恰好发生了线程切换，<strong>此时，A 还没来得及对 M 指向的内存初始化</strong></p>
</li>
<li><p>线程 B 进入 getInstance() 方法，判断 instance 不为空，于是 B 直接获取到了未初始化的 instance</p>
</li>
<li><p>线程 B 使用未初始化完全的对象 instance 在访问 instance 的成员变量时可能会发生异常</p>
</li>
</ol>
<p>所以需要添加 volatile 防止指令重排。</p>
<h3 id="8-1-5-使用静态内部类实现懒汉式单例模式"><a href="#8-1-5-使用静态内部类实现懒汉式单例模式" class="headerlink" title="8.1.5 使用静态内部类实现懒汉式单例模式"></a>8.1.5 使用静态内部类实现懒汉式单例模式</h3><p>虽然通过 <strong>双重锁检查+volatile</strong>相结合的方式能实现高性能、线程安全的单例模式，但是该实现的底层原理比较复杂、实现繁琐，另一种易于理解、编程简单的单例模式实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取单例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这种方式只有在调用 getInstance() 的时候才会初始化单例，该方式既解决了线程安全问题，又解决了写法繁琐的问题。书中推荐使用这种方案。</p>
<h2 id="8-2-Master-worker-模式"><a href="#8-2-Master-worker-模式" class="headerlink" title="8.2 Master-worker 模式"></a>8.2 Master-worker 模式</h2><p>这是一种常见的高并发模式，它的核心思想是：任务的调度和执行分离，调度任务的角色是 Master，执行任务的角色是 Worker，Master 负责接收、分配和合并（Merge）任务结果，Worker 负责执行任务。</p>
<h3 id="8-2-1-Master-worker-模式的参考实现"><a href="#8-2-1-Master-worker-模式的参考实现" class="headerlink" title="8.2.1 Master-worker 模式的参考实现"></a>8.2.1 Master-worker 模式的参考实现</h3><h4 id="Master-的参考代码"><a href="#Master-的参考代码" class="headerlink" title="Master 的参考代码"></a>Master 的参考代码</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Task</span>, <span class="title">R</span>&gt; </span>{</span><br><span class="line">    <span class="comment">// 所有Worker的集合</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Worker&lt;T, R&gt;&gt; workers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务的集合</span></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;T&gt; taskQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务处理结果集合</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;String, R&gt; resultMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Master的任务调度线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保持最终的和</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong sum = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Master</span><span class="params">(<span class="keyword">int</span> workerCount)</span> </span>{</span><br><span class="line">        <span class="comment">// 每个Worker对象都需要持有queue的引用，用于领任务与提交结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workerCount; i++) {</span><br><span class="line">            Worker&lt;T, R&gt; worker = <span class="keyword">new</span> Worker&lt;&gt;();</span><br><span class="line">            workers.put(<span class="string">"子节点: "</span> + i, worker);</span><br><span class="line">        }</span><br><span class="line">        thread = <span class="keyword">new</span> Thread(() -&gt; <span class="keyword">this</span>.execute());</span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(T task)</span> </span>{</span><br><span class="line">        taskQueue.add(task);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取worker结果处理的回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resultCallBack</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        Task&lt;R&gt; task = (Task&lt;R&gt;) o;</span><br><span class="line">        String taskName = <span class="string">"Worker:"</span> + task.getWorkerId() + <span class="string">"-"</span> + <span class="string">"Task:"</span> + task.getId();</span><br><span class="line">        R result = task.getResult();</span><br><span class="line">        resultMap.put(taskName, result);</span><br><span class="line">        sum.getAndAdd((Integer) result); <span class="comment">//和的累加</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动所有的子任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; ; ) {</span><br><span class="line">            <span class="comment">// 从任务队列中获取任务，然后Worker节点轮询，轮流分</span></span><br><span class="line">            配任务</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Worker&lt;T, R&gt;&gt; entry :workers.entrySet()) {</span><br><span class="line">                T task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    task = <span class="keyword">this</span>.taskQueue.take();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取任务</span></span><br><span class="line">                    Worker worker = entry.getValue(); <span class="comment">//</span></span><br><span class="line">                    获取节点</span><br><span class="line">                    worker.submit(task, <span class="keyword">this</span>::resultCallBack); <span class="comment">//分配任务</span></span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最终的结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printResult</span><span class="params">()</span> </span>{</span><br><span class="line">        Print.tco(<span class="string">"----------sum is :"</span> + sum.get());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, R&gt; entry : resultMap.entrySet()) {</span><br><span class="line">            String taskName = entry.getKey();</span><br><span class="line">            Print.fo(taskName + <span class="string">":"</span> + entry.getValue());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="Worker-的代码实现"><a href="#Worker-的代码实现" class="headerlink" title="Worker 的代码实现"></a>Worker 的代码实现</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Task</span>, <span class="title">R</span>&gt; </span>{</span><br><span class="line">    <span class="comment">//接收任务的阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;T&gt; taskQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">//Worker 的编号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger index = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerId;</span><br><span class="line">    <span class="comment">//执行任务的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.workerId = index.getAndIncrement();</span><br><span class="line">        thread = <span class="keyword">new</span> Thread(() -&gt; <span class="keyword">this</span>.run());</span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 轮询执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 轮询启动所有的子任务</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//从阻塞队列中提取任务</span></span><br><span class="line">                T task = <span class="keyword">this</span>.taskQueue.take();</span><br><span class="line">                task.setWorkerId(workerId);</span><br><span class="line">                task.execute();</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收任务到异步队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(T task, Consumer&lt;R&gt; action)</span> </span>{</span><br><span class="line">        task.resultAction = action; <span class="comment">//设置任务的回调方法</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">this</span>.taskQueue.put(task);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="8-3-FokJoin模式"><a href="#8-3-FokJoin模式" class="headerlink" title="8.3 FokJoin模式"></a>8.3 FokJoin模式</h2><p>目前没心思看，先略过</p>
<h2 id="8-4-生产者-消费者模式"><a href="#8-4-生产者-消费者模式" class="headerlink" title="8.4 生产者-消费者模式"></a>8.4 生产者-消费者模式</h2><p>略过</p>
<h2 id="8-5-Future模式"><a href="#8-5-Future模式" class="headerlink" title="8.5 Future模式"></a>8.5 Future模式</h2><p>略</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/25/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC7%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/25/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC7%E7%AB%A0/" class="post-title-link" itemprop="url">第7章：JUC容器类</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-25 21:21:00" itemprop="dateCreated datePublished" datetime="2023-02-25T21:21:00+08:00">2023-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-21 21:52:01" itemprop="dateModified" datetime="2023-02-21T21:52:01+08:00">2023-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>Java的基础容器主要有 List、Set、Queue、Map 四大类，但是大家熟知的 ArrayList、LinkedList 、HashMap 等都不是线程安全的。为了解决安全问题，Java用内置锁提供了一套线程安全的同步容器类，但是效率不高；因此，JUC提供了一套高并发容器。</p>
<h2 id="7-1-线程安全的同步容器类"><a href="#7-1-线程安全的同步容器类" class="headerlink" title="7.1 线程安全的同步容器类"></a>7.1 线程安全的同步容器类</h2><p>Java 同步容器类通过 synchronized 来实现同步的容器，比如 HashTable、Vector 以及 SynchronizedList 等容器，另外，Java 还提供了一组包装方法，将一个普通的基础容器包装成线程安全的同步容器，例如通过 Collections.synchronizedMap() 包装方法能将Map 包装成线程安全的 Map，看代码就能知道其原理：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.util.Collections</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K, V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedMap&lt;&gt;(m);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;,<span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;</span><br><span class="line">    <span class="keyword">final</span> Object mutext;</span><br><span class="line"></span><br><span class="line">    SynchronizedMap(Map&lt;K,V&gt; m) {</span><br><span class="line">        <span class="keyword">this</span>.m = Objects.requeireNonNull(m);</span><br><span class="line">        <span class="keyword">this</span>.mutext = <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span> <span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (mutext) {</span><br><span class="line">            <span class="keyword">return</span> m.size();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isEmpty</span> <span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (mutext) {</span><br><span class="line">            <span class="keyword">return</span> m.isEmpty();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ....省略其他方法</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过上述代码可以看出，Collections 提供的包装方法实现步骤：<strong>首先实现了容器的操作接口，在操作接口上使用 synchronized 进行线程同步，然后在 synchronized 临界区将实际的操作委托给被包装的基础容器。</strong></p>
<h3 id="7-1-1-同步容器面临的问题"><a href="#7-1-1-同步容器面临的问题" class="headerlink" title="7.1.1 同步容器面临的问题"></a>7.1.1 同步容器面临的问题</h3><p>由前面的描述可知：同步容器实现线程安全的方式是(包括HashTable之类的以及 Collections包装类之类的)*<em>在需要同步访问的方法上添加关键字 synchonized *</em>。所以效率并不高。</p>
<h2 id="7-2-JUC-高并发容器"><a href="#7-2-JUC-高并发容器" class="headerlink" title="7.2 JUC 高并发容器"></a>7.2 JUC 高并发容器</h2><p>为了解决同步容器的性能问题，有了 JUC 高并发容器。高并发容器是基于<strong>非阻塞算法(也说无锁编程算法)</strong>实现的容器类，<strong>主要通过 CAS(Compare And Swap) + volatile 组合实现，其中 CAS 保证原子性，volatile 保证可见性</strong>。其主要优点如下：</p>
<ul>
<li>开销小：无需在内核态和用户态来回切换</li>
<li>读写不互斥： 读读操作之间可以不互斥，只有写操作需要使用基于 CAS 机制的乐观锁</li>
</ul>
<h2 id="7-3-CopyOnWriteArrayList"><a href="#7-3-CopyOnWriteArrayList" class="headerlink" title="7.3 CopyOnWriteArrayList"></a>7.3 CopyOnWriteArrayList</h2><p>很多应用场景读操作可能会远远大于写操作，由于读操作不会修改原有数据，因此每次读取都要加锁其实是一种浪费。</p>
<h3 id="7-3-2-CopyOnWriteArrayList-原理"><a href="#7-3-2-CopyOnWriteArrayList-原理" class="headerlink" title="7.3.2 CopyOnWriteArrayList 原理"></a>7.3.2 CopyOnWriteArrayList 原理</h3><p>CopyOnWrite(写时复制)就是在修改器对一块内存进行修改时，不直接在原有内存块上进行写操作，而是将内存复制一份，在新的内存中进行写操作，写完之后，再将原来的指针(引用)指向新的内存，原来的内存GC 。CopyOnWriteArrayList 的核心成员如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>,<span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 对所有的修改器方法进行保护，访问器方法并不需要保护 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">     <span class="comment">/** 内部对象数组，通过 getArray/setArray 方法访问 */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *获取内部对象数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] getArray() {</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *设置内部对象数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>{</span><br><span class="line">      array = a;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-3-3-CopyOnWriteArrayList-的读取操作"><a href="#7-3-3-CopyOnWriteArrayList-的读取操作" class="headerlink" title="7.3.3 CopyOnWriteArrayList 的读取操作"></a>7.3.3 CopyOnWriteArrayList 的读取操作</h3><p>读取操作没有任何同步操作和锁控制，理由是内部数组array 不会发生修改，只会被另一个 array 替换，因此可以保证数据安全：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 操作内存的引用*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line"><span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回操作内存</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() {</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-3-4-CopyOnWriteArrayList-写入操作"><a href="#7-3-4-CopyOnWriteArrayList-写入操作" class="headerlink" title="7.3.4 CopyOnWriteArrayList 写入操作"></a>7.3.4 CopyOnWriteArrayList 写入操作</h3><p>写入操作 add() 方法在执行时加了独占锁以确保只能有一个线程进行写入操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); </span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>每次进行添加操作时，都会重新复制一份数组，再往新数组中添加元素，添加完了，再将array 引用指向新的数组。也就是<strong>当add() 操作完成后，array 的引用就已经指向新的存储空间了</strong>。</p>
<h3 id="7-3-5-CopyOnWriteArrayList-优缺点以及对比-自己加的章节"><a href="#7-3-5-CopyOnWriteArrayList-优缺点以及对比-自己加的章节" class="headerlink" title="7.3.5 CopyOnWriteArrayList 优缺点以及对比(自己加的章节)"></a>7.3.5 CopyOnWriteArrayList 优缺点以及对比(自己加的章节)</h3><h4 id="7-3-5-1-优缺点-自己加的章节"><a href="#7-3-5-1-优缺点-自己加的章节" class="headerlink" title="7.3.5.1 优缺点(自己加的章节)"></a>7.3.5.1 优缺点(自己加的章节)</h4><ul>
<li>优点：高并发操作下读取、遍历操作不需要同步，速度非常快，适用于“读多写少“的场景</li>
<li>缺点： 每次添加要复制一份，增加内存开销</li>
</ul>
<h4 id="7-3-5-2-比较-自己加的章节"><a href="#7-3-5-2-比较-自己加的章节" class="headerlink" title="7.3.5.2 比较(自己加的章节)"></a>7.3.5.2 比较(自己加的章节)</h4><p>CopyOnWriteArrayList 和 ReentrantReadWriteLock (读写锁) 的思想非常类似，ReentrantReadWriteLock 的泗县时：读读共享、写写互斥、读写互斥、写读互斥，而 CopyOnWriteArrayList 更进一步了：为了将读取的性能发挥到极致，读取时完全不加锁。</p>
<h2 id="7-4-BlockingQueue"><a href="#7-4-BlockingQueue" class="headerlink" title="7.4 BlockingQueue"></a>7.4 BlockingQueue</h2><p>在多线程环境中，通过 BlockingQueue (阻塞队列) 可以很容易实现多线程之间的数据共享和通信，比如在经典的“生产者-消费者“模型中，通过 BlockingQueue 可以完成一个高性能版本。</p>
<h3 id="7-4-3-常见的-BlockingQueue"><a href="#7-4-3-常见的-BlockingQueue" class="headerlink" title="7.4.3 常见的 BlockingQueue"></a>7.4.3 常见的 BlockingQueue</h3><p>BlockingQueue 的实现类大概有 ：ArrayBlockingQueue、DelayQueue、LinkedBlockingDeque、<br>PriorityBlockingQueue、SynchronousQueue等。</p>
<h4 id="7-4-3-1-ArrayBlockingQueue"><a href="#7-4-3-1-ArrayBlockingQueue" class="headerlink" title="7.4.3.1 ArrayBlockingQueue"></a>7.4.3.1 ArrayBlockingQueue</h4><p>ArrayBlockingQueue 内部<strong>采用定长数组来存储元素，添加和删除操作采用同一个锁对象，也就是说添加和删除无法并行运行(为什么不能并行呢？因为作者认为ArrayBlockingQueue的写入和获取操作已经足够轻量了)</strong>。</p>
<blockquote>
<p>为什么 ArrayBlockingQueue 比 LinkedBlockingQueue 更加常用？因为前者添加或者删除的时候不会产生或者销毁任何额外的 Node 实例，在高并发场景下，这可以减轻系统 GC 压力</p>
</blockquote>
<h4 id="7-4-3-2-LinkedBlockingQueue"><a href="#7-4-3-2-LinkedBlockingQueue" class="headerlink" title="7.4.3.2 LinkedBlockingQueue"></a>7.4.3.2 LinkedBlockingQueue</h4><p>LinkedBlockingQueue 是基于链表的阻塞队列，对于添加和删除元素分别才用了独立的锁控制，也就是在高并发场景下，消费者和生产者可以并行地操作队列中数据。</p>
<blockquote>
<p>需要注意的是，新建 LinkedBlockingQueue 时如果没有指定其容量大小，则默认大小近乎无限(Integer.MAX_VALUE)，这样的话，一旦生产速度大于消费速度，也许还没等到队列满阻塞产生，系统内存就消耗光了。</p>
</blockquote>
<h4 id="7-4-3-3-DelayQueue"><a href="#7-4-3-3-DelayQueue" class="headerlink" title="7.4.3.3 DelayQueue"></a>7.4.3.3 DelayQueue</h4><p>DelayQueue 只有当其指定的延迟时间到了才能够从队列中取该元素，<strong>它是一个没有大小限制的队列，因此添加(生产者)永远不会被阻塞，只有获取数据(消费者)才会被阻塞。</strong></p>
<blockquote>
<p>DelayQueue 的适用场景较少，常见的例子是用来管理一个超时未响应的连接队列</p>
</blockquote>
<h4 id="7-4-3-4-PriorityBlockingQueue"><a href="#7-4-3-4-PriorityBlockingQueue" class="headerlink" title="7.4.3.4 PriorityBlockingQueue"></a>7.4.3.4 PriorityBlockingQueue</h4><p>PriorityBlockingQueue 和 DelayQueue 类似，它也不会阻塞生产者，只会在没有可消费的数据时阻塞消费者。</p>
<h4 id="7-4-3-5-SynchronousQueue"><a href="#7-4-3-5-SynchronousQueue" class="headerlink" title="7.4.3.5 SynchronousQueue"></a>7.4.3.5 SynchronousQueue</h4><p>SynchronousQueue 是一种无缓冲的等待队列，不像 LinkedBlockingQueue 有中间缓冲区，所以吞吐率相对而言会低一些。不过对于单个任务来说，正因为没有缓冲区，所以响应会快一些。</p>
<p>LinkedBlockingQueue、DelayQueue 以及 PriorityBlockingQueue 都需要注意生产速度不能快于消费者，否则容易耗光内存。</p>
<h3 id="7-4-4-ArrayBlockingQueue-的基本使用"><a href="#7-4-4-ArrayBlockingQueue-的基本使用" class="headerlink" title="7.4.4 ArrayBlockingQueue 的基本使用"></a>7.4.4 ArrayBlockingQueue 的基本使用</h3><p>用 ArrayBlockingQueue 队列实现一个生产者-消费者的案例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 省略import</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueuePetStore</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AMOUNT = <span class="number">10</span>; <span class="comment">//数据区长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//共享数据区，类定义</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBuffer</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">        <span class="comment">//使用阻塞队列保存数据</span></span><br><span class="line">        <span class="keyword">private</span> ArrayBlockingQueue&lt;T&gt; dataList = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(MAX_AMOUNT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向数据区增加一个元素，委托给阻塞队列</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T element)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            dataList.add(element); <span class="comment">//直接委托</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 从数据区取出一个商品，委托给阻塞队列</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">return</span> dataList.take(); <span class="comment">//直接委托</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Print.cfo(<span class="string">"当前进程的ID是"</span> + JvmUtil.getProcessID());</span><br><span class="line">        System.setErr(System.out);</span><br><span class="line">        <span class="comment">//共享数据区，实例对象</span></span><br><span class="line">        DataBuffer&lt;IGoods&gt; dataBuffer = <span class="keyword">new</span> DataBuffer&lt;&gt;();</span><br><span class="line">        <span class="comment">//生产者执行的操作</span></span><br><span class="line">        Callable&lt;IGoods&gt; produceAction = () -&gt; {</span><br><span class="line">            <span class="comment">//首先生成一个随机的商品</span></span><br><span class="line">            IGoods goods = Goods.produceOne();</span><br><span class="line">            <span class="comment">//将商品加上共享数据区</span></span><br><span class="line">            dataBuffer.add(goods);</span><br><span class="line">            <span class="keyword">return</span> goods;</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//消费者执行的操作</span></span><br><span class="line">        Callable&lt;IGoods&gt; consumerAction = () -&gt; {</span><br><span class="line">        <span class="comment">// 从PetStore获取商品</span></span><br><span class="line">            IGoods goods = <span class="keyword">null</span>;</span><br><span class="line">            goods = dataBuffer.fetch();</span><br><span class="line">            <span class="keyword">return</span> goods;</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> THREAD_TOTAL = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 线程池，用于多线程模拟测试</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_TOTAL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假定共11个线程，其中有10个消费者，但是只有1个生产者</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> CONSUMER_TOTAL = <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PRODUCE_TOTAL = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PRODUCE_TOTAL; i++) {</span><br><span class="line">            <span class="comment">//生产者线程每生产一个商品，间隔50毫秒</span></span><br><span class="line">            threadPool.submit(<span class="keyword">new</span></span><br><span class="line">            Producer(produceAction, <span class="number">50</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONSUMER_TOTAL; i++){</span><br><span class="line">            <span class="comment">//消费者线程每消费一个商品，间隔100毫秒</span></span><br><span class="line">            threadPool.submit(<span class="keyword">new</span></span><br><span class="line">            Consumer(consumerAction, <span class="number">100</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-4-6-非阻塞式添加元素-add-、offer-方法的原理"><a href="#7-4-6-非阻塞式添加元素-add-、offer-方法的原理" class="headerlink" title="7.4.6 非阻塞式添加元素 add()、offer() 方法的原理"></a>7.4.6 非阻塞式添加元素 add()、offer() 方法的原理</h3><p>首先来看非阻塞式添加元素，<strong>在队列满而不能添加元素时，非阻塞式添加元素的方法会立即返回，所以线程不会被阻塞。</strong>add() 方法的实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出直接调用了 offer 方法，如果 offer 方法添加失败，直接抛出异常，否则返回true。</p>
<p>offer() 方法的实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//offer()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    checkNotNull(e); <span class="comment">//检查元素是否为null</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)<span class="comment">//判断数组是否已满</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            enqueue(e);<span class="comment">//添加元素到队列</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，offer() 方法的操作如下：</p>
<ol>
<li>如果数组满了，就直接释放锁，返回false</li>
<li>数组没满，将元素加入队(通过enqueue()方法)然后返回true</li>
</ol>
<h3 id="7-4-7-阻塞式添加元素：put-方法的原理"><a href="#7-4-7-阻塞式添加元素：put-方法的原理" class="headerlink" title="7.4.7 阻塞式添加元素：put() 方法的原理"></a>7.4.7 阻塞式添加元素：put() 方法的原理</h3><p>put() 方法是一个阻塞方法，如果队列元素已满，那么当前线程会被加入 notFull 条件等待队列中，直到有空位置才会被唤醒执行添加操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put()方法，阻塞时可中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();<span class="comment">//该方法可中断</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//当队列元素个数与数组长度相等时，无法添加元素</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">        <span class="comment">//将当前调用线程挂起，添加到notFull条件队列中，等待被唤醒</span></span><br><span class="line">        notFull.await();</span><br><span class="line">        enqueue(e);<span class="comment">//如果队列没有满，就直接添加</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结一下put()流程:</p>
<ol>
<li>获取 putLock 锁</li>
<li>如果队列满了，就被阻塞，put线程进入 notFull 等待队列，等着被唤醒</li>
<li>如果队列未满，通过 enqueue 方法入队</li>
<li>释放 putLock 锁</li>
</ol>
<h3 id="7-4-8-非阻塞式删除元素：-poll-方法"><a href="#7-4-8-非阻塞式删除元素：-poll-方法" class="headerlink" title="7.4.8 非阻塞式删除元素： poll() 方法"></a>7.4.8 非阻塞式删除元素： poll() 方法</h3><p>当队列空而不能删除元素时，非阻塞删除元素的方法会立即返回，执行线程不会被阻塞。poll() 方法实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//判断队列是否为null，不为null执行dequeue()方法，否则返回null</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>里面使用了 dequeue() 方法出队：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除队列头元素并返回</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//拿到当前数组的数据</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">    <span class="comment">//获取要删除的对象</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    <span class="comment">//清空位置：将数组中的takeIndex索引位置设置为null</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//takeIndex索引加1并判断是否与数组长度相等</span></span><br><span class="line">    <span class="comment">//如果相等就说明已到尽头，恢复为0</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;<span class="comment">//元素个数减1</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();<span class="comment">//同时更新迭代器中的元素数据</span></span><br><span class="line">    <span class="comment">//删除了元素说明队列有空位，唤醒notFull条件等待队列中的put线程，执行添加操作</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>主要注意后面的通过 notFull.signal() 唤醒条件等待队列中的一个 put 线程。阻塞式的 take() 方法略。</p>
<h2 id="7-5-ConcurrentHashMap"><a href="#7-5-ConcurrentHashMap" class="headerlink" title="7.5 ConcurrentHashMap"></a>7.5 ConcurrentHashMap</h2><p>在 Java 7 之前版本 ConcurrentHashMap 采用分段锁实现，数据分为一段一段的，每段分配一把锁，当一个线程访问其中一段数据的时候，其他段的数据能被正常访问，实现了真正的并发访问；Java8对内部存储结构进行了优化，性能进一步提升。</p>
<h3 id="7-5-1-HashMap-和-HashTable-的问题"><a href="#7-5-1-HashMap-和-HashTable-的问题" class="headerlink" title="7.5.1 HashMap 和 HashTable 的问题"></a>7.5.1 HashMap 和 HashTable 的问题</h3><p>HashMap 不是线程安全的，<strong>多线程环境下，HashMap 的 put() 操作可能会引起死循环，导致CPU使用率接近100%。</strong>于是JDK提供了线程安全的Map-HashTable，它使用几乎与 HashMap 几乎一样区别有2点：</p>
<ul>
<li>HashTable 不允许key 和value 为null</li>
<li>HashTable 的包括 get/set 在内的方法都是用 synchronized 来保证线程安全，对整个 Hash 表锁定，但是代价会非常大的</li>
</ul>
<h3 id="7-5-2-Java-1-7-及以前版本的-ConcurrentHashMap"><a href="#7-5-2-Java-1-7-及以前版本的-ConcurrentHashMap" class="headerlink" title="7.5.2 Java 1.7 及以前版本的 ConcurrentHashMap"></a>7.5.2 Java 1.7 及以前版本的 ConcurrentHashMap</h3><p>分段锁是一种锁设计，并不是具体的锁。对于 ConcurrentHashMap 而言，分段锁技术将 key 分成一个个小 segment 存储，给每段数据一把锁，当一个线程占用锁访问其中一段数据时，其他段数据也能被其他线程访问，实现真正的并发。</p>
<p>这个原理已经比较了解了，这里就不按照书本的章节走，略过了</p>
<h3 id="7-5-4-JDK-1-8版本-ConcurrentHashMap-的结构"><a href="#7-5-4-JDK-1-8版本-ConcurrentHashMap-的结构" class="headerlink" title="7.5.4 JDK 1.8版本 ConcurrentHashMap 的结构"></a>7.5.4 JDK 1.8版本 ConcurrentHashMap 的结构</h3><p>1.7 版本虽然<strong>通过 segment 方式实现了并发热点分离</strong>，默认情况下将一个table 分裂成 16 个小的 table(Segment表示)，从而在 Segment 维度实现并发。但是这样并发粒度还不够细。1.8 版本抛弃了 Segment 分段锁机制，存储结构采用数组+链表或者红黑树的组合方式，<strong>将并发粒度细化到每一个桶，进一步细化了热点</strong>，利用 CAS + Synchronized 来保证并发更新安全。</p>
<blockquote>
<p>JDK 1.7 的 ConcurrentHashMap 每个桶为链表结构，1.8 引入了红黑树结构，当桶的节点超过阈值(默认64)时，自动将链表结构转换为红黑树，<strong>可以理解为将链式桶转为树状桶</strong>。这样的好处在于，访问的时候只需要对一个桶锁定，而不需要将整个 Map 集合都进行粗粒度锁定。事实上，引入红黑树的一个原因是：链表查询复杂度 O(n) ，红黑树查询复杂度 O(log(n))</p>
</blockquote>
<p><img src="/assets/Book-Notes/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%8D%B72/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%8D%B72-%E7%AC%AC7%E7%AB%A0-%E4%B8%80%E4%B8%AA1.8%E7%89%88%E6%9C%AC%E7%9A%84ConcurrentHashMap%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.jpg" alt="一个1.8版本的ConcurrentHashMap实例内部结构"></p>
<h3 id="7-5-5-ConcurrentHashMap的核心原理-1-8-版本"><a href="#7-5-5-ConcurrentHashMap的核心原理-1-8-版本" class="headerlink" title="7.5.5 ConcurrentHashMap的核心原理-1.8 版本"></a>7.5.5 ConcurrentHashMap的核心原理-1.8 版本</h3><p>JDK 1.8版本的ConcurrentHashMap中通过一个 Node&lt;K,V&gt;[] 数组table 来保存添加到哈希表中的桶，在同一个 Bucket 位置是通过链表和 红黑树的形式来保存的，<strong>但是 table 是懒加载的，只有在第一次添加元素的时候才会初始化</strong>。它的主要成员属性大致如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class"><span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>{</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"> <span class="comment">//常量：表示正在转移</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED = -<span class="number">1</span>;</span><br><span class="line"> <span class="comment">// 常量：表示已经转换成树</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN = -<span class="number">2</span>; </span><br><span class="line"> <span class="comment">// 常量：hash for transient reservations</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED = -<span class="number">3</span>; </span><br><span class="line"> <span class="comment">// 常量：usable bits of normal node hash</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; </span><br><span class="line"> <span class="comment">//数组，用来保存元素</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"> <span class="comment">//转移时用的数组</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来控制表初始化和扩容的控制属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 省略其他</span></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<p>重要属性介绍如下：</p>
<ul>
<li>table用于保存添加到哈希表中的桶</li>
<li>DEFAULT_CAPACITY： table的默认长度。默认初期长度为16，在第一次添加元素时，会将table初始化成16个元素的数组</li>
<li>sizeCtl：sizeCtl用来控制table的初始化和扩容操作的过程</li>
</ul>
<p>涉及修改 sizeCtl 的方法有 5 个：</p>
<ul>
<li>initTable()：初始化哈希表时，涉及sizeCtl的修改</li>
<li>addCount()：增加容量时，涉及sizeCtl的修改</li>
<li>tryPresize()：ConcurrentHashMap扩容方法之一</li>
<li>transfer()：table数据转移到 nextTable，扩容操作的核心在于数据的转移，把旧数组中的数据前一到新的数组。ConcurrentHashMap可以利用多线程来协同扩容，简单说是把 table 数组当做多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程锁负责的取件，一个已经迁移完的 Bucket 会被替换为一个 ForwardingNode 节点，标记当前 Bucket 已经被其他线程迁移完成。</li>
<li>helpTransfer()：并发添加元素时，如果正在扩容，其他线程会帮助扩容，也就是多线程扩容。</li>
</ul>
<h3 id="7-5-6-JDK-1-8-版本-ConcurrentHashMap的核心源码"><a href="#7-5-6-JDK-1-8-版本-ConcurrentHashMap的核心源码" class="headerlink" title="7.5.6 JDK 1.8 版本 ConcurrentHashMap的核心源码"></a>7.5.6 JDK 1.8 版本 ConcurrentHashMap的核心源码</h3><p>下面来看JDK 1.8版本ConcurrentHashMap的put()操作:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自旋：并发情况下，也可以保障安全添加成功</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K, V&gt;[] tab = table; ; ) {</span><br><span class="line">        Node&lt;K, V&gt; f;</span><br><span class="line">        <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">//第一次添加，先初始化node数组</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">//计算出table[i]无节点，创建节点</span></span><br><span class="line">            <span class="comment">//使用Unsafe.compareAndSwapObject 原子操作table[i]位置</span></span><br><span class="line">            <span class="comment">//如果为null，就添加新建的node节点，跳出循环</span></span><br><span class="line">            <span class="comment">//反之，再循环进入执行添加操作</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key, value, <span class="keyword">null</span>))) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) {</span><br><span class="line">            <span class="comment">//如果当前处于转移状态，返回新的tab内部表，然后进入循环执行添加操作</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//在链表或红黑树中追加节点</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//使用synchronized 对 f 对象加锁</span></span><br><span class="line">            <span class="comment">// f = tabAt(tab, i = (n - 1) &amp; hash) ： table[i] 的node对象(桶)</span></span><br><span class="line">            <span class="comment">//注意：这里没用ReentrantLock，而是使用 synchronized 进行同步</span></span><br><span class="line">            <span class="comment">//在争用不激烈的场景中，synchronized 的性能和 ReentrantLock不相上下</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) {</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) {</span><br><span class="line">                    <span class="comment">//在链表上追加节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) {</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; e = f; ; ++binCount) {</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) {</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent) {</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                }</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                            Node&lt;K, V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) {</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//在红黑树上追加节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) {</span><br><span class="line">                        Node&lt;K, V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K, V&gt;) f).putTreeVal(hash, key, value)) != <span class="keyword">null</span>) {</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) p.val = value;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">//节点数大于临界值，转换成红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD) {</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从源码可以看出，使用 CAS 自旋完成桶的设置时，使用 synchronized 内置锁保证桶内并发操作的线程安全。尽管对同一个 Map 操作的线程争夺会非常激烈，但是在同一个桶内的线程争夺通常不会很激烈，所以使用 CAS 自旋、synchronized 的偏向锁或轻量级锁 不会降低 ConcurrentHashMap 的性能。为什么不用显式锁 ReentrantLock 呢？因为如果为每个桶都创建一个 ReentrantLock 实例，就会带来大量的内存消耗，而前面那些方法带来的内存消耗微乎其微。</p>
<p>get方法也没有加锁操作，与 JDK1.7差不多，就不赘述了。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/18/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/18/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">第5章：JUC显式锁的原理与实战</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-18 15:54:00 / 修改时间：16:29:42" itemprop="dateCreated datePublished" datetime="2023-02-18T15:54:00+08:00">2023-02-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="5-1-显式锁"><a href="#5-1-显式锁" class="headerlink" title="5.1 显式锁"></a>5.1 显式锁</h2><p>使用 Java内置锁 时，无需通过 Java 代码显式地对同步对象的监视器进行抢占和释放，使用起来非常方便。但是不具备一些比较高级的锁功能：</p>
<ul>
<li><p>限时抢锁：设置超时时长，不至于无限等下去</p>
</li>
<li><p>可中断抢锁：抢锁时，外部线程给抢锁线程发一个中断信号，就能唤起等待锁的线程，并终止抢占过程</p>
</li>
<li><p>多个等待队列：为锁维持多个等待队列，以提高锁的效率。比如生产者-消费者模式中，生产者和消费者公用一把锁，锁上维持2个队列：一个生产队列和一个消费者队列</p>
</li>
</ul>
<h3 id="5-1-3-使用显式锁的模板代码"><a href="#5-1-3-使用显式锁的模板代码" class="headerlink" title="5.1.3 使用显式锁的模板代码"></a>5.1.3 使用显式锁的模板代码</h3><p>因为 JUC 中的显式锁都实现了 Lock 接口，所以不同类型的显式锁对象使用的方法都是模板化的、套路化的，模板代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建锁对象，SomeLock 为 Lock 的某个实现类，如 ReentrantLock</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> SomeLock();</span><br><span class="line"><span class="comment">//step 1： 抢占锁</span></span><br><span class="line">lock.lock;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//step2 ： 抢锁成功，执行临界区代码</span></span><br><span class="line">    doSomething();</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    lock.unlock(); <span class="comment">//step3： 释放锁</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>模板代码有几个需要注意的点：</p>
<ul>
<li><p>释放锁操作 unlock 必须在 try-catch 的finally 中执行，否则如果临界区代码抛出异常，锁就可能永远也得不到释放了</p>
</li>
<li><p>抢占锁的操作<strong>lock 必须在 try 语句之外</strong>，原因：lock 方法不一定能够抢锁成功（我猜测作者是想说 tryLock() 之类的方法不一定会获取成功），如果没有抢占到锁，也肯定不需要释放锁，<strong>在没有占有锁的情况下释放锁可能导致异常</strong>。</p>
</li>
<li><p>在抢占锁操作 lock 和 try 语句之间不要插入任何代码，避免抛出异常而无法执行到 try，进而无法释放锁。</p>
</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/17/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC4%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/17/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC4%E7%AB%A0/" class="post-title-link" itemprop="url">第4章：可见性与有序性的原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-17 14:20:00" itemprop="dateCreated datePublished" datetime="2023-02-17T14:20:00+08:00">2023-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-18 15:53:19" itemprop="dateModified" datetime="2023-02-18T15:53:19+08:00">2023-02-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="4-1-CPU物理缓存结构"><a href="#4-1-CPU物理缓存结构" class="headerlink" title="4.1 CPU物理缓存结构"></a>4.1 CPU物理缓存结构</h2><p>L1缓存离 CPU 最近也最快，一般就 32k/64k水平；L2 缓存速度次之，容量一般比L1大；L3级缓存最大，比前面二者都大，速度也最慢，大小可能 12M 的水平。</p>
<h2 id="4-2-并发编程的三大问题"><a href="#4-2-并发编程的三大问题" class="headerlink" title="4.2 并发编程的三大问题"></a>4.2 并发编程的三大问题</h2><p>三大问题分别是： 原子性、可见性、有序性 问题。必须要保证这 3 个，只要有一个没保证，在多线程情况下就可能不正确。</p>
<p>后续的略。</p>
<h2 id="4-3-硬件层的MESI协议原理"><a href="#4-3-硬件层的MESI协议原理" class="headerlink" title="4.3 硬件层的MESI协议原理"></a>4.3 硬件层的MESI协议原理</h2><p>为了缓解内存速度和CPU速度差问题，现在计算机都会为CPU添加高速缓存，每个CPU内核都有自己的一级、二级高速缓存，同一个CPU多个内核之间共享一个三级高速缓存。</p>
<h3 id="4-3-1-总线锁和缓存锁"><a href="#4-3-1-总线锁和缓存锁" class="headerlink" title="4.3.1 总线锁和缓存锁"></a>4.3.1 总线锁和缓存锁</h3><p>CPU的处理流程为：现将计算需要用到的数据缓存到CPU的高速缓存中，CPU计算时，直接从高速缓存获取数据并在计算完成后写会高速缓存，整个运算完成后再把高速缓存的数据同步回主存。由于每个线程可能运行在不同的CPU内核中，因此<strong>同一份数据可能被缓存到多个CPU内核中，就会发生内存可见性问题</strong>。</p>
<p>后续的略。</p>
<h3 id="4-4-1-重排序"><a href="#4-4-1-重排序" class="headerlink" title="4.4.1 重排序"></a>4.4.1 重排序</h3><p><strong>编译器</strong>为什么要重排序？其目的为： <strong>与其等待阻塞指令（如等待缓存刷入），不如先去执行其他指令。</strong>另外，CPU层面也有重排序。</p>
<h2 id="4-5-JMM-详解"><a href="#4-5-JMM-详解" class="headerlink" title="4.5 JMM 详解"></a>4.5 JMM 详解</h2><p>JMM (Java Memory Model ，Java 内存模型) 并不像JVM 内存结构一样是真实存在的运行实体，更多体现为一种规范和规则。</p>
<p>JMM 定义了一组规则或规范，该规范定义了<strong>一个线程对共享变量写入时，如何确保对另一个线程是可见的</strong>，实际上 JMM 提供了合理的禁用缓存以及禁止重排序的方法，所以其核心价值在于<strong>解决可见性和有序性</strong>。它的另一大价值在于：<strong>屏蔽各大硬件和操作系统差异，保证 Java 程序在各大平台堆内存访问是一致的。</strong></p>
<p>JMM 规定所有的变量都存储在主存（类似于物理内存，但是有区别）中，每个 Java 线程都有自己的工作内存（类似于CPU高速缓存，但有区别）。</p>
<p>JMM 提供了一套自己的方案解决可见性和有序性问题，包括 volatile、synchronized、final 等。</p>
<h2 id="4-7-volatile-不具备原子性"><a href="#4-7-volatile-不具备原子性" class="headerlink" title="4.7 volatile 不具备原子性"></a>4.7 volatile 不具备原子性</h2><p>对于关键字 volatile 修饰的内存可见变量而言，具有2个重要的语义：</p>
<ul>
<li><p>使用 volatile 修饰的变量在变量的值发生改变时，会立刻同步到主存，并使其他线程的变量副本失效</p>
</li>
<li><p>禁止指令重排序</p>
</li>
</ul>
<p>使用++操作说明volatile不具备重排序功能：</p>
<ol>
<li><p>A、B线程分别运行在Core1 和 Core2 核上，假设此时共享value 的值为 0，现在线程 A、B 都读取value值到自己的工作内存上</p>
</li>
<li><p>线程 A 将 value 的值变为 1，完成了 assign、store 操作，假设在执行 write 指令前 A 的时间片用完，线程 A 被空闲但是 write 操作还没达到主存，但是呢， store 操作触发了写的信号，导致了 B 缓存过期</p>
</li>
<li><p>B重新从主存读到 value，可想而知这时候还是 0</p>
</li>
<li><p>线程 B 执行完所有操作，将 value 值变成 1 写入主存</p>
</li>
<li><p>线程 A 重新拿到时间片，将过期了的 1 写入主存</p>
</li>
</ol>
<p>所以，<strong>对于复合操作，volatile无法保障原子性，如果要保证复合操作的原子性，就需要用到锁</strong>。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/16/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第1章：CAS原理与JUC原子类</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-16 14:50:00 / 修改时间：21:46:27" itemprop="dateCreated datePublished" datetime="2023-02-16T14:50:00+08:00">2023-02-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>JVM 的Synchrod 轻量级锁使用 CAS 进行自旋抢锁，并且处于用户态下，所以轻量级锁开销较小。</p>
<h2 id="3-1-什么是-CAS"><a href="#3-1-什么是-CAS" class="headerlink" title="3.1 什么是 CAS"></a>3.1 什么是 CAS</h2><p>JDK 5 增加的 JUC (java.util.concurrent) 并发包对操作系统的底层 CAS 原子操作进行了封装，为上层提供了 CAS 操作的 API 。</p>
<h3 id="3-1-1-Unsafe-类中的-CAS-方法"><a href="#3-1-1-Unsafe-类中的-CAS-方法" class="headerlink" title="3.1.1 Unsafe 类中的 CAS 方法"></a>3.1.1 Unsafe 类中的 CAS 方法</h3><p>Unsafe 是位于 sun.misc 包下的一个类，主要提供一些用于执行低级别、不安全的底层操作，如直接访问系统内存资源、自主管理内存资源等。从名字都可以看出这个类对普通程序员来说是“危险”的，官方也不建议直接在程序中使用这些类。</p>
<h5 id="获取-Unsafe-实例"><a href="#获取-Unsafe-实例" class="headerlink" title="获取 Unsafe 实例"></a>获取 Unsafe 实例</h5><p>Unsafe 类时一个final 修饰的不允许继承的类，并且构造函数是 private 类型，源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        Reflection.registerMethodsToFilter(Unsafe.class, Set.of(<span class="string">"getUnsafe"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe = <span class="keyword">new</span> Unsafe();</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所以我们无法在外部对 Unsafe 实例化，那么应该怎么获取呢？可以通过反射方式获取 theUnsafe 实例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmUtil</span> </span>{</span><br><span class="line">    <span class="comment">//自定义地获取Unsafe实例的辅助方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 省略不相干代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="Unsafe提供的-CAS-方法"><a href="#Unsafe提供的-CAS-方法" class="headerlink" title="Unsafe提供的 CAS 方法"></a>Unsafe提供的 CAS 方法</h5><p>总共提供了如下3种方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object expected,Object x)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,  <span class="keyword">int</span> expected,  <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">long</span> expected, <span class="keyword">long</span> x)</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>这些方法首先将内存位置的值与预期值比较，如果相匹配，那么CPU 会自动将该内存位置的值更新为新值，并返回true；否则，CPU不做任何操作，并返回false。</p>
<h3 id="3-1-2-使用-CAS-进行无锁编程"><a href="#3-1-2-使用-CAS-进行无锁编程" class="headerlink" title="3.1.2 使用 CAS 进行无锁编程"></a>3.1.2 使用 CAS 进行无锁编程</h3><p>CAS 是一种无锁算法，底层CPU 利用原子操作判断 <strong>内存值与期望值是否相等，如果相等就给内存地址赋新值，否则不做任何操作。</strong>使用 CAS 进行无锁编程的步骤大概如下：</p>
<ol>
<li><p>获得字段的期望值(oldValue)</p>
</li>
<li><p>计算出需要替换的新值(newValue)</p>
</li>
<li><p>通过 CAS 将 newValue 放在字段的内存地址上，如果 CAS 失败就重复从第1步开始，直到 CAS 成功。<strong>这种重复俗称“自旋”</strong></p>
</li>
</ol>
<p>举例： 假如 2 个线程 A 和B 对一个共享变量做 +1 操作，用 CAS 去做这个操作。但是线程是并发进行的，假如 A 和 B 都读到旧值是 1 ，然后并发通过 CAS 操作，都是 CAS(1, 2)  ，但是CAS 是原子操作，同一个内存地址的 CAS 在同一个时刻只能执行一个，因此，假设 A 先执行，A 的 CAS(1, 2) 因为期望值是1，内存值也是1，操作成功，返回true；接下来 B 执行 CAS(1, 2) 肯定会失败了，因为内存值目前已经是 2 了，而期望值是 1 ，所以只得重新获取得到期望值 2，计算出新的值 3， 最后通过 CAS(2, 3) 才能成功。</p>
<h2 id="3-2-JUC原子类"><a href="#3-2-JUC原子类" class="headerlink" title="3.2 JUC原子类"></a>3.2 JUC原子类</h2><p>并发执行时，诸如 ++ 或者 – 类的运算不具备原子性，大家可能会用 synchronized 方法做同步，但效率肯定会影响的。JDK 为这些类型不安全的操作提供了一些原子类，与 synchronized 相比效率会更高。</p>
<h3 id="3-2-1-JUC中的Atomic-原子操作包"><a href="#3-2-1-JUC中的Atomic-原子操作包" class="headerlink" title="3.2.1 JUC中的Atomic 原子操作包"></a>3.2.1 JUC中的Atomic 原子操作包</h3><p>只需要知道有： </p>
<ul>
<li><p>基本原子类：AtomicInteger、AtomicLong、AtomicBoolean</p>
</li>
<li><p>数组原子类：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p>
</li>
<li><p>引用原子类：AtomicReference、AtomicMarkableReference、AtomicStampedReference</p>
</li>
</ul>
<p>等等一些常见的即可。</p>
<h2 id="3-4-ABA问题"><a href="#3-4-ABA问题" class="headerlink" title="3.4 ABA问题"></a>3.4 ABA问题</h2><p>什么是 ABA 问题，举个例子：比如线程 A 从内存位置 M 取出 V1，另一个线程 B 也取出 V1 ，假设 B 进行了一些操作后将 M 位置的数据 V1 变成了 V2，然后又在一些操作之后将 V2 变成了 V1，然后线程 A 通过 CAS 操作时发现条件满足，CAS 操作成功。</p>
<p>但是这个过程是有问题的，A 操作的时候 V1 已经不是以前的 V1 了，这就是 ABA 问题。</p>
<h3 id="3-4-2-ABA问题的解决方案"><a href="#3-4-2-ABA问题的解决方案" class="headerlink" title="3.4.2 ABA问题的解决方案"></a>3.4.2 ABA问题的解决方案</h3><p>很多乐观锁的实现版本是： <strong>使用版本号(Version)方式来解决ABA问题。</strong> 每次在执行数据的修改操作时<strong>都会带上一个版本号</strong>，版本号和数据的版本号一致就可以执行修改操作，否则执行失败。因为操作的版本号只会增加，不会减少。</p>
<p>当然，参考乐观锁的版本号实现， JDK 提供了一个 AtomicStampedReference 类来解决 ABA 问题，AtomicStampedReference 在 CAS 的基础上增加了一个 Stamp（印戳或标记）来察觉数据是否发生了变化。</p>
<p>当然，还可以使用 AtomicMarkableReference 解决。它是 AtomicStampedReference 的简化版，不关心修改过几次，只关心是否修改过。</p>
<h2 id="3-5-提升高并发场景下-CAS-操作的性能"><a href="#3-5-提升高并发场景下-CAS-操作的性能" class="headerlink" title="3.5 提升高并发场景下 CAS 操作的性能"></a>3.5 提升高并发场景下 CAS 操作的性能</h2><p>在竞争激烈的场景下，会导致大量的 CAS 自旋，比如大量线程同时并发修改一个 AtomicInteger 是，很多线程可能不停地自旋， 这浪费了大量的 CPU。</p>
<h3 id="3-5-1-以空间换时间：LongAdder"><a href="#3-5-1-以空间换时间：LongAdder" class="headerlink" title="3.5.1 以空间换时间：LongAdder"></a>3.5.1 以空间换时间：LongAdder</h3><p>AtomicLong 使用内部变量 value 保存着实际的 long 值，所有操作都是针对该 value 的，也就是说，当高并发的情况下，value 变量其实是一个热点，N 个线程竞争这一个热点，重试的线程越多，意味着 CAS 失败的概率越高。</p>
<p>LongAdder 的核心思想是热点分离，与 ConcurrentHashMap 的设计思想类似：将 value 值分离成一个数组，当多线程访问时，通过 Hash 算法将线程映射到数组的一个元素进行操作；而获取最终value 结果时，则将数组的元素求和。</p>
<p>具体一点：LongAdder 将 value 值分散到一个数组中，不同的线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行 CAS 操作，这样热点就被分散了，这样，即使线程数再多也不担心，各个线程分配到多个元素更新。<strong>如果要获取完整的 LongAdder 存储的值，只要将各个槽中的变量值累加即可</strong></p>
<blockquote>
<p>在 CAS 竞争非常激烈的场景， LongAdder 的性能可达到 AtomicLong 的 8 倍。</p>
</blockquote>
<h2 id="3-6-CAS在JDK中的广泛应用"><a href="#3-6-CAS在JDK中的广泛应用" class="headerlink" title="3.6 CAS在JDK中的广泛应用"></a>3.6 CAS在JDK中的广泛应用</h2><h3 id="3-6-1-CAS操作的弊端和规避措施"><a href="#3-6-1-CAS操作的弊端和规避措施" class="headerlink" title="3.6.1 CAS操作的弊端和规避措施"></a>3.6.1 CAS操作的弊端和规避措施</h3><p>CAS 操作弊端主要有下面 3 点：</p>
<ul>
<li><p>ABA问题，<strong>解决思路</strong>： 添加版本号、使用 AtomicStampedReference、AtomicMarkableReference，其中前者比较常用</p>
</li>
<li><p>只能保证一个共享变量的原子操作。<strong>解决思路</strong>：将多个共享变量合并成一个共享变量来操作</p>
</li>
<li><p>开销问题。<strong>解决思路</strong>：分散操作热点(如 LongAdder)、使用队列削峰(将 发生 CAS 争用的线程加入一个队列中排队，降低 CAS 争用的激烈程度，JUC 中非常重要的基础类 AQS 就是这么做的！)</p>
</li>
</ul>
<h3 id="3-6-2-CAS-在JDK中的应用"><a href="#3-6-2-CAS-在JDK中的应用" class="headerlink" title="3.6.2 CAS 在JDK中的应用"></a>3.6.2 CAS 在JDK中的应用</h3><p>CAS 在 在java.util.concurrent.atomic包中的原子类、Java AQS 以及 显式锁、ConcurrentHashMap 等重要并发容器中都有非常广泛的应用</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/16/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/16/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">第1章：Java内置锁的核心原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-16 10:10:00 / 修改时间：12:42:49" itemprop="dateCreated datePublished" datetime="2023-02-16T10:10:00+08:00">2023-02-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="2-8-偏向锁、轻量级锁与重量级锁的对比"><a href="#2-8-偏向锁、轻量级锁与重量级锁的对比" class="headerlink" title="2.8 偏向锁、轻量级锁与重量级锁的对比"></a>2.8 偏向锁、轻量级锁与重量级锁的对比</h2><p>总结一下，synchronized 的执行过程大致如下：</p>
<ol>
<li>线程抢锁时，JVM 首先检测内置锁对象 Mark Word 的biased_lock(偏向锁标识)是否为1，lock (锁标志位)是否为01，如果都满足，说明内置锁对象为可偏向状态</li>
<li>如果内置锁对象为可偏向状态，JVM 检查 Mark Word 中线程 ID 是否为当前抢锁线程的 ID，如果是，标识抢锁线程处于偏向所状态，快速获得锁，开始执行临界区代码</li>
<li>如果Mark Word 中的线程 ID 不是当前抢锁线程，就通过 CAS 竞争锁。如果竞争成功，就将 Mark Word 中的线程 ID 设置为抢锁线程的 ID ，偏向锁标志设为 1 ，锁标志位设为 01,此时内置锁对象处于偏向锁状态，然后开始执行临界区代码</li>
<li>如果 CAS 竞争失败，说明发生了竞争，撤销偏向锁，进而升级为轻量级锁</li>
<li>JVM 使用 CAS 将锁对象的 Mark Word 替换为抢锁线程的锁记录指针，如果成功，抢锁线程就获得锁；如果替换失败，就表示其他线程在竞争锁。那么 JVM 尝试使用 CAS 自旋替换抢锁线程的锁记录指针，如果自旋成功（抢锁成功），那么锁对象依旧处于轻量级锁状态。</li>
<li>如果JVM的CAS 替换锁记录指针自旋失败，轻量级锁就膨胀为重量级锁，后面等待锁的线程也要进入阻塞状态</li>
</ol>
<p>3种锁的优缺点对比和适用场景如下表所示：</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加解锁不需要额外消耗，和执行非同步方法仅存在纳秒级差距</td>
<td>如果线程间存在锁竞争，会带来额外的撤销锁操作</td>
<td>适用于只有一个线程访问的临界区场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>抢不到锁的竞争线程会CAS自旋，消耗CPU</td>
<td>锁占用时间短，吞吐量低</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争无需自旋，不消耗CPU</td>
<td>线程阻塞，响应时间慢</td>
<td>锁占用时间长，吞吐量高</td>
</tr>
</tbody></table>
<h2 id="2-9-线程间通信"><a href="#2-9-线程间通信" class="headerlink" title="2.9 线程间通信"></a>2.9 线程间通信</h2><p>多个线程共同操作共享的资源时，线程间通过某种方法互相告知自己的状态，以避免无效的资源争夺。<strong>线程间通信的方式可以有很多种：等待-通知、共享内存、管道流。</strong></p>
<h3 id="2-9-2-低效的线程轮询"><a href="#2-9-2-低效的线程轮询" class="headerlink" title="2.9.2 低效的线程轮询"></a>2.9.2 低效的线程轮询</h3><p>轮询版本的生产者-消费者模型中，消费者每一轮消费，无论数据区是否为空，都需要进行数据区的询问和判断：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> IGoods <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    IGoods goods = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (amount &lt;= <span class="number">0</span>) {</span><br><span class="line">        Print.tcfo(<span class="string">"队列已经空了！"</span>);</span><br><span class="line">        <span class="comment">//数据区为空，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当数据区为空(amount &lt;= 0)时，消费者无法取出数据，但是仍然做无用的询问工作，浪费了CPU的时间片。同理，对于生产者也会存在这样的问题：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T element)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (amount.get() &gt; MAX_AMOUNT) {</span><br><span class="line">        Print.tcfo(<span class="string">"队列已经满了！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当数据区满时，生产者无法加入数据，这时执行add方法也浪费CPU的时间片。<strong>使用“等待-通知”方式进行生产者与消费者之间的线程通信可以避免这种浪费。</strong></p>
<p>具体方法是：<strong>当数据区满时，给让生产者等待，当可以添加数据时，给生产者发通知，让生产者唤醒；消费者同理。</strong>具体操作为：消费者取出一个数据后，由消费者去唤醒等待的生产者；生产者加入一个数据后，由生产者唤醒等待的消费者。</p>
<h3 id="2-9-3-wait-、notify-方法的原理"><a href="#2-9-3-wait-、notify-方法的原理" class="headerlink" title="2.9.3 wait 、notify 方法的原理"></a>2.9.3 wait 、notify 方法的原理</h3><h5 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait 方法"></a>wait 方法</h5><p>对象的 wait 方法作用就是<strong>让当前线程阻塞并等待被唤醒，wait 方法与对象监视器密切相关，使用时一定要放在同步块中：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(locko) {</span><br><span class="line">    ...</span><br><span class="line">    locko.wait();</span><br><span class="line">    ....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其原理大致如下：</p>
<ul>
<li><p>线程调用了 locko 的wait 方法后，JVM 会将当前线程假如 locko 监视器的 WaitSet(等待集) 中，等待被其他线程唤醒</p>
</li>
<li><p>当前线程会释放 locko 对象监视器 的 Owner 权利，让其他线程可以抢夺 locko 对象的监视器</p>
</li>
<li><p>让当前线程等待，其状态变为 WAITING</p>
</li>
</ul>
<h5 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify 方法"></a>notify 方法</h5><p>notify 方法也需要放在同步块中执行，它有2个版本：</p>
<ul>
<li><p>notify ： 唤醒 locko 监视器等待集中的第一条等待线程，被唤醒的线程进入 EntryList ，状态从 WAITING 变为 BLOCKED</p>
</li>
<li><p>notifyAll： 唤醒 locko 监视器等待集中全部等待线程，所有线程进入 EntryList ，状态从 WAITING 变为 BLOCKED</p>
</li>
</ul>
<p>notify 核心原理如下：</p>
<ul>
<li><p>当线程调用了 locko 的 notify 方法后，JVM 会唤醒 locko 监视器等待集中的第一条等待线程（如果是 notifyAll 则是所有线程），被唤醒的线程进入 EntryList ，状态从 WAITING 变为 BLOCKED，<strong>具备了排队抢夺监视器 Owner权利的资格</strong></p>
</li>
<li><p>EntryList 中的线程抢夺到监视器的 Owner 权利后，线程的状态从 BLOCKED 变成 RUNNABLE，具备重新执行的资格</p>
</li>
</ul>
<h3 id="2-9-5-生产者-消费者之间的线程间通信"><a href="#2-9-5-生产者-消费者之间的线程间通信" class="headerlink" title="2.9.5 生产者-消费者之间的线程间通信"></a>2.9.5 生产者-消费者之间的线程间通信</h3><p>此实现版本大致需要定义以下3个同步对象：</p>
<ul>
<li><p>LOCK_OBJECT：用于临界区同步，临界区资源为数据缓冲区的 dataList 变量和 amount 变量</p>
</li>
<li><p>NOT_FULL：用于数据缓冲区的未满条件等待和通知，生产者在添加元素时需要判定是否已满，如果已满，则进入 NOT_FULL 的同步去等待，只要消费者耗费一个元素，就会通过 NOT_FULL 发送通知。</p>
</li>
<li><p>NOT_EMPTY：同理，这是用于数据缓冲区的非空条件的等待和通知。消费者在消费前需要判断数据区是否空，如果是，消费者就进入 NOT_EMPTY 的同步区等待被通知，只要生产者添加一个元素，生产者就会通过 NOT_EMPTY 发送通知</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommunicatePetStore</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AMOUNT = <span class="number">10</span>; <span class="comment">//数据缓冲区最大长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据缓冲区，类定义</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBuffer</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">        <span class="comment">//保存数据</span></span><br><span class="line">        <span class="keyword">private</span> List&lt;T&gt; dataList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//数据缓冲区长度</span></span><br><span class="line">        <span class="keyword">private</span> Integer amount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object LOCK_OBJECT = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object NOT_FULL = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object NOT_EMPTY = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向数据区增加一个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T element)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">while</span> (amount &gt; MAX_AMOUNT) {</span><br><span class="line">                <span class="keyword">synchronized</span> (NOT_FULL) {</span><br><span class="line">                    Print.tcfo(<span class="string">"队列已经满了！"</span>);</span><br><span class="line">                    <span class="comment">//等待未满通知</span></span><br><span class="line">                    NOT_FULL.wait();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK_OBJECT) {</span><br><span class="line">                dataList.add(element);</span><br><span class="line">                amount++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">synchronized</span> (NOT_EMPTY) {</span><br><span class="line">                <span class="comment">//发送未空通知</span></span><br><span class="line">                NOT_EMPTY.notify();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从数据区取出一个商品</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">while</span> (amount &lt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">synchronized</span> (NOT_EMPTY) {</span><br><span class="line">                    Print.tcfo(<span class="string">"队列已经空了！"</span>);</span><br><span class="line">                    <span class="comment">//等待未空通知</span></span><br><span class="line">                    NOT_EMPTY.wait();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            T element = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK_OBJECT) {</span><br><span class="line">                element = dataList.remove(<span class="number">0</span>);</span><br><span class="line">                amount--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (NOT_FULL) {</span><br><span class="line">                <span class="comment">//发送未满通知</span></span><br><span class="line">                NOT_FULL.notify();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">            InterruptedException </span>{</span><br><span class="line">        Print.cfo(<span class="string">"当前进程的ID是"</span> + JvmUtil.getProcessID());</span><br><span class="line">        System.setErr(System.out);</span><br><span class="line">        <span class="comment">//共享数据区，实例对象</span></span><br><span class="line">        DataBuffer&lt;IGoods&gt; dataBuffer = <span class="keyword">new</span> DataBuffer&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产者执行的动作</span></span><br><span class="line">        Callable&lt;IGoods&gt; produceAction = () -&gt; {</span><br><span class="line">            <span class="comment">//首先生成一个随机的商品</span></span><br><span class="line">            IGoods goods = Goods.produceOne();</span><br><span class="line">            <span class="comment">//将商品加上共享数据区</span></span><br><span class="line">            dataBuffer.add(goods);</span><br><span class="line">            <span class="keyword">return</span> goods;</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//消费者执行的动作</span></span><br><span class="line">        Callable&lt;IGoods&gt; consumerAction = () -&gt; {</span><br><span class="line">            <span class="comment">// 从PetStore获取商品</span></span><br><span class="line">            IGoods goods = <span class="keyword">null</span>;</span><br><span class="line">            goods = dataBuffer.fetch();</span><br><span class="line">            <span class="keyword">return</span> goods;</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> THREAD_TOTAL = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">//线程池，用于多线程模拟测试</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_TOTAL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//假定共11个线程，其中有10个消费者，但是只有1个生产者</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> CONSUMER_TOTAL = <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PRODUCE_TOTAL = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PRODUCE_TOTAL; i++) {</span><br><span class="line">            <span class="comment">//生产者线程每生产一个商品，间隔50毫秒</span></span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> Producer(produceAction, <span class="number">50</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONSUMER_TOTAL; i++) {</span><br><span class="line">            <span class="comment">//消费者线程每消费一个商品，间隔100毫秒</span></span><br><span class="line">            threadPool.submit(<span class="keyword">new</span> Consumer(consumerAction, <span class="number">100</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="2-9-6-需要在synchronized-同步块的内部使用-wait-和notify"><a href="#2-9-6-需要在synchronized-同步块的内部使用-wait-和notify" class="headerlink" title="2.9.6 需要在synchronized 同步块的内部使用 wait 和notify"></a>2.9.6 需要在synchronized 同步块的内部使用 wait 和notify</h3><p>调用 wait 和 notify 方法时，<strong>“当前线程”必须拥有该对象的同步锁，也即wait 和notiry 方法必须在同步块中使用，否则JVM 就会抛出 IllegalMonitorStateException 异常。</strong></p>
<p>这是为什么呢？还得从这 2 个方法的原理说起：</p>
<ul>
<li><p>调用 wait ：JVM 会释放当前线程的对象监视器的 Owner 资格，还会将当前线程移入监视器的 WaitSet 队列，这些操作都是和对象监视器锁相关的，所以，当前线程执行 wait 方法前，必须通过 synchronized 方法称为对象锁的 Owner，要在同步块内调用</p>
</li>
<li><p>同理， 调用 notify 时，JVM 从对象锁的监视器 WaitSet 队列移动线程到其 EntryList 队列，这些操作都与对象锁的监视器有关，所以，也必须先成为对象锁监视器的 Owner，然后在同步块内调用</p>
</li>
</ul>
<h3 id="2-9-7-调用wait、notify方法进行线程间通信的要点（自己加的章节）"><a href="#2-9-7-调用wait、notify方法进行线程间通信的要点（自己加的章节）" class="headerlink" title="2.9.7 调用wait、notify方法进行线程间通信的要点（自己加的章节）"></a>2.9.7 调用wait、notify方法进行线程间通信的要点（自己加的章节）</h3><p>有了以上的知识储备，来说下wait 和 notify 方法进行线程间通信的要点：</p>
<ul>
<li><p>调用某个同步对象 locko 的 wait 和 notify 类型方法前，必须要获得这个锁对象的监视器锁，这2个类型的方法必须放在同步块中执行，否则报错</p>
</li>
<li><p>调用<strong>wait方法是使用while进行条件判断，如果是在某种条件下进行等待，对条件的判断就不能使用if语句做一次性判断，而是使用while 循环进行反复判断</strong>，只有这样才能在线程被唤醒后继续检查wait 条件，并在条件没有满足的情况下继续等待。</p>
</li>
</ul>
<p>正确的条件判断代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">while</span> (amount &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">synchronized</span> (NOT_EMPTY) {</span><br><span class="line">            <span class="comment">//队列空了</span></span><br><span class="line">            NOT_EMPTY.wait();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>错误地使用 if 条件判断：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//消费者获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">fetch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (amount &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">synchronized</span> (NOT_EMPTY) {</span><br><span class="line">            <span class="comment">//队列空了</span></span><br><span class="line">            NOT_EMPTY.wait();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>至于为什么要这样，从之前说的原理我们知道，wait 方法会释放锁。我们考虑这么一种场景：</p>
<ul>
<li><p>假如有 2 个消费者 consumerOne 和 consumerTwo </p>
</li>
<li><p>consumerOne 在判定是空的时候，wait 了，这时候会释放锁；由于释放了锁，consumerTwo 自然就能获取到这个锁，然后发现也是空的，自然也 wait 了</p>
</li>
<li><p>也就是说 consumerOne 和 consumerTwo 都在wait 等待了，这是问题关键</p>
</li>
<li><p>此时，生产者放入一个元素，完了调用 notifyAll ，consumerOne 和 consumerTwo 都被唤醒了，他们会竞争锁</p>
</li>
<li><p>假如 consumerOne 拿到锁了，consumerTwo 还在锁池中继续阻塞，consumerOne 执行wait 后面的代码消费了，接着又会变为空</p>
</li>
<li><p>consumerOne 执行完成后，consumerTwo 拿到锁也接着执行 wait 后面的代码，由于被 consumerOne 消费变为空了之后，consumerTwo 后续的执行以不空作为条件的执行会出现问题</p>
</li>
</ul>
<p>如果不太明白，还可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37430539/article/details/100005522">为什么生产者消费者中模式中要用while作临界判断？_xuwen_chen的博客-CSDN博客</a></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/14/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC1%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/14/%E4%B9%A6-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B(%E5%8D%B72)-%E7%AC%AC1%E7%AB%A0/" class="post-title-link" itemprop="url">第1章：多线程原理与实战</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-14 15:10:00 / 修改时间：21:52:21" itemprop="dateCreated datePublished" datetime="2023-02-14T15:10:00+08:00">2023-02-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程是操作系统资源分配的最小单位，线程是 CPU 调度的最小单位。</p>
<p>一个标准的线程主要由<strong>3部分构成：线程描述信息(线程ID、线程名称、线程状态、线程优先级、其他)、程序计数器 和 栈内存。</strong>其中，程序计数器它记录着线程下一条指令的代码段内存地址；每个线程在创建的时候默认被分配 1M 大小的栈内存大小，<strong>和堆内存不同，栈内存不受垃圾回收器管理</strong>。</p>
<p>当线程执行流程进入方法时，JVM 就会为方法分配一个对应的栈帧压入栈内存；当线程流程跳出方法时，JVM 就从栈内存弹出该方法的栈帧，此时方法帧的局部变量的内存空间就会被回收。</p>
<h2 id="创建线程的4种方法"><a href="#创建线程的4种方法" class="headerlink" title="创建线程的4种方法"></a>创建线程的4种方法</h2><p>Thread 类中有个属性， private boolean deamon = false; 该属性保存 Thread 线程实例的守护状态，默认为false ，表示普通用户线程，而不是<strong>守护线程。</strong> 守护线程是在进程运行提供某种后台服务的线程，比如GC 线程。</p>
<ul>
<li><p>继承Thead 类创建线程类（Thread 本身就实现了 Runnable ）</p>
</li>
<li><p>实现 Runnable 接口创建线程目标类(传入 Thread 中时，Thread将其以 target 字段保存)</p>
</li>
<li><p>使用 Callable 和 FutureTask 创建线程</p>
</li>
<li><p>通过线程池创建</p>
</li>
</ul>
<p>前面2种创建方法有一个共同的缺陷：不能获取异步执行的结果。在此基础上，才有了使用 Callable 和 FutureTask 创建线程的方法。</p>
<h4 id="Callable-接口"><a href="#Callable-接口" class="headerlink" title="Callable 接口"></a>Callable 接口</h4><p>Callable 是个泛型接口，它的源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Callable 接口类似与 Runnable ，不同的是 Runnable 的run 方法没有返回值，也没有接收异常的异常声明，因此，感觉 Callable 更强大一些，只是 Callable 暂时还没能和 Thread 产生关系。不过，一个在 Callable 接口与 Thread 线程之间搭桥的重要接口 RunnableFuture 接口就要登场了。 </p>
<h4 id="RunnableFuture-接口"><a href="#RunnableFuture-接口" class="headerlink" title="RunnableFuture 接口"></a>RunnableFuture 接口</h4><p>RunnableFuture 接口与 Runnable 接口、Thread 类紧密相关，源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看出，它继承了 Runnable 接口，从而可以作为 Thread 的 target ，同时还继承了 Future 接口，保证了可以获取未来的异步执行结果。</p>
<h4 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a>Future 接口</h4><p>Future 接口至少提供了三大功能：</p>
<ul>
<li><p>能够取消异步执行中的任务</p>
</li>
<li><p>判断异步任务是否执行完成</p>
</li>
<li><p>获取有任务完成后的执行结果</p>
</li>
</ul>
<p>它的源码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>虽然它提供了这么多功能，但它终归只是个接口，通过它没法直接完成对异步任务的操作，为此，JDK 提供了一个默认实现类： FutureTask 。</p>
<h4 id="FutureTask-类"><a href="#FutureTask-类" class="headerlink" title="FutureTask 类"></a>FutureTask 类</h4><p>FutureTask类实现了RunnableFuture接口，相当于既实现了 Runnable 接口，又实现了 Future 接口。所以FutureTask既能作为一个 Runnable 类型的 target 被Thread执行，又能作为Future异步任务来获取Callable的计算结果。</p>
<h4 id="使用Callable和FutureTask创建线程的步骤"><a href="#使用Callable和FutureTask创建线程的步骤" class="headerlink" title="使用Callable和FutureTask创建线程的步骤"></a>使用Callable和FutureTask创建线程的步骤</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>{</span><br><span class="line">    FutureTask&lt;Long&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Long&gt;(<span class="keyword">new</span> Callable&lt;Long&gt;() {</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(futureTask, <span class="string">"returnableThread"</span>);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    System.out.println(thread.getName() + <span class="string">"线程占用时间："</span> + futureTask.get());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>returnableThread线程首先执行 thread.run() 方法，然后在其中执行其target（futureTask任务）的run()方法；接着在futureTask.run()方法中会执行 callable 成员的 call()方法。Callable的call()方法执行完成后，会将结果保存在FutureTask内部的outcome实例属性中。这里有两种情况：</p>
<ul>
<li><p>futureTask的结果outcome不为空，callable.call()执行完成，futureTast.get会直接取回outcome结果返回给结果获取线程。</p>
</li>
<li><p>futureTask的结果outcome为空，callable.call()还没有执行完。则结果获取线程会被<strong>阻塞</strong>住直到callable.call()执行完成。当执行完后，最终结果会保存到outcome中，futureTask会唤醒结果获取线程。</p>
</li>
</ul>
<h2 id="1-4-线程的核心原理"><a href="#1-4-线程的核心原理" class="headerlink" title="1.4 线程的核心原理"></a>1.4 线程的核心原理</h2><h3 id="1-4-1-线程的调度与时间片"><a href="#1-4-1-线程的调度与时间片" class="headerlink" title="1.4.1 线程的调度与时间片"></a>1.4.1 线程的调度与时间片</h3><p>在不同的操作系统、不同的CPU上，线程的 CPU 时间片长度都不同，windows xp 的时间片长度为 20 毫秒，线程调度模型主要分为 2 种：</p>
<ul>
<li><p>分时调度。系统平均分配 CPU 的时间片，人人平等</p>
</li>
<li><p>抢占式调度。按照线程的优先级分配时间片，如果大家优先级都相同，就随机选择一个，目前大部分操作系统选择的是这种调度方式</p>
</li>
</ul>
<h3 id="1-4-2-线程优先级"><a href="#1-4-2-线程优先级" class="headerlink" title="1.4.2 线程优先级"></a>1.4.2 线程优先级</h3><p>对于优先级，有以下结论：</p>
<ul>
<li><p>整体而言，高优先级的线程获得的执行机会更多</p>
</li>
<li><p>执行机会的获取具有随机性，优先级高的不一定获得机会多（文中的例子10级的优先级比9级的优先级获得的机会还少，个人认为可能的一个因素是：Java的线程映射到系统线程时，10级与 9 级并没有区分）</p>
</li>
</ul>
<h3 id="1-4-3-线程的生命周期"><a href="#1-4-3-线程的生命周期" class="headerlink" title="1.4.3 线程的生命周期"></a>1.4.3 线程的生命周期</h3><p>Java 的线程有6种状态：</p>
<ul>
<li><p>NEW： 新建，创建成功，但是没有调用 start() 方法</p>
</li>
<li><p>RUNNABLE：可执行，包含操作系统的就绪、运行2种状态</p>
</li>
<li><p>BLOCKED：阻塞</p>
</li>
<li><p>WAITTING：等待</p>
</li>
<li><p>TIMED_WAITTING：限时等待，包括Thread.sleep(n)、Object.wait(n)、Thread.join(n)、LockSupport.parkNanos(n)、LockSupport.parkUntil(n) 等</p>
</li>
<li><p>TERMINATED：终止。线程的 run 方法执行完毕（或者执行run方法被异常终止）</p>
</li>
</ul>
<h3 id="1-4-5-使用-Jstack-工具查看线程状态"><a href="#1-4-5-使用-Jstack-工具查看线程状态" class="headerlink" title="1.4.5 使用 Jstack 工具查看线程状态"></a>1.4.5 使用 Jstack 工具查看线程状态</h3><p>Jstack 是Java 虚拟机自带的 <strong>堆栈跟踪工具</strong>，用于生成或者导出（Dump）JVM 运行实例当前时刻的线程快照。命令的语法格式如下：</p>
<blockquote>
<p>jstack <pid>   //pid表示 Java 进程的 id，可以用 jps 命令查看</pid></p>
</blockquote>
<h2 id="1-5-线程的基本操作"><a href="#1-5-线程的基本操作" class="headerlink" title="1.5 线程的基本操作"></a>1.5 线程的基本操作</h2><h3 id="1-5-2-线程的sleep-操作"><a href="#1-5-2-线程的sleep-操作" class="headerlink" title="1.5.2 线程的sleep 操作"></a>1.5.2 线程的sleep 操作</h3><p>sleep 的作用是让线程休眠，让 CPU 执行其他的任务，从状态来讲就是<strong>从执行状态变成限时阻塞状态</strong>。当睡眠时间满后，线程不一定立即得到执行，因为此时CPU可能正在执行其他任务，所以还需要等待分配时间片。</p>
<h3 id="1-5-3-线程的-interrupt-操作"><a href="#1-5-3-线程的-interrupt-操作" class="headerlink" title="1.5.3 线程的 interrupt 操作"></a>1.5.3 线程的 interrupt 操作</h3><p>Java 语言提供了 stop()  方法终止正在运行的方法，但后来不建议使用了，因为这像突然关闭计算机电源一样，无法知道这个线程在处于什么状态，它可能持有某把锁，强行停止可能会导致锁无法释放；或者可能正在操作数据库，强行停止导致数据不一致。</p>
<p>一个线程什么时候可以退出只有线程自己直到，所以，<strong>这里介绍的 interrupt 方法本质不是用来中断一个线程，而是将线程设置为中断状态。</strong>当我们调用线程的 interrupt 方法时，它有2个作用：</p>
<ul>
<li><p>如果此线程处于阻塞状态，就会立马退出阻塞，并抛出 InterruptedException 异常，线程可以通过捕获 InterruptedException 异常来做一定处理，从而提早终结被阻塞状态。</p>
</li>
<li><p>如果线程正在运行，就不受任何影响，仅仅只是中断标记被置为 true 了。</p>
</li>
</ul>
<blockquote>
<p>如果 interrupt()方法先被调用，然后线程开始调用阻塞方</p>
<p>法进入阻塞状态，InterruptedException异常依旧会抛出；如果线程</p>
<p>捕获InterruptedException异常后，继续调用阻塞方法，将不再触发</p>
<p>InterruptedException异常。</p>
</blockquote>
<h3 id="1-5-4-线程的join操作"><a href="#1-5-4-线程的join操作" class="headerlink" title="1.5.4 线程的join操作"></a>1.5.4 线程的join操作</h3><p>也就是线程的合并操作，可以用一个例子来说明： 假设线程 A 和 B，现在 A 执行过程中对 B 的执行有依赖：A 需要将 B 的执行流程合并到自己执行的流程中，这就是线程合并，伪代码大概如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread threadb = <span class="keyword">new</span> Thread(<span class="string">"thread-b"</span>);</span><br><span class="line">        threadb.join();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码中，执行 threadb.join() 这行代码的当前线程为合并线程（线程 A）会进入 TIMED_WAITING 等待状态，让出 CPU。所以上述过程应该是<strong>等 B线程执行完成之后，A 线程再继续执行</strong></p>
<h3 id="1-5-5-线程的-yield-操作"><a href="#1-5-5-线程的-yield-操作" class="headerlink" title="1.5.5 线程的 yield 操作"></a>1.5.5 线程的 yield 操作</h3><p>线程的 yield（让步）操作的作用是让目前正在执行的线程放弃当前的执行，让出 CPU执行权限，之后变为 RUNNABLE 状态，从操作系统层面来讲就是进入了就绪状态（而不是阻塞）。在线程 yield 时，线程放弃和重占 CPU 的时间是不确定的，可能刚放弃了 CPU ，马上又获得了 CPU 的执行权限，接着开始执行了。</p>
<h3 id="1-5-6-线程的daemon操作"><a href="#1-5-6-线程的daemon操作" class="headerlink" title="1.5.6 线程的daemon操作"></a>1.5.6 线程的daemon操作</h3><p>守护线程也称为后台线程，专门指在程序进程运行过程中，在后台提供某种通用服务的线程。比如，每启动一个JVM进程，都会在后台运行一系列的 GC 线程，这些 GC 线程就是守护线程。</p>
<p>只要 JVM 中尚存任何一个用户线程没有结束，守护线程就能执行自己的工作，只有当最后一个用户线程结束，守护线程随同 JVM 一同结束工作。</p>
<h4 id="守护线程的要点"><a href="#守护线程的要点" class="headerlink" title="守护线程的要点"></a>守护线程的要点</h4><p>使用守护线程时，有几点需要特别注意：</p>
<ul>
<li><p>线程必须在start() 方法调用前设置其为守护线程(即调用setDaemon(true)方法) ，否则会抛出 InterruptedException异常</p>
</li>
<li><p>在守护线程中创建的线程，新的线程都是守护线程。如果要创建用户线程，需要显式调用 setDaemon(false)</p>
</li>
</ul>
<h2 id="1-6-线程池原理与实战"><a href="#1-6-线程池原理与实战" class="headerlink" title="1.6 线程池原理与实战"></a>1.6 线程池原理与实战</h2><p>Java 线程的创建非常昂贵，需要 JVM 和 OS 配合完成大量工作：</p>
<ul>
<li>为线程堆栈分配大量内存快，包括至少 1M 的栈内存</li>
<li>需要进行系统调用，以便在OS中创建和注册本地线程</li>
</ul>
<p>而线程池的出现主要解决了以下问题：</p>
<ul>
<li><p>提升性能：最大限度地复用已经创建的线程，避免创建和销毁，提升性能</p>
</li>
<li><p>线程管理：线程池可以保持对线程的统计信息，例如完成任务数量、空闲时间等，能对异步任务进行高效调度（<strong>我个人觉得还有可能根据cpu的核心数之类的确定线程数量</strong>）。</p>
</li>
</ul>
<h3 id="1-6-1-JUC-的线程池架构"><a href="#1-6-1-JUC-的线程池架构" class="headerlink" title="1.6.1 JUC 的线程池架构"></a>1.6.1 JUC 的线程池架构</h3><p>JUC 是 java.util.concrrent 工具包的简称，是用于完成高并发、处理多线程的一个工具包。其中的线程池类与接口的架构图大致如下：</p>
<p><img src="/assets/Book-Notes/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%8D%B72/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%8D%B72-%E7%AC%AC1%E7%AB%A0-JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="线程池类与接口的架构图"></p>
<h3 id="1-6-2-Executors-的4种快捷创建线程池的方法"><a href="#1-6-2-Executors-的4种快捷创建线程池的方法" class="headerlink" title="1.6.2 Executors 的4种快捷创建线程池的方法"></a>1.6.2 Executors 的4种快捷创建线程池的方法</h3><p>Java 通过 Excutors 工厂类提供了4种快捷创建线程池的方法，如下表所示：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能简介</th>
</tr>
</thead>
<tbody><tr>
<td>newSingleThreadExcutor</td>
<td>创建只有一个线程的线程池</td>
</tr>
<tr>
<td>newFixedThreadPool</td>
<td>创建固定大小的线程池</td>
</tr>
<tr>
<td>newCachedThreadPool</td>
<td>创建一个不限制线程数量的线程池，任何提交的任务都立即执行，但是空闲线程会得到及时回收</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>创建一个可定期或者延时执行的任务的线程池</td>
</tr>
</tbody></table>
<p>总的来说，newSingleThreadExcutor 线程池有以下特点：</p>
<ul>
<li><p>线程池中的任务是按照提交的顺序执行的</p>
</li>
<li><p>池中的唯一线程的存活时间是无限的</p>
</li>
<li><p>当池中唯一线程繁忙时，<strong>新提交的任务会进入内部的阻塞队列，这个队列是无界队列</strong></p>
</li>
</ul>
<p>线程池使用完后，要调用 shutDown 来关闭线程池，此时线程池将变为 SHUTDOWN 状态，将拒绝新任务，添加新任务会抛出 RejectedExecutionException 异常，此时，线程池不会立刻退出，直到线程池中的任务都执行完成。还有另一个方法 shutdownNow ，执行之后线程状态会立刻变成 STOP ，并且不再处理了还在阻塞队列中等待的任务，会返回哪些未执行的任务。</p>
<p>newFixedThreadPool用于创建一个“固定数量的线程池”，它的特点如下：</p>
<ul>
<li>提交任务时，如果显成熟没有达到固定数量，线程池内就会创建一个新线程，直到达到固定数量</li>
<li>提交新任务时，如果所有的线程都在繁忙，则新任务会进入阻塞队列，该队列是<strong>无界的阻塞队列</strong></li>
</ul>
<p>“固定数量的线程池”适合场景： 需要任务长期执行的场景，比如处理CPU密集型任务。线程数能够比较稳定地维持在某个数量，避免频繁回收和创建线程。</p>
<p>newCachedThreadPool 创建“可缓存线程池”，如果线程池内某些线程成为空闲线程，“可缓存线程池”能灵活回收这些线程。它的特点大致如下：</p>
<ul>
<li>接收新任务时，如果池内所有线程繁忙，则添加新线程来处理</li>
<li>对线程池大小没有限制，完全依赖于JVM能够创建的最大线程大小</li>
<li>如果线程空闲（60s不执行任务），就会回收</li>
</ul>
<p>它的适合场景：需要快速处理突发性强，耗时短的任务场景，如 Netty 的 NIO 处理场景、REST API 接口瞬时削峰场景。</p>
<p>newScheduledThreadPool 创建“可调度线程池”，它提供一个“延时”和“周期性”任务调度功能的ScheduledExecutorService类型的线程池。使用方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduled = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 参数中：0表示首次执行任务的延迟时间，500表示每次执行任务的间隔时间</span></span><br><span class="line">scheduled.scheduleAtFixedRate(<span class="keyword">new</span> TargetTask(), <span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></tbody></table></figure>

<p>“可调度线程池”的适用场景：周期性地执行任务的场景。</p>
<h3 id="1-6-3-线程池的标准创建方式"><a href="#1-6-3-线程池的标准创建方式" class="headerlink" title="1.6.3 线程池的标准创建方式"></a>1.6.3 线程池的标准创建方式</h3><p>大部分企业的开发规范会禁止时候用上述Java 提供的4种创建线程池的方式。，要求通过标准创建方式自行创建。标准创建的一个构造方法如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用标准构造器构造一个普通的线程池</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">int</span> corePoolSize, // 核心线程数，即使线程空闲（Idle），也不会回收</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">int</span> maximumPoolSize, // 线程数的上限</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">long</span> keepAliveTime, TimeUnit unit, // 线程最大空闲（Idle）时长</span></span></span><br><span class="line"><span class="params"><span class="function"> BlockingQueue&lt;Runnable&gt; workQueue, // 任务的排队队列</span></span></span><br><span class="line"><span class="params"><span class="function"> ThreadFactory threadFactory, // 新线程的产生方式</span></span></span><br><span class="line"><span class="params"><span class="function"> RejectedExecutionHandler handler)</span> <span class="comment">// 拒绝策略</span></span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="corePoolSize-与-maximumPoolSize"><a href="#corePoolSize-与-maximumPoolSize" class="headerlink" title="corePoolSize 与 maximumPoolSize"></a>corePoolSize 与 maximumPoolSize</h5><p>corePoolSize 与 maximumPoolSize 自动维护线程池中的工作线程，规则如下：</p>
<ul>
<li>收到新任务，并且当前线程数少于 corePoolSize，即使其他线程处于空闲状态，也会创建新线程来处理该请求</li>
<li>核心线程不会被回收，但是如果设置了 allowCoreThreadTimeOut 的话，则会例外，这时候是可以被回收的</li>
<li>如果当前线程数大于 corePoolSize ，但是小于 maximumPoolSize ，那么仅当任务排队队列已满才会创建新线程。</li>
<li>当 maximumPoolSize 被设置为无界值（如Integer.MAX_VALUE，因为这是int的最大值了）时，线程池可以接受任意数量的并发任务</li>
<li>corePoolSize 与 maximumPoolSize 的值可以动态更改</li>
</ul>
<blockquote>
<p>根据上述规则可知，<strong>给 corePoolSize 和 maximumPoolSize 设置相同的值可以创建一个固定大小的线程池。</strong></p>
</blockquote>
<h5 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h5><p>BlockingQueue 也就是阻塞队列，如果线程池的核心线程都在忙，则收到的任务都缓存在阻塞队列中</p>
<h5 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h5><p>用于设置线程的最大 Idle 市场，如果非 Core 线程（默认情况下只针对非Core线程，但如果allowCoreThreadTimeOut 设置为true，则也会应用于Core线程）空闲超过这个时常，就会被回收。<strong>如果要防止 Idle 线程被回收，可以将 keepAliveTime 设置为 Long.MAX_VALUE</strong>。当然，这个值也是能动态调整的。</p>
<h3 id="1-6-4-向线程池提交任务的2种方式"><a href="#1-6-4-向线程池提交任务的2种方式" class="headerlink" title="1.6.4 向线程池提交任务的2种方式"></a>1.6.4 向线程池提交任务的2种方式</h3><p>有 submit 和 execute 两种方式，这二者的区别：</p>
<ul>
<li>submit 有返回值 Future ，execute 没有</li>
<li>由于 submit 有返回值Future ，所以可以方便对当前任务处理 Exception</li>
<li>入参不同，submit 可以接收 Callable、Runnable 两种，execute 只能接收 Runnable</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//submit 结果获取和异常处理</span></span><br><span class="line"><span class="keyword">try</span>{</span><br><span class="line">    Future&lt;Integer&gt; future = pool.submit(callable);</span><br><span class="line">    Interger result = future.get();</span><br><span class="line">} <span class="keyword">catch</span>(Exception e) {</span><br><span class="line">    e.printStack();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-6-5-线程池任务调度流程"><a href="#1-6-5-线程池任务调度流程" class="headerlink" title="1.6.5 线程池任务调度流程"></a>1.6.5 线程池任务调度流程</h3><p>任务调度流程大致如下：</p>
<ol>
<li>接收任务时，如果当前线程数量小于核心线程数，则创建线程（哪怕其他线程空闲），然后执行任务</li>
<li>如果线程池中的线程大于核心线程数量，新任务将被加入阻塞队列，直到阻塞队列满了</li>
<li>完成一个任务后，优先从阻塞队列中获取下一个任务，直到阻塞队列为空</li>
<li>当核心线程繁忙，并且阻塞队列也已经满了，如果再接收到新任务，将会为新任务创建一个（非核心）线程，并立即开始执行<strong>新任务</strong>。</li>
<li>当核心线程繁忙，阻塞队列满的情况下，来新任务会一直创建线程，当线程总数超过 maximumPoolSize 时就会执行拒绝策略。</li>
</ol>
<h3 id="1-6-6-ThreadFactory-（线程工厂）"><a href="#1-6-6-ThreadFactory-（线程工厂）" class="headerlink" title="1.6.6 ThreadFactory （线程工厂）"></a>1.6.6 ThreadFactory （线程工厂）</h3><p>略</p>
<h3 id="1-6-7-BlockingQueue（任务阻塞队列）"><a href="#1-6-7-BlockingQueue（任务阻塞队列）" class="headerlink" title="1.6.7 BlockingQueue（任务阻塞队列）"></a>1.6.7 BlockingQueue（任务阻塞队列）</h3><p>阻塞队列与普通队列相比有一个重要的特点: <strong>一个线程从一个空的阻塞队列获取元素时会被阻塞(怎么实现的？)，直到队列中有了元素；当队列中有了元素，被阻塞的线程会被自动唤醒。</strong>比较常用的实现类有以下几种：</p>
<ul>
<li>ArrayBlockingQueue：数组实现的<strong>有界阻塞队列</strong>，队列中元素按照 FIFO 排序。</li>
<li>LinkedBlockingQueue：基于链表实现的阻塞队列，按照 FIFO 排序，<strong>可以设置容量(有界队列)，不设置容量则默认使用 Integer.Max_VALUE 作为容量（即无界队列）</strong>。</li>
<li>PriorityBlockingQueue： 具有优先级的<strong>无界队列</strong></li>
<li>DelayQueue：<strong>无界阻塞延迟队列</strong>，底层基于 PriorityBlockingQueue，队列中每个元素都有过期时间，当从队列获取元素时，<strong>只有已经过期的元素才会出队，队列头部是做早过期的元素</strong></li>
<li>SynchronousQueue ：同步队列，不存储元素的阻塞队列，<strong>每个插入操作必须等到另一个线程的调用移除操作，否则插入一直处于阻塞状态。</strong></li>
</ul>
<blockquote>
<p>Excutors.newScheduledThreadPool所创建的线程池就是使用 DelayQueue<br>而，Executors.newCachedThreadPool 所创建的线程池使用的是 SynchronousQueue</p>
</blockquote>
<h3 id="1-6-8-调度器钩子方法"><a href="#1-6-8-调度器钩子方法" class="headerlink" title="1.6.8 调度器钩子方法"></a>1.6.8 调度器钩子方法</h3><ul>
<li>beforeExecute： 执行目标实例前在工作线程异步执行该方法</li>
<li>afterExecute： 执行目标实例后在工作线程异步执行该方法</li>
<li>terminated： 线程池终止时的钩子方法</li>
</ul>
<h3 id="1-6-9-线程池的拒绝策略"><a href="#1-6-9-线程池的拒绝策略" class="headerlink" title="1.6.9 线程池的拒绝策略"></a>1.6.9 线程池的拒绝策略</h3><p>当出现如下情况时，新提交的任务会被拒绝：</p>
<ol>
<li>线程池已经被关闭</li>
<li>所有线程繁忙，并且线程数已经达到了 maximunPoolSize</li>
</ol>
<p>当拒绝的时候，会调用 RejectedExecutionHandler 实例的 rejectedExecution 方法，JUC 提供了以下几种实现：</p>
<ul>
<li>AbortPolicy ： 新任务丢掉同时抛出 RejectedExecutionException 异常，这是线程池默认策略</li>
<li>DiscardPolicy： 新任务直接丢掉，并且不会抛出异常</li>
<li>DiscardOldestPolicy： 抛弃最早的任务，然后让新任务入队</li>
<li>CallerRunsPolicy： 调用者执行策略，提交任务线程会自己执行该任务</li>
<li>自定义策略</li>
</ul>
<h3 id="1-6-10-线程池的优雅关闭"><a href="#1-6-10-线程池的优雅关闭" class="headerlink" title="1.6.10 线程池的优雅关闭"></a>1.6.10 线程池的优雅关闭</h3><p>优雅地关闭线程池主要涉及的方法有 3 个：</p>
<ul>
<li>shutDown： 这是有序关闭线程池的方法，调用之后当前线程会立即返回，不会等待线程池关闭完成。<strong>会等待当前工作队列中剩余的任务全部执行完毕，才关闭线程池</strong>。只要调用了这个方法，线程池会转为 SHUTDOWN 状态，不会再接收任务</li>
<li>shutDownNow ：立即关闭线程池，调用之后当前线程会立即返回，不会等待线程池关闭完成。</li>
<li>awaitTermination： shutDown与shutDownNow调用后会立即返回，不管线程池的关闭。而这个方法就是用于等待线程池完成关闭。</li>
</ul>
<p>优雅关闭线程池的方法：</p>
<ol>
<li>调用 shutDown 方法，拒绝新任务提交</li>
<li>调用 awaitTermination(long timeOut) 指定超时时间，判断是否已经关闭</li>
<li>如果 awaitTermination 超时，就可以进入循环关闭，循环一定次数(比如1000次)，不断关闭线程池，直到关闭或者结束</li>
<li>如果 awaitTermination 返回false 或者 被中断，调用 shutDownNow 立即关闭</li>
</ol>
<h3 id="1-6-11-Executors-快捷创建线程池的潜在问题-系统默认提供的4种方法"><a href="#1-6-11-Executors-快捷创建线程池的潜在问题-系统默认提供的4种方法" class="headerlink" title="1.6.11 Executors 快捷创建线程池的潜在问题(系统默认提供的4种方法)"></a>1.6.11 Executors 快捷创建线程池的潜在问题(系统默认提供的4种方法)</h3><ul>
<li>newFixedThreadPool创建的固定大小线程池：它的阻塞队列是 LinkedBlockingQueue 类型的无界队列，可能导致大量的任务等待，队列太大还可能导致 OOM </li>
<li>单线程的线程池也是无界队列，可能导致OOM</li>
<li>newCachedThreadPool 创建可缓存线程池：因为核心线程数 0 ，最大线程数为 Integer.MAX_VALUE，阻塞队列为 SynchronousQueue<runnable> 同步队列，不缓存任务，所以理论上任务数量不受限制，相当于来一个任务首先寻找可用线程，没有的话，就创建一个新的。会导致创建的线程过多，可能造成 OOM ，甚至把 CPU资源耗尽</runnable></li>
<li>newScheduledThreadPool 创建可调度线程池，其最大问题是线程数量不设上限，可能导致CPU资源耗尽</li>
</ul>
<h2 id="1-7-确定线程池的线程数"><a href="#1-7-确定线程池的线程数" class="headerlink" title="1.7 确定线程池的线程数"></a>1.7 确定线程池的线程数</h2><h3 id="1-7-1-按照任务类型分类"><a href="#1-7-1-按照任务类型分类" class="headerlink" title="1.7.1 按照任务类型分类"></a>1.7.1 按照任务类型分类</h3><ul>
<li>IO 密集型： IO任务操作时间长，导致 CPU 利用率不高，常处于空闲状态。线程数确定：设置allowCoreThreadTimeOut为true、使用有界队列、corePollSize 和 maximunPoolSize 保持一致，使得接收新任务而没有空闲线程时，直接创建新线程执行，而不是在阻塞队列中等待。</li>
<li>CPU 密集型： 主要是计算任务，CPU一直在运行，利用率很高。线程数确定：CPU密集型任务虽然可以并行完成，但是并行任务越多，花在任务切换的时间也越多，效率也就越低。<strong>CPU密集型任务并行执行的数量应当等于CPU的核心数</strong>。</li>
<li>混合性任务：既要逻辑计算，又要IO。线程数确定：业界有一个公式</li>
</ul>
<h2 id="1-8-ThreadLocal-原理与实战"><a href="#1-8-ThreadLocal-原理与实战" class="headerlink" title="1.8 ThreadLocal 原理与实战"></a>1.8 ThreadLocal 原理与实战</h2><p>ThreadLoacal 的应用场景大致有 2 类：</p>
<ul>
<li>线程隔离</li>
<li>跨函数传递数据</li>
</ul>
<p>原理：每一个线程在获取本地值时，都会将 ThreadLocal 实例作为 Key 从自己拥有的 ThreadLocalMap 中获取值，别的线程无法访问自己的 ThreadLocalMap ，自己也无法访问别人的。并且，由于 ThreadLocalMap 是线程私有的，当线程销毁时 ThreadLocalMap 也随之销毁，在一定程度上减少内存的消耗。</p>
<h3 id="1-8-8-ThreadLocal-综合使用案例"><a href="#1-8-8-ThreadLocal-综合使用案例" class="headerlink" title="1.8.8 ThreadLocal 综合使用案例"></a>1.8.8 ThreadLocal 综合使用案例</h3><p>ThreadLocal 使用不当会造成严重的内存泄露，为了避免这种情况，使用时应遵守以下原则：</p>
<ul>
<li>尽量使用 private static final 修饰ThreadLocal ，final为了避免他人修改、变更 ThreadLocal 变量的引用，使用static 为了确保全局唯一</li>
<li>ThreadLocal 使用完后务必调用 remove 方法，这是简单有效避免引发内存泄露问题的方法</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/06/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/%E7%AC%AC6%E7%AB%A0-%E5%85%B6%E4%BB%96%E4%BC%98%E7%A7%80%E7%9A%84%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/06/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/%E7%AC%AC6%E7%AB%A0-%E5%85%B6%E4%BB%96%E4%BC%98%E7%A7%80%E7%9A%84%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">第6章-其他优秀的热修复方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-06 18:30:00" itemprop="dateCreated datePublished" datetime="2023-02-06T18:30:00+08:00">2023-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-05 22:01:57" itemprop="dateModified" datetime="2023-02-05T22:01:57+08:00">2023-02-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="Dexposed浅析"><a href="#Dexposed浅析" class="headerlink" title="Dexposed浅析"></a>Dexposed浅析</h2><p>Dexposed 对于某个函数而言，有3个hook点可供选择：函数执行前注入（before），函数执行后注入（after），替换函数执行的代码段（replace），由此衍生了很多典型应用场景：</p>
<ul>
<li><p>AOP 编程</p>
</li>
<li><p>插桩（例如测试，性能监控等）</p>
</li>
<li><p>在线热更新</p>
</li>
<li><p>SDK hooking 以提供更好的开发体验</p>
</li>
</ul>
<h3 id="AndFix"><a href="#AndFix" class="headerlink" title="AndFix"></a>AndFix</h3><p>略</p>
<h3 id="腾讯系热修复方案简介"><a href="#腾讯系热修复方案简介" class="headerlink" title="腾讯系热修复方案简介"></a>腾讯系热修复方案简介</h3><p>略</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/05/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/%E7%AC%AC5%E7%AB%A0-so%E5%BA%93%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/05/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/%E7%AC%AC5%E7%AB%A0-so%E5%BA%93%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">第5章-so库热修复技术</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-05 21:30:00 / 修改时间：21:53:09" itemprop="dateCreated datePublished" datetime="2023-02-05T21:30:00+08:00">2023-02-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="so库加载原理"><a href="#so库加载原理" class="headerlink" title="so库加载原理"></a>so库加载原理</h2><p>Java API 提供 2 个接口加载一个 so 库：</p>
<ul>
<li><p>System.loadLibrary(String libName): 传进去 so 库名称，位于APK压缩文件的 libs 目录，最后复制到 APK 安装目录下</p>
</li>
<li><p>System.load(String pathName)：传进去的是so库在磁盘的完整路径，加载自定义的外部so</p>
</li>
</ul>
<p>以上2中方式最后都调用到 nativeLoad 这个 Native 方法。</p>
<p><strong>so 库实时生效方案，对于静态注册的 native 方法有一定的局限性，不能满足一般的通用性，所以放弃了 so 库实时生效需求，转而求其次，实现 so 库修复的冷部署重启生效方案。</strong></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/04/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/%E7%AC%AC4%E7%AB%A0-%E8%B5%84%E6%BA%90%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/04/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/%E7%AC%AC4%E7%AB%A0-%E8%B5%84%E6%BA%90%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">第4章-资源热修复技术</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-04 17:00:00" itemprop="dateCreated datePublished" datetime="2023-02-04T17:00:00+08:00">2023-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-05 21:43:28" itemprop="dateModified" datetime="2023-02-05T21:43:28+08:00">2023-02-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="普遍的实现方式"><a href="#普遍的实现方式" class="headerlink" title="普遍的实现方式"></a>普遍的实现方式</h2><p>目前市面上很多资源热修复都参考了 Instant Run 的实现，首先看下 Instant Run 是怎么做到资源热修复的：</p>
<ol>
<li><p>创建一个新的 AssetManager (AssetManager.class.getConstructor().newInstance())，并通过反射调用 addAssetPath 添加 sdcard 上的新资源包</p>
</li>
<li><p>反射所有 Activity 中 AssetManager 的引用处，全部换成刚才新建的 newAssetManager</p>
</li>
<li><p>得到 Resource 的弱引用集合，把它们的 AssetManager 成员替换成 newAssetManager</p>
</li>
</ol>
<p>总体来说就是2步：构造一个新的 AssetManager ，并通过反射调用 addAssetPath ，这样就得到一个含有所有新资源的 AssetManager；找到所有引用到原有 AssetManager 的地方，通过反射把引用处替换成 newAssetManager 。</p>
<h3 id="资源文件的格式"><a href="#资源文件的格式" class="headerlink" title="资源文件的格式"></a>资源文件的格式</h3><p>我们随便找个带资源的APK，用 AAPT 解析以下，可以看到内容大概是这样的：</p>
<blockquote>
<p>aapt d resources App-debug.apk</p>
<p>…</p>
<p>spec resource 0x7f040019 com.taobao.demo:layout/activity_main:flags=0x00000000</p>
</blockquote>
<p>这就表示，activity_main.xml 这个资源编号是 0x7f040019， 其中packageid 是 0x7f ， 资源类型id 是 0x04 ，在Type String Pool 中对应的正是 layout 类型，而 0x04 类型的 第 0x0019 个资源就是 activity_main 这个资源。</p>
<h3 id="运行时资源的解析"><a href="#运行时资源的解析" class="headerlink" title="运行时资源的解析"></a>运行时资源的解析</h3><p>默认由 Android SDK 编出来的 APK 是由 AAPT 工具打包的，其资源包的 package id 就是 0x7f 。<strong>在走到 App第一行代码之前，系统就已经帮我们构建好一个已经添加了安装包资源的 AssetManager 了，即包含了 package id 为0x01 的 framework-res.jar 中资源和 package id 为 0x7f 的 App 安装包资源</strong>。</p>
<p>如果补丁包中资源的 package id 也是 0x7f ，就会使得同一个 package id 的包被加载2次，怎么解决呢？</p>
<blockquote>
<p>在Android L 之后这是没问题的，因为它会默默把后来的包添加到之前的包的同一个 PackageGroup 下面，仍旧会加入到该类型的 TypeList 中，只是会打出一个 warning log。但是，使用时获取某个 Type 资源时，会从前往后遍历，也就是说先得到原有安装包里的资源，补丁包中的资源永远无法生效了。<strong>所以，在Android L 以上的版本，在原有的 AssetManager 上加入补丁包，是没有任何作用的。</strong></p>
<p>而在 Android 4.4 以下版本，addAssetPath 只是把补丁包的路径添加到了 mAssetPath 中，这时候早已经错过真正解析资源包时间了。</p>
</blockquote>
<p><strong>以上解释了为什么像 Instant Run 这种方案，一定需要一个全新的 AssetManager ，然后再加入完整的新资源包，替换原有的 AssetManager。</strong></p>
<h4 id="另辟蹊径的资源修复方案"><a href="#另辟蹊径的资源修复方案" class="headerlink" title="另辟蹊径的资源修复方案"></a>另辟蹊径的资源修复方案</h4><p>一个好的资源修复方案，首先补丁包要足够小，直接下发完整的补丁包肯定是不行的。目前主要有以下方案：</p>
<ul>
<li><p>对资源包做差量处理，在运行时合成完整包，虽然减少了包体积，但是运行时的合成操作耗费了运行事件和内存。</p>
</li>
<li><p>自己修改 AAPT ，在打补丁包时对资源重新编号，这样会涉及修改 Android SDK 工具包，不利于集成，也无法很好地对将来的 AAPT 升级。</p>
</li>
</ul>
<p>我们的方案：构造一个package id 为 id 0x66 的资源包，它只包含改变了的资源项，直接在原有 AssetManager 中 addAssetPath 这个包即可。补丁包的资源，只包含原有包没有而新报里面有的<strong>新增资源</strong>，以及<strong>发生了改变的资源</strong>。对于增加、减少、修改这3种情况，我们要如何处理呢？</p>
<ul>
<li><p>新增资源直接假如补丁包</p>
</li>
<li><p>减少资源，只要不使用这个资源就好了</p>
</li>
<li><p>修改资源，比如替换了一张图片，那么将其视为新增资源，在打入补丁包的时候，代码引用处也做相应修改，把原来使用的旧资源id的地方变为新的 id</p>
</li>
</ul>
<p>一张图说明下这些情况(绿线表示新增资源，红线表示发生修改的资源，黑线表示内容没有变化，但是id发生了变化的，x表示删除了的资源)：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-2-%E8%B5%84%E6%BA%90%E8%A1%A5%E4%B8%81%E5%8C%85%E6%9E%84%E5%BB%BA.png" alt="资源补丁包构建"></p>
<h4 id="新增的资源及其导致的id偏移"><a href="#新增的资源及其导致的id偏移" class="headerlink" title="新增的资源及其导致的id偏移"></a>新增的资源及其导致的id偏移</h4><p><strong>新资源插入的位置是随机的，这与每次 AAPT 打包时解析 XML 的顺序有关。</strong></p>
<p>所以，新增的资源导致它们所属的 type 中跟在它们之后的资源 id 发生了位移，<strong>发生位移的资源不会加入补丁包中，但是在补丁包的代码中会调整 id 的引用处，</strong>如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageView.setImageResource(R.drawable.holo)</span><br></pre></td></tr></tbody></table></figure>

<p>R.drawable.holo 是一个int 值，它的值是 AAPT 指定的，可以用反编译工具可以看到它的真实值：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageView.setImageResource(<span class="number">0x7f020002</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>打出一个新包时，对于开发者而言，holo 的图片内容没变，代码引用处也没变，但是在新包里面，同样这句话，由于新资源插入导致 id 改变，所以引用实际变成了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageView.setImageResource(<span class="number">0x7f020003</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>但这种情况不属于资源改变，更不属于代码改变，所以，我们在对比新旧代码之前，会把新包里面的这行代码修正为原来的id：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageView.setImageResource(<span class="number">0x7f020002</span>)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="内容发生改变的资源"><a href="#内容发生改变的资源" class="headerlink" title="内容发生改变的资源"></a>内容发生改变的资源</h4><p>内容发生改变，比如 activity_main.xml 文件内容改变了，也可能我们修改了string 类型的值，他们都会加入到补丁包中，并重新编号，相应代码也会改变：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setContentView(R.layout.activity_main)</span><br></pre></td></tr></tbody></table></figure>

<p>实际上就是：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setContentView(<span class="number">0x7f030000</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>在生成新旧代码对比之前，我们会把新包里面的这行代码改为：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setContentView(<span class="number">0x66020000</span>)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这样，新旧代码对比时，会检测到这行代码发生了改变，于是相应的代码修复会在运行时发生，这样就得到了正确的新内容资源。</strong></p>
<h4 id="删除了的资源"><a href="#删除了的资源" class="headerlink" title="删除了的资源"></a>删除了的资源</h4><p>不影响补丁包，就不多言</p>
<h4 id="对于type的影响"><a href="#对于type的影响" class="headerlink" title="对于type的影响"></a>对于type的影响</h4><p>上面说的所谓简单，值得是运行时应用补丁变得简单了。真正复杂的地方在于构造补丁。</p>
<h3 id="更优雅地替换-AssetManager"><a href="#更优雅地替换-AssetManager" class="headerlink" title="更优雅地替换 AssetManager"></a>更优雅地替换 AssetManager</h3><p>分2种情况：</p>
<ul>
<li><p>对于 Android L 以后的版本，直接在原有 AssetManager 上应用补丁就行了，并且由于是应用原来的 AssetManager ，与 Instant Run 方案比，省略了大量的反射和替换操作，提升了加载补丁的效率</p>
</li>
<li><p>之前提过，在Android KK 和以下版本，addAssetPath 是不会加载资源的。<strong>我们对原有的 AssetManager 先进行析构，再重构的时候将补丁包资源也加入，用的还是原来的 AssetManager，同样避免了反射和替换操作</strong>（Instant Run  方案还是必须重新构造一个新的 AssetManager 并加入补丁包，再替换原来的）</p>
</li>
</ul>
<h3 id="意料之外的资源问题"><a href="#意料之外的资源问题" class="headerlink" title="意料之外的资源问题"></a>意料之外的资源问题</h3><p>在加载完补丁之后，如果做了 new WebView() 操作，就会发现找不到新资源的问题，这是因为 WebView 初始化时可能会构造新的 ResourceImpl ，替换掉了原先的 ResourceImpl ，从而把补丁资源给一起丢掉了。其他的就不展开。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>对比市面上的方案，我们的方案优势：</p>
<ul>
<li><p>不侵入打包，直接对比新旧资源即可产生补丁资源（对比修改 AAPT）</p>
</li>
<li><p>不必下发完整包，补丁中只有变动的资源（对比 Instant Run、Amigo等方式）</p>
</li>
<li><p>不需要在运行时合成完整包，不占用运行时的计算和内存资源（对比Tinker）</p>
</li>
</ul>
<p>唯一需要注意的是，<strong>因为对新资源的引用是在新代码中，所有资源修复需要代码修复的支持的</strong></p>
<p>可能的问题：查找旧 id 的时候，是直接对 int 值替换，所以会找到 0x7f?????? ，如果开发者也使用了 0x7f?????? 这样的数字，就会导致数字会被错误地转换。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">139</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共296.9k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/',]
      });
      });
  </script>


</body>
</html>
