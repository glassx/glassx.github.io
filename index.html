<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="生活是天籁，需要凝神静听">
<meta property="og:type" content="website">
<meta property="og:title" content="glassx的小黑屋">
<meta property="og:url" content="https://glassx.github.io/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="生活是天籁，需要凝神静听">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="glassx,码农">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://glassx.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">153</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/14/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC15%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/14/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC15%E7%AB%A0/" class="post-title-link" itemprop="url">第15章：TCP数据流与窗口管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-14 19:50:00 / 修改时间：20:50:27" itemprop="dateCreated datePublished" datetime="2023-03-14T19:50:00+08:00">2023-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="15-3-延时确认"><a href="#15-3-延时确认" class="headerlink" title="15.3 延时确认"></a>15.3 延时确认</h2><p>累积确认可以允许 TCP 延迟一段时间发送 ACK ，<strong>以便将 ACK 和相同方向上需要传的数据结合发送</strong>。不过TCP 不能任意时长地延迟 ACK，否则对方会误认为数据丢失而出现不必要的重传。</p>
<h2 id="15-4-Nagle-算法"><a href="#15-4-Nagle-算法" class="headerlink" title="15.4 Nagle 算法"></a>15.4 Nagle 算法</h2><p>从前面可知， ssh 连接中，通常单次按键就会引发数据流的传输。这些包很小，但是会造成相当高的网络传输代价，也就是说与其他包相比，有效的应用数据占比较低（IP头部有 20 字节，TCP头部 20 字节，数据部分仅仅 48 字节）。</p>
<p>Nagle 算法要求：当一个 TCP 在传数据时，小的报文段不能被发送，直到所有的在传数据都收到了 ACK，并且，TCP 需要收集这些小数据，将其整合到一个报文段中发送。</p>
<h3 id="15-5-流量控制与窗口管理"><a href="#15-5-流量控制与窗口管理" class="headerlink" title="15.5 流量控制与窗口管理"></a>15.5 流量控制与窗口管理</h3><p>前面提到可以采用可变滑动窗口来实现流量控制。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/14/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC14%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/14/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC14%E7%AB%A0/" class="post-title-link" itemprop="url">第14章：TCP超时与重传</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-14 09:00:00 / 修改时间：19:48:00" itemprop="dateCreated datePublished" datetime="2023-03-14T09:00:00+08:00">2023-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="14-1-引言"><a href="#14-1-引言" class="headerlink" title="14.1 引言"></a>14.1 引言</h2><p>TCP 拥有<strong>2套</strong>独立的机制来完成重传：</p>
<ul>
<li><p><strong>基于时间:</strong> 发送数据后设置计时器，若超时还未收到数据确认，则触发超时重传。</p>
</li>
<li><p><strong>基于确认信息的构成:</strong> 也叫做<strong>快速重传</strong>，通常发生在没有延时的情况下（根据以前的知识就是连续收到 3 个相同的 ACK），重传可能丢失的分组</p>
</li>
</ul>
<p>当失序数据到达时，重复 ACK 应当立即返回，不能延时发送，原因在于 <strong>使发送端尽早得知有失序报文，并告诉其空缺在哪</strong></p>
<blockquote>
<p>与超时重传相比，快速重传能更有效地修复丢包情况</p>
</blockquote>
<h2 id="14-3-设置超时重传"><a href="#14-3-设置超时重传" class="headerlink" title="14.3 设置超时重传"></a>14.3 设置超时重传</h2><p>TCP 并非对其接收到的每个报文段都返回 ACK，例如：当传输大批量数据时，TCP 通常采取每2个报文段返回一个 ACK 方法；另外，当数据出现丢失、失序或者重传成功时TCP 的累积确认机制表明报文段与ACK 之间并非严格一一对应的。</p>
<p>在TCP 握手阶段，SYN 、ACK 等数据包并未包含实际数据，由于 <strong>TCP 对不包含数据的报文段不提供可靠传输</strong>，意味着若出现丢包不会重传，因此<strong>无须设定重传计时器</strong>！</p>
<blockquote>
<p>由于接收端在收到失序的数据后会立即返回 ACK，以此来帮助触发快速重传，<strong>因此网络中任何一个失序的数据包都会生成重复的ACK</strong>。如果我们一旦收到重复 ACK 就立即启动快速重传，那就会导致大量不必要的重传发生，为了解决这一问题，快速重传仅在达到<strong>重复阈值</strong>之后才会被触发</p>
</blockquote>
<h2 id="14-10-重新组包"><a href="#14-10-重新组包" class="headerlink" title="14.10 重新组包"></a>14.10 重新组包</h2><p>当TCP 超时重传时，并不需要完全重传相同的报文段。TCP 允许执行<strong>重新组包</strong>发送一个更大的报文来提高性能。</p>
<blockquote>
<p>允许这样做的原因在于，TCP 是通过字节号来识别发送和接收的数据，而非报文段(或包)号。</p>
</blockquote>
<p>可以基于重新组包的方式来检测伪超时。</p>
<h2 id="14-11-与-TCP-重传相关的攻击"><a href="#14-11-与-TCP-重传相关的攻击" class="headerlink" title="14.11 与 TCP 重传相关的攻击"></a>14.11 与 TCP 重传相关的攻击</h2><p>有一类 DoS 攻击称为 低速率DoS 攻击。这类攻击向网关或主机发送大量数据，使得受害系统持续处于重传超时的状态，由于攻击者可以预知受害TCP何时启动重传，并在每次重传时发送大量数据，因此，受害 TCP 总能感知到拥塞的存在，根据Karn算法不断减小发送速率并退避发送，导致无法正常使用网络宽带</p>
<p>解决方案：随机选择 RTO，<strong>使得攻击者无法预知准确的重传时间</strong></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC13%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC13%E7%AB%A0/" class="post-title-link" itemprop="url">第13章：TCP连接管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-13 18:02:00 / 修改时间：18:59:10" itemprop="dateCreated datePublished" datetime="2023-03-13T18:02:00+08:00">2023-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="13-1-引言"><a href="#13-1-引言" class="headerlink" title="13.1 引言"></a>13.1 引言</h2><p>TCP 必须检测并修补所有在 IP 层产生的数据传输问题： 比如丢包、重复 以及 错误。</p>
<h3 id="13-5-2-TIME-WAIT-状态"><a href="#13-5-2-TIME-WAIT-状态" class="headerlink" title="13.5.2 TIME_WAIT 状态"></a>13.5.2 TIME_WAIT 状态</h3><p>TIME_WAIT 状态也称为 2MSL 等待状态，该状态下，TCP 将会等待 2 倍于<strong>最大段生存期（Maximum  Segment Lifetime， MSL</strong>的时间，这段时间连接不可用，等待链路上的报文段过期，防止复用这个连接时，将老的连接中的报文当成新连接发送的数据。</p>
<h3 id="13-5-3-静默时间"><a href="#13-5-3-静默时间" class="headerlink" title="13.5.3 静默时间"></a>13.5.3 静默时间</h3><p>在本地与外地的 IP 地址、端口号 都相同的情况下，2MSL 状态能防止新的连接将前一个连接的延迟报文解释成自身数据的状况。然而，这种方法只有在与<strong>处于2MSL等待状态的连接相关的主机未关闭的情况</strong>才有意义。为什么呢？</p>
<p>假如一台与处于 TIME_WAIT 状态下的链接相关联的主机崩溃，然后再 MSL 内重新启动，并且使用与主机崩溃之前处于 TIME_WAIT 状态的连接相同的 IP 地址与端口号，那要怎么处理呢？解决办法就是：在崩溃或者重启后，TCP 应该在创建新的连接之前等待一个 MSL 的时间，这段时间称为 <strong>静默时间</strong>。</p>
<h2 id="13-8-与-TCP-连接管理相关的攻击"><a href="#13-8-与-TCP-连接管理相关的攻击" class="headerlink" title="13.8 与 TCP 连接管理相关的攻击"></a>13.8 与 TCP 连接管理相关的攻击</h2><p>SYN 洪泛攻击时一种 TCP 拒绝服务攻击。在这种攻击中一个或者多个恶意的客户端产生一系列 TCP 连接尝试，并将他们发送给一台服务器，他们通常采用“伪造”的源 IP 地址。服务器回味每条链接分配一定数量的连接资源，由于连接尚未完全建立，服务器为了维护大量的半打开连接会在耗尽自身内存后拒绝为后续的合法连接请求服务。</p>
<blockquote>
<p>解决办法：只有当 SYN+ACK 报文段本身被确认后，才会分配真正的内存</p>
</blockquote>
<p>还有一种攻击与路径最大传输单元发现过程相关。攻击者伪造一个非常小的 MTU 值，迫使受害的 TCP  尝试采用非常小的数据报来填充数据，从而大大降低性能。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC12%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC12%E7%AB%A0/" class="post-title-link" itemprop="url">第12章：TCP:传输控制协议（初步）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-13 16:00:00 / 修改时间：18:01:08" itemprop="dateCreated datePublished" datetime="2023-03-13T16:00:00+08:00">2023-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="12-1-引言"><a href="#12-1-引言" class="headerlink" title="12.1 引言"></a>12.1 引言</h2><h3 id="12-1-1-ARQ-和-重传"><a href="#12-1-1-ARQ-和-重传" class="headerlink" title="12.1.1 ARQ 和 重传"></a>12.1.1 ARQ 和 重传</h3><p>重传的时候，接收方可能收到被传送分苏的重复副本，这就要求使用序列号来解决：在被远端发送时，每个唯一的分组都有一个新的序列号。</p>
<p>如果想要吞吐量更高，我们就要求在网络中可以同时存在多个分组，这就变得更加复杂：发送方不仅要决定什么时候注入一个分组到网络中，还要考虑注入多少个，并且在等待 ACK 的时候，怎样维持计时器，同时还需要保存每个还没收到 ACK 分组的副本防止重传需要。</p>
<h3 id="12-1-2-分组窗口和滑动窗口"><a href="#12-1-2-分组窗口和滑动窗口" class="headerlink" title="12.1.2 分组窗口和滑动窗口"></a>12.1.2 分组窗口和滑动窗口</h3><p>为了解决上述问题，我们假设每个分组有一个序列号，并且定义一个分组窗口作为<strong>已经被发送但是还没完成确认</strong>的分组集合，我们把窗口中分组的数量称为<strong>窗口大小</strong>，如下图所示：</p>
<p><img src="/assets/Book-Notes/TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/12%E7%AB%A0/%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F.png" alt="发送窗口示意图"></p>
<p>上图显示当前窗口有3个分组，整个窗口大小是3。其中，3号分组已经被发送和确认，所以发送方保存的副本可以释放了；分组 7 在发送方已经准备好，但是还没发送，因为还没“进入窗口”。现在假如发送方下一步收到分组 4 的 ACK，此时窗口向右边 “滑动”一个分组，意味着 4 可以释放了，而 7 可以发送了。这种就叫做 “滑动窗口”协议。</p>
<p>一般来说，这个滑动窗口在发送方和接收方都会有，在发送方，它记录着哪些分组可以释放，哪些正在等待 ACK，哪些分组还不能被发送；在接收方，它记录着哪些分组已经被接收和确认，哪些分组时下一步期望的，哪些分组即使接收了也会被丢弃。</p>
<h3 id="12-1-3-变量窗口：流量控制和拥塞控制"><a href="#12-1-3-变量窗口：流量控制和拥塞控制" class="headerlink" title="12.1.3 变量窗口：流量控制和拥塞控制"></a>12.1.3 变量窗口：流量控制和拥塞控制</h3><p>为了处理接收方相对发送方太慢的问题，我们在接收方跟不上时会强迫发送方慢下来，这称为<strong>流量控制</strong>。主要有以下2种方式：</p>
<ul>
<li><p>基于速率流量控制：给发送方指定某个速率，去报数据不能超过这个速率发送。多用于流应用程序，可被用于广播和组播发现</p>
</li>
<li><p>基于窗口流量控制：这是使用滑动窗口最流行的方法，思想是：窗口大小不固定，允许随时间变化而变化，必须有一种方法让接收方可以通知到发送方使用多大窗口（即窗口通告）</p>
</li>
</ul>
<p>拥塞控制用于发送方减低速度以不至于压垮发送方与接收方之间的网络。</p>
<h2 id="12-2-TCP的引入"><a href="#12-2-TCP的引入" class="headerlink" title="12.2 TCP的引入"></a>12.2 TCP的引入</h2><p>TCP 提供一种字节流抽象概念给应用程序使用，这就意味着没有消息边界。举例解释一下：如果应用程序一一端写入 10 字节，随后又写入 20 字节，再随后写入 50 字节，那么在另一端时不知道每次写入多少字节的；另一端可能以每次读取20字节分4次读取或者一次性读取80字节的方式读取。</p>
<p><strong>TCP根本不会解读字节流中的字节内容</strong>，它不知道传输的是二进制数据、ASCII 还是其他东西。</p>
<h3 id="12-2-2-TCP中的可靠性"><a href="#12-2-2-TCP中的可靠性" class="headerlink" title="12.2.2 TCP中的可靠性"></a>12.2.2 TCP中的可靠性</h3><p>TCP 必须把应用程序发送的字节流转换为一组 IP可以携带的分组，这被称为组包。这些分组包含序列号，该序列号在TCP 中代表了每个分组的第一个字节在整个数据流中的字节偏移，而不是分组号。TCP传给IP的块称为 <strong>报文段</strong>。</p>
<p>而UDP 就不同了，应用程序每次写入通常就产生一个 UDP 数据，其大小就是写入的那么大（加上头部）。</p>
<p>TCP 发送一组报文段时会设置一个<strong>重传计时器</strong>，等待对方的确认。不过它不会为每个报文段设置，而是发送一个窗口的数据，它只设置一个计时器，当 ACK 到达时再更新超时。如果有一个确认没有及时接收到，这个报文段就会被重传。</p>
<h2 id="12-3-TCP-头部封装"><a href="#12-3-TCP-头部封装" class="headerlink" title="12.3 TCP 头部封装"></a>12.3 TCP 头部封装</h2><p>UDP 的头部一般是 8 字节，TCP 头部通常是 20 个字节（带选项的话可达 60 字节）。每个TCP 的头部都包含了 源和目的IP地址，以及源和目的 端口号。</p>
<blockquote>
<p>在 TCP 术语中，一个 IP 地址和一个端口的组合被称为 套接字（Socket） 或者 端点（endpoint）</p>
</blockquote>
<p>TCP 报文段的数据部分是可选的，基于后面的知识我们可以看到：当一个连接被建立和终止时（我理解的是 握手和挥手），交换的报文段只包含 TCP 头部而没有数据。</p>
<h2 id="12-4-总结"><a href="#12-4-总结" class="headerlink" title="12.4 总结"></a>12.4 总结</h2><p>处理传输过程的差错主要有2种方法：</p>
<ul>
<li><p>差错校正码：添加一些冗余比特，使得即使某些比特被毁，真实的信息也能被恢复过来</p>
</li>
<li><p>重传，直至信息被正确接收</p>
</li>
</ul>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC10%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71/%E4%B9%A6-TCP:IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71-%E7%AC%AC10%E7%AB%A0/" class="post-title-link" itemprop="url">第10章：用户数据报协议和IP分片</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-13 14:37:00 / 修改时间：15:59:36" itemprop="dateCreated datePublished" datetime="2023-03-13T14:37:00+08:00">2023-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="10-2-UDP-头部"><a href="#10-2-UDP-头部" class="headerlink" title="10.2 UDP 头部"></a>10.2 UDP 头部</h2><p>在UDP 中，源端口号是可选的，如果数据报的发送者不要求对方回复的话，它可以被置为 0。</p>
<p>TCP 的端口号只能被 TCP 使用，UDP 端口号只能被 UDP 使用，以此类推。这样导致的一个结果就是：2个完全不同的服务器可以使用相同的端口号和 IP 地址，只要它们属于不同的传输协议。</p>
<p>UDP 头部中的 Length 字段表示的是长度，这个长度包括 UDP 头部 和 UDP 数据 的总长度；需要注意的是，发送一个带 0 字节数据的 UDP 数据报是允许的，尽管很少见。</p>
<h2 id="10-3-UDP-校验和"><a href="#10-3-UDP-校验和" class="headerlink" title="10.3 UDP 校验和"></a>10.3 UDP 校验和</h2><p>UDP 在 IPv4 头部中的校验和只覆盖整个头部（并不覆盖IP分组中的任何数据），头部中的校验和是可选的。不过，在 IPv6 中，UDP 的校验和的计算与使用时强制的，因为在 IP 层没有头部校验和。</p>
<h2 id="10-7-IP-分片"><a href="#10-7-IP-分片" class="headerlink" title="10.7 IP 分片"></a>10.7 IP 分片</h2><p>链路层通常对可传输的每个帧的最大长度有一个上限， IP 比较外出接口的 MTU 和数据大小，如果数据报太大则进行分片。当一个 IP 数据报被分片了，直到它到大最终目的地才会被重组，这是为什么呢？为什么不在中途重组呢？有 2 个原因，第 2 个原因比第 1 个原因更重要：</p>
<ol>
<li><p>在网络中不进行重组要比重组更能减轻路由转发软件（或硬件）的负担</p>
</li>
<li><p>同一数据报的不同分片可能经由不同的路径到达相同的目的地。也就是说路径上的路由通常没有能力来重组原始数据报（因为手头只有所有分片的一个子集）</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>UDP 不提供差错纠正、队列管理、重复消除、流量控制和拥塞控制，它提供了差错检测，包含校验和。当要避免连接的开销、使用多端点（组播/广播）传送时，或者不需要 TCP 相对“笨重”的可靠语义时，最常用的就是 UDP，主要用途就是支持 DNS ，多媒体上也得到广泛使用。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/13/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC7%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC7%E7%AB%A0/" class="post-title-link" itemprop="url">第7章：Kotlin协程在Android上的应用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-13 11:33:00" itemprop="dateCreated datePublished" datetime="2023-03-13T11:33:00+08:00">2023-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-11 11:51:57" itemprop="dateModified" datetime="2023-03-11T11:51:57+08:00">2023-03-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>未开始</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/11/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/11/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">第5章：Kotlin协程框架开发初探</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-11 09:10:00" itemprop="dateCreated datePublished" datetime="2023-03-11T09:10:00+08:00">2023-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-10 21:01:35" itemprop="dateModified" datetime="2023-03-10T21:01:35+08:00">2023-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>为了学习官方协程，我们先实现一些轻量级的复合协程，只是用于学习，不适合生产环境。</p>
<h2 id="5-1-开胃菜：实现一个-delay-函数"><a href="#5-1-开胃菜：实现一个-delay-函数" class="headerlink" title="5.1 开胃菜：实现一个 delay 函数"></a>5.1 开胃菜：实现一个 delay 函数</h2><p>使用线程的时候，如果希望代码延迟一段时间再执行，通常会调用 Thread.sleep 函数，<strong>这会令当前线程阻塞</strong>。在协程中也可以这样，不过协程可以挂起还去阻塞线程，就很浪费资源，我们的目的是后面的代码延迟一段时间执行，因此可以确定以下2点：</p>
<ul>
<li><p>不要阻塞线程</p>
</li>
<li><p>是个挂起函数，指定时间之后能够恢复执行即可</p>
</li>
</ul>
<p>从上面 2 点我们可以给出 delay 函数的声明： </p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(time: <span class="type">Long</span>, unit: <span class="type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">    。。。</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来要考虑挂起，<strong>自然就想到了 suspendCoroutin</strong>：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(time: <span class="type">Long</span>, unit: <span class="type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> {</span><br><span class="line">    。。。</span><br><span class="line">    suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; {continuation: Continuation&lt;<span class="built_in">Unit</span>&gt; -&gt;  </span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    。。。</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>只需要做到在指定的 time 之后执行 continuation.resume() 就行，因此，<strong>我们只需要提供这样一个定时回调机制就可以！</strong>,定时任务很容易想到 <strong>ScheduledExecutorService</strong>，因此代码可以这样写：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> executor = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="keyword">object</span> : ThreadFactory{</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newThread</span><span class="params">(r: <span class="type">Runnable</span>)</span></span>: Thread {</span><br><span class="line">        <span class="keyword">return</span> Thread(r, <span class="string">"Scheduler"</span>).apply {</span><br><span class="line">            isDaemon = <span class="literal">true</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>这里为什么要设置 isDaemon ，放到后面说。接着我们可以实现功能了：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(time: <span class="type">Long</span>, unit: <span class="type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> {</span><br><span class="line">    suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; {continuation: Continuation&lt;<span class="built_in">Unit</span>&gt; -&gt;</span><br><span class="line">        executor.schedule(<span class="keyword">object</span>: Runnable{</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> {</span><br><span class="line">                continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">            }</span><br><span class="line">        }, time, unit)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="5-1-1-为什么这样用-ScheduledExecutorService（自己加的标题）"><a href="#5-1-1-为什么这样用-ScheduledExecutorService（自己加的标题）" class="headerlink" title="5.1.1 为什么这样用 ScheduledExecutorService（自己加的标题）"></a>5.1.1 为什么这样用 ScheduledExecutorService（自己加的标题）</h3><p>了解 ScheduledExecutorService 工作机制的朋友还会有疑惑：Scheduled-ExecutorService <strong>在等待延时的阶段还是会阻塞</strong>，这不也浪费资源吗？这里说明下2个原因：</p>
<ul>
<li><p>如果当前线程有特殊地位，例如 UI线程 等，那么它们是不能被阻塞的，因此我们将阻塞动作放到后台线程上是有意义的</p>
</li>
<li><p>后台<strong>一个线程可以承载非常多的延时任务</strong>，例如：有 10 个协程调用 delay ，那么只需要阻塞一个 后台线程即可实现这 10 个协程的延时执行 ！参考下图：</p>
</li>
</ul>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3kotlin%E5%8D%8F%E7%A8%8B/%E7%AC%AC5%E7%AB%A0/%E5%A4%9A%E4%B8%AAdelay%E5%8D%8F%E7%A8%8B%E5%85%AC%E7%94%A8%E4%B8%80%E4%B8%AA%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B.png" alt="多个delay协程公用一个后台线程"></p>
<h2 id="5-2-协程的描述"><a href="#5-2-协程的描述" class="headerlink" title="5.2 协程的描述"></a>5.2 协程的描述</h2><p>Java 平台上 Thread 的定义很直观，让人很容易识别 Java 线程；而协程一开始只是在标准库中放了协程基础设施，导致难以上手和分辨。这里我们尝试给一个类来描述协程，按照官方的做法把它命名为 Job ，如下代码清单：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Job</span> : <span class="type">CoroutineContext.Element {</span></span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;Job&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt; <span class="keyword">get</span>() = Job</span><br><span class="line">    <span class="keyword">val</span> isActive: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnCancel</span><span class="params">(onCancel: <span class="type">OnCancel</span>)</span></span>: Disposable</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnCompletion</span><span class="params">(onComplete: <span class="type">OnComplete</span>)</span></span>: Disposable</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(disposable: <span class="type">Disposable</span>)</span></span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>与 Thread 相比， Job 同样有 join ，调用时会挂起( 而线程的 join 则会阻塞线程 )，直到协程完成；cancel() 类比与 Thread 的 interrupt() ，用于取消协程； isAlive() 类比 Thread 的 isAlive()  ，用于查询协程是仍在执行。</p>
<p>invokeOnCancel 用于协程取消时的回调；invokeOnCompletion 可以注册协程完成的回调。remove 用于移除回调。 key 将协程 Job 存入上下文，这样就很容易拿到 Job 实例。</p>
<h3 id="5-2-2-协程的状态"><a href="#5-2-2-协程的状态" class="headerlink" title="5.2.2 协程的状态"></a>5.2.2 协程的状态</h3><p>我们对协程进行封装，目的就是让它状态更容易管理。对于协程来讲，启动之后主要就是 <strong>未完成、已取消、已完成</strong>这几种状态，接下来定义一下状态：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineState</span> </span>{</span><br><span class="line">    <span class="comment">//未完成：协程启动后立即进入该状态，直到完成获取取消</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Imcomplete</span> : <span class="type">CoroutineState</span></span>()</span><br><span class="line">    <span class="comment">//已取消：协程被取消后立即进入该状态</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cancelling</span> : <span class="type">CoroutineState</span></span>()</span><br><span class="line">    <span class="comment">//已完成：协程执行完后（不管成功失败）进入该状态</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Complete</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> value: T? = <span class="literal">null</span>, <span class="keyword">val</span> exception: Throwable? = <span class="literal">null</span>) : CoroutineState()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>——————-中间略过一大截，看不懂—————————–</p>
<h2 id="5-4-协程的执行调度"><a href="#5-4-协程的执行调度" class="headerlink" title="5.4 协程的执行调度"></a>5.4 协程的执行调度</h2><p>协程在哪里挂起、什么时候恢复都是开发者自己决定的，意味着不像线程那样把调度工作交给操作系统，而是在用户态解决，所以协程也经常被称为<strong>用户态线程</strong>。</p>
<h3 id="5-4-2-协程的调度位置"><a href="#5-4-2-协程的调度位置" class="headerlink" title="5.4.2 协程的调度位置"></a>5.4.2 协程的调度位置</h3><p><strong>当协程执行到挂起点为止时，如果产生异步行为，协程就会在这个挂起点挂起</strong>，这里的一部情形包括以下形式：</p>
<ul>
<li><p>挂起点对应的挂起函数内部切换了线程，并在线程内部调用 Continuation 的恢复调用来恢复。</p>
</li>
<li><p>挂起函数内部通过某种事件循环机制将 Continuation 的恢复调用转到新的线程调用栈上执行。如：Android平台通过 Handler 的 post 操作，实际上这个过程不一定发生线程切换</p>
</li>
<li><p>挂起函数内部将 Continuation 保存，在后续某个时机再执行恢复调用，这个过程也不一定发生线程切换，但是函数调用栈会发生变化。</p>
</li>
</ul>
<p><strong>综上所述，不管何种形式，恢复和挂起不再同一个函数调用栈中执行就是挂起点挂起的充分条件！</strong>只有当挂起点真正挂起，我们才有机会实现调度，而<strong>实现调度需要使用协程拦截器</strong>。</p>
<h3 id="5-4-3-协程的调度器设计"><a href="#5-4-3-协程的调度器设计" class="headerlink" title="5.4.3 协程的调度器设计"></a>5.4.3 协程的调度器设计</h3><p>官方协程框架的默认调度器就是基于线程池实现的：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DefaultDispatcher : Dispatcher {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> threadGroup = ThreadGroup(<span class="string">"DefaultDispatcher"</span>) </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> threadIndex = AtomicInteger(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> executor = Executors.newFixedThreadPool(</span><br><span class="line">        Runtime.getRuntime().availableProcessors() + <span class="number">1</span></span><br><span class="line">    ) { runnable -&gt;</span><br><span class="line">        Thread(</span><br><span class="line">            threadGroup,</span><br><span class="line">            runnable,</span><br><span class="line">            <span class="string">"<span class="subst">${threadGroup.name}</span>-worker-<span class="subst">${threadIndex.getAndIncrement()}</span>"</span></span><br><span class="line">        ).apply { isDaemon = <span class="literal">true</span> }</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> {</span><br><span class="line">        executor.submit(block)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>调用dispatch 方法的时候，实际上是将 block 扔给 executor 放到线程中执行。</p>
<p>其实也可以实现成基于拦截器的方式：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> {</span><br><span class="line">    dispatcher.dispatch { delegate.resumeWith(result) }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>基于UI事件循环的调度器就是通过在disptch() 方法中用 Handler 的 post 实现：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> AndroidDispatcher : Dispatcher {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> handler = Handler(Looper.getMainLooper()) </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> {</span><br><span class="line">        handler.post(block)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<p>——————-后续的又看懵逼了—————————–</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/10/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC4%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/10/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC4%E7%AB%A0/" class="post-title-link" itemprop="url">第4章：Kotlin协程的拓展实践</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-10 16:55:00 / 修改时间：17:25:33" itemprop="dateCreated datePublished" datetime="2023-03-10T16:55:00+08:00">2023-03-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>前面的介绍了解了协程可以挂起和恢复，但是对于协程如何使用仍然倍感疑惑，所以还需要机遇简单协程构建足够有好的上层 API ，即复合协程。</p>
<h2 id="4-1-序列生成器"><a href="#4-1-序列生成器" class="headerlink" title="4.1 序列生成器"></a>4.1 序列生成器</h2><p>看得云里雾里，先略过</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/03/07/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E9%A6%96%E5%B8%A7%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/07/%E9%9D%A2-%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E9%A6%96%E5%B8%A7%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">MP4视频首帧加载时间过长的问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-07 16:18:00 / 修改时间：22:37:29" itemprop="dateCreated datePublished" datetime="2023-03-07T16:18:00+08:00">2023-03-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>MP4 格式的课程视频从打开播放器到第一帧画面显式，加载时间过长</p>
<h2 id="时间埋点"><a href="#时间埋点" class="headerlink" title="时间埋点"></a>时间埋点</h2><p>博客作者使用的是 ijkPlayer ，我们项目中使用的是 ExoPlayer ，不过这个关系不太大。给播放器加载过程埋点的时候需要关闭播放器自己打印的日志，否则会打印很多无关的内容。在本地视频模式和在线视频模式下分别打印关键方法的耗时。</p>
<p>从作者分析的数据可以看到，在线模式下，首帧耗时为 4.967s ，在线模式下首帧耗时 0.257s ，然后发现主要耗时是 avformat_open_input 方法（Exoplayer中方法可能是另一个）</p>
<h3 id="avformat-open-input-方法"><a href="#avformat-open-input-方法" class="headerlink" title="avformat_open_input 方法"></a>avformat_open_input 方法</h3><p>这个函数的主要作用是<strong>打开一个输入流并且读取它的头部信息</strong>。</p>
<h2 id="分析视频结构"><a href="#分析视频结构" class="headerlink" title="分析视频结构"></a>分析视频结构</h2><p>请求视频头部信息，在 MP4 格式下即为请求 moov 数据，可以使用 Media Parser 解析问题视频如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/Android%E5%9F%BA%E7%A1%80/MP4%E5%A4%B4%E7%BB%93%E6%9E%84.PNG" alt="问题视频数据可视化"></p>
<p>从图可以看出， moov 在视频文件尾部。本地播放时，可以通过指针快速定位到 moov ；<strong>在线播放时，需要先加载一部分头部数据，如 fytp、free、madat 等，计算出 moov 的偏移量，再通过 Http Range Bytes 请求 moov 数据。</strong></p>
<p>moov 数据约有 2.2M ，在线播放视频时，avformat_open_input 方法需要获取全部的 moov 数据，建立索引表后再解析音视频数据。而本地播放无需这个网络请求。</p>
<h2 id="结论及解决方案"><a href="#结论及解决方案" class="headerlink" title="结论及解决方案"></a>结论及解决方案</h2><h4 id="视频头过大导致的首帧过慢"><a href="#视频头过大导致的首帧过慢" class="headerlink" title="视频头过大导致的首帧过慢"></a>视频头过大导致的首帧过慢</h4><p><strong>问题：</strong>视频头过大，导致下载时间比较长，然后首帧出来就比较迟了</p>
<p><strong>解决方案：</strong>避免加载提及过大的视频头：1）将长视频拆分为多个短视频，减少 moov 的长度   2）使用轻量级格式，如分段FLV（爱奇艺、优酷）、DASH （YoTuBe、B站）等方案</p>
<h4 id="结构特性导致首帧过慢"><a href="#结构特性导致首帧过慢" class="headerlink" title="结构特性导致首帧过慢"></a>结构特性导致首帧过慢</h4><p><strong>问题：</strong> moov 在视频文件尾部，多了一次 seek 请求操作，这个问题比上述的问题要轻</p>
<p><strong>解决方案：</strong>在服务端使用 ffmpeg 命令将 moov 文件移到 ftyp 后面</p>
<h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><p><strong>问题：</strong> 播放的时候，还要同时先去下载视频头，导致了耗时较长</p>
<p><strong>解决方案：</strong>预加载，在适当时机提前加载视频头部数据，写入本地文件，播放器从本地读取数据，快速构建索引表，进入首帧解码</p>
<blockquote>
<p>以上内容参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/865c566c0a06">简书上的博客</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2023/02/27/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/27/%E4%B9%A6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Kotlin%E5%8D%8F%E7%A8%8B-%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">第3章：Kotlin协程的基础设施</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-27 14:25:00" itemprop="dateCreated datePublished" datetime="2023-02-27T14:25:00+08:00">2023-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-10 16:54:39" itemprop="dateModified" datetime="2023-03-10T16:54:39+08:00">2023-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><h2 id="3-1-协程的构造"><a href="#3-1-协程的构造" class="headerlink" title="3.1 协程的构造"></a>3.1 协程的构造</h2><h3 id="3-1-1-协程的创建"><a href="#3-1-1-协程的创建" class="headerlink" title="3.1.1 协程的创建"></a>3.1.1 协程的创建</h3><p>Kotlin 提供了一个 createCoroutine 函数用来创建协程：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>其中 suspend() -&gt; T 是 createCoroutin 函数的 Receiver，对 Kotlin 函数不了解的话，这个还是有点费解的。我们依次剖析 createCoroutine 的参数和返回值：</p>
<ul>
<li><p>Receiver 是一个被 suspend 修饰的挂起函数，这也是协程协程的执行体（协程体）</p>
</li>
<li><p>参数是 completion（是 Continuation 类型）会在协程体执行完后调用，实际上就是<strong>协程完成的回调</strong></p>
</li>
<li><p>返回值也是一个 Continuation 对象，由于现在协程仅仅被创建出来，因此需要通过这个值在之后触发协程的启动</p>
</li>
</ul>
<p>以一个例子来说明 createCoroutine 的用法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> continuation = <span class="keyword">suspend</span> {</span><br><span class="line">    println(<span class="string">"In Coroutine."</span>)</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">}.createCoroutine(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt; {</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">        println(<span class="string">"Coroutine End: <span class="variable">$result</span>"</span>)</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>目前协程被创建出来了，但是它还未启动。</p>
<h3 id="3-1-2-协程的启动"><a href="#3-1-2-协程的启动" class="headerlink" title="3.1.2 协程的启动"></a>3.1.2 协程的启动</h3><p>在上述的例子中，我们已经创建了协程，之后只需要调用 continuation.resume(Unit) 之后，协程就会立即开始。为什么这样就可以触发协程体执行呢？</p>
<p>其实，我们创建协程得到的 continuation 是 SafeContinuation 的实例，不过这也是个“马甲”，它有个 delegate 属性，里面将 suspend() -&gt; T  封装成了一个 Continuation 对象</p>
<p><strong>也就是说，我们创建协程得到的 continuation 其实就是套了几层“马甲”的协程体，故调用这个 continuation.resume() 可以触发协程体的执行</strong></p>
<p>一般来讲，我们创建协程之后就会启动它，所以标准库还提供了另一个一步到位的API——startCoroutin ：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(completion: Continuation&lt;T&gt;)</span><br></pre></td></tr></tbody></table></figure>

<p>我们知道，作为参数传入的 completion 就如同回调一样，**协程体的返回值会作为 resumeWith 的参数传入，例如，下面的例子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">suspend</span> {</span><br><span class="line">        println(<span class="string">"我跑在协程里"</span>)</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    }.startCoroutine(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt; {</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">            <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">            println(<span class="string">"协程执行完成，result = <span class="variable">$result</span>"</span>)</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果协程体执行正常，则 result 为 Success 结果；否则返回 Failure 结果。上述代码结果如下：</p>
<blockquote>
<p>我跑在协程里<br>//协程执行完成，result = Failure(java.lang.IllegalStateException: 抛出异常)<br>协程执行完成，result = Success(3)</p>
</blockquote>
<h3 id="3-1-3-协程体的-Receiver"><a href="#3-1-3-协程体的-Receiver" class="headerlink" title="3.1.3 协程体的 Receiver"></a>3.1.3 协程体的 Receiver</h3><p>与协程创建和启动相关的 API 还有一组：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> R.()</span></span> -&gt; T).create(</span><br><span class="line">    receiver: R,</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start 方法略</span></span><br></pre></td></tr></tbody></table></figure>

<p>上述的 R 可以为协程体提供一个作用域，在协程体内我们可以直接使用，如下代码所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先把上述方法封装下，如果不封装怎么调用？</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">launchCoroutine</span><span class="params">(receiver: <span class="type">R</span>, block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span>)</span></span> {</span><br><span class="line">    block.startCoroutine(receiver, <span class="keyword">object</span> : Continuation&lt;T&gt; {</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> {</span><br><span class="line">            println(<span class="string">"Coroutine End: <span class="variable">$result</span>"</span>)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context = EmptyCoroutineContext</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建额外的域</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerScope</span>&lt;<span class="type">T</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">(value: <span class="type">T</span>)</span></span> {</span><br><span class="line">        println(<span class="string">"我在额外的 Receiver 中了: <span class="variable">$value</span>"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    launchCoroutine(ProducerScope&lt;<span class="built_in">Int</span>&gt;()) {</span><br><span class="line">        println(<span class="string">"In Coroutine."</span>)</span><br><span class="line">        produce (<span class="number">1024</span>)</span><br><span class="line">        <span class="comment">//delay (1000)  //我自己测试的时候，如果放开这个注释，就不会打到 2048，coroutine end 也不会执行到</span></span><br><span class="line">        produce (<span class="number">2048</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>这里要注意的一点是，如果额外的域 ProducerScope 添加了 @RestrictsSuspension 注解，则无法使用外部的函数，因此例子中的 delay 也不会调用</p>
</blockquote>
<h3 id="3-1-4-可挂起的-main-函数"><a href="#3-1-4-可挂起的-main-函数" class="headerlink" title="3.1.4 可挂起的 main 函数"></a>3.1.4 可挂起的 main 函数</h3><p>前面我们一直这样写：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样就能在程序入口就获得一个协程了，这到底是怎么实现的呢？首先，我们能确认2点：</p>
<ul>
<li><p>JVM 压根就不知道什么挂起函数，kotlin协程</p>
</li>
<li><p>JVM 肯定有一个 main 函数的</p>
</li>
</ul>
<p>为了搞清楚原理，我们可以对 Kotlin 反编译成 Java 代码（IDEA的 Kotlin byteCode 功能）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>{</span><br><span class="line">   RunSuspendKt.runSuspend(<span class="keyword">new</span> KotlinMainKt$$$main(var0));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，其实它是有真正的 main 函数的，里面的协程封装逻辑都被扔到 RunSuspendKt里面了</p>
<h3 id="3-2-1-挂起函数"><a href="#3-2-1-挂起函数" class="headerlink" title="3.2.1 挂起函数"></a>3.2.1 挂起函数</h3><p>整个 kotlin 语境下有 2种函数： 普通函数和挂起函数，<strong>其中：挂起函数能调用任何函数，但是普通函数不能调用挂起函数。</strong></p>
<p>所谓的协程挂起其实就是程序执行流程发生异步调用时，当前调用流程进入等待状态。注意：<strong>挂起函数不一定真的会挂起，只是提供了挂起的条件</strong>，那额什么情况才会真正挂起呢？</p>
<h3 id="3-2-2-挂起点"><a href="#3-2-2-挂起点" class="headerlink" title="3.2.2 挂起点"></a>3.2.2 挂起点</h3><p>回想下协程的创建过程，我们的协程体本身就是一个 Continuation 实例，正因如此，挂起函数才能在协程体内运行。<strong>在协程体内部，挂起函数的调用处称为挂起点，挂起点如果出现异步调用，当前协程就会被挂起，直到对应的 Continuation.resume 函数被调用才会恢复执行。</strong></p>
<p><strong>异步调用如何发生，取决于 resume 函数与对应的挂起函数的调用是否在相同的调用栈上</strong></p>
<h3 id="3-2-3-CPS-变换"><a href="#3-2-3-CPS-变换" class="headerlink" title="3.2.3 CPS 变换"></a>3.2.3 CPS 变换</h3><p>我们知道，挂起函数如果需要挂起，则需要通过 suspendCoroutine 来获取 Continuation 实例，我们已经知道它是协程体封装成的 Continuation，但是这个实例是怎么传入的呢？先看下面的suspend 函数：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">notSuspend</span><span class="params">()</span></span> = suspendCoroutine&lt;<span class="built_in">Int</span>&gt; { continuation -&gt;</span><br><span class="line">    continuation.resume(<span class="number">100</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看起来这个方法没有接收任何参数，kotlin 中看不出来我们就用 Java 直接调用它：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Object result = KotlinMainKt.notSuspend(<span class="keyword">new</span> Continuation&lt;Integer&gt;() {</span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CoroutineContext <span class="title">getContext</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resumeWith</span><span class="params">(<span class="meta">@NotNull</span> Object o)</span> </span>{</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们发现用Java 调用的时候，需要传入一个 Continuation<integer> ，也就是说kotlin 中的 suspend() -&gt; Int 类型 在Java 看来实际上是 Continuation<integer> -&gt; Object 类型 ！</integer></integer></p>
<p>这与我们平时写的异步回调相似，传入callback 等待结果回调。但是为什么会有返回值 Object？这里的 Object 会有 2 种情况：</p>
<ul>
<li><p>挂起函数同步返回时：作为参数传入的 Continuation 的 resumeWith 不会被调用，函数实际地返回值 Object 就是挂起函数的返回值</p>
</li>
<li><p>挂起函数挂起，执行异步逻辑。此时函数返回值 Object 是一个挂起标志，通过这个标志外部协程就可以知道该函数需要挂起等到异步逻辑执行。</p>
</li>
</ul>
<p>挂起标志是一个常量，定义在 Intrinsics.kt 当中：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> COROUTINE_SUSPENDED: Any <span class="keyword">get</span>() = CoroutineSingletons.COROUTINE_SUSPENDED</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineSingletons</span> </span>{ </span><br><span class="line">    COROUTINE_SUSPENDED, </span><br><span class="line">    UNDECIDED, </span><br><span class="line">    RESUMED </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在大家知道了原来挂起函数就是普通函数<strong>参数</strong>中多了一个 Continuation 实例，这也难怪<strong>普通函数不能调用挂起函数，但是挂起函数可以调用普通函数的原因</strong>。</p>
<p>还可以仔细想想，为什么Kotlin 语法要求挂起函数一定要运行在协程体内或者挂起函数中呢？答案是：协程体或者挂起函数中都隐含了 Continuation 实例 </p>
<h2 id="3-3-协程的上下文"><a href="#3-3-协程的上下文" class="headerlink" title="3.3 协程的上下文"></a>3.3 协程的上下文</h2><h3 id="3-3-1-协程上下文的集合特征"><a href="#3-3-1-协程上下文的集合特征" class="headerlink" title="3.3.1 协程上下文的集合特征"></a>3.3.1 协程上下文的集合特征</h3><p>协程的 Context 更像是个 List 结构，都有空的表示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list: List&lt;<span class="built_in">Int</span>&gt; = emptyList()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> context: CoroutineContext = EmptyCoroutineContext</span><br></pre></td></tr></tbody></table></figure>

<p>接下来，我们往里面添加数据(<strong>要记得将 list 和 context 设置为 var 而不是 val ，我就是因为设置 val 所以不能用  “+” 操作</strong>)：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list += <span class="number">0</span>   <span class="comment">//添加一个元素，得到一个新的list</span></span><br><span class="line">list += listOf&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">//将listOf中的元素都添加进去，生成一个新的 list</span></span><br><span class="line"></span><br><span class="line">context += EmptyCoroutineContext</span><br></pre></td></tr></tbody></table></figure>

<p>协程 Context 是一个集合，那么它的元素类型是什么呢？看下代码:</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineContext</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the element with the given [key] from this context or `null`.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An element of the [CoroutineContext]. An element of the coroutine context is a singleton context by itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> : <span class="type">CoroutineContext {</span></span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A key of this coroutine context element.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line">        <span class="comment">//省略其他代码</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>Element 是本身也实现了 CoroutineContext 接口，这看上去就好像  Int 实现了 List<int> 接口一样，这就很奇怪。其实这主要是为了 API 设计方便，Element 中是不会存放除了它自己以外的其他数据的（<strong>这句话其实不太明白，还需要后续的理解</strong>）</int></p>
<p>Element 中有个属性 key ，这个属性很关键，虽然我们往 list中添加元素时没有明确指出，但是我们都知道 list 中的元素都有一个 index 索引，而<strong>这里的协程上下文Element 的 key 就是这个集合中元素的索引，不同之处是这个索引“长”在数据里面，意味着上下文的数据在出生时就找到了自己的位置</strong>（这句话同样不太理解。。。）</p>
<blockquote>
<p>可能有人觉得协程 Context 和 Map 似乎更近，为什么这里要与 List 对比呢？一是 List 的 Key 类型是固定的 Int ，而 Map 的Key 有很多种类型；二是是协程上下文内部实现是一个单链表，这也反映出它与 List 之间的关系。</p>
</blockquote>
<h3 id="3-3-2-协程上下文元素的实现"><a href="#3-3-2-协程上下文元素的实现" class="headerlink" title="3.3.2 协程上下文元素的实现"></a>3.3.2 协程上下文元素的实现</h3><p>上一节知道协程 Conext 是个接口，实际上还有个抽象类 AbstractCoroutineContextElement，能让我们实现协程上下文更加方便：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCoroutineContextElement</span></span>(<span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> key: Key&lt;*&gt;) : Element</span><br></pre></td></tr></tbody></table></figure>

<p>创建元素并不难，<strong>只需要提供对应的 Key 即可，以下是协程名的实现（系统源码）：</strong></p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">CoroutineName</span></span>(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * User-defined coroutine name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">) : AbstractCoroutineContextElement(CoroutineName) {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Key for [CoroutineName] instance in the coroutine context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineName&gt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以下是协程异常处理器的实现源码：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineExceptionHandler</span></span>(<span class="keyword">val</span> onErrorAction: (Throwable) -&gt; <span class="built_in">Unit</span>) : AbstractCoroutineContextElement(Key) {</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(error: <span class="type">Throwable</span>)</span></span> {</span><br><span class="line">        error.printStackTrace()</span><br><span class="line">        onErrorAction(error)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-3-3-协程上下文的使用"><a href="#3-3-3-协程上下文的使用" class="headerlink" title="3.3.3 协程上下文的使用"></a>3.3.3 协程上下文的使用</h3><p>前面说了，可以为协程上下文添加多个 Context，添加好之后，我们可以将 Context 绑定到协程上了：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> {</span><br><span class="line">    println(<span class="string">"我在协程里面"</span>)</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">}.createCoroutine(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt; {</span><br><span class="line">    <span class="keyword">var</span> tempContext: CoroutineContext = CoroutineName(<span class="string">"name-01"</span>) + </span><br><span class="line">            CoroutineExceptionHandler(){</span><br><span class="line">        println(<span class="string">"出错啦"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = tempContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>先自己构建出 tempContext 然后再将 tempContext 赋值给 context。绑定了协程的上下文，我们的协程就初步成型了！接下来演示如何使用这个CoroutineExceptionHandler:</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">    result.onFailure {</span><br><span class="line">        context[CoroutineExceptionHandler]?.onError(it)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>不管结果如何，这个 resumeWith 是一定会被调用的，如果有异常出现，我们就从协程上下文找到 CoroutineExceptionHandler 实例，调用它的 onError 方法即可</strong>，这个上下文在协程内部都是可以直接获取的，比如，在协程内部获取名字：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> {</span><br><span class="line">    println(<span class="string">"协程名字：<span class="subst">${coroutineContext[CoroutineName]?.name}</span>"</span>)</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">}.createCoroutine(<span class="keyword">object</span>: Continuation&lt;<span class="built_in">Int</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>这样，我们就知道了协程上下文的设置和获取方法了。</p>
<h2 id="3-4-协程的拦截器"><a href="#3-4-协程的拦截器" class="headerlink" title="3.4 协程的拦截器"></a>3.4 协程的拦截器</h2><p>之前的内容知道 Kotlin 协程<strong>通过调用挂起函数实现挂起，通过Continuation 的恢复调用来实现恢复</strong>，还可以通过 Context 的设置来丰富协程能力，那么，如果处理线程的调度？其实标准库还提供了拦截器（Interceptor）的组件，允许我们拦截协程异步回调时的恢复调用，那么线程调度应该也不是什么难事。</p>
<h3 id="3-4-2-拦截器的使用"><a href="#3-4-2-拦截器的使用" class="headerlink" title="3.4.2 拦截器的使用"></a>3.4.2 拦截器的使用</h3><p>拦截器 ContinuationInterceptor 继承了 CoroutineContext.Element ，而Element 又继承 CoroutineContext 类型，所以<strong>拦截器也是 上下文 的一种实现</strong>。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ContinuationInterceptor</span> : <span class="type">CoroutineContext.Element</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> : <span class="type">CoroutineContext</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>自己定义拦截器只需要实现拦截器接口 ContinuationInterceptor 即可，比如打印日志(<strong>注意：拦截器的 Key 是一个固定值: ContinuationInterceptor</strong>,协程执行时会拿到拦截器并拦截)：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span></span>() : ContinuationInterceptor{</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt; = ContinuationInterceptor</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; {</span><br><span class="line">        <span class="keyword">return</span> LogContinuation(continuation)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogContinuation</span>&lt;<span class="type">T</span>&gt; </span>(<span class="keyword">private</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; <span class="keyword">by</span> continuation {</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> {</span><br><span class="line">        println(<span class="string">"执行前"</span>)</span><br><span class="line">        continuation.resumeWith(result)</span><br><span class="line">        println(<span class="string">"执行后"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来使用的时候，我们就将拦截器作为context就好了，前面说了拦截器本来就是上下文：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">haha</span> <span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">val</span> continuation = <span class="keyword">suspend</span> {</span><br><span class="line">        println(<span class="string">"我在协程里面"</span>)</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    }.startCoroutine(<span class="keyword">object</span> : Continuation&lt;<span class="built_in">Int</span>&gt;{</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = LogInterceptor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> {</span><br><span class="line">            <span class="comment">//。。。</span></span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="3-4-3-拦截器的执行细节"><a href="#3-4-3-拦截器的执行细节" class="headerlink" title="3.4.3 拦截器的执行细节"></a>3.4.3 拦截器的执行细节</h3><p>略</p>
<h2 id="3-5-Kotlin-协程所属类别"><a href="#3-5-Kotlin-协程所属类别" class="headerlink" title="3.5 Kotlin 协程所属类别"></a>3.5 Kotlin 协程所属类别</h2><p>略</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">153</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共347.2k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://glassx.github.io/',]
      });
      });
  </script>


</body>
</html>
