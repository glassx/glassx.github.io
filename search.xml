<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>自己编的-特殊函数</title>
    <url>/2021/08/18/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E8%87%AA%E5%B7%B1%E5%8A%A0%E7%9A%84%E7%89%B9%E5%88%AB%E7%AF%87/</url>
    <content><![CDATA[<html><head></head><body></body></html><html><head></head><body><h3 id="run-函数"><a href="#run-函数" class="headerlink" title="run()函数"></a>run()函数</h3><p>它的实现如下，<strong>其实就是调用传入的block参数(一般是个Lambda代码块)</strong>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> inline fun &lt;R&gt; run(block: () -&gt; R): R { </span><br><span class="line">    contract { </span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE) </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> block() </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">run {</span><br><span class="line">    myFun()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="apply-函数"><a href="#apply-函数" class="headerlink" title="apply() 函数"></a>apply() 函数</h3><p>实现如下，主要看后面两行，先是调用了block函数（block里面可以直接使用this？），然后再返回当前调用者this。即执行完block后返回当前的调用者：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T { </span><br><span class="line">    contract { </span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    }</span><br><span class="line">    block() </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法</span></span><br><span class="line">val a = ArrayList&lt;String&gt;().apply {</span><br><span class="line">    add(<span class="string">"A"</span>)</span><br><span class="line">    add(<span class="string">"B"</span>)</span><br><span class="line">    add(<span class="string">"C"</span>)</span><br><span class="line">    println(<span class="keyword">this</span>)<span class="comment">//打印 [A,B,C]</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">println(a)<span class="comment">//同样打印 [A,B,C]</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="let函数"><a href="#let函数" class="headerlink" title="let函数"></a>let函数</h3><p>只需要看源代码最后一行即可：意思是把当前调用对象作为参数传入block代码块(意味着一定要用it访问调用对象，能不能this?),最后，返回block执行结果，即作用域中的最后一个对象：：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R { </span><br><span class="line">    contract { </span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE) </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>) </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="also-函数"><a href="#also-函数" class="headerlink" title="also() 函数"></a>also() 函数</h3><p>源码先调用block(this) ，但是最后返回值是this，也就是，将当前调用者传入block，执行完后返回调用者。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T { </span><br><span class="line">    contract { </span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE) </span><br><span class="line">    }</span><br><span class="line">    block(<span class="keyword">this</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">val a = <span class="string">"ABC"</span>.also{</span><br><span class="line">    println(it)<span class="comment">//输出 ABC</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pintln(a);<span class="comment">//输出 ABC</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="with-函数"><a href="#with-函数" class="headerlink" title="with() 函数"></a>with() 函数</h3><p>源码传入一个接收者对象 reciver，然后使用该对象去调用传入的Lambda代码块： receiver.block()</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R { </span><br><span class="line">    contract { </span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE) </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> receiver.block() </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">whith(ArrayList&lt;String&gt;()) {</span><br><span class="line">    add(<span class="string">"A"</span>)</span><br><span class="line">    add(<span class="string">"B"</span>)</span><br><span class="line">    add(<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="keyword">this</span>)<span class="comment">//ABC</span></span><br><span class="line">}.let {</span><br><span class="line">    println(it)<span class="comment">//kotlin.Unit</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="run、let-与-also-对比"><a href="#run、let-与-also-对比" class="headerlink" title="run、let 与 also 对比"></a>run、let 与 also 对比</h3><p>由下面代码可能更好理解run实现中 return block() 、let实现中的  return block(this)  ，以及 also 源码中的 return this ：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//run提供了一个单独的作用域，并且会返回在这个作用域当中的最后一个对象</span></span><br><span class="line"><span class="comment">//例如现在有这么一个场景，用户领取app的奖励，如果用户没有登录弹出登录dialog，如果已经登录则弹出领取奖励的dialog。我们可以使用以下代码来处理这个逻辑</span></span><br><span class="line">run {</span><br><span class="line">    <span class="keyword">if</span> (islogin) loginDialog <span class="keyword">else</span> getAwardDialog</span><br><span class="line">}.show()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">val original = <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line">original.let {</span><br><span class="line">    println(<span class="string">"The original String is $it"</span>) <span class="comment">// "abc"</span></span><br><span class="line">    it.reversed() </span><br><span class="line">}.let {</span><br><span class="line">    println(<span class="string">"The reverse String is $it"</span>) <span class="comment">// "cba"</span></span><br><span class="line">    it.length  </span><br><span class="line">}.let {</span><br><span class="line">    println(<span class="string">"The length of the String is $it"</span>) <span class="comment">// 3</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">original.also {</span><br><span class="line">    println(<span class="string">"The original String is $it"</span>) <span class="comment">// "abc"</span></span><br><span class="line">    it.reversed() </span><br><span class="line">}.also {</span><br><span class="line">    println(<span class="string">"The reverse String is ${it}"</span>) <span class="comment">// "abc"</span></span><br><span class="line">    it.length  </span><br><span class="line">}.also {</span><br><span class="line">    println(<span class="string">"The length of the String is ${it}"</span>) <span class="comment">// "abc"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>run是直接提供一个作用域，并返回作用域里面最后一个对象</li>
<li>let 将this传入block中，并且返回 block(this)，也就是作用域最后一个对象</li>
<li>also 将this传入block中，但是返回的是 this，也就是调用者本身</li>
<li>with 呢，是以 with(T) 的形式使用(但是它貌似不能判断null？)</li>
<li>apply没有传入this，但是直接返回this</li>
</ul>
<p>最后，按需使用的情景：</p>
<p><img src="https://img-blog.csdn.net/20180316005903782?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2xqZDIwMzg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="场景"></p>
<blockquote>
<p>有些内容参考 <a href="https://blog.csdn.net/ljd2038/article/details/79576091">无嘴小呆子</a></p>
</blockquote>
<p>无需写interface，直接写个高阶函数？这个地方是不是高阶函数？</p>
</body></html>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-Kotlin核心编程</tag>
      </tags>
  </entry>
</search>
