<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第9章：Activity的插件化解决方案</title>
    <url>/2021/03/29/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC9%E7%AB%A0/</url>
    <content><![CDATA[<p>Activity的插件化需要解决3方面的技术问题：</p><ul>
<li>宿主App可以加载插件App中的类         </li>
<li>宿主App可以加载插件中的App资源           </li>
<li>宿主App可以加载插件中的Activity          </li>
</ul><h2 id="启动没有在AndroidManifest中声明的插件Activity"><a href="#启动没有在AndroidManifest中声明的插件Activity" class="headerlink" title="启动没有在AndroidManifest中声明的插件Activity"></a>启动没有在AndroidManifest中声明的插件Activity</h2><p>在5.4节介绍了启动没有在AndroidManifest 中声明的 Activity，借助宿主App中的StubActivity ，在 AMN 中欺骗，在ActivityThread 中欺骗。这种方式的代码如下：</p><a id="more"></a>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码可以参见： https://github.com/BaoBaoJianqiang/ActivityHook1</span></span><br></pre></td></tr></table></figure>

<h2 id="基于动态替换的Activity插件化解决方案"><a href="#基于动态替换的Activity插件化解决方案" class="headerlink" title="基于动态替换的Activity插件化解决方案"></a>基于动态替换的Activity插件化解决方案</h2><p>这章节好混乱，压根就没说这里解决的是什么问题</p>
<h2 id="加载插件中类的方案2：-合并多个dex"><a href="#加载插件中类的方案2：-合并多个dex" class="headerlink" title="加载插件中类的方案2： 合并多个dex"></a>加载插件中类的方案2： 合并多个dex</h2><h2 id="对LaunchMode的支持"><a href="#对LaunchMode的支持" class="headerlink" title="对LaunchMode的支持"></a>对LaunchMode的支持</h2><p>前面介绍的 Activity 插件化技术，对于LaunchMode 都是standard的情况是完全适用的。对于 SingleTop、SingleTask 和 SingleInstance 需要重新考虑。</p>
<p>解决LaunchMode 的问题，适用的还是 <strong>占位Activity</strong> 的思想，即实现为这3种 LaunchMode 创建很多StubActivity，如下图所示：</p>
<p><img src alt="占位思想解决LaunchMode问题"></p>
<p>我们可以从服务端下载一个Json，指定插件中的Activity 对应哪种 StubActivity ，写Demo的时候，可以直接在本地 Mock 这些数据，保存在 MyApplication 中，然后再 Mock1Class 接货 startActivity 的时候，如果发现要启动的Activity 在 MyApplication 的 pluginActivities 集合中，那就使用这个插件 Activity 对应的占位 StubActivity，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码参见： https://github.com/BaoBaoJianqiang/ZeusStudy1.3</span></span><br></pre></td></tr></table></figure>

<p>接下来可以测试下。这里有个小bug，无论singleTop还是singleTask，再回到这个Activity时，并不会触发它的onCreate，而是会触发它的onNewIntent(其实这里说的bug我并没有明白，等测试后再说)。为此，我们需要在MockClass2 中，拦截onNewIntent方法，把占位 StubActivity 替换回插件Activity，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码可以参考上面的链接</span></span><br></pre></td></tr></table></figure>

<h2 id="加载插件中类的方案3：修改App原生的ClassLoader"><a href="#加载插件中类的方案3：修改App原生的ClassLoader" class="headerlink" title="加载插件中类的方案3：修改App原生的ClassLoader"></a>加载插件中类的方案3：修改App原生的ClassLoader</h2><p>..</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android插件化开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>第12章：ContentProvider的插件化解决方案</title>
    <url>/2021/03/28/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC12%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="ContentProvider基本概念"><a href="#ContentProvider基本概念" class="headerlink" title="ContentProvider基本概念"></a>ContentProvider基本概念</h2><p>ContentProvider 就是一个SQLite 数据库，数据提供方A和数据使用方B是通过<strong>匿名共享内存</strong>来传输数据的。B告诉A，“你把数据写在这个内存地址上”；B准备好数据，写到A要求的内存地址上，A就可以直接使用这些数据了。当数据量非常大的时候，这个数据传递速度是非常快的。</p><a id="more"></a>
<p>并不是所有数据传递都需要ContentProvider，比如，Activity 跳转时，数据的传递就用的 Binder，一般来说，传输的数据量不超过 1 M 时，使用Binder；否则，此时需要ContentProvider 。</p>
<h2 id="ContentProvider-插件化"><a href="#ContentProvider-插件化" class="headerlink" title="ContentProvider 插件化"></a>ContentProvider 插件化</h2><p>前面介绍了 BroadCastReceiver 的插件化解决方案，即把插件中的静态广播都转换为动态广播，然后手动注册到宿主App的广播中。</p>
<p>其实，ContentProvider 也能这么做，这时候不叫“注册”，而叫“安装”。安装当前Apk中所有的ContentProvider 的方法位于 ActivityThread 的 installContentProviders方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码略</span></span><br></pre></td></tr></table></figure>

<p>我么你只需要手动执行这个方法，把插件中的ContentProvider 集合作为第二个参数填进去即可。如此一来，我们得到了ContentProvider 插件化的解决方案：</p>
<ol>
<li>沿用Activity插件化的第二种方案，将宿主App和插件App的dex合并到一起     </li>
<li>借助PackageParse的parsePackage方法，读取插件中的ContentProvider信息，然后把得到的Package对象转换为我们需要的 ProviderInfo类型对象     </li>
<li>将ContentProvider 的packageName 设置为当前apk的packageName，之后把插件中的 ContentProvider 放入宿主中     </li>
<li>通过反射执行 ActivityThread 的 installContentProviders 方法，把ContentProvider 作为插件的参数，相当于把插件 ContentProvider “安装” 到宿主App中     </li>
</ol>
<h2 id="执行这段Hook代码的时机"><a href="#执行这段Hook代码的时机" class="headerlink" title="执行这段Hook代码的时机"></a>执行这段Hook代码的时机</h2><p>ContentProvider 这个组件，往往是提供给外界使用的，如果插件中的ContentProvider 还没安装到宿主App中，第三方就来调用了，那就要等很久了，所以安装插件 ContentProvider 的过程越早越好。<strong>App安装自身的 ContentProvider 是在ActivityThread 执行 installContentProviders 方法中，这个方法比Application 的onCreate 要早，但是会晚于 Application 的 attachBaseContent 方法，所以，我们可以在 attachBaseContent 方法中，手动执行 ActivityThread 的 installContentProviders</strong> 。</p>
<h2 id="ContentProvider-的转发机制"><a href="#ContentProvider-的转发机制" class="headerlink" title="ContentProvider 的转发机制"></a>ContentProvider 的转发机制</h2><p>让外界App直接调用当前App的插件里定义的ContentProvider ，并不是理想的解决方案。最好的是在宿主App中定义一个 StubContentProvider 作为中转，让外界调用当前App的 StubContentProvider ，然后在 StubContentProvider 中再调用插件里的 ContentProvider：</p>
<p><img src="/assets/Book-Notes/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8C%87%E5%8D%97/%E7%AC%AC12%E7%AB%A0/ContentProvider%E6%8F%92%E4%BB%B6%E5%8C%96%E5%88%86%E5%8F%91%E6%80%9D%E6%83%B3.png" alt="ContentProvider插件化分发思想"></p>
<p>ContentProvider 插件化的精髓在于分发，外界使用 App 提供的 ContentProviderA 时，只知道发送给一个宿主AndroidManifest 中声明锅的 ContentProviderA，而受到请求后，再做二次转发。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android插件化开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>第11章：BroadcastReceiver的插件化解决方案</title>
    <url>/2021/03/28/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC11%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="Receiver概述"><a href="#Receiver概述" class="headerlink" title="Receiver概述"></a>Receiver概述</h2><p>Receiver分为动态和静态两种，简单讨论下区别：</p><ul>
<li>静态广播在 AndroidManifest 中注册，因为Android系统重启时，PMS都会解析App中的AndroidManifest，所以<strong>静态广播都存在于 PMS 中</strong>      </li>
<li>动态广播通过 Context 的registerReceiver 方法最终调用 AMN.getDefault().registerReceiver 方法，所以，<strong>动态广播的注册信息存在于 AMS 中</strong>       </li>
</ul><a id="more"></a>

<p>除了注册方式不一样，后续发送和接收的过程就一样了。整个过程简单如下：1、Context 发送广播，最终通过 AMN.getDefault().broadcastIntent，把要发送的广播告诉AMS。2、AMS收到消息后，根据intent-filter 筛选 PMS 和 AMS (即静态广播和动态广播)中符合条件的接收器，通知App进程启动这些广播(调用这些广播的 onReceive)。</p>
<h2 id="动态广播的插件化解决方案"><a href="#动态广播的插件化解决方案" class="headerlink" title="动态广播的插件化解决方案"></a>动态广播的插件化解决方案</h2><p>对于动态广播，我们只需要确保宿主App能加载插件中的这个动态广播类就行(因为这里并不需要直接与AMS打交道，只是个类而已)。通过9.3节的dex合并技术，就能做到了。</p>
<h2 id="静态广播解决方案"><a href="#静态广播解决方案" class="headerlink" title="静态广播解决方案"></a>静态广播解决方案</h2><p>静态广播无法像Activity那样，即使没在AndroidManifest 中注册也能生效，因为无论是注册还是发送广播，都必须有 IntentFilter，其中的action是可以随意设置的，所以我们对于 Receiver 压根就不能通过类似 Activity 的插桩方式。只有另辟蹊径。</p>
<h3 id="静态广播当做动态广播处理"><a href="#静态广播当做动态广播处理" class="headerlink" title="静态广播当做动态广播处理"></a>静态广播当做动态广播处理</h3><p>具体分为两步：</p>
<ol>
<li>PMS 只能读取宿主 App 的AndroidManifest 文件，读取其中的静态广播并注册。我们可以反射，手动控制PMS读取插件AndroidManifest 中声明的静态广播列表。     </li>
<li>遍历这个静态广播列表，使用 classLoader 加载列表中每个广播类，实例化成一个对象，<strong>然后作为动态广播注册到AMS中</strong>           </li>
</ol>
<h3 id="静态广播的插件化终极解决方案"><a href="#静态广播的插件化终极解决方案" class="headerlink" title="静态广播的插件化终极解决方案"></a>静态广播的插件化终极解决方案</h3><p>上述静态广播当做动态广播的方案，这丧失了静态广播的特性——不需要启动App就可以启动一个静态广播。所以我们仍要探寻如何不启动App也能和插件中的静态广播通信。</p>
<p>回忆一下前面介绍的Activity 和 Service 插件化的占位思想：</p>
<ul>
<li>Activity 只需要一个占位 StubActivity 就能面对大部分插件Activity了，对于LaunchMode 的其他三种形式，则需要更多的占位 StubActivity 应对     </li>
<li>Service 也需要占位 StubService ，但是一个 StubService 只能对应一个插件中的Service，所以我们需要在宿主App中占位多个 StubService，通过json来配置映射关系。    </li>
</ul>
<p>如果也用占位的思想，每个静态广播需要携带一个或者多个Action，StubReceiver 也不例外，如果 StubReceiver 和插件中的静态广播是一对多的关系，那么从外界发送一个广播到App，<strong>就会触发插件中的所有静态广播</strong>。由此得出：<strong>StubReceiver 和插件中的广播只能是一对一的关系</strong>。</p>
<p>不过，我们可以为一个广播设置多个Action，这样我们就不需要预先创建很多个StubReceiver用来面对插件中的静态广播了，只需要一个 StubReceiver ，为它配置很多个 action 即可。这样，插件中的静态广播就要和这些 action 建立一对一的关系，还是以前的思路，使用<strong>Json配置映射关系就行</strong>。</p>
<p>还有，AndroidManifest 中<strong>支持为每个组件配置 metadata</strong>，利用这个特性，为插件中每个静态广播配置对应的 StubReceiver 中的 action ，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyReceiver"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">baobao/</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"oldAction"</span> <span class="attr">android:value</span>=<span class="string">"jianqiang1"</span>&gt;</span><span class="tag">&lt;/<span class="name">meta-data</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyReceiver2"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span> &gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"baobao2"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"oldAction"</span> <span class="attr">android:value</span>=<span class="string">"jianqiang2"</span>&gt;</span><span class="tag">&lt;/<span class="name">meta-data</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>解析插件中的 AndroidManifest 文件，可以借助11.3章节介绍的ReceiverHelper 类的 preLoadReceiver 方法，在遍历插件中的每个静态的 Receiver 时，去除Receiver 的metadata 数据，根据oldAction值，对应到Receiver，比如 MyReceiver 对应 jianqiang1，MyReceiver2 对应 jianqiang2 。</p>
<p>之后，把插件中的Receiver 手动注册为动态广播。宿主中定义的<strong>StubReceiver占位广播的作用是分发</strong>。</p>
<p>这就解决了静态广播的问题，<strong>我们可以在App没启动的时候，就启动插件中的静态广播</strong>(我其实还是没看懂怎么在没有启动App的情况，就能启动这个静态广播，后续长丝下)。美中不足的是，这个StubReceiver 需要配置很多个 Action 。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android插件化开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>第8章：最简单的插件化解决方案</title>
    <url>/2021/03/26/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC8%E7%AB%A0/</url>
    <content><![CDATA[<p>本章介绍一种最简单的插件化方案，适用于四大组件，技术涉及以下3个方面：</p><ul>
<li>合并所有的插件dex，用以解决插件类的加载问题             </li>
<li>在宿主AndroidManifest中预先声明插件中的四大组件(插件中的Activity如果很多就很麻烦)      </li>
<li>把插件中的所有资源一次性合并到宿主资源中(可能会导致资源id冲突)     </li>
</ul><a id="more"></a>

<h2 id="在AndroidManifest-中声明插件中的组件"><a href="#在AndroidManifest-中声明插件中的组件" class="headerlink" title="在AndroidManifest 中声明插件中的组件"></a>在AndroidManifest 中声明插件中的组件</h2><p>在插件中有啥，在宿主中声明啥就行     </p>
<h2 id="宿主App加载插件中的类"><a href="#宿主App加载插件中的类" class="headerlink" title="宿主App加载插件中的类"></a>宿主App加载插件中的类</h2><p>把插件dex都合并到宿主的dex中，那么宿主App对应的ClassLoader 就可以加载插件中任意类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码参考： https://github.com/BaoBaoJianqiang/ZeusStudy1.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoaderHookHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">patchClassLoder</span><span class="params">(ClassLoader cl,File apkFile,File optDexFile)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取BaseDexClassLoder: pathList</span></span><br><span class="line">        Object pathListObj = RefInvoke.getFiledObject(DexClassLoader.class.getSuperclass(), cl, <span class="string">"pathList"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取PathList: Element[] dexElements</span></span><br><span class="line">        Object[] dexElements = (Object[])RefInvoke.getFieldObject(pathListObj.getClass(), pathListObj, <span class="string">"dexElements"</span>);</span><br><span class="line"></span><br><span class="line">        ...<span class="comment">//手敲太难了，到时候复制下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动插件Service"><a href="#启动插件Service" class="headerlink" title="启动插件Service"></a>启动插件Service</h2><p>根据前面两章，素组App就能启动一个插件中的Service了，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">String serviceName = <span class="string">"jianqiang.com.plugin1.TestService1"</span>;</span><br><span class="line">intent.setClassName(<span class="keyword">this</span>, serviceName);</span><br><span class="line">startService(intent);</span><br></pre></td></tr></table></figure>

<h2 id="加载插件中的资源"><a href="#加载插件中的资源" class="headerlink" title="加载插件中的资源"></a>加载插件中的资源</h2><p>四大组件都可以这样实现插件化方案，Service 、ContentProvider 和 Receiver 都只要合并dex就够了，他们没有资源的概念。Activity严重依赖资源，所以必须解决插件中的资源问题。前面章节介绍了AssetManager 和 Resources ，AssetManager 有个 addAssetPath 方法，可以一次性把插件的路径都“灌进去”，然后根据这个“超级” AssetManager 生成一个“超级” Resources ，以后无论是查找插件还是宿主的资源，都能通过这个“超级”Resources 找到了。上述实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码参考：  https://github.com/BaoBaoJianqiang/ZeusStudy1.1</span></span><br></pre></td></tr></table></figure>
<p>至此，Activity 的“傻瓜式”插件化解决方案就完成了，我们甚至可以从插件Activity跳转到宿主中的Activity，但是这个方案有以下两个问题：</p>
<ul>
<li>插件的四大组件都必需先在宿主中声明，不能新增      </li>
<li>插件和宿主的资源都合并到一起，资源id可能会有冲突     </li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android插件化开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>第10章：Service的插件化解决方案</title>
    <url>/2021/03/25/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC10%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="Android界的荀彧和荀攸：Service和Activity"><a href="#Android界的荀彧和荀攸：Service和Activity" class="headerlink" title="Android界的荀彧和荀攸：Service和Activity"></a>Android界的荀彧和荀攸：Service和Activity</h2><p>根据Context的族谱，Service 是 Activity 的叔叔，结合作用来看，二者有太多相似，但是备份不同，类似三国时期的荀彧和荀攸。不过，二者的区别也挺明显：</p><ul>
<li>Activity 是面向用户的，有大量的用户交互的方法，而Service 是后台运行的，生命周期函数很少    </li>
<li>Activity 中有LaunchMode 的概念，每个Activity启动时都会放在栈顶，根据不同的 LaunchMode 可能会有复用以前的实例或者不复用以前的实例。但是Service不同，<strong>同一个 Service 调用多次startService并不会启动多个实例，只会有一个实例</strong>，所以，只用一个StubActivity 是应付不了多个插件的Service 的     </li>
<li>ActivityThread 最终通过Instrumentation 启动一个Activity。而ActivityThread 启动Service 并不借助于 Instrumentation ，而是直接把Service 反射出来就启动了    </li>
</ul><a id="more"></a>

<p>注意一点，Service 有两种形式： 由 startService 启动的服务；由 bindService 绑定的服务。二者的区别在于：startService 以及对应的 stopService ，就是简单地启动和停止 Service ；bindService 执行时会传递一个 ServiceConnection 对象给 AMS ，接下来 Service 在执行 onBind 时，可以把生成的 binder 对象返回给 App 调用端，这个值存于 ServiceConnection 对象的 onServiceConnected 回调函数的第二个参数中。       </p>
<h2 id="预先占位"><a href="#预先占位" class="headerlink" title="预先占位"></a>预先占位</h2><p>前面说过，Service 与 Activity 不一样，它只会存在一个实例，所以只用一个StubService 是应付不了多个插件Service 的。考虑到在绝大部分App中Service 数据不会超过10个，所以我们完全可以在宿主App 中创建 10 个 StubService ，StubService1，StubService2…StubService10 ，每个 StubService 只对应插件中的一个Service，如下图：</p>
<p><img src="/assets/Book-Notes/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8C%87%E5%8D%97/%E7%AC%AC10%E7%AB%A0/StubService%E5%8D%A0%E4%BD%8D%E7%A4%BA%E6%84%8F.png" alt="StubService占位示意"></p>
<p>接下来就是让每个插件Service匹配一个宿主中的 StubService 了，有两种匹配方式：</p>
<ul>
<li>服务器下发一个 JSON 字符串，给出二者的一一对应关系     </li>
<li>在每个插件 App 的 assets 目录中，创建一个 plugin_config 配置文件，把这个 JSON 字符串放进去</li>
</ul>
<p>第2种做法更自然，不需要和服务器交互，json文件解析类似如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String strJson = Utils.readZipFileString(dexFile.getAbsolutePath(), <span class="string">"assets/plugin_config.json"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strJson == <span class="keyword">null</span> || TextUtils.isEmpty(strJson)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSONObject jobject = <span class="keyword">new</span> JSONObject(strJson.replaceAll(<span class="string">"\r|\n"</span>, <span class="string">""</span>));</span><br><span class="line">JSONArray jsonArray = jobject.getJSONArray(<span class="string">"plugins"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; jsonArray.length(); i++) &#123;</span><br><span class="line">    JSONObject jsonObject = (JSONObject) jsonArray.get(i);</span><br><span class="line">    UPFApplication.pluginServices.put(</span><br><span class="line">        jsonObject.optString(<span class="string">"PluginService"</span>),</span><br><span class="line">        jsonObject.optString(<span class="string">"StubService"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将 JSON 转化为一个 HashMap ，<strong>以插件的类名作为key，以宿主的替身作为value</strong>，这个HashMap 存放在宿主App 的 UPFApplication 的 plutinServices 中，是一个全局变量。</p>
<h2 id="startService-的解决方案"><a href="#startService-的解决方案" class="headerlink" title="startService 的解决方案"></a>startService 的解决方案</h2><p>Service 的插件化机制和Activity 很像，因为它们是亲戚。我们首先从简单的startService 和 stopService 的插件化做起。</p>
<p>首先，把插件和宿主的dex合并，之前有封装过 BaseDexClassLoaderHookHelper 类，合并后才能随心所欲加载类；其次，采用“欺骗AMS”方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//即 Hook AMN 的 gDefault，它是一个Singleton 对象，之后创建它的代理对象 MockClass1 ，然后替换这个字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//之后，再Hook 到 Handler 类型的 H 类的 mCallback 字段，替换为 MockClass2</span></span><br></pre></td></tr></table></figure>

<p>主要流程分析一下：</p>
<ol>
<li><p>Hook AMN，让 AMS 启动 StubService，这次要拦截的是 startServcie 和 stopService 这两个方法(也即在AMN中就拦截这两个方法，将要操作的目标Service替换成相应的StubService)。不过，这次不再需要把 Intent 缓存了，因为有了 UPFApplication 中的 plutinServices ，我们可以根据插件 Service 找到对应的 StubService，也可以根据 StubService 反向找到 Service</p>
</li>
<li><p>AMS 被“欺骗”之后，它原本会通知App启动StubService，而我们要Hook掉ActivityThread 的 mH 对象的 mCallback 对象，仍然截获它的 handleMessage 方法，只不过这次截获的是 “CREATE_SERVICE” 分支，这个分支执行 ActivityThread 的 handleCreateService 方法。在 handleCreateService 中，并不能获取到 App 发送给 AMS 的 Intent，AMS 要启动那个Service ，这个信息是存在 handleCreateService 方法的 dat 参数中，是 CreateServiceData 类型的。Android系统的实现如下：   </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span> <span class="params">(CreateServiceData data)</span> </span>&#123; </span><br><span class="line">    LoadedApk packageinfo = getPackageinfoNoCheck(data.info.applicationinfo, data.compatInfo);</span><br><span class="line">    Service service = <span class="keyword">null</span>; </span><br><span class="line">    java.lang.ClassLoader cl= packageinfo.getClassLoader(); </span><br><span class="line">    service = (Service) cl.loadClass(data.info.name).newinstance(); </span><br><span class="line">    <span class="comment">//省略无关代码</span></span><br><span class="line">    service . onCreate ();</span><br></pre></td></tr></table></figure>

<p>上面代码中，data.info.name 就是Service 的名称，<strong>所以我们只需要将这个值 Hook 为插件的Service即可</strong>。至此，一个支持 startService 的插件化框架就完成了。</p>
<h2 id="bindService-的解决方案"><a href="#bindService-的解决方案" class="headerlink" title="bindService 的解决方案"></a>bindService 的解决方案</h2><p>有了前面的基础，Service 的 bind 与 unbind 就非常简单了，只要在 AMN 的Hook 中添加一个分支，在 “bindService” 的时候 “欺骗AMS” 就行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (”bindService”.equals(method . getName())) &#123; </span><br><span class="line">    <span class="comment">//找到参数里面的第一个 Intent 对象</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (inti= <span class="number">0</span>; i &lt; args . length ; i++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (args [i) <span class="keyword">instanceof</span> Intent) &#123; </span><br><span class="line">            index = i ; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Intent rawintent = (Intent) args[index); </span><br><span class="line">    String rawServiceName = rawintent.getComponent().getClassName(); </span><br><span class="line">    String stubServiceName = UPFApplication.pluginServces.get(rawServiceName)</span><br><span class="line">    <span class="comment">//替换 Plugin Service of StubService </span></span><br><span class="line">    ComponentName componentName =<span class="keyword">new</span> ComponentName(stubPackage, stubServiceName); </span><br><span class="line">    Intent newintent = <span class="keyword">new</span> Intent(); </span><br><span class="line">    newintent.setComponet(componentName);</span><br><span class="line">    <span class="comment">//替换 Intent ，欺骗 AMS</span></span><br><span class="line">    args[index] = newintent ; </span><br><span class="line">    Log.d(TAG, ” hook success <span class="string">"); </span></span><br><span class="line"><span class="string">    return method.invoke(mBase , args);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个过程就完成了，接下来就是使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//unbind</span></span><br><span class="line">btnBind.setOnClickListener(<span class="keyword">new</span> View.OnclickListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"jianqiang.com.testservice1"</span>), <span class="string">"jianqiang.com.testservice1.MyService2"</span>);</span><br><span class="line">        bindService(intent, conn, Service.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//unbind</span></span><br><span class="line">btnUnbind.setOnClickListener(<span class="keyword">new</span> View.OnclickListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        unbindService(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>看了上面的使用方法，可能会有疑惑了：</p>
<ul>
<li>上半场，对于unbind行为，为什么不像bind一样在 unbind 的时候做“欺骗AMS”？    </li>
<li>下半场，为什么不用在MockClass2中写代码，把StubService2 换回 MyService2？        </li>
</ul>
<p>关于第一个问题，因为我们 unbind 的语法是这样的 <em>unbindService(conn)</em> ，只需要一个 ServiceConnection 类型的参数 conn 即可，这个 conn 在前面的bindService 时用到了，<strong>AMS 会根据这个conn 来找到对应的Service，所以并不需要在unbind的时候去做欺骗</strong>。</p>
<p>第二个问题，这要从Android 系统源码说起，bindService 过程在 AMS通知 App 下半场的流程图如下所示：</p>
<p><img src="/assets/Book-Notes/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8C%87%E5%8D%97/%E7%AC%AC10%E7%AB%A0/bindService%E8%BF%87%E7%A8%8BAMS%E9%80%9A%E7%9F%A5App%E8%BF%99%E4%B8%8B%E5%8D%8A%E5%9C%BA.png" alt="bindService过程AMS通知App这下半场"></p>
<p>也就是说，bindService 先走114(handleCreateSrvice)分支，再走 121 (handleBindService) ，在 handleCreateSrvice 中已经把我们要启动的 MyService2 放到了 mService 这个集合中了，那么，在 handleBindService 和 handleUnbindService 中，都会从 mService 集合中找到 Service2 。在之前章节，为了解决 createService ，已经拦截了 114 分支把 StubService2 换回了 MyService2 了，所以我们不需要要拦截 121 和 122 了， 无需再MockClass2 添加额外代码。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里给出Service第一种解决方案——预先占位，在宿主中预先声明若干个StubService。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android插件化开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>第7章：资源初探</title>
    <url>/2021/03/25/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC7%E7%AB%A0/</url>
    <content><![CDATA[<p>Activity 与资源是一对孪生兄弟，想彻底解决Activity 插件化，就要面对如何使用插件中资源的问题。</p><h2 id="资源加载机制"><a href="#资源加载机制" class="headerlink" title="资源加载机制"></a>资源加载机制</h2><h3 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h3><p>Android资源分为两类：</p><ul>
<li>第一类是res目录下存放的可编译资源文件，编译时，系统会自动在R.java中生成资源文件的十进制值，这种访问比较简单，只需要获取Resources对象，进而通过Resources的getxxx即可得到资源        </li>
<li>第二类是assets目录下存放的原始资源文件，因为apk在编译的时候不会编译它们，所以我们也不能通过 R.xx 来访问，通过绝对路径呢？也不行，因为apk不会解压到本地，所以我们无法直接获取，只能通过AssetManager类的open方法去获取，类似如下代码：</li>
</ul><a id="more"></a>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resources resources = getResources();</span><br><span class="line">AssetManager am = getResources().getAssets();</span><br><span class="line">InputStream is = getResources().getAssets().open(<span class="string">"filename"</span>);</span><br></pre></td></tr></table></figure>

<p>由此可见啊，Resources 就能搞定一切！</p>
<h3 id="剪不断理还乱：Resources-和-AssetManager"><a href="#剪不断理还乱：Resources-和-AssetManager" class="headerlink" title="剪不断理还乱：Resources 和 AssetManager"></a>剪不断理还乱：Resources 和 AssetManager</h3><p>AssetManager 中有一个 addAssetPath(String path) 方法，App启动时，会把当前的Apk路径穿进去，接下来AssetManager 和 Resources 就能访问当前apk的所有资源了。addAssetPath 方法是不对外的，不过我们可以通过反射的方式，把插件apk的路径传入这个方法，就把插件资源添加到一个资源池了，当然，当前App的资源早已经在这个池子中了。App有几个插件，就调用几次addAssetPath ，把插件资源都塞到池子里。</p>
<blockquote>
<p>apk打包时，每个资源都会在R文件中有一个十六进制值，并且会生成一个 resources.arsc 文件，它是一个 Hash 表，存放着每个十六进制值和资源的对应关系，这样在运行时，就能知道十六进制值对应res目录下哪个目录哪个资源。</p>
</blockquote>
<h2 id="资源插件化解决方案"><a href="#资源插件化解决方案" class="headerlink" title="资源插件化解决方案"></a>资源插件化解决方案</h2><p>以 在宿主App 中读取插件里面的字符串资源 为例，说明这个解决方案，总共会分为 4 个步骤：</p>
<ol>
<li>loadResources 。通过反射，创建 AssetManager 对象，调用 addAssetPath 方法，把插件 Plugin1 的路径添加到 AssetManager 对象中，从此，这个AssetManager 就只为这个插件 Plugin1 服务了。在这个 AssetManager 基础上，创建相应的 Resources 和 Theme 对象。    </li>
<li>重写 Activity 的getAsset ，getResources 和 getTheme 方法，它们的思路都是一样的，如果插件的对象中相应的对象为空，则使用默认的，即类似： if(mAssetManager == null) { return super.getAssets(); }     </li>
<li>加载外部的插件，生成这个插件的对应的 ClassLoader：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File extractFile = <span class="keyword">this</span>.getFileStreamPath(apkName);</span><br><span class="line">dexPath = extractFile.getPath();</span><br><span class="line"></span><br><span class="line">fileRelease = getDir(<span class="string">"dex"</span>, <span class="number">0</span>);<span class="comment">//0代表Context.MODE_PRIVATE</span></span><br><span class="line">classLoder = newDexClassLoader(dexPath, fileRelease.getAbsolutePath(), <span class="keyword">null</span>, getClassLoder());</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>通过反射，获取插件中的类，构造出插件类的对象 dynamicObject ，然后就可以让插件中的类读取插件中的资源了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整个章节的示例代码可以参考： https://github.com/BaoBaoJianqiang/Dynamic2</span></span><br></pre></td></tr></table></figure>

<h2 id="换肤"><a href="#换肤" class="headerlink" title="换肤"></a>换肤</h2><p>在学习了插件化编程后，换肤其实是可以把图片放到插件App中，然后生成R文件来动态读取这些资源：</p>
<p>因为前面已经讲过原理，所以这里暂且不表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码可以参考： https://github.com/BaoBaoJianqiang/Dynamic3.2</span></span><br></pre></td></tr></table></figure>




























]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android插件化开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章：插件化技术基础知识</title>
    <url>/2021/03/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC6%E7%AB%A0/</url>
    <content><![CDATA[<p>这是第二部分【解决方案】的第一章</p><h2 id="加载外部dex"><a href="#加载外部dex" class="headerlink" title="加载外部dex"></a>加载外部dex</h2><p>加载外部dex主要有3个步骤：</p><ol>
<li>从服务器下载插件 apk到手机 sdcard(需要sdcard权限)    </li>
<li>读取插件apk中的dex，生成对应的 DexClassLoader    </li>
<li>使用DexClassLoader 的loadClass 方法读取插件 dex 中的任何一个类   </li>
</ol><a id="more"></a>


<p>在理解原理的时候，可以把插件App放在主App的 assets 目录中，用于替代从服务器下载插件。</p>
<p>接下来的部分是例子演示，这里不表。</p>
<h2 id="插件的瘦身"><a href="#插件的瘦身" class="headerlink" title="插件的瘦身"></a>插件的瘦身</h2><p>在插件化编程过程中会出现某个moudule在测试的时候需要，但是在正式环境中不需要，因此，可以把这个module打包成jar包，之后使用provided引用：</p>
<blockquote>
<p>provided files(“lib/classes.jar”)</p>
</blockquote>
<p>因为关键字provided只支持jar包，而不支持module</p>
<h2 id="Application-的插件化解决方案"><a href="#Application-的插件化解决方案" class="headerlink" title="Application 的插件化解决方案"></a>Application 的插件化解决方案</h2><p>在插件中可能自定义Application，插件会在这个自定义的Application的onCreate中做一些初始化工作，但我们知道<strong>插件的Application是没机会执行的</strong>，此时，我们可以<strong>在宿主的自定义的Application的onCreate方法中，手动把这些插件Application都反射出来，执行他们的onCreate</strong>，不过这样一来，插件Application就是没有生命周期的，它彻底沦为一个普通类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//示例代码参见： https://github.com/BaoBaoJianqiang/ZeusStudy1.8</span></span><br></pre></td></tr></table></figure>





























]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android插件化开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章：对startActivity 方法进行Hook</title>
    <url>/2021/03/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC5%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="startActivity-的两种形式"><a href="#startActivity-的两种形式" class="headerlink" title="startActivity 的两种形式"></a>startActivity 的两种形式</h2><p>我们知道，最常见的启动Activity的方式：</p><ul>
<li>在Activity 中通过Activity 的startActivity 来启动    </li>
<li>利用Context 的startActivity 方式</li>
</ul><p>在前面我们了解过了，二者最终都是使用 Instrumentation 的 EXEStartActivity 来实现的，只不过前面的步骤略有不同而已。</p><a id="more"></a>


<h2 id="对Activity-的startActivity-方法进行Hook"><a href="#对Activity-的startActivity-方法进行Hook" class="headerlink" title="对Activity 的startActivity 方法进行Hook"></a>对Activity 的startActivity 方法进行Hook</h2><p> Activity1通过startActivity 启动Activity2，这个流程很长，上半场是：Activity1通知AMS要启动Activity2；下半场是： AMS 通知App进程，要启动Activity2 。针对上半场，我们可以Hook的地方包括：</p>
<ul>
<li>Activity 的startActivityForResult方法    </li>
<li>Activity 的 mInstrumentation 字段     </li>
<li>AMN 的 getDefault 方法获取到的对象    </li>
</ul>
<p>针对下半场，我们可以Hook的地方包括：</p>
<ul>
<li>H 的 mCallback 字段    </li>
<li>ActivityThread 的 mInstrumentation 对象，对应的 newActivity 方法和 callActivityOnCreate 方法    </li>
</ul>
<p><strong>注意：这里为什么说只能Hook这些地方，一开始我也不理解。经过请教旭哥(刘旭)，我们只能访问到自己所在进程的内容，所以只能Hook自己本身进程，而不能Hook到其他进程去。这也是为什么我们不能Hook到AMS的原因，因为压根就不运行在同一个进程</strong>。经国斌大神指出，只能Hook到自己的进程以及子进程，<strong>如果要Hook其他进程，得有Root权限</strong>。</p>
<h3 id="Hook-Activity-的-startActivityForResult-方法"><a href="#Hook-Activity-的-startActivityForResult-方法" class="headerlink" title="Hook Activity 的 startActivityForResult 方法"></a>Hook Activity 的 startActivityForResult 方法</h3><p>实际上就是为App写个BaseActivity基类，重写其startActivityForResult方法，这样，不论调用 startActivity 还是 startActivityForResult ，都会执行这个重写逻辑。实际上这都不能称为Hook，只是覆写了而已。</p>
<h3 id="对Activity-的mInstrumentation-字段进行Hook"><a href="#对Activity-的mInstrumentation-字段进行Hook" class="headerlink" title="对Activity 的mInstrumentation 字段进行Hook"></a>对Activity 的mInstrumentation 字段进行Hook</h3><p>Activity 的startActivityForResult 最终会用 mInstrumentation 去调用 execStartActivity ，mInstrumentation 是private的，可以通过反射来获取这个对象，之后把它Hook成我们自己写的 EvilInstrumentation 类型对象，这次我们只是在调用 execStartActivity 之前打印一行日志。</p>
<h3 id="对AMN的getDefault-方法进行Hook"><a href="#对AMN的getDefault-方法进行Hook" class="headerlink" title="对AMN的getDefault 方法进行Hook"></a>对AMN的getDefault 方法进行Hook</h3><p>在之前曾经介绍过，AMN的getDefault 返回的是IActivityManager 类型，**IActivityManager 是个接口，那么我们就可以使用 Proxy.newProxyInstance 这种动态代理，把这个IActivityManager 接口类型的对象Hook成我们自定义类MockClass1生成的对象。在实际应用的框架中，一般在 Application 的 attachBaseContext 方法中进行 Hook，这样可以在进入任意一个Activity的时候就能应用这个Hook。</p>
<h3 id="对H类的mCallback-字段进行Hook"><a href="#对H类的mCallback-字段进行Hook" class="headerlink" title="对H类的mCallback 字段进行Hook"></a>对H类的mCallback 字段进行Hook</h3><p>因为 App 在收到 AMS 发送的 LAUNCH_ACTIVITY 命令后，会通过 Handler 类型的 H 类发送消息，以启动指定的Activity，我们知道，在Handler 内部有个 CallBack 类型的 mCallback 对象，所以我们可以对 H 类的 mCallback 字段进行Hook，拦截这个过程。这时候，你也许会问，为什么不直接Hook了ActivityThread 的mH字段，答案是： 实现不了。截止现在，可以回顾下：</p>
<ul>
<li>使用静态代理，只有两个类，一个是Handler.Callback，另一个是 Instrumentation，参与Android运转的类，系统只暴露了这两个    </li>
<li>使用动态代理，只有两个<strong>接口</strong>： 一个是IActivityManager ，一个是IpackageManager，这<strong>很符合Proxy.newProxyInstance 方法特性，它只能对接口类型对象进行Hook</strong>    </li>
</ul>
<h3 id="再次对Instrumentation字段进行Hook"><a href="#再次对Instrumentation字段进行Hook" class="headerlink" title="再次对Instrumentation字段进行Hook"></a>再次对Instrumentation字段进行Hook</h3><p>与前面不同，我们这次截获的是 Instrumentation 的 newActivity 和 callActivityOncreate 方法，这两个方法会创建目标 Activity 实例，并且调用它的 onCreate。</p>
<h3 id="对AMN的getDefault-方法进行Hook是一劳永逸的"><a href="#对AMN的getDefault-方法进行Hook是一劳永逸的" class="headerlink" title="对AMN的getDefault 方法进行Hook是一劳永逸的"></a>对AMN的getDefault 方法进行Hook是一劳永逸的</h3><p>Instrumentation 调用execStartActivity ，最终调用 AMN.getDefault().startActivity() 方法来启动Activity。我们前面知道，Context 和 Activity 都是通过 Instrumentation 来启动Activity。所以如果我们对 AMN 的 getDefault 方法进行 Hook，那么，不管是从Context 进行startActivity还是从 Activity 进行 startActivityForResult，都能生效，是一劳永逸的。</p>
<h2 id="启动没有在AndroidManifest-中声明的Activity"><a href="#启动没有在AndroidManifest-中声明的Activity" class="headerlink" title="启动没有在AndroidManifest 中声明的Activity"></a>启动没有在AndroidManifest 中声明的Activity</h2><p>我们插件的App一般是没有在宿主App的AndroidManifest中声明的。</p>
<h3 id="“欺骗AMS”策略分析"><a href="#“欺骗AMS”策略分析" class="headerlink" title="“欺骗AMS”策略分析"></a>“欺骗AMS”策略分析</h3><p>这要从Activity 页面跳转流程说起：</p>
<p><img src alt="启动Activity的时序图"></p>
<p>AMS在第2步会检查Activity是否在AndroidManifest中声明，如果不存在就会报错。如果要让AMS检查不到要启动的Activity怎么办呢？难道要Hook AMS ？不行，做不到的，AMS还管理着其他的App，如果这么做，所有App都受影响了，Android整个的安全性都会有问题了。既然如此，我们就只能在第 1 步(检查之前) 和第 5 步上做文章了。基本思路是：</p>
<ul>
<li>在第 1 步，发送要启动的Activity 信息给AMS 之前，<strong>把这个Activity 替换为一个在AndroidManifest中声明的StubActivity，这样就能绕过AMS的检查了</strong>。在替换过程中，要把原来的Activity信息存放在Bundle中。    </li>
<li>在第 5 步，AMS通知App启动StubActivity的时候，我们肯定不是启动StubActivity ，而是要替换成目标 Activity，原先的Activity 存在Bundle中，取出来就行。    </li>
</ul>
<p>整个流程如下图所示：</p>
<p><img src alt="Hook Activity 启动流程"></p>
<h3 id="Hook-的上半场"><a href="#Hook-的上半场" class="headerlink" title="Hook 的上半场"></a>Hook 的上半场</h3><p>前面说了，对AMN进行Hook，可以一劳永逸，这里我们就按照整个思路来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码参见： https://github.comBaoBaoJianqiang/Hook31</span></span><br></pre></td></tr></table></figure>
<p>MockClass1 的基本思路是：拦截startActivity 方法，从参数中取出原油的Intent，替换为启动StubActivity的newIntent，同时把原有的Intent保存在newIntent中，后面换回来的时候还会用到。</p>
<h3 id="Hook的下半场：对H类的mCallback字段进行Hook"><a href="#Hook的下半场：对H类的mCallback字段进行Hook" class="headerlink" title="Hook的下半场：对H类的mCallback字段进行Hook"></a>Hook的下半场：对H类的mCallback字段进行Hook</h3><p>经过前面的AMS欺骗，在第4步的时候AMS就会通知App启动 StubActivity了，我们没有权限修改AMS进程，只能需改第5步。本节的解决方案是基于对H类的mCallback字段进行Hook。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码可以参考： https://github.com/BaoBaoJianqiang/Hook31</span></span><br></pre></td></tr></table></figure>

<p>这里主要是将“替身”换成“真身”。</p>
<h3 id="Hook下半场：对ActivityThread的mInstrumentation字段Hook"><a href="#Hook下半场：对ActivityThread的mInstrumentation字段Hook" class="headerlink" title="Hook下半场：对ActivityThread的mInstrumentation字段Hook"></a>Hook下半场：对ActivityThread的mInstrumentation字段Hook</h3><p>上一节是通过 Hook Handler 的mCallback 把真身换回来，这节换个思路：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码可以参考： https://github.com/BaoBaoJianqiang/Hook32</span></span><br></pre></td></tr></table></figure>

<p>对Instrumentation的 newActivity 和 callActivityOnCreate 方法进行拦截。虽然我们没有在源头把真身换回来，但是我在创建目标Activity的对象时，创建的是目标Activity，并调用目标Activity的onCreate  。</p>
<h3 id="“欺骗AMS”的弊端"><a href="#“欺骗AMS”的弊端" class="headerlink" title="“欺骗AMS”的弊端"></a>“欺骗AMS”的弊端</h3><p>这种欺骗AMS手段有个大大的问题——AMS会认为每次打开的都是StubActivity。<strong>在AMS端有个栈，会存放每次打开的Activity，那么现在栈上就都是StubActivity了，这就相当于那些没有在AndroidManifest中声明的Activity的LaunchMode就只能是standard类型了，即使为此设置了singleTask或者singleTop也不会生效</strong>。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android插件化开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章：代理模式</title>
    <url>/2021/03/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>插件化用到代理模式，所以要掌握代理模式。随着泛型引进，代理模式分为动态代理和静态代理，在插件化中分别表现为对 Instrumentation 和 对 AMN 进行Hook。</p><p>代理模式的UML图如下：</p><p><img src alt="代理模式类图"></p><p>其中RealSubject 和 Proxy 都是Subject 的子类，在Proxy内部有一个RealSubject类型的成员变量，Proxy 的Reqeust 方法会调用 RealSubject 的Request方法，代码如下；</p><a id="more"></a>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RealSubject : Subject &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//完成一些任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Proxy : Subject &#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//关键是这句话</span></span><br><span class="line">        realSubject.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的UML图和这短短的代码，就是代理的精髓，在介绍代理模式的使用场景时，就知道它的威力了。</p>
<h2 id="远程代理（AIDL）"><a href="#远程代理（AIDL）" class="headerlink" title="远程代理（AIDL）"></a>远程代理（AIDL）</h2><p>在Android系统中，远程代理的设计实现就是AIDL。以之前的例子来说，add 方法把a和b两个整数写入data中，通过mRemote的transact方法，把data和reply发送到AIDL的另一端，replay是回调函数，会把计算结果传递回来，UML图如下所示：</p>
<p><img src alt="AIDL的UML图"></p>
<h3 id="给生活加点料-记日记"><a href="#给生活加点料-记日记" class="headerlink" title="给生活加点料(记日记)"></a>给生活加点料(记日记)</h3><p>Class1有个doSomething方法，我们想在这个方法之前记录一行日志，一般的做法是，直接在在doSomething 方法的最前端写一行代码用于记录日志，在学习了代理模式后，我们可以设计一个Class1Proxy，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class1Proxy</span> <span class="keyword">implements</span> <span class="title">Class1Interface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class <span class="number">1</span> clazz = <span class="keyword">new</span> Class1();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        println(<span class="string">"begin log"</span>);</span><br><span class="line">        clazz.doSomething();</span><br><span class="line">        println(<span class="string">"End log"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来使用ClassProxy 而不是使用 Class1：</span></span><br><span class="line"></span><br><span class="line">Class1Proxy proxy = <span class="keyword">new</span> Class1Proxy();</span><br><span class="line">proxy.doSomething();</span><br></pre></td></tr></table></figure>

<h2 id="静态代理和动态代理"><a href="#静态代理和动态代理" class="headerlink" title="静态代理和动态代理"></a>静态代理和动态代理</h2><p>前面讲的是“静态代理”，但是其实这样是有问题的，每个类都要有个对应的Proxy类，Proxy类的数量会很多，<strong>但其实它们的逻辑大同小异</strong>。接下来介绍“动态代理”，基于 Proxy 类的 newProxyInstance 方法，它的声明如下：</p>
<blockquote>
<p>static Object newProxyInstance(ClassLoder loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</p>
</blockquote>
<p>其中，interfaces 设置为目标对象Class1 所实现的接口类型，对应上面的例子是 Class1Interface，我们通过h对象，可以实现把目标对象 class1 注入，我们看下在实际应用中自己实现的这个h：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerTest</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationHandlerTest</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Overrid</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method,Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        println(<span class="string">"start log"</span>);</span><br><span class="line">        Object obj = method.invoke(target,objects);</span><br><span class="line">        println(<span class="string">"end log"</span>);</span><br><span class="line">        retun obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 method.invoke(target,objects)，其中target 就是 class1 对象，接下来调用就是如下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class1Interface proxy = <span class="keyword">new</span> Class1();</span><br><span class="line">Class1Interface class1Proxy = (Class1Interface)Proxy.newProxyInstance(class1.getclass.getClassLoder(),class1.getclass.getInterfaces(),<span class="keyword">new</span> InvocationHandlerTest(class1));</span><br></pre></td></tr></table></figure>

<p>所以，invoke方法实际上就是在执行 class1 的doSomething 方法。</p>
<h2 id="对AMN的Hook"><a href="#对AMN的Hook" class="headerlink" title="对AMN的Hook"></a>对AMN的Hook</h2><p>后续有时间补上</p>
<h2 id="对PMS的Hook"><a href="#对PMS的Hook" class="headerlink" title="对PMS的Hook"></a>对PMS的Hook</h2><p>PMS 是系统服务，是没办法Hook的，这个标题只是为了容易理解。我们只能修改它在Android App 进程中的代理对象，它是PackageManager 类型的在很多类中都有这个代理的对象，比如，在ActivityThread 中，有一个字段 sPackageManager ，以及 ApplicationPackageManager 的 mPM字段，我们可以尝试Hook这些字段。</p>
<p>代码：略，后续补上。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android插件化开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序实现</title>
    <url>/2021/03/13/%E9%A1%B9%E7%9B%AE-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h2><ol>
<li>通过提供的接口调用方法，打算启动 </li>
<li>判断AppId是否为空，空则return；否则继续进入    </li>
<li>启动跨进程的Service(如果之前没有启动的话)    </li>
<li>根据AppId获取小程序配置(可能会在内存中有缓存，通过map存储起来，key为appId，value为配置的Bean)，如果有缓存，则先直接使用缓存进入下一步，同时网络拉取配置供下次启动使用           </li>
<li>根据配置判断<strong>小程序url是否合法、是否需要登录态</strong>，需要强制登录，则判断当前登录态(通过startActivityForResult 登录，在 onActivityResult 中跨进程更新登录态信息)；否则拉取js信息。</li>
<li>正式进入小程序打开小程序     </li>
</ol><a id="more"></a>
<h2 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h2><ul>
<li><p>整个小程序体系包含：小程序 Loading 页的 Activity 以及 正式的小程序展示页面的 Activity</p>
</li>
<li><p>对于单个小程序，会由 mainFragment 和 newFragment 来展示，其中 mainFragment 用于展示小程序主页面，打开新的子页面使用 newFragment 来承载</p>
</li>
<li><p>跨进程用的服务 AIDLService 在主进程中</p>
</li>
<li><p>小程序 Loading 页与小程序 Activity 在 :miniapp 进程中</p>
</li>
<li><p>为了加快用户进入App就进入小程序这种应用场景，我们创建了一个空的 MiniAppPreService （这是一个 IntentService） ，并且这个 Service 在 :miniapp 进程中，在闪屏页就启动这个 Service。</p>
</li>
<li><p>当小程序需要用户信息时，会有授权流程</p>
</li>
<li><p>判断是否还是当前用户(比如需要涉及到支付的时候，需要做这一步)</p>
</li>
<li><p>提供外部浏览器打开某个链接方式</p>
</li>
<li><p>提供打开本地页面的接口</p>
</li>
<li><p>提供向本地向小程序反馈结果的方法</p>
</li>
</ul>
<h2 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h2><h3 id="1、为什么要跨进程？多进程带来的问题？"><a href="#1、为什么要跨进程？多进程带来的问题？" class="headerlink" title="1、为什么要跨进程？多进程带来的问题？"></a>1、为什么要跨进程？多进程带来的问题？</h3><p>数据安全(获取用户信息必须得通过接口提供)、小程序崩溃不影响主程序、降低主程序的内存占用</p>
<p>多进程的问题：</p>
<ul>
<li>谨慎使用多进程，新进程会带有一些公共资源，是会消耗内存的     </li>
<li>Application 会执行多次     </li>
<li>SharedPreference 不可靠    </li>
<li>静态成员失效</li>
<li>断点调试问题，在实际开发中，调试的时候先去除多进程</li>
</ul>
<h3 id="2、为什么要降低主程序内存占用，或者说内存占用过大会怎么样？"><a href="#2、为什么要降低主程序内存占用，或者说内存占用过大会怎么样？" class="headerlink" title="2、为什么要降低主程序内存占用，或者说内存占用过大会怎么样？"></a>2、为什么要降低主程序内存占用，或者说内存占用过大会怎么样？</h3><p>内存占用过大容易引起gc</p>
<h3 id="3、为什么要用-mainFragment-和-newFragment-来承载小程序？"><a href="#3、为什么要用-mainFragment-和-newFragment-来承载小程序？" class="headerlink" title="3、为什么要用 mainFragment 和 newFragment 来承载小程序？"></a>3、为什么要用 mainFragment 和 newFragment 来承载小程序？</h3><p>方便小程序内部页面跳转，以及小程序内部回退。</p>
<p>自己覆写了 onBackPressed 重写按返回键的行为，按返回键会移除新打开的页面</p>
<h3 id="4、怎样启动newFragment？"><a href="#4、怎样启动newFragment？" class="headerlink" title="4、怎样启动newFragment？"></a>4、怎样启动newFragment？</h3><p>创建新的 newFragment 对象，将 url 穿进去。之后，通过 FragmentTransaction 的 add 方法，将 newFragment 添加进去，在移除的时候，使用 FragmentTransaction 的 remove 方法移除。</p>
<h3 id="5、fragment的-commit-和-commitAllowLoss-的理解？"><a href="#5、fragment的-commit-和-commitAllowLoss-的理解？" class="headerlink" title="5、fragment的 commit 和 commitAllowLoss 的理解？"></a>5、fragment的 commit 和 commitAllowLoss 的理解？</h3><h3 id="6、AIDLService里面做了什么？"><a href="#6、AIDLService里面做了什么？" class="headerlink" title="6、AIDLService里面做了什么？"></a>6、AIDLService里面做了什么？</h3><p>创建Binder 对象，用以从主进程获取数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class AIDLService : Service() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> val binder: Binder = object : IUserInfoAidlInterface.Stub() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">override fun <span class="title">getAidlUserInfo</span><span class="params">()</span>: AidlUserInfo </span>&#123;</span><br><span class="line">            val info = AidlUserInfo()</span><br><span class="line">            info.ck = UserInfoInstance.getInstance().ck</span><br><span class="line">            info.userName = UserInfoInstance.getInstance().username</span><br><span class="line">            info.latitude = CommonUtil.getLatitude()</span><br><span class="line">            info.longitude = CommonUtil.getLongitude()</span><br><span class="line">            info.encryptNetTime = TimerUtil.encryptNetTime</span><br><span class="line">            <span class="keyword">return</span> info</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">onBind</span><span class="params">(intent: Intent?)</span>: IBinder? </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> binder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="7、js-用来干什么"><a href="#7、js-用来干什么" class="headerlink" title="7、js 用来干什么"></a>7、js 用来干什么</h3><p>为小程序提供调用 Native 方法的接口，比如调用获取用户信息，比如调用打开 App 中的页面</p>
<h3 id="8、aidl-怎么使用，支持哪些数据格式"><a href="#8、aidl-怎么使用，支持哪些数据格式" class="headerlink" title="8、aidl 怎么使用，支持哪些数据格式"></a>8、aidl 怎么使用，支持哪些数据格式</h3><p>自己编写 aidl 文件即可，Android Studio 会自动生成 Java 文件，关于这块的知识可以参考<a href="https://glassx.gitee.io/2021/03/11/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC2%E7%AB%A0/#more">以前的博客</a> ，aidl 文件类似下面的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">文件：IUserInfoAidlInterface.aidl</span><br><span class="line"></span><br><span class="line"><span class="comment">//一定要记得手动加这个import</span></span><br><span class="line"><span class="keyword">import</span> com.xxx.userinfoprovider.model.AidlUserInfo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IUserInfoAidlInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">AidlUserInfo <span class="title">getAidlUserInfo</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>支持基本的类型，int、long、boolean、float、double、String， 我们项目中需要支持对象，所以我们还需要再定义个 aidl 文件（这个Bean就这一行代码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">文件：AidlUserInfo.aidl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parcelable AidlUserInfo;</span><br></pre></td></tr></table></figure>

<p>所以我们写 AIDL，如果需要传输 bean 的话，需要写 n+1 个 aidl 文件，这个 n 就是需要传输的 Bean 的个数。</p>
<h3 id="9、怎么为小程序-Activity-设置进程"><a href="#9、怎么为小程序-Activity-设置进程" class="headerlink" title="9、怎么为小程序 Activity 设置进程"></a>9、怎么为小程序 Activity 设置进程</h3><p>在 AndroidManifest.xml 中设置  android:process=”:miniapp”</p>
<h3 id="10、MiniAppPreService-中做了什么？为什么是-IntentService-？-IntentService-的作用-？"><a href="#10、MiniAppPreService-中做了什么？为什么是-IntentService-？-IntentService-的作用-？" class="headerlink" title="10、MiniAppPreService 中做了什么？为什么是 IntentService ？  IntentService 的作用 ？"></a>10、MiniAppPreService 中做了什么？为什么是 IntentService ？  IntentService 的作用 ？</h3><p>里面啥也没做，使用它主要是因为 IntentService 在没有任务的时候自己会结束，不需要手工干预。</p>
<h3 id="11、授权流程怎样的"><a href="#11、授权流程怎样的" class="headerlink" title="11、授权流程怎样的"></a>11、授权流程怎样的</h3><ol>
<li>与主进程同步数据</li>
<li>检查是否登录了，未登录先登录</li>
<li>与后台请求以前是否有授权过，如果授权过，直接将数据返回(json 形式，通过 webview.loadUrl(“javascript:” ) 形式返回)</li>
<li>未授权过，弹窗，让用户选择是否授权</li>
</ol>
<h3 id="12、如何检测是否还是当前用户？"><a href="#12、如何检测是否还是当前用户？" class="headerlink" title="12、如何检测是否还是当前用户？"></a>12、如何检测是否还是当前用户？</h3><p>因为在小程序里面支付的时候需要，所以支付之前需要检测是否是当前用户</p>
<p>检测方式： 将小程序自己持有的信息以参数形式传过来，之后传给后台，让后台判断</p>
<h3 id="13、如何反馈信息给小程序？"><a href="#13、如何反馈信息给小程序？" class="headerlink" title="13、如何反馈信息给小程序？"></a>13、如何反馈信息给小程序？</h3><p>通过使用 webview.loadUrl ，url 为  javascript: 开头的信息：</p>
<blockquote>
<p>webview.loadUrl(“javascript:” )</p>
</blockquote>
<h3 id="14、不是会内存裁剪？提前启动-Service-会有作用吗？"><a href="#14、不是会内存裁剪？提前启动-Service-会有作用吗？" class="headerlink" title="14、不是会内存裁剪？提前启动 Service 会有作用吗？"></a>14、不是会内存裁剪？提前启动 Service 会有作用吗？</h3>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章：Android底层知识</title>
    <url>/2021/03/11/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC2%E7%AB%A0/</url>
    <content><![CDATA[<p>接下来章节要介绍以下概念，掌握了这些底层知识，就算是迈进了Android插件化的大门了：</p><ul>
<li>Binder</li>
<li>AIDL</li>
<li>AMS</li>
<li>四大组件工作原理</li>
<li>PMS</li>
<li>App安装过程</li>
<li>ClassLoader以及双亲委托</li>
</ul><h2 id="Binder-原理"><a href="#Binder-原理" class="headerlink" title="Binder 原理"></a>Binder 原理</h2><p>对于Binder的原理，只需要了解以下过程即可：</p><ol>
<li>首先，Server 在 SM 中注册</li>
<li>如果Client 需要调用Server 的 add 方法，就需要先获取Server 的对象，但是SM不会把真正的 Server 对象返回给 Client，而是把 Server 的一个代理对象(Proxy)返回给Client    </li>
<li>Client 调用Proxy 的add方法，SM 会帮它去调用 Server 的add 方法，并把结果返回给 Client</li>
</ol><a id="more"></a>



<p>具体过程可以参考下图：</p>
<p><img src="http://weishu1.dimensionalzone.com/2016binder-procedure.png" alt="Binder原理"></p>
<h2 id="AIDL原理"><a href="#AIDL原理" class="headerlink" title="AIDL原理"></a>AIDL原理</h2><p>我们自定义一个aidl 文件时(比如 MyAidl.aidl，里面有个sum方法)，在sync 和 rebuild 之后，Android studio 会为我们自动生成 MyAidl.java 文件，类图如下图所示：</p>
<p><img src alt="aidl类图"></p>
<p>为什么要把3个类都放在一个文件里面呢？因为<strong>如果有多个aidl文件，那么就会有很多的Stub和Proxy类，这样就会重名，把它们放在各自的文件里面，就区分开了，实现了内聚</strong>。3个类的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，在Stub的asInterface 方法中会根据 IBinder 类型的obj 对象来判断是不是有跨进程，如果未跨进程，直接返回 obj 通过 queryLocalInterface 得到的iin；如果有跨进程，则新建 Stub.Proxy ，并返回。</p>
<p>还有，Stub 的 onTransact 指的是接收Server 返回的数据，这里面会根据code 来做相应的操作，对Server的每个操作都会有唯一的code对应，因为底层并没支持类似 sum 这种method标识。</p>
<p>此外，Parcel 类型的写和读也值得注意，它并不需要key-value的方式，而是直接将value写入(reply.writeString(),reply.wrteInt() 等方式)。可以理解为(这里与旭哥聊过，我自己没看过源码，不一定准确)：这些数据都是挨着排放，会存储每个值的偏移值(curr_position)以及大小(size)，取的时候，Parcel 并不知道里面存的是什么，只能靠自己正确知道类型<strong>按照存入的顺序</strong>取出来，比如 data.readInt()、data.redString()，通过偏移值(curr_position)以及大小(size)，就能正确读取值。这里可以参考<a href="https://blog.csdn.net/andy_android/article/details/7226225" target="_blank" rel="noopener">csdn上的博客</a></p>
<p>对于Proxy 而言，它的sum方法，只是通过 IBinder 类型的 mRemote 将参数和code(用来唯一标记一个操作，对应 onTransact 接收server 返回的数据时的code)发送给server (用_data发送数据，用_reply接收数据)，而并没有真正计算。</p>
<p>经过以上的分析，完整的 AIDL 类图应该如下图所示：</p>
<p><img src alt="完整的AIDL类图"></p>
<h2 id="AMS"><a href="#AMS" class="headerlink" title="AMS"></a>AMS</h2><p>站在四大组件角度看，AMS就是Binder的Server，四大组件都归他管。</p>
<p>这里引申两个问题：</p>
<ul>
<li>App 的安装过程，为什么不把apk解压到本地，这样读取图片就不用每次都从apk中读取了。    </li>
<li>为什么Hook永远是在Binder 的Client端，也就是四大组件这边，而不是在 AMS 端。   </li>
</ul>
<p>对于第二个问题，拿Android的剪贴板来说，它也是个Binder服务，如果在AMS层面把剪贴板给Hook了，那会导致Android系统中所有的剪贴板功能被Hook了，所有App都会受到影响，这不就是病毒嘛。。。所以Android肯定不会允许。</p>
<h2 id="Activity-工作原理"><a href="#Activity-工作原理" class="headerlink" title="Activity 工作原理"></a>Activity 工作原理</h2><h3 id="App怎么启动"><a href="#App怎么启动" class="headerlink" title="App怎么启动"></a>App怎么启动</h3><p>Launcher 是个App，与我们的各种应用App没什么不同。我们在开发一个App时，在AndroidManifest文件中需要定义默认启动Activity：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".MainActivity"</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>
<p>这些信息在App安装或者 (Android系统启动)的时候，PackageManager-Service 会从apk 中读取封装到 Launcher 显示的桌面图标中。</p>
<h3 id="启动App并非那么简单"><a href="#启动App并非那么简单" class="headerlink" title="启动App并非那么简单"></a>启动App并非那么简单</h3><p>上一节只是简单描述，Launcher 与 我们要启动的App(假设是斗鱼App)位于两个不同的进程，所以这一系列过程需要进程间通信Binder来完成的，AMS 也出场了，以启动斗鱼App为例，整体分为以下7个阶段(基于Android 6.0源码)：</p>
<ol>
<li>Launcher通知AMS，要启动斗鱼App，并指定启动的页面    </li>
<li>AMS 通知 Launcher “我知道了，没你什么事了”，同时，把要启动的首页记下来    </li>
<li>Launcher 页面进入 Pause 状态，然后通知AMS “我睡了，你找斗鱼App去”    </li>
<li>AMS 检查斗鱼App是否启动，是，则直接唤起；否则，就启动一个新进程。AMS在新进程中创建一个 ActivityThread 对象，启动其中的main函数    </li>
<li>斗鱼App启动后，通知 AMS “我启动好了”    </li>
<li>AMS 翻出步骤 2 中保存的值，告诉斗鱼App，启动哪个页面。    </li>
<li>斗鱼App启动首页，创建 Context 并与首页Activity关联，之后调用首页 Activity 的onCreate函数</li>
</ol>
<p>至此，App启动流程已经完成。</p>
<p>以上步骤总体可以分为三个部分： 一、Launcher 通知AMS；二、AMS处理Launcher传过来的信息；三、Launcher休眠，通知AMS：“我真的已经睡了”；四、AMS启动新的进程；五：新进程启动，以ActivityThread 的main函数作为入口；六、AMS告诉新的App启动哪个Activity；7、App启动Activity。</p>
<p>Launcher页面本身也是Activity，所以它startActivity 最终也会调用到 Activity 的startActivityForResult，在里面，最终使用 Instrumentation 的 execStartActivity 来实现功能：</p>
<blockquote>
<p>Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options)</p>
</blockquote>
<p>其中，</p>
<ul>
<li>mMainThread.getApplicationThread() 获取的是一个Binder 对象，这个对象类型为 ApplicationThread(是 MainThread的内部类),这个对象代表了 Launcher 所在的进程。    </li>
<li>mToken 也是一个Binder对象，代表Launcher这个Activity ，通过 Instrumentation 传给 AMS 后，AMS 一查就能知道是谁向 AMS 发起了请求。    </li>
</ul>
<p>Launcher通知AMS 的流程如下图所示：</p>
<p><img src alt="Launcher通知AMS"></p>
<p>这里要注意一点，ActivityThread 是UI县城，它代表应用程序，我们平常认知 Application 是这个角色。其实Application 就是一个上下文而已，对开发者也许很重要，但是对Android系统中没那么重要。</p>
<p>Instrumentation 的execStartActivity 方法执行时，其实就是将数据透传给 ActivityManagerNativ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrumentation</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法省略了参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActivityResult <span class="title">exeStartActivity</span><span class="params">(xxx,xxx,...)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result = ActivityManagerNative.getDefault().startActivity(xx,xx,....);</span><br><span class="line">                              </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">ActivityManagerNative(AMN) 这个类会反复用到。AMN通过getDefault从ServiceManager中取得一个名为 activity 的对象，然后把它包装成 ActivityManagerProxy(AMP) 对象, AMP 就是 AMS 的代理对象。AMN 和 AMP 都实现了 IActivityManager 接口，**AMS 继承自 AMN**，对照之前的 AIDL 的UML，就不难理解了，下图是 他们的类图：</span><br><span class="line"></span><br><span class="line">![AMN/AMP的类图]()</span><br><span class="line"></span><br><span class="line">第二阶段就是 AMS 处理Launcher 传过来的信息，主要有如下步骤：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. Binder(即 AMN/AMP) 和 AMS 通信，比如这次因为是要启动斗鱼App首页，那么是发送 START_ACTIVITY 请求给 AMS。    </span><br><span class="line"><span class="number">2</span>. AMS 收到后，就会检查斗鱼 App 中 AndroidManifest文件，是否存在这个目标Activity，如果不存在就抛出 Activity not found。   </span><br><span class="line"><span class="number">3</span>. AMS 通知Launcher，“没你事了，洗洗睡”。</span><br><span class="line"></span><br><span class="line">我们想想第<span class="number">3</span>步AMS 怎样给 Launcher 发送消息，之前我们说启动过程把 Launcher 以及它所在的进程传过来了，**它在AMS 这边保存了一个 ActivityRecord 对象，这个对象里有个 ApplicationThreadProxy，这就是一个Binder代理，它的Binder 真身，就是 ApplicationThread**。因此，答案就是：AMS通过ApplicationThreadProxy 发送消息，而App通过 ApplicationThread来接收这个消息。</span><br><span class="line"></span><br><span class="line">ApplicationThread(APT)在接收到AMS的消息后，会调用ActivityThread的sendMessage向Launcher主线程Handler(H对象)发送一个 ACTIVITY_PAUSE消息，即进入第三阶段：Launcher休眠，并且通知AMS：“我真的已经睡了”。</span><br><span class="line"></span><br><span class="line">这个pause的实现原理：**在ActivityThread里面有一个 mActivities 集合，保存当前App(目前是Launcher)中所有的Activity，这时候把它们都找出来，让它们全部休眠**。之后，就通知AMS “已经休眠”。</span><br><span class="line"></span><br><span class="line">这时候，应该到第四阶段： AMS应该给Zygote 进程发送消息创建新进程了，并且在创建进程后，马上创建 ActivityThread 对象，并且在其中创建主线程Looper、创建Application(注意，Application是在这里生成的)。</span><br><span class="line"></span><br><span class="line">具体过程是：ActivityThread **在收到 BIND_APPLICATION消息后，根据传过来的 ApplicationInfo 创建一个对应的 LoadedApk** 对象(标志当前的APK信息)，接着反射创建Application。在App创建好之后，就通知 AMS “我启动好了”，同时把自己的 ActivityThread 对象发送给AMS，AMS 就登记这个App信息，AMS 以后也能通过这个 ActivityThread (我的理解是ActivityThread中的ApplicationThread的代理对象)对象向这个 APP 发送消息。</span><br><span class="line"></span><br><span class="line">接下来就是AMS告诉App要启动哪个Activity，App通过 H 类启动这个新的 Activity。</span><br><span class="line"></span><br><span class="line">## App内部页面跳转</span><br><span class="line"></span><br><span class="line">有了前面的页面跳转，内部跳转就更容易了，流程大同小异，这里不多说</span><br><span class="line"></span><br><span class="line">## Context家族史</span><br><span class="line"></span><br><span class="line">可以用一张图来展示 Context 家族的关系：</span><br><span class="line"></span><br><span class="line">![Context家族]()</span><br><span class="line"></span><br><span class="line">## 两种启动Activity方式的差别(这是我自己加的)</span><br><span class="line"></span><br><span class="line">通过Activity可以直接 startActivity 来启动新的Activity，也可以在Activity 中 getApplicationContext 来获取 Context 上下文通过 ContextImpl 来最终启动Activity，这二者的区别是什么呢？首先看下下图：</span><br><span class="line"></span><br><span class="line">![两种启动Activity方式]()</span><br><span class="line"></span><br><span class="line">Context的 startActivity ，其实也是通过 ContextImpl 拿 mMainThread对象，从 mMainThread 中获取 Instrumentation，让它来执行 execStartActivity，和 Activity 自己的方法实现是一样一样的(其实这里在书上说得并不详细，至少没说为什么 ApplicationContext 在startActivity 时 为什么要 NEW_TASK 标记)。</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line"><span class="comment">//Context 的 startActivity</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">                    <span class="string">"Calling startActivity() from outside of an Activity "</span></span><br><span class="line">                    + <span class="string">" context requires the FLAG_ACTIVITY_NEW_TASK flag."</span></span><br><span class="line">                    + <span class="string">" Is this really what you want?"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">                getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</span><br><span class="line">                (Activity) <span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Activity 的 startActivity</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode,@Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Note we want to go through this method for compatibility with</span></span><br><span class="line">                <span class="comment">// existing applications that may have overridden it.</span></span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主要是Context 的startActivity 时，要求一定要有 FLAG_ACTIVITY_NEW_TASK，否则就不能执行下去。还有，Activity 的startActivityForResult 中执行的 mParent.startActivityFromChild()，最终也是通过 <strong>mInstrumentation.execStartActivity</strong>实现的，因此我们可以说<strong>Activity 的startActivity 最终也是通过 Instrumentation 的 execStartActivity 实现</strong>。</p>
<h2 id="Service-工作原理"><a href="#Service-工作原理" class="headerlink" title="Service 工作原理"></a>Service 工作原理</h2><p>Service 有两套流程，一套是启动流程，另一套是绑定流程：</p>
<p><img src alt="Service两套流程"></p>
<h3 id="在新进程启动-service"><a href="#在新进程启动-service" class="headerlink" title="在新进程启动 service"></a>在新进程启动 service</h3><p>在新进程启动Service主要分为 5 个阶段：</p>
<ol>
<li>App向 AMS 发送一个启动Service 的消息</li>
<li>AMS例行检查(是否在AndroidManifest中声明)，查看目标Service 是否存在，如果存在就不管；如果不存在，则把Service信息保存下来，之后创建新进程    </li>
<li>新进程启动后，通知AMS “我可以了”</li>
<li>AMS 把保存的Service信息发给新进程    </li>
<li>新进程启动Service    </li>
</ol>
<p>当然，这个启动新进程，还是会启动 ActivityThread ，并且新进程启动Service 也是向 ActivityThread 的 H 类发送 START_SERVICE 来启动。</p>
<p>不管是前面的Activity ，还是后面的Service，创建对象时，都是通过 packageInfo(它是一个LoadedApk对象)去获取 ClassLoader，之后再通过反射创建出来 Activity 或者 Service 对象，四大组件的逻辑都是如此。<strong>所以，我们如果要做插件化，可以在这里做文章，换成插件的classLoder，加载插件中的四大组件</strong>。</p>
<h2 id="BroadCast-原理"><a href="#BroadCast-原理" class="headerlink" title="BroadCast 原理"></a>BroadCast 原理</h2><h3 id="注册过程"><a href="#注册过程" class="headerlink" title="注册过程"></a>注册过程</h3><p>用Activity或者Context去注册，其实都是使用Context的registerReceiver方法，然后通过 AMN/AMP 把一个Receiver 传给AMS，在注册过程中，会使用 PMS 获取包信息，业绩 LoadedApk 对象。这个LoadedApk 对象的 getReceiverDispatcher 方法将传过来的 Receiver 封装成一个实现了 IIntentReceiver 接口的Binder 对象。我们实际上就是<strong>将这个 Binder 对象和 IntentFilter 对象传递给了 AMS。不过，这时发送广播是不知道发给谁的，</strong>所以Activity所在的进程还要把自身的对象也发送给AMS。</p>
<p>这里都是动态注册广播，那静态广播呢？它是在App安装的时候注册。动态Receiver 与静态Receiver 分别存在AMS中不同的变量中，在发送广播时，会把两种 Receiver 合并到一起，其中动态的排在静态的前面，然后依次发送，因此，动态Receiver 永远先于静态Receiver收到消息。</p>
<h3 id="发送过程"><a href="#发送过程" class="headerlink" title="发送过程"></a>发送过程</h3><p>发送时，通过 AMN/AMP 发送广播给 AMS，广播中也带着 IntentFilter 对象。AMS 收到广播后，根据Filter 找到对应的Receiver，<strong>向广播接收者所在的进程发送广播</strong>。Receiver 所在进程收到广播后，并不会直接发给Receiver，而是将广播封装成一个消息，(通过H类)发送到主线程的消息队列，当这个消息被处理时，才会把消息中的广播发送给 Receiver。</p>
<h2 id="广播种类"><a href="#广播种类" class="headerlink" title="广播种类"></a>广播种类</h2><p>无序广播、有序广播、粘性广播。这个粘性广播，用一个例子来了解：当电量小于 20%时，就会提示用户，而获取电池电量信息就是通过广播来实现的，一般的广播发完就完了，我们需要这样一种广播，发出后还能一直存在，<strong>未来的注册者也能收到这个广播，这种广播就是粘性广播</strong>。</p>
<h2 id="ContentProvider-工作原理"><a href="#ContentProvider-工作原理" class="headerlink" title="ContentProvider 工作原理"></a>ContentProvider 工作原理</h2><p>ContentProvider 的本质是把数据存储在SQLite 数据库中，但是封装成了统一的访问方式，比如对于数据集合而言，必须提供增删改查功能。我们在SQLite 上封装了一层，就成了 ContentProvider。</p>
<h3 id="匿名共享内存-ASM"><a href="#匿名共享内存-ASM" class="headerlink" title="匿名共享内存(ASM)"></a>匿名共享内存(ASM)</h3><p>ContentProvider 读取数据使用了 ASM，并且，<strong>ASM实质上也是个Binder通信</strong>，下图为 ASM 类的交互关系图：</p>
<p><img src alt="ASM的类交互关系"></p>
<p>图中的 CursorWindow 就是匿名共享内存，这个流程简单来说分为3个步骤：</p>
<ol>
<li>Client内部有一个 CursorWindow 对象，发送请求时，把这个CursorWindow 类型对象传过去，这个对象暂时为空     </li>
<li>Server 收到请求，搜集数据，填充到这个CursorWindow 对象中    </li>
<li>Client 读取内部这个CursorWindow 对象，获取数据。</li>
</ol>
<p>举个例子就是： 你定牛奶，在家门口放个空箱子，送奶人每天早上往这个箱子放牛奶，你睡醒了去箱子里取牛奶，<strong>这个奶箱就是匿名共享内存</strong>。</p>
<h3 id="ContentProvider-与-AMS-的通信"><a href="#ContentProvider-与-AMS-的通信" class="headerlink" title="ContentProvider 与 AMS 的通信"></a>ContentProvider 与 AMS 的通信</h3><ol>
<li>App2发送消息给AMS，想要访问 App1 中的 ContentProvider     </li>
<li>AMS 检查发现，App1的ContentProvider没有启动过(也即App1没启动，因为我们知道App启动时，在 Application的onCreate 之前就会启动ContentProvider，这也是 LeakCanary 新版免install的原理)，为此新开一个进程启动App1     </li>
<li>AMS获取App1启动的ContentProvider ，并把 ContentProvider 的代理对象返回给 App2     </li>
<li>App2 拿到 ContentProvider 的代理对象，也就是 IContentProvider，就调用它的增删改查方法。        </li>
<li>接下来就是使用 ASM(匿名共享内存)  传输数据，也就是上面提到的 CursorWindow 类，取得数据或者操作结果即可    </li>
</ol>
<h2 id="PMS-及-App-安装过程"><a href="#PMS-及-App-安装过程" class="headerlink" title="PMS 及 App 安装过程"></a>PMS 及 App 安装过程</h2><h3 id="PMS简介"><a href="#PMS简介" class="headerlink" title="PMS简介"></a>PMS简介</h3><p>在前面我们介绍过，AMS会使用 PackageManagerService(简称PMS)加载包的信息，之后AMS会将这个信息封装在 LoadedApk 这个类对象中，然后我们就可以从中取出在AndroidManifest 中声明的四大组件信息了。</p>
<p>在安装App的过程中，会把 apk <strong>复制到 data/app 目录</strong>下。apk是一个zip压缩包，在文件头会记录压缩包的大小，所以就算在后续文件尾追加一部电影，都不会对解压造成任何影响。Android的多渠道打包其中的一种思路就是这样，在 apk 尾巴上追加几个字节，来标记apk的渠道，apk启动时，从apk尾巴上读取这个渠道值。不过，后来google发现了这个漏洞，在新版本系统中，<strong>系统安装apk时，会检查apk实际大小，二者不相等就会报错安装失败</strong>。</p>
<p>这里回答前面提出的问题：为什么App安装不把它解压？其实，每次从apk读取资源，并不是先解压再找资源，而是解析apk中的resources.arsc文件，这个文件存储着资源的所有信息，包括资源在apk中的地址、大小等，按图索骥，可以很快拿到资源文件，这是一种很高效的算法。不解压的好处自然是<strong>节省空间</strong>。</p>
<h3 id="App安装流程"><a href="#App安装流程" class="headerlink" title="App安装流程"></a>App安装流程</h3><p>Android 系统使用PMS解析apk的AndroidManifest 文件，包括：</p>
<ul>
<li>四大组件信息    </li>
<li>分配用户id和用户组id，用户ID是唯一的，用户组id指的是各种权限，每个权限都在一个用户组中     </li>
<li>Launcher 生成一个icon，icon中保存着默认启动Activity的信息    </li>
<li>App 安装的最后，会把上面的信息记录在一个 xml文件中，以备下次安装使用      </li>
</ul>
<p><strong>Android手机系统每次启动时，都会使用PMS，把Android系统中所有的apk都安装一遍</strong>，共4个步骤：</p>
<p><img src alt="App安装流程"></p>
<p>关于第1步，因为app安装过后，都会xml保存安装信息，所以Android系统再次启动后，就可以直接读取之前保存的xml 了。第2步就是从所有目录安装apk。</p>
<h3 id="PakageParser"><a href="#PakageParser" class="headerlink" title="PakageParser"></a>PakageParser</h3><p>PMS是系统进程，我们是不能Hook的。PMS中有个类：PackageParser ，它是专门用来解析 AndroidManifest 文件的，以获取四大组件信息以及用户权限。它有一个parsePackage 方法，接收一个apkFile 文件参数，这个参数既可以是 当前apk文件，也可以是 外部apk文件，<strong>我们可以使用这个方法来读取插件apk的信息</strong>，虽然PackageParser 类不对外开放，但是我们可以反射来获取这个类。</p>
<h3 id="ActivityThread-与-PackageManager"><a href="#ActivityThread-与-PackageManager" class="headerlink" title="ActivityThread 与 PackageManager"></a>ActivityThread 与 PackageManager</h3><p>对于App开发人员，可以通过 Context.getPackageManager() 来获取当前的 Apk 信息，但其实它在ContextImpl中的真正实现是通过 ActivityThread.getPackageManager() 来实现的。所以，我们一般可以通过反射 ActivityThread 来获取Apk 信息，注意，<strong>这里一般是获取宿主Apk 的包信息，而不是插件Apk包信息</strong>。</p>
<h2 id="ClassLoader-家族史"><a href="#ClassLoader-家族史" class="headerlink" title="ClassLoader 家族史"></a>ClassLoader 家族史</h2><p>Android 插件化能加载外部下载的 Apk，就在于 ClassLoader。其中最重要的是 PathClassLoader 和 DexClassLoader，及其父类 BaseDexClassLoader。 PathClassLoader 和 DexClassLoader这两个类都很简单，粗看没啥区别，仔细看，构造函数第2个参数 optimizedDirectory 的值不一样，PathClassLoader 把这个参数设置为null，DexClassLoader 把它设置为一个非空的值。其实，<strong>这个值是用来缓存我们需要加载的dex文件的，并创建一个DexFile对象，如果为null，那么就会直接使用dex文件原有的路径来创建DexFile对象</strong>。由于DexClassLoader 可以指定自己的 optimizedDirectory，所以它可以用来加载外部的dex；而PathDexClassLoader 没有这个参数，只能加载内部的dex(存在于系统中的已经安装过的apk里面)。</p>
<h2 id="MultiDex"><a href="#MultiDex" class="headerlink" title="MultiDex"></a>MultiDex</h2><p>方法数超过65536 时，会有著名的 “65536”问题，一般来说我们使用 MultiDexApplication就能解决。Google还推出了 MultiDex 工具，它就是把原先的一个dex文件，拆分成多个dex文件，每个dex的方法数量不超过 65536。<strong>其中 classes.dex 称为主dex ，由App 使用PathClassLoader 加载，而 classes2.dex 等 dex 会在App 启动之后使用 DexClassLoader 进行加载。</strong></p>
<p>在Android 5.0之后，虽然能够在dex中容纳比65536更多的方法数，但是dex的体积变大了，<strong>为了加快速度，我们还是可对dex进行拆分，classes.dex只保留App启动所需的类以及首页的代码，从而确保App花最少的时间启动并进入首页</strong>，而把其他的模块代码转移到其他dex中，这个技术称为手动分包，在后续会介绍。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android插件化开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章：插件化昨天、今天与明天</title>
    <url>/2021/03/11/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E7%AC%AC1%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="插件化是什么"><a href="#插件化是什么" class="headerlink" title="插件化是什么"></a>插件化是什么</h2><p>如果做一个游戏平台，不可能把所有的游戏都包含进去，因为这样体积太大，浪费流量，浪费用户存储空间。只有用户需要玩什么游戏的时候，再动态下载安装某个游戏，这就是插件化的思想。</p><h2 id="为什么需要插件化"><a href="#为什么需要插件化" class="headerlink" title="为什么需要插件化"></a>为什么需要插件化</h2><p>如果某个插件功能有问题，则只需要改好bug打包这个插件就ok，不需要发版，用户不需要去应用商店更新App，就能够修复好的版本。这样，交易不会丢失。</p><a id="more"></a>

<p>此外，对于和竞争对手抢占市场的情况下，需要不断迭代发布新版本，发版周期太长，用户体验不到新功能；太短会引起用户反感，如果有插件化技术，做完新功能就能让用户看到新功能，这样就非常具有竞争力了。</p>
<h2 id="后续发展趋势"><a href="#后续发展趋势" class="headerlink" title="后续发展趋势"></a>后续发展趋势</h2><p>在插件化风行一段时间之后，Android热修复技术和 React Native 开始出现，与Android的插件化平分秋色，插件化技术不再是唯一选择。</p>
<h2 id="插件化的用途"><a href="#插件化的用途" class="headerlink" title="插件化的用途"></a>插件化的用途</h2><p>真是场景下，<strong>插件化 80% 的应用场景是为了修复线上bug</strong>，在这一点上，插件化与 Tinker、Robust 这类修复工具有相同的能力，甚至更出色。</p>
<p>其实，插件化更适合游戏领域，游戏经常上线新英雄，或者新的皮肤，这些都不用发版。</p>
<p>还有一个很好的场景： <strong>ABTest</strong>，当产品为两种风格的设计举棋不定的时候，那么把两种策略做成两个插件包，让 50% 的用户下载A策略，另外 50% 下载B策略，一周后看数据即可。</p>
<h2 id="更好的替代品：React-Native"><a href="#更好的替代品：React-Native" class="headerlink" title="更好的替代品：React Native"></a>更好的替代品：React Native</h2><p>React Native 这种映射思路(Android 和 ios 中的控件在RN中都能找到映射)，能够跨越 Android 和 ios 的系统差别。使用RN和纯原生相比，性能差距不大，在两个平台都很流畅。对于中小型企业来说，还能节省一端人力。</p>
<p>在jsPatch 被禁止后，RN 其实是ios 上最合适的热修复方案了。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android插件化开发指南</tag>
      </tags>
  </entry>
  <entry>
    <title>第13讲-存储优化<中>-如何优化数据存储</title>
    <url>/2020/07/04/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-13%E8%AF%BE/</url>
    <content><![CDATA[<h3 id="Serializable-的原理"><a href="#Serializable-的原理" class="headerlink" title="Serializable 的原理"></a>Serializable 的原理</h3><p>Serializable 的原理是<strong>通过 ObjectInputStream 和 ObjectOutputStream 来实现的</strong>，通过 Android 6.0 的源码可以看到 ObjectOutPutStream 的部分源码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeFieldValues</span><span class="params">(Object obj, ObjectStreamClass classDesc)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ObjectStreamField fieldDesc : classDesc.fields()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Field field = classDesc.checkAndGetReflectionField(fieldDesc);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>整个序列化过程使用了大量反射(反射意味着效率低)和临时变量(临时变量意味着GC)，并且，<strong>在序列化对象时，不仅会序列化当前对象本身，还需要地柜序列化对象引用的其他对象</strong>。</p>
<h3 id="Serializable-的进阶"><a href="#Serializable-的进阶" class="headerlink" title="Serializable 的进阶"></a>Serializable 的进阶</h3><p>Serializable 序列化支持使用自定义 writeObject和readObject，他会先反射判断是否存在我们自己实现的 序列化writeObject方法和反序列化readObject 方法。<strong>通过这两个方法，我们可以对某些字段做修改，也能实现序列化的加密功能。</strong></p>
<p>还有，Serializable 的反序列默认是不会执行构造函数的</p>
<h3 id="Parcelable-的永久存储"><a href="#Parcelable-的永久存储" class="headerlink" title="Parcelable 的永久存储"></a>Parcelable 的永久存储</h3><p>一般来说，我们使用 parcelable 只是会在内存中序列化操作，并不会存储到磁盘。其实，我们也可以存储到磁盘的：<strong>通过 Parcel.java 中的 marshall 接口获取byte 数组，然后存在文件中，从而实现 Parcelable 的永久存储。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns the raw bytes of the parcel.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] marshall() &#123;</span><br><span class="line">    <span class="keyword">return</span> nativeMarshall(mNativePtr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set the bytes in data to be the raw bytes of this Parcel.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unmarshall</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    nativeUnmarshall(mNativePtr, data, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，一般不推荐这样做，因为可能会有系统版本兼容性问题，因为我们无法保证所有的 Android 版本的 Parcel.cpp 实现完全一致。还有就是数据前后的兼容性，这里并没有类似 Serializable 里面有个 serialVersionUID 来保证版本一致性。</p>
<h2 id="14-数据库优化"><a href="#14-数据库优化" class="headerlink" title="14-数据库优化"></a>14-数据库优化</h2><p>SQLite 默认支持多进程并发操作，它通过文件锁来控制多进程的并发，但是SQLite 的锁粒度并没有非常细，针对的是整个DB文件，简单来说，多进程可以同事获取 SHARED 锁来读取数据，但是只有一个进程可以获取 EXCLUSIVE 锁来写数据库</p>
<p>数据库使用注意：</p>
<ul>
<li>防止注入   </li>
<li>防止窃取      </li>
<li>小表无需维护索引，因为索引是需要一直维护的，有代价        </li>
<li>慎用 “select * “ 需要多少列，就取多少列      </li>
<li>定期删除无用数据             </li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发高手课</tag>
      </tags>
  </entry>
  <entry>
    <title>存储优化<上>-常见的存储方式</title>
    <url>/2020/06/28/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-12%E8%AF%BE/</url>
    <content><![CDATA[<h2 id="Android存储安全"><a href="#Android存储安全" class="headerlink" title="Android存储安全"></a>Android存储安全</h2><p>在4.3以前，应用都在自己的沙盒里，沙盒使用标准Linux保护机制，为每个应用创建唯一 Linux UID 来定义。<strong>简单来说，就是保证微信不能访问淘宝的数据</strong>。</p><p>4.3以后引入SELinux，进一步定义应用沙盒边界。即使我们进程有root权限也不能为所欲为(想干事情必须先在安全策略配置文件中赋予权限)。</p><a id="more"></a>

<p>数据加密：Android 两种加密，全盘加密和文件加密。全盘加密在4.4引入，在 5.0 后默认打开</p>
<h2 id="常见数据存储方法"><a href="#常见数据存储方法" class="headerlink" title="常见数据存储方法"></a>常见数据存储方法</h2><p>综合来看,Android提供了 SharedPreferences /ContentProvider/文件/数据库</p>
<h3 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h3><p>非常简便，但是问题比较多:</p>
<ul>
<li>跨进程不安全       </li>
<li>加载缓慢(使用异步加载，且没设置线程优先级，就有可能出现主线程等待低优先级线程所问题)        </li>
<li>全量写入(无论commit还是apply，即使只改动一个条目，也会把全部内容写入，并且多次写入一个同一文件，也不会合并为一次)       </li>
<li>卡顿(收到系统广播或onPause等时机，系统会强制把sp文件写到磁盘，此过程或阻塞)      </li>
<li>还有，存储json等复杂文件时，会有转义等操作，会额外耗时     </li>
</ul>
<p>如果我们想的话，可以使用 MMKV 替代sp，<strong>它利用文件锁保证跨进程安全</strong>，并且性能也比较好</p>
<h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p><strong>ContentProvider 的生命周期默认在 Application 的onCreate 之前，而且是在主线程的</strong>，ContentProvider 跨进程传递数据是利用 Android 的 Binder 和匿名共享内存机制。简单来说，<strong>就是通过 Binder 传递 (CusorWindow 对象内部的）匿名共享内存的文件描述符</strong>，这样数据无需跨进程。</p>
<p>ContentProvider 主要存在以下几个问题：</p>
<ul>
<li>自定义的 ContentProvider 的构造函数、静态代码块、onCreate 函数尽量不要做耗时操作       </li>
<li>性能。传输数据比较小的时候，使用 ContentProvider 不一定划算    </li>
<li>安全：ContentProvider本身提供了很好的安全，但是如果是exported，当支持执行 sql 语句时，就要注意 sql 注入问题。     </li>
</ul>
<p>简而言之，ContentProvider 适合相对比较笨重，适合传输量大的数据</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发高手课</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-算法-红黑树</title>
    <url>/2020/06/27/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉查找树-也称二叉搜索树"><a href="#二叉查找树-也称二叉搜索树" class="headerlink" title="二叉查找树(也称二叉搜索树)"></a>二叉查找树(也称二叉搜索树)</h2><ul>
<li>左子树上的节点值都<strong>小于等于</strong>根节点的值    </li>
<li>右子树上的节点值都<strong>大于等于</strong>根节点的值    </li>
<li>左右子树也是二叉搜索树    </li>
</ul><p>它是基于二分查找的思想，<strong>查找最大的次数为二叉树高度</strong>     </p><h3 id="查找代价"><a href="#查找代价" class="headerlink" title="查找代价"></a>查找代价</h3><ul>
<li>当左右子树高度大致平衡时，时间复杂度在 O(logN)     </li>
<li>当先后插入的关键字<strong>有序</strong>时，退化成链表，查找的时间复杂度就在 O(N)了     </li>
</ul><a id="more"></a>


<h3 id="插入代价"><a href="#插入代价" class="headerlink" title="插入代价"></a>插入代价</h3><p>新节点插入到树的叶子节点上，因此，插入节点和查找一个不存在的数据的代价相同    </p>
<h3 id="删除代价"><a href="#删除代价" class="headerlink" title="删除代价"></a>删除代价</h3><ul>
<li>如果被删除的节点左、右 有一个为null时，代价仅为 O(1)      </li>
<li>如果左右子树都存在，时间复杂度最大也不会超过O(logN)      </li>
</ul>
<p>缺陷：</p>
<p>极端情况可能退化成链表，时间复杂度为  n。这主要是由于树不平衡导致的</p>
<h2 id="平衡二叉查找树-平衡二叉搜索树"><a href="#平衡二叉查找树-平衡二叉搜索树" class="headerlink" title="平衡二叉查找树(平衡二叉搜索树)"></a>平衡二叉查找树(平衡二叉搜索树)</h2><p>是严格的平衡二叉树，它是空树或者左右两个子树的高度差 <strong>小于等于1</strong>，同时，左右两个子树也是平衡二叉搜索树</p>
<h3 id="查找代价-1"><a href="#查找代价-1" class="headerlink" title="查找代价"></a>查找代价</h3><p>时间很稳定，查找效率最好最坏都是  O(logN)</p>
<h3 id="插入代价-1"><a href="#插入代价-1" class="headerlink" title="插入代价"></a>插入代价</h3><p>由于要保证严格的平衡，插入时可能要进行再平衡(最多旋转一次)，因此插入的整体代价还在 O(logN)</p>
<h3 id="删除代价-1"><a href="#删除代价-1" class="headerlink" title="删除代价"></a>删除代价</h3><p>和插入一样，要考虑再平衡，但是最多需要O(logN)次旋转，所以时间复杂度为  O(2logN)</p>
<h2 id="红黑树-Red-Black-Tree"><a href="#红黑树-Red-Black-Tree" class="headerlink" title="红黑树(Red-Black Tree)"></a>红黑树(Red-Black Tree)</h2><p>它并不严格地平衡，最长路径长度不超过最短路径长度的2倍。它删除和插入引起平衡性改变的概率要远低于平衡二叉搜索树</p>
<h3 id="查找代价-2"><a href="#查找代价-2" class="headerlink" title="查找代价"></a>查找代价</h3><p>查找代价基本上维持在 O(logN) 级别，最差情况下肯定比平衡二叉搜索树要差，因为没有那么平衡</p>
<h3 id="插入代价-2"><a href="#插入代价-2" class="headerlink" title="插入代价"></a>插入代价</h3><p>不容易引起失衡，整体代价和平衡二叉搜索树差不多，也是 O(logN) 级别(虽然涉及变色，但是变色的代价很小)</p>
<h3 id="删除代价-2"><a href="#删除代价-2" class="headerlink" title="删除代价"></a>删除代价</h3><p>相对平衡二叉搜索树，不容易引起失衡，时间复杂度也在 O(logN) 级别</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>平衡二叉搜索树由于插入和删除，会引起需要调整，可以通过 ：变色、左旋转、右旋转  三种方式调整。是否需要调整要根据红黑树的特性：</p>
<ul>
<li>节点是红色或黑色    </li>
<li>根节点是黑色    </li>
<li>叶子节点都是黑色的空节点    </li>
<li>红色节点的两个子节点都是黑的(红节点不能连续出现)    </li>
<li>任一点到每个叶子节点的路径包含相同数目的黑节点    </li>
</ul>
<h2 id="B-树和B-树"><a href="#B-树和B-树" class="headerlink" title="B-树和B+ 树"></a>B-树和B+ 树</h2><p>我们所谓的B-树，其实并不是B减树，中间是横线，不是减号；B + 就是 B加树了</p>
<p>如 os 的文件目录存储、数据库中的索引结构的存储，不可能在内存中建立查找结构，必须在磁盘中建立好结构。</p>
<p>在磁盘组织结构下，从任何一个节点指向其他节点都可能读取一次磁盘，再将数据写入内存比较。这回带来大量的IO操作，所以我们需要新的数据结构，即 B树和B+树。</p>
<p>B树是一种<strong>多路平衡查找树</strong>，每个节点最多包含k个孩子，k称为B树的阶。K大小取决于<strong>磁盘页的大小</strong>。</p>
<blockquote>
<p>以上内容参考自<a href="https://zhuanlan.zhihu.com/p/54084335" target="_blank" rel="noopener">知乎专栏</a>、<a href="https://zhuanlan.zhihu.com/p/31805309" target="_blank" rel="noopener">知乎</a>、<a href="https://blog.csdn.net/z702143700/article/details/49079107" target="_blank" rel="noopener">csdn博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>第18课-耗电优化<上></title>
    <url>/2020/06/26/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-18%E3%80%8119%E8%AF%BE/</url>
    <content><![CDATA[<h2 id="第18课-耗电优化-lt-上-gt"><a href="#第18课-耗电优化-lt-上-gt" class="headerlink" title="第18课-耗电优化&lt;上&gt;"></a>第18课-耗电优化&lt;上&gt;</h2><p>准确的测量电量并不是那么容易，在<a href="https://tech.meituan.com/2018/03/11/dianping-shortvideo-battery-testcase.html" target="_blank" rel="noopener">《大众点评App的短视频耗电量优化实战》</a>一文中，为我们总结了下面几种电量测试的方法:</p><p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E8%80%97%E7%94%B5%E9%87%8F%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95.png" alt="耗电量测试方法"></p><p>当测试反馈耗电问题时，<a href="https://developer.android.google.cn/studio/debug/bug-report" target="_blank" rel="noopener">bug report</a> 结合 <a href="https://github.com/google/battery-historian" target="_blank" rel="noopener">Battery Historian</a> 是最好的排除方法：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//7.0和7.0以后</span><br><span class="line">$ adb bugreport bugreport.zip</span><br><span class="line">//6.0和6.0之前:</span><br><span class="line">$ adb bugreport &gt; bugreport.txt</span><br><span class="line">//通过historian图形化展示结果</span><br><span class="line">python historian.py -a bugreport.txt &gt; battery.html</span><br></pre></td></tr></table></figure><a id="more"></a>




<h2 id="19讲-耗电优化-lt-下-gt"><a href="#19讲-耗电优化-lt-下-gt" class="headerlink" title="19讲-耗电优化&lt;下&gt;"></a>19讲-耗电优化&lt;下&gt;</h2><h3 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h3><ul>
<li>耗电优化的第一个优化方向是优化应用后台耗电    </li>
<li>第二个优化方向是符合系统的规则，让系统认为你的耗电是正常的。</li>
</ul>
<p>比如，Android P 通过 Android Vitals 监控后台耗电，所以我们需要符合它的规则，它的规则如下：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android-Vitals%E8%A7%84%E5%88%99.png" alt="Android-Vitals规则"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发高手课</tag>
      </tags>
  </entry>
  <entry>
    <title>第16课-网络优化<中></title>
    <url>/2020/06/26/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-16,17%E8%AF%BE/</url>
    <content><![CDATA[<h2 id="第16课-网络优化-lt-中-gt"><a href="#第16课-网络优化-lt-中-gt" class="headerlink" title="第16课-网络优化&lt;中&gt;"></a>第16课-网络优化&lt;中&gt;</h2><p>对于速度、弱网络以及安全的优化，该从哪些方面入手，首先我们要弄清楚一个网络请求的整个过程,示意图如下：</p><p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B.png" alt="网络请求的完整流程"></p><p>可以看出，整个流程分为 发起请求-&gt;DNS解析-&gt;创建连接-&gt;发送/接收数据-&gt;关闭连接    </p><h2 id="第17课-网络优化-lt-下-gt-大数据下网络如何监控"><a href="#第17课-网络优化-lt-下-gt-大数据下网络如何监控" class="headerlink" title="第17课-网络优化&lt;下&gt;-大数据下网络如何监控"></a>第17课-网络优化&lt;下&gt;-大数据下网络如何监控</h2><a id="more"></a>


<h3 id="插桩"><a href="#插桩" class="headerlink" title="插桩"></a>插桩</h3><p>为了兼容性考虑，首先考虑插桩。如360开源的性能监控工具 ArgusAPM ，就是利用 Aspect 切换插桩，实现监控系统和 OkHttp 网络请求库的请求。</p>
<p>系统网络库的插桩实现可以参考TraceNetTrafficMonitor，主要利用Aspect的切面功能，关于OkHttp的拦截可以参考OkHttp3Aspect，它会更加简单一些，因为OkHttp本身就有代理机制。</p>
<h3 id="Native-Hook"><a href="#Native-Hook" class="headerlink" title="Native Hook"></a>Native Hook</h3><p>hook 本地的代码，需要考虑兼容性</p>
<h3 id="统一网络库"><a href="#统一网络库" class="headerlink" title="统一网络库"></a>统一网络库</h3><p>ios 和Android 都统一使用同一套网络库，统一监控   </p>
<p><strong>小技巧：1、我们可以通过Android官方的 TrafficStats 类来获取整个手机或者某个 UID 从开机算起的网络流量； 2、Android 和 Iphone 都有一个网络测试模式，可以尝试下：</strong></p>
<blockquote>
<p>Android手机：打开拨号界面，输入 <em>#</em>#4636#<em>#</em> ，然后按拨号键（可进入工程测试模式，部分版本可能不支持）<br>iPhone手机：打开拨号界面，输入 <em>3001#12345#</em> ，然后按拨号键。</p>
</blockquote>
<p>自己注：在网上找到的<a href="https://www.jianshu.com/p/da2a0030962a" target="_blank" rel="noopener">微信弱网优化方法</a></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发高手课</tag>
      </tags>
  </entry>
  <entry>
    <title>第20课-UI优化-UI渲染关键概念</title>
    <url>/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-20%E8%AF%BE/</url>
    <content><![CDATA[<h2 id="UI优化-lt-上-gt-20讲"><a href="#UI优化-lt-上-gt-20讲" class="headerlink" title="UI优化&lt;上&gt;-20讲"></a>UI优化&lt;上&gt;-20讲</h2><h3 id="UI渲染的背景知识"><a href="#UI渲染的背景知识" class="headerlink" title="UI渲染的背景知识"></a>UI渲染的背景知识</h3><p>ppi 像素密度，每英寸包含的像素数，这是物理参数，不可改</p><p>dpi 像素密度，指的是单位尺寸像素数量。这是可以人为调整的         </p><p>density 密度，每平方英寸中包含的像素点数，density = dpi / 160    </p><p>dp ： px = dp * density</p><a id="more"></a>



<h3 id="屏幕适配方案"><a href="#屏幕适配方案" class="headerlink" title="屏幕适配方案"></a>屏幕适配方案</h3><p>使用dp</p>
<p>限制符适配</p>
<h3 id="CPU-与-GPU"><a href="#CPU-与-GPU" class="headerlink" title="CPU 与 GPU"></a>CPU 与 GPU</h3><p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6%E5%92%8C%E7%A1%AC%E4%BB%B6%E7%BB%98%E5%88%B6.png" alt="软件绘制与硬件绘制"></p>
<p>由上面的图可以知道，软件绘制使用的是Skia 库，硬件绘制是通过 open GL 之后在GPU 上实现的        </p>
<p>在Android 7.0以后，添加了对 Vulkan 的支持，它比 OpenGL 功耗和多核优化上更优秀</p>
<h3 id="Android-渲染的演进"><a href="#Android-渲染的演进" class="headerlink" title="Android 渲染的演进"></a>Android 渲染的演进</h3><p>可以通过下图整体看下Android 图形体系：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/Android%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F.png" alt="Android图形体系"></p>
<p>各个部分的功能可以比喻成以下内容：</p>
<ul>
<li>画笔：Skia 或者 OpenGL 。Skia 使用CPU 绘制，OpenGL 使用 GPU 绘制         </li>
<li>画纸：Surface。所有元素都在 Surface 这张画纸上绘制和渲染。<strong>在Android中，Window 是View的容器，每个Window 都会关联一个Surface</strong>。windowManager 负责管理这些 window ，并且把它们的数据传递给 SurfaceFlinger。   </li>
<li>画板：Graphic Buffer。Graphic Buffer 缓冲用于应用程序图形的绘制，Android 4.1 之前使用的是双缓冲；4.1之后使用三缓冲      </li>
<li>显示：SurfaceFliger 。将WindowManager 提供的所有 Surface ，通过Hardware Composer 合成并输出到显示屏      </li>
</ul>
<h3 id="开启硬件加速"><a href="#开启硬件加速" class="headerlink" title="开启硬件加速"></a>开启硬件加速</h3><p>软件绘制流程图如下：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.png" alt="软件绘制流程"></p>
<ul>
<li>Surface： 每个View 都由某个Window 管理，每个Window 关联一个Surface     </li>
<li>Cavas。通过Surface的lock 函数获得一个Cavas，Cavas 可以理解成Skia 底层接口的封装      </li>
<li>Grapic Buffer。 SurfaceFlinger 帮我们托管 BufferQueue ，我们从BufferQueue 中拿到 Graphic Buffer，然后通过Canvas 和 Skia 将绘制内容栅格化到上面(个人理解为栅格化后的数据保存在这个buffer中)。     </li>
<li>SurfaceFlinger 。通过 Swap Buffer 把 Front Graphic Buffer 的内容交给 SurfaceFlinger ，最后硬件合成器 Hardware Composer 合成并输出到显示屏。      </li>
</ul>
<p>硬件加速绘制流程如下图(3.0以后支持硬件加速)：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E7%A1%AC%E4%BB%B6%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.png" alt="硬件绘制流程"></p>
<p>硬件绘制与软件绘制最核心的区别是<strong>硬件绘制通过GPU完成 Graphic Buffer内容的绘制</strong>，此外，硬件绘制引入了 DisplayList 的概念，<strong>每个View内部都有一个DisplayList，当某个View需要重绘时，将其标记为Dirty，重绘也仅仅只需要重绘一个View的DisplayList</strong>，这样，无需像软件绘制那样向上递归，大大减少绘图的操作数量，提高了渲染效率，更新的过程示意如下：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E7%A1%AC%E4%BB%B6%E7%BB%98%E5%88%B6%E6%9B%B4%E6%96%B0Display.png" alt="硬件绘制更新Display"></p>
<p>硬件加速虽然极大地提高了显示和刷新速度，但是它也存在一些问题，一方面是内存消耗，另一方面是部分绘制函数不支持</p>
<h3 id="Project-Butter-（黄油计划）"><a href="#Project-Butter-（黄油计划）" class="headerlink" title="Project Butter （黄油计划）"></a>Project Butter （黄油计划）</h3><p>4.1的时候，提出黄油计划，主要包括两个方面，一是 VSYNC ,一是 Triple Bufferfing (三缓冲)。</p>
<p>在4.0 及以前，cpu可能在忙别的事情，导致没来得及处理UI 绘制，为了解决这个问题，VSYNC 出现了，它类似于时钟中断，这个信号到来时，CPU立即准备Buffer数据，大部分设备刷新频率都是60Hz，所以一帧数据的准备工作要在 16ms内完成。</p>
<p>4.0及以前，Android使用双缓冲，一般不同的View或者Activity 都会公用一个Window，也就是公用一个Surface，每个Surface 会有一个BufferQueue 缓存队列，这个队列由SurfaceFlinger 管理，<strong>通过匿名共享内存与App应用层交互。</strong>示意图如下：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/app%E4%B8%8Eui%E6%9C%BA%E5%88%B6%E4%BA%A4%E4%BA%92%E5%9B%BE.png" alt="app与ui机制交互图"></p>
<p>整个流程如下：</p>
<p>每个Surface对应的 BufferQueue 内有有两个Graphic Buffer，一个用于绘制，一个用于显示。</p>
<p>同一时刻可能有多个Surface (可能是不同应用的Surface，也可能是同一个应用里面类似SurfaceView 和TexureView ，它们都会有自己单独的Surface)，SurfaceFlinger 把所有的Surface 要显示的内容统一交给 Hardware Composer，它会最终合成屏幕显示的内容。</p>
<p>如果只有两个Buffer，当CPU/GPU 绘制时间过长，则两个缓冲区分别被显示设备和GPU 占用，cpu 无法准备下一帧数据，造成浪费。三个缓冲区的话，cpu、gpu 显示设备都能使用各自的缓冲区工作，个不影响，最大限度利用空闲时间。</p>
<p>在黄油计划之后，Android 5.0 推出了 RenderThread ，将所有GL 命令执行放到 RenderThread 中执行，减轻UI 线程的负担。</p>
<h3 id="数据测量"><a href="#数据测量" class="headerlink" title="数据测量"></a>数据测量</h3><p>可以通过开发者选项中查看过度绘制的情况</p>
<p>还可以使用 Systrace 性能数据采样和分析工具</p>
<p>4.1及以后，可以采用 Tracer for OpenGL ES 逐帧分析</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发高手课</tag>
      </tags>
  </entry>
  <entry>
    <title>第21课-UI优化-优化UI渲染</title>
    <url>/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-21%E8%AF%BE/</url>
    <content><![CDATA[<h2 id="UI优化-lt-下-gt"><a href="#UI优化-lt-下-gt" class="headerlink" title="UI优化&lt;下&gt;"></a>UI优化&lt;下&gt;</h2><h3 id="ui渲染测量"><a href="#ui渲染测量" class="headerlink" title="ui渲染测量"></a>ui渲染测量</h3><p>测试工具： Profile GPU Rendeing 和 Show GPU Overdraw ，定位方法可以参考<a href="https://developer.android.com/studio/profile/inspect-gpu-rendering" target="_blank" rel="noopener">官方文档，检查GPU渲染速度和过度绘制</a></p><p>问题定位工具可以使用 Systrace 和 Tracer for OpenGL ES，具体可以参考<a href="https://developer.android.google.cn/topic/performance/vitals/render" target="_blank" rel="noopener">官方文档：渲染速度慢</a></p><a id="more"></a>

<h3 id="适用于自动化测试场景的测试方式-自己加的标题"><a href="#适用于自动化测试场景的测试方式-自己加的标题" class="headerlink" title="适用于自动化测试场景的测试方式(自己加的标题)"></a>适用于自动化测试场景的测试方式(自己加的标题)</h3><p>虽然图形化界面工具非常好用，但是难以用在自动化测试场景，以下测量方式可以用于自动化测试：</p>
<h4 id="gfxinfo"><a href="#gfxinfo" class="headerlink" title="gfxinfo"></a>gfxinfo</h4><p>gfxinfo 可以输出包含各个阶段发生的动画以及帧相关的性能信息，以及渲染相关的内存和View hierachy 信息，命令如下：</p>
<blockquote>
<p>adb shell dumpsys gfxinfo <packagename></packagename></p>
</blockquote>
<p>在Android 6.0 之后，gxfinfo 命令新增了 framestats 参数，可以拿到最近120帧每个绘制阶段的耗时信息：</p>
<blockquote>
<p>adb shell dumpsys gfxinfo <packagename> framestats</packagename></p>
</blockquote>
<h4 id="SurfaceFlinger"><a href="#SurfaceFlinger" class="headerlink" title="SurfaceFlinger"></a>SurfaceFlinger</h4><p>除了耗时，还需要关心渲染使用的内存，4.1以后每个 Surface 都会有 3个 Graphic Buffer，那如何查看 Graphic Buffer 占用的内存，可以通过如下命令查看相应信息：</p>
<blockquote>
<p>adb shell dumpsys SurfaceFlinger</p>
</blockquote>
<p>这部分内存大小和 屏幕分辨率，以及Surface的个数有关。</p>
<h3 id="UI优化的常用手段"><a href="#UI优化的常用手段" class="headerlink" title="UI优化的常用手段"></a>UI优化的常用手段</h3><p>我们的目标是实现app的帧率达到 60fps，意味着所有操作要在 16.7 ms 内完成，这期间要做的事情如下所示：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/UI%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png" alt="UI渲染流程"></p>
<p>我们优化，就是拆解渲染的各个阶段耗时，找到瓶颈，加以优化。ui优化的方法如下：</p>
<h4 id="1、尽量使用硬件加速。"><a href="#1、尽量使用硬件加速。" class="headerlink" title="1、尽量使用硬件加速。"></a>1、尽量使用硬件加速。</h4><p>硬件加速绘制的性能是远远高于软件绘制的，所以ui优化第一个手段应该尽量使用硬件加速。但是有些api不支持硬件加速，这个需要注意，比如 渐变、磨砂、圆角等，它们的渲染性能比较低。</p>
<h4 id="2、View-的创建优化"><a href="#2、View-的创建优化" class="headerlink" title="2、View 的创建优化"></a>2、View 的创建优化</h4><p>View 的创建在UI线程，对于复杂的界面，这部分耗时不容忽视。View 的创建过程中，会包括xml的读取io，解析xml 以及生成对象的时间(Framework会大量使用反射)</p>
<p>因此建议：</p>
<p>1、使用代码创建view 对象缺点是不能直接预览<br>2、提前创建、异步创建<br>3、View 重用(模仿ListView、RecyclerView，不过重用要注意先清空状态)。  </p>
<p>如果异步创建，那么会导致系统抛出异常。这时候，我们可以通过非常取巧的方式来异步创建ui：<strong>先把线程的Looper的MessageQueue替换成Looper的Queue：</strong></p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BAui.png" alt="子线程创建ui"></p>
<p><strong>要注意的是，在创建完成view之后，需要把线程的Looper恢复成原来的。</strong></p>
<h4 id="3、measure-layout-优化"><a href="#3、measure-layout-优化" class="headerlink" title="3、measure/layout 优化"></a>3、measure/layout 优化</h4><p>这两部分也是在ui线程执行的，一般的优化方法有：</p>
<ul>
<li>减少UI布局层次      </li>
<li>优化layout开销。尽量不要使用 RelativeLayout 和 weighted LinearLayout ，它们开销很大，建议使用 ConstranLayout    </li>
<li>背景优化。尽量不要重复设置背景，<strong>尤其注意的是主题背景，theme默认会是一个纯色背景，如果我们自定义了界面背景，那么主题背景对我们来说是无用的</strong>，由于主题背景是设置在DecorView 中的，所以会带来重复绘制，也会带来绘制性能损耗。     </li>
</ul>
<h4 id="4、UI优化进阶"><a href="#4、UI优化进阶" class="headerlink" title="4、UI优化进阶"></a>4、UI优化进阶</h4><p>可以采用flutter</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发高手课</tag>
      </tags>
  </entry>
  <entry>
    <title>第7、8课-启动优化</title>
    <url>/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-7,8%E8%AF%BE/</url>
    <content><![CDATA[<h2 id="启动优化-lt-上-gt-第7讲"><a href="#启动优化-lt-上-gt-第7讲" class="headerlink" title="启动优化&lt;上&gt;-第7讲"></a>启动优化&lt;上&gt;-第7讲</h2><h3 id="启动分析"><a href="#启动分析" class="headerlink" title="启动分析"></a>启动分析</h3><p>着手优化之前，首先分析启动过程。</p><ol>
<li>首先预览窗口，系统拉起App进程之前，会根据app的Theme属性创建预览窗口。当然，我们禁用预览窗口或者预览窗口为透明时，用户依然可以看到桌面。               </li>
<li>进程和闪屏页创建完毕，可以看到广告图片界面                 </li>
<li>主窗口创建完成可以看到首页了         </li>
<li>首页加载完，才能操作起来            </li>
</ol><a id="more"></a>

<h3 id="启动遇到的问题"><a href="#启动遇到的问题" class="headerlink" title="启动遇到的问题"></a>启动遇到的问题</h3><ul>
<li>点击图标很久都不响应。可能是禁用了预览窗口或者透明皮肤           </li>
<li>首页显示太慢。闪屏广告、其它准备工作都要在启动阶段完成，如果耗时太多就慢            </li>
<li>首页显示后无法操作。工作异步延后之后，首页就会出现白屏，或者首页出来无法操作         </li>
</ul>
<h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><p>优化工具：综合看来，在卡顿优化中提到的 “systrace + 函数插桩” 是比较理想的方案，而且还能看到一些关键事件：GC、SystemServer 、CPU 调度等       </p>
<p><strong>准确的评估之后，才能指引优化的方向</strong></p>
<h4 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h4><ul>
<li>闪屏优化。今日头条把预览窗口与是县城闪屏效果，用户在很短时间内看到“预览闪屏”，不过这种实现对于低端机型会把总的闪屏时间拉长。所以比较推荐在 6.0及以上的版本才采用“预览闪屏”      </li>
<li>业务梳理。清楚启动过程中每一个运行的模块，哪些是一定需要的，哪些是可以砍掉，可以懒加载的。<strong>还有，懒加载要防止集中化，容易出现首页用户无法操作的情况</strong>。       </li>
<li>线程优化。主要在于减少cpu调度带来的波动，让应用启动更加稳定。具体做法是，一方面控制县城的数量，要有线程池(我们是采用Rxjava，统一管理线程池)；还有一个就是管理线程的锁，比如业务有先后顺序，或者优先级不同，这一点可以采用第三方启动框架来解决，比如<a href="https://github.com/alibaba/alpha" target="_blank" rel="noopener">阿里开源的Alpha</a>、<a href="https://mp.weixin.qq.com/s/6Q818XA5FaHd7jJMFBG60w?" target="_blank" rel="noopener">微信内部使用的mmkernel</a>            </li>
</ul>
<h2 id="启动优化-lt-下-gt-第8讲"><a href="#启动优化-lt-下-gt-第8讲" class="headerlink" title="启动优化&lt;下&gt;-第8讲"></a>启动优化&lt;下&gt;-第8讲</h2><h3 id="启动进阶方法"><a href="#启动进阶方法" class="headerlink" title="启动进阶方法"></a>启动进阶方法</h3><p>启动过程不建议出现网络io</p>
<p>还有，就是数据结构选择问题，在启动时，只需要读写很少量的 sp文件，如果与很大的sp文件一起解析，这个解析时间可能就要超过  100ms了(可以说我们的application中的sp解析是花了很长时间的)。</p>
<h3 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h3><p>应用加固对启动速度来说是灾难</p>
<h3 id="启动监控"><a href="#启动监控" class="headerlink" title="启动监控"></a>启动监控</h3><ul>
<li>实验室监控，如果客观地反映启动耗时，视频录制是非常好的选择，尤其是我们拿不到竞品的数据(通过分析竞品，我们制定了秒开的标准，可以取平均值、最大值、最小值)              </li>
<li>线上监控。我们使用talkingdata来监测。(但是我们要注意监测的耗时)，最终衡量指标呢，使用平均法容易忽略掉性能差的手机，可以使用快开慢开比：比如2秒快开比，5秒快开比；另一种就是 90% 用户启动时间，如果90%用户启动时间都小于5秒，那我们90%区间启动耗时就是5秒。                </li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发高手课</tag>
      </tags>
  </entry>
  <entry>
    <title>第5、6课-卡顿优化</title>
    <url>/2020/05/27/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-5,6%E8%AF%BE/</url>
    <content><![CDATA[<h2 id="卡顿优化-lt-上-gt"><a href="#卡顿优化-lt-上-gt" class="headerlink" title="卡顿优化&lt;上&gt;"></a>卡顿优化&lt;上&gt;</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>获取cpu信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 CPU 核心数</span></span><br><span class="line">cat /sys/devices/system/cpu/possible  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个 CPU 的频率</span></span><br><span class="line">cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq</span><br></pre></td></tr></table></figure><a id="more"></a>


<h3 id="卡顿指标"><a href="#卡顿指标" class="headerlink" title="卡顿指标"></a>卡顿指标</h3><p>出现卡顿，首先应该看<strong>cpu使用率</strong>，可以通过 /proc/stat 查看系统的cpu使用情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">proc/self/stat:</span><br><span class="line">  utime:       用户时间，反应用户代码执行的耗时  </span><br><span class="line">  stime:       系统时间，反应系统调用执行的耗时</span><br><span class="line">  majorFaults：需要硬盘拷贝的缺页次数</span><br><span class="line">  minorFaults：无需硬盘拷贝的缺页次数</span><br></pre></td></tr></table></figure>

<p>如果cpu使用率长期大于60%，表示系统处于繁忙状态，就需要<strong>进一步分析用户时间和系统时间的比例</strong>。普通应用程序系统时间不会长期高于 30% ，如果高于这个值，就应该检查<strong>是否是I/O过多，还是其他的系统调用问题</strong>。</p>
<p>另外，top 命令可以查看哪个进程是cpu消耗大户。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发高手课</tag>
      </tags>
  </entry>
  <entry>
    <title>第3、4课-内存优化</title>
    <url>/2020/05/27/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-3,4%E8%AF%BE/</url>
    <content><![CDATA[<h2 id="内存优化-lt-上-gt"><a href="#内存优化-lt-上-gt" class="headerlink" title="内存优化&lt;上&gt;"></a>内存优化&lt;上&gt;</h2><h3 id="Android中Bitmap-内存分配的变化过程"><a href="#Android中Bitmap-内存分配的变化过程" class="headerlink" title="Android中Bitmap 内存分配的变化过程"></a>Android中Bitmap 内存分配的变化过程</h3><ol>
<li>3.0以前，Bitmap 对象放在Java堆，像素数据存放在 Native内存中，如果不手动调用 recycle ，那么Native内存中的像素数据完全依赖于 finalize 函数，而这个函数是不可靠的         </li>
<li>3.0~7.0,Bitmap 对象和像素数据统一放到 Java 堆，这样就算不 recycle 操作，像素数据也会随着一起回收，不过，这导致大量内存占用，引起大量GC。一起放在内存也有可能即使系统有大量内存没利用，但是却会导致oom了(比如给分配的最大堆只到 300M，但是用得差不多了，此时系统却还空闲有3G内存，却要引起oom了)       </li>
<li>Android 8.0 中，NativeAllocationRegistry 可以满足Bitmap 对象存放在Java 堆，像素数据在 Native 中，还能实现一并回收对象和像素数据。(8.0还提供硬件位图(Hardware Bitmap)，减少内存占用并提升绘制效率)        </li>
</ol><a id="more"></a>
<h3 id="关于内存优化的两个误区"><a href="#关于内存优化的两个误区" class="headerlink" title="关于内存优化的两个误区"></a>关于内存优化的两个误区</h3><ul>
<li>内存占用越小越好。不是这样的，更多的内存意味着更好的动画效果和更快的缓存命中，只需要做到系统内存充足时多用，系统内存紧张时少用(释放不是必须的内存)即可                </li>
<li>Native 的内存不用管。其实，当系统内存不足的时候，就会开始依次清理 后台、桌面、服务、前台，一步步来，直到内存足够，最后直到重启手机                  </li>
</ul>
<h3 id="内存观测方法"><a href="#内存观测方法" class="headerlink" title="内存观测方法"></a>内存观测方法</h3><ol>
<li>观察Log，查看GC 回收的原因            </li>
<li>使用如下命令查看：         </li>
</ol>
<blockquote>
<p>adb shell dumpsys meminfo &lt;package_name|pid&gt; [-d]</p>
</blockquote>
<h2 id="内存优化-lt-下-gt"><a href="#内存优化-lt-下-gt" class="headerlink" title="内存优化&lt;下&gt;"></a>内存优化&lt;下&gt;</h2><h3 id="内存优化探讨"><a href="#内存优化探讨" class="headerlink" title="内存优化探讨"></a>内存优化探讨</h3><p>Bigmap 优化、内存泄露优化、设备分级几个层次入手</p>
<p>设备等级就是，在某些低性能的机器上，动画不要了，进程也不预先启动了。安装包大小也是有要求的，比如有很多app就有极速版这个概念，它们的apk很小，动画也不酷炫。apk大小跟内存的关系可以参考如下图：</p>
<p><img src="/assets/Book-Notes/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%B8%8E%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F%E5%85%B3%E7%B3%BB.png" alt="安装包大小和内存关系"></p>
<p>Bitmap 可以用第三方框架来做，比如Fresco，实在要自己管理，可以向后台要求指定宽度，bitmap的inbitMap内存复用，inSample降低采样</p>
<p>内存泄露：使用LeakCanary自动化检测方案，只可以做到Activity和Fragment的泄漏检测，如何检测其他的内存泄露呢？如何监测疑似的内存泄漏呢？</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发高手课</tag>
      </tags>
  </entry>
  <entry>
    <title>他山之石</title>
    <url>/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/</url>
    <content><![CDATA[<h2 id="碰到的"><a href="#碰到的" class="headerlink" title="碰到的"></a>碰到的</h2><p>1、内存泄漏怎么检测？LeakCanary 原理？</p><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><a href="https://glassx.gitee.io/2019/11/20/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/">参考以前的源码解析第10点</a></p>
</details><p>2、HashMap 源码？为什么要将链表转成红黑树？红黑树特点？</p><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">参考java基础中的第3点</a></p>
</details><p>3、消息循环源码、如何做到任务切换线程？想要提交一个任务有几种方式？</p><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>关于源码，可以从postDelay、IdleHandler、插队的msg 几个角度来讲。其中源码可以查看<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础中的3、4题</a>，后面两个可以参考<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础的32、33题</a></p>
</details><a id="more"></a>











<p>4、多个Fragment在销毁后重建之后重叠怎么办</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="产生重叠的原因"><a href="#产生重叠的原因" class="headerlink" title="产生重叠的原因"></a>产生重叠的原因</h3><p>一般是由于我们采用show 和 hide 的方式( 而不是replace )来控制Fragment 的显示和隐藏，当Activity 由于内存不足被回收之后再恢复的时候，如果不做处理，那就会把这些fragment new 出来添加到Activity 中，由于是刚new出来的，并没有以前的show/hide 状态，因此就造成重叠。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在第一次进入Activity 初始化Fragment的时候，为添加的fragment 设置tag ，并且 tag 为fragment的全限定名，将这些tag以列表形式tags保存。在 onSaveInstanceState 回调的时候，保存tags。</p>
<p>在恢复的时候，首先恢复出来tags，再依次遍历tags中的tag，使用FragmentManager.findFragmentByTag 查找fragment。如果查找出来的 fragment 不空，则直接使用，否则的话，就使用 savedInstanceState?.classLoader.loadClass(tag) 来反射新建这个fragment (因为我们的tag就是fragment 的全限定名嘛)。</p>
<h3 id="replace-方式切换fragment-与-show-hide-方式切换fragment"><a href="#replace-方式切换fragment-与-show-hide-方式切换fragment" class="headerlink" title="replace 方式切换fragment 与 show/hide 方式切换fragment"></a>replace 方式切换fragment 与 show/hide 方式切换fragment</h3><p>replace 固然可以避免很多不必要的问题，但是它不能保存页面状态，对用户体验不友好，频繁切换还会导致卡顿。show/hide 方式只会控制隐藏/展示，所以效率上会好一些。</p>
</details>

<blockquote>
<p>以上内容参考自<a href="https://www.jianshu.com/p/d2b088e7b6c0" target="_blank" rel="noopener">简书上的博客</a>、<a href="https://blog.csdn.net/qq_27258799/article/details/80489722" target="_blank" rel="noopener">披萨大叔</a></p>
</blockquote>
<p>5、设计一个图片缓存框架，缓存算法用什么</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>缓存算法使用 LRUCache，其原理可以参考<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础-LruCache原理</a></p>
</details>

<p>6、有个ListView快速滑动 如何优化Bitmap的显示</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>监听列表的 onScrollChangeListener ，在快速滑动的时候， Fresco.getImagePipeline().pause() ,停下之后又 resume() 操作。</p>
</details>

<blockquote>
<p>以上内容可以参考：<a href="https://www.cnblogs.com/ldq2016/p/6646761.html" target="_blank" rel="noopener">cnblogs上的博客</a></p>
</blockquote>
<p>7、Bitmap的复用听过没有</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Bitmap 复用可以参考 <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础的58知识点</a></p>
<p>大图加载可以参考<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础38知识点</a></p>
</details>

<p>kotlin 协程原理？怎么切换线程的？Kotlin 优点和缺点？</p>
<p>调优、怎么瘦身，打包流程，模块化</p>
<p>开发者模式中，GPUInfo 中柱状图颜色代表的含义；命令dumpsys meminfo中VSS、PSS、GSS、USS代表什么意思</p>
<p>Android绘制三部曲、Canvas是怎么最终显示在屏幕中的、是以什么样子的数据结构传输的</p>
<p>物理内存与虚拟内存的关系、Android Heap的结构是怎么样的、如果要进行垃圾回收，会收集那些区域</p>
<p>binder源码、其原理是什么，发起一次请求的过程，如何根据文件描述符找到对应的binder实体</p>
<p>如何进行内存优化 减少内存消耗</p>
<h2 id="shopee"><a href="#shopee" class="headerlink" title="shopee"></a>shopee</h2><p>1、try catch finally关于return的执行结果</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>参考<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">java基础-Java finally与return执行顺序</a></p>
</details>

<p>2、treemap如何对两个元素进行比较? 非compareble对象比较?</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>如果是非 compareble 对象，则通过构造函数传入自定义的 Comparetor 比较器。</p>
<p>参考<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">java基础第10个知识点</a></p>
</details>

<p>3、object有什么方法</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>clone、equals、finalize、getClass、hashCode、identityHashCode、identityHashCodeNative、internalClone、notify、notifyAll、toString、wait</p>
</details>

<blockquote>
<p>以上内容参考自系统源码</p>
</blockquote>
<p>4、讲讲Android存在的设计模式</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>Context 的装饰器模式       </li>
<li>AlertDialog 使用了建造者模式     </li>
<li>BitmapFactory 的工厂模式    </li>
<li>View 的layout、measure、draw 就是 责任链模式</li>
<li>aidl 代理模式     </li>
<li>ListView、Gridview 等 使用的适配器模式      </li>
</ul>
</details>

<blockquote>
<p>以上内容参考自<a href="https://www.jianshu.com/p/1a9f571ad7c0" target="_blank" rel="noopener">简书上的文章</a></p>
</blockquote>
<p>5、android的事件分发</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>可以参考<a href="https://glassx.gitee.io/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/">以前写的专题</a></p>
</details>

<p>6、android的消息机制</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础的第4点</a></p>
</details>

<p>7、LeakCanary</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><a href="https://glassx.gitee.io/2019/11/20/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/">参考以前的源码解析第10点</a></p>
</details>

<p>8、讲个android的源码 自选</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>讲讲Handler，在<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础的第4点</a>的基础上完善下表述。</p>
</details>

<p>9、hashcode 与 equals理解</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>可以看看<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">Java基础的15~18知识点</a></p>
</details>

<p>10、设计模式讲讲有什么认识的，代理模式优缺点</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>代理模式优点：</p>
<ul>
<li>协调调用者和被调用者，降低耦合度    </li>
<li>增强被调用者的功能。增加和更换代理无需修改被调用者源码，如何开闭原则，具有良好的可扩展性。      </li>
<li>保护目标对象      </li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了类         </li>
<li>速度可能慢。在调用者和被调用者之间增加了代理对象，因此请求处理的速度可能会变慢    </li>
<li>增加系统复杂度。实现代理模式需要额外的工作，有些可能还比较复杂，比如远程代理。      </li>
</ul>
</details>

<blockquote>
<p>以上内容参考自<a href="https://www.jianshu.com/p/6991491be81a" target="_blank" rel="noopener">简书上的博客</a></p>
</blockquote>
<p>图片 缓存机制</p>
<p>首屏调优 内存调优</p>
<h2 id="lazada"><a href="#lazada" class="headerlink" title="lazada"></a>lazada</h2><p>1、自我介绍一下    </p>
<p>2、app网络防劫持 介绍下，出现劫持，解决方案呢？拦截了webview 网络请求后，用什么请求 </p>
<p>3、性能优化，做了哪些工作</p>
<p>4、强引用、弱引用和软引用。弱引用和软引用的区别。    </p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>参考以前的<a href="https://glassx.gitee.io/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/">读书笔记</a></p>
</details>

<p>5、MVC 和 MVP 的区别。他们各个层次之间交互有什么区别 </p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>以前写的关于<a href="https://glassx.gitee.io/2019/11/23/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式的内容</a> 第1题 </p>
</details> 

<p>6、SharedPreference 是线程/进程 安全的吗？apply 和 commit 有什么区别？(提交到哪？是本地的xml 还是 内存的xml？)，有什么坑？ </p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>查看<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础</a> 第20题即可     </p>
</details> 

<p>7、Handler 机制说一下？ 消息延迟是怎么做到的？我有个新消息，在已有的消息队列中我想让他先执行，可以吗。</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>查看<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础</a> 第4题即可     </p>
</details> 

<p>8、最有挑战的项目？你负责做了什么？给公司带来什么价值？，这个sdk给你们的产品带来什么价值？如何判断你这个sdk是否好用？你们的业务成功率是多少，有统计吗？如果要设计这个监控这个sdk？你们有相关的埋点吗？感觉面试官隐约对app的监控感兴趣。</p>
<p>9、http 和 http2 有什么区别。</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>查看<a href="https://glassx.gitee.io/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">网络知识</a> 第15题即可     </p>
</details> 

<p>10、http 和 https 有什么区别。告诉我它是怎么做到安全的呢？</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>查看<a href="https://glassx.gitee.io/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">网络知识</a> 第9、10题即可     </p>
</details> 

<p>11、kotlin 语言与java 语言相比有什么优点吗？</p>
<p>12、kotlin 的协程了解吗？它的原理？协程相比线程创建的开销小一些？主线程使用协程是不是不会阻塞？假设我在主线程里面使用协程执行非常耗时的操作，我的主线程会ANR吗？为什么在io操作比较多的时候对协程有利呢？协程有自己的栈空间吗？  </p>
<h2 id="cici"><a href="#cici" class="headerlink" title="cici"></a>cici</h2><p>1、数组实现队列</p>
<p>2、gc的流程</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>可以查看 <a href="https://glassx.gitee.io/2019/11/23/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a> 第5题</p>
</details> 

<p>3、java软引用与弱引用区别  </p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>参考以前的<a href="https://glassx.gitee.io/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/">读书笔记</a></p>
</details>  

<p>4、java中的this编译时的原理</p>
<p>5、final变量用反射修改</p>
<p>6、HashMap的内部结构，给定一个key，如何找到对应的value，使用equal</p>
<p>7、volatile</p>
<p>8、Java线程池有什么作用</p>
<p>9、Java动态代理</p>
<p>10、handler机制</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>查看<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">Android基础</a> 第4题即可     </p>
</details> 

<p>11、android跨进程通信的方式</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>阅读<a href="https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/">以前的读书笔记</a></p>
</details> 

<p>12、自定义控件方式</p>
<p>13、Canvas绘制过什么 手写功能</p>
<p>14、断点续传的实现</p>
<p>15、如何设计图片加载库</p>
<p>16、有看过哪些安卓的源码 </p>
<ul>
<li>Activity启动    </li>
<li>handler      </li>
<li>ThreadHandler</li>
<li>IntentThread     </li>
</ul>
<p>17、看过哪些开源项目    </p>
<ul>
<li>LeakCanary    </li>
<li>Alpha    </li>
<li>okhttp    </li>
</ul>
<p>18、app 启动速度的优化做过哪些</p>
<p>19、fresco加载图片原理 优势是什么</p>
<p>20、写程序时，堆和栈有什么优化点 内存回收时机 如何判断对象可被回收</p>
<p>21、引用计数法和gc root法</p>
<p>22、事件分发 cancel事件一般在什么时候被触发</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>参考<a href>源码理解</a>中的12、13题</p>
</details> 

<p>23、touchdelagate 一个父view只能设置一个delegate，如何解决设置多个</p>
<p>24、App整个架构了解么</p>
<p>25、mvvm data binding</p>
<p>26、webview</p>
<p>27、fragment startactivity</p>
<p>28、动画的原理</p>
<p>黄油计划 vsync</p>
<p>设计一个离线视频下载功能</p>
<p>Activity 启动流程</p>
<p>android  app签名原理</p>
<p>Android查询资源文件layout原理</p>
<p>设计一个decode bitmap方法</p>
<p>启动Activity A后，按home键，再从桌面启动activity A ， Activity A的生命周期</p>
<p>handler原理</p>
<p>onSaveInstanceState调用时机</p>
<p>Fragment View区别</p>
<p>Java内存管理和内存回收</p>
<p>Android scheme</p>
<p>Activity怎么管理自己的生命周期，ActivityThread怎么运作</p>
<p>消息事件分发</p>
<p>进程之间通讯</p>
<p>线程锁</p>
<p>touch事件分发原理scrollview和viewpager之间的滑动如何防止冲突，里面listitem也需要支持滑动怎么办</p>
<p>插件化的了解情况动态代理实现（自由发挥的）</p>
<p>如何实现一个拥有取出最小值方法的堆栈，要求算法的事件复杂度是O(E)如何算</p>
<p>二叉树节点之间的最小距离</p>
<p>两个链表，可能很长，实现求和（大数求和），结果也是单向链表</p>
<p>ActivityTask的使用</p>
<p>onNewIntent的调用时机</p>
<p>checkbox，up事件和down事件的区别</p>
<p>怎么用Standard方式来实现一个SingleTop启动的Activity</p>
<p>Http文件上传的具体过程</p>
<h2 id="BD"><a href="#BD" class="headerlink" title="BD"></a>BD</h2><p>线程同步方法（关键字，并发包）</p>
<p>wait/notify,notify方法和notifyAll方法区别，notifyAll方法唤醒的线程，怎么决定哪一个线程得到运行</p>
<p>HashMap(要很熟悉)，put过程，get过程</p>
<p>现在key为double类型，需要将key的整数部分当成同一个key应该怎么做（提示：重写方法）</p>
<p>内存泄露分析</p>
<p>进程间通信方式(别忘了BroadcastReceiver)</p>
<p>A跳转到B的生命周期调用，如果A的onStop方法方法发生在B的onResume方法之前会发生什么现象，如果B是singleTask又是什么情况？会调用B的哪些方法</p>
<p>service运行在什么线程</p>
<p>Handler内存泄露原理(message.target = handler，所以真正原因是由于message造成的)，解决方法，一个线程可以有多个Handler吗。</p>
<p>handler的sendMessage方法和postRunable方法区别</p>
<p>HandlerThread</p>
<p>设计一个图片加载框架，LRUCache原理</p>
<p>看过第三方库的源码吗</p>
<p>排序算法，时间复杂度，快排为什么是NlogN</p>
<p>完全二叉树高度</p>
<p>弱引用和软引用</p>
<p>今天面到的题目新的部分有几个  1include merge viewstub区别  2二叉树第n层节点个数  3touchdelegate </p>
<h2 id="TOU面试"><a href="#TOU面试" class="headerlink" title="TOU面试"></a>TOU面试</h2><p>1、http状态码</p>
<p><a href="https://glassx.gitee.io/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">网络知识</a>第16题</p>
<p>onTouch、onTouchEvent、onClick 执行顺序</p>
<p>onclick 不响应，如何排查    </p>
<p>设计一个下载框架(考虑多线程)。</p>
<p>单进程中，一个线程下载和用两个线程下载哪个更快？</p>
<p>在主线程要优先执行一个任务咋办？除了消息栅栏外还有其他方法吗？<br>Thread.join，还有吗？如何发送消息栅栏，这是hide方法，自己如何发送异步消息。</p>
<p>空闲的时候执行某个任务有什么方法？IdleHandler，还有其他方式吗</p>
<p>IntentService 与 Service 区别，啥时候用IntentService  </p>
<p>synchronized 锁优化策略</p>
<p>线程安全的集合有哪些？CopyOnWriteList 在什么时候使用？HashTable 与 ConcurrentHashMap 的区别？</p>
<p>线程池的拒绝策略有哪些？</p>
<p>什么情况下singleTask 在一个进程中会有两个实例？ NEW_TASK A启动B，B启动C，C启动D，现在从D启动A，并且启动完成后只保留A，如何做？</p>
<p>Okhttp 的 addInteceptor 与 addNetWorkInterceptor 的区别 </p>
<p>如何保证dns的安全？自己建立dns服务器，httpdns</p>
<p>做sdk的话，如何在接入的时候管理第三方依赖</p>
<p>设计模式，整体和部分</p>
<p>Okhttp 多个host，如何配置</p>
<h2 id="TENG面试"><a href="#TENG面试" class="headerlink" title="TENG面试"></a>TENG面试</h2><p>了解插件化吗？有哪些第三方开源的方案？Tinker的原理</p>
<p>行业内性能优化的方案有了解吗？页面如何秒开？</p>
<p>串行GC的时候，会锁住堆挂起线程，那么无论线程处于什么状态都能挂起吗？</p>
<p>多线程中的同步队列与等待队列(可能问的是 同步队列和条件队列)</p>
<p>CAS是啥？AQS是啥<a href="https://ddnd.cn/2019/03/15/java-abstractqueuedsynchronizer/" target="_blank" rel="noopener">可以参考这里</a>？RetraintLock的原理</p>
<p>锁的种类，什么是可重入锁</p>
<p>如何让多个线程同时启动</p>
<p>Java内存空间怎么划分</p>
<p>有哪些GC算法，哪些对象可以作为GC Root</p>
<p>JNI 中，Env是啥，它能干什么</p>
<p>什么情况下本地方法栈会引用Java对象</p>
<p>HashMap原理</p>
<p>Android系统的启动流程，应用为什么用zygote来fork，有什么好处</p>
<p>Apk的签名原理，v1和v2</p>
<p>https相比http的优势是什么？除了安全之外呢？证书如何校验</p>
<p>Java的堆与栈的区别，除了存储的对象不一样之外，还有其他不一样么？</p>
<p>进程间通信为什么用Binder，Binder的原理？空间大小限制（貌似是4M）?</p>
<p>可重入锁是什么？悲观锁和乐观锁的区别？</p>
<p>什么时候用到TCP，什么时候用到UDP？举例</p>
<p>https的攻击手段，https的证书是如何发送给客户端的？</p>
<p>RecyclerView和ListView的区别</p>
<h2 id="TENG面试-1"><a href="#TENG面试-1" class="headerlink" title="TENG面试"></a>TENG面试</h2><p>http状态码</p>
<p>ontouch  ontouchEvent  onClick  执行顺序</p>
<p>onClick不响应，应该怎么排查</p>
<p>设计一个下载框架（还要考虑多线程），单进程中，一个线程下载和用两个线程下载谁快？（要充分利用cpu）</p>
<p>在主线程我要优先执行一个任务咋办？消息栅栏，除了这种方法之外呢？如何发送消息栅栏？这是hide方法</p>
<p>空闲的时候执行某个任务有什么方法？IdleHandler，thread. join，还有啥方法吗</p>
<p>IntentService 与service区别？啥时候用IntentService </p>
<p>synchronize锁优化策略</p>
<p>线程安全集合有哪些？HashTable与ConcurrentHashMap 的区别？Copy onWrite List在啥时候用？</p>
<p>线程池的拒绝策略有哪些</p>
<p>什么情况下singleTask在一个进程中会有两个实例</p>
<p>a启动b，b启动c，c再启动d，这时候直接回到a页面，并且只保留a页面，有啥方法？</p>
<p>okhttp的addIntercept 与 add Network Interceptor 方法区别？</p>
<p>dns安全，httpdns 方案</p>
<p>做sdk管理第三方依赖</p>
<p>设计模式，整体和部分</p>
<p>自己发送异步消息</p>
<p>okhttp多个host，多重配置</p>
<p>异步创建view的原理</p>
<p>如何插桩</p>
<p>哪些地方匿名共享内存：堆，contentprovider，显示的时候</p>
<p>sp原理</p>
<p>事件分发</p>
<p>hashtable concurrentHashMap</p>
<h2 id="TOU面试-1"><a href="#TOU面试-1" class="headerlink" title="TOU面试"></a>TOU面试</h2><p>handler，IdleHandler原理，使用</p>
<p>组件化，插件化，热修复</p>
<p>断点续传</p>
<p>用过哪些开源库？retrofit的原理</p>
<p>反转二叉树</p>
<p>做了哪些优化？gpu优化？</p>
<p>hashmap原理，如何hash？为什么8个的时候要红黑树？</p>
<p>a启动b生命周期怎么走</p>
<p>gc算法，哪些可以作为gc root，分代算法是怎样的？</p>
<p>volatile关键字作用？能保证原子性吗？</p>
<p>webview内存泄露的原理，handler内存泄露原理</p>
<p>如何发现内存泄露？LeakCanary的原理是什么？</p>
<p>Activity的启动模式</p>
<p>taskaffinity的作用？</p>
<p>进程间通信方式有哪些？AIDL能传递的数据类型有哪些？AIDL怎么使用？AIDL的方法参数能传接口吗？都跨进程干什么</p>
<p>app崩溃率多少？怎么统计的？能捕捉所有异常吗？如何捕捉native的崩溃？</p>
<p>动态代理</p>
<h2 id="TENG面试-2"><a href="#TENG面试-2" class="headerlink" title="TENG面试"></a>TENG面试</h2><p>relativelayout与constrantlayout（可以参考链接：<a href="https://mp.weixin.qq.com/s/gGR2itbY7hh9fo61SxaMQQ）" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/gGR2itbY7hh9fo61SxaMQQ）</a></p>
<p>如何查看cursor之类的导致内存泄露问题</p>
<p>onclick，onTouch执行顺序</p>
<p>算法：链表的中间元素，判断链表是否有环，快排最好最差时间复杂度，快排是怎么操作的</p>
<h2 id="T3-面试"><a href="#T3-面试" class="headerlink" title="T3 面试"></a>T3 面试</h2><p>近期有做什么优化或者重大技术？<br>DNS污染是怎么回事<br>https的证书是怎么起作用的？<br>用什么检测内存泄漏-LeakCanary<br>扫码登录是怎么做到的<br>多线程用过吗，乐观锁与悲观锁说下    </p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>String可以继承吗？为什么？为什么设计成不可变？<br>快排原理<br>二分查找原理<br>Activity的几种启动方式，Service中怎么启动Activity（参考链接：<a href="https://blog.csdn.net/fang323619/article/details/74388804），从源码角度来说，ActivityManager" target="_blank" rel="noopener">https://blog.csdn.net/fang323619/article/details/74388804），从源码角度来说，ActivityManager</a> 为什么会对4种tag做处理</p>
<p>事件传递的机制(触摸事件)？Activity 的顶级响应视图是啥？onTouchListener 与onClickListener 哪个先执行(onTouchListener)？onTouchListener 返回true 之后，onClickListener 还会执行吗(不会)？onTouchListener 和 onLongClick 哪个先执行？</p>
<p>View的绘制流程？从掉帧的角度来说下 View 的绘制流程？<br>ScrollView 嵌套滑动冲突怎么去解决？在父view的up里面return 了true，子view会收到down事件吗？<br>tcp与udp区别，tcp三次握手做了什么<br>单例模式怎么写，为什么<br>大图一般是怎么优化的？fresco的源码有看过吗，它有什么缺点？有没有用过其他的图片框架？<br>Activitymanagerservice 源码<br>知道哪些app性能优化</p>
<h2 id="国斌"><a href="#国斌" class="headerlink" title="国斌"></a>国斌</h2><p>1:<br>    （1）自我介绍<br>    （2）你主要负责什么模块、奖金优化是什么东西（奖金优化的前提是如果能中奖，中奖金额要怎么样）、如何将所有组合列出来、如何将注数分配出去、奖金范围怎么算的<br>    （3）APP的架构是怎么样的，为什么要这样子架构？MVP每块你们是怎么分工的<br>    （3）首屏怎么调优的、加快启动速度的，内存泄漏怎么检测，LeakCanary原理是什么<br>    （4）HashMap源码相关、为什么要将链转红黑树？红黑树特点、插入删除<br>    （5）消息循环源码、如何做到任务切换线程、想要提交一个任务有几种方式<br>    （6）Kotlin协程原理，怎么切换线程的，为什么要换Kotlin及其优缺点<br>    （6）一个无序、实际上是逆序的数组排序用什么算法好 我说的是快排、实际上应该用归并排序能获得最好的时间复杂度</p>
<p>2：<br>    （1）还是奖金优化<br>    （2）还是性能调优、怎么瘦身、打包流程、模块化<br>    （3）开发者GPUInfo中的每条柱状图颜色代表含义、命令dumpsys meminfo中VSS、PSS、GSS、USS代表什么意思<br>    （4）Android绘制三部曲、Canvas是怎么最终显示在屏幕中的、是以什么样子的数据结构传输的<br>    （5）物理内存与虚拟内存的关系、Android Heap的结构是怎么样的、如果要进行垃圾回收，会收集那些区域<br>    （6）binder源码、其原理是什么，发起一次请求的过程，如何根据文件描述符找到对应的binder实体<br>    （7）广度、深度搜索，拓朴排序、最短路径算法<br>    （8）ELF文件格式、反编译器原理<br>    （9）Kotlin优缺点</p>
<p>3：<br>    （1）项目架构是怎么样的<br>    （2）画一下结构图<br>    （3）为什么要迁移项目到Kotlin<br>    （4）线程 协程 为什么需要线程池 他的状态变化是怎么样的 在Android中的应用<br>    （5）如何设计一个App的架构 该考虑什么<br>    （6）Flutter怎么从平台到Dart的 如何渲染的<br>    （7）你觉得面得怎么样</p>
<p>4：</p>
<p>讲个项目你负责的模块<br>多个Fragment在销毁后重建之后重叠怎么办<br>设计一个图片缓存框架<br>缓存算法用什么<br>有个ListView快速滑动 如何优化Bitmap的显示<br>Bitmap的复用听过没有<br>如何进行内存优化 减少内存消耗</p>
<p>5：</p>
<p>讲下项目的架构<br>负责的模块<br>算法 最大子序和<br>try catch finally关于return的执行结果<br>hashmap源码 treemap如何对两个元素进行比较 非compareble对象比较<br>hashcode equals区别<br>object有什么方法<br>讲讲Android存在的设计模式<br>android的消息机制<br>android的事件分发<br>讲个android的源码 自选<br>LeakCanary</p>
<p>6：<br>android消息机制<br>android事件分发<br>设计模式讲讲有什么认识的 代理模式优缺点<br>图片 缓存机制<br>首屏调优 内存调优</p>
<h2 id="lazada-1"><a href="#lazada-1" class="headerlink" title="lazada"></a>lazada</h2><p>自我介绍<br>性能优化做了哪些工作<br>四种引用的含义<br>mvp 与 mvc 区别<br>Handler 机制，如何实现消息延迟<br>最有挑战的项目，负责做了什么<br>业务监控怎么设计<br>http与http2的区别<br>http与https的区别<br>kotlin语言与java的区别，优点<br>kotlin的协程原理，有自己的栈空间吗，与线程区别</p>
<p>英语自我介绍下？–妥妥挂了。。</p>
<h2 id="猫总"><a href="#猫总" class="headerlink" title="猫总"></a>猫总</h2><p>为什么不用URLConnection而用OKHttp不了解</p>
<h2 id="qq的music"><a href="#qq的music" class="headerlink" title="qq的music"></a>qq的music</h2><p>自我介绍下<br>性能优化的经验<br>如何设计措施，防止以后新人在主线程添加太多的任务<br>了解过启动框架吗<br>如何分阶段启动相关任务，这些任务有相互依赖，或者有向无关图<br>能达到什么效果，量化下<br>内存优化的内容<br>webp 占用内存小一些还是尺寸小一些？<br>图片框架本来就会做这些裁剪之类的功能，这样自己做是否就重复了<br>其它内存优化的点(我觉得可以说说大图加载，只加载一部分)<br>了解ashmem 吗，除了这个作用还能有其他作用吗<br>优化app的整体内存占用<br>第一步得分析吧。profile 工具<br>第二步、分析问题在哪，native 和 Java 层 的内存占用，如果native 和 Java 中图片占用都比较大，如何分析<br>第三步、是内存泄漏导致的、还是大数组、大对象</p>
<p>用LRU 的话，一般不会引起内存很大占用，所以如果内存大，一般是内存泄漏导致的</p>
<p>Talkingdata 统计些什么     </p>
<p>监控dns的成功率，即用户使用你的ip直接请求的成功率了，以前系统直接解析，现在是用户直接打不开         </p>
<p>尝试使用https 去解决吗</p>
<p>网络成功率怎么优化      </p>
<p>dark 和 art 的 gc 过程有了解吗        </p>
<p>非并行 GC 的过程</p>
<p>分配内存，不够，然后做什么操作，最后就会分配成功。分配不够的话，系统会扩容，扩容发生在什么时机           </p>
<p>常用设计模式，单例模式怎么写      </p>
<p>volatile ：</p>
<p>性能优化了解不太多，尤其内存优化总结不多，数据量化</p>
<h2 id="字节参考"><a href="#字节参考" class="headerlink" title="字节参考"></a>字节参考</h2><p>Fresco 架构上说下，MVC模式，说说 Fresco加载gift的流程和原理<br>4. 一个大的ViewGroup，上面显示两个不一样大小的图片，内容一样，怎么做（利用Fresco的缓存）<br>5. 一个图片是50 * 50，一个图片是100 * 100，内存大小是怎样的，比如 50<em>50的内存大小是1，100</em>100的内存大小是多少？  两张图片，内存变大了还是不变，内存副本有几份？<br>6. RecyclerView 滑动的时候，缓存机制<br>7. RecyclerView 下面一个子item，我手指按在RecylerView上，然后滑动，说出滑动过程<br>8. 海量数据中找出TOP N（堆）<br>9. 自定义帧动画机制，一边解压一边加载，用完之后回收，inBitmap进行内存复用。用了哪些数据结构，如何保证按顺序执行。<br>10. bitmap drawable 区别(互相转化，drawable包含bitmap)Bitmap是Drawable . Drawable不一定是Bitmap Drawable在内存占用和绘制速度这两个非常关键的点上胜过Bitmap</p>
<p>1、   jni 方法调用是怎么实现之类的<br>2、   java  string 和 c++ string 有什么区之类的<br>3、   自己做的项目上遇到的技术难题和解决方案<br>4、   消息队列</p>
<p>如何设计一个组件化的app<br>View的绘制流程<br>activity的启动模式<br>如何监控启动就crash的问题<br>如何独立编译单独的组件<br>对比一下图片加载模块，Glide 和Fresco , AsyncImageView</p>
<p>主要还是通过项目发散开的问题：<br>1，android开发中常见的两种序列化，serializeble 和 parcelable 的区别<br>2，recyleview中的常见卡顿问题是如何解决的，如何监控到用户的卡顿（监控UI线程的message 处理逻辑，超过60ms）<br>3，项目比较大，编译比较慢的解决办法（插件化，组件化）<br>4，项目中遇到的一个小问题，是如何解决的<br>5，OOM类型的问题如何解决<br>6，内存泄漏如何监</p>
<p>Android so如何减包<br>Android Camera采集渲染流程<br>如何排序一个比内存大的文件</p>
<p>C++ 父类析构函数的virtual作用，怎么实现防止内存泄漏的<br>C++ 虚函数表是什么<br>JNI的attachCurrentThread作用是什么<br>JNI的LocalRef和GlobalRef new了是否要delete，可以不delete么？<br>简单介绍下libuv</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>他山之石</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发技巧</title>
    <url>/2020/05/01/Android%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="查看运行的service"><a href="#查看运行的service" class="headerlink" title="查看运行的service"></a>查看运行的service</h2><p>如果要查看当前手机上运行有哪些service（不可以先 adb shell 再执行后面的，否则显示的进程就不对了，至少我的是这样的）：</p><blockquote>
<p>adb shell dumpsys activity services</p>
</blockquote><p>当然，肯定是可以加 grep 关键字过滤的：</p><blockquote>
<p>adb shell dumpsys activity services | grep MiniAppPreService</p>
</blockquote><a id="more"></a>



<p>同理，我们也可以通过 grep 过滤查看当前一组进程(下面示例是过滤出名字中包含 com.example.io 的)：</p>
<blockquote>
<p>adb shell ps | grep com.example.io</p>
</blockquote>
]]></content>
      <categories>
        <category>Android技巧</category>
      </categories>
      <tags>
        <tag>手摸手</tag>
      </tags>
  </entry>
  <entry>
    <title>第8章：计算机网络中的安全</title>
    <url>/2020/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87%E7%AC%AC6%E7%89%88-%E7%AC%AC8%E7%AB%A0/</url>
    <content><![CDATA[<p>8.6 使TCP 连接安全，SSL </p><p>SSL （Secure Socket Layer ）安全套接字层， SSL 版本 3的一个稍加修改的版本被称为 TLS(Transport Layer Security)</p><p>在 http 之下，tcp 之上，有 ssl 层。</p><p>ssl 握手流程：</p><p>总体来说，ssl 握手，首先要建立一个tcp 连接 ，其次在验证server 的真实性 ，最后 client 再将对称加密所需要的key通过公钥加密交给server。此后，两端通过对称加密来完成通信。整个过程如下图所示：</p><a id="more"></a>




<p><img src="/assets/Book-Notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC8%E7%AB%A0/ssl%E6%8F%A1%E6%89%8B.png" alt="ssl握手整体步骤"></p>
<p>抛开tcp连接的建立，详细步骤如下：</p>
<ol>
<li>client发送支持的算法列表以及一个随机数 x      </li>
<li>server 从接收的列表中选择一种对称算法、一种非对称算法 和 一种摘要算法，连同自己的证书 以及 随机数 y 一起返回      </li>
<li>client 验证该证书，提取公钥，并生成一个<strong>前主密钥</strong>，并用服务器的公钥加密这个 前主密钥，之后发送给server      </li>
<li>server 解密获得 主密钥    </li>
<li>client 发送自己这边所有握手的报文的一个 摘要    </li>
<li>server 端发送自己这边握手报文的一个 摘要    </li>
</ol>
<p>最后两个步骤保证了握手免受篡改危害。比如，在观察第一步的时候，客户端提供的算法列表，有些算法强，有些弱，因为还未协商，所以这张列表是以明文发送的。如果中间攻击者从中删除了较强的算法，迫使server 最后只能选择较弱的算法。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>计算机网络-自自顶向下方法-中文第6版</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章：运输层</title>
    <url>/2020/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87%E7%AC%AC6%E7%89%88-%E7%AC%AC3%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="3-2-因特网提供的运输服务"><a href="#3-2-因特网提供的运输服务" class="headerlink" title="3.2 因特网提供的运输服务"></a>3.2 因特网提供的运输服务</h2><p>TCP 协议提供的拥塞控制不一定能给通信进程带来直接好处，但能为因特网带来整体好处。</p><h2 id="3-3-无连接运输：UDP"><a href="#3-3-无连接运输：UDP" class="headerlink" title="3.3 无连接运输：UDP"></a>3.3 无连接运输：UDP</h2><p>Dns 是一个通常使用 UDP 的应用层协议的例子。一台主机中的DNS应用程序想要进行一次查询时，它构造一个报文并将其交给UDP。如果没有查询到，要么告知应用程序不能响应，要么试图向另一个dns服务器发送查询。</p><a id="more"></a>

<p>为什么不是总选择TCP这种可靠连接呢？有以下几个原因：</p>
<ul>
<li>速度快。无需建立连接，不用像TCP 哪样三次握手然后建立连接(想想如果dns运行在tcp上，则会慢很多)     </li>
<li>更精细控制。使用UDP ，应用层可以更精细控制 何时、发送什么数据     </li>
<li>UDP 无需维护连接状态。没有维护连接状态，也就不需要发送和跟踪 缓存、拥塞控制、序号确认  等工作，响应更快     </li>
<li>分组的首部开销小，TCP 有20个字节，而UDP 仅仅 8个字节     </li>
</ul>
<p>首先要提一下，UDP 是可以实现可靠数据传输的，可以通过在应用程序中建立可靠性机制来保证。这样无需受制于TCP 拥塞控制机制限制传输速率。</p>
<p>UDP 首部只有 源端口号，目的端口号，长度(首部+数据) 以及 校验和。校验和用于防止传输过程中引入的差错(路由器内存可能引入比特差错)</p>
<p>3.4 可靠传输的原理</p>
<p>TCP 是在不可靠的 IP 层之上实现可靠数据传输协议。</p>
<p>需要三种协议来处理比特差错的情况：</p>
<ul>
<li>差错检测。要有检测手段      </li>
<li>接收方反馈。     </li>
<li>重传     </li>
</ul>
<p>回退N步：允许发送放发送多个分组，而不需要等待确认，但是也受到滑动窗口的限制，不能超过最大分组数。如果出现超时，发送方重传所有已发送但还未被确认过的分组。当接收到一个连续的ack时，窗口就向前滑动(因为接收方是要求按序接收的，比如n还没收到，但是来了n+1，将会把n+1丢掉的)。<br>选择重传：按照滑动窗口发送时，接收方将确认一个正确接收的分组而不管其是否按序，时序的分组将被缓存直到所有丢失分组都受到位置，这样才一并交给上一层。避免丢弃导致无谓的重传</p>
<h2 id="3-5-面向连接的传输：TCP"><a href="#3-5-面向连接的传输：TCP" class="headerlink" title="3.5 面向连接的传输：TCP"></a>3.5 面向连接的传输：TCP</h2><p><strong>快速重传</strong>： 一旦收到3个冗余的ACK，TCP就会执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。      </p>
<p>TCP让发送方维护一个接收窗口的变量来提供流量控制。</p>
<p><strong>流量控制服务：</strong>限制发送速率，避免发送方使接收方缓存溢出的可能性。    </p>
<p>如果客户端故意不发送ACK来完成第三次握手，那就是所谓的SYN洪范攻击。</p>
<p><strong>拥塞控制：</strong>如果TCP发送方感知到网络没什么拥塞，则TCP发送方增加其发送速率；如果发送方感知有拥塞，则降低发送速率。</p>
<p>确定拥塞： 超时或者 收到3个冗余的 ACk，就认为发生了拥塞<br>如何控制：可以使用拥塞窗口(congestion window，用cwnd 来表示) 去控制发送方向网络中发送流量的速率。    </p>
<p>TCP拥塞控制算法：</p>
<ul>
<li>慢启动：TCP 连接开始时，cwnd 通常设置一个较小的值，之后，每发送成功一次，cwnd就翻番。因此，tpc开始时较慢，但在慢启动过程中以指数增长。    </li>
<li>拥塞避免： 一旦进入拥塞避免状态，cwnd的值是上次遇到拥塞时的值的一半，即距离拥塞并不远。因此，tcp 每发送成功一次不再是翻番，而是增加一定的量，先行规律缓慢增长，比慢启动速率慢很多。</li>
<li>快速恢复： 拥塞窗口减半cwnd=cwnd/2，之后执行拥塞避免算法，使拥塞窗口慢慢增大。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>计算机网络-自自顶向下方法-中文第6版</tag>
      </tags>
  </entry>
  <entry>
    <title>高级进阶课</title>
    <url>/2020/04/19/%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="4-1-停止线程"><a href="#4-1-停止线程" class="headerlink" title="4-1 停止线程"></a>4-1 停止线程</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>有两种方法：</p>
<ul>
<li>调用 interruput 方法，通过抛异常的方式触发</li>
<li>使用boolean 标志位，注意，要使用volatile 标志位保证可见性；</li>
</ul>
<p>一般而言，如果你使用了 Thread.sleep() 这样的系统方法，那么使用 interrupt 方法来停止线程，否则一律使用 boolean 标志位。</p>
<p>建议转移到线程安全问题上去</p>
<h3 id="为什么停止线程会有问题"><a href="#为什么停止线程会有问题" class="headerlink" title="为什么停止线程会有问题"></a>为什么停止线程会有问题</h3><p>suspend 方法，但是现在已经被废弃。线程 t1 和 t2 ，如果t1被暂停了，然后一直持有锁 L1，那么t2一直在等待L1，而且不知道什么时候会恢复，这就很糟心了；并且如果t2持有t1需要的锁 L2 ，那就更麻烦了，可能导致死锁。所以线程的暂停(suspend方法)方法被废弃了。停止线程t1，马上释放锁，这时候线程t2 获取锁，接着读取这块加锁的内容，此时，如果t1在这个过程中只写入部分数据，t2 拿到的就是 非法数据，所以停止线程(stop方法)是不安全的。</p>
<p>为什么Thread 的run方法中执行 sleep 方法要try-catch 捕捉 InterruptedException ，这是因为在sleep 过程中，有可能这个thread 会被调用 thread.interrupt() ，此时就会触发 这个异常，我们应该在 catch 语句中 关闭打开的文件之类的。</p>
</details><a id="more"></a>

<h2 id="4-2、如何写出线程安全的代码"><a href="#4-2、如何写出线程安全的代码" class="headerlink" title="4-2、如何写出线程安全的代码"></a>4-2、如何写出线程安全的代码</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>每个线程都有一个自己的内存副本，这是java的内存模型。</p>
<p>要么不共享，要么不可变。其次就是采取一定手段了</p>
<p>final 其实还有一个功能就是禁止重排序。某些情况下，构造函数调用完了，非final的成员变量还没初始化完(final 是已经初始化完了)，这就会有问题了。</p>
<p>为什么 a++ 不是原子性的，因为这个操作首先要将 a 赋值进来，int temp = a; 之后再对temp 操作：temp += 1; 最后再将 temp 的值赋回给a。</p>
<h3 id="ThreadLocal-的使用建议"><a href="#ThreadLocal-的使用建议" class="headerlink" title="ThreadLocal 的使用建议"></a>ThreadLocal 的使用建议</h3><p>ThreadLocal 对对象也是弱引用</p>
<ul>
<li>声明为全局静态final 成员，避免初始化多个ThreadLocal 对象(因为设置value的时候是以ThreadLocal 为key的)        </li>
<li>避免存储大量对象，因为hash冲突使用的是<strong>开放定址</strong> 法，这并不适合大量数据      </li>
<li>用完后及时移除，因为它只能靠主动移除和线程退出时移除，否则线程声明周期长的时候，迟迟得不到释放。    </li>
</ul>
<p>禁止重排序的方法：</p>
<ul>
<li>final 关键字</li>
<li>volatile关键字</li>
<li>加锁(synchronized/Lock)</li>
</ul>
<p>保证可见性：</p>
<ul>
<li>final 关键字    </li>
<li>volatile     </li>
<li>加锁(释放锁之前强制刷新到主内存 )     </li>
</ul>
<p>保证原子性的方法：</p>
<ul>
<li>加锁    </li>
<li>使用CAS 指令    </li>
<li>使用原子类型 ，如 AtomicInteger       </li>
<li>使用原子属性更新器    </li>
</ul>
</details>

<blockquote>
<p>还可以参考<a href="https://www.jianshu.com/p/95291228aff7" target="_blank" rel="noopener">简书上的博客</a></p>
</blockquote>
<h2 id="4-3、ConcurrentHashMap"><a href="#4-3、ConcurrentHashMap" class="headerlink" title="4-3、ConcurrentHashMap"></a>4-3、ConcurrentHashMap</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>从1.5 到 1.8 一直在优化</p>
<p>jdk5：诞生，分段锁(segment)，对段加锁，必要时加锁。它的hashCode 计算方法就是，对key 求hashCode ，之后对这个hashCode 再散列得到散列码 code，之后，根据这个code 的高位 来计算segment 的值，根据低位计算在segment 中的值。<br>1.6：二次hash算法。Integer 的hashCode() 函数返回的就是它的value值。3万多以下的整数高位都是15，于是都集中在一个segment中，退化成 HashTable 了(因为对这个segment 加锁也就相当于对整个ConcurrentHashMap加锁了)<br>1.7：段(segment)懒加载，volatile &amp; CAS 操作避免加锁。一开始并不会把segment 通通new出来，需要哪个。使用volatile  来修饰 segment[] 数组，防止可见性导致的问题，比如，在某个segment 创建后，另一个线程不能马上知道。<br>8、摒弃段(segment)，基于Hashmap 原理并发。  使用    </p>
<h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>分段计数</p>
<h3 id="CHM-是弱一致性"><a href="#CHM-是弱一致性" class="headerlink" title="CHM 是弱一致性"></a>CHM 是弱一致性</h3><ul>
<li>添加元素不一定马上读到。你读过这个段，然后再往这个段添加数据，那么就遗漏了</li>
<li>同以上的理，清空之后可能还有元素；</li>
</ul>
<h3 id="HashTable-的问题"><a href="#HashTable-的问题" class="headerlink" title="HashTable 的问题"></a>HashTable 的问题</h3><ul>
<li>大锁，对整个HashTable 加锁    </li>
<li>长锁，直接对方法加锁    </li>
<li>读写公用一把锁，读写不能同时进行</li>
</ul>
<h3 id="CHM-解法"><a href="#CHM-解法" class="headerlink" title="CHM 解法"></a>CHM 解法</h3><p>小锁： 分段锁(1.5<del>1.7 版本使用segment)，后来(1.8版本)桶节点锁<br>短锁：先尝试获取，失败再加锁<br>分离读写锁：读写失败再加锁(1.5</del>1.7版本)，volatile读CAS写(1.7~1.8版本)     </p>
<h3 id="总结：如何进行锁优化"><a href="#总结：如何进行锁优化" class="headerlink" title="总结：如何进行锁优化"></a>总结：如何进行锁优化</h3><p>长锁不如短缩：尽可能只锁必要的部分<br>大锁不如小锁：对加锁的对象拆分<br>分离读写锁，读写的频次是不一样的<br>消除无用锁，尽量不加锁，使用volatile 或者 CAS </p>
</details>

<h2 id="4-5-Android-中写出优雅的代码"><a href="#4-5-Android-中写出优雅的代码" class="headerlink" title="4-5 Android 中写出优雅的代码"></a>4-5 Android 中写出优雅的代码</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>异步，不一定涉及到多线程，比如你setOnclickListener，它不是马上执行，而是等点击再相响应。异步不一定快，如果你线程一直在做运算，其实就无需太多线程，如果有很多io，被阻塞在那，那多开线程是有用的。</p>
<p>避免回调地狱。</p>
<h3 id="Rxjava-要注意的问题："><a href="#Rxjava-要注意的问题：" class="headerlink" title="Rxjava 要注意的问题："></a>Rxjava 要注意的问题：</h3><ul>
<li>很多时候Rxjava 请求完数据后，要更新UI，其实本质上这还是匿名内部类，会持有 Activity 引用。更新ui的时候，ui可能已经没有了，可能出现空指针；    </li>
<li>声明将所有任务的句柄放在 List<disposable> 列表中，在需要停止的时候，遍历执行 Disposable.dispose();     </disposable></li>
</ul>
<h3 id="kotlin-协程"><a href="#kotlin-协程" class="headerlink" title="kotlin 协程"></a>kotlin 协程</h3><p>协程将异步逻辑同步化，取消协程，其实是跟 view 绑定，监听它的attach 状态，在dettach 的时候，取消协程。</p>
</details>

<h2 id="5-1-cpu-架构适配"><a href="#5-1-cpu-架构适配" class="headerlink" title="5-1 cpu 架构适配"></a>5-1 cpu 架构适配</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>注意问题：</p>
<ul>
<li>native 开发才关注cpu架构</li>
<li>不同架构兼容性如何    </li>
<li>so 库太多如何优化 apk 体积     </li>
<li>sdk 开发者应该提供哪些so 库    </li>
</ul>
<p>armeabi 可以兼容x86 和 arm 架构，但是不兼容 mips(mips 目前已经被Android废弃了)。但是兼容方式无法获得最优性能，性能不敏感的话，可以这么干。有哪个架构的目录，那么所有so库就要有一份这个架构。</p>
<p>目前用得最多的可能就是 armabi-v7a 了，考虑实际情况可能使用 armabi-v7a 就可以了。</p>
<p>但是如果你有某个compute.so  针对计算比较多，那么你可以在 armeabi 目录下存在一个 compute.so  以及 compute_v8a.so  ，其他的abi 只要提供一份就可以了(其实，微信就是这么干的)。非启动加载的so可以云端加载，从后台拉取。</p>
<p>在gradle 中指定需要的so类型，减小apk体积</p>
<p>sdk 开发要提供完整abi  </p>
</details>

<h2 id="5-2-Java-native-方法怎么与Native-函数绑定"><a href="#5-2-Java-native-方法怎么与Native-函数绑定" class="headerlink" title="5-2 Java native 方法怎么与Native 函数绑定"></a>5-2 Java native 方法怎么与Native 函数绑定</h2><p>第5章的，都是jni，后面再看</p>
<h2 id="6-1，Activity-启动流程"><a href="#6-1，Activity-启动流程" class="headerlink" title="6-1，Activity 启动流程"></a>6-1，Activity 启动流程</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="考察什么："><a href="#考察什么：" class="headerlink" title="考察什么："></a>考察什么：</h3><ul>
<li>与ams 如何交互<br>参数结果如何展示</li>
<li>Activity 如何实例化</li>
<li>Activity 生命周期如何流转</li>
<li>Activity 窗口如 何展示</li>
<li>Activity转场动画实现机制</li>
</ul>
<h3 id="Activity-跨进程启动"><a href="#Activity-跨进程启动" class="headerlink" title="Activity 跨进程启动"></a>Activity 跨进程启动</h3><p>所有进程Zygote fork 出来，预加载到启动资源，加快速度。 </p>
<p>插件化，要有占位Activity才能实现。只能Activity 在进程内启动另一个Activity 的时候可以，在请求ActivityManagerProxy 之前和在ActivityThread 中开始回调Activity生命周期之前进行相应处理。</p>
<p>Activity 跨进程启动Activity ，会涉及到Binder 通信，这个Binder 缓冲区是有大小限制的(貌似是4M)，没办法传递的。如果要实现数据传递，如果在同一个进程，可以使用单例，否则呢，不在同一个进程中，可以使用Provider(而AIDL 使用的也是Binder ，同样有大小限制吧)。</p>
<p>由于Activity 是通过反射构建出来的对象： (Activity)cl.loadClass(className).newInstance()  ，它是通过无参的构造器构造的，所以呢，我们不要去写Activity 的构造函数，这是不应该的；尤其不要只写有参数的构造函数，这样的话，就没法启动这个Activity 了，会崩溃的。</p>
<p>Fragment 也不要自己写有参数的构造器，虽然我们自己可以把它new出来。但是当Activity 被回收，之后恢复Activity 的时候，会恢复Fragment ，当然，这个恢复也是通过反射的方式，通过无参的构造函数来构建Fragment实例的。如果你是通过有参数的构造函数自己启动Fragment的，那么在恢复的时候可能会丢失信息，<strong>这也是我们要求使用 arguments 方式而不是构造函数的参数给fragment传递数据的原因</strong>。个人猜测，这可能也是不让我们自己new Activity 的方式去构造它的原因吧。</p>
<h3 id="Activity的窗口展示流程"><a href="#Activity的窗口展示流程" class="headerlink" title="Activity的窗口展示流程"></a>Activity的窗口展示流程</h3><p><img src alt="Activity的窗口展示流程"></p>
<p>在Activity 启动过程中，ActivityThread 执行 handleLaunchActivity，在这个方法中，attach 的时候就会 createPhoneWindow，之后调用 create、start、restoreState、postCreate、resume 过程中，其实都在installDecor (个人觉得是初始化 DecorView)，在resume回调之后，马上调用 makeVisible 才将DecorView 展示出来(layout啊，绘制啊)，我们才能看到显示的内容。这也就是为什么在resume 之前我们无法准确地获取View 的高度的原因。</p>
<h3 id="转场动画"><a href="#转场动画" class="headerlink" title="转场动画"></a>转场动画</h3><p>前一个页面调用 ExitTransiton，在新页面没打开之前，执行这个退出动画，进入新页面时，执行进入动画，这样就衔接上了。</p>
</details>

<h2 id="6-2-如何跨App-启动Activity？有哪些注意事项？"><a href="#6-2-如何跨App-启动Activity？有哪些注意事项？" class="headerlink" title="6-2 如何跨App 启动Activity？有哪些注意事项？"></a>6-2 如何跨App 启动Activity？有哪些注意事项？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="如何启动外部应用的-Activity"><a href="#如何启动外部应用的-Activity" class="headerlink" title="如何启动外部应用的 Activity"></a>如何启动外部应用的 Activity</h3><ul>
<li>共享uid的app(即在App的AndroidManifest文件中都注明了 android:sharedUserId=”xxx”，这个xxx 在两个应用中都是相同的) ，给 Intent 设置包名和Activity的全路径名，即可启动。    </li>
<li>目标Activity 在AndroidManifest.xml中 设置为 exported=true，之后给Intent 设置 包名 和Activity全路径名即可。     </li>
<li>给目标Activity 设置 action 和 category ，使用 IntentFilter 隐式启动    </li>
</ul>
<h3 id="为允许外部启动的-Activity-添加权限"><a href="#为允许外部启动的-Activity-添加权限" class="headerlink" title="为允许外部启动的 Activity 添加权限"></a>为允许外部启动的 Activity 添加权限</h3><p>为目标Activity 添加权限，如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"com.examle.permit"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"zzz"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"zzzzz"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么，如果外部app要启动这个Activity，它要在 AndroidManifest 文件中声明这个权限。之后，再通过 action 和 category 方式启动。不过，这个要求含有目标Activity 的app先行安装。      </p>
<h3 id="拒绝服务漏洞"><a href="#拒绝服务漏洞" class="headerlink" title="拒绝服务漏洞"></a>拒绝服务漏洞</h3><p>如果你的Activity 暴露出去了，那么攻击者可以来攻击，让你的Activity 拒绝服务。具体的原理如下：</p>
<ol>
<li>我们知道，如果Activity A 启动另一个App 的 Activity B 的时候，往Intent 里面传入一个 实现了序列化接口的对象 serializableObject ，是可以传递过去的。    </li>
<li>在 B 中，只要你去访问了 intent.getExtra() ，那bundle 就会把序列化的数据反序列化过来。     </li>
<li>好了，如果serializableObject 对象对应的类只在 A 中有，但是在 B 应用中并没有，这时候反序列化就会产生异常(ClassNotFoundException，类找不到异常)。</li>
</ol>
<p>拒绝服务异常一般发生在 Activity 启动过程中 或者在 onNewIntent 回调过程中。解决方法包括： 1、使用try-catch   2、不要暴露Activity   </p>
</details>


<h2 id="6-4、在代码任意位置为当前-activity-添加-view"><a href="#6-4、在代码任意位置为当前-activity-添加-view" class="headerlink" title="6-4、在代码任意位置为当前 activity 添加 view"></a>6-4、在代码任意位置为当前 activity 添加 view</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="如何在任意位置获取当前Activity"><a href="#如何在任意位置获取当前Activity" class="headerlink" title="如何在任意位置获取当前Activity"></a>如何在任意位置获取当前Activity</h3></details>

<h2 id="6-5、微信右滑返回效果"><a href="#6-5、微信右滑返回效果" class="headerlink" title="6-5、微信右滑返回效果"></a>6-5、微信右滑返回效果</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Fragment中实现相对简单，Activity 实现起来复杂</p>
<p>fragment实现： view 跟随手势移动的效果，不涉及window控制</p>
<p>用Activity实现，前一个activity 要搞成透明的效果，windowIsTranslucent = true，window的background 设置为透明<br>多个Task情况，比如顺序启动 a、b、c 三个，a 和 c 在同一个栈，因此可以先获取b的照片放做背景<br>透明对Activity生命周期影响，设置透明的话，下面的Activity 只能是 onPause 状态，不可能stop<br>所以我们只有在滑动的时候，才要求透明，其他的时候不透明，因为透明会影响绘制效率啊。。。。    </p>
</details>

<h2 id="7-1、为什么不能在UI线程绘制"><a href="#7-1、为什么不能在UI线程绘制" class="headerlink" title="7-1、为什么不能在UI线程绘制"></a>7-1、为什么不能在UI线程绘制</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>ui线程是什么？ActivityThread 的main函数所运行的线程<br>为什么ui要设计成非线程安全的？因为加锁开销大，ui对时间敏感，ui具有高频可变性</p>
<p>非ui线程一定不能更新吗？不是，还有surfaceView，它会对canvas 加锁 ： lockCanvas ，其次再draw ，最后 unLockCanvas，绘制放在子线程，效率提高。所以，可能app已经anr了，但是地图绘制界面还在绘制，很奇怪，这是因为地图绘制使用了 surfaceview。不过现在官方推荐使用TexutureView了，不推荐使用 SurfaceView。</p>
</details>

<h2 id="Handler-的delay-可靠吗？"><a href="#Handler-的delay-可靠吗？" class="headerlink" title="Handler 的delay 可靠吗？"></a>Handler 的delay 可靠吗？</h2><p>不可靠</p>
<h2 id="7-3、ANR-类型"><a href="#7-3、ANR-类型" class="headerlink" title="7-3、ANR 类型"></a>7-3、ANR 类型</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>原理，就是处理事物之前 postDelay 一个事件，这个事件会导致anr窗口弹出，如果在delay的时间内完成事物，则会removeMessage ，把这个postDelay的message移除，就不会产生anr了。</p>
<p>Looper为什么不会导致cpu占用过高？因为 epoll多路复用机制</p>
</details>

<h2 id="7-4、自己实现Handler"><a href="#7-4、自己实现Handler" class="headerlink" title="7-4、自己实现Handler"></a>7-4、自己实现Handler</h2><p>略</p>
<h2 id="8-1、如何避免oom"><a href="#8-1、如何避免oom" class="headerlink" title="8-1、如何避免oom"></a>8-1、如何避免oom</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>native heap 在内存不够的时候，也会抛oom</p>
<p>使用合适的数据结构<br>避免枚举-影响内存和编译出来的文件(都会增大)</p>
<p>Bitmap： 选选择合适的分辨率，如果作为背景不要太清晰<br>不要使用帧动画<br>对Bitmap的重采样</p>
<p>谨慎使用多进程，新进程会带有一些公共资源，是会消耗内存的。<br>谨慎使用largeHeap = true，不同的手机上不一定能实现，还有，内存太大了，gc会困难<br>使用NDK，Native Heap 优雅避免java 堆内存限制</p>
</details>

<h2 id="8-2、如何对图片缓存？"><a href="#8-2、如何对图片缓存？" class="headerlink" title="8-2、如何对图片缓存？"></a>8-2、如何对图片缓存？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>网络/磁盘/内存 进行缓存<br>缓存算法-LRU算法，或者最少使用频率的算法<br>如何验证算法的效果(命中率)</p>
</details>

<h2 id="如何计算图片占用内存的大小"><a href="#如何计算图片占用内存的大小" class="headerlink" title="如何计算图片占用内存的大小"></a>如何计算图片占用内存的大小</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>根据实图手动计算它在内存中占用的内存。</p>
<p>首先了解dip，mdpi、hdpi、xhdpi、xxhdpi、xxxhdpi</p>
<p>canvas 就相当于一个层，这个层根据不同手机进行缩放</p>
<p>assets(sd卡上的文件也是一样的)：<br>如果png，采用ARGB_8888 的话呢，那就是 宽 × 高 × 4 ，因为每个像素要有4个字节，这里 4个8，每个8代表8个比特<br>如果是jpg，你没有指定加载格式，它默认还是使用 ARGB_8888，计算方式还是：宽 × 高 × 4。 其实jpg它没有透明度，那个A是没有用的，使用 RGB_565 即可，5 + 6 + 5 = 16 ，2个字节，所以就是  宽 × 高 × 2    </p>
<p>从hdpi：</p>
<p>假设图片的大小为 112px * 131px ,格式png，如果你图片在 hdpi 中，那么系统会认为你这个图片的密度本身就是1.5，如果你这时候有个2.75密度屏幕的手机，那么它就会换算，比如说宽度 ： 112 / 1.5 * 2.75 = 205.333…. ，系统会四舍五入取 205 ，同理高度会换算成： 131/1.5<em>2.75 = 240，所以如果使用 ARGB_8888 ，那占用内存就是  205</em>240 * 4。同理啊，如果手机屏幕大点，比如说是3，那就是 131/1.5*3  和 112 / 1.5 * 3 了。</p>
<p>在把它放到xxhdpi，这时候密度是 3 了，这时候如果手机是 3，那就得是 131/3*3  和 112 / 3 * 3 了</p>
<p>所以如果在 mdpi中，那默认图片密度是 1了，那么在 dpi 是 3的手机上，图片宽高应该是 131*3  和 112 * 3</p>
<p>以此类推，其实在drawable，后面没有带dpi 的，那效果和 mdpi 一样，默认图片是 1</p>
<p>如果是nodpi ，告诉系统不会缩放，就按照原始的像素，131 和 112 了</p>
<p>所以宽高的计算方式 ：  图片/dpi * 屏幕dpi</p>
<h3 id="图片体积优化"><a href="#图片体积优化" class="headerlink" title="图片体积优化"></a>图片体积优化</h3><p>跟图片存储格式无关。跟采用 ARGB_8888 或者 RGB_565<br>根据需要的尺寸<br>采样<br>使用矩阵变换来放大图片<br>不透明采用  RGB_565<br>.9 图片<br>使用VectorDrawable</p>
</details>

<h2 id="9-1、Android-p-规避访问私有api的限制"><a href="#9-1、Android-p-规避访问私有api的限制" class="headerlink" title="9-1、Android p 规避访问私有api的限制"></a>9-1、Android p 规避访问私有api的限制</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>访问私有api，我们使用的是 反射 方式</p>
<p>反射时 setAccessible(true)  ,只是绕过语言层面，并不会更改它的 final 或者 private 属性，不会说把private 改成public。</p>
<p>Android p中设置了 API 名单，有白名单、黑名单之类的，私有api在黑名单中，通过限制反射来限制访问 私有api</p>
</details>

<h2 id="9-2、换肤的原理"><a href="#9-2、换肤的原理" class="headerlink" title="9-2、换肤的原理"></a>9-2、换肤的原理</h2><p>略</p>
<h2 id="9-3、virtualApk-插件化原理"><a href="#9-3、virtualApk-插件化原理" class="headerlink" title="9-3、virtualApk 插件化原理"></a>9-3、virtualApk 插件化原理</h2><p>略</p>
<h2 id="Tinker-怎么实现热修复"><a href="#Tinker-怎么实现热修复" class="headerlink" title="Tinker 怎么实现热修复"></a>Tinker 怎么实现热修复</h2><p>略</p>
<h2 id="10-1、如何开展优化工作"><a href="#10-1、如何开展优化工作" class="headerlink" title="10-1、如何开展优化工作"></a>10-1、如何开展优化工作</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>对整个目标是否有清晰认识</p>
<p>重点问题拆解</p>
<p>优化前期花 20% 的时间就能解决80%问题，剩下的 20%优化很难</p>
<p>对比业内(tester 测试其他app的打开页面方式)</p>
<p>指标监控，前后对比</p>
</details>

<h2 id="10-x"><a href="#10-x" class="headerlink" title="10-x"></a>10-x</h2><p>都略</p>
<h2 id="11-1、如何设计一个系统"><a href="#11-1、如何设计一个系统" class="headerlink" title="11-1、如何设计一个系统"></a>11-1、如何设计一个系统</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>保持和面试官沟通，多确认</p>
<p>需求-&gt; 关键流程 -&gt; 细节，明确边界</p>
<p>细节和边界的通常问题：</p>
<p>如何处理并发，是否有频繁io<br>网络怎么接入-短连接、长连接、连接池化，是否频繁与服务端交互(项目中的大接口)、是否有推送啊<br>保障安全性-数据是否需要加密、加密算法、</p>
</details>

<h2 id="11-2、插件化"><a href="#11-2、插件化" class="headerlink" title="11-2、插件化"></a>11-2、插件化</h2><p>略</p>
<h2 id="11-3、设计一个短视频app"><a href="#11-3、设计一个短视频app" class="headerlink" title="11-3、设计一个短视频app"></a>11-3、设计一个短视频app</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>视频如何处理？<br>视频来源？自有还是第三方？<br>视频由用户上传还是专业供应平台<br>是否需要建立用户关系链<br>支持分享？<br>支付系统打赏啊？<br>社交。聊天<br>播放器比较耗电<br>视频防止对手获取<br>防止广告被劫持</p>
</details>

<h2 id="11-4、设计一个网络框架"><a href="#11-4、设计一个网络框架" class="headerlink" title="11-4、设计一个网络框架"></a>11-4、设计一个网络框架</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>不局限于http，还可以 websococket</p>
<p>单向请求还是双向请求啊？</p>
<p>支持异步请求？使用Rxjava 还是kotlin 协程？</p>
<p>要考虑可移植性啊？</p>
<p>缓存策略，多大啊？如何淘汰？ </p>
<p>全局数据拦截器，对所有请求ip替换啊，对公共结果处理啊</p>
<p>日志输出，json，pb 转换为可视化</p>
<p>重试机制，3s、6s 之后再重试，最多重复多少次，防止死循环</p>
<p>参数组装，bean？hashMap，或者类似Retrofit 使用注解配置</p>
<p>协议体可以使用 Builder 模式</p>
<p>数据传输与拦截使用责任链模式</p>
<p>数据序列化</p>
<p>DNS 增强-httpDnsServer ，比如google的，还有aliyun 和腾讯云有，可以默认支持几个</p>
</details>]]></content>
      <categories>
        <category>上课笔记</category>
      </categories>
      <tags>
        <tag>高级进阶课</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-算法-LeetCode-多线程</title>
    <url>/2020/04/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="1114、按序打印：类中的3个方法分别运行在3个线程中，如何保证它们按顺序执行？"><a href="#1114、按序打印：类中的3个方法分别运行在3个线程中，如何保证它们按顺序执行？" class="headerlink" title="1114、按序打印：类中的3个方法分别运行在3个线程中，如何保证它们按顺序执行？"></a>1114、按序打印：类中的3个方法分别运行在3个线程中，如何保证它们按顺序执行？</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>没找到方便记忆的版本，自己写个。当然，链接中通过 AtomInteger 来实现自旋也是不错的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test1"</span>);</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (a != <span class="number">1</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"test2"</span>);</span><br><span class="line">        a= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (a != <span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"test3 \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自己写的时候的问题：<strong>看懂题目，volatile 关键字使用即可</strong></p>
</details><a id="more"></a>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/print-in-order/solution/an-xu-da-yin-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="1195、-交替打印字符串"><a href="#1195、-交替打印字符串" class="headerlink" title="1195、 交替打印字符串"></a>1195、 交替打印字符串</h3><p>编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：</p>
<ul>
<li>如果这个数字可以被 3 整除，输出 “fizz”。</li>
<li>如果这个数字可以被 5 整除，输出 “buzz”。</li>
<li>如果这个数字可以同时被 3 和 5 整除，输出 “fizzbuzz”。</li>
</ul>
<p>假设有这么一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; ... &#125;               <span class="comment">// constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(printFizz)</span> </span>&#123; ... &#125;          <span class="comment">// only output "fizz"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(printBuzz)</span> </span>&#123; ... &#125;          <span class="comment">// only output "buzz"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(printFizzBuzz)</span> </span>&#123; ... &#125;  <span class="comment">// only output "fizzbuzz"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(printNumber)</span> </span>&#123; ... &#125;      <span class="comment">// only output the numbers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>看参考答案吧</p>
<p>自己写的时候的问题：<strong>使用Semaphore 关键字会简单很多，使用volatile 关键字稍稍麻烦些。</strong></p>
</details>

<p>这个问题也可以关联到后续的 <a href="https://leetcode-cn.com/problems/print-zero-even-odd/" target="_blank" rel="noopener">打印零与奇偶数</a></p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/fizz-buzz-multithreaded/solution/1ge-reentrantlock-1ge-condition-1ge-volatilebian-l/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="1115、-交替打印FooBar"><a href="#1115、-交替打印FooBar" class="headerlink" title="1115、 交替打印FooBar"></a>1115、 交替打印FooBar</h3><p>我们提供一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">"foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">"bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。请设计修改程序，以确保 “foobar” 被输出 n 次。</p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>注意在空闲的时候Thread.yield()</p>
<p>自己写的时候的问题：<strong>可以使用 volatile 关键字，不过在 while 自旋过程中，需要 Thread.yield(); 让出cpu，否则容易出现超时。</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/print-foobar-alternately/solution/wu-suo-qie-zui-jian-dan-zui-rong-yi-li-jie-de-shi-/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="1226、-哲学家进餐"><a href="#1226、-哲学家进餐" class="headerlink" title="1226、 哲学家进餐"></a>1226、 哲学家进餐</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>这个问题还没想通，后续再看</p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/the-dining-philosophers/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="H2O-生成"><a href="#H2O-生成" class="headerlink" title="H2O 生成"></a>H2O 生成</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>使用 Semaphore简单粗暴。这个问题还没想通，后续再看</p>
<p>自己写的时候的问题：<strong>看别人的再自己写的，h的Semaphore(2),而 o 的 Semaphore(0) ，但是生成h 一个 就release一个 o (虽然o的permit 数量为 0 ，但是在另一个线程release 一个就相当于create 一个，所以并不矛盾，同理，在生成 o 的时候， o.acquire(2))</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/building-h2o/solution/yong-xin-hao-liang-jian-dan-cu-bao-by-hua-shang-1/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-算法-LeetCode-题库简单题</title>
    <url>/2020/04/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-LeetCode-%E9%A2%98%E5%BA%93%E7%AE%80%E5%8D%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="注：-以下题目都是根据-LeetCode-App上的顺序，按照由易到难排列-与其他列表有重复的题目就略过了"><a href="#注：-以下题目都是根据-LeetCode-App上的顺序，按照由易到难排列-与其他列表有重复的题目就略过了" class="headerlink" title="注： 以下题目都是根据 LeetCode App上的顺序，按照由易到难排列(与其他列表有重复的题目就略过了)"></a>注： 以下题目都是根据 LeetCode App上的顺序，按照由易到难排列(与其他列表有重复的题目就略过了)</h2><h2 id="704、二分查找，给定一个-n-个元素有序的（升序）整型数组-nums-和一个目标值-target-，写一个函数搜索-nums-中的-target，如果目标值存在返回下标，否则返回-1"><a href="#704、二分查找，给定一个-n-个元素有序的（升序）整型数组-nums-和一个目标值-target-，写一个函数搜索-nums-中的-target，如果目标值存在返回下标，否则返回-1" class="headerlink" title="704、二分查找，给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1"></a>704、二分查找，给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>这题目自己写得还不错</p>
<p>自己写的时候的问题：<strong>无</strong></p>
</details><a id="more"></a>

<blockquote>
<p>参考链接：<a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h2 id="最小k个数"><a href="#最小k个数" class="headerlink" title="最小k个数"></a>最小k个数</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>使用 PriorityQueue 代替自己建堆</p>
<p>自己写的时候的问题：<strong>Comparator 单词没写对，还有 Comparator 应该是个泛型，后面要接上<integer></integer></strong></p>
</details>

<blockquote>
<p>参考链接<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<ol start="104">
<li>二叉树的最大深度</li>
</ol>
<p>参考别人的思想</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p>
</blockquote>
<ol start="110">
<li>平衡二叉树</li>
</ol>
<p>参考别人的思想</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/solution/balanced-binary-tree-di-gui-fang-fa-by-jin40789108/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/balanced-binary-tree/solution/balanced-binary-tree-di-gui-fang-fa-by-jin40789108/</a></p>
</blockquote>
<ol start="559">
<li>N叉树的最大深度</li>
</ol>
<p>依葫芦画瓢</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/</a></p>
</blockquote>
<ol start="111">
<li>二叉树的最小深度</li>
</ol>
<p>我去，审题啊，叶节点啊，[1,2]的时候，叶节点是2啊，1还不是叶节点。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/li-jie-zhe-dao-ti-de-jie-shu-tiao-jian-by-user7208/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/li-jie-zhe-dao-ti-de-jie-shu-tiao-jian-by-user7208/</a></p>
</blockquote>
<ol start="226">
<li>翻转二叉树</li>
</ol>
<p>我去，面试google的那个牛人都没能写出来，我写出来了，额。。其实不就是每个结点都在翻转么。估摸着是那个哥们紧张了吧。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree/</a></p>
</blockquote>
<ol start="101">
<li>对称二叉树</li>
</ol>
<p>右边比左边，左边比右边</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree/</a></p>
</blockquote>
<p>面试题 03.04. 化栈为队</p>
<p>别人的想法太巧妙了，pop 或者 peek 的时候，只要辅助栈的元素不空，就可以出去。为空就将原本栈的元素倒入到辅助栈再pop或者peek。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/solution/java-liang-ge-zhan-by-npe_tle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/solution/java-liang-ge-zhan-by-npe_tle/</a></p>
</blockquote>
<ol start="771">
<li>宝石与石头</li>
</ol>
<p>真心傻逼了，用 if(!set.add(charAt(i))) 去判断，应该只要 if(set.contains(charAt(i))) 即可。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jewels-and-stones/</a></p>
</blockquote>
<ol start="1281">
<li>整数的各位积和之差</li>
</ol>
<p>乘积的初始值应该为1啊，蛋疼，居然初始化为 0</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/</a></p>
</blockquote>
<ol start="1342">
<li>将数字变成 0 的操作次数</li>
</ol>
<p>while循环到num == 0 为止</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/</a></p>
</blockquote>
<ol start="1295">
<li>统计位数为偶数的数字</li>
</ol>
<p>转成字符串看length不就好了，还要想着去除，唉</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/</a></p>
</blockquote>
<ol start="1365">
<li>有多少小于当前数字的数字</li>
</ol>
<p>1、快排的条件有点忘了，最开始的判断条件 front &gt; tail，while循环中要有 nums[j] &gt;= pvoit 、num[i] &lt;= pvoit   ,一轮while 之后，要执行 nums[start] = nums[front];  nums[front] = pvoit;<br>2、对于数组，int[] nums = {1,4,8,50,2,44,2};可以执行 nums.clone()  能将数组复制一份</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/</a></p>
</blockquote>
<p>面试题 02.03. 删除中间节点</p>
<p>脑筋急转弯</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-middle-node-lcci/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-算法-LeetCode-精选TOP面试题</title>
    <url>/2020/03/15/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-LeetCode-%E7%B2%BE%E9%80%89TOP%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="注：-以下题目都是根据-LeetCode-App上的顺序，按照由易到难排列-与其他列表有重复的题目就略过了"><a href="#注：-以下题目都是根据-LeetCode-App上的顺序，按照由易到难排列-与其他列表有重复的题目就略过了" class="headerlink" title="注： 以下题目都是根据 LeetCode App上的顺序，按照由易到难排列(与其他列表有重复的题目就略过了)"></a>注： 以下题目都是根据 LeetCode App上的顺序，按照由易到难排列(与其他列表有重复的题目就略过了)</h2><h3 id="350、两个数组的交集II"><a href="#350、两个数组的交集II" class="headerlink" title="350、两个数组的交集II"></a>350、两个数组的交集II</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ol>
<li>hashmap 记录第一个数组每个元素出现次数，再遍历第二个数组    2. 先给两个数组排序，再遍历**</li>
</ol>
<p>自己写的时候的问题：<strong>Integer 写错、HashMap&lt;Integer,Integer&gt; 在 int times = get(key) 的时候，要注意判空</strong></p>
</details><a id="more"></a>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="412、Fizz-Buzz，写一个程序，输出从-1-到-n-数字的字符串表示。1-如果-n-是3的倍数，输出“Fizz”；2-如果-n-是5的倍数，输出“Buzz”；3-如果-n-同时是3和5的倍数，输出-“FizzBuzz”。"><a href="#412、Fizz-Buzz，写一个程序，输出从-1-到-n-数字的字符串表示。1-如果-n-是3的倍数，输出“Fizz”；2-如果-n-是5的倍数，输出“Buzz”；3-如果-n-同时是3和5的倍数，输出-“FizzBuzz”。" class="headerlink" title="412、Fizz Buzz，写一个程序，输出从 1 到 n 数字的字符串表示。1. 如果 n 是3的倍数，输出“Fizz”；2. 如果 n 是5的倍数，输出“Buzz”；3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。"></a>412、Fizz Buzz，写一个程序，输出从 1 到 n 数字的字符串表示。1. 如果 n 是3的倍数，输出“Fizz”；2. 如果 n 是5的倍数，输出“Buzz”；3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>计算 n%3==0 及 n%5==0 的 boolean 值。之后分别输出</p>
<p>自己写的时候的问题：<strong>canDivid3 的时候，应该使用遍历的下标i ，而不是传入的参数n %3 == 0</strong></p>
</details>

<blockquote>
<p> <a href="https://leetcode-cn.com/problems/fizz-buzz/solution/fizz-buzz-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="13、-罗马数字转整数"><a href="#13、-罗马数字转整数" class="headerlink" title="13、 罗马数字转整数"></a>13、 罗马数字转整数</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>前一个数比后一个数小</p>
<p>自己写的时候的问题：<strong>map写成了 HashMap&lt;String,Integer&gt; ，应该是 HashMap&lt;Character,Integer&gt;，还有，throw 抛出异常的时候，应该要有new关键字，即 throw new IllegalArgumentException(“error input!”);</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/roman-to-integer/solution/yong-shi-9993nei-cun-9873jian-dan-jie-fa-by-donesp/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="387、字符串中的第一个唯一字符，给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回-1"><a href="#387、字符串中的第一个唯一字符，给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回-1" class="headerlink" title="387、字符串中的第一个唯一字符，给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1"></a>387、字符串中的第一个唯一字符，给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>第一次遍历，次数存放在HashMap中，第二次遍历，找到第一个不重复的。</p>
<p>自己写的时候的问题：<strong>无</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/solution/zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-fu-by-leet/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="28、实现-strStr-，给定一个-haystack-字符串和一个-needle-字符串，在-haystack-字符串中找出-needle-字符串出现的第一个位置-从0开始-。如果不存在，则返回-1。"><a href="#28、实现-strStr-，给定一个-haystack-字符串和一个-needle-字符串，在-haystack-字符串中找出-needle-字符串出现的第一个位置-从0开始-。如果不存在，则返回-1。" class="headerlink" title="28、实现 strStr()，给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。"></a>28、实现 strStr()，给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</h3><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: haystack = <span class="string">"hello"</span>, needle = <span class="string">"ll"</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>只有第一个字符匹配上才需要比较</p>
<p>自己写的时候的问题：<strong>haystack = “” 且 needle = “” 时，我返回了 -1，应该是  0，还有计算String的长度应该是 str.length() ,而不是 str.leng ,不过数组倒是可以这样做 arr.length</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="38、外观数列"><a href="#38、外观数列" class="headerlink" title="38、外观数列"></a>38、外观数列</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>读懂题目很重要，递归</p>
<p>自己写的时候的问题：<strong>throw 要 new ！</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/count-and-say/solution/di-gui-by-zhaowenhai/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="69、x的平方根，计算并返回-x-的平方根，其中-x-是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去，如8的平方根是-2-28…，则结果取2即可"><a href="#69、x的平方根，计算并返回-x-的平方根，其中-x-是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去，如8的平方根是-2-28…，则结果取2即可" class="headerlink" title="69、x的平方根，计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去，如8的平方根是 2.28…，则结果取2即可"></a>69、x的平方根，计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去，如8的平方根是 2.28…，则结果取2即可</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>我自己的写法，没有考虑数字越界：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"error input!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span> || x == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i * i &lt;= x; i++)&#123;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">        result = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他数字都对，但是如果输入 2147395600 ，则在 i= 46340 时，i就已经是结果了，但是这里的循环条件还是会继续执行，这时候 i= 46341 时，就超出 int 的取值范围越界了，因此不对。<strong>如果非要用这种方法去实现，可以在 for 语句里面加个条件： i * i &gt; 0 。因为Java 中的int型数据是有符号数，最高位表示符号，越界的时候，最高位变成1了，也就是变成负数，所以这个条件在刚发生越界的时候就不满足了，就能得到正确的结果</strong>。</p>
<p>使用二分查找法要注意几点：首先 (a/2)² &gt; a ，则可以解出来正整数解是 a &gt; 4，即在 a &gt; 4的情况下 a/2 &gt; 根号a 是必然的，再综合 1,2,3,4 这几个特殊数字，我们可以得出，a开根号的值在 [1,a/2] 这种闭合区间。还有，<strong>开根号这里可能会有小数，但是我们只要返回正数，所以可以要求 front == tail ，最后是返回tail的值，要注意</strong>。</p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="371、两整数之和，不使用运算符-和-，计算两个整数-a、b之和"><a href="#371、两整数之和，不使用运算符-和-，计算两个整数-a、b之和" class="headerlink" title="371、两整数之和，不使用运算符 + 和 -，计算两个整数 a、b之和"></a>371、两整数之和，不使用运算符 + 和 -，计算两个整数 a、b之和</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>异或求出普通位相加，与操作求出进位</p>
<p>自己写的时候的问题：<strong>a 要暂存 无进位结果，我写的时候忘了暂存了。因为无进位结果 + 进位 还有可能产生进位，所以要有 while 循环。</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/sum-of-two-integers/solution/wei-yun-suan-xiang-jie-yi-ji-zai-python-zhong-xu-y/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="283、移动零，给定一个数组-nums，编写一个函数将所有-0-移动到数组的末尾，同时保持非零元素的相对顺序"><a href="#283、移动零，给定一个数组-nums，编写一个函数将所有-0-移动到数组的末尾，同时保持非零元素的相对顺序" class="headerlink" title="283、移动零，给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序"></a>283、移动零，给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>2个指针，1次遍历</p>
<p>自己写的时候的问题：<strong>无</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="1、两数之和，给定一个整数数组-nums-和一个目标值-target，请你在该数组中找出和为目标值的那-两个-整数，并返回他们的数组下标。"><a href="#1、两数之和，给定一个整数数组-nums-和一个目标值-target，请你在该数组中找出和为目标值的那-两个-整数，并返回他们的数组下标。" class="headerlink" title="1、两数之和，给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。"></a>1、两数之和，给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>使用 HashMap 辅助</p>
<p>自己写的时候的问题：<strong>无</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/two-sum/solution/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="101、对称二叉树-给定一个二叉树，检查它是否是镜像对称的"><a href="#101、对称二叉树-给定一个二叉树，检查它是否是镜像对称的" class="headerlink" title="101、对称二叉树,给定一个二叉树，检查它是否是镜像对称的"></a>101、对称二叉树,给定一个二叉树，检查它是否是镜像对称的</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>递归判断</p>
<p>自己写的时候的问题：<strong>要懂递归啊，这是乱写成功的。不会递归时，把条件列出来，估计就有思路了。</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/symmetric-tree/solution/hua-jie-suan-fa-101-dui-cheng-er-cha-shu-by-guanpe/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="108-还未写-、将有序数组转换为二叉搜索树，将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树"><a href="#108-还未写-、将有序数组转换为二叉搜索树，将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树" class="headerlink" title="108(还未写)、将有序数组转换为二叉搜索树，将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树"></a><font color="#ff0000">108(还未写)、</font>将有序数组转换为二叉搜索树，将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>二叉树遍历</p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-15/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="118、杨辉三角，给定一个非负整数numRows，生成杨辉三角的前numRows行"><a href="#118、杨辉三角，给定一个非负整数numRows，生成杨辉三角的前numRows行" class="headerlink" title="118、杨辉三角，给定一个非负整数numRows，生成杨辉三角的前numRows行"></a>118、杨辉三角，给定一个非负整数numRows，生成杨辉三角的前numRows行</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>按照描述的方法，暴力解就好</p>
<p>自己写的时候的问题：<strong>自己想的 for语句，依次生成前面的行</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/pascals-triangle/solution/yang-hui-san-jiao-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="125、验证回文串，给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。"><a href="#125、验证回文串，给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。" class="headerlink" title="125、验证回文串，给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。"></a>125、验证回文串，给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>自己写的时候的问题：<strong>自己写的感受还是使用双指针，效率高，转小写，然后去掉无关的符号这种操作效率太低。注意Character的方法 toLowerCase()、 isDigit() 和 isLetter() 就可以了</strong>。</p>
</details>

<blockquote>
<p>[LeetCode](<a href="https://leetcode-cn.com/problems/valid-palindrome/solution/java-da-dao-zhi-jian-6xing-by-rabbitzhao/）" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome/solution/java-da-dao-zhi-jian-6xing-by-rabbitzhao/）</a></p>
</blockquote>
<h3 id="268、缺失数字，给定一个包含-0-1-2-…-n-中-n-个数的序列，找出-0-n-中没有出现在序列中的那个数。"><a href="#268、缺失数字，给定一个包含-0-1-2-…-n-中-n-个数的序列，找出-0-n-中没有出现在序列中的那个数。" class="headerlink" title="268、缺失数字，给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。"></a>268、缺失数字，给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ol>
<li>数组中所有数字异或，结果再与 0<del>n 异或，得到的结果就是缺失的那个数字(因为相同的数字异或结果为0)    2. 0</del>n 这些数字的和-数组所有数字的和 = 缺失的数字</li>
</ol>
<p>自己写的时候的问题：<strong>自己写的时候，感觉使用 异或 操作简单方便</strong>。</p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/missing-number/solution/que-shi-shu-zi-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="171、Excel-表序列号，给定一个Excel表格中的列名称，返回其相应的列序号。如：A-gt-1，B-gt-2，Z-gt-26，AA-gt-27，AB-gt-28"><a href="#171、Excel-表序列号，给定一个Excel表格中的列名称，返回其相应的列序号。如：A-gt-1，B-gt-2，Z-gt-26，AA-gt-27，AB-gt-28" class="headerlink" title="171、Excel 表序列号，给定一个Excel表格中的列名称，返回其相应的列序号。如：A -&gt; 1，B -&gt; 2，Z -&gt; 26，AA -&gt; 27，AB -&gt; 28"></a>171、Excel 表序列号，给定一个Excel表格中的列名称，返回其相应的列序号。如：A -&gt; 1，B -&gt; 2，Z -&gt; 26，AA -&gt; 27，AB -&gt; 28</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>我们常用的 10 进制数字，0~9 共 10 个数字。题目A-Z，26个字母，所以是26进制，故，AB= 26 + 2 = 28**</p>
<p>自己写的时候的问题：<strong>看做26进制的数字，从字符串尾部开始遍历，计算每个char所在位的 base ，要注意输入小写字母，所以要统一转为小写去比较</strong>。</p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/solution/hua-jie-suan-fa-171-excelbiao-lie-xu-hao-by-guanpe/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="172、-阶乘后的零，给定一个整数-n，返回-n-结果尾数中零的数量，你算法的时间复杂度应为-O-log-n"><a href="#172、-阶乘后的零，给定一个整数-n，返回-n-结果尾数中零的数量，你算法的时间复杂度应为-O-log-n" class="headerlink" title="172、 阶乘后的零，给定一个整数 n，返回 n! 结果尾数中零的数量，你算法的时间复杂度应为 O(log n)"></a>172、 阶乘后的零，给定一个整数 n，返回 n! 结果尾数中零的数量，你算法的时间复杂度应为 O(log n)</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>可以转换为n的质因数中5的个数</p>
<p>自己写的时候的问题：*<em>自己写的时候，使用for循环(从 5 到 n，每次进5) 的方式来计算5的个数，结果超时，虽然放在 IntelliJ 中运行结果是对的。因此，应该使用更高效的方式， n /= 5; result += n; *</em>。</p>
</details>

<blockquote>
<p>[LeetCode](<a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-3/）" target="_blank" rel="noopener">https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-3/）</a></p>
</blockquote>
<h3 id="189、旋转数组，给定一个数组，将数组中的元素向右移动-k-个位置，其中-k-是非负数。"><a href="#189、旋转数组，给定一个数组，将数组中的元素向右移动-k-个位置，其中-k-是非负数。" class="headerlink" title="189、旋转数组，给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。"></a>189、旋转数组，给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先能想到的是：新建一个数组，然后将原数组中的数字按照旋转后的顺序放到新数组  ，其次就是：首先将整个数组旋转，再分别旋转前面部分和后面部分</p>
<p>自己写的时候的问题：<strong>写了3次，旋转3次是没问题，关键是处理好 k &gt; nums.length 的情况。</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="190、-还未写-颠倒二进制位-颠倒给定的-32-位无符号整数的二进制位。"><a href="#190、-还未写-颠倒二进制位-颠倒给定的-32-位无符号整数的二进制位。" class="headerlink" title="190、(还未写)颠倒二进制位,颠倒给定的 32 位无符号整数的二进制位。"></a>190、<font color="#ff0000">(还未写)</font>颠倒二进制位,颠倒给定的 32 位无符号整数的二进制位。</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary><summary>

<p>每次取1位反转</p>
</summary></details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/reverse-bits/solution/yi-dong-zui-hou-yi-wei-dao-di-yi-wei-4-xing-dai-ma/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="191、位1的个数，编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为-‘1’-的个数"><a href="#191、位1的个数，编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为-‘1’-的个数" class="headerlink" title="191、位1的个数，编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数"></a>191、位1的个数，编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>n&amp;(n-1) 或者 一直往右移</p>
<p>自己写的时候的问题：<strong>无符号数有点难，还么有完全理解。while 条件写成 n &gt; 0 ，应该要写成  n != 0。</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/number-of-1-bits/solution/wei-1de-ge-shu-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="198、打家劫舍-小偷计划偷窃沿街的房屋。每间房内都藏有一定的现金，但如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额"><a href="#198、打家劫舍-小偷计划偷窃沿街的房屋。每间房内都藏有一定的现金，但如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额" class="headerlink" title="198、打家劫舍,小偷计划偷窃沿街的房屋。每间房内都藏有一定的现金，但如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额"></a>198、打家劫舍,小偷计划偷窃沿街的房屋。每间房内都藏有一定的现金，但如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>奇偶，然后选较大</p>
<p>自己写的时候的问题：<strong>求偶数和的时候，先计算当前偶数和，再与奇数和比较，计算当前偶数和的最终值</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-ikaruga/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="202、快乐数，判断一个数是不是快乐数。一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为-1，也可能是无限循环但始终变不到-1。如果可以变为-1，那么这个数就是快乐数。"><a href="#202、快乐数，判断一个数是不是快乐数。一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为-1，也可能是无限循环但始终变不到-1。如果可以变为-1，那么这个数就是快乐数。" class="headerlink" title="202、快乐数，判断一个数是不是快乐数。一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。"></a>202、快乐数，判断一个数是不是快乐数。一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>快慢指针用来终止无限循环</p>
<p>自己写的时候的问题：<strong>主要是要细心，自己写的时候写成 result = temp * temp ,应该是 result += temp * temp</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/happy-number/solution/shi-yong-kuai-man-zhi-zhen-si-xiang-zhao-chu-xun-h/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="204、计数质数，统计所有小于非负整数-n-的质数的数量。（质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。）"><a href="#204、计数质数，统计所有小于非负整数-n-的质数的数量。（质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。）" class="headerlink" title="204、计数质数，统计所有小于非负整数 n 的质数的数量。（质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。）"></a>204、计数质数，统计所有小于非负整数 n 的质数的数量。（质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。）</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>质数的判断：for (int i = 2; i * i &lt;= n; i++)</p>
<p>自己写的时候的问题：<strong>最优解暂时有点难理解，还是先只要注意 i * i &lt;= n 这样的优化方式吧</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/count-primes/solution/ru-he-gao-xiao-pan-ding-shai-xuan-su-shu-by-labula/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="234、回文链表，判断链表是否是回文链表"><a href="#234、回文链表，判断链表是否是回文链表" class="headerlink" title="234、回文链表，判断链表是否是回文链表"></a>234、回文链表，判断链表是否是回文链表</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>1、反转链表，对比反转后和原链表是否相同  2、链表值复制到数组中，再采用前后双指针</p>
<p>自己写的时候的问题：<strong>写得很完美，第一步，快慢指针找到中间节点  第二步、反转中间节点之后的部分 第三步、对比前半部分和反转后的后半部分</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="326、3的幂，给定一个整数，写一个函数来判断它是否是-3-的幂次方。"><a href="#326、3的幂，给定一个整数，写一个函数来判断它是否是-3-的幂次方。" class="headerlink" title="326、3的幂，给定一个整数，写一个函数来判断它是否是 3 的幂次方。"></a>326、3的幂，给定一个整数，写一个函数来判断它是否是 3 的幂次方。</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>1、不断求余，不断除以3，看结果  2、转换成3进制，看是不是前面1个1，后面全是0</p>
<p>自己写的时候的问题：<strong>老老实实一直除以 3 ，但是，要注意数字 0 ，否则 n % 3 == 0 会进入死循环</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/power-of-three/solution/3de-mi-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="242、有效的字母异位词，给定两个字符串-s-和-t-，编写一个函数来判断-t-是否是-s-的字母异位词。"><a href="#242、有效的字母异位词，给定两个字符串-s-和-t-，编写一个函数来判断-t-是否是-s-的字母异位词。" class="headerlink" title="242、有效的字母异位词，给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。"></a>242、有效的字母异位词，给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>大小26的数组，两个字符串遍历每个字符，s遍历就在相应下标+1，而遍历t时在相应下标-1</p>
<p>自己写的时候的问题：<strong>只有小写字母，所以用数组实现了，不难</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/valid-anagram/solution/you-xiao-de-zi-mu-yi-wei-ci-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-算法-LeetCode-腾讯精选练习50题</title>
    <url>/2020/03/08/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-LeetCode-%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%89%E7%BB%83%E4%B9%A050%E9%A2%98/</url>
    <content><![CDATA[<h2 id="注：-以下题目都是根据-LeetCode-App上的顺序，按照由易到难排列"><a href="#注：-以下题目都是根据-LeetCode-App上的顺序，按照由易到难排列" class="headerlink" title="注： 以下题目都是根据 LeetCode App上的顺序，按照由易到难排列"></a>注： 以下题目都是根据 LeetCode App上的顺序，按照由易到难排列</h2><h3 id="237、删除链表中的节点"><a href="#237、删除链表中的节点" class="headerlink" title="237、删除链表中的节点"></a>237、删除链表中的节点</h3><p>编写一个函数，使其可以删除某个链表中给定的(非末尾)节点，函数将只会传给你要被删除的节点(坑在这里，注意：<strong>传给你的不是head节点和要删除的值，而是直接传给你要删除的那个节点</strong>)。</p><details>
<summary>点击看答案</summary><summary>

<p>仅仅只是删除而已，简直是脑筋急转弯，被坑进去了</p>
<p>自己写的时候的问题：<strong>没啥，主要是审题</strong></p>
</summary></details><a id="more"></a>


<blockquote>
<p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/solution/shan-chu-lian-biao-zhong-de-jie-dian-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="344、反转字符串"><a href="#344、反转字符串" class="headerlink" title="344、反转字符串"></a>344、反转字符串</h3><details>
<summary>点击看答案</summary><summary> 

<p>首尾双指针</p>
<p>自己写的时候的问题：<strong>尴尬，忘了 i++,j– 了</strong></p>
</summary></details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/reverse-string/solution/fan-zhuan-zi-fu-chuan-by-leetcode" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="7、整数反转"><a href="#7、整数反转" class="headerlink" title="7、整数反转"></a>7、整数反转</h3><details>
<summary>点击看答案</summary><summary>

<p>每次反转一个数字，注意防止溢出(可以考虑result使用long类型)</p>
<p>自己写的时候的问题：<strong>要注意负数的最小值，和整数最大值一样处理</strong></p>
</summary></details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/reverse-integer/solution/hua-jie-suan-fa-7-zheng-shu-fan-zhuan-by-guanpengc/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="9、回文数，判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。你能不将整数转为字符串来解决这个问题吗？"><a href="#9、回文数，判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。你能不将整数转为字符串来解决这个问题吗？" class="headerlink" title="9、回文数，判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。你能不将整数转为字符串来解决这个问题吗？"></a>9、回文数，判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。你能不将整数转为字符串来解决这个问题吗？</h3><details>
<summary>点击看答案</summary><summary>反转后一半数字

<p>自己写的时候的问题：*<em>通过不断除以10，搞清楚这个值到底是什么数量级，比如99，那 div 就是10级，比如 999，那 div 就是 100级，然后通过 n/div 就能得到第一位， n%10，得到最后一位，比较他们的值。依次往复 *</em></p>
</summary></details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/palindrome-number/solution/dong-hua-hui-wen-shu-de-san-chong-jie-fa-fa-jie-ch/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="14、-还未做-最长公共前缀"><a href="#14、-还未做-最长公共前缀" class="headerlink" title="14、(还未做)最长公共前缀"></a>14、<font color="#ff0000">(还未做)</font>最长公共前缀</h3><details>
<summary>点击看答案</summary><summary>

<p>直接看链接，这个不大会</p>
</summary></details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/hua-jie-suan-fa-14-zui-chang-gong-gong-qian-zhui-b/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="88、合并两个有序数组nums1和nums2，将nums2合并到nums1中，使nums1成为一个有序数组-假设nums有足够空间-。"><a href="#88、合并两个有序数组nums1和nums2，将nums2合并到nums1中，使nums1成为一个有序数组-假设nums有足够空间-。" class="headerlink" title="88、合并两个有序数组nums1和nums2，将nums2合并到nums1中，使nums1成为一个有序数组(假设nums有足够空间)。"></a>88、合并两个有序数组nums1和nums2，将nums2合并到nums1中，使nums1成为一个有序数组(假设nums有足够空间)。</h3><details>
<summary>点击看答案</summary><summary>

<p>从后往前，注意 nums1 中剩余的元素</p>
<p>自己写的时候的问题：<strong>没问题，从尾到头合并即可</strong></p>
</summary></details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="20、有效的括号：给定一个只包括-‘-‘，’-’，’-‘，’-’，’-‘，’-’-的字符串，判断字符串是否有效-即括号的开闭符合规则-。"><a href="#20、有效的括号：给定一个只包括-‘-‘，’-’，’-‘，’-’，’-‘，’-’-的字符串，判断字符串是否有效-即括号的开闭符合规则-。" class="headerlink" title="20、有效的括号：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效(即括号的开闭符合规则)。"></a>20、有效的括号：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效(即括号的开闭符合规则)。</h3><details>
<summary>点击看答案</summary><summary>

<p>使用HashMap 建立映射关系，Stack 用于遍历</p>
<p>自己写的时候的问题：<strong>记住 Stack 的 isEmpty() 、pop 、push 方法即可</strong></p>
</summary></details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="21、合并两个有序链表，将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的-假设链表元素顺序由小到大"><a href="#21、合并两个有序链表，将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的-假设链表元素顺序由小到大" class="headerlink" title="21、合并两个有序链表，将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的(假设链表元素顺序由小到大)"></a>21、合并两个有序链表，将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的(假设链表元素顺序由小到大)</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>双指针，注意其中一个链表到表尾时，另一个链表整个接上去</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/hua-jie-suan-fa-21-he-bing-liang-ge-you-xu-lian-bi/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="292、Nim-游戏，桌上一堆石头，两人轮流拿1-3块石头，拿到最后一块石头的人获胜。现在给n块石头，你先拿，判定你是否能赢得游戏。你们是聪明人，每一步都是最优解。"><a href="#292、Nim-游戏，桌上一堆石头，两人轮流拿1-3块石头，拿到最后一块石头的人获胜。现在给n块石头，你先拿，判定你是否能赢得游戏。你们是聪明人，每一步都是最优解。" class="headerlink" title="292、Nim 游戏，桌上一堆石头，两人轮流拿1~3块石头，拿到最后一块石头的人获胜。现在给n块石头，你先拿，判定你是否能赢得游戏。你们是聪明人，每一步都是最优解。"></a>292、Nim 游戏，桌上一堆石头，两人轮流拿1~3块石头，拿到最后一块石头的人获胜。现在给n块石头，你先拿，判定你是否能赢得游戏。你们是聪明人，每一步都是最优解。</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>当 n%4 != 0 时，就可以赢</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/nim-game/solution/292nimyou-xi-by-redsnapper/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="26、删除排序数组中的重复项，你必须在-原地-修改输入数组-并在使用-O-1-额外空间的条件下完成。你不需要考虑数组中超出新长度后面的元素。"><a href="#26、删除排序数组中的重复项，你必须在-原地-修改输入数组-并在使用-O-1-额外空间的条件下完成。你不需要考虑数组中超出新长度后面的元素。" class="headerlink" title="26、删除排序数组中的重复项，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。你不需要考虑数组中超出新长度后面的元素。"></a>26、删除排序数组中的重复项，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。你不需要考虑数组中超出新长度后面的元素。</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>后一个元素与当前重复，则直到不重复的元素，移过来，覆盖重复元素。</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="53、最大子序和"><a href="#53、最大子序和" class="headerlink" title="53、最大子序和"></a>53、最大子序和</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>前面的和是否是正数，是正数就有增益</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/hua-jie-suan-fa-53-zui-da-zi-xu-he-by-guanpengchn/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="70、爬楼梯，需要爬n阶才能到楼顶，每次可以爬1阶或者2阶，有多少种方法爬到楼顶？"><a href="#70、爬楼梯，需要爬n阶才能到楼顶，每次可以爬1阶或者2阶，有多少种方法爬到楼顶？" class="headerlink" title="70、爬楼梯，需要爬n阶才能到楼顶，每次可以爬1阶或者2阶，有多少种方法爬到楼顶？"></a>70、爬楼梯，需要爬n阶才能到楼顶，每次可以爬1阶或者2阶，有多少种方法爬到楼顶？</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>斐波那契数列</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="104、二叉树的最大深度"><a href="#104、二叉树的最大深度" class="headerlink" title="104、二叉树的最大深度"></a>104、二叉树的最大深度</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>记住递归方法，好用的递归的方法</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="121、买卖股票的最佳时机，给定一个数组，它的第-i-个元素是一支给定股票第-i-天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。"><a href="#121、买卖股票的最佳时机，给定一个数组，它的第-i-个元素是一支给定股票第-i-天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。" class="headerlink" title="121、买卖股票的最佳时机，给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。"></a>121、买卖股票的最佳时机，给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>遍历，记录当前最小的值，以及之后相对应的最大利润</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="122、买卖股票的最佳时机-II，给定一个数组，它的第-i-个元素是一支给定股票第-i-天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票，注意你不能在买入股票前卖出股票）"><a href="#122、买卖股票的最佳时机-II，给定一个数组，它的第-i-个元素是一支给定股票第-i-天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票，注意你不能在买入股票前卖出股票）" class="headerlink" title="122、买卖股票的最佳时机 II，给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票，注意你不能在买入股票前卖出股票）"></a>122、买卖股票的最佳时机 II，给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票，注意你不能在买入股票前卖出股票）</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>简单的一次遍历,相邻依次减下去</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="136、只出现一次的数字，一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素"><a href="#136、只出现一次的数字，一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素" class="headerlink" title="136、只出现一次的数字，一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素"></a>136、只出现一次的数字，一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>所有元素异或</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/single-number/solution/xue-suan-fa-jie-guo-xiang-dui-yu-guo-cheng-bu-na-y/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="141、环形链表，给定一个链表，判断链表中是否有环"><a href="#141、环形链表，给定一个链表，判断链表中是否有环" class="headerlink" title="141、环形链表，给定一个链表，判断链表中是否有环"></a>141、环形链表，给定一个链表，判断链表中是否有环</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>快慢指针，并且快指针每次走两步，慢指针每次走一步</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="557、反转字符串中的单词-III"><a href="#557、反转字符串中的单词-III" class="headerlink" title="557、反转字符串中的单词 III"></a>557、反转字符串中的单词 III</h3><blockquote>
<p>输入: “Let’s take LeetCode contest”<br>输出: “s’teL ekat edoCteeL tsetnoc”       </p>
</blockquote>
<details>
<summary>点击看答案</summary>

<p><strong><summary>使用辅助栈</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/pei-pian-rang-wen-ti-bian-jian-dan-zhan-mo-ni-by-p/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="155、最小栈，设计一个支持push、pop、top操作，并且能在常数时间内检索到最小元素的栈"><a href="#155、最小栈，设计一个支持push、pop、top操作，并且能在常数时间内检索到最小元素的栈" class="headerlink" title="155、最小栈，设计一个支持push、pop、top操作，并且能在常数时间内检索到最小元素的栈"></a>155、最小栈，设计一个支持push、pop、top操作，并且能在常数时间内检索到最小元素的栈</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>两个栈，一个正常存放元素，一个不同步存放小元素</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/min-stack/solution/shi-yong-fu-zhu-zhan-tong-bu-he-bu-tong-bu-python-/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="160、相交链表，编写一个程序，找到两个单链表相交的起始节点"><a href="#160、相交链表，编写一个程序，找到两个单链表相交的起始节点" class="headerlink" title="160、相交链表，编写一个程序，找到两个单链表相交的起始节点"></a>160、相交链表，编写一个程序，找到两个单链表相交的起始节点</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>两个指针分别遍历两个链表，到尾结点后切换到另一个链表的头结点，两个指针相交的地方就是第一个相交的节点</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/tu-jie-xiang-jiao-lian-biao-by-user7208t/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="169、多数元素，给定一个大小为-n-的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于-⌊-n-2-⌋-的元素"><a href="#169、多数元素，给定一个大小为-n-的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于-⌊-n-2-⌋-的元素" class="headerlink" title="169、多数元素，给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素"></a>169、多数元素，给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>排序，中间那个元素就是</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="206、反转链表"><a href="#206、反转链表" class="headerlink" title="206、反转链表"></a>206、反转链表</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>pre节点和current 节点</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="217、存在重复元素，给定一个整数数组，判断是否存在重复元素。"><a href="#217、存在重复元素，给定一个整数数组，判断是否存在重复元素。" class="headerlink" title="217、存在重复元素，给定一个整数数组，判断是否存在重复元素。"></a>217、存在重复元素，给定一个整数数组，判断是否存在重复元素。</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>HashSet</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/contains-duplicate/solution/cun-zai-zhong-fu-yuan-su-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="231、2的幂，给定一个整数，编写一个函数来判断它是否是-2-的幂次方。"><a href="#231、2的幂，给定一个整数，编写一个函数来判断它是否是-2-的幂次方。" class="headerlink" title="231、2的幂，给定一个整数，编写一个函数来判断它是否是 2 的幂次方。"></a>231、2的幂，给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>二进制数据中只有1个1</summary></strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/power-of-two/solution/power-of-two-er-jin-zhi-ji-jian-by-jyd/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="二叉搜索树的最近公共祖先-给定一个二叉搜索树-找到该树中两个指定节点的最近公共祖先。"><a href="#二叉搜索树的最近公共祖先-给定一个二叉搜索树-找到该树中两个指定节点的最近公共祖先。" class="headerlink" title="二叉搜索树的最近公共祖先,给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。"></a>二叉搜索树的最近公共祖先,给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</h3><details>
<summary>点击看答案</summary>

<p><strong><summary>直接看链接</summary></strong></p>
</details>

<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian--2/" target="_blank" rel="noopener">LeetCode</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-算法-概念</title>
    <url>/2020/03/08/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="二叉查找树-也称二叉搜索树"><a href="#二叉查找树-也称二叉搜索树" class="headerlink" title="二叉查找树(也称二叉搜索树)"></a>二叉查找树(也称二叉搜索树)</h2><ul>
<li>左子树上的节点值都<strong>小于等于</strong>根节点的值    </li>
<li>右子树上的节点值都<strong>大于等于</strong>根节点的值    </li>
<li>左右子树也是二叉搜索树    </li>
</ul><p>它是基于二分查找的思想，<strong>查找最大的次数为二叉树高度</strong>     </p><h3 id="查找代价"><a href="#查找代价" class="headerlink" title="查找代价"></a>查找代价</h3><ul>
<li>当左右子树高度大致平衡时，时间复杂度在 O(logN)     </li>
<li>当先后插入的关键字<strong>有序</strong>时，退化成链表，查找的时间复杂度就在 O(N)了     </li>
</ul><a id="more"></a>


<h3 id="插入代价"><a href="#插入代价" class="headerlink" title="插入代价"></a>插入代价</h3><p>新节点插入到树的叶子节点上，因此，插入节点和查找一个不存在的数据的代价相同    </p>
<h3 id="删除代价"><a href="#删除代价" class="headerlink" title="删除代价"></a>删除代价</h3><ul>
<li>如果被删除的节点左、右 有一个为null时，代价仅为 O(1)      </li>
<li>如果左右子树都存在，时间复杂度最大也不会超过O(logN)      </li>
</ul>
<p>缺陷：</p>
<p>极端情况可能退化成链表，时间复杂度为  n。这主要是由于树不平衡导致的</p>
<h2 id="平衡二叉查找树-平衡二叉搜索树"><a href="#平衡二叉查找树-平衡二叉搜索树" class="headerlink" title="平衡二叉查找树(平衡二叉搜索树)"></a>平衡二叉查找树(平衡二叉搜索树)</h2><p>是严格的平衡二叉树，它是空树或者左右两个子树的高度差 <strong>小于等于1</strong>，同时，左右两个子树也是平衡二叉搜索树</p>
<h3 id="查找代价-1"><a href="#查找代价-1" class="headerlink" title="查找代价"></a>查找代价</h3><p>时间很稳定，查找效率最好最坏都是  O(logN)</p>
<h3 id="插入代价-1"><a href="#插入代价-1" class="headerlink" title="插入代价"></a>插入代价</h3><p>由于要保证严格的平衡，插入时可能要进行再平衡(最多旋转一次)，因此插入的整体代价还在 O(logN)</p>
<h3 id="删除代价-1"><a href="#删除代价-1" class="headerlink" title="删除代价"></a>删除代价</h3><p>和插入一样，要考虑再平衡，但是最多需要O(logN)次旋转，所以时间复杂度为  O(2logN)</p>
<h2 id="红黑树-Red-Black-Tree"><a href="#红黑树-Red-Black-Tree" class="headerlink" title="红黑树(Red-Black Tree)"></a>红黑树(Red-Black Tree)</h2><p>它并不严格地平衡，最长路径长度不超过最短路径长度的2倍。它删除和插入引起平衡性改变的概率要远低于平衡二叉搜索树</p>
<h3 id="查找代价-2"><a href="#查找代价-2" class="headerlink" title="查找代价"></a>查找代价</h3><p>查找代价基本上维持在 O(logN) 级别，最差情况下肯定比平衡二叉搜索树要差，因为没有那么平衡</p>
<h3 id="插入代价-2"><a href="#插入代价-2" class="headerlink" title="插入代价"></a>插入代价</h3><p>不容易引起失衡，整体代价和平衡二叉搜索树差不多，也是 O(logN) 级别(虽然涉及变色，但是变色的代价很小)</p>
<h3 id="删除代价-2"><a href="#删除代价-2" class="headerlink" title="删除代价"></a>删除代价</h3><p>相对平衡二叉搜索树，不容易引起失衡，时间复杂度也在 O(logN) 级别</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>平衡二叉搜索树由于插入和删除，会引起需要调整，可以通过 ：变色、左旋转、右旋转  三种方式调整。是否需要调整要根据红黑树的特性：</p>
<ul>
<li>节点是红色或黑色    </li>
<li>根节点是黑色    </li>
<li>叶子节点都是黑色的空节点    </li>
<li>红色节点的两个子节点都是黑的(红节点不能连续出现)    </li>
<li>任一点到每个叶子节点的路径包含相同数目的黑节点    </li>
</ul>
<blockquote>
<p>以上内容参考自<a href="https://zhuanlan.zhihu.com/p/54084335" target="_blank" rel="noopener">zhihu</a>、<a href="https://blog.csdn.net/z702143700/article/details/49079107" target="_blank" rel="noopener">csdn</a>、<a href="https://zhuanlan.zhihu.com/p/31805309" target="_blank" rel="noopener">知乎</a></p>
</blockquote>
<h2 id="B-树和B-树"><a href="#B-树和B-树" class="headerlink" title="B-树和B+ 树"></a>B-树和B+ 树</h2><p>我们所谓的B-树，其实并不是B减树，中间是横线，不是减号；B + 就是 B加树了</p>
<p>如 os 的文件目录存储、数据库中的索引结构的存储，不可能在内存中建立查找结构，必须在磁盘中建立好结构。</p>
<p>在磁盘组织结构下，从任何一个节点指向其他节点都可能读取一次磁盘，再将数据写入内存比较。这回带来大量的IO操作，所以我们需要新的数据结构，即 B树和B+树。</p>
<p>B树是一种<strong>多路平衡查找树</strong>，每个节点最多包含k个孩子，k称为B树的阶。K大小取决于<strong>磁盘页的大小</strong>。</p>
<h2 id="一些算法上的概念"><a href="#一些算法上的概念" class="headerlink" title="一些算法上的概念"></a>一些算法上的概念</h2><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>理解平衡二叉树后，就会更好理解后续的B树。</p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树是一棵二叉树，每个节点的左边节点小于当前节点的值，右边节点的值大于当前节点的值。</p>
<p>因为二叉树的遍历性能和树的层级成反比，层级h越小查询越快，为了保证树的结构左右两端数据大致平衡以降低二叉树高度，一般会采用算法机制实现节点的平衡，如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B3%E8%A1%A1.jpg" alt="平衡树的高度"></p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h4><p>当上述的平衡二叉树深度很深无法存储所有的节点数据时，需要读取磁盘。从而树的深度越大，需要的I/O操作次数越多，因此效率也越低，因此我们需要想办法降低树的高度。</p>
<p>B 树的思路和平衡二叉树一样，但是采用了多叉的方式降低了高度。</p>
<p>B树的具体实现比较难描述，看下面的参考链接更清晰，就不赘述。</p>
<blockquote>
<p>以上内容参考自： <a href="https://zhuanlan.zhihu.com/p/27700617" target="_blank" rel="noopener">勤劳的小手</a>、<a href="http://www.androidos.net.cn/book/android-road/data-structure/tree/b-tree.html" target="_blank" rel="noopener">B树概念</a></p>
</blockquote>
<h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><p>主要是利用KMP算法，这个很令人头大，这里贴出算法代码，如果需要详细了解，可以去查看<a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">July大神的这篇文章</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String str, String dest,<span class="keyword">int</span>[] next)</span></span>&#123;<span class="comment">//str文本串  dest 模式串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; str.charAt(i) != dest.charAt(j))&#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == dest.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == dest.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] kmpnext(String dest)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[dest.length()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>; i &lt; dest.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(j) != dest.charAt(i))&#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dest.charAt(i) == dest.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>next数组的计算主要跟模式串有关，与文本串并没有关系，因为，模式串前后公共最长子序列。这样才会让我们跳过大量的重复计算</p>
<h3 id="数字排列"><a href="#数字排列" class="headerlink" title="数字排列"></a>数字排列</h3><p>题目：用1，2，2，3，4，5 这6个数字，写一个方法，打印出所有不同的排列，如 512234、412235等，要求4不能再第三位，3与5不能相连。</p>
<blockquote>
<p>思路：问题可以归结为<strong>图的遍历</strong>，实际上6个数字就是6个结点，把6个结点连成无向连通图，对于每个结点求这个图形的遍历路径，所有结点的遍历路径就是最后对这6个数字的排列组合结果集。当然，这样获取的结果集未达到题目要求：<br>（1）3与5不能相连，这个可以在构造图的时候就满足条件；<br>（2）不能重复，有两个2，明显会存在重复结果，得最后去重（可以放在treeSet中）；<br>（3）4不能排在第三位，这个仍旧在结果集中排除即可。</p>
</blockquote>
<p>具体代码略。</p>
<h3 id="手写算法题。猫扑素数；1到n，求1的个数；单词反转。"><a href="#手写算法题。猫扑素数；1到n，求1的个数；单词反转。" class="headerlink" title="手写算法题。猫扑素数；1到n，求1的个数；单词反转。"></a>手写算法题。猫扑素数；1到n，求1的个数；单词反转。</h3><h3 id="算法：排序、二叉树遍历、红黑树了解。常见的数据结构主要有数组、链表、栈、队列、二叉堆、树、图等，红黑树和BL树的区别"><a href="#算法：排序、二叉树遍历、红黑树了解。常见的数据结构主要有数组、链表、栈、队列、二叉堆、树、图等，红黑树和BL树的区别" class="headerlink" title="算法：排序、二叉树遍历、红黑树了解。常见的数据结构主要有数组、链表、栈、队列、二叉堆、树、图等，红黑树和BL树的区别"></a>算法：排序、二叉树遍历、红黑树了解。常见的数据结构主要有数组、链表、栈、队列、二叉堆、树、图等，红黑树和BL树的区别</h3><h3 id="快速排序底层原理简单描述。"><a href="#快速排序底层原理简单描述。" class="headerlink" title="快速排序底层原理简单描述。"></a>快速排序底层原理简单描述。</h3>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Android获取debug包的cookies的db文件</title>
    <url>/2020/02/27/Android%E8%8E%B7%E5%8F%96debug%E5%8C%85%E7%9A%84cookies%E7%9A%84db%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在项目中，用户登录后，需要为白名单中的 host 注入特定的cookies，在用户退出登录的时候，需要将注入的 cookies 清除(只清除app自己注入的cookies，h5 注入的cookies不要清除)。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Android 的webview 并没有提供针对单个host 清除cookies的方法，只有全部清除，因此主要思路是将需要删除的cookies 设置为过期，再删除过期的即可，具体可以参考<a href="https://blog.csdn.net/turkeycock/article/details/53091103" target="_blank" rel="noopener">Android清除单个域名的cookie</a></p><a id="more"></a>

<p>当然，设置cookies过期有两种方法:</p>
<blockquote>
<p>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</p>
</blockquote>
<p>使用Cookie的: Expires 属性. 它可以设置cookie的过期时间. 下面的代码表示id这条cookie的过期时间是2015年10月21日早上7点28分;</p>
<blockquote>
<p>Set-Cookie: id=a3fWa; Max-Age=86400</p>
</blockquote>
<p>使用Cookie的: Max-Age 属性. 它可以指定从现在开始Cookie存在的秒数. 秒数过完则cookie过期</p>
<p>参考 <a href="https://www.cnblogs.com/aisowe/p/11566073.html" target="_blank" rel="noopener">aisowe</a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>但是在清理的时候，发现总是不能清除掉指定cookie，打印出来发现：同一个host，比如 baidu.com ，它的cookie里面有2个key是一样的，但是值不一样，清理的时候，指定host 为baidu.com ，但是只能清除一个，另一个怎么也清理不掉。</p>
<p>这就很奇怪了，能想到的就是可能在多个不同的host下都注入了这个key，于是想办法要把它存储cookies的文件取出来看下。</p>
<p>我们知道，cookies 文件存储在 /data/data/<package>/app_webview，文件名是Cookies ，但是这个路径是一个app内部空间，普通情况下是没办法将这个文件获取出来的，除非是在虚拟机或者root过后，安装特定的文件管理器。</package></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>不过我们安装Debug 的包的情况下，可能会有解决办法。因为 PackageManager 会检查 AndroidManifest.xml 中 isDebuggable 是不是false，这个值在我们打包的时候会根据你是打release包还是debug包而是不同的值，debug情况下是 isDebuggable = true，release 情况下是 true。</p>
<p>这样，我们将手机通过Android Studio 安装上debug包，进入shell：</p>
<blockquote>
<p>adb shell    </p>
</blockquote>
<p>进入app 空间：</p>
<blockquote>
<p>run-as <package>    </package></p>
</blockquote>
<p>这样就能进入到app的内部空间，当然，也可以参考<a href="https://www.cnblogs.com/SZ2015/p/4750051.html" target="_blank" rel="noopener">不root情况下读取data数据</a> ,此时我们再通过命令：</p>
<blockquote>
<p>cd app_webview/</p>
</blockquote>
<p>就能进到存放cookies的目录了，通过 ls 命令就能看到 Cookies 这个文件，这个文件是个数据库文件，可以使用sqlite3 打开。此时我们不能直接将其copy到我们电脑上，只能将其复制到我们的 sdcard 中：</p>
<blockquote>
<p>cp Cookies /sdcard</p>
</blockquote>
<p>此时，Cookies 文件已经被赋值到 sdcard，通过两次 exit 命令，就能退出 shell 模式，再通过 adb pull 命令，就能将其复制到电脑上了。</p>
<h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>在命令行打开Cookies 文件：</p>
<blockquote>
<p>sqlite3 /desktop/Cookies<br>.dump cookies</p>
</blockquote>
<p>就能看到cookies的数据了，这时候才发现，原来两个host都注入了这个key的cookie，一个是  baidu.com  一个是 .baidu.com，而后者是h5页面自己注入的，接下来问题就很明了了，将需要清除的cookies 按照前面的方法添加过期时间就ok，再手动执行删除过期cookies的操作，任务就完成了。</p>
<p>该篇文章旨在记录问题解决过程，详细过程这里略过。</p>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>第13章：热修复原理</title>
    <url>/2020/01/15/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC13%E7%AB%A0/</url>
    <content><![CDATA[<p>热修复框架的核心技术主要有3类：代码修复、资源修复和动态链接库修复。</p><h2 id="资源修复"><a href="#资源修复" class="headerlink" title="资源修复"></a>资源修复</h2><p>很多热修复的框架的资源修复参考了Instant Run的资源修复原理，因此我们首先了解下Instant Run 的原理。Instant Run 的资源修复核心逻辑在MonkeyPatcher 的monkeyPatchExistingResources 方法中，如下所示：</p><a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com/android/tools/fd/runtime/MonkeyPatcher.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">monkeyPatchExistingResources</span><span class="params">(Context context,String externalResourceFile,Collection&lt;Activity&gt; activityes)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个新的 AssetManager</span></span><br><span class="line">       AssetManager newAssetManager = (newAssetManager)newAssetManager.class.getConstructor(<span class="keyword">new</span> Class[<span class="number">0</span>]).newInstance(<span class="keyword">new</span> Object[<span class="number">0</span>]);<span class="comment">//1</span></span><br><span class="line">       </span><br><span class="line">       Method mAddAssetPath = AssetManager.class.getDeclareMethod(<span class="string">"addAssetPath"</span>,<span class="keyword">new</span> Class[] &#123;String.class&#125;);<span class="comment">//2</span></span><br><span class="line">       </span><br><span class="line">       mAddAssetPath.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">//通过反射调用 addAssetPath 方法加载外部的资源( SD 卡)</span></span><br><span class="line">       <span class="keyword">if</span> (((Integer) mAddAssetPath.invoke(newAssetManager,<span class="keyword">new</span> Object[]&#123; externalResourceFile&#125;)).intValue () == <span class="number">0</span>) &#123;<span class="comment">//3</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not create new AssetManager"</span>);</span><br><span class="line">            </span><br><span class="line">       <span class="keyword">if</span>&#123;activities != <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">for</span> (Activity activity : activities) &#123;</span><br><span class="line">         Resources resources= activity.getResources() ;<span class="comment">//4</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//反射得到 Resources 的 AssetManager 类型的 mAssets 字段</span></span><br><span class="line">          Field mAssets = Resources.class.getDeclareField(<span class="string">"mAssets"</span>);<span class="comment">//5</span></span><br><span class="line">          mAssets.setAccessible(<span class="keyword">true</span> );</span><br><span class="line"></span><br><span class="line">          <span class="comment">//将 mAssets 字段的引用替换为新创建的 AssetManager</span></span><br><span class="line">          mAssets.set(resources,newAssetManager) ;<span class="comment">//6</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//得到 Activity 的 Resources.Theme</span></span><br><span class="line">          Resources.Theme theme = activity.getTheme();</span><br><span class="line">          ...</span><br><span class="line">          <span class="comment">//反射得到 Resources.Theme 的 mAssets 字段</span></span><br><span class="line">          Field ma = Resources . Theme.class.getDeclaredField (” mAssets <span class="string">" ) ;</span></span><br><span class="line"><span class="string">          ma.setAccessible(true);</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">          //将 Resources.Theme 的 mAssets 字段替换为 newAssetManager</span></span><br><span class="line"><span class="string">          ma.set(theme,newAssetManager);//7</span></span><br><span class="line"><span class="string">         &#125; catch (Throwable ignore) &#123;</span></span><br><span class="line"><span class="string">         </span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看出，在注释1处创建了一个新的AssetManager，之后通过反射调用 addAssetPath 方法加载外部(SD卡)的资源。在注释4处遍历Activity 列表，得到每个Activity 的Resource ，在5处通过反射得到Resources 的AssetManager 类型的mAsset字段，并在注释6处改写mAssets字段的引用为新的 AssetManager。之后，将AssetManager 类型的mAssets 字段的引用全部替换为新创建的 AssetManager。所以，总共就是两个步骤：</p>
<ul>
<li>创建新的 AssetManager ,通过反射调用 addAssetPath 方法加载外部的资源,这样<br>新创建的 AssetManager 就含有了外部资源。     </li>
<li>将 AssetManager 类型的 rnAssets 字段的引用全部替换为新创建的 AssetManager。</li>
</ul>
<h2 id="代码修复"><a href="#代码修复" class="headerlink" title="代码修复"></a>代码修复</h2><p>先写到这，后续有空再来。。。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android进阶解密</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章：理解上下文Context</title>
    <url>/2019/12/06/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC5%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="Context-的关联类"><a href="#Context-的关联类" class="headerlink" title="Context 的关联类"></a>Context 的关联类</h2><p>开发中经常使用的Context 的使用场景大体分为两类：</p><ul>
<li>使用Context 调用方法，比如启动 Activity、访问资源、调用系统服务等。    </li>
<li>调用方法时传入，比如弹出 Toast、创建dialog。    </li>
</ul><p>Activity、Service 与 Application 都间接继承 Context，因此可以说一个应用进程的Context 数量 = Activity 数量 + Service 数量 + 1，这个1就是Application数量。Context 的关联类的关系如下图所示：</p><a id="more"></a>


<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC5%E7%AB%A0/Context%E5%85%B3%E8%81%94%E7%B1%BB%E5%85%B3%E7%B3%BB.png" alt="Context关联类关系"></p>
<p>可以看出，ContextWrapper 中包含有 Context 类型的 mBase 对象，mBase 具体指向 ContextImpl，此外，ContextThemeWrapper、Service 和 Application 都继承自 ContextWrapper，这样它们都能通过 mBase 来使用Context 的方法。同时它们也是装饰类，在 ContextWrapper 上又添加了不少功能。比如，ContextThemeWrapper 包含了主题相关的方法(getTheme之类)，因此Activity 继承了ContextThemeWrapper，而Service 不需要主题，因此继承 ContextWrapper。Context 关联类的继承结构有以下优点：</p>
<ul>
<li>使用者能够方便使用Context 的功能。    </li>
<li>如果 ContextImpl 发生了变化，它的装饰类 ContextWrapper 无需做任何修改。    </li>
<li>ContextImpl 的具体实现不会暴露给使用者。     </li>
<li>通过组合而不是继承，拓展 ContextImpl 的功能。运行时选择不同的装饰类，实现不同功能。    </li>
</ul>
<h2 id="Application-Context-的创建过程"><a href="#Application-Context-的创建过程" class="headerlink" title="Application Context 的创建过程"></a>Application Context 的创建过程</h2><p>我们通过 getApplicationContext 来获取应用程序的全局 Application Context，那么 Application Context 是如何创建的呢？在应用程序启动完成后，应用程序就有一个全局的 Application Context，那就从应用程序启动过程着手，Application Context 的创建过程时序图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC5%E7%AB%A0/ApplicationContext%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Application context 的创建时序图"></p>
<p>应用程序进程的主线程管理类 ActivityThread 会调用内部类 ApplicationThread 的 scheduleLaunchActivity 方法来启动Activity，而在scheduleLaunchActivity 中会向 H 发送 LAUNCH_ACTIVITY 类型消息，目的是将启动Activity 的逻辑放在主线程中。在 H 的 handleMessage 方法中最终会调用到 LoadApk 类的  makeApplication 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,Instrumentation nstrumentation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123;<span class="comment">//l</span></span><br><span class="line">        <span class="keyword">return</span> mApplication;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    Application app = <span class="keyword">null</span>;</span><br><span class="line">    String appClass = mApplicationinfo.className;</span><br><span class="line">    <span class="keyword">if</span> (forceDefaultAppClass || (appClass == <span class="keyword">null</span>) ) &#123;</span><br><span class="line">        appClass = <span class="string">"android.app.Application”;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    try &#123;</span></span><br><span class="line"><span class="string">        java.lang.ClassLoader cl= getClassLoader();</span></span><br><span class="line"><span class="string">        if (!mPackageName.equals ("</span>android<span class="string">"))&#123;</span></span><br><span class="line"><span class="string">            initializeJavaContextClassLoader ();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Contextimpl appContext = Contextimpl.createAppContext(mActivityThread,this); //2</span></span><br><span class="line"><span class="string">        app = mActivityThread.rninstrumentation.newApplication(cl, appClass, appContext);//3</span></span><br><span class="line"><span class="string">        appContext. setOUterContext(app) ;//4</span></span><br><span class="line"><span class="string">    &#125;catch (Exception e)&#123;</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    mApplication = app;//5</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    return app;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注释1处，假设是第一次启动应用程序，因此 mApplication 为null，在注释2处通过 Contextimpl 的 createAppContext 方法创建 Contextimpl 的实例，注释3中创建了 Application 对象，注释4处将 Application 对象赋值给 Contextimpl 的成员变量 mOuterContext ，<strong>这样，ContextImpl 中也包含了 Application 的引用。</strong>注释5处的 mApplication 即 LoadedApk 的成员变量 mApplication。来看看注释 3 处Application 是如何创建的（最终调用到如下代码的方法）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/lnstrumentation.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(xxxx)</span></span>&#123;</span><br><span class="line">    Application app = (Application) clazz.newinstance ();</span><br><span class="line">    app.attach(context) ; <span class="comment">//l</span></span><br><span class="line">    <span class="keyword">return</span> app ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释1处通过反射来创建Application</strong>，并调用其 attach 方法，并且将 ContextImpl 类型的对象传进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/Application.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    mLoadedApk = Contextimpl.getimpl(context).mPackageinfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mBase != <span class="keyword">null</span> ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException (<span class="string">"Base context already set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mBase = base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，把一路传过来的 ContextImpl 类型的 base 赋值给 Application 的 mBase 。前面讲过，这个歌mBase 是ContextWrapper 的成员变量，因为Application 继承 ContextWrapper ，所以才有这个变量。因此，Application 的attach 方法的作用就是使 Application 可以使用 Context 的方法，这样，Application 才可以用来代表 Application Context。</p>
<h2 id="Application-Context-的获取过程"><a href="#Application-Context-的获取过程" class="headerlink" title="Application Context 的获取过程"></a>Application Context 的获取过程</h2><p>我们通过 getApplicationContext 来获取Application Context，这个方法在 ContextWrapper 中实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/content/ContextWrapper.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">getApplicationContext</span><span class="params">()</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    return mBase.getApplicationContext( )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从前面我们可知，mBase 指的是 ComtextImpl，具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">getApplicationContext</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mPackageinfo != <span class="keyword">null</span> ) ? mPackageinfo.getApplication() : mMainThread.getApplication();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 loadedApk 类型的mPackageinfo 不为 null，则调用其 getApplication 方法，否则调用 ActivityThread 的 getApplication 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"></span><br><span class="line"><span class="function">Application <span class="title">getApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mApplication ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 mApplication 应该熟悉，是在前面提到的  LoadedApk 的  makeApplication 方法中注释 5 处被赋值的，是个Application 对象。就这样，我们获取到 Application Context。</p>
<h2 id="Activity-的Context-创建过程"><a href="#Activity-的Context-创建过程" class="headerlink" title="Activity 的Context 创建过程"></a>Activity 的Context 创建过程</h2><p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC5%E7%AB%A0/Activity%E7%9A%84context%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Activity的context创建过程时序图"></p>
<p>应用程序进程的主线程管理类 ActivityThread 会调用内部类 ApplicationThread 的 scheduleLaunchActivity 方法来启动Activity，最终通过 H 类在主线程中处理启动事项，最终调用到 ActivityThread 的 performLaunchActivity 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">perfomLaunchActivity</span><span class="params">(ActivityClientRecord r , Intent customintent)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);<span class="comment">//l</span></span><br><span class="line">    Activity activity = <span class="keyword">null</span> ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(cl , <span class="function">component <span class="title">getClassName</span><span class="params">()</span> , r.intent) </span>; <span class="comment">//2</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        appContext.<span class="function">setOuterC nte <span class="title">t</span><span class="params">(activity)</span> </span>; <span class="comment">//3</span></span><br><span class="line">        <span class="comment">//4</span></span><br><span class="line">        activity.attach(xxxx,xxxx);</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在注释2处创建了Activity 的实例，注释1处<strong>通过 createBaseContextForActivity 方法创建 Activity 的 ContextImpl</strong>，并在注释4 处将 ContextImpl 对象传给activity 的attach方法，在注释3处调用了 ContextImpl 的 setOuterContext 方法，将 Activity 的实例赋值给 ContextImpl 的成员变量 mOuterContext ，这样，ContextImpl 也可以访问 Activity 的变量和方法。createBaseContextForActivity 方法中，最终也会调用 ContextWrapper 的 attachBaseContext ，将Activity 中的 ContextImpl 对象赋值给 ContextWrapper 的成员变量 mBase，这样，ContextWrapper 的功能就可以交由 ContextImpl 来处理。</p>
<h2 id="Service-的-Context-创建过程"><a href="#Service-的-Context-创建过程" class="headerlink" title="Service 的 Context 创建过程"></a>Service 的 Context 创建过程</h2><p>Service 的Context 创建过程与 Activity 的Context 创建过程类似，这里先略过，后续有时间再记录。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android进阶解密</tag>
      </tags>
  </entry>
  <entry>
    <title>第12章：理解ClassLoader</title>
    <url>/2019/11/28/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC12%E7%AB%A0/</url>
    <content><![CDATA[<p>热修复和插件化是目前比较热门的技术，想要更好地掌握它们需要先了解ClassLoader。从第11章可知，DVM 和 ART 加载的是dex文件，JVM 加载的是class文件，因此它们的类加载器 ClassLoader 是肯定有区别的。</p><h2 id="Java中的ClassLoader"><a href="#Java中的ClassLoader" class="headerlink" title="Java中的ClassLoader"></a>Java中的ClassLoader</h2><p>虚拟机章节提到 <strong>类加载子系统</strong>，它的主要作用就是通过多种类加载器来查找和加载Class文件到Java虚拟机中。Java<strong>系统</strong>中的类加载器主要包括以下：</p><a id="more"></a>

<ul>
<li>Bootstrap ClassLoader(引导类加载器)：C/C++实现的，用于加载指定的JDK核心类库，比如 java.lang、java.uti等系统类。    </li>
<li>Extensions ClassLoader(拓展类加载器)： Java中的实现类为 ExtClassLoader ，用于加载Java的拓展类，主要包括 $JAVA_HOME/jre/lib/ext 、java.ext.dir 等目录。    </li>
<li>Application ClassLoader(应用程序类加载器)：Java中的实现类为 AppClassLoader，用来加载 1、当前程序的 Classpath 目录 ；2、系统属性 java.class.path指定的目录。    </li>
</ul>
<h3 id="ClassLoader-继承关系"><a href="#ClassLoader-继承关系" class="headerlink" title="ClassLoader 继承关系"></a>ClassLoader 继承关系</h3><p>以下代码可以验证 运行一个Java程序需要用到哪些类加载器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ClassLoader loader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        <span class="keyword">while</span> (loader != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(loader);<span class="comment">//1</span></span><br><span class="line">            loader = loader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码可以获得当前类 ClassLoaderTest 的类加载器，接着打印出当前类加载器的父加载器，直到没有父加载器，打印的结果如：</p>
<blockquote>
<p>sun misc Launcher AppClassLoader@75b84c92<br>sun .misc .Launcher$ExtClassLoader@lb6d3586     </p>
</blockquote>
<p>可以看出，<strong>加载 ClassLoaderTest 的加载器是 AppClassLoader</strong>，并且AppClassLoader 的父加载器是 ExtClassLoader。但是这里没有打印出 ExtClassLoader 的父加载器 Bootstrap ClassLoader ，是因为Bootstrap ClassLoader 由 C/C++ 编写，并不是一个Java类，因此我们无法在Java代码中获取。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>所谓的双亲委派模型就是首先判断该Class是否已经加载，如果未加载，则当前加载器委托父加载器进行查找，这样依次地柜，直到委托到最顶层的 Bootstrap ClassLoader，如果Bootstrap ClassLoader 找到了该Class，就直接返回，否则，依次向下查找，如果当前加载器之上的所有加载器都未能加载，则当前加载器自身去查找。</p>
<p>如果要加载一个位于D盘的Class文件，系统所提供的类加载器就不能满足，这时候需要自定义类加载器 CustomClassLoader 继承java.lang.ClassLoader 并覆写findClass方法，加载D盘的Class文件步骤如下：</p>
<ol>
<li>CustomClassLoader 首先从缓存中查找Class文件是否已经加载，已经加载就返回，没有加载就委托给<strong>父加载器(AppClassLoader)</strong>。    </li>
<li>按照双亲委派模型递归。    </li>
<li>一直委托到 Bootstrap ClassLoader ，如果 Bootstrap ClassLoader 也没能加载，则交给子加载器(ExtClassLoader)，以此类推。    </li>
</ol>
<blockquote>
<p>综合以上，ClassLoader的父子关系不是使用继承来实现的，二是使用组合来实现代码复用。</p>
</blockquote>
<p>双亲委派模型的好处：</p>
<ol>
<li>避免重复加载。如果Class已经加载过，就不需要加载，二是直接读取。    </li>
<li>更加安全。如果不使用双亲委派模型，就可以自定义一个String类来替代系统的String类，显然会造成安全隐患。或者自定义一个Object类，有可能会动摇java基础，因为java里面所有类都要继承java的Object(这段是我自己理解添加的)。采用双亲委派模型似的系统的类在Java虚拟机启动时就被加载，也就无法自定义系统类来替代系统。</li>
</ol>
<p>自定义类加载器的代码如下：<br><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC12%E7%AB%A0/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A81.jpeg" alt="自定义类加载器1"><br><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC12%E7%AB%A0/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A82.jpeg" alt="自定义类加载器2"></p>
<h2 id="Android-中的ClassLoader"><a href="#Android-中的ClassLoader" class="headerlink" title="Android 中的ClassLoader"></a>Android 中的ClassLoader</h2><h3 id="ClassLoader-的类型"><a href="#ClassLoader-的类型" class="headerlink" title="ClassLoader 的类型"></a>ClassLoader 的类型</h3><p>Android中系统类加载器也主要包括3种：</p>
<ul>
<li>BootClassLoader： 由Java代码实现，类的访问修饰符是默认的，只有在同一个包中才能访问，用户无法直接调用。Android系统启动时，会使用BootClassLoader 预加载常用类。    </li>
<li>DexClassLoader：可以加在dex文件以及包含dex的压缩文件(apk和jar)，不管加载哪种文件，最终都加载dex文件。    </li>
<li>PathClassLoader：Android使用它来加载系统类和应用程序的类，通常用来加载已经安装的apk的dex文件。</li>
</ul>
<h3 id="ClassLoader的继承关系"><a href="#ClassLoader的继承关系" class="headerlink" title="ClassLoader的继承关系"></a>ClassLoader的继承关系</h3><p>通过前面用于验证java类继承关系的代码，在这里同样可以验证Android中类加载器的继承关系。</p>
<h3 id="ClassLoader-的加载过程"><a href="#ClassLoader-的加载过程" class="headerlink" title="ClassLoader 的加载过程"></a>ClassLoader 的加载过程</h3><p>Android 的 ClassLoader 同样遵循了双亲委派模型，ClassLoader 的加载方法为 loadClass方法，这个方法定义在抽象类 ClassLoader中。ClassLoader的查找流程如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC12%E7%AB%A0/ClassLoader%E7%9A%84%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B.png" alt="ClassLoader的查找流程"></p>
<h3 id="BootClassLoader的创建"><a href="#BootClassLoader的创建" class="headerlink" title="BootClassLoader的创建"></a>BootClassLoader的创建</h3><p>在ZygoteInit的main方法中，调用了Zygote的 preload 方法，preload方法中又调用了 ZygoteInit 的 preloadClasses 方法，preloadClasses用于预加载常用的类，这个预加载属于拿空间换时间的策略。在preloadClasses方法中会创建 BootClassLoader 。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android进阶解密</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章：四大组件的工作过程</title>
    <url>/2019/11/25/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC4%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="根Activity的启动过程"><a href="#根Activity的启动过程" class="headerlink" title="根Activity的启动过程"></a>根Activity的启动过程</h2><p>根Activity 是应用程序第一个Activity，相比普通的Activity的启动过程，一般用根Activity 的启动过程来指代应用程序的启动过程，更具有参考意义。根Activity 的启动过程比较复杂，这里分为3个部分来讲：<font color="green">Launcher 请求AMS 过程、AMS 到ApplicaitonThread 的调用过程 以及 ActivityThread 启动Activity</font>。</p><a id="more"></a>
<h3 id="Launcher-请求AMS-过程"><a href="#Launcher-请求AMS-过程" class="headerlink" title="Launcher 请求AMS 过程"></a>Launcher 请求AMS 过程</h3><p>当我们点击桌面上某个应用的快捷图标时，就会通过Launcher 请求AMS 来启动该应用程序，过程的时序图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/Launcher%E8%B0%83%E7%94%A8AMS%E5%90%AF%E5%8A%A8Activity%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Launcher调用AMS启动Activity时序图"></p>
<p>点击桌面图标，会调用 Launcher 的startActivitySafely方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  packages/apps/Launcher3/src/com/android/launcher3/Launcher.java </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startActivitySafely</span><span class="params">(View v ,Intent intent, Itemlnfo item)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); <span class="comment">//l </span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xxxx)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(user == <span class="keyword">null</span> || user.equals(Process.myUserHandle()))&#123;</span><br><span class="line">            startActivity(intent, optsBundle); <span class="comment">//2 </span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ActivityNotFoundExceptionlSecurityException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是启动新的应用，所以注释1处将根Activity 在新的任务栈启动，应用启动会执行到注释2处的startActivity 方法，最终会在Activity 中调用  startActivityForResult 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/and oid/app/Activity.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;<span class="comment">//1</span></span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">        Instrumentation.ActivityResult ar = minstrumentation.execStartActivity(<span class="keyword">this</span>, mMainThread.getApplicationThread(), mToke,<span class="keyword">this</span>,intent, requestCode , option);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注释1的mParent 是Activity 类型，表示当前Activity 的父类(个人理解，这里应该说是当前Activity的前一个Activity)，因此mParent == null 成立，最后由 Instrumentation 的execStartActivity方法来执行启动操作。 <strong>Instrumentation 主要用于监控应用程序和系统的交互。</strong>主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/android/app/Instrumentation.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who , IBinder contextThread, IBinder token , Activity target, Intent intent ,<span class="keyword">int</span> requestCode ,Bundle options)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    intent.migrateExtraStreamToClipData();</span><br><span class="line">    intent.prepareToLeaveProcess(who );</span><br><span class="line">    <span class="keyword">int</span> result = ActivityManager.getService().startActivity(xxx,xxx,xxxx));</span><br><span class="line">    checkStartActivityResult(result, intent);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>由代码可知，首先通过 ActivityManager 获取 AMS 的代理对象，接着调用代理对象的 startActivity 方法。AMS 的代理对象是一个 IActivityManager(该类由AIDL在工具编译时自动生成的)对象，这个对象封装了 IBinder 类型的 AMS 的引用。通过一系列进程间通信，最终调用 AMS 的 startActivity 方法。</p>
<h3 id="AMS-到-ApplicationThread-的调用过程"><a href="#AMS-到-ApplicationThread-的调用过程" class="headerlink" title="AMS 到 ApplicationThread 的调用过程"></a>AMS 到 ApplicationThread 的调用过程</h3><p>Launcher 请求进入AMS 后，接着是AMS 到 ApplicationThread 调用流程，时序图如下所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/AMS%E5%88%B0ApplicationThread%E8%B0%83%E7%94%A8.png" alt="Launcher调用AMS启动Activity时序图"></p>
<p>在AMS 的startActivity 会使用 startActivityAsUser 实现功能，并获取UserHandle.getCallingUserld() 即 调用者的UserId 作为参数传入。之后，startActivityAsUser 中会判断调用者进程是否被隔离，如果隔离则抛出<font color="green">SecurityException</font>异常；接着，根据UserId 等参数检查调用者权限，如果没权限也抛出 SecurityException 异常。</p>
<p>AMS 中最终调用ActivityStater 的 startActivityLocked 方法，并且如果有 TaskRecord(代表启动的Activity所在的栈)，则将其也作为参数传入；startActivityLocked 中会收集所有逻辑来决定如何将Intent 和Flags 转换为Activity(生成用于描述Activity 的  ActivityRecord 对象)，并且将Activity 与Task 及 Stack 关联。</p>
<blockquote>
<p>TaskRecord 用于描述一个 Activity 任务栈，Activity 任务栈其实是一个假想模型，并不真实存在。</p>
</blockquote>
<p>最终调用到 ActivityStackSupervisor 的 startSpecificActivityLocked 方法时，会判断要启动的Activity 所在的应用程序进程是否已经运行，已经运行则调用 realStartActivityLocked 方法，并传入代表应用程序进程的 ProcessRecord。之后会调用 ApplicationThread 的 scheduleLaunchActivity 方法。当前代码逻辑运行在AMS所在进程(即SystemServer进程)中，通过 ApplicationThread 进程间通信，将程序执行到应用程序进程，<strong>ApplicationThread是AMS 进程与应用程序进程的通信桥梁</strong>，如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/AMS%E4%B8%8E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.png" alt="AMS与应用程序进程通信"></p>
<h3 id="ActivityThread-启动Activity-的过程"><a href="#ActivityThread-启动Activity-的过程" class="headerlink" title="ActivityThread 启动Activity 的过程"></a>ActivityThread 启动Activity 的过程</h3><p>由前面的知识可知，目前的代码逻辑已经运行到应用程序进程中，先查看下ActivityThread 启动Activity 的时序图：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/ActivityThread%E5%90%AF%E5%8A%A8Activity%E8%BF%87%E7%A8%8B%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="ActivityThread启动Activity过程的时序图"></p>
<p>ApplicationThread 是 ActivityThread 的内部类，前面讲过应用程序进程创建完成后，会运行代表主线程的实例 ActivityThread 。接着上一节的内容查看 ApplicationThread.scheduleLaunchActivity 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(xxx,xx,xxx)</span> </span>&#123;<span class="comment">//参数太多，这里省略了参数</span></span><br><span class="line">    updateProcessState(procState ,<span class="keyword">false</span>);</span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line">    r.token = token;</span><br><span class="line">    r.ident ＝ident;</span><br><span class="line">    r.intent = intent;</span><br><span class="line">    r.referrer = referrer;</span><br><span class="line">    ...</span><br><span class="line">    updatePendingCoηfiguration (curConfig);</span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY ,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在把启动Activity 必要的数据封装成 ActivityClientRecord 后，通过 sendMessage 方法将封装的数据以 H.LAUNCH_ACTIVITY 类型发送了出去，这里可以大胆地猜测sendMessage方法是通过handler的 sendMessage 执行的，果不其然,sendMessage 有多个重载方法，最终调用到如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what ,Object obj ,<span class="keyword">int</span> argl ,<span class="keyword">int</span> arg2 ,<span class="keyword">boolean</span> async)</span></span>&#123;</span><br><span class="line">    Message msg = <span class="function">Message <span class="title">obta</span> <span class="params">()</span></span>;</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.ob]= obj;</span><br><span class="line">    msg.argl = argl;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        msg .setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br></pre></td></tr></table></figure>

<p>这里的mH指的是 ActivityThread 的内部类 H，前面讲过，这个H是集成Handler，是应用进程中主线程的消息管理类，<strong>因为ApplicationThread 是一个Binder，它的调用逻辑都运行在Binder 线程池中，所以这里需要使用H将代码的逻辑切换到主线程中。</strong>这样一来，我们只需要看 H 的handleMessage 方法即可知道具体的执行操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span> <span class="params">(Message msg )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> LAUNCH_ACTIVITY:</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER，<span class="string">"activityStart"</span>);</span><br><span class="line">        <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;<span class="comment">//1</span></span><br><span class="line">        r.packageinfo = getPackageinfoNoCheck(r.activityinfo.applicationinfo, r.compatlnfo); <span class="comment">//2</span></span><br><span class="line">        handleLaunchActivity(r,<span class="keyword">null</span> ,<span class="string">"LAUNCH ACTIVITY"</span>); <span class="comment">//3</span></span><br><span class="line">        Trace.traceEnd (Trace . TRACE TAG ACTIVITY MANAGER);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在注释1处将传过来的 msg 的成员变量 obj 还原成 ActivityClientRecord，注释2获得LoadApk 类型的对象。<strong>应用程序进程要启动Activity时需要将该Activity 所属的APK 加载进来，而LoadApk 就是用来描述已经加载的APK 文件的。</strong>注释3处调用 handleLaunchActivity 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r ,Intent customintent, String reason)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    WindowManagerGlobal.initialize ();</span><br><span class="line">    <span class="comment">//启动 Activity</span></span><br><span class="line">    Activity a = performLaunchActivity(r, customintent);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span>(a != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//将 Activity 的状态置为 Resume</span></span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,!r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);<span class="comment">//2</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//停止 Activity 启动</span></span><br><span class="line">        <span class="function">ActivityManager getServ <span class="title">ce</span> <span class="params">()</span> .<span class="title">finishActivity</span><span class="params">(r . token , Activity . RESULT CANCELED , <span class="keyword">null</span> , Activity . DONT_FINISH_TASK_WITH_ACTIVITY)</span> </span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处performLaunchActivity 方法启动了 Activity，注释2处将Activity的状态设置为 Resume ，如果该Activity 为null，则会通知AMS 停止启动Activity。我们来看看 performLaunchActivity 方法做了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r , Intent customintent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取 Activityinfo</span></span><br><span class="line">    Activityinfo ainfo = r.activityinfo;<span class="comment">//l</span></span><br><span class="line">    <span class="keyword">if</span> (r.packageinfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取 APK 文件的描述类 LoadedApk</span></span><br><span class="line">        r.packageinfo = getPackageinfo(ainfo.applicationinfo ,r.compatinfo,Context.CONTEXT_INCLUDE_CODE);<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    ComponentName component= r.intent.getComponent();<span class="comment">//3</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建要启动 Activity 的上下文环境</span></span><br><span class="line">    Contextlmpl appContext = createBaseContextForActivity(r) ; <span class="comment">//4</span></span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang .ClassLoader cl= appContext.getClassLoader();</span><br><span class="line">        <span class="comment">//用类加载器来创建该 Activity 的实例</span></span><br><span class="line">        activity = <span class="function">mInstrumentation <span class="title">newActivity</span><span class="params">(cl ,component.getClassName()</span> ,r.intent) </span>;<span class="comment">//5</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建 Application</span></span><br><span class="line">        Application app = r.packageinfo.makeApplication(<span class="keyword">false</span> ,minstrumentation); <span class="comment">//6</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//初始化Activity，参数太多，省略</span></span><br><span class="line">            activity.attach(....) ;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                minstrumentation.callActivityOnCreate(activity,r.state ,r.persistentState); <span class="comment">//8</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="function">minstrumentat on <span class="title">callActivityOnCreate</span><span class="params">(activ ty r .state)</span> </span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        r.paused = <span class="keyword">true</span> ;</span><br><span class="line">        mActivities.put(r.token,r);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e ;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br></pre></td></tr></table></figure>

<p>注释1处获取 Activityinfo，用于存储AndroidManifest 以及 代码中设置的Activity 和 Receiver 节点的信息，比如Activity 的theme 和launchMode 。注释3中获取要启动的Activity 的 <strong>ComponentName 对象，该对象中保存了该Activity 的包名和类名</strong>。注释4中启动了Activity的上下文，注释5根据 Activity 的类名，用类加载器创建该 Activity 的实例。之后，注释6中创建了Application ，并且会调用 Application 的 onCreate方法。注释7中调用 Activity 的attach 方法初始化Activity，并且创建Window 对象(PhoneWindow)与Activity 自身关联。注释8中正式启动Activity，并调用Activity 的onCreate 方法。</p>
<p>至此，根Activity 就启动了，即应用程序启动了。</p>
<h3 id="根Activity-启动过程中涉及的进程"><a href="#根Activity-启动过程中涉及的进程" class="headerlink" title="根Activity 启动过程中涉及的进程"></a>根Activity 启动过程中涉及的进程</h3><p>根Activity 启动过程中涉及的4个进程之间关系如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/%E6%A0%B9Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png" alt="根Activity启动过程中涉及的进程关系"></p>
<p>首先Launcher 进程向 AMS 请求创建根 Activity ，AMS 会判断根Activity 所需要的应用程序进程是否存在，不存在就请求 Zygote 进程创建应用程序进程；之后，AMS 请求创建根Activity。上图中步骤 2 采用Socket 通信，步骤 1 和4采用Binder 通信。</p>
<p>读完书本，虽然各个点清晰，但是未能完整总结，<strong>以下 桌面点击图标 启动流程总结参考自<a href="http://www.androidos.net.cn/book/android-road/android/advance/app-launch.html" target="_blank" rel="noopener">他人博客</a></strong></p>
<ol>
<li>点击桌面图标，Launcher 采用Binder IPC 方式向system_server 发起startActivity 请求。    </li>
<li>system_server 进程接收到请求后，向 zygote 进程发送创建进程请求。    </li>
<li>zygote 进程fork 出新进程，即App进程。    </li>
<li>App 进程通过 Binder IPC 向 system_server 发起 attachApplication 请求。     </li>
<li>system_server收到请求做一系列准备后，通过 Binder IPC 向App 进程发送 scheduleLauncherActivity请求。    </li>
<li>App 进程的Binder 线程(ApplicationThread)收到请求后，通过Handler 向主线程发送 LAUNCH_ACTIVITY 消息。    </li>
<li>主线程收到Message 后，通过反射机制创建目标Activity ，并回调Activity.onCreate 等方法。    </li>
<li>至此，App启动，开始Activity 生命周期。</li>
</ol>
<p>这个过程示意图如下所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Activity启动流程图"></p>
<h2 id="Service-启动过程"><a href="#Service-启动过程" class="headerlink" title="Service 启动过程"></a>Service 启动过程</h2><p>Service 的启动过程和根Activity 的启动过程有部分相似知识点。Service 的启动过程可以分为两个部分讲解：分别是ContextImpl 到ActivityManageService 的调用过程，以及 ActivityThread 启动 Service。</p>
<h3 id="ContextImpl-到-AMS-的调用过程"><a href="#ContextImpl-到-AMS-的调用过程" class="headerlink" title="ContextImpl 到 AMS 的调用过程"></a>ContextImpl 到 AMS 的调用过程</h3><p>首先上时序图：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC4%E7%AB%A0/ContextImpl%E5%88%B0AMS%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="ContextImpl到AMS的调用过程"></p>
<p>调用startService方法启动service，这个方法在 ContextWrapper 中实现</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android进阶解密</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章：应用程序进程启动过程</title>
    <url>/2019/11/24/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC3%E7%AB%A0/</url>
    <content><![CDATA[<p>AMS启动一个应用程序首先要保证该应用程序的进程已经启动，如果应用程序进程还不存在，则请求 Zygote 进程启动进程。</p><p>从前一章内容可知，在Zygote 的Java 框架层会创建Server 端的Socket，用于等待AMS 请求Zygote 创建新的应用程序进程。Zygote 通过fork自身即可创建应用程序进程，这个进程会包含虚拟机实例，并且会创建Binder线程池和消息循环。</p><a id="more"></a>

<p>本章学习应用程序进程的启动，注意，是应用程序进程而不是应用程序的启动过程。</p>
<h2 id="应用程序进程启动过程介绍"><a href="#应用程序进程启动过程介绍" class="headerlink" title="应用程序进程启动过程介绍"></a>应用程序进程启动过程介绍</h2><p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC3%E7%AB%A0/AMS%E5%8F%91%E9%80%81%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.jpeg" alt="AMS发送启动应用程序进程请求过程的时序图"></p>
<p>AMS 通过调用  startProcessLocked 向 Zygote 进程发送请求， 主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">String hostingNameStr, String abiOverride ,String entryPoint ,String [] entryPointArgs)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取要创建的应用程序进程的用户 ID</span></span><br><span class="line">    <span class="keyword">int</span> uid = app.uid; <span class="comment">//1 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> [] gids = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">if</span> (!app.isolated) &#123; </span><br><span class="line">        <span class="comment">//2  gids创建和赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="function">ArrayUtils <span class="title">isEmpty</span><span class="params">(permGids)</span>)</span>&#123;</span><br><span class="line">            gids =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">            gids = <span class="keyword">new</span> <span class="keyword">int</span>[permGids.leng + <span class="number">3</span>] ; </span><br><span class="line">            System.arraycopy(permGids, <span class="number">0</span>, gids, <span class="number">3</span>, permGids.length) ; </span><br><span class="line">            gids[O] = UserHandle.getSharedAppGid(UserHandle.getAppid(uid)); </span><br><span class="line">            gids[<span class="number">1</span>] = UserHandle.getCacheAppGid(UserHandle .getAppid(uid)) ; </span><br><span class="line">            gids[<span class="number">2</span>] = UserHandle.getUserGid&#123;UserHandle.getUserid(uid)); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (entryPoint = <span class="keyword">null</span>) entryPoint = <span class="string">"android.app.ActivityThread"</span>;<span class="comment">//3</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//启动应用程序进程,这里省略不重要的参数</span></span><br><span class="line">    startResult = Process.start(entryPoint,xxx,uid, xxx,gids,xxx,xxx);</span><br></pre></td></tr></table></figure>

<p>上述代码<strong>首先得到应用程序进程的用户ID</strong>，之后创建用户组ID 并且赋值，在注释3处判断 entryPoint 为null就赋值 “android.app.ActivityThread”，<font color="#008000">这个值就是应用程序进程主线程的类名</font>。在最终调用 Process.start 创建进程时，会将进程的用户ID和用户组ID传入。</p>
<p>Process.start会将实现交给 ZygoteProcess(<strong>ZygoteProcess用于保持与Zygote进程的通信状态</strong>)的start 方法处理，其中首先会执行 openZygoteSocketifNeeded  方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed ()) &#123; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">//与 Zygote 进程建立 Socket 连接</span></span><br><span class="line">    primaryZygoteState = ZygoteState.connect(mSocket);<span class="comment">//1</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ioe&#125; &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx (<span class="string">"Error connecting to primary zygote"</span>， ioe)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//连接 Zygote 主模式返回的 ZygoteState 是否与启动应用程序进程所需要的ABI匹配</span></span><br><span class="line"><span class="keyword">if</span> (primaryZygotestate.matches (abi)) &#123;<span class="comment">//2 </span></span><br><span class="line">    <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">／／如果不匹配，则尝试连接 Zygote 辅模式</span><br><span class="line"><span class="keyword">if</span> (secondaryZygoteState ==<span class="keyword">null</span> || secondaryZygoteState.isClosed()) &#123; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    secondaryZygoteState = ZygoteState.connect(mSecondarySocket);<span class="comment">//3</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ioe) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx (<span class="string">"Error connecting to secondary zygote"</span>, ioe) ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">／／连接 Zygote 辅模式返回的 ZygoteState 是否与启动应用程序进程所需要的 ABI 匹配</span><br><span class="line"><span class="keyword">if</span> (secondaryZygoteState.matches(abi)) &#123;<span class="comment">//4 </span></span><br><span class="line">    <span class="keyword">return</span> secondaryZygoteState; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx (<span class="string">"Unsupported zygote ABI :"</span> + abi);</span><br></pre></td></tr></table></figure>

<p>前面章节提到Zygote的main方法中会创建name为 “zygote” 的server端Socket，注释1就是与Zygote进程建立Socket 连接(name为”zygote”)，并得到 ZygoteState 对象primaryZygoteState；注释2处如果primaryZygoteState 与启动应用程序所需要的 ABI 不匹配，则在注释3处连接name为 “zygote_secondary” 的Socket。如果辅模式返回的 ZygoteState 与进程所需的ABI也不匹配，就抛出异常。</p>
<p>通过 openZygoteSocketifNeeded 获取ZygoteState后，将其作为参数调用 ZygoteProcess的  ZygoteSendArgsAndGetResult 方法 获取Process.ProcessStartResult。</p>
<h3 id="Zygote-接收请求并创建应用程序进程"><a href="#Zygote-接收请求并创建应用程序进程" class="headerlink" title="Zygote 接收请求并创建应用程序进程"></a>Zygote 接收请求并创建应用程序进程</h3><p>执行完以上步骤后，继续执行 argsForZygote 方法即可让Zygote 收到创建新的应用程序进程的请求。Zygote 接收请求并创建应用程序进程的时序图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC3%E7%AB%A0/Zygote%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Zygote接收请求并创建应用程序进程的时序图"></p>
<p>由前面章节我们知道，Zygote 中的Server Socket 的runSelectLoop 方法一直在等待 AMS请求创建新的应用程序进程，runSelectLoop 中是通过 runOnce 来创建进程的，runOnce最终调用到 Zygote 的 forkAndSpecialize 方法创建应用程序进程，并返回pid。forkAndSpecialize 通过fork 当前进程来创建一个子进程。此后，便会在应用程序进程中创建 Binder 线程池，*<em>进一步通过反射 ActivityThread 类的main方法调用，令应用程序进程进入了ActivityThread 的main方法中。此时，应用程序进程创建完毕，并且运行了主线程管理类 ActivityThread *</em>。</p>
<blockquote>
<p>如果pid为0，说明当前代码运行在新创建的子进程中。</p>
</blockquote>
<h3 id="Binder-线程池启动过程"><a href="#Binder-线程池启动过程" class="headerlink" title="Binder 线程池启动过程"></a>Binder 线程池启动过程</h3><p>程序中会检查代码，确保Binder线程池只会被启动一次。</p>
<h3 id="消息循环创建过程"><a href="#消息循环创建过程" class="headerlink" title="消息循环创建过程"></a>消息循环创建过程</h3><p>通过反射方式 invok 执行 ActivityThread 的main方法时，会执行一系列主线程的工作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建主线程 Looper</span></span><br><span class="line">    Looper.prepareMainLooper(); <span class="comment">//1 </span></span><br><span class="line">    ActivityThread thread= <span class="keyword">new</span> ActivityThread(); <span class="comment">//2 </span></span><br><span class="line">    thread.attach(<span class="keyword">false</span>) ; </span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span> ) &#123;<span class="comment">//3 </span></span><br><span class="line">    <span class="comment">//创建主线程 H 类</span></span><br><span class="line">    sMainThreadHandler = thread . getHandler ();<span class="comment">//4 </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123; </span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span> LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>）；</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER) ; </span><br><span class="line">    <span class="comment">//Looper 开始工作</span></span><br><span class="line">    Looper.loop (); <span class="comment">//5 </span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityThread类用于管理当前应用程序进程的主线程，上述代码中创建了主线程的消息循环Looper，其中的内部类 H 继承 Handler，在注释 5 处调用Looper.loop ，即使得Looper 开始处理消息，可见，系统在应用程序进程启动完成后，就会创建消息循环。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android进阶解密</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-设计模式</title>
    <url>/2019/11/23/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1、mvc、mvp、mvvm"><a href="#1、mvc、mvp、mvvm" class="headerlink" title="1、mvc、mvp、mvvm"></a>1、mvc、mvp、mvvm</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="mvc"><a href="#mvc" class="headerlink" title="mvc"></a>mvc</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvc.png" alt="mvc示意图"></p>
<p><strong>特征：</strong></p>
<ul>
<li>view 接收用户的输入，并且可以通知Controller 更改Model 层数据，如果没有涉及逻辑，还可以直接通知Model 更改数据。    </li>
<li>需要ui变化，但是没有涉及业务数据，直接调用controller 即可(比如用户选择使用用户名/手机号登录)    </li>
<li>model 数据变化时，若需要修改ui，需要通过Controller 来通知更新。</li>
</ul>
<p><strong>在Android中存在问题：</strong></p>
<ul>
<li>Activity 的职责不明，并且臃肿。Activity 除了要展示view (加载view，接收用户操作)，还要承担部分逻辑处理(比如生命周期回调)    </li>
</ul>
<h3 id="mvp"><a href="#mvp" class="headerlink" title="mvp"></a>mvp</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvp.png" alt="mvp示意图"></p>
<p><strong>特点</strong>:</p>
<ul>
<li>View 层接收输入</li>
<li>Presenter 处理业务逻辑，View 与 Model 之间必须经过 Presenter</li>
</ul>
<p><strong>优点(相对MVC)：</strong></p>
<ul>
<li>避免了View、Model 直接联系，更加解耦，通过Presenter 实现两者之间的沟通    </li>
<li>Activity 更加简明，仅仅负责UI上的工作    </li>
</ul>
<h3 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvvm.png" alt="mvvm示意图"></p>
<p>可能主要关注view 通过databinding 与 viewmodel 相互绑定。</p>
<h3 id="mvc-与-mvp-的区别"><a href="#mvc-与-mvp-的区别" class="headerlink" title="mvc 与 mvp 的区别"></a>mvc 与 mvp 的区别</h3><ul>
<li>在mvc 中 Activity 具有 view 的功能，并且兼任部分 controller 功能，而mvp 中Activity 是纯粹的view    </li>
<li>mvc 中view 和model 可以直接沟通(没有逻辑情况下，view直接更改model，当然，有逻辑改动的情况下经过controller)，而mvp中二者沟通必须经过presenter。    </li>
</ul>
</details><a id="more"></a>

<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/carson_ho/article/details/100070713" target="_blank" rel="noopener">carson_ho的博客</a></p>
</blockquote>
<h3 id="2、实现一个线程安全的单例模式"><a href="#2、实现一个线程安全的单例模式" class="headerlink" title="2、实现一个线程安全的单例模式"></a>2、实现一个线程安全的单例模式</h3><h3 id="3、观察者模式和回调有什么区别？"><a href="#3、观察者模式和回调有什么区别？" class="headerlink" title="3、观察者模式和回调有什么区别？"></a>3、观察者模式和回调有什么区别？</h3>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-虚拟机知识</title>
    <url>/2019/11/23/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="1、对象的内存布局"><a href="#1、对象的内存布局" class="headerlink" title="1、对象的内存布局"></a>1、对象的内存布局</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>分为3个区域：对象头、实例数据 以及 对齐填充</p>
<p><strong>对象头：</strong>包括两部分信息，第一部分：对象自身运行时数据，如hashcode、GC年龄分代、锁状态标志位，官方称为”Mark Word”。第二部分：类型指针，虚拟机通过这个指针确定对象是哪个类的实例。</p>
<p><strong>实例数据：</strong>对象真正存储的有效信息。</p>
<p><strong>对齐填充：</strong>比如HotSpot vm 要求对象起始地址必须是8的整数倍。对齐填充不是必需的。</p>
<p>以下是句柄访问 时，内存布局关系图：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="内存布局关系图"></p>
<blockquote>
<p>以上内容参考自： <a href="http://www.androidos.net.cn/book/android-road/java/virtual-machine/object.html" target="_blank" rel="noopener">对象创建与定位</a></p>
</blockquote>
</details><a id="more"></a>

<h2 id="2、垃圾收集算法"><a href="#2、垃圾收集算法" class="headerlink" title="2、垃圾收集算法"></a>2、垃圾收集算法</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>标记-清除 算法。不足：1、标记清除效率不高。2、产生内存碎片。    </li>
<li>复制算法。为了解决标记清除的效率问题，将内存划分为大小相等的两块，每次使用一块。不足：可用内存缩小为原来一半。    </li>
<li>标记-整理。不足：复制存货对象耗时过多。    </li>
<li>分代收集算法。 新生代使用复制算法；老年代采用“标记-清除” 或者 “标记-整理”算法。</li>
</ul>
</details>

<blockquote>
<p>以上内容参考自： <a href="http://www.androidos.net.cn/book/android-road/java/virtual-machine/Garbage-Collector.html" target="_blank" rel="noopener">垃圾回收算法</a></p>
</blockquote>
<h2 id="3、说说四大引用？强，软，弱，虚，并说明下合适GC"><a href="#3、说说四大引用？强，软，弱，虚，并说明下合适GC" class="headerlink" title="3、说说四大引用？强，软，弱，虚，并说明下合适GC"></a>3、说说四大引用？强，软，弱，虚，并说明下合适GC</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。</p>
</blockquote>
<blockquote>
<p>软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，只有在内存不足的时候 JVM 才会回收该对象。这一点可以很好地用来解决 OOM 的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>
</blockquote>
<blockquote>
<p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p>
</blockquote>
<blockquote>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。要注意的是，虚引用必须和引用队列关联使用.</p>
</blockquote>
</details>

<h2 id="4、Android中内存分配的执行流程"><a href="#4、Android中内存分配的执行流程" class="headerlink" title="4、Android中内存分配的执行流程"></a>4、Android中内存分配的执行流程</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="铺垫"><a href="#铺垫" class="headerlink" title="铺垫"></a>铺垫</h3><p>Dalvik 虚拟机的Java堆的底层实现是一块共享匿名内存(Ashmem)，并且将其抽象为C库的一个 mspace ，于是，Dalvik 虚拟机就可以利用 C 库里面的 dlmalloc 内存分配器来解决内存碎片问题(这是个成熟的内存分配器，<strong>可以很好地解决内存碎片的问题</strong>)</p>
<h3 id="Android中内存分配的执行流程："><a href="#Android中内存分配的执行流程：" class="headerlink" title="Android中内存分配的执行流程："></a>Android中内存分配的执行流程：</h3><p>流程图如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B.png" alt="dalvik虚拟机内存分配流程"></p>
<ol>
<li>尝试在Java堆上分配指定大小的内存，如果内存充足，就直接分配成功。(不改变java堆当前大小的前提下进行内存分配，属于轻量级的内存分配)      </li>
<li>如果分配失败，就执行一次GC(如果此时有GC在运行，则等待这次GC执行完成)，GC 时设置参数false标记<strong>不要</strong>回收软引用的对象。        </li>
<li>GC 完成后，再次尝试轻量级内存分配操作，如果内存充足，就分配成功了               </li>
<li>如果上一步内存分配失败，就考虑将Java堆的当前大小设置为Dalvik 虚拟机启动时指定的Java堆最大值，再进行内存分配         </li>
<li>如果内存充足，就完成内存的分配       </li>
<li>如果上一步还是分配失败，就再次调用GC，并将参数标记为true，<strong>表示要回收软引用的对象</strong>           </li>
<li>GC完毕后，再次尝试分配，成功就返回；不成功也就抛出OOM了       </li>
</ol>
<blockquote>
<p>以上内容参考自：<a href="https://blog.csdn.net/luoshengyang/article/details/41688319" target="_blank" rel="noopener">老罗的博客</a></p>
</blockquote>
</details>

<h2 id="5、Android-GC-流程"><a href="#5、Android-GC-流程" class="headerlink" title="5、Android GC 流程"></a>5、Android GC 流程</h2><h3 id="Art-虚拟机GC过程"><a href="#Art-虚拟机GC过程" class="headerlink" title="Art 虚拟机GC过程"></a>Art 虚拟机GC过程</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E8%99%9A%E6%8B%9F%E6%9C%BA/Art%E7%9A%84gc%E6%B5%81%E7%A8%8B.jpg" alt="Art的gc流程"></p>
<p>由图可知，非并行GC的过程如下所示：</p>
<ol>
<li>挂起所有的ART运行时线程。      </li>
<li>调用子类实现的成员函数MarkingPhase执行GC标记阶段。          </li>
<li>调用子类实现的成员函数ReclaimPhase执行GC回收阶段。       </li>
<li>恢复第2步挂起的ART运行时线程。          </li>
</ol>
<p>并行GC的过程如下所示：</p>
<ol>
<li>获取用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数MarkingPhase执行GC并行标记阶段。</li>
<li>释放用于访问Java堆的锁。</li>
<li>挂起所有的ART运行时线程。</li>
<li>调用子类实现的成员函数HandleDirtyObjectsPhase处理在GC并行标记阶段被修改的对象。。</li>
<li>恢复第4步挂起的ART运行时线程。</li>
<li>重复第5到第7步，直到所有在GC并行阶段被修改的对象都处理完成。</li>
<li>获取用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数ReclaimPhase执行GC回收阶段。</li>
<li>释放用于访问Java堆的锁。</li>
</ol>
<p>从上面的分析就可以看出，并行GC和非并行GC的区别在于：</p>
<ol>
<li>非并行GC的标记阶段和回收阶段是在挂住所有的ART运行时线程的前提下进行的，因此，只需要执行一次标记。         </li>
<li>并行GC的标记阶段只锁住了Java堆，因此它不能阻止那些不是正在分配对象的ART运行时线程同时运行，而这些同进运行的ART运行时线程可能会引用了一些在之前的标记阶段没有被标记的对象。如果不对这些对象进行重新标记的话，那么就会导致它们被GC回收，造成错误。因此，与非并行GC相比，并行GC多了一个处理脏对象的阶段。所谓的脏对象就是我们前面说的在GC标记阶段同时运行的ART运行时线程访问或者修改过的对象。        </li>
<li>并行GC并不是自始至终都是并行的，例如，处理脏对象的阶段就是需要挂起除GC线程以外的其它ART运行时线程，这样才可以保证标记阶段可以结束。         </li>
</ol>
</details>


<h3 id="Dalvik-虚拟机垃圾收集过程"><a href="#Dalvik-虚拟机垃圾收集过程" class="headerlink" title="Dalvik 虚拟机垃圾收集过程"></a>Dalvik 虚拟机垃圾收集过程</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Dalvik 虚拟机使用 Mark-Sweep 算法来进行垃圾收集<br>Dalvik 执行GC 时会有一些选项：</p>
<ul>
<li>isPartial，为true 时，表示仅仅回收Active 堆的垃圾；为false时，表示同时回收Active 堆和Zygote 堆的垃圾    </li>
<li>isConcurrent：为true时，表示执行并行GC，false时，表示非并行GC    </li>
<li>doPreserve：为true的时候，表示不回收软引用的对象；false的时候，表示回收软引用对象<br>Dalvik在如下几种情况会触发GC：</li>
<li>分配对象时，内存不足触发GC    </li>
<li>已经分配的内存达到一定阈值时触发GC    </li>
<li>调用 System.gc 、VMRuntime.gc 或者收到信号触发 GC    </li>
<li>准备抛出 OOM 前而最后进行的 GC<br>GC线程在空闲达到一定时间后，会调用函数对Java堆进行裁剪，将一些没有用到的内存交还给内核。<br>dalvik 的GC 流程(并行和非并行情况)如下图所示：<br><img src="/assets/%E9%9D%A2%E8%AF%95/java%E8%99%9A%E6%8B%9F%E6%9C%BA/dalvik%E7%9A%84gc%E6%B5%81%E7%A8%8B.jpg" alt="dalvik虚拟机gc流程"></li>
</ul>
<h3 id="哪些对象可以做-GC-Root"><a href="#哪些对象可以做-GC-Root" class="headerlink" title="哪些对象可以做 GC Root"></a>哪些对象可以做 GC Root</h3><ul>
<li>虚拟机栈引用的对象    </li>
<li>本地方法栈引用的对象     </li>
<li>方法区中类静态属性引用的对象     </li>
<li>方法区中常量引用的对象        </li>
<li>Dalvik 虚拟机内部创建的部分异常对象      </li>
<li>Dalvik 虚拟机内部创建的原子类     </li>
<li>注册在调试器的对象</li>
</ul>
</details>

<blockquote>
<p>以上内容参考自以上内容参考自 <a href="https://blog.csdn.net/Luoshengyang/article/details/41822747?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158968621519724843340084%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=158968621519724843340084&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v25-6-41822747.nonecase&utm_term=dalvik" target="_blank" rel="noopener">罗升阳的博客</a>  、 <a href="https://blog.csdn.net/luoshengyang/article/details/42555483" target="_blank" rel="noopener">老罗的博客</a></p>
</blockquote>
<h2 id="6、如何理解Java类加载机制"><a href="#6、如何理解Java类加载机制" class="headerlink" title="6、如何理解Java类加载机制"></a>6、<a href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&mid=2247483903&idx=1&sn=c20d3172052bd7db9a1ad6a95f112bc9&chksm=96cda0b2a1ba29a4cc9912cb1bf8a955f97ee45a7b8db48e384f1694ddbabbd4d5e7fa90f880&scene=21#wechat_redirect" target="_blank" rel="noopener">如何理解Java类加载机制</a></h2>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>第11章：Dalvik 和 ART</title>
    <url>/2019/11/23/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC11%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="Dalvik虚拟机"><a href="#Dalvik虚拟机" class="headerlink" title="Dalvik虚拟机"></a>Dalvik虚拟机</h2><p>Dalvik虚拟机 简称 DVM，第10章提到，它不是一个 jvm，主要原因是它没有遵循jvm规范实现，二者的主要区别有：</p><ul>
<li>基于的架构不同</li>
</ul><blockquote>
<p>JVM 基于栈，DVM 基于寄存器。基于栈意味着需要去栈中读写数据，所需要的指令更多，并且速度更慢，对于性能优先的移动设备，显然是不合适的。</p>
</blockquote><a id="more"></a>


<ul>
<li>执行的字节码不同</li>
</ul>
<blockquote>
<p>在Java SE 程序中，Java 类被编译成一个或者多个.class 文件，并被打包成 jar 文件，之后JVM 会通过相应的 .class 和 jar 文件获取相应的字节码；而DVM 会用dx工具将所有的 .class 文件转换为一个 .dex 文件，然后DVM 从该 .dex 文件中读取指令和数据。<br>.jar文件里面包含多个.class 文件，每个.class文件包含了该类的常量池、类信息、属性等，当JVM 加载.jar文件的时候，会加载里面所有的.class文件，JVM 这种加载方式很慢(首先就是很多io操作)，对于内存有限的移动设备并不合适；而.dex文件将所有的.class里面所包含的信息全部整合到一块了，这样再加载就减少了I/O操作，加快查找速度；并且，相对Android而言，.class中有许多冗余信息，dex工具会去掉冗余信息。</p>
</blockquote>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC11%E7%AB%A0/dalvik%E4%B8%8Ejvm%E6%89%A7%E8%A1%8C%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="DVM与JVM执行的字节码不同"></p>
<ul>
<li>DVM 允许在有限的内存中同时运行多个进程</li>
</ul>
<blockquote>
<p>在Android中，每个应用都运行在一个DVM中，每个DVM 实例都运行在一个独立的进程中，这样，某一个虚拟机崩溃的时候不会导致其他app也关闭。</p>
</blockquote>
<ul>
<li>DVM 由Zygote创建和初始化</li>
</ul>
<blockquote>
<p>在第2章有介绍<strong>Zygote，它是一个DVM进程</strong>，当系统需要创建一个应用程序时，Zygote就会fork自身，快速地创建和初始化一个DVM实例。对于一些只读的库，所有的DVM实例都会和Zygote共享一块内存区域，节省内存开销。</p>
</blockquote>
<ul>
<li>DVM 有共享机制</li>
</ul>
<blockquote>
<p>DVM 的共享机制可以使<strong>不同应用之间在运行时可以共享相同的类</strong>，这带来更高的效率；而JVM不具有这种机制，不同的程序，打包以后的程序都是彼此独立的，即便它们在包里使用了同样的类，运行时也是单独加载和运行的。</p>
</blockquote>
<h3 id="DVM-运行时堆"><a href="#DVM-运行时堆" class="headerlink" title="DVM 运行时堆"></a>DVM 运行时堆</h3><p>DVM运行时堆使用标记-清除算法进行GC，它由两个Space以及多个辅助数据结构组成，两个Space分别是：Zygote Space(Zygote Heap) 和 Allocation Space(Active Heap)，前者用于管理Zygote进程在启动过程中预加载和创建的对象，并且Zygote Space不会触发GC，Zygote 进程和应用进程之间会共享Zygote Space。在Zygote 进程fork第一个子进程前，会把Zygote Space 分为两部分，原来已经被使用的部分对仍旧叫做Zygote Space，而未使用的那部分堆叫做 Allocation Space ，以后的对象都会在 Allocation Space上进行分配和释放。</p>
<h2 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h2><p>Android 4.4 的时候发布了ART虚拟机，但是4.4版本默认还是使用DVM，Android 5.0 及以后版本默认采用ART，从此，DVM退出历史舞台。</p>
<h3 id="ART-与-Dalvik-区别"><a href="#ART-与-Dalvik-区别" class="headerlink" title="ART 与 Dalvik 区别"></a>ART 与 Dalvik 区别</h3><p>ART 与 Dalvik 的区别主要有4点：</p>
<ul>
<li>DVM 是为32位CPU涉及的，而ART支持64位并且兼容32位 CPU。    </li>
<li>ART 对垃圾回收机制进行了改进，将 GC 暂停由2次减少为1次，并且频繁执行并行垃圾收集。    </li>
<li>ART 的运行时堆空间划分和DVM不同。    </li>
<li>DVM中应用每次运行时，字节码通过 JIT 编译器编译为机器码，使得应用程序运行效率低下；而在ART中，系统在安装应用程序时会进行一次AOT(ahead of time compilation,预编译)，将字节码预先编译成机器码并存储在本地，这样应用程序每次运行时就不需要执行编译了。</li>
</ul>
<blockquote>
<p>ART也有两个主要缺点：一是AOT使应用安装时间变长，二是预编译的机器码占用的存储空间比较大。为了解决上面的缺点，Android 7.0 版本在ART中加入了JIT编译器，作为AOT的补充：在安装应用时不会将字节码全部编译成机器码，而是在运行中将热点代码编译器机器码，以达到缩短应用安装时间并节省存储空间。</p>
</blockquote>
<p>更详细的内容，可以参考<a href="https://source.android.google.cn/devices/tech/dalvik/gc-debug" target="_blank" rel="noopener">官网上的描述</a></p>
<h3 id="ART-运行时堆"><a href="#ART-运行时堆" class="headerlink" title="ART 运行时堆"></a>ART 运行时堆</h3><p>与DVM 的GC不同的是，ART采用多种垃圾收集方案，每个方案会运行不同的垃圾收集器，默认是采用 CMS(Concurrent Mark-Sweep)方案，主要有sticky-CMS 和 partial-CMS，不同的CMS方案，ART运行时堆得空间划分也不同，默认由4个Space和多个辅助结构组成，采用标记-清除算法时，两种虚拟机运行时堆对比图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC11%E7%AB%A0/dalvik%E4%B8%8Eart%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4.png" alt="两种虚拟机运行时堆对比"></p>
<p>由图可以看到ART的4个Space，其中，Zygote Space 、Allocation Space 和 DVM 中的作用一样，ImageSpace 用来存放一些预加载类，Large Object Space 用来分配一些大对象。其中Zygote Space 与 Image Space 是进程共享的。</p>
<h3 id="ART-的GC-日志"><a href="#ART-的GC-日志" class="headerlink" title="ART 的GC 日志"></a>ART 的GC 日志</h3><ol>
<li>GC Reason<br>ART 虚拟机GC日志中会包含产生这次GC原因，主要会有：</li>
</ol>
<ul>
<li>Concurrent: 并发GC，在后台线程运行GC，不会使App的线程暂停，不会阻止内存分配。    </li>
<li>Alloc： 当堆内存已满，App尝试分配内存而引起的GC，<strong>这个GC发生在正在分配内存的线程中。</strong>    </li>
<li>Explicit： App显式请求垃圾收集，比如 System.gc()。    </li>
<li>NativeAlloc： Native 内存分配时触发的GC。    </li>
</ul>
<ol start="2">
<li>垃圾收集器名称<br>ART 虚拟机GC日志中会包含所使用的收集器名称，主要会有：</li>
</ol>
<ul>
<li>Concurrent Mark Sweep(CMS)： 它是以最短收集暂停时间为目标的收集器，采用标记-清除算法，<strong>能释放除了Image Space外的所有空间</strong>    </li>
<li>Concurrent Partial Mark Sweep： 能释放除了Image Space 和 Zygote space 意外的所有空间    </li>
<li>Concurrent Sticky Mark Sweep： 粘性收集器，<strong>基于分代的垃圾收集思想</strong>，只能释放自上次GC以来分配的对象，这个收集器扫描比较频繁，因为它很快并有很短的暂停时间。    </li>
<li>Marksweep + Semispace：非并发GC，复制GC用于堆转换以及堆碎片整理。    </li>
</ul>
<h2 id="DVM-和-ART-的诞生"><a href="#DVM-和-ART-的诞生" class="headerlink" title="DVM 和 ART 的诞生"></a>DVM 和 ART 的诞生</h2><p>它们是从Zygote进程诞生的，这样，Zygote进程就持有了DVM或者ART的实例，此后，Zygote进程每次fork自身创建新的应用进程时，应用程序进程也就得到了 DVM 或者ART 的实例，即每个应用进程都有一个单独的虚拟机实例。<strong>这样做的好处是，无需在每次启动应用程序进程时都要创建DVM或者ART，从而加快了应用程序进程的启动速度</strong>。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android进阶解密</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章：Android系统启动</title>
    <url>/2019/11/22/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC2%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="init-进程启动过程"><a href="#init-进程启动过程" class="headerlink" title="init 进程启动过程"></a>init 进程启动过程</h2><p>init进程是Android系统中<strong>用户空间的第一个进程</strong>，进程号为1，它被赋予了很多重要职责，比如创建 Zygote 和属性服务等。</p><h3 id="引入init进程"><a href="#引入init进程" class="headerlink" title="引入init进程"></a>引入init进程</h3><p>了解Android系统启动流程的前几步，可以有助于引入init进程：</p><ol>
<li>启动电源以及系统启动。当电源按下时，引导芯片代码从预定义的地方(固化在ROM中)开始执行，<strong>加载引导程序到RAM中</strong>，然后执行。    </li>
<li>引导程序BootLoader。它是Android操作系统开始运行前的一个小程序，主要作用是把系统OS拉起来。    </li>
<li>Linux 内核启动。linux内核启动完成系统设置后，<strong>它首先在系统文件中寻找init.rc，并启动init进程。</strong>     </li>
<li>init进程启动。init进程的工作比较多，主要用于初始化、启动属性服务 以及 启动Zygote进程。</li>
</ol><a id="more"></a>


<h3 id="init进程入口"><a href="#init进程入口" class="headerlink" title="init进程入口"></a>init进程入口</h3><p>在Linux内核加载完成后，首先在系统文件中查找init.rc，并启动init进程。init的main函数中做了很多事情，我们主要了解以下几点：</p>
<ul>
<li>调用property_init 函数对属性初始化，调用 start_property_service函数启动属性服务。    </li>
<li>调用 signal_handler_init <strong>设置子进程信号处理函数，主要用于防止init进程的子进程成为僵尸进程。</strong>为了防止僵尸进程的出现，系统会在子进程暂停和终止的时候发出 SIGCHLD信号，signal_handler_init就是用来接收这个信号的。</li>
</ul>
<blockquote>
<p>僵尸进程：在linux中，父进程使用fork创建子线程，在子线程终止后，如果父进程并不知道子线程终止了，那么还会在系统进程表为它保留一定的信息。僵尸进程主要危害就是占用系统进程表，可能导致系统进程表被耗尽而无法创建新的进程。假设init的子进程Zygote终止了，signal_handler_init 函数会找到Zygote进程并移除所有Zygote进程信息，再重启Zygote。</p>
</blockquote>
<h3 id="解析-init-rc"><a href="#解析-init-rc" class="headerlink" title="解析 init.rc"></a>解析 init.rc</h3><p>init.rc 是一个配置文，是由Android 初始化语言编写的脚本，为了分析如何创建Zygote，我们主要查看其中的Service类型语句，在Android 8.0 及以后，每个Service 都对应一个rc 文件。init.rc 中定义Service 的格式如下：</p>
<blockquote>
<p>service <name> <pathname> [ <argument> ] * //&lt;service 的名字〉〈执行程序路径〉〈传递参数〉</argument></pathname></name></p>
</blockquote>
<p>举个栗子，zygote的Service配置文件就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin -- zygote --startsystem- server </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">main</span> </span></span><br><span class="line"><span class="class"><span class="title">priority</span> -20 </span></span><br><span class="line"><span class="class"><span class="title">user</span> <span class="title">root</span> </span></span><br><span class="line"><span class="class"><span class="title">group</span> <span class="title">root</span> <span class="title">readproc</span></span></span><br></pre></td></tr></table></figure>

<p>来大概分析代码意思，Service用于通知 init 进程创建名为 zygote 的进程，这个进程执行程序的路径为 /system/bin/app_process64，其中 <font color="#008000">class main</font>指的是Zygote 的classname 为 main。<strong>后面的代码是要传给 app_process64的参数。</strong></p>
<h3 id="解析Service类型语句"><a href="#解析Service类型语句" class="headerlink" title="解析Service类型语句"></a>解析Service类型语句</h3><p>init.rc中Service类型语句使用ServiceParser类来解析，它将init.rc中的service解析生成的Service对象加入到 Service 链表中。</p>
<h3 id="init-启动Zygote"><a href="#init-启动Zygote" class="headerlink" title="init 启动Zygote"></a>init 启动Zygote</h3><p>我们来了解init是如何启动Service的，这里主要讲解 Zygote这个Service。前面提到，在Zygote的启动脚本中描述Zygote的classname为<font color="#008000">main</font>，在init.rc中会遍历 解析Service类型语句 过程生成的Service链表，找到 classname 为main的Zygote，如果Zygote Service 已经运行，则不再启动，否则就调用fork函数创建子进程，并在子进程中调用Service的main函数，Zygote的main函数代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main （<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv []) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123; </span><br><span class="line">        runtime.start （<span class="string">"com.android.internal.os.Zygoteinit”， args, zygote) ; //1</span></span><br><span class="line"><span class="string">    &#125; else if (className) &#123; </span></span><br><span class="line"><span class="string">        runtime .start （” com android nternal.os.Runtimeinit ”， args zygote) ; </span></span><br><span class="line"><span class="string">    &#125; else&#123;</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>从注释1处可以看到调用runtime的start函数启动了 Zygote 。</p>
<h3 id="属性服务"><a href="#属性服务" class="headerlink" title="属性服务"></a>属性服务</h3><p>Windows上有注册表管理器以键值对的形式记录用户软件的一些使用信息，即使系统或者软件重启，其还是能够根据之前注册表中的记录进行相应初始化工作。Android中也提供了类似机制，叫做<strong>属性服务</strong>。init 进程启动时会启动属性服务，并为其分配内存存储这些属性，如果需要这些属性直接读取即可。启动属性服务的主要代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">property_set_fd =create_socket(PROP_SERVICE_NAME ,SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,<span class="number">0666</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>); <span class="comment">//1</span></span><br><span class="line">...</span><br><span class="line">listen(property_set_fd, <span class="number">8</span>); <span class="comment">//2  </span></span><br><span class="line">register_epoll_handler(property_set_fd , handle_property_set_fd) ; <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>由代码可知，首先创建非阻塞的Socket，并对property_set_fd 监听，这样创建的Socket 就成为server，也就是属性服务；listener的参数意味着可以同时为8个试图设置属性的用户服务。最后使用epoll 来监听property_set_fd ：<strong>当property_set_fd中有数据到来时，init进程将调用handle_property_set_fd函数处理。</strong></p>
<blockquote>
<p>epoll是linux下多路复用I/O接口，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU的利用率。</p>
</blockquote>
<p>对属性进行修改时，首先判断属性的合法性，之后查找属性，如果属性存在就更新属性值，否则添加属性。</p>
<h3 id="init进程启动总结"><a href="#init进程启动总结" class="headerlink" title="init进程启动总结"></a>init进程启动总结</h3><p>主要做了3件事：1、创建和挂载启动所需文件目录  2、启动服务属性  3、解析init.rc ，并启动 Zygote 进程。</p>
<h2 id="Zygote进程启动过程"><a href="#Zygote进程启动过程" class="headerlink" title="Zygote进程启动过程"></a>Zygote进程启动过程</h2><p>在Android系统中，DVM(或者ART)、应用程序进程、SystemServer进程等都是由Zygote进程创建的。由于Zygote在启动时会创建 DVM(或者ART)，因此其fork的应用程序进程和SystemServer进程可以在内部获取一个 DVM 或者 ART。</p>
<p>在Zygote 中通过 JNI 调用 ZygoteInit(<font color="#008000">ZygoteInit是由Java编写的</font>)的 main 方法后，Zygote 便进入了Java 框架层，<strong>此前没有任何代码进入Java框架层的。</strong>即Zygote开创了Java框架层。</p>
<p>ZygoteInit的main方法中主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/com/android/internal/os/Zygotelnit.java </span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//创建一个 Server 端的 Socket socketName 的值为"zygote"</span></span><br><span class="line">zygoteServer.registerServerSocket(socketName);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//预加载类和资源</span></span><br><span class="line">preload(b otT U.ngsTraceLog);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (startSystemServer) &#123; </span><br><span class="line">    <span class="comment">//启动 SystemServer 进程</span></span><br><span class="line">    startSystermServer(abiList, socketName, zygoteServer);</span><br><span class="line">&#125;</span><br><span class="line">／／等待 AMS 请求</span><br><span class="line">zygoteServer.runSelectLoop(abiList);</span><br></pre></td></tr></table></figure>

<p>由代码可知，通过 registerServerSocket 方法创建一个Server端的Socket ，<strong><font color="#008000">这个名为 “zygote” 的Socket 用于等待 ActivityManagerService 请求 Zygote 来创建新的应用程序进程</font></strong>。总结一下，ZygoteInit 的main方法总共做了4件事：</p>
<ol>
<li>创建一个Server端的Socket    </li>
<li>预加载类和资源    </li>
<li>启动 SystemServer 进程    </li>
<li>等待 AMS 请求创建新的应用程序进程    </li>
</ol>
<h3 id="Zygote-进程启动总结"><a href="#Zygote-进程启动总结" class="headerlink" title="Zygote 进程启动总结"></a>Zygote 进程启动总结</h3><p>Zygote进程启动共做了以下几件事：</p>
<ol>
<li>创建AppRuntime ，并调用其start方法，启动Zygote 进程    </li>
<li>创建java虚拟机并未Java虚拟机注册 JNI 方法    </li>
<li>通过 JNI 调用ZygoteInit 的main函数进入Zygote 的Java 框架层    </li>
<li>通过 registerServerSocket 创建服务端 Socket ，循环等待AMS 请求来创建新的应用程序进程。    </li>
<li>启动 SystemServer    </li>
</ol>
<h2 id="SystemServer-处理过程"><a href="#SystemServer-处理过程" class="headerlink" title="SystemServer 处理过程"></a>SystemServer 处理过程</h2><p>SystemServer 进程主要用于创建系统服务，如 AMS、WMS、PMS 。在 ZygoteInit.java 中启动了 SystemServer，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span> <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException｛</span></span><br><span class="line"><span class="function">    <span class="comment">//当前运行在 SystemServer 进程中</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(p == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote (socketName ); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭 Zygote 进程创建的 Socket</span></span><br><span class="line">        zygoteServer . closeServerSocket() ; <span class="comment">//1 </span></span><br><span class="line">        handleSystemServerProcess(parsedArgs) ; <span class="comment">//2 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p>由以上代码可知，SystemServer 进程复制了 Zygote 进程的地址空间，因此也会得到Zygote 创建的 server Socket，这个socket对SystemServer 没有用处，因此在代码 1处将其关闭，之后通过 handleSystemServerProcess 方法启动 SystemServer 进程。接下来，在ZygoteInit中<strong>创建了 PathClassLoader</strong>，并且通过native 方法 ZygoteInit.nativeZygotelnit <strong>启动了Binder线程池</strong>，之后进入 SystemServer 的main 方法。</p>
<p>SystemServer 的run 方法中用  SystemServiceManager 启动了  ActivityManagerService、 PackageManagerService 等服务。在PackageManagerService 创建完成后，将其注册到 ServiceManager 中，<font color="#008000">ServiceManager 用于管理系统中各种Service，用于系统C/S 架构中的Binder 通信机制：Client端要使用某个Service，需要先到 ServiceManager 中查询Service 的相关信息，然后与Service 所在的Server 进程建立通信通路，这样Client就可以使用Service 了</font>。</p>
<h3 id="SystemServer-进程总结"><a href="#SystemServer-进程总结" class="headerlink" title="SystemServer 进程总结"></a>SystemServer 进程总结</h3><p>SystemServer 进程被创建后，主要工作：</p>
<ol>
<li>启动Binder 线程池，这样可以与其他进程通信。    </li>
<li>创建 SystemServiceManager，创建和管理系统服务    </li>
<li>启动各种服务    </li>
</ol>
<h2 id="Launcher-启动过程"><a href="#Launcher-启动过程" class="headerlink" title="Launcher 启动过程"></a>Launcher 启动过程</h2><p>系统启动的最后一步是启动一个应用程序来显示系统中已经安装的应用程序，即 Launcher。Launcher 在启动过程中请求 PackageManagerService 获取系统中已经安装的应用程序信息，并且将信息封装成一个个快捷图标列表显示在系统屏幕上，用户就可以通过点击图标来启动相应的应用程序了。Launcher 的启动过程时序图如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC2%E7%AB%A0/Launcher%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE.jpeg" alt="Launcher的启动过程时序图"></p>
<p>启动Launcher的入口方法为AMS 的systemReady 方法，该方法在SystemServer 的startOtherService中被调用，之后调用 ActivityStack 的resumeTopActivityUncheckedLocked 方法，ActivityStack 用于描述Activity 栈的。最终调用到 AMS 的 startHomeActivityLocked 方法，在该方法中，创建了 Launcher 启动所需的 Intent，并且在一系列判断后，将该Intent 的 Action 设置为 Intent.ACTION_MAIN 、Category 为 Intent.CATEGORY_HOME，并且在 Launcher 的AndroidManifest 中也是这么配置的。</p>
<p>经过以上操作，com.android.launcher3.Launcher 的Activity 就成为了主 Activity，此时，如果Launcher 还未启动，AMS 就会调用 ActivityStarter 的 startHomeActivityLocked 来启动 Launcher 。</p>
<h2 id="Android系统启动流程"><a href="#Android系统启动流程" class="headerlink" title="Android系统启动流程"></a>Android系统启动流程</h2><p>结合前面几节内容，可以总结出Android系统启动流程：</p>
<ol>
<li><p>启动电源以及系统启动     </p>
<blockquote>
<p>按下电源键，从预定义地方开始执行，加载BootLoader 到RAM。</p>
</blockquote>
</li>
<li><p>引导程序BootLoader     </p>
<blockquote>
<p>主要作用是拉起系统OS。</p>
</blockquote>
</li>
<li><p>Linux 内核启动      </p>
<blockquote>
<p>内核启动，设置缓存、计划表、加载驱动等，之后寻找 init.rc 文件，并启动init 进程。</p>
</blockquote>
</li>
<li><p>init 进程启动      </p>
<blockquote>
<p>初始化和启动属性服务，并启动 Zygote 进程。</p>
</blockquote>
</li>
<li><p>Zygote进程启动     </p>
<blockquote>
<p>创建Java虚拟机，并未Java虚拟机注册 JNI 方法，创建服务端 Socket 循环等待AMS 请求来创建新的应用程序进程</p>
</blockquote>
</li>
<li><p>SystemServer 进程启动     </p>
<blockquote>
<p>启动Binder 线程池 和 SystemServiceManager ，并启动各种服务。</p>
</blockquote>
</li>
<li><p>Launcher启动   </p>
<blockquote>
<p>SystemServer 进程启动的 AMS 会启动 Launcher，Launcher 会将已安装的应用显示到界面上。</p>
</blockquote>
</li>
</ol>
<p>用图表示就是：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC2%E7%AB%A0/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.jpeg" alt="Android系统启动流程图"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android进阶解密</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-网上搜集的题目(一)</title>
    <url>/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E4%B8%8A%E6%90%9C%E9%9B%86%E7%9A%84%E9%A2%98%E7%9B%AE(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="谈谈对this和super的认识"><a href="#谈谈对this和super的认识" class="headerlink" title="谈谈对this和super的认识"></a>谈谈对this和super的认识</h2><h2 id="闭包和内部类的区别"><a href="#闭包和内部类的区别" class="headerlink" title="闭包和内部类的区别"></a>闭包和内部类的区别</h2><h2 id="Java-多态实现的机制是什么"><a href="#Java-多态实现的机制是什么" class="headerlink" title="Java 多态实现的机制是什么"></a>Java 多态实现的机制是什么</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>重写和重载</p>
</details><h2 id="final-关键字的作用"><a href="#final-关键字的作用" class="headerlink" title="final 关键字的作用"></a>final 关键字的作用</h2><h2 id="多维数组在内存上是怎么存储的"><a href="#多维数组在内存上是怎么存储的" class="headerlink" title="多维数组在内存上是怎么存储的"></a>多维数组在内存上是怎么存储的</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Java 中的多维数组就是通过一维数组来实现的，只不过这个一维数组中的元素还是多维数组，比如如下声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>它实际上大致等同于如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][][];  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;  </span><br><span class="line">  a[i] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length; j++) &#123;  </span><br><span class="line">    a[i][j] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码参考自<a href="https://www.iteye.com/blog/rednaxelafx-1050144" target="_blank" rel="noopener">iteye中的博客</a></p>
<p>如果要自己用一维数组去实现二维(或者更多维)的数组，可以使用类似规律： k = j*(j-1)/2 + i -1 来计算出在一维数组中的下标 k 值。</p>
</details><a id="more"></a>



<h2 id="Java-的异常体系的理解"><a href="#Java-的异常体系的理解" class="headerlink" title="Java 的异常体系的理解"></a>Java 的异常体系的理解</h2><h2 id="运行时异常-与-非运行时异常"><a href="#运行时异常-与-非运行时异常" class="headerlink" title="运行时异常 与 非运行时异常"></a>运行时异常 与 非运行时异常</h2><h2 id="NIO-BIO-AIO"><a href="#NIO-BIO-AIO" class="headerlink" title="NIO/BIO/AIO"></a>NIO/BIO/AIO</h2><h2 id="Collection-与-Map-的区别"><a href="#Collection-与-Map-的区别" class="headerlink" title="Collection 与 Map 的区别"></a>Collection 与 Map 的区别</h2><h2 id="如何深拷贝List-集合"><a href="#如何深拷贝List-集合" class="headerlink" title="如何深拷贝List 集合"></a>如何深拷贝List 集合</h2><h2 id="Set-如何保证唯一性的"><a href="#Set-如何保证唯一性的" class="headerlink" title="Set 如何保证唯一性的"></a>Set 如何保证唯一性的</h2><h2 id="谈谈Java集合中那些线程安全的集合-amp-实现原理"><a href="#谈谈Java集合中那些线程安全的集合-amp-实现原理" class="headerlink" title="谈谈Java集合中那些线程安全的集合 &amp; 实现原理"></a>谈谈Java集合中那些线程安全的集合 &amp; 实现原理</h2><h2 id="Collection-和-Collections-的区别"><a href="#Collection-和-Collections-的区别" class="headerlink" title="Collection 和 Collections 的区别"></a>Collection 和 Collections 的区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Collection是接口，Collections 是帮助类，能实现排序(Collections.sort() )等功能</p>
</details>

<blockquote>
<p>以上题目参考自<a href="https://gitee.com/ClAndEllen/AndroidFaceInterview?_from=gitee_search" target="_blank" rel="noopener">gitee上博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-网络知识</title>
    <url>/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="1、TCP-IP-三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）"><a href="#1、TCP-IP-三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）" class="headerlink" title="1、TCP/IP 三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）"></a>1、TCP/IP 三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）</h2><p><strong>首先要会画 三次握手和四次挥手 的图。很重要，画了两次错了</strong></p><h3 id="3次握手的示意图如下："><a href="#3次握手的示意图如下：" class="headerlink" title="3次握手的示意图如下："></a>3次握手的示意图如下：</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p><p>三次握手过程：TCP发起的一方A，由操作系统生成一个序列号 n，以这个n为原点，对自己每个将要发送的数据进行编号，连接的另一方 B 会对A每次发送的数据进行确认，如果A收到B的确认编号2001，则可以认为 n~2000编号已经全部到达B。</p><a id="more"></a>


<h3 id="为什么三次握手"><a href="#为什么三次握手" class="headerlink" title="为什么三次握手"></a>为什么三次握手</h3><ol>
<li>首先，三次握手证明双方收发能力正常    </li>
<li>其次，如果只需要两次握手，那第二次(从server发到client端)之后server就分配资源了，但是如果第二次丢失了，那就造成资源浪费    </li>
<li>还有，如果client没有收到确认，就会再次发送握手连接，如果服务端先接到了第二个消息，然后发送返回确认，双方通信完毕，关闭。这时候第一个请求到了服务端，服务端确认，然而客户端已经关闭了，不理睬，这时候服务端只能一直等。    </li>
<li>还有，握手就确认了双方的序列号规则    </li>
</ol>
<h3 id="可以不握手吗？"><a href="#可以不握手吗？" class="headerlink" title="可以不握手吗？"></a>可以不握手吗？</h3><p>tcp实现可靠通信与 报文序号和确认号(ack) 是分不开的，我们知道握手是干的啥，其中就有告知初始序号的功能，所以不能不握手。</p>
<h3 id="4次挥手示意图："><a href="#4次挥手示意图：" class="headerlink" title="4次挥手示意图："></a>4次挥手示意图：</h3><p><img src="/assets/%E9%9D%A2%E8%AF%95/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p>
<p>由上图看出，由client端发起挥手，server给client的2次回复中，一次是确认信息ack，一次是数据的传送，那可不可以只要3次挥手呢？答案是可能的，TCP是全双工的，Client在没有数据需要发送给Server后，就发送FIN告知server，然后终止对server发送消息，但这个时候server还以发送数据给client，这时候需要4次；但是如果server收到client的FIN后再也没有数据要发给client了，那么 对client的ack包和server自己的FIN包就能合并成一个包发送过去，四次挥手变成3次。</p>
<p>了解完挥手完成后，可能还想更深入了解 TIME_WAIT，可以查看<a href="https://glassx.github.io/2018/05/21/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0/" target="_blank" rel="noopener">之前写的这篇</a>。</p>
<h2 id="2、延伸-握手可能有什么安全问题"><a href="#2、延伸-握手可能有什么安全问题" class="headerlink" title="2、延伸-握手可能有什么安全问题"></a>2、延伸-握手可能有什么安全问题</h2><p>首先，发起请求时候的序列是随机的，为什么是随机的呢？想想如果是固定的从0开始，那么客户端发送多次握手(重传)，那么，当新连接建立之后，如果上一次的请求再过来了，序列还是 0 ，那就乱了。相反，如果序列不固定，那么上一次的过来，我只要和新连接这里对比下 序列号 就知道是否合法了。</p>
<ul>
<li>client第一个 SYN 包丢失，这个无所谓，后续触发重传机制，隔5s，24s等     </li>
<li>server 收到 SYN ，但是回复的 SYN，ACK 丢失，也会触发重传，可能依次隔 3s,6s,12s 等    </li>
<li>client 最后依次发送的 ACK 丢了，server 因为没收到 ACK 而实现重传，但是client 已经进入 ESTABLISHED 状态了。因为多数情况下，client 发送完最后的 ACK之后，就认为连接建立，开始发送数据。现实中的情况是，在这种情况下 server 收到 client 的数据会进入 ESTABLISH 状态，并会认为数据有效。     </li>
<li>如果client 故意不发最后一次 ACK，那么服务端处于<strong>半连接状态</strong>，如果这种半连接很多的话，server 端很有压力，因为需要一直重传</li>
</ul>
<blockquote>
<p>以上内容参考自<a href="https://zhuanlan.zhihu.com/p/102197175" target="_blank" rel="noopener">知乎上的文章</a>、<a href="https://zhuanlan.zhihu.com/p/85557012" target="_blank" rel="noopener">知乎上的文章1</a>、<a href="https://www.zhihu.com/question/53658729/answer/498879547" target="_blank" rel="noopener">知乎-泪花的回答</a>     </p>
</blockquote>
<h2 id="3、延伸-三次握手可以携带数据吗？"><a href="#3、延伸-三次握手可以携带数据吗？" class="headerlink" title="3、延伸-三次握手可以携带数据吗？"></a>3、延伸-三次握手可以携带数据吗？</h2><p>第一次、第二次不可以，第三次可以。想想为什么？</p>
<ul>
<li>假如第一次允许带数据，那么攻击者只需要在第一次SYN中放入大量数据，根本不考虑服务器接收能力，这会让server 花费很长时间和很多空间来处理这些报文       </li>
<li>并且，第一次不知道server 是否有接收能力；如果放第二次，server 也不知道clien 是否有接收能力。    </li>
</ul>
<blockquote>
<p>以上内容参考自<a href="https://zhuanlan.zhihu.com/p/102197175" target="_blank" rel="noopener">知乎上的文章</a>、<a href="https://zhuanlan.zhihu.com/p/85557012" target="_blank" rel="noopener">知乎上的文章1</a>、<a href="https://www.zhihu.com/question/53658729/answer/498879547" target="_blank" rel="noopener">知乎-泪花的回答</a></p>
</blockquote>
<h2 id="4、引申——为什么要等待2MSL？"><a href="#4、引申——为什么要等待2MSL？" class="headerlink" title="4、引申——为什么要等待2MSL？"></a>4、引申——为什么要等待2MSL？</h2><p>原因有二：<strong>保证TCP协议的全双工连接能够可靠关闭</strong> 以及 <strong>保证这次连接的重复数据段从网络中消失</strong></p>
<p>第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p>
<p>第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p>
<h2 id="5、IP地址分类（A-B-C-D类）"><a href="#5、IP地址分类（A-B-C-D类）" class="headerlink" title="5、IP地址分类（A/B/C/D类）"></a>5、IP地址分类（A/B/C/D类）</h2><p>IP地址由四段组成，每个字段是一个字节，即4个字节、 每个字节有8位，最大值是255，IP地址 = 网络号+主机号。分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/ip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" alt="ip地址分类"></p>
<p>由图可知：</p>
<blockquote>
<p>A类：前1个字节(8位)为网络号，后3个字节(24位)为主机号。A类第1位必须是0<br>B类：前2个字节(16位)为网络号，后2个字节(16位)为主机号。B类前两位固定为10<br>C类：前3个字节(24位)为网络号，后1个字节(8位)为主机号。C类前3位固定为110<br>D类： 是多播地址，一般用于多路广播用户。该类IP地址的最前面为1110<br>E类： 是保留地址。该类IP地址的最前面为1111</p>
</blockquote>
<h2 id="6、TCP与UDP区别"><a href="#6、TCP与UDP区别" class="headerlink" title="6、TCP与UDP区别"></a>6、TCP与UDP区别</h2><ol>
<li>UDP发送数据前无需建立连接，TCP需要握手建立连接。    </li>
<li>UDP尽最大努力交付,不保证可靠交付；TCP提供可靠交付。    </li>
<li>UDP面向报文，对应用程序交下来的报文，在添加首部之后就交付给Ip层，不会对报文拆分；TCP面向字节流，会对应用程序的报文进行拆分。    </li>
<li>UDP支持一对一、一对多、多对一和多对一的通信；TCP全双工通信，并且只能点对点通信，允许通信双方在任何时候均能通信。    </li>
<li>UDP首部开销小，TCP开销大（UDP 8个字节，TCP20个字节）。    </li>
<li>UDP没有拥塞控制，在网络条件差的情况下发送端也不会降低发送速率；TCP有拥塞控制，慢开始避免拥塞，快重传、快恢复。  </li>
<li>TCP 通过滑动窗口实现流量控制，UDP 无。  </li>
</ol>
<p>需要参考<a href="https://zhuanlan.zhihu.com/p/108822858" target="_blank" rel="noopener">知乎上的讲解</a>)重写一下</p>
<h2 id="7、引申-TCP流量控制"><a href="#7、引申-TCP流量控制" class="headerlink" title="7、引申-TCP流量控制"></a>7、引申-TCP流量控制</h2><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p>
<p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.jpg" alt="tcp流量控制"></p>
<p>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。</p>
<p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p>
<h2 id="8、引申-快重传和快恢复"><a href="#8、引申-快重传和快恢复" class="headerlink" title="8、引申-快重传和快恢复"></a>8、引申-快重传和快恢复</h2><ul>
<li>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</li>
</ul>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E5%BF%AB%E9%87%8D%E4%BC%A0.webp" alt="快重传"></p>
<ul>
<li>快恢复：当发送方连续收到三个重复确认，就开始执行拥塞避免算法，缩小拥塞窗口，随后再使拥塞窗口缓慢地线性增大。</li>
</ul>
<h2 id="9、Http和Https的区别？"><a href="#9、Http和Https的区别？" class="headerlink" title="9、Http和Https的区别？"></a>9、Http和Https的区别？</h2><blockquote>
<p>Https是ssl加密传输，Http是明文传输<br>Https是使用端口443，而Http使用80<br>HttpsSSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比Http协议安全<br>Https协议需要到CA申请证书</p>
</blockquote>
<h2 id="10、中间人攻击"><a href="#10、中间人攻击" class="headerlink" title="10、中间人攻击"></a>10、中间人攻击</h2><p>带着下列问题去了解Https 安全性：</p>
<ul>
<li>为什么用了https 就是安全的？用了https就一定安全吗？    </li>
<li>https 的底层原理如何？    </li>
</ul>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="https的原理"><a href="#https的原理" class="headerlink" title="https的原理"></a>https的原理</h3><p>https的整体过程分为证书验证和数据传输阶段，具体交互如下图：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/https%E6%95%B4%E4%BD%93%E8%BF%87%E7%A8%8B.jpg" alt="https整体过程"></p>
<p>所以证书验证阶段流程就是：</p>
<ol>
<li>客户端发起https 请求     </li>
<li>服务端返回https 证书      </li>
<li>客户端验证证书是否合法</li>
</ol>
<p>数据传输阶段流程就是：</p>
<ol>
<li>证书合法后，在本地生成随机数    </li>
<li>通过公钥加密随机数，并把加密后的随机数传输给服务端    </li>
<li>服务端通过私钥对随机数解密     </li>
<li>服务端<strong>通过客户端传入的随机数构造对称加密算法</strong>，对返回结果内容进行加密后传输</li>
</ol>
<p>那我们再引申一下，为什么后来要使用对称加密传输数据。这是因为：</p>
<ul>
<li>非对称加密的效率低    </li>
<li>https 上述场景中，只有服务端保存了私钥，一对公私钥只能单向加解密，而对称加密可以实现双向的加解密</li>
</ul>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>了解以上原理之后，中间人攻击的具体流程如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="中间人攻击流程图"></p>
<p>主要包括以下步骤：</p>
<ol>
<li>本地请求被劫持(如dns劫持等)，所有请求均发送到中间人的服务器    </li>
<li>中间人<strong>返回自己自己的证书</strong>    </li>
<li>客户端创建随机数并通过中间人的证书公钥加密，之后凭随机数构造对称加密对传输内容加密    </li>
<li>中间人用私钥解密随机数，此时中间人拥有客户端的随机数，所以可以通过对称加密算法解密内容    </li>
<li>中间人再以客户端的请求内容向正规服务器发送请求，此时中间人发起的请求就是正规请求了，数据也是正规数据，所以合法，正规服务器会通过建立的安全通道返回加密数据      </li>
<li>此后流程都是合法化的了，中间人只是做了个转发而已     </li>
</ol>
<p>以上，就是中间人攻击的流程，我们日常使用的fiddler 代理，其实就很好地模拟了中间人攻击。因为我们使用fiddler 代理https 的时候，需要本地信任fiddler 的证书，其实就是中间人返回自己的证书过程，中间人攻击关键也是这一步。</p>
<p>一般客户端会验证证书的合法性，所以中间人的证书没有这么容易被信任，中间人攻击的难点也在这。</p>
</details>

<blockquote>
<p>以上内容参考自<a href="https://zhuanlan.zhihu.com/p/95293098" target="_blank" rel="noopener">知乎-Java面试那些事儿</a></p>
</blockquote>
<h2 id="11、TCP-IP-流量控制，拥塞避免，可以结合这篇文章"><a href="#11、TCP-IP-流量控制，拥塞避免，可以结合这篇文章" class="headerlink" title="11、TCP/IP 流量控制，拥塞避免，可以结合这篇文章"></a>11、TCP/IP 流量控制，拥塞避免，可以结合<a href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&mid=2247486825&idx=1&sn=db596ed4b69bd9220f6a8ad79ef308db" target="_blank" rel="noopener">这篇文章</a></h2><h2 id="12、Session-和-Cookie-的区别？"><a href="#12、Session-和-Cookie-的区别？" class="headerlink" title="12、Session 和 Cookie 的区别？"></a>12、Session 和 Cookie 的区别？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<p>HTTP是一种无状态的协议，为了分辨链接是谁发起的，Session和Cookie就是为解决这个问题而提出来的两个机制。<br><strong>Cookies是服务器下发，存储到本地机器上的一段文本，并随每一个请求发回服务器，是在客户端保持状态的方案。</strong><br>浏览器第一次发送请求时，服务器自动生成了一HashTable和一个Session ID来唯一标识这个HashTable，并将其通过响应发送回浏览器。Session的实现方式和Cookie有一定关系，一般会把session id存在Cookie中（<strong>也可以依赖于url重写</strong>），每次访问的时候将Session id带过去，服务器就根据id查找hashtable就可以识别当前用户状态了。<br>所以可以总结，cookie存在本地，session存在服务器；父路径不能享用子路径的cookies，而同一个session的窗口可以共享session；cookie没有session可靠。</p>
</blockquote>
</details>


<h2 id="13、在浏览器中输入www-baidu-com后执行的全部过程"><a href="#13、在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="13、在浏览器中输入www.baidu.com后执行的全部过程"></a>13、在浏览器中输入<a href="http://www.baidu.com后执行的全部过程" target="_blank" rel="noopener">www.baidu.com后执行的全部过程</a></h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ol>
<li><p>客户端浏览器通过DNS解析到<a href="http://www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。" target="_blank" rel="noopener">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></p>
</li>
<li><p>在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</p>
</li>
<li><p>客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
</li>
<li><p>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p>
</li>
</ol>
</details>

<h2 id="14、HTTP中，POST与GET的区别"><a href="#14、HTTP中，POST与GET的区别" class="headerlink" title="14、HTTP中，POST与GET的区别"></a>14、HTTP中，POST与GET的区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ol>
<li><p>Get是从服务器上获取数据，Post是向服务器传送数据。</p>
</li>
<li><p>Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中科院看到。</p>
</li>
<li><p>Get传送的数据量小，不能大于2KB；post传送的数据量较大，一般被默认为不受限制。</p>
</li>
<li><p>根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p>
</li>
</ol>
</details>

<h2 id="15、http2-与http1-的区别"><a href="#15、http2-与http1-的区别" class="headerlink" title="15、http2 与http1 的区别"></a>15、http2 与http1 的区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>总结一下：1)、新的二进制格式  2)、多路复用   3)、header 压缩   4)、采用新的压缩算法  5)、server push  6)、更安全的SSL</p>
<ul>
<li>新的二进制格式    </li>
</ul>
<p><strong>解释：</strong> http1 设计的时候是基于文本，http2 基于二进制格式。http2 的格式定义更接近tcp层的方式，length 定义了整个frame 的开始到结束，type 定义了frame 的类型，stream id 用作流控制。如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.jpg" alt="http2格式变化"></p>
<p>虽然看上去写一个是和http1完全不同了，实际上并没有改变http1的语义，只是把http1的header 和 body 用frame 重新封装了一层而已。他们的对应关系如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E4%B8%8Ehttp1%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.jpg" alt="http2与http1对应关系"></p>
<p>上述http1的首部信息会封装到 Header 的 frame，而相应的 body 封装到 Data frame。</p>
<ul>
<li>多路复用    </li>
</ul>
<p><strong>解释：</strong>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。一个request对应一个 stream 并分配一个id，这样一个连接上可以有多个stream，每个stream 的frame 可以随机地混杂在一起，接收方可以根据stream id 将各个frame 再归属到不同的request 里面。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/http2%E8%BF%9E%E6%8E%A5%E5%85%B1%E4%BA%AB.jpg" alt="http2连接共享"></p>
<p>http 性能优化的关键并不在于<strong>高带宽</strong>，而是<strong>低延迟</strong>，tcp 连接会随着时间进行自我“调谐”，起初会限制最大速度，如果传输成功，会随着时间提高传输的速度，这种调谐称为“慢启动”。http2 通过让所有数据流共用同一个连接，可以更高效地使用TCP。</p>
<p>客户端依据域名来向服务器建立连接，一般pc端浏览器会针对单个域名的server 同时建立 6~8 个连接，<strong>连接无法复用会导致请求要经历三次握手和慢启动</strong>。在http1中，假如有5个连接同时发出，在第一个请求没有收到回复之前，后续从应用层发出的请求只能排队，请求2，3，4，5只能等请求1的response 回来之后才能逐个发出。网络通畅的时候性能影响不大，一旦请求1的request 因为什么原因没有抵达服务器，影响到后续所有的请求，问题就比较严重了。</p>
<ul>
<li>header 压缩    </li>
</ul>
<p><strong>解释：</strong>http2针对header 采用新的压缩方式，高效地压缩算法可以很大地压缩header。并且，通讯双方各自缓存一份 header fields 表，避免重复header 的传输。</p>
<ul>
<li>采用新的压缩算法</li>
</ul>
<p><strong>解释：</strong>http2在采用gzip之外的新的压缩算法，更加安全。</p>
<ul>
<li>server push</li>
</ul>
<p><strong>解释：</strong>http2 能通过push的方式将客户端需要的内容预先推送过去。</p>
<ul>
<li>更安全的SSL</li>
</ul>
<p><strong>解释：</strong>http2.0 对 tls 的安全性做了进一步加强。</p>
</details>
> 以上内容参考自[知乎上的回答](https://www.zhihu.com/question/34074946)

<h2 id="16、网络状态码？以-2、3、4、5-开头的代表什么意思。"><a href="#16、网络状态码？以-2、3、4、5-开头的代表什么意思。" class="headerlink" title="16、网络状态码？以 2、3、4、5 开头的代表什么意思。"></a>16、网络状态码？以 2、3、4、5 开头的代表什么意思。</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="1xx-临时响应"><a href="#1xx-临时响应" class="headerlink" title="1xx-临时响应"></a>1xx-临时响应</h3><p>100： 继续。请求者应当继续提出请求<br>101： 切换协议。请求者要求服务器切换协议，服务器确认并准备切换   </p>
<h3 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx-成功"></a>2xx-成功</h3><p>200： 成功。服务器成功处理请求<br>201： 已创建。请求成功并且服务器创建了新的资源<br>202： 已接受。 服务器接受请求，但是尚未处理<br>203： 非授权信息。服务器成功处理请求，但返回的信息可能来自另一来源<br>204： 无内容。服务器成功处理请求，但是没有返回任何内容<br>205： 重置内容。服务器成功处理请求，但是没有返回任何内容<br>206： 部分内容。服务器成功处理了部分GET请求</p>
<h3 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx-重定向"></a>3xx-重定向</h3><p>300： 多种选择。服务器根据请求者选择一项操作，火提供操作列表供请求者选择<br>301： 永久移动。请求的资源永久移动到新位置了，返回此响应时会自动转到新位置<br>302： 临时移动。从不同位置响应请求，但是后续还是以原来位置继续请求<br>303： 查看其它位置。<br>304： 未修改。自上次请求后，请求的网页未修改过，此时不会返回网页内容<br>305： 使用代理。请求者只能使用代理访问请求的网页。    </p>
<h3 id="4xx-请求错误"><a href="#4xx-请求错误" class="headerlink" title="4xx-请求错误"></a>4xx-请求错误</h3><p>400： 错误请求。服务器不理解请求语法<br>401： 未授权。请求要求身份验证<br>403： 进制。服务器拒绝请求<br>404： 未找到。服务器找不到请求的网页<br>405： 方法禁用。禁用请求中指定的方法<br>408： 请求超时。服务器等候请求时发生超时<br>410： 已删除。请求的资源已永久删除<br>413： 请求实体过大。请求实体过大，服务器无法响应<br>414： 请求的URI过长。请求的URI（通常为网址）过长，无法处理<br>415： 不支持的媒体类型。</p>
<h3 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx-服务器错误"></a>5xx-服务器错误</h3><p>500： 服务器内部错误。服务器遇到错误，无法完成请求<br>501： 尚未实施。服务器不具备完成请求的功能<br>502： 错误网关。<br>503： 服务不可用。暂时地维护或者超载了<br>504： 网关超时。服务器作为网关或者代理，但是没有及时从上游服务器收到请求<br>505： HTTP版本不支持。服务器不支持请求中所用的HTTP协议版本   </p>
</details>

<blockquote>
<p>以上内容参考自<a href="http://tool.chinaz.com/pagestatus/" target="_blank" rel="noopener">站长工具</a> </p>
</blockquote>
<h2 id="17、HttpDNS"><a href="#17、HttpDNS" class="headerlink" title="17、HttpDNS"></a>17、HttpDNS</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="当前-DNS-系统存在的问题"><a href="#当前-DNS-系统存在的问题" class="headerlink" title="当前 DNS 系统存在的问题"></a>当前 DNS 系统存在的问题</h3><ul>
<li>域名缓存。运营商的 LocalDNS 会缓存域名解析的结果，而不是向权威域名发起递归。运营商缓存dns就可以实现把dns解析结果指向广告</li>
<li>解析转发。运营商自身不进行域名递归解析，而是把它发给其它运营商。一些小运营商就是这样做的。这样，比如说访问的是qq.com，则腾讯的权威dns收到的域名解析请求的来源就变成了其它运营商，最终导致用户流量被导向了错误的IDC，比如明明是广东的用户，被导向去了北京的服务器。    </li>
<li>NAT ，网络地址转换。运营商LocalDNS出口根据权威DNS目标ip进行NAT，导致腾讯权威dns无法正确识别运营商的 LocalDNS 的ip，引发域名解析错误，流量跨网等</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>使用 114 等中立DNS 服务器</p>
</li>
<li><p>使用HttpDNS，HttpDNS 的基本原理如下：</p>
</li>
</ul>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/HttpDNS%E5%8E%9F%E7%90%86.webp" alt="HttpDNS的原理"></p>
<p><strong>注意：HttpDNS主要用于客户端</strong></p>
<p>HttpDNS 的使用过程主要有两步：</p>
<ol>
<li>客户端直接访问HttpDNS 接口，获取Host对应的IP。     </li>
<li>客户端通过IP，向后台发送请求。以Http为例，通过在Header中指定host 字段，向HttpDNS 返回的IP 发送标准的Http请求即可。</li>
</ol>
</details>

<blockquote>
<p>以上内容参考自<a href="https://mp.weixin.qq.com/s/u6-53Kp9Jb48dKWzaJOKig" target="_blank" rel="noopener">鹅厂网事上的博客</a></p>
</blockquote>
<h2 id="18、https的证书验证"><a href="#18、https的证书验证" class="headerlink" title="18、https的证书验证"></a>18、https的证书验证</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>证书是一级一级的验证的，验证当前的证书时，首先拿上一级的证书的公钥，用上一级的公钥来验证当前证书的签名，验证成功就通过，不成功就报错了。然后一级一级上去，顶级。因为本地(浏览器和操作系统)一般存有信任的根证书，顶级证书一般都能通过本地证书验证。</p>
</details>

<blockquote>
<p>以上内容可以参考<a href="https://www.zhihu.com/question/37370216" target="_blank" rel="noopener">知乎上的内容</a></p>
</blockquote>
<h2 id="19、https的攻击方式"><a href="#19、https的攻击方式" class="headerlink" title="19、https的攻击方式"></a>19、https的攻击方式</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>1、中间人攻击。类似Fiddler 这种方式，前提是黑客通过某种特殊手段在被攻击者的手机上安装了根证书<br>2、Https协议降级攻击。比如说client端仅仅支持某个有漏洞的ssl版本(比如SSLv3.0)，那么服务端只能接收或者直接拒绝。如果接受的话，攻击者就能攻击(应该是 Padding Oracle 攻击)<br>3、使用对称加密的时候破解的对称加密</p>
</details>

<blockquote>
<p>以上内容参考自<a href="https://zhuanlan.zhihu.com/p/22917510" target="_blank" rel="noopener">知乎的博客</a>、<a href="https://blog.fundebug.com/2019/09/17/mitm-for-https/" target="_blank" rel="noopener">中间人攻击</a></p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-系统源码理解</title>
    <url>/2019/11/20/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="1、okhttp的理解"><a href="#1、okhttp的理解" class="headerlink" title="1、okhttp的理解"></a>1、okhttp的理解</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先看下okhttp 的整个工作流程：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/okhttp%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="okhttp工作流程"></p>
<ol>
<li>首先通过 Builder 创建 OkhttpClient 对象    </li>
<li>根据设定的条件，使用Request.Builder 构建request 对象      </li>
<li>根据 OkhttpClient 与 request 创建 RealCall     </li>
<li>不论是通过execute 还是enqueue 方式异步执行，最终都通过 getResponseWithInterceptorChain 方式获取Http 的返回结果           </li>
<li>步骤4中，通过Okio 封装的Socket 请求网络，并获取返回结果    </li>
</ol>
<p>Interceptor 是Okhttp 中最重要的一个东西，它不止拦截请求执行一些额外处理，实际上实际的网络请求、缓存、透明压缩等都是通过Interceptor 实现，它们一起连成 Interceptor.chain，每一个Interceptor 决定它自己能处理哪些事件，如果不能处理，则交给下一个Interceptor 处理，也就是<strong>责任链模式。</strong>这很类似View 中对点击事件的处理。</p>
<blockquote>
<p>以上内容参考自：<a href="http://www.androidos.net.cn/book/android-road/android/open-source-framework/okhttp.html" target="_blank" rel="noopener">okhttp 解析</a></p>
</blockquote>
</details><a id="more"></a>

<h2 id="2、谈谈对RxJava的理解"><a href="#2、谈谈对RxJava的理解" class="headerlink" title="2、谈谈对RxJava的理解"></a>2、谈谈对RxJava的理解</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="常用操作符"><a href="#常用操作符" class="headerlink" title="常用操作符"></a>常用操作符</h3><ul>
<li>map：将被观察者发送的数据类型转换为其他类型    </li>
<li>flatMap ： 将事件序列中的元素整合，返回一个新的被观察者    </li>
<li>zip ： 将多个观察者事件整合发送给观察者</li>
</ul>
<h3 id="如何实现线程切换"><a href="#如何实现线程切换" class="headerlink" title="如何实现线程切换"></a>如何实现线程切换</h3><ul>
<li>Observer 最终会封装成 SubscribeTask ，这个类实现了 Runnable 接口。    </li>
<li>最终在 Runnable 的run 方法中完成 观察者-被观察者的订阅关系      </li>
<li>也即，这个run 在哪个线程执行，observer 方法就在哪个方法执行。     </li>
<li>如果是 AndroidSchedulers.mainThread 的话，则会以Android主线程的Looper(Looper.getMainLooper())新建一个 Handler ，之后将上述Runnable 封装成Message ，通过Handler 发送到主线程。     </li>
<li>如果是其他线程，则会丢给特定线程或者线程池处理。     </li>
</ul>
<blockquote>
<p>以上内容参考自： <a href="https://cloud.tencent.com/developer/article/1408083" target="_blank" rel="noopener">rxjava2线程切换原理</a>、<a href="https://www.jianshu.com/p/5213fe112fa9" target="_blank" rel="noopener">rxjava使用与原理</a></p>
</blockquote>
</details>

<h2 id="3、fresco的理解"><a href="#3、fresco的理解" class="headerlink" title="3、fresco的理解"></a>3、fresco的理解</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="为什么使用fresco"><a href="#为什么使用fresco" class="headerlink" title="为什么使用fresco"></a>为什么使用fresco</h3><ol>
<li>部门决定采用webp 格式的图片，而fresco 对其支持           </li>
<li>5.0 以下Android系统，使用 ashmem(匿名共享内存) 区域存储bitmap ，它的创建、释放都不会触发 GC，带来良好的性能。   </li>
</ol>
<blockquote>
<p>fresco 使用ashmem 区域存储bitmap ，gc不会处理这块区域，并且也不会被”ashmem内置清除机制”回收，所以减少gc，提升性能。在ashmem 中，fresco 采用引用计数方式，自己管理内存。</p>
</blockquote>
<ol start="3">
<li>使用了三级缓存，方便图片快速复用、加载：Bitmap 缓存 + 未解码缓存 + 硬盘缓存，前面两个是内存缓存，Bitmap 根据不同系统版本存放不同区域(5.0以下存放ashmem)，未解码存放在堆内存。      </li>
<li>fresco 的设计，UIThread 只做从内存缓存中加载图片和显示图片两件事，其他诸如 图片Decode、缓存读写 都放在非 UI线程。      </li>
</ol>
<h3 id="fresco-原理解析"><a href="#fresco-原理解析" class="headerlink" title="fresco 原理解析"></a>fresco 原理解析</h3><p>典型的MVC模式应用：</p>
<ul>
<li>DraweeView ： view 层，负责显示图片。它继承ImageView 的目的是使用它来显示 drawable ，其他的ImageView 方法都没有使用，也不推荐使用。   </li>
<li>Hierarchy： model 层，负责生成要显示的图片     </li>
<li>DraweeController： controller 层     </li>
</ul>
<p>DraweeView 把获得event 转给 controller，controller 决定是否隐藏或者显示什么图像，而这些图像存储在 Hierarchy，最后 DraweeView 直接通过 getTopLevelDrawable 获取要显示的图像。</p>
<p>DraweeView 不直接与 Hierarchy 及 DraweeController 打交道，而是通过 DraweeHolder 间接与他们打交道，因为 DraweeHolder 管理着 Hierarchy 与 Controller。</p>
</details>

<h2 id="4、ThreadLocal-详解"><a href="#4、ThreadLocal-详解" class="headerlink" title="4、ThreadLocal 详解"></a>4、ThreadLocal 详解</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>ThreadLocal 很典型的一个用处就是存储线程的 Looper，我们知道，子线程中初始化Handler 的时候，需要先执行 Looper.prepare ，这个操作就是新建一个Looper 并且将其保存到 ThreadLocal 中。</p>
<p>Thread 类中有个专门存储线程的 ThreadLocal 数据的结构，即 ThreadLocal.Values 。保存值时，首先通过 Thread.currentThread 获取到当前线程，再获取该线程的 ThreadLocal.Values ，这个 Values 中有个 Object[] table 的数组，ThreadLocal 对象就存在这个数组中。每个 ThreadLocal 对象根据自己的 hashcode 按照一定规则获取到在数组中的 index ，之后进行读取或者存储。</p>
<p>这样，每个线程通过同一个 ThreadLocal 获取到的是不同的值。各个线程可以相互独立地执行操作。</p>
</details>

<blockquote>
<p>以上内容总结自源码，部分语言参考自<a href="https://blog.csdn.net/singwhatiwanna/article/details/48350919" target="_blank" rel="noopener">任玉刚的博客内容</a></p>
</blockquote>
<h2 id="5、LocalBroadcastManager"><a href="#5、LocalBroadcastManager" class="headerlink" title="5、LocalBroadcastManager"></a>5、LocalBroadcastManager</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>LocalBroadcastManager 注册本地广播<strong>只能通过代码，不能通过xml静态注册</strong>。本地广播不会跨进程，不用跟system_server 交互。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>首先，LocalBroadcastManager.getInstance 是个单例，在初始化过程中，会根据 mainLooper 创建一个Handler：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LocalBroadcastManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mAppContext = context;</span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler(context.getMainLooper()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_EXEC_PENDING_BROADCASTS:</span><br><span class="line">                    executePendingBroadcasts();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，注册过程，其实可以理解成订阅某种消息，以便在符合条件的消息发送的时候，这里能接收：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerReceiver</span><span class="params">(@NonNull BroadcastReceiver receiver, @NonNull IntentFilter filter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">    	<span class="comment">//创建ReceiverRecord对象</span></span><br><span class="line">        ReceiverRecord entry = <span class="keyword">new</span> ReceiverRecord(filter, receiver);</span><br><span class="line">        <span class="comment">//mReceivers：数据类型为HashMap&lt;BroadcastReceiver, ArrayList&gt;， 记录广播接收者与IntentFilter列表的对应关系</span></span><br><span class="line">        ArrayList&lt;ReceiverRecord&gt; filters = mReceivers.get(receiver);</span><br><span class="line">        <span class="keyword">if</span> (filters == <span class="keyword">null</span>) &#123;</span><br><span class="line">            filters = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">            mReceivers.put(receiver, filters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filters.add(entry);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;filter.countActions(); i++) &#123;</span><br><span class="line">            String action = filter.getAction(i);</span><br><span class="line">            <span class="comment">//mActions：数据类型为HashMap&lt;String, ArrayList&gt;， 记录action与广播接收者的对应关系</span></span><br><span class="line">            ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action);</span><br><span class="line">            <span class="keyword">if</span> (entries == <span class="keyword">null</span>) &#123;</span><br><span class="line">                entries = <span class="keyword">new</span> ArrayList&lt;ReceiverRecord&gt;(<span class="number">1</span>);</span><br><span class="line">                mActions.put(action, entries);</span><br><span class="line">            &#125;</span><br><span class="line">            entries.add(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，发送广播，可以理解为，根据 sendBroadcast(Intent intent) 中 intent 的值获取 actions，再根据action 来查询相应的广播接收者，当然，如果当前receiver 正在处理其他广播，则跳过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据Intent的action来查询相应的广播接收者列表</span></span><br><span class="line">        ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction());</span><br><span class="line">        <span class="keyword">if</span> (entries != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">//用于存放与当前action匹配的receiver</span></span><br><span class="line">            ArrayList&lt;ReceiverRecord&gt; receivers = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;entries.size(); i++) &#123;</span><br><span class="line">                ReceiverRecord receiver = entries.get(i);</span><br><span class="line">                <span class="keyword">if</span> (receiver.broadcasting) &#123;</span><br><span class="line">                	<span class="comment">//当前receiver正在处理其他广播，则跳过</span></span><br><span class="line">                    <span class="keyword">continue</span>; </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> match = receiver.filter.match(action, type, scheme, data,categories, <span class="string">"LocalBroadcastManager"</span>);</span><br><span class="line">                <span class="keyword">if</span> (match &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (receivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        receivers = <span class="keyword">new</span> ArrayList&lt;ReceiverRecord&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    receivers.add(receiver);</span><br><span class="line">                    receiver.broadcasting = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (receivers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;receivers.size(); i++) &#123;</span><br><span class="line">                    receivers.get(i).broadcasting = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//创建相应广播，添加到mPendingBroadcasts队列</span></span><br><span class="line">                mPendingBroadcasts.add(<span class="keyword">new</span> BroadcastRecord(intent, receivers));</span><br><span class="line">                <span class="keyword">if</span> (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123;</span><br><span class="line">                    <span class="comment">//发送消息【见小节2.3.1】</span></span><br><span class="line">                    mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 LocalBroadcastManager 的构造函数中我们初始化了这个以 mainLooper 建立的Handler，此时利用它 sendEmptyMessage，在handleMessage 中最终会调用 executePendingBroadcasts 方法（说明此函数也运行在主线程）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executePendingBroadcasts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> BroadcastRecord[] brs;</span><br><span class="line">        <span class="comment">//将mPendingBroadcasts保存到brs数组</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mPendingBroadcasts.size();</span><br><span class="line">            <span class="keyword">if</span> (N &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            brs = <span class="keyword">new</span> BroadcastRecord[N];</span><br><span class="line">            mPendingBroadcasts.toArray(brs);</span><br><span class="line">            mPendingBroadcasts.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//挨个回调相应广播接收者的onReceive</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;brs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> BroadcastRecord br = brs[i];</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> nbr = br.receivers.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;nbr; j++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReceiverRecord rec = br.receivers.get(j);</span><br><span class="line">                <span class="keyword">if</span> (!rec.dead) &#123;</span><br><span class="line">                    rec.receiver.onReceive(mAppContext, br.intent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上的原理分析，我们知道本地广播只是在发送广播的时候，在主线程中挨个通知 action 符合的receiver，因此并不会超出进程范围，也不会超出 app 范围，只会在当前app 的当前进程发生。</p>
</details>

<blockquote>
<p>以上内容参考自<a href="http://gityuan.com/2017/04/23/local_broadcast_manager/" target="_blank" rel="noopener">gityuan的分析</a></p>
</blockquote>
<h2 id="6、Java线程池ThreadPoolExecutor实现原理"><a href="#6、Java线程池ThreadPoolExecutor实现原理" class="headerlink" title="6、Java线程池ThreadPoolExecutor实现原理"></a>6、Java线程池ThreadPoolExecutor实现原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>ThreadPoolExecutor 构造函数参数非常多，有以下：</p>
<ul>
<li><p>corePoolSize： 通过 submit 或者 execute 提交任务时，如果当前线程池的线程数 n &lt; corePoolSize ，则创建一个新的线程处理任务，即使其他 core 线程是空闲的。    </p>
</li>
<li><p>maximumPoolSize: 如果当前线程数 n &gt; corePoolSize &amp;&amp; n &lt; maximumPoolSize ，那么不会创建新的线程；但是如果 n &gt;= maximumPoolSize 时，就会创建新的线程。如果是个无界队列(LinkedBlockingQueue)，那么不存在满的情况(n &gt;= maximumPoolSize),也就不会创建新线程。    </p>
</li>
<li><p>keepAliveTime: 如果当前线程池中的线程数 n &gt; corePoolSize,那么如果在 keepAliveTime 时间内没有新的任务需要处理，那么就会销毁 corePoolSize - n 个线程。    </p>
</li>
<li><p>handler ：异常处理策略。即当任务提交失败的时候，调用这个处理器。</p>
</li>
</ul>
<h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><p>ThreadPoolExecutor 使用一个 AtomicInteger 的前三位表示线程池状态，后 29 位表示线程数，因此是可以支持上亿的线程计数。线程池主要有几种状态：</p>
<ul>
<li>Running： 线程池正在运行，可以接收新任务。    </li>
<li>ShutDown： 不再接收新任务，但会继续处理队列中任务。    </li>
<li>Stop： 不接受新任务，也不处理队列中任务，并且<strong>中断正在处理的任务</strong>    </li>
<li>Tidying： 所有任务处理玩，线程数为 0(线程池为空)    </li>
<li>Terminated： 已经执行完毕(执行了 terminated)    </li>
</ul>
<p>submit 执行过程 就是将 Runnable 和 Callable 封装成 RunnableFuture 之后，最终提交给execute 执行。使用 HashSet 类型的 worker 来存储正在运行的任务，只要 worker.size() &lt; corePoolSize，提交新的任务就马上开启新线程执行(上面提到过)。在提交过程中要检查线程池的状态，检查是否关闭了。</p>
<p>worker的数目也是通过 CAS的方式 增减的。</p>
</details>

<blockquote>
<p>以上内容参考自<a href="https://github.com/aCoder2013/blog/issues/28" target="_blank" rel="noopener">github上的博客</a></p>
</blockquote>
<h2 id="7、延伸-Java-线程池的异常处理机制"><a href="#7、延伸-Java-线程池的异常处理机制" class="headerlink" title="7、延伸-Java 线程池的异常处理机制"></a>7、延伸-Java 线程池的异常处理机制</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>如果是使用submit 提交的话，可以通过继承 ThreadPoolExecutor 再重写 afterExecute 方法，得到实际的异常 (包含 Runnable 和 Throwable)    </li>
<li>如果是调用的execute 方法提交的话，那就会抛到 dispatchUncaughtException 里面去了，这时候我们只有对线程 Thread.setUncaughtExceptionHandler(UncaughtExceptionHandler)  来捕捉。即自己写 ThreadFactory (thread 工厂类),并为创建的线程 setUncaughtExceptionHandler       </li>
<li>还有一种，就是对 Runnable 的 run 方法里面整个 try-catch    </li>
</ul>
</details>

<blockquote>
<p>以上内容参考自<a href="http://ifeve.com/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">并发编程网</a> 或者它<a href="https://github.com/aCoder2013/blog/issues/3" target="_blank" rel="noopener">在github上的相同文章</a></p>
</blockquote>
<h2 id="8、AsyncTask-解析"><a href="#8、AsyncTask-解析" class="headerlink" title="8、AsyncTask 解析"></a>8、AsyncTask 解析</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>AsyncTask 是个抽象类，必须子类实现才能使用。在构建的时候，需要指定三个泛型参数类型，分别是 Params、Progress、Result ，即类似 AsyncTask&lt;Integers, Integers, ResponseBean&gt; ，当然，如果某个参数不需要，类型可以写成 Void 。</p>
<p>其整体原理还是 将task丢给ThreadPool 在子线程执行，得到结果后，通过 Handler 的 sendEmptyMessage 的方式将结果切换到主线程</p>
<p>在 AsyncTask 使用的过程中需要遵守如下原则：</p>
<ul>
<li>必须在UI线程中实例化             </li>
<li>execute 必须在UI线程中调用                </li>
<li>不要人为调用 onPreExecute、onPostExecute、doInBackground 和 onProgressUpdate               </li>
<li>一个 AsyncTask 实例只能执行一次，如果多次调用会报异常                  </li>
</ul>
<p>AsyncTask 中有 <strong>static</strong> 的 ThreadPool ，<strong>意味着不管有多少个实例，都只有这个线程池</strong>，而在初始化这个线程池的时候，corePoolSize 在不同版本的值默认被设置为 1 或者 5 (Android 3.0以前是5，还不能改；3.0之后设置为1，但是可以自己设置Excutor )，并且 BlockingQueue 基本上是个无界队列(BlockingQueue 或 SynchronousQueue，队列不存在满的情况)，根据 ThreadPool 的原理，我们每次最多只有一个线程或者 5 个线程在执行，<strong>意味着多的任务就要排队，并不能实时执行</strong>，并且在早期，我们不能设置自定义的 ThreadPoolExcutor，到后来才可以(貌似是Android 4.0以后)。</p>
<p>AsyncTask 存在的问题：</p>
<ol>
<li>AsyncTask 对象只能execute 一次，多次请求会导致多个对象创建          </li>
<li>生命周期与Activity 的生命周期不一致，有可能导致内存泄露           </li>
<li>cancle 并不马上生效，因为它就是线程，在cancle之后，还得等它完成           </li>
</ol>
</details>

<blockquote>
<p>以上内容参考自 系统源码、<a href="http://zmywly8866.github.io/2015/09/29/android-call-asynctask-excute-not-run.html" target="_blank" rel="noopener">github上的博客</a>、<a href="https://www.cnblogs.com/yanyojun/p/6414919.html" target="_blank" rel="noopener">cnblogs的博客</a>、<a href="https://blog.csdn.net/weixin_43507738/article/details/83418989" target="_blank" rel="noopener">csdn的博客</a></p>
</blockquote>
<h2 id="9、阿里Alpha原理"><a href="#9、阿里Alpha原理" class="headerlink" title="9、阿里Alpha原理"></a>9、阿里Alpha原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>想象下有以下场景： </p>
<p>有6个任务需要在Application里面执行，其中Task1，Task4，Tas6需要在主线程执行，Task2，Task3需要在Task1执行完才能执行，Task4，Task5需要Task2和Task3执行完才能执行，Task6需要Task4和Task5执行完才能执行，Task4的耗时要大于Task5，是不是顿时就乱了？其实可以通过 PERT 图来捋一捋这个关系，涉及到具体实现的话，可以参考阿里巴巴的 alpha 框架。</p>
<p>Alpha是一个<strong>基于PERT图</strong>构建的Android异步启动框架</p>
<p>首先解决多进程疑惑，在start方法中就首先判断了 <strong>主进程任务、非主进程任务 以及 适用于所有进程的任务</strong>，这些任务是通过 public void addProject(Task project, int mode) 方法添加进去的。</p>
<p>在实际情况中，可能会有多个任务同时开始，并且也有可能多个任务作为结束节点，所以为了<strong>方便控制整个流程</strong>，alpha 设计了startTask 和 finishTask，标记流程的开始和结束，方便任务的监听</p>
<p>如果Task 是在主线程执行的，那么就通过Handler 将时间传递给主线程；如果是非主线程，则通过线程池去执行。</p>
<p>在一个Task执行完成后，就会遍历自己持有的 <strong>mSuccessorList(紧后任务列表，也就是当前任务执行完成之后可以执行的Task列表，这里面的Task会根据Priority进行排序)</strong>，并依次执行里面元素的 onPredecessorFinished 方法。</p>
<p>mSuccessorList 列表中的Task 是通过 after 方法加入的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//紧后任务添加</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">after</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">    task.addSuccessor(mCacheTask);</span><br><span class="line">    mFinishTask.removePredecessor(task);</span><br><span class="line">    mIsSetPosition = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要操作在这个方法里</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSuccessor</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//task 添加紧前任务</span></span><br><span class="line">    task.addPredecessor(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//真正添加为紧后任务</span></span><br><span class="line">    mSuccessorList.add(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>意思是Task2要在Task1后面执行，这样，Task2就是Task1的紧后任务，同理，Task1也成了Task2的紧前任务，那这个紧前任务有什么用呢？试想一下，如果Task1、Task2、Task3的紧后任务都是 Task4，那么，在Task1执行完成之后，还要判断 Task2和Task3是否执行完成，然后才能决定是否执行Task4，这就是紧前任务的作用了。</p>
</details>

<blockquote>
<p>以上文章主要参考自：<a href="https://blog.csdn.net/liuzhengisme/article/details/106996006" target="_blank" rel="noopener">积木zz的csdn博客</a>, 有博客说，使用 <a href="https://zhuanlan.zhihu.com/p/163014950" target="_blank" rel="noopener">Anchors</a> 比使用 Alpha 更精细，后续再看</p>
</blockquote>
<h2 id="10、LeakCanary-原理"><a href="#10、LeakCanary-原理" class="headerlink" title="10、LeakCanary 原理"></a>10、LeakCanary 原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>原理：</p>
<ol>
<li>通过registerActivityLifecycleCallbacks 来监听 Activity 的生命周期 onActivityDestroyed。    </li>
<li>即 lifecycleCallbacks 监听Activity 的 onDestroy 方法，正常情况下执行了onDestroy 后资源立即回收。    </li>
<li>监察机制利用了 WeakReference 和 ReferenceQueue ，使用 WeakReference 对Activity 进行引用，在Activity回收的时候，就会将该WeakReference 引用放到 ReferenceQueue 中。     </li>
<li>在onDestroy 之后，等待一段时间，再通过监测 ReferenceQueue 是否包含 WeakReference 就能检查 Activity 是否被正确回收。    </li>
<li>如果Activity 没有被回收，就手动 GC 一次，等待若干时间，之后再次判断Activity 是否被回收，若未被回收，说明 Activity 已经泄露。    </li>
<li>如果Activity 泄露了，则抓取 dump 信息显示出来。</li>
</ol>
<p>以上要注意的是：</p>
<p>1、是使用<strong>WeakReference</strong>对Activity进行引用<br>2、LeakCanary可以配置<strong>忽略</strong>某些路径的内存泄漏<br>3、手动GC是使用的 Runtime.getRuntime().gc() 实现，代码中解释是这样触发gc的概率会比System.gc() 高一些: System.gc() does not garbage collect every time. Runtime.gc() is more likely to perform a gc.<br>4、 当Activity对象被回收时，会将 <strong>WeakReference(而不是Activity)对象</strong>放入 ReferenceQueue 中，自己写的测试代码如下：</p>
<pre><code class="Java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{
    <span class="keyword">private</span> RecyclebleObject testObject;
    <span class="keyword">private</span> WeakReference&lt;RecyclebleObject&gt; objectWeakReference;
    <span class="keyword">private</span> ReferenceQueue&lt;RecyclebleObject&gt; referenceQueue;

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);

        testObject = <span class="keyword">new</span> RecyclebleObject();
        referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();
        objectWeakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(testObject, referenceQueue);

        <span class="keyword">final</span> TextView btnClick = findViewById(R.id.click_view);

        btnClick.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
            <span class="meta">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
                <span class="keyword">if</span> (testObject == <span class="keyword">null</span>) {
                    testObject = <span class="keyword">new</span> RecyclebleObject();
                }

                Log.e(<span class="string">"NullTest"</span>, <span class="string">"testObject = "</span> + testObject);
                Log.e(<span class="string">"NullTest"</span>, <span class="string">"referenceQueue 中的内容： "</span> + referenceQueue.poll());
                testObject = <span class="keyword">null</span>;
                Runtime.getRuntime().gc();

                btnClick.postDelayed(<span class="keyword">new</span> Runnable() {
                    <span class="meta">@Override</span>
                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                        Log.e(<span class="string">"NullTest"</span>, <span class="string">"GC 后，testObject = "</span> + testObject);
                        Reference result = referenceQueue.poll();
                        Log.e(<span class="string">"NullTest"</span>, <span class="string">"GC 后，referenceQueue 的内容： "</span> + result + <span class="string">",这个对象与objectWeakReference 相等吗？ "</span> + (result == objectWeakReference));
                    }
                }, <span class="number">1000</span>);
            }
        });
    }
}</code></pre>
<p>以上代码将会打印出以下结果：</p>
<blockquote>
<p>testObject = com.example.myapplication.RecyclebleObject@86f4db5<br>referenceQueue 中的内容： null<br>GC 后，testObject = null<br>GC 后，referenceQueue 的内容： java.lang.ref.WeakReference@f6c4a,这个对象与objectWeakReference 相等吗？ true     </p>
</blockquote>
<p>说明在回收后， WeakReference 对象会出现在 referenceQueue 中，而不是 testObject 本身出现在 referenceQueue  。</p>
<hr>
<p>有意思的是，在 LeakCanary2 时，并不需要接入者手动初始化(LeakCanary.install(this);)了，而是只需要引入即可。其根本原理是：<strong>LeakCanary 写了个 ContentProvider 并在 AndroidManifest中注册了，并在 ContentProvider 的onCreate方法中执行了 install 操作！</strong>我们知道，ContentProvider 的 onCreate 方法会在启动App的时候自动执行，并且比 Application 的 onCreate 方法还要早，因此它自动执行完全没问题。</p>
</details>

<blockquote>
<p>以上内容参考自<a href="https://www.jianshu.com/p/261e70f3083f" target="_blank" rel="noopener">JasmineBen的博客</a>、<a href="https://blog.csdn.net/braintt/article/details/99685243" target="_blank" rel="noopener">CSDN上的博客</a>、以及自己写的代码验证</p>
</blockquote>
<h2 id="11、Toast显示流程"><a href="#11、Toast显示流程" class="headerlink" title="11、Toast显示流程"></a>11、Toast显示流程</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先，为了避免Toast显示冲突，会将要显示的Toast放在队列中，然后依次取出来展示</p>
<ol>
<li>makeText的时候，创建Toast对象和TN对象，Toast创建好后，加载布局，创建mNextView，然后 TN 是控制Toast的显示和隐藏以及取消的，它里面有个 Handler ，以当前线程的Looper来初始化，Toast的显示隐藏取消就是通过这个Handler来处理的。        </li>
<li>Toast对象创建完成就 enqueueToast 到NotificationManagerService 进程中去排队的(所以这中间是有跨进程通信这个概念的)，在中间会判断是否要显示这个Toast(如果此Toast正在取消或者隐藏就不展示了)，接着就开始排队，显示的话，就是不断从队列里面取出 ToastRecord ，然后调用 Toast对应的TN 的show 方法展示Toast。</li>
<li>TN收到显示的消息，创建WindowManager对象，然后将第一步创建的 View 添加到 WindowManager ，之后Toast 就显示出来了。          </li>
</ol>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/Android%E5%9F%BA%E7%A1%80/Toast%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B.webp" alt="Toast显示流程"></p>
</details>

<blockquote>
<p>以上内容参考自<a href="https://www.jianshu.com/p/7177360e3f63" target="_blank" rel="noopener">简书上的博客</a></p>
</blockquote>
<h2 id="12、onTouchListener、onTouchListener-的onTouch方法、onTouchEvent、onClickListener、onLongClickListener-的执行顺序？"><a href="#12、onTouchListener、onTouchListener-的onTouch方法、onTouchEvent、onClickListener、onLongClickListener-的执行顺序？" class="headerlink" title="12、onTouchListener、onTouchListener 的onTouch方法、onTouchEvent、onClickListener、onLongClickListener 的执行顺序？"></a>12、onTouchListener、onTouchListener 的onTouch方法、onTouchEvent、onClickListener、onLongClickListener 的执行顺序？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>dispatchTouchEvent 在 onTouchListener 之前发生，如果在 dispatchTouchEvent 的 down 事件就return 了 false，则后续的事件压根就不会传过来了，所以不会有什么故事。        </li>
<li>但如果 down 事件返回了 true ，则事件虽然onTouchListener 和 onTouchEvent 会发生，但不会有点击事件了，即onLongClick 和 onClick 都不会响应了。    </li>
<li>onTouchListener 在onTouchEvent 之前发生， onLongClick 与 onClick 依赖于是在onTouchEvent 里面发生的，也就是说 click 事件是在 onTouchEvent 之后执行，并且 onClick 在 onLongClick 之后执行。        </li>
<li>如果在 onTouchListener 的 onTouch 方法中返回true，则没有后面的 onTouchEvent 什么事了，更别提 click 事件        </li>
<li>在onTouch 发生后，如果直接在 onTouchEvent 中返回true 或者false ，那就没有 click 什么事情了（因为click 是在super.onTouchEvent中）    </li>
<li>如果TouchEvent 不做处理，那么在down事件发生后长按，则会响应 onLongClick 事件，之后up，如果之前的 onLongClick 返回false ，则还会接着 onClick，反之，如果之前的 onLongClick 返回true，则 onClick 不会执行。     </li>
</ul>
</details>

<blockquote>
<p>以上内容来自自己的实验，以及<a href="https://blog.csdn.net/qiantanlong/article/details/82017462" target="_blank" rel="noopener">csdn上的博客1</a>、<a href="https://blog.csdn.net/wang_k516/article/details/52849565" target="_blank" rel="noopener">csdn上的博客2</a></p>
</blockquote>
<h2 id="13、Android-事件中-CANCLE-事件是怎么来的？它的作用是啥？"><a href="#13、Android-事件中-CANCLE-事件是怎么来的？它的作用是啥？" class="headerlink" title="13、Android 事件中 CANCLE 事件是怎么来的？它的作用是啥？"></a>13、Android 事件中 CANCLE 事件是怎么来的？它的作用是啥？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>第一个问题：我们知道view如果处理了 Down 事件，则随之而来的 Move 和 Up 事件也会交给它处理，但是交给它处理之前，父View 可以拦截，如果被拦截了，就会返回 Cancel 事件，并且不会收到后续的 Move 和 Up 事件</p>
<p>第二个问题：</p>
</details>

<blockquote>
<p>以上内容参考自 <a href="https://blog.csdn.net/cufelsd/article/details/89471402" target="_blank" rel="noopener">csdn上的博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章：Android系统架构</title>
    <url>/2019/11/19/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC1%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>分为五层，从上往下依次是应用层、应用框架层、系统运行库层、硬件抽象层和Linux内核层。</p><ul>
<li>应用层(System Apps)：系统内置的应用程序以及非系统级的应用程序都属于应用层，负责与用户进行直接交互。    </li>
<li>应用框架层(Java API FrameWork)：应用框架层为开发人员提供了开发应用程序所需要的API，我们平时开发应用程序都是调用这一层提供的API。    </li>
<li>系统运行库层(Native)：系统运行库层分为两部分：分别是C/C++程序库和Android运行时库。运行时库又分为核心库和ART(Dalvik)，核心库提供了Java语言核心库的大多数功能，这样开发者可以使用Java语言来编写Android应用。     </li>
<li>硬件抽象层(HAL)：硬件抽象层是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商的知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台。    </li>
<li>Linux内核层(Linux Kernel)：Android 的核心系统服务基于Linux内核，在此基础上添加了部分Android专用驱动。</li>
</ul><a id="more"></a>

<h2 id="Android系统源码目录"><a href="#Android系统源码目录" class="headerlink" title="Android系统源码目录"></a>Android系统源码目录</h2><p>Android 8.0.0系统根目录结构说明如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC1%E7%AB%A0/Android%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95-1.png" alt="Android系统目录-1"></p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC1%E7%AB%A0/Android%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95-2.png" alt="Android系统目录-2"></p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层位于整个Android系统的最上层，开发者开发的应用程序以及系统内置应用程序都在应用层，它的目录结构如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC1%E7%AB%A0/%E5%BA%94%E7%94%A8%E5%B1%82%E7%9B%AE%E5%BD%95-1.png" alt="应用层目录-1"></p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC1%E7%AB%A0/%E5%BA%94%E7%94%A8%E5%B1%82%E7%9B%AE%E5%BD%95-2.png" alt="应用层目录-2"></p>
<h3 id="应用框架层部分"><a href="#应用框架层部分" class="headerlink" title="应用框架层部分"></a>应用框架层部分</h3><p>应用框架层是系统的核心部分，一方面向上提供接口给应用层调用，另一方面向下与下层进行衔接，应用框架层的主要实现代码在 frameworks/base 和 frameworks/av 目录下，其中frameworks/base 目录结构如下：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC1%E7%AB%A0/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E5%B1%82%E7%9B%AE%E5%BD%95.png" alt="应用框架层目录"></p>
<h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><p>系统源码阅读的方式有在线阅读和下载源码到本地用软件工具阅读。</p>
<h3 id="在线阅读"><a href="#在线阅读" class="headerlink" title="在线阅读"></a>在线阅读</h3><p>Android 在线阅读源码的网站有很多，比如：<a href="http://androidxref.com/" target="_blank" rel="noopener">http://androidxref.com/</a>,<a href="http://www.androidos.net.cn/" target="_blank" rel="noopener">http://www.androidos.net.cn/</a>,在书中，作者推荐使用前一个url在线阅读；我个人比较推荐第二个，因为它在类搜索这块做得非常舒服，像使用google、baidu 一样容易使用，此外，它还是中文界面。</p>
<h3 id="使用Source-Insight"><a href="#使用Source-Insight" class="headerlink" title="使用Source Insight"></a>使用Source Insight</h3><p>下载源码到本地，再用软件工具阅读源码是最好的方式，不受网速影响，效率更高，本地阅读源码可以采用 Android Studio、Eclipse、Sublime 和Source Insight 等软件，这里推荐使用Source Insight 。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android进阶解密</tag>
      </tags>
  </entry>
  <entry>
    <title>第10章：Java虚拟机</title>
    <url>/2019/11/18/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC10%E7%AB%A0/</url>
    <content><![CDATA[<p>需要注意的是，Android中的Dalvik 和 ART 并不属于Java 虚拟机。</p><p>当一个Java 文件经过Java编译器后会生成Class 文件，这个Class 文件会由 Java 虚拟机进行处理，Java 虚拟机与 Java 语言没有必然的联系，它只与特定的二进制文件：Class 文件有关。任何语言只要能编译成 Class 文件，都能被Java 虚拟机识别并执行。</p><a id="more"></a>

<h2 id="Java虚拟机结构"><a href="#Java虚拟机结构" class="headerlink" title="Java虚拟机结构"></a>Java虚拟机结构</h2><p>按照Java虚拟机规范，抽象的Java 虚拟机如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC10%E7%AB%A0/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BB%93%E6%9E%84.png" alt="Java虚拟机结构"></p>
<p>从图可以看出，Java虚拟机结构包括 运行时数据区域、执行引擎、本地库接口和本地方法库，其中类加载子系统并不属于Java 虚拟机的内部结构。下面针对这个图来介绍Android 开发需要掌握的Class 文件格式和运行时数据区域。</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>类的生命周期如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/%E7%AC%AC10%E7%AB%A0/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="类的生命周期"></p>
<p>类加载的各个阶段的工作：</p>
<ol>
<li><p>加载： 查找并加载Class文件    </p>
</li>
<li><p>连接： 包括验证、准备和解析    </p>
<ul>
<li>验证：确保被导入类型的正确性     </li>
<li>准备：为类的**静态字段分配字段，并用默认值初始化这些字段    </li>
<li>解析：虚拟机将常量池内的符号引用替换为直接引用    </li>
</ul>
</li>
<li><p>初始化： 将类变量初始化为正确的初始值。    </p>
</li>
</ol>
<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>可取的几点：</p>
<ul>
<li>为了在线程切换后能恢复到正确的执行位置，每个线程都会有个独立的程序计数器。如果线程执行的方法是Native方法，则程序计数器的值为空(Undefined)，否则，保存正在执行的字节码指令地址。    </li>
<li>可以选择在方法区不显示垃圾收集    </li>
</ul>
<p>其他的可以参考深入理解Java虚拟机的<a href="https://glassx.gitee.io/2019/04/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0/">这篇文章</a>即可。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>当虚拟机接收到一个 new 指令时，它会做如下操作：</p>
<ol>
<li>判断对象对应的类是否加载、链接、以及初始化。    </li>
<li>为对象分配内存：如果内存规整，则只需要将指针指示器向空闲的内存移动若干距离即可；若不规整，则需要由虚拟机维护一个列表记录哪些内存是可用的。</li>
<li>处理并发安全问题，有两种方式解决：   <ul>
<li>对分配内存空间的动作做同步处理，比如采用 CAS 方式配合失败重试</li>
<li>为每个线程在Java堆中预先分配一小块内存，只有这块内存被使用完后，才需要同步的方式分配新的内存。</li>
</ul>
</li>
<li>初始化分配到的内存空间：将分配到的内存，出对象头以外都初始化为零值。     </li>
<li>设置对象的对象头：将对象所属的类、对象的hashcode、以及GC分代年龄等存放在对象头。    </li>
<li>执行init方法进行初始化。</li>
</ol>
<h2 id="垃圾标记算法"><a href="#垃圾标记算法" class="headerlink" title="垃圾标记算法"></a>垃圾标记算法</h2><p>GC 主要做两个工作：一是内存的划分和分配，二是对垃圾进行回收。关于内存的划分和分配，目前Java虚拟机内存的划分是依赖于GC 的，比如现在的GC 都采用分代收集算法来回收垃圾的。<strong>Java 堆作为GC 的主要管理区域</strong>，被细分为新生代和老年代。</p>
<blockquote>
<p>查看gc日志的时候，[GC(Systemt.gc()) 和 [Full GC(Systemt.gc() 用于说明此次垃圾收集的<strong>停顿类型(而非区分新生代和老年代)</strong>，后者表示此次GC发生了 STW(Stop the World，只有GC线程在运行，其他线程都暂停)。</p>
</blockquote>
<p>其余主要内容，<a href="https://glassx.gitee.io/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/">参考以前写的这篇文章</a></p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>首先标记可以被回收的对象，之后回收被标记的对象所占的空间。它主要有两大缺点：一个是标记和清除两个过程的效率都不高，另一个就是，容易产生大量的内存碎片，<strong>碎片太多可能会导致没有足够的连续内存分配给较大的对象</strong>，从而提前触发新的GC。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>把空间分为两个相等部分，每次只使用其中一部分，垃圾收集时，把存货的对象复制到另一部分，再把当前部分全部清理掉，这样不需要考虑碎片化问题，缺点就是可用内存变为了原来的一半。</p>
<h3 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h3><p>新生代一半存活的对象比较少，可以使用复制算法，但是老年代不能选择复制算法了，因为老年代的对象存活率会较高，这样会有很多复制操作，导致效率降低。它的主要方式是，在标记可回收的对象后，将所有还存活的对象压缩到内存的一端，使它们紧凑地排列在一起，然后对边界外的内存进行回收。<strong>标记-压缩算法解决了标记-清除算法容易产生大量内存碎片的问题，但是它的效率仍然是很低的。</strong></p>
<h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p>垃圾收集的类型分为两种，分别是：</p>
<ul>
<li>Minor Collection: 新生代垃圾收集    </li>
<li>Full Collection: 老年代垃圾收集，也称 Major Collection， Full Collection 通常会伴随至少一次的 Minor Collection。 Full Collection 收集频率低，耗时长。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android进阶解密</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-算法-LeetCode-书籍-剑指offer</title>
    <url>/2019/11/15/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-LeetCode-%E4%B9%A6%E7%B1%8D-%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<h2 id="LeetCode-剑指offer系列"><a href="#LeetCode-剑指offer系列" class="headerlink" title="LeetCode-剑指offer系列"></a>LeetCode-剑指offer系列</h2><hr><h3 id="面试题03、数组中重复的数字"><a href="#面试题03、数组中重复的数字" class="headerlink" title="面试题03、数组中重复的数字"></a>面试题03、数组中重复的数字</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>HashSet 是否添加进去了</p>
<p>自己写的时候的问题：<strong>没啥，用hashset 搞定，但是忘了 new 关键字。。。</strong></p>
</details><blockquote>
<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-b-4/" target="_blank" rel="noopener">力扣</a></p>
</blockquote><h3 id="面试题04、二维数组中的查找"><a href="#面试题04、二维数组中的查找" class="headerlink" title="面试题04、二维数组中的查找"></a>面试题04、二维数组中的查找</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>左下角标志法     </p>
<p>自己写的时候的问题：<strong>自己写得完美，没问题。为了加深印象，我们说行数 rowNum = matrix.length;  columnNum = matrix[0].length,  之后从左下角开始即可。</strong></p>
</details><a id="more"></a>





<blockquote>
<p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题05、替换String空格"><a href="#面试题05、替换String空格" class="headerlink" title="面试题05、替换String空格"></a>面试题05、替换String空格</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>使用 StringBuilder</p>
<p>自己写的时候的问题：<strong>没啥问题，StringBuilder 疯狂拼接即可</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题10-I、斐波那契数列由-0-和-1-开始，之后的斐波那契数就是由之前的两数相加而得出，求第n个数，但是结果要对-1000000007，如计算初始结果为：1000000008，请返回-1。"><a href="#面试题10-I、斐波那契数列由-0-和-1-开始，之后的斐波那契数就是由之前的两数相加而得出，求第n个数，但是结果要对-1000000007，如计算初始结果为：1000000008，请返回-1。" class="headerlink" title="面试题10-I、斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出，求第n个数，但是结果要对 1000000007，如计算初始结果为：1000000008，请返回 1。"></a>面试题10-I、斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出，求第n个数，但是结果要对 1000000007，如计算初始结果为：1000000008，请返回 1。</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>使用 StringBuilder</p>
<p>自己写的时候的问题：<strong>大体上使用数组是对的，但是在做计算的时候写成了： arrs[i] = arrs[i - 1]%mod + arrs[i-2] % mod;，而实际上应该写成： arrs[i] = (arrs[i - 1] + arrs[i-2]) % mod; 以后要注意</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/zhi-xing-yong-shi-0-ms-zai-suo-you-java-ti-jiao-96/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<p>还可以延伸<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/mian-shi-ti-10-ii-qing-wa-tiao-tai-jie-wen-ti-dong/" target="_blank" rel="noopener">青蛙跳台阶问题</a></p>
<h3 id="面试题11、旋转数组的最小数字"><a href="#面试题11、旋转数组的最小数字" class="headerlink" title="面试题11、旋转数组的最小数字"></a>面试题11、旋转数组的最小数字</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>二分法</p>
<p>自己写的时候的问题：<strong>没啥难，就是要注意细节，1、没有旋转的情况  2、所有数字都相同的情况  3、只有一个数字的情况  4、剩下的就是从后面往前面找，当到某一个数字它的前面一个数字比当前数字大的时候，那最小数字就是当前数字了。</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题15、二进制中1的个数"><a href="#面试题15、二进制中1的个数" class="headerlink" title="面试题15、二进制中1的个数"></a>面试题15、二进制中1的个数</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>n &amp; (n -1)</p>
<p>自己写的时候的问题：<strong>没啥，还是 n &amp; (n-1)</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题18、删除链表的节点"><a href="#面试题18、删除链表的节点" class="headerlink" title="面试题18、删除链表的节点"></a>面试题18、删除链表的节点</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>两个指针</p>
<p>自己写的时候的问题：<strong>没啥，处理好head，之后就是常用的pre 指针、current 指针了</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/solution/mian-shi-ti-18-shan-chu-lian-biao-de-jie-dian-shua/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题21、-调整数组顺序使奇数位于偶数前面"><a href="#面试题21、-调整数组顺序使奇数位于偶数前面" class="headerlink" title="面试题21、 调整数组顺序使奇数位于偶数前面"></a>面试题21、 调整数组顺序使奇数位于偶数前面</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首尾双指针</p>
<p>自己写的时候的问题：<strong>没啥，很顺利。双指针，快排思想</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/solution/ti-jie-shou-wei-shuang-zhi-zhen-kuai-man-shuang-zh/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题22、-链表中倒数第k个节点"><a href="#面试题22、-链表中倒数第k个节点" class="headerlink" title="面试题22、 链表中倒数第k个节点"></a>面试题22、 链表中倒数第k个节点</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>前后指针</p>
<p>自己写的时候的问题：<strong>没啥，快慢指针，快指针先走k步</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/javajie-fa-shuang-zhi-zhen-by-shi-na-de-ya/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题24、-反转链表。反转一个单链表，如输入：-1-gt-2-gt-3-gt-4-gt-5-gt-Null-，则输出：5-gt-4-gt-3-gt-2-gt-1-gt-Null"><a href="#面试题24、-反转链表。反转一个单链表，如输入：-1-gt-2-gt-3-gt-4-gt-5-gt-Null-，则输出：5-gt-4-gt-3-gt-2-gt-1-gt-Null" class="headerlink" title="面试题24、 反转链表。反转一个单链表，如输入： 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;Null  ，则输出：5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;Null"></a>面试题24、 反转链表。反转一个单链表，如输入： 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;Null  ，则输出：5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;Null</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>存储当前节点和上一个节点</p>
<p>自己写的时候的问题：<strong>没啥，搞个pre</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<h3 id="面试题25、-合并两个排序的链表"><a href="#面试题25、-合并两个排序的链表" class="headerlink" title="面试题25、 合并两个排序的链表"></a>面试题25、 合并两个排序的链表</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>一个链表到表尾之后，需要接上另一个表的剩余部分</p>
<p>自己写的时候的问题：<strong>没啥，造一个空节点</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/solution/tu-jie-jian-zhi-offerzhi-he-bing-liang-ge-pai-xu-d/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>两个栈，一个维持压入数据，一个维持最小数栈，注意相同最小值要都压入最小数栈</p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/shuang-zhan-wei-hu-jie-fa-ji-linkedlistjie-fa-by-c/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题39、-数组中出现次数超过一半的数字"><a href="#面试题39、-数组中出现次数超过一半的数字" class="headerlink" title="面试题39、 数组中出现次数超过一半的数字"></a>面试题39、 数组中出现次数超过一半的数字</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>既然出现次数超过一半 那么排序后在中间的就是所需数字</p>
<p>自己写的时候的问题：<strong>先排序后取值不难，但是时间复杂度太高，提交的时候耗时1.3s；使用hashMap 计数，也不难，只是略微繁琐，还有 HashMap 额外占用空间。要熟练 摩尔计数法，这才是最优解。</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution/ji-ran-chu-xian-ci-shu-chao-guo-yi-ban-na-yao-pai-/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题40、最小的k个数"><a href="#面试题40、最小的k个数" class="headerlink" title="面试题40、最小的k个数"></a>面试题40、最小的k个数</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>大顶堆</p>
<p>自己写的时候的问题：<strong>暂时还没做</strong></p>
</details>

<p>还可以引申<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/" target="_blank" rel="noopener">数据流中中位数</a></p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/javada-ding-dui-shi-xian-by-lsz/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>要么取大值，要么另起炉灶</p>
<p>自己写的时候的问题：<strong>与之前写的 力扣53题的答案，这次更加简洁粗暴，直接判断result &lt; 0 是否成立，成立就放弃result，否则就还让它继续 result += element;重点记住这个答案就好</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/6xing-dai-ma-1ms-3xing-jie-shi-by-18716060157/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题50、第一个只出现一次的字符"><a href="#面试题50、第一个只出现一次的字符" class="headerlink" title="面试题50、第一个只出现一次的字符"></a>面试题50、第一个只出现一次的字符</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>hashmap 存储次数</p>
<p>自己写的时候的问题：<strong>HashMap 辅助，没啥难度。在 字符出现次数 &gt; 1 的时候，不要尝试去增加它的次数，节省put 操作。 因为 2次 和 100次 对我们意义是一样的</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/solution/java-shi-yong-ha-xi-biao-chang-gui-jie-fa-by-panc-/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题52、两个链表的第一个公共节点"><a href="#面试题52、两个链表的第一个公共节点" class="headerlink" title="面试题52、两个链表的第一个公共节点"></a>面试题52、两个链表的第一个公共节点</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。这样，当它们相遇时，所指向的结点就是第一个公共结点</p>
<p>自己写的时候的问题：<strong>刚开始脑抽只允许一个转换，其实 应该 A 和B两个链表应该各有一次转换机会。</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/shuang-zhi-zhen-fa-lang-man-xiang-yu-by-ml-zimingm/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题53-I、在排序数组中查找数字-I，统计一个数字在排序数组中出现的次数"><a href="#面试题53-I、在排序数组中查找数字-I，统计一个数字在排序数组中出现的次数" class="headerlink" title="面试题53 - I、在排序数组中查找数字 I，统计一个数字在排序数组中出现的次数"></a>面试题53 - I、在排序数组中查找数字 I，统计一个数字在排序数组中出现的次数</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>二分法</p>
<p>自己写的时候的问题：<strong>自己写没问题，二分查找没毛病。</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/java-liang-chong-er-fen-cha-zhao-fang-fa-by-caixia/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题53-II-0～n-1中缺失的数字。一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字"><a href="#面试题53-II-0～n-1中缺失的数字。一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字" class="headerlink" title="面试题53 - II. 0～n-1中缺失的数字。一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字"></a>面试题53 - II. 0～n-1中缺失的数字。一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>解法1：与下标是否相等 解法2：求和？(要考虑溢出)  解法3：二分法</p>
<p>自己写的时候的问题：<strong>在数组下标都对应得上的时候，缺失的就是最后一个数字，写的时候没想到这点。</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/solution/java-yi-ci-bian-li-hen-jian-dan-by-guard-2/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题56-I、数组中数字出现的次数。一个整型数组-nums-里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O-n-，空间复杂度是O-1"><a href="#面试题56-I、数组中数字出现的次数。一个整型数组-nums-里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O-n-，空间复杂度是O-1" class="headerlink" title="面试题56 - I、数组中数字出现的次数。一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)"></a>面试题56 - I、数组中数字出现的次数。一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>异或-&gt; 数字分组</p>
<p>自己写的时候的问题：<strong>不太熟练，自己只能想到全员异或，然后分组，之后想不到了。其实在分组过后，每组元素都是由 若干个出现两次的数字和一个只出现一次的数字  组成，组内异或就能得到那个只出现一次的数字。</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/zhi-chu-xian-yi-ci-de-shu-xi-lie-wei-yun-suan-by-a/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素"><a href="#给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素" class="headerlink" title="给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素"></a>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>全员异或</p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/single-number/solution/cou-yi-pian-ti-jie-hua-shuo-ti-jie-hen-hao-wan-by-/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题57、和为s的两个数字。输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可"><a href="#面试题57、和为s的两个数字。输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可" class="headerlink" title="面试题57、和为s的两个数字。输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可"></a>面试题57、和为s的两个数字。输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>双指针即可</p>
<p>自己写的时候的问题：<strong>没啥说的，提交完美。双指针即可</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/solution/2msshuang-100-by-wei-yu-13/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题58-I、翻转单词顺序。输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I-am-a-student-“，则输出”student-a-am-I”"><a href="#面试题58-I、翻转单词顺序。输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I-am-a-student-“，则输出”student-a-am-I”" class="headerlink" title="面试题58 - I、翻转单词顺序。输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”"></a>面试题58 - I、翻转单词顺序。输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>两次翻转</p>
<p>自己写的时候的问题：<strong>这题目本身就有点坑爹，注意审题，因为它首尾的空格要求在结果中去掉，并且单词间有多个空格也只保留一个。还有，清空StringBuilder 可以使用 sb.setLength(0) 的方式。其他的倒是没啥。</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution/fan-zhuan-dan-ci-shun-xu-by-peterbrave/" target="_blank" rel="noopener">力扣</a></p>
</blockquote>
<h3 id="面试题58-II、-左旋转字符串。字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”"><a href="#面试题58-II、-左旋转字符串。字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”" class="headerlink" title="面试题58 - II、 左旋转字符串。字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”"></a>面试题58 - II、 左旋转字符串。字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>subString即可</p>
<p>自己写的时候的问题：<strong>没啥，StringBuilder 拼接，简单粗暴</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/javaqie-pian-pin-jie-fa-by-abner-42/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<h3 id="面试题59-I、-滑动窗口的最大值。给定一个数组-nums-和滑动窗口的大小-k，请找出所有滑动窗口里的最大值"><a href="#面试题59-I、-滑动窗口的最大值。给定一个数组-nums-和滑动窗口的大小-k，请找出所有滑动窗口里的最大值" class="headerlink" title="面试题59 - I、 滑动窗口的最大值。给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值"></a>面试题59 - I、 滑动窗口的最大值。给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>上一次的最大值是不是被滑过的位置</p>
<p>自己写的时候的问题：<strong>自己写，不难。充分利用好上一次的最大值即可</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/bu-shi-yong-shu-ju-jie-gou-shuang-100-by-sun-239/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<h3 id="面试题61、-扑克牌中的顺子。从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为-0-，可以看成任意数字。A-不能视为-14"><a href="#面试题61、-扑克牌中的顺子。从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为-0-，可以看成任意数字。A-不能视为-14" class="headerlink" title="面试题61、 扑克牌中的顺子。从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14"></a>面试题61、 扑克牌中的顺子。从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>根据差值计算大小王是否够用就行</p>
<p>自己写的时候的问题：<strong>看懂原理，就不难(抄别人的)： 如果我们能够知道 5 张扑克牌中的最大值 maxValue 和最小值 minValue ，那我们就知道，要使它为顺子需要 maxValue - minValue + 1 张牌，所以我们只需要计算最大最小值(0除外)，然后通过上述规律来判断。当然，如果其中有重复的数字(0除外),那么肯定凑不齐了。所以我们关键是找最大最小值，以及判断是否重复。这里面的细节很多，比如boolean[] 用来表示元素是否重复的数组，它的index 不是 遍历牌的 i ，而是牌面值，即 nums[i]</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/solution/bu-ke-pai-zhong-de-shun-zi-pai-xu-fang-shi-he-bu-p/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<h3 id="面试题62、圆圈中最后剩下的数字。0-1-n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字"><a href="#面试题62、圆圈中最后剩下的数字。0-1-n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字" class="headerlink" title="面试题62、圆圈中最后剩下的数字。0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字"></a>面试题62、圆圈中最后剩下的数字。0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>约瑟夫环，记得公式就行（返回的是数组下标）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cir</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p=(p+m)%i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<blockquote>
<p>题目<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">leetcode</a>、解答参考<a href="https://blog.csdn.net/u011500062/article/details/72855826" target="_blank" rel="noopener">csdn</a></p>
</blockquote>
<h3 id="面试题65、不用加减乘除做加法。写一个函数，求两个整数之和，要求在函数体内不得使用-“-”、“-”、“-”、“-”-四则运算符号"><a href="#面试题65、不用加减乘除做加法。写一个函数，求两个整数之和，要求在函数体内不得使用-“-”、“-”、“-”、“-”-四则运算符号" class="headerlink" title="面试题65、不用加减乘除做加法。写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号"></a>面试题65、不用加减乘除做加法。写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>异或操作</p>
<p>自己写的时候的问题：<strong>凭记忆做出来了，后续还是要加强。 注意一点再java中不要做 &lt;&lt;&lt; 操作，非法的。</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/ni-hao-fan-te-xi-by-chen-san-shi/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<h3 id="面试题66、给定一个数组-A-0-1-…-n-1-，请构建一个数组-B-0-1-…-n-1-，其中-B-中的元素-B-i-A-0-×A-1-×…×A-i-1-×A-i-1-×…×A-n-1-。不能使用除法。"><a href="#面试题66、给定一个数组-A-0-1-…-n-1-，请构建一个数组-B-0-1-…-n-1-，其中-B-中的元素-B-i-A-0-×A-1-×…×A-i-1-×A-i-1-×…×A-n-1-。不能使用除法。" class="headerlink" title="面试题66、给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。"></a>面试题66、给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>对称数组</p>
<p>自己写的时候的问题：<strong>似懂非懂</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/solution/gou-jian-cheng-ji-shu-zu-dui-cheng-bian-li-by-huwt/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<h3 id="66、加一，给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一，最高位存放在数组收尾，数组中每个元素只存储单个数字，可以假设除了0之外，这个整数不会以0开头。假如输入：-1-2-3-，代表123，则输出-1-2-4-；输入-4-3-2-1-，代表-4321，则输出-4-3-2-2"><a href="#66、加一，给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一，最高位存放在数组收尾，数组中每个元素只存储单个数字，可以假设除了0之外，这个整数不会以0开头。假如输入：-1-2-3-，代表123，则输出-1-2-4-；输入-4-3-2-1-，代表-4321，则输出-4-3-2-2" class="headerlink" title="66、加一，给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一，最高位存放在数组收尾，数组中每个元素只存储单个数字，可以假设除了0之外，这个整数不会以0开头。假如输入：[1,2,3] ，代表123，则输出 [1,2,4]；输入 [4,3,2,1] ，代表 4321，则输出 [4,3,2,2]"></a>66、加一，给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一，最高位存放在数组收尾，数组中每个元素只存储单个数字，可以假设除了0之外，这个整数不会以0开头。假如输入：[1,2,3] ，代表123，则输出 [1,2,4]；输入 [4,3,2,1] ，代表 4321，则输出 [4,3,2,2]</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>它只是加一的话，可能的情况只有两种：</p>
<ul>
<li>除9之外的数字加一    </li>
<li>数字9加一<br>加一得十，进一位，个位数为0；如加法运算不出现进位，则运算就结束了。还有一种情况就是 当出现 9，99，999 之类的数字时，循环到最后也需要进位，需要手动将它进一位</li>
</ul>
<p>自己写的时候的问题：<strong>没啥问题，遍历每个元素让每个元素 +1 ，当某个元素 +1 之后 &lt; 10,就将当前数组返回；否则，加到最后也还没返回，就要新建一个数组，最开始位为1</strong></p>
</details>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/plus-one/solution/java-shu-xue-jie-ti-by-yhhzw/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章：异步编程</title>
    <url>/2019/11/13/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8-%E7%AC%AC4%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>在Flutter中，<strong>异步是使用 Future 来修饰的，并运行在 event loop 中</strong>，Flutter的异步特性和Android的Looper以及前端的 event loop 类似，都是不断地从事件队列里获取事件然后运行。</p><h3 id="isolate"><a href="#isolate" class="headerlink" title="isolate"></a>isolate</h3><p>所有的 Dart 代码都是在 isolate 上运行的，通常情况下，我们的应用都是运作在 main isolate 中，必要时，我们可以创建新的 isolate ，以便更好地利用 CPU 。isolate 在Flutter 中是个很重要的概念，它是通过 Flutter Engine 层面的一个线程来实现的。除了 isolate 所在的线程以外，还有其他的线程，他们跟 Flutter 的线程模型(Threading Mode) 有关。</p><a id="more"></a>

<blockquote>
<p>需要注意的是，多个 isolate 无法共享内存，必须通过相关 API 通信才可以。</p>
</blockquote>
<h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h3><p>理解 event loop ，首先可以看下图：</p>
<p><img src="/assets/Book-Notes/Flutter%E4%BB%8E0%E5%88%B01%E5%BA%94%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/%E7%AC%AC4%E7%AB%A0/event_loop%E5%9B%BE%E7%A4%BA.png" alt="event loop图示"></p>
<p>图中运行的步骤如下：</p>
<ol>
<li>运行 App并执行 main 方法。    </li>
<li>开始并<strong>优先处理 microtask queue</strong> ，直到队列为空。    </li>
<li>开始处理 event queue，如果里面有 event，则执行（<strong>每次只取一条</strong>），每执行一条再判断 microtask queue 是否有新的消息。    </li>
<li>microtask queue 和 event queue 都为空，则 App 可以正常退出。</li>
</ol>
<blockquote>
<p>当处理 microtask queue 时，event queue 是会被阻塞的，所以 microtask queue 应当避免耗时操作，否则将导致 App 的绘制和交互被卡住。<strong>所以，绘制和交互等应该作为event存放在event queue中更合适。</strong></p>
</blockquote>
<h3 id="线程模型与isolate"><a href="#线程模型与isolate" class="headerlink" title="线程模型与isolate"></a>线程模型与isolate</h3><p>isolate是通过Flutter Engine 层面的一个线程来实现的，Flutter Engine 线程的创建和管理是由 embedder(嵌入层) 负责的，embedder 是平台引擎移植的中间层代码，其运行架构如下：</p>
<p><img src="/assets/Book-Notes/Flutter%E4%BB%8E0%E5%88%B01%E5%BA%94%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/%E7%AC%AC4%E7%AB%A0/flutter_engine%E6%9E%B6%E6%9E%84.png" alt="Flutter engine运行架构"></p>
<p>它提供了4种Task Runner。</p>
<ul>
<li>Platform Task Runner</li>
</ul>
<blockquote>
<p>Platform Task Runner 是Flutter Engine 的主 Task Runner，不仅可以处理与 Engine 的交互，还可以处理来自 Native(Android/ios) 平台的交互。Flutter应用启动时会创建一个Engine实例，Engine会创建一个Platform Thread 供Platform Task Runner 使用。即使Platform Thread 被阻塞，也不会直接导致Flutter应用的卡顿，尽管如此，还是不建议在Platform Task Runner 里面执行繁重的耗时操作，因为长时间卡住Platform Thread ，应用可能会被系统的 Watchdog 强行终止。</p>
</blockquote>
<ul>
<li>UI Task Runner</li>
</ul>
<blockquote>
<p>UI Task Runner 不能想当然地认为像Android那样运行在主线程，它其实运行在线程对应到平台的线程上的，属于<strong>子线程</strong>。在Root isolate 通知 Flutter Engine 有帧需要被渲染时，UI Task Runner 就会生成 Layer Tree 并交给 Flutter Engine。该Tree 最终决定什么内容会在屏幕上被绘制。因此，如果UI Task Runner 过载会导致卡顿。<br>UI Task Runner 还可以处理来自 Native plugin 的消息、timers、microtasks、异步I/O操作。</p>
</blockquote>
<ul>
<li>GPU Task Runner</li>
</ul>
<blockquote>
<p>GPU Task Runner 被用于执行与设备GPU相关的调用，它运行的线程对应着平台的子线程，它可以将 UI Task Runner 生成的 Layer Tree 所提供的信息转化为实际的GPU指令。GPU Task Runner 会根据目前帧被执行的进度向 UI Task Runner 要求下一帧数据，这样可以避免 UI Task Runner 不必要的消耗。GPU Task Runner 任务过重会造成Flutter应用卡顿。</p>
</blockquote>
<ul>
<li>IO Task Runner</li>
</ul>
<blockquote>
<p>IO Task Runner 也对应着平台的子线程。当UI Task Runner 和 GPU Task Runner 都出现过载时，Flutter应用卡顿，IO Task Runner 会负责做一些预处理的读取工作，然后再上报给 GPU Task Runner，相当于 GPU Task Runner 的助手，助其减少额外工作。</p>
</blockquote>
<h3 id="Stream事件流"><a href="#Stream事件流" class="headerlink" title="Stream事件流"></a>Stream事件流</h3><p>略</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Flutter从0到1构建大前端应用</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-多线程知识</title>
    <url>/2019/11/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="1、线程同步，你了解哪几种方式？"><a href="#1、线程同步，你了解哪几种方式？" class="headerlink" title="1、线程同步，你了解哪几种方式？"></a>1、线程同步，你了解哪几种方式？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<ol>
<li>数据同步：可以使用Android 提供的同步容器。如： CopyOnWriteArrayList（当某个线程要修改list的元素时，首先copy一份出来，然后在修改前加锁，防止多个线程同时修改而copy多个副本，读的时候无需加锁，读的是副本）、concurrentHashMap（分段锁）、BlockingQueue（队列满了，在调用put，会阻塞，直到不再是满的；同理，取也是一样）。</li>
<li>用锁。同步锁：synchronize（无论synchronized关键字加在方法上还是对象上，他锁的都是对象，而不是把一段代码或函数当作锁）、ReentrantLock</li>
</ol>
</blockquote>
</details><a id="more"></a>

<h2 id="2、synchronized-与-Lock。讲下-RecentLock-可重入锁？-什么是可重入锁？为什么要设计可重入锁？"><a href="#2、synchronized-与-Lock。讲下-RecentLock-可重入锁？-什么是可重入锁？为什么要设计可重入锁？" class="headerlink" title="2、synchronized 与 Lock。讲下 RecentLock 可重入锁？ 什么是可重入锁？为什么要设计可重入锁？"></a>2、synchronized 与 Lock。讲下 RecentLock 可重入锁？ 什么是可重入锁？为什么要设计可重入锁？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<p><strong>介绍：</strong>synchronized：无论synchronized关键字加在方法上还是对象上，他锁的都是对象，而不是把一段代码或函数当作锁。<br>Lock：一般使用ReentrantLock类做为锁，需要显式指出加锁与释放锁的位置，在加锁和解锁处通过lock()和unlock()显示指出，所以一般会在finally块中写unlock()以防死锁。  </p>
</blockquote>
<blockquote>
<p><strong>区别：</strong>  </p>
</blockquote>
<ul>
<li>synchronized 是个关键字，而 Lock 是个接口  </li>
<li>synchronized 使用简单，会自动释放；Lock需要显式加锁与释放，要防止死锁  </li>
<li>synchronized是悲观锁，其他线程只能阻塞来等待线程释放锁；Lock是乐观锁。  </li>
<li>lock可以使我们多线程交互变得方便，而使用synchronized则无法做到这点。如：某个线程在等待锁的过程中需要中断、或者获知某个线程有没有获取到锁、或者需要指定notify哪个线程</li>
</ul>
</details>

<h2 id="3、为什么wait、notify、notifyAll-方法在object-类中，而sleep-在Thread-类中？"><a href="#3、为什么wait、notify、notifyAll-方法在object-类中，而sleep-在Thread-类中？" class="headerlink" title="3、为什么wait、notify、notifyAll 方法在object 类中，而sleep 在Thread 类中？"></a>3、为什么wait、notify、notifyAll 方法在object 类中，而sleep 在Thread 类中？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>一个例子，假如要做的事情是“生火-烧水-煮面”。sleep 就是，当我生火之后，觉得有点累，要休息一段时间，所以并不立即烧水，等过会再烧，休息的这段时间是由我自己来控制的，这个灶台我也要一直占用；而对于wait，首先，wait 是由某个object 来调用的，这个object 类似于监督人的角色，当我点火在烧水的过程中，监督人要求我停下来，不允许我继续烧水了，同时剥夺我灶台使用权，让其他人先用灶台，我在旁边等着，直到这个监督人通知(notify/notifyAll)我可以继续使用灶台了，我才能继续。</p>
<p>通过这个例子，我们可以知道：</p>
<ul>
<li>首先，sleep 和 其他的是有本质区别的：sleep 是一个线程的运行状态控制，所以交给Thread 自己更合适；而wait 是线程之间的通讯工具，交给object更合适，这样各个竞争线程不需要知道彼此的存在。       </li>
<li>其次，wait、notify与notifyAll 是锁级别的操作，而锁属于对象，每个对象都可能作为锁，所以它们定义在Object 类中。       </li>
</ul>
<p>从另一个角度来说是，假如不这样做的话，即如果wait、notify和notifyAll 都在Thread 中，会有什么问题：</p>
<p>首先，wait 方法仍然可以使当前线程挂起，但是挂起后怎么被其他线程唤起呢？因为唤起时需要知道要唤起哪个线程。<br>其次，notify 与 notifyAll 都需要知道目前需要唤醒哪些线程。</p>
<p>当然你可以说我们使用共享变量或者其他方式，这无疑会增加线程间通信的复杂性，并带来安全隐患，所以并没有必要。</p>
<blockquote>
<p>值得注意的是：必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()、notify()或notifyAll()方法。原因很简单，如果这个代码块或者方法不是同步的，那么进入其中必然是不需要获取锁的，所以释放锁和等待锁就无从谈起，这时候调用的话会报 IllegalMonitorStateException。Java 给报这个错，其实就是不想让我们的程序在不经意间出现 Lost Wake-Up 问题。</p>
</blockquote>
<blockquote>
<p>以上内容<a href="https://blog.csdn.net/liuzhe_2008/article/details/36901737" target="_blank" rel="noopener">参考csdn的这篇文章</a></p>
</blockquote>
</details>

<h2 id="4、延伸-深究-notify-wait-方法为什么一定要放在同步块中？"><a href="#4、延伸-深究-notify-wait-方法为什么一定要放在同步块中？" class="headerlink" title="4、延伸-深究 notify/wait 方法为什么一定要放在同步块中？"></a>4、延伸-深究 notify/wait 方法为什么一定要放在同步块中？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>前面谈到的是没有同步就没必要释放或者等待锁，这里深究如果不放在同步块中会出现什么问题。这主要是涉及到 <strong>“Lost Wake-Up Problem”</strong>问题。</p>
<p>我们notify/wait 很典型的一个用途就是生产者-消费者 场景，伪代码如下：</p>
<p>生产者：</p>
<blockquote>
<p>count ++;<br>notify();    </p>
</blockquote>
<p>消费者：</p>
<blockquote>
<p>while(count &lt;= 0) wait();<br>count –;    </p>
</blockquote>
<p>生产者和消费着都有两个步骤，如果不在同步块中的话，多线程情况下执行顺序很难保证，有可能会出现如下图所示的执行顺序：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E4%B9%B1%E5%BA%8F.png" alt="生产消费乱序"></p>
<p>初始的时候，count == 0，消费者发现条件成立，此时，发生上下文切换，生产者线程一顿操作执行了 count ++，之后发出了通知准备唤醒一个线程，这时候消费者刚决定wait，但是还没进入wait，此时，由于消费者线程还未进入wait状态，因此在等待队列中还找不到消费者线程，这个notify就被丢掉了。</p>
<blockquote>
<p>以上内容<a href="https://blog.csdn.net/belalds/article/details/89225104" target="_blank" rel="noopener">参考自360linker</a>的博客</p>
</blockquote>
</details>

<h2 id="5、两个线程交替打印，一个输出偶数，一个输出奇数"><a href="#5、两个线程交替打印，一个输出偶数，一个输出奇数" class="headerlink" title="5、两个线程交替打印，一个输出偶数，一个输出奇数"></a>5、两个线程交替打印，一个输出偶数，一个输出奇数</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>第一种，使用synchronize 关键字，锁住对象，每次只能一个线程进入。每打印一个数，就释放锁，然后挂起自己，如此往复：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MainClass obj = <span class="keyword">new</span> MainClass();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(obj::printOdds);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(obj::printEven);</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printOdds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"t1---"</span> + i);</span><br><span class="line">            notify();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printEven</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"t2---"</span> + i);</span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种，使用volatile 来保证:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                <span class="keyword">for</span> (;num&lt;=<span class="number">100</span>;)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!flag &amp;&amp; (num == <span class="number">0</span> || ++num %<span class="number">2</span> == <span class="number">0</span>))&#123;<span class="comment">//打印偶数</span></span><br><span class="line">                        System.out.println(num);</span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                <span class="keyword">for</span> (;num&lt;<span class="number">100</span>;)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (flag &amp;&amp; ++num %<span class="number">2</span> != <span class="number">0</span>)&#123;<span class="comment">//打印奇数</span></span><br><span class="line">                        System.out.println(num);</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中 num 和flag 都必须为volatile ，根据短路机制，if 语句中基本上只需要管 flag的值，所以即使 ++num 这个操作是非原子性的，也无妨。</p>
<blockquote>
<p>以上内容参考<a href="https://www.cnblogs.com/stateis0/p/9091254.html" target="_blank" rel="noopener">莫那.鲁道的博客</a></p>
</blockquote>
<h3 id="如何控制某个方法允许并发访问线程的个数？"><a href="#如何控制某个方法允许并发访问线程的个数？" class="headerlink" title="如何控制某个方法允许并发访问线程的个数？"></a>如何控制某个方法允许并发访问线程的个数？</h3></details>

<h2 id="6、Java创建线程的三种方式"><a href="#6、Java创建线程的三种方式" class="headerlink" title="6、Java创建线程的三种方式"></a>6、Java创建线程的三种方式</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>继承Thread类。优点：使用简单 缺点：已经继承Thread 类，不能继承其它类。    </li>
<li>实现runnable 接口，创建线程类。    </li>
<li>通过Callable 和 Future 创建线程。</li>
</ul>
<blockquote>
<p>以上内容参考自：<a href="https://www.androidos.net.cn/codebook/AndroidRoad/java/concurrence/CreateThread.html" target="_blank" rel="noopener">Java创建线程的三种方式</a></p>
</blockquote>
</details>

<h2 id="7、synchronized原理"><a href="#7、synchronized原理" class="headerlink" title="7、synchronized原理"></a>7、synchronized原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>JVM基于进入和退出Monitor对象来实现 代码块同步 和 方法同步 ，两者实现细节不同。</p>
<p>代码块同步： 在编译后通过将monitorenter指令插入到同步代码块的开始处，将monitorexit指令插入到方法结束处和异常处，通过反编译字节码可以观察到。任何一个对象都有一个monitor与之关联，线程执行monitorenter指令时，会尝试获取对象对应的monitor的所有权，即尝试获得对象的锁。</p>
<p>方法同步： synchronized方法在method_info结构有ACC_synchronized标记，线程执行时会识别该标记，获取对应的锁，实现方法同步。</p>
<p>两者虽然实现细节不同，但本质上都是对一个对象的监视器（monitor）的获取。任意一个对象都拥有自己的监视器，当同步代码块或同步方法时，执行方法的线程必须先获得该对象的监视器才能进入同步块或同步方法，没有获取到监视器的线程将会被阻塞，并进入同步队列，状态变为BLOCKED。当成功获取监视器的线程释放了锁后，会唤醒阻塞在同步队列的线程，使其重新尝试对监视器的获取。</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronize%E5%8E%9F%E7%90%86.png" alt="对象、监视器、同步队列和执行线程间的关系"></p>
<blockquote>
<p>以上内容参考自：<a href="http://www.androidos.net.cn/book/android-road/java/concurrence/synchronized-reentrantlock.html" target="_blank" rel="noopener">synchronized原理</a></p>
</blockquote>
</details>

<h2 id="8、线程间通信？"><a href="#8、线程间通信？" class="headerlink" title="8、线程间通信？"></a>8、线程间通信？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>1、通过内存共享，共享内存中的信息是公共可见的，但是需要显式地进行同步，可以使用Synchronize 和 Lock 来进行同步。    </p>
<p>2、notify/wait 方法</p>
<p>3、Condition 实现等待/通知</p>
<blockquote>
<p>以上内容部分参考自： <a href="http://www.androidos.net.cn/book/android-road/java/concurrence/producer-consumer.html" target="_blank" rel="noopener">线程通信</a></p>
</blockquote>
</details>

<h2 id="9、单例中，为什么要使用volatile-修饰instance？"><a href="#9、单例中，为什么要使用volatile-修饰instance？" class="headerlink" title="9、单例中，为什么要使用volatile 修饰instance？"></a>9、单例中，为什么要使用volatile 修饰instance？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:</p>
<p>1.给 instance 分配内存<br>2.调用 Singleton 的构造函数来初始化成员变量<br>3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。</p>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>
</details>

<h2 id="10、有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#10、有三个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="10、有三个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>10、有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>参考2个线程的即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                <span class="keyword">for</span> (;num&lt;=<span class="number">100</span>;)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="number">1</span>)&#123;</span><br><span class="line">                        ++num;</span><br><span class="line">                        System.out.println(<span class="string">"t1-"</span>+ num);</span><br><span class="line">                        flag = <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                <span class="keyword">for</span> (;num&lt;<span class="number">100</span>;)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="number">2</span>)&#123;</span><br><span class="line">                        ++num;</span><br><span class="line">                        System.out.println(<span class="string">"t2-"</span>+ num);</span><br><span class="line">                        flag = <span class="number">3</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                <span class="keyword">for</span> (;num&lt;<span class="number">100</span>;)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="number">3</span>)&#123;</span><br><span class="line">                        ++num;</span><br><span class="line">                        System.out.println(<span class="string">"t3-"</span>+ num);</span><br><span class="line"></span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="11、Java停止一个正在运行的线程"><a href="#11、Java停止一个正在运行的线程" class="headerlink" title="11、Java停止一个正在运行的线程"></a>11、Java停止一个正在运行的线程</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>采用经过volatile 标记的变量来控制    </li>
<li>Thread.stop() ，但是不推荐    </li>
<li>使用FutureTash 时，可以使用其 cancel() 方法来取消任务    </li>
<li>使用return 关键字    </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"开始执行"</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"return 之后"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码只会打印 “开始执行”  ，代码中if是需要的，不然会提示编译不通过。</p>
<blockquote>
<p>以上部分内容参考自：<a href="https://blog.csdn.net/abreaking2012/article/details/83376951?utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">Java如何停止线程</a></p>
</blockquote>
</details>

<h2 id="12、Java线程池工作原理"><a href="#12、Java线程池工作原理" class="headerlink" title="12、Java线程池工作原理"></a>12、Java线程池工作原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="线程池好处"><a href="#线程池好处" class="headerlink" title="线程池好处"></a>线程池好处</h3><ul>
<li>复用已经创建的线程，降低线程创建和销毁带来的损耗      </li>
<li>提高响应速度。当任务到达时，可以复用已有线程，无需等到线程创建就能立即执行    </li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制创建，不仅消耗系统资源，延长线程等待时间，还可能降低系统稳定性。</li>
</ul>
<h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h3><ol>
<li>新建状态(New)：新建一个线程对象    </li>
<li>就绪状态(Runnable)：调用线程的 start() 方法，线程变成可运行状态，其他资源都已经获取，只等cpu了     </li>
<li>运行状态(Running)：就绪状态的线程获取CPU，执行    </li>
<li>阻塞状态(Blocked)：由于某种原因放弃cpu使用权。可能是调用了线程的 wait() 方法、或者等待获取同步锁、或者是执行了sleep()或者其他线程执行了 join()    </li>
<li>死亡状态(Dead)：线程执行完了或者因为一场退出run()     </li>
</ol>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程生命周期"></p>
</details>

<blockquote>
<p>以上代码参考自：<a href="https://itimetraveler.github.io/2018/02/13/%E3%80%90Java%E3%80%91%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" target="_blank" rel="noopener">java线程池</a></p>
</blockquote>
<h2 id="13、死锁条件"><a href="#13、死锁条件" class="headerlink" title="13、死锁条件"></a>13、死锁条件</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>产生死锁的四个条件（满足才会死锁）：</p>
<ol>
<li>互斥使用    </li>
<li>不可剥夺    </li>
<li>请求保持    </li>
<li>循环等待    </li>
</ol>
<p>破坏任意一个条件即可解锁</p>
</details>

<h2 id="14、引申-写个简单的死锁程序"><a href="#14、引申-写个简单的死锁程序" class="headerlink" title="14、引申-写个简单的死锁程序"></a>14、引申-写个简单的死锁程序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">      Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">      Thread thread1 = <span class="keyword">new</span> Thread(<span class="string">"thread1"</span>)&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.run();</span><br><span class="line">              <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">                  System.out.println(Thread.currentThread().getName() + <span class="string">"进入第1层锁"</span>);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      sleep(<span class="number">1000</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + <span class="string">"进入第2层锁"</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Thread thread2 = <span class="keyword">new</span> Thread(<span class="string">"thread1"</span>)&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.run();</span><br><span class="line">              <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">                  System.out.println(Thread.currentThread().getName() + <span class="string">"进入第1层锁"</span>);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      sleep(<span class="number">1000</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + <span class="string">"进入第2层锁"</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      thread1.start();</span><br><span class="line">      thread2.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="15、synchronized-关键字"><a href="#15、synchronized-关键字" class="headerlink" title="15、synchronized 关键字"></a>15、synchronized 关键字</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>当执行如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Method 1 start"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译之后能看到 monitorenter 和 monitorexit 字样，关于这两条指令，jvm中的解释如下：</p>
<blockquote>
<p>每个对象都有一个监视器锁(monitor)，当monitor 被占用时就处于锁定状态，线程执行 monitorenter 指令时，就尝试获取 monitor的所有权，过程如下：    </p>
</blockquote>
<blockquote>
<p>1、如果 monitor 的进入数为 0 ，则该线程进入 monitor，然后将进入数设置为 1，即该现成为 monitor 的所有者。    </p>
</blockquote>
<blockquote>
<p>2、如果有线程已经占有 monitor ，之后又重新进入，则 monitor 的进入数加 1。    </p>
</blockquote>
<blockquote>
<p>3、如果其他线程已经占用了 monitor ，则当前线程进入阻塞状态，直到 monitor 的进入数为 0(之后被唤醒)，再重新获取 monitor 的所有权。</p>
</blockquote>
<p>反之，monitorexit 则是线程退出的一个过程。</p>
<p>所以我们知道，修饰代码块时，synchronized 底层是通过 monitor 对象来完成的，<strong>其实，wait/notify方法也是依赖于 monitor 对象的，这也是为什么只有再同步块中才能调用 wait/notify 等方法(因为wait 等待的是啥？其实等待的就是对象的 monitor，由于所有类都是object ，里面内置有一个 monitor，因此自然所有类都应该有 wait/notify 方法)。</strong></p>
<p>在修饰成员方法时，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译过后就会有 ACC_SYNCHRONIZED 标识符(没有用 monitorenter 和 monitorexit，其实理论上也是可以的)，jvm 根据这个标识符来实现方法同步：当调用方法时，首先检查方法的 ACC_SYNCHRONIZED 标志是否被设置，如果设置了，则线程首先获取 monitor，获取成功后才能执行方法，方法执行完成后再释放 monitor，方法执行期间，其他对象无法再获得同一个 monitor。所以与修饰 代码块 的时候本质上是没有区别的。</p>
<p>最后，如果修饰的是静态方法，则锁定的是 class 对象。</p>
<blockquote>
<p>以上内容参考自：<a href="https://www.cnblogs.com/paddix/p/5367116.html" target="_blank" rel="noopener">Synchronized及其实现原理</a></p>
</blockquote>
</details>

<h2 id="16、synchronized-锁持有的object-是Thread-对象"><a href="#16、synchronized-锁持有的object-是Thread-对象" class="headerlink" title="16、synchronized 锁持有的object 是Thread 对象"></a>16、synchronized 锁持有的object 是Thread 对象</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>看过上面synchronized原理，我们来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread threadTest = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行线程中方法"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    threadTest.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (threadTest) &#123;<span class="comment">//这里不明白可以想象单例的 synchronized 用法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadTest.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"执行到了这里"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，wait 必须在同步块中执行，上述代码也是这样的；同时我们也知道，wait() 方法后，必须收到 notify/notifyAll 之后才能结束等待状态。但是上述代码首先输出 “执行线程中方法”  ，之后输出 “执行到了这里” ，明明没有notify ，怎么就能结束 wait 状态呢？其实这是因为synchronized 获得对象锁是 Thread 对象的锁时，当该线程执行完成后，会调用线程自身的 notifyAll() 方法，通知所有等待在该线程对象上的线程。所以，用这种方式能够实现 join 的功能，使得线程依次执行。</p>
<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/chenkaibsw/article/details/80912878" target="_blank" rel="noopener">csdn上的博客</a></p>
</blockquote>
</details>

<h2 id="17、引申-理解Java-中的-join"><a href="#17、引申-理解Java-中的-join" class="headerlink" title="17、引申-理解Java 中的 join"></a>17、引申-理解Java 中的 join</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>如果要用join 方法实现上述功能，可以这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread threadTest = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行线程中方法"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    threadTest.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadTest.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"执行到了这里"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>join 方法从字面上理解就是新线程加入进来，等新线程执行完后，老的线程才继续执行。我们日常使用 join 方法是通过 join(0) 来实现的，我们看它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;             <span class="comment">//如果时执行的join(0)</span></span><br><span class="line">           <span class="keyword">while</span> (isAlive()) &#123;        <span class="comment">//如果线程是运行状态，就会执行下面的等待</span></span><br><span class="line">               wait(<span class="number">0</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;                       <span class="comment">//如果是执行的join(time)</span></span><br><span class="line">           <span class="keyword">while</span> (isAlive()) &#123;               <span class="comment">//如果线程时运行状态</span></span><br><span class="line">               <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">               <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               wait(delay);                 <span class="comment">//等待delay时间后自动返回继续执行</span></span><br><span class="line">               now = System.currentTimeMillis() - base;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 while (isAlive()) { wait(0) } ，我们日常调用的 wait() 方法就是调用的 wait(0) 实现，因此这里本质还是 执行了 wait 方法，就是让其一直等待。所以我们上述代码： threadTest.join() 本质是利用 threadTest 对象作为对象锁，当线程终止时，会调用线程自身的 notifyAll ，因此这个 wait 就解除了。</p>
<p>再说下 while (isAlive())，这是在判断线程是否线程是否已经执行了start() 方法，因此如果还没有start() 则不会执行wait() 方法。可以用如下代码验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"t1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"t2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t2.start();<span class="comment">//先启动t2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t1.start();<span class="comment">//延迟2秒后启动t1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看起来执行了 t1.join() ，应该要等t1执行完了才会执行t2，但是呢，这里最终输出： t2  t1 ，即 t2 还是会先执行。这是因为在执行 t1.join() 的时候，t1并没有执行 start() ，isAlive() 为false，因此不生效。</p>
<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/chenkaibsw/article/details/80912878" target="_blank" rel="noopener">csdn上的博客</a></p>
</blockquote>
</details>

<h2 id="18、wait-sleep-yield-join-方法"><a href="#18、wait-sleep-yield-join-方法" class="headerlink" title="18、wait/sleep/yield/join 方法"></a>18、wait/sleep/yield/join 方法</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>wait() 方法的作用是将当前线程挂起，让其进入阻塞状态，直到 notify/notifyAll 方法来唤醒线程，很容易理解，wait 是释放了锁资源的。</p>
<p>wait(long timeout)方法与 wait 相似，区别在于如果再指定时间内没有被notify/notifyAll ，则自动唤醒。</p>
<p>sleep方法只是暂时让出cpu执行权，并不释放锁，而 wait 是释放锁的。</p>
<p>yield 方法只是暂停当前线程，以便其他线程有机会运行，不过不能指定暂停时间，也不能保证当前线程立即停止。yield 方法只是将thread 的状态由 Running 转变为 Runable 状态。不过<strong>调度器可能会忽略这个方法，并且Java官方建议只用这个方法用于调试和测试。</strong></p>
<p>join 方法是父线程等待子线程执行完之后再执行。</p>
<blockquote>
<p>以上内容参考自<a href="https://www.cnblogs.com/paddix/p/5381958.html" target="_blank" rel="noopener">cnblogs的博客</a></p>
</blockquote>
</details>

<h2 id="19、实现线程安全的方法（三种）"><a href="#19、实现线程安全的方法（三种）" class="headerlink" title="19、实现线程安全的方法（三种）"></a>19、实现线程安全的方法（三种）</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>互斥同步    </li>
</ul>
<blockquote>
<p>指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个(再使用信号量的时候可以是一些)线程使用，Java中典型的互斥同步手段是 synchronized 关键字，以及 ReentrantLock 类。</p>
</blockquote>
<ul>
<li>非阻塞同步    </li>
</ul>
<blockquote>
<p>互斥同步主要的问题就是线程阻塞和唤醒带来的性能问题，因此也称为阻塞同步。非阻塞同步就是先进行操作，如果没有其它线程争用共享数据，操作就成功了，否则产生冲突再补偿(比如自旋不断重试，直到成功为止)，这种乐观方式无需把线程挂起和唤醒，CAS 的出现也为非阻塞同步提供了条件。</p>
</blockquote>
<ul>
<li>无同步方案    </li>
</ul>
<blockquote>
<p>如果方法本来就没有涉及共享数据，每次输入相同的数据就能得到相同的输出，这种情况当然无需进行同步。</p>
</blockquote>
</details>


<h2 id="20、死锁"><a href="#20、死锁" class="headerlink" title="20、死锁"></a>20、死锁</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>产生死锁的四个条件（满足才会死锁）：</p>
<ol>
<li>互斥使用    </li>
<li>不可剥夺    </li>
<li>请求保持    </li>
<li>循环等待    </li>
</ol>
<p>破坏任意一个条件即可解锁</p>
<details>

<h2 id="21、引申-写个简单的死锁程序"><a href="#21、引申-写个简单的死锁程序" class="headerlink" title="21、引申-写个简单的死锁程序"></a>21、引申-写个简单的死锁程序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">      Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">      Thread thread1 = <span class="keyword">new</span> Thread(<span class="string">"thread1"</span>)&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.run();</span><br><span class="line">              <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">                  System.out.println(Thread.currentThread().getName() + <span class="string">"进入第1层锁"</span>);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      sleep(<span class="number">1000</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + <span class="string">"进入第2层锁"</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Thread thread2 = <span class="keyword">new</span> Thread(<span class="string">"thread1"</span>)&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.run();</span><br><span class="line">              <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">                  System.out.println(Thread.currentThread().getName() + <span class="string">"进入第1层锁"</span>);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      sleep(<span class="number">1000</span>);</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + <span class="string">"进入第2层锁"</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      thread1.start();</span><br><span class="line">      thread2.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="22、synchronized-关键字"><a href="#22、synchronized-关键字" class="headerlink" title="22、synchronized 关键字"></a>22、synchronized 关键字</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>当执行如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Method 1 start"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译之后能看到 monitorenter 和 monitorexit 字样，关于这两条指令，jvm中的解释如下：</p>
<blockquote>
<p>每个对象都有一个监视器锁(monitor)，当monitor 被占用时就处于锁定状态，线程执行 monitorenter 指令时，就尝试获取 monitor的所有权，过程如下：    </p>
</blockquote>
<blockquote>
<p>1、如果 monitor 的进入数为 0 ，则该线程进入 monitor，然后将进入数设置为 1，即该现成为 monitor 的所有者。    </p>
</blockquote>
<blockquote>
<p>2、如果有线程已经占有 monitor ，之后又重新进入，则 monitor 的进入数加 1。    </p>
</blockquote>
<blockquote>
<p>3、如果其他线程已经占用了 monitor ，则当前线程进入阻塞状态，直到 monitor 的进入数为 0(之后被唤醒)，再重新获取 monitor 的所有权。</p>
</blockquote>
<p>反之，monitorexit 则是线程退出的一个过程。</p>
<p>所以我们知道，修饰代码块时，synchronized 底层是通过 monitor 对象来完成的，<strong>其实，wait/notify方法也是依赖于 monitor 对象的，这也是为什么只有再同步块中才能调用 wait/notify 等方法(因为wait 等待的是啥？其实等待的就是对象的 monitor，由于所有类都是object ，里面内置有一个 monitor，因此自然所有类都应该有 wait/notify 方法)。</strong></p>
<p>在修饰成员方法时，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译过后就会有 ACC_SYNCHRONIZED 标识符(没有用 monitorenter 和 monitorexit，其实理论上也是可以的)，jvm 根据这个标识符来实现方法同步：当调用方法时，首先检查方法的 ACC_SYNCHRONIZED 标志是否被设置，如果设置了，则线程首先获取 monitor，获取成功后才能执行方法，方法执行完成后再释放 monitor，方法执行期间，其他对象无法再获得同一个 monitor。所以与修饰 代码块 的时候本质上是没有区别的。</p>
<p>最后，如果修饰的是静态方法，则锁定的是 class 对象。</p>
<blockquote>
<p>以上内容参考自：<a href="https://www.cnblogs.com/paddix/p/5367116.html" target="_blank" rel="noopener">Synchronized及其实现原理</a></p>
</blockquote>
</details>

<h2 id="23、synchronized-锁持有的object-是Thread-对象"><a href="#23、synchronized-锁持有的object-是Thread-对象" class="headerlink" title="23、synchronized 锁持有的object 是Thread 对象"></a>23、synchronized 锁持有的object 是Thread 对象</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>看过上面synchronized原理，我们来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread threadTest = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行线程中方法"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    threadTest.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (threadTest) &#123;<span class="comment">//这里不明白可以想象单例的 synchronized 用法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadTest.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"执行到了这里"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，wait 必须在同步块中执行，上述代码也是这样的；同时我们也知道，wait() 方法后，必须收到 notify/notifyAll 之后才能结束等待状态。但是上述代码首先输出 “执行线程中方法”  ，之后输出 “执行到了这里” ，明明没有notify ，怎么就能结束 wait 状态呢？其实这是因为synchronized 获得对象锁是 Thread 对象的锁时，当该线程执行完成后，会调用线程自身的 notifyAll() 方法，通知所有等待在该线程对象上的线程。所以，用这种方式能够实现 join 的功能，使得线程依次执行。</p>
<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/chenkaibsw/article/details/80912878" target="_blank" rel="noopener">csdn上的博客</a></p>
</blockquote>
<details>

<h2 id="24、引申-理解Java-中的-join"><a href="#24、引申-理解Java-中的-join" class="headerlink" title="24、引申-理解Java 中的 join"></a>24、引申-理解Java 中的 join</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>如果要用join 方法实现上述功能，可以这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread threadTest = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行线程中方法"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    threadTest.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadTest.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"执行到了这里"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>join 方法从字面上理解就是新线程加入进来，等新线程执行完后，老的线程才继续执行。我们日常使用 join 方法是通过 join(0) 来实现的，我们看它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;             <span class="comment">//如果时执行的join(0)</span></span><br><span class="line">           <span class="keyword">while</span> (isAlive()) &#123;        <span class="comment">//如果线程是运行状态，就会执行下面的等待</span></span><br><span class="line">               wait(<span class="number">0</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;                       <span class="comment">//如果是执行的join(time)</span></span><br><span class="line">           <span class="keyword">while</span> (isAlive()) &#123;               <span class="comment">//如果线程时运行状态</span></span><br><span class="line">               <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">               <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               wait(delay);                 <span class="comment">//等待delay时间后自动返回继续执行</span></span><br><span class="line">               now = System.currentTimeMillis() - base;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 while (isAlive()) { wait(0) } ，我们日常调用的 wait() 方法就是调用的 wait(0) 实现，因此这里本质还是 执行了 wait 方法，就是让其一直等待。所以我们上述代码： threadTest.join() 本质是利用 threadTest 对象作为对象锁，当线程终止时，会调用线程自身的 notifyAll ，因此这个 wait 就解除了。</p>
<p>再说下 while (isAlive())，这是在判断线程是否线程是否已经执行了start() 方法，因此如果还没有start() 则不会执行wait() 方法。可以用如下代码验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"t1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"t2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t2.start();<span class="comment">//先启动t2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t1.start();<span class="comment">//延迟2秒后启动t1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看起来执行了 t1.join() ，应该要等t1执行完了才会执行t2，但是呢，这里最终输出： t2  t1 ，即 t2 还是会先执行。这是因为在执行 t1.join() 的时候，t1并没有执行 start() ，isAlive() 为false，因此不生效。</p>
<details>

<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/chenkaibsw/article/details/80912878" target="_blank" rel="noopener">csdn上的博客</a></p>
</blockquote>
<h2 id="25、wait-sleep-yield-join-方法"><a href="#25、wait-sleep-yield-join-方法" class="headerlink" title="25、wait/sleep/yield/join 方法"></a>25、wait/sleep/yield/join 方法</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>wait() 方法的作用是将当前线程挂起，让其进入阻塞状态，直到 notify/notifyAll 方法来唤醒线程，很容易理解，wait 是释放了锁资源的。</p>
<p>wait(long timeout)方法与 wait 相似，区别在于如果再指定时间内没有被notify/notifyAll ，则自动唤醒。</p>
<p>sleep方法只是暂时让出cpu执行权，并不释放锁，而 wait 是释放锁的。</p>
<p>yield 方法只是暂停当前线程，以便其他线程有机会运行，不过不能指定暂停时间，也不能保证当前线程立即停止。yield 方法只是将thread 的状态由 Running 转变为 Runable 状态。不过<strong>调度器可能会忽略这个方法，并且Java官方建议只用这个方法用于调试和测试。</strong></p>
<p>join 方法是父线程等待子线程执行完之后再执行。</p>
<blockquote>
<p>以上内容参考自<a href="https://www.cnblogs.com/paddix/p/5381958.html" target="_blank" rel="noopener">cnblogs的博客</a></p>
</blockquote>
<details>

<h2 id="26、Java-中锁的种类"><a href="#26、Java-中锁的种类" class="headerlink" title="26、Java 中锁的种类"></a>26、Java 中锁的种类</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>大概可以分类为：</p>
<ul>
<li>乐观锁、悲观锁       </li>
<li>独享锁、共享锁          </li>
<li>公平锁、非公平锁           </li>
<li>互斥锁、读写锁             </li>
<li>可重入锁             </li>
<li>分段锁                 </li>
</ul>
<p>其中乐观锁认为线程基本上是没有竞争的，一般采用CAS机制实现，悲观锁认为一个线程获取数据时，一定会有其他数据对数据进行更改，它的实现就是加锁，比如 synchronize 关键字</p>
<p>至于独享锁：一次只能被一个线程拥有，ReentrantLock 这个可重入锁也是独享锁。而共享锁可以被多个线程持有，比如：ReentrantReadWrite 中的读锁ReadLock 是共享锁，写锁WriteLock 是独享锁。</p>
<p>互斥锁的具体实现就是 synchronized、ReentrantLock 等实现；读写锁具体实现就是 ReadWriteLock。</p>
<p>可重入锁：对于同一个线程，在外层方法获取锁的时候，在进入内层方法也会自动获取锁。</p>
<p>公平锁：多线程竞争时排队，按照申请顺序获取锁；非公平锁：竞争时，先尝试插队，失败再排队。</p>
<p>分段锁：并不是一种锁，只是细化锁的粒度。</p>
<details>

<p>以上内容参考自<a href="https://zhuanlan.zhihu.com/p/112649693" target="_blank" rel="noopener">知乎上的内容</a></p>
<h2 id="27、Java-中锁优化的方式"><a href="#27、Java-中锁优化的方式" class="headerlink" title="27、Java 中锁优化的方式"></a>27、Java 中锁优化的方式</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li><strong>自旋锁与自适应自旋</strong>(主要解决互斥同步挂起和恢复需要转入内核态的问题。引入的自适应自旋，意味着自旋时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定的，因为如果在同一个锁对象上，自旋等待刚获得过锁，并且持有锁的线程正在运行，那么虚拟机认为当前自旋也很有可能再次成功，进而允许自旋等待更长时间)       </li>
<li>锁消除（虚拟机对于检测到不可能存在共享的数据进行锁消除）            </li>
<li>锁消除(一般来说，加锁同步块区域尽量小，只锁真正共享的区域，以便在锁竞争的时候，能尽快释放。但是如果一系列的连续操作对同一个对象频繁反复加锁解锁，甚至是出现在循环体中，那就会导致不必要的性能损耗，典型的就是在 循环中执行StringBuilder 的append操作)</li>
<li>轻量级锁（如果同步对象没有被锁定，虚拟机首先将将在当前线程的栈帧中建立一个名为锁记录-Lock Record 的空间，用于存储锁对象目前的 Mark Word的拷贝，然后虚拟机使用CAS操作尝试把对象的Mark Word 更新为指向 Lock Record 的指针，如果更新成功了，则代表线程拥有了这个对象的锁，对象Mark Word的锁标志也会标记为 “00”，即轻量级锁状态。如果这个cas操作失败，则意味着至少存在一条线程竞争，此时检查Mark Word 是否指向当前线程的栈帧，如果是，则说明已经拥，有了，直接进入同步块即可。否则，如果有两条以上线程争用一个锁，则必须膨胀微重量级锁。轻量级锁的依据是，“对于绝大部分锁，在整个同步周期内是不存在竞争的”，如果没有竞争，则轻量级锁通过CAS操作避免了使用互斥量的开销；当然，如果存在竞争，除了互斥量本身之外，还发生了CAS开销，反而更慢了）    </li>
<li>偏向锁（它的目的是在无竞争的情况下消除CAS操作，进一步提升性能。当锁对象第一次被线程获取的时候，就将对象头中的偏向模式置为 “1”,即偏向模式，同时使用CAS操作把获取这个锁的线程的ID记录在Mark word 中，如果操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块都不需要进行同步操作，不过，一旦出现另外一个线程尝试去获取这个锁的情况，偏向模式马上结束。根据锁对象目前是否处于锁定状态来决定是否撤销偏向、恢复到未锁定或者轻量级锁定状态）</li>
</ul>
<blockquote>
<p>以上内容参考自《深入理解Java虚拟机-第三版》</p>
</blockquote>
<details></details></details></details></details></details></details></details></details></details></details></details></details>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-Android基础</title>
    <url>/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="1、是否可以在子线程更新UI"><a href="#1、是否可以在子线程更新UI" class="headerlink" title="1、是否可以在子线程更新UI"></a>1、是否可以在子线程更新UI</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>今天看到网上有人较真，说Android中，你可以在子线程更新UI，于是我写了如下测试代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line">    <span class="keyword">val</span> textView = findViewById&lt;TextView&gt;(R.id.text_view)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> runnable = Runnable &#123;</span><br><span class="line">        textView.setText(<span class="string">"new text"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread(runnable).start()</span><br></pre></td></tr></table></figure>

<p>在子线程中更新EditText的文字居然成功！其实，在主线程修改UI，这属于一个“建议”而不是“标准”，因为如果在子线程定义UI的修改，无法预料到UI会被如何修改。</p>
<p>一言以蔽之：View之所以不能在子线程做UI操作，是因为在 ViewRootImpl 里面会做线程检测，而在onCreate 的时候，ViewRootImpl 还没初始化。</p>
<p>settext的调用流程大概会经历如下步骤：</p>
<ul>
<li>TextView 的 checkForRelayout() 方法     </li>
<li>TextView 的 invalidate() 方法       </li>
<li>View 的 invalidate() 方法      </li>
<li>View 的 invalidateInternal() 方法      </li>
<li>ViewGroup(ViewParent) 的 invalidateChild() 方法(不断loop取上一个节点的mParent，然后DecorView 的mParent 是 ViewRootImpl )       </li>
<li>即一直调用到 ViewRootImpl 的 invalidateChild()       </li>
<li>最终在 ViewRootImpl 中会 checkThread()检查线程        </li>
</ul>
<p>在ViewGroup 的 invalidateChild() 中，会判断 AttachInfo 是否为空，而在Activity 的 onCreate的时候，Activity 还在初始化，ImageView的mAttachInfo 是空的，所以在ViewGroup 中就直接没执行下去了，而settext 早就发生了，因此，就略过了检查线程这一阶段。</p>
</details><a id="more"></a>

<h2 id="2、延伸-子线程更新UI骚操作-在子线程启动-Dialog"><a href="#2、延伸-子线程更新UI骚操作-在子线程启动-Dialog" class="headerlink" title="2、延伸-子线程更新UI骚操作-在子线程启动 Dialog"></a>2、延伸-子线程更新UI骚操作-在子线程启动 Dialog</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>我们可以看下 ViewRootImpl 中的 构造函数 和 checkThread() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">        mDisplay = display;</span><br><span class="line">        mBasePackageName = context.getBasePackageName();</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">//checkThread 方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                    <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，这里并不是要求什么主线程(UI线程)，而是只要当前线程和ViewRootImpl/Window/View 的创建线程是同一个线程就ok,所以，只要在子线程中创建的View，就能在那个子线程更新UI，试试如下代码(我自己亲测可以运行)：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> runnable = Runnable &#123;</span><br><span class="line">     Looper.prepare()</span><br><span class="line">     <span class="keyword">val</span> dialog = MyDialog(<span class="keyword">this</span><span class="symbol">@MainActivity</span>)</span><br><span class="line">     dialog.show()</span><br><span class="line">     Looper.loop()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> Thread(runnable).start()</span><br></pre></td></tr></table></figure>

</details>

<h2 id="3、LruCache-原理"><a href="#3、LruCache-原理" class="headerlink" title="3、LruCache 原理"></a>3、LruCache 原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>LRU(Least Recently Used，最近最少使用) 缓存算法就是为缓存设计的，它的思想就是当缓存满时，会优先淘汰那些最近最少使用的缓存对象。LruCache 就是Android 基于 LRU 算法给的一个缓存类。</p>
<p>LruCache 的核心就是维护一个缓存对象列表，其中对象按照访问顺序实现的，即一致没访问的对象，将放在队尾，首先被淘汰，最近访问的对象放在队头，最后淘汰。如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/Android%E5%9F%BA%E7%A1%80/LruCache%E6%B7%98%E6%B1%B0%E8%BF%87%E7%A8%8B.png" alt="LruCache淘汰过程"></p>
<p>这里面的队列是由LinkedHashMap 来维护的，前面已经介绍过<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">它的实现原理</a>了，他有个构造函数是这样的：</p>
<blockquote>
<p>public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder)</p>
</blockquote>
<p>最后一个参数 accessOrder 用来表示LinkedHashMap 中双向链表的顺序是插入顺序还是访问顺序，举个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JvmStatic</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> linkedHashMap = LinkedHashMap&lt;<span class="built_in">Int</span>,<span class="built_in">Int</span>&gt;(<span class="number">0</span>,<span class="number">0.75f</span>,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    linkedHashMap[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    linkedHashMap[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    linkedHashMap[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    linkedHashMap[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">    linkedHashMap[<span class="number">4</span>] = <span class="number">4</span></span><br><span class="line">    linkedHashMap[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ar1 = linkedHashMap[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">val</span> ar2 = linkedHashMap[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    linkedHashMap.forEach &#123; (t, u) -&gt;</span><br><span class="line">        println(<span class="string">"key = <span class="variable">$t</span>,value = <span class="variable">$u</span> \n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在构造LinkedHashMap 的时候，accessOrder 为false ，则会依次打印：</p>
<blockquote>
<p>key = 0,value = 0<br>key = 1,value = 1<br>key = 2,value = 2<br>key = 3,value = 3<br>key = 4,value = 4<br>key = 5,value = 5      </p>
</blockquote>
<p>如果为true，则会打印：</p>
<blockquote>
<p>key = 0,value = 0<br>key = 3,value = 3<br>key = 4,value = 4<br>key = 5,value = 5<br>key = 1,value = 1<br>key = 2,value = 2       </p>
</blockquote>
<p>这是因为为true时，会导致最近访问的最后输出，那么这就刚好满足LRU 缓存算法的思想，所以LruCache 的巧妙实现，就是利用了 LinkedHashMap 的这个功能。 所以LruCache 的构造函数为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以LruCache 后续的操作就比较好理解了：</p>
<ul>
<li>在put 新元素的时候，首先判断 key 和value 都不能为空，之后更新缓存大小；如果之前这个key 有值，则替换这个值，由于已经先前更新过缓存大小，此时要把老的value所占缓存大小减去。最后调整缓存大小，如果缓存大小超过阈值，则依次取出LinkedHashMap 中取出key-value 删除，直到小于阈值为止。    </li>
<li>get 的时候，判断 key 是否为 null ，不能为 null 。get操作之后，接着把这个节点删除，再把这个节点添加(头插法，会插入到头部，这样保证顺序)。       </li>
</ul>
</details>

<h2 id="4、聊聊handler机制？-一个线程是否只有一个Looper？如何保证一个线程只有一个Looper？"><a href="#4、聊聊handler机制？-一个线程是否只有一个Looper？如何保证一个线程只有一个Looper？" class="headerlink" title="4、聊聊handler机制？ 一个线程是否只有一个Looper？如何保证一个线程只有一个Looper？"></a>4、聊聊handler机制？ 一个线程是否只有一个Looper？如何保证一个线程只有一个Looper？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<p>Handler 初始化的时候会通过 Looper.myLooper（实际上只是返回了 sThreadLocal.get()） 获取当前线程的Looper。之后通过 looper 获取当前线程的 mQueue 。<br>当然，如果在子线程中new Handler ，基本上会提示 您还未执行Looper.prepare();<br>Looper.prepare() 会判断当前 sThreadLocal.get()是否已经存在了，如果已经存在了，就会提示 “一个线程只能有一个Looper”（<strong>注意，就是在这里保证了一个线程只有一个Looper</strong>）。Looper.prepare() 只是执行了sThreadLocal.set(new Looper())，在这里给线程设置了Looper。<br>而在主线程中，ActivityThread 的main 方法中会执行 Looper.prepareMainLooper（）来设置Looper，故我们可以直接new Handler，而在子线程中要手动Looper.prepare()才行，并且还要Looper.loop()，让消息循环。<br>接下来就是 handler 的 sendMessage 和post 方法，其实两个方法都是调用 sendMessageDelay 方法，只不过post方法首先将 Runnable封装成Message，变成Message的CallBack。<br>在最终send的时候，Message会持有handler的引用，叫做target，之后，message被丢到handler所持有的MessageQueue中。<br>之后，在主线程中，Looper一直在循环，取出queue中的Message，然后执行message.target.dispatchMessage，在这个方法中，最终会调用到我们写handler时候覆写的 handleMessage 方法。至此，整个流程走完。</p>
</blockquote>
</details>

<h2 id="5、Handler-的postDelay-是怎么实现的？"><a href="#5、Handler-的postDelay-是怎么实现的？" class="headerlink" title="5、Handler 的postDelay 是怎么实现的？"></a>5、Handler 的postDelay 是怎么实现的？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>可能用举例子的方式容易懂一些：</p>
<ol>
<li>postDelay 一个10秒的 RunableA 到 MessageQueue，MessageQueue 会调用 nativePollOnce 阻塞线程。    </li>
<li>接着post 一个 RunnableB 到 MessageQueue，由于 RunnableB 没有延时，因此when 时间比 RunableA 小，因此被插入在队头，然后调用nativeWake 方法唤醒 线程 。    </li>
<li>唤醒后，MessageQueue.next() 方法继续执行，读取到第一个消息 RunnableB，由于没有延时，直接交给Looper。    </li>
<li>Looper 处理完B 后，再次调用 MessageQueue.next() 方法，这时候 RunableA 还没到时间，这时候调用 nativePollOnce 阻塞。    </li>
<li>这个状态直到阻塞时间到或者下一次有Message 进队。</li>
</ol>
<p>至于为什么 handler.postDelay并不是先等待一定的时间再放入到MessageQueue中，因为那样的话会需要多个定时器，增加开销。</p>
<blockquote>
<p>以上内容源自阅读源码以及 <a href="https://blog.csdn.net/qingtiantianqing/article/details/72783952" target="_blank" rel="noopener">网上博客</a> </p>
</blockquote>
</details>

<h2 id="附：如何移除Handler的Message？有啥坑吗？"><a href="#附：如何移除Handler的Message？有啥坑吗？" class="headerlink" title="附：如何移除Handler的Message？有啥坑吗？"></a>附：如何移除Handler的Message？有啥坑吗？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>如果移除Message,有两种方式：</p>
<ul>
<li>根据 Message 的 what 来移除：handler.removeMessages(what),handler.removeMessages(what.obj)，当然，后者的obj如果为空，就会移除所有的 Message        </li>
<li>根据token移除：handler.removeCallbacksAndMessages(token)，当然，如果token为空，就会移除所有 Message (比如在Activity的onDestroy 中有时候为了避免内存泄露会移除)，则只需要传入 null 即可。           </li>
</ul>
<p>handler 的延时操作有两种：</p>
<ul>
<li>handler.postDelayed(runnable, 10000);        </li>
<li>handler.sendMessageDelay(0, 10000);           </li>
</ul>
<p>但是，如果我们混合使用二者，在移除的时候可能会出现意想不到的问题，比如如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建handler</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        Log.d(TAG, <span class="string">"handleMessage: "</span>+msg.what);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建runnable：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable runnable1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"run: 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Runnable runnable2 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"run: 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyHandler handler = <span class="keyword">new</span> MyHandler();</span><br><span class="line">handler.postDelayed(runnable1,<span class="number">1000</span>);</span><br><span class="line">handler.postDelayed(runnable2,<span class="number">1000</span>);</span><br><span class="line">handler.sendEmptyMessageDelayed(<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">handler.sendEmptyMessageDelayed(<span class="number">1</span>,<span class="number">1000</span>);</span><br><span class="line">handler.sendEmptyMessageDelayed(<span class="number">2</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//handler.removeMessages(0);</span></span><br></pre></td></tr></table></figure>

<p>如果屏蔽最后一行，就会输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">run: <span class="number">1</span></span><br><span class="line">run: <span class="number">2</span></span><br><span class="line">handleMessage: <span class="number">0</span></span><br><span class="line">handleMessage: <span class="number">1</span></span><br><span class="line">handleMessage: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>但是如果不屏蔽，就只会输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">handleMessage: <span class="number">1</span></span><br><span class="line">handleMessage: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>意味着两个Runnable 也被移除了！这是咋回事？原来，handler 的 postDelay 功能也是用 sendMessageDelayed 方法去实现的！这当然需要构造 Message 对象咯，然而也仅仅只是 Message m = Message.obtain();m.callback = r; 意味着会新建一个 Message ，而新建的 Message 的what值默认为0 ！问题找到了，那么以后使用remove的时候需要注意什么呢？主要两点：</p>
<ul>
<li>自定义Handler 处理 msg.what 的时候，what的值不要使用默认值0         </li>
<li>同一个Handler 不要同时使用 postDelayed() 和 sendMessageDelayed()          </li>
</ul>
<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/xyq046463/article/details/54891427" target="_blank" rel="noopener">csdn的博客</a>      </p>
</blockquote>
</details>


<h2 id="6、RecyclerView-的性能优化"><a href="#6、RecyclerView-的性能优化" class="headerlink" title="6、RecyclerView 的性能优化"></a>6、RecyclerView 的性能优化</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>有以下几种方式能做到RecyclerView的优化：</p>
<ul>
<li><p>数据处理与视图绑定分离。    </p>
<blockquote>
<p>bindViewHolder 方法是在ui线程执行的，而远端拉取数据肯定是要放在子线程的，所以我们在拉取数据之后做一些预处理后再丢给adapter，防止在 bindViewHolder 方法中再去处理时间比较、保留小数位数之类的操作。</p>
</blockquote>
</li>
<li><p>布局优化    </p>
<blockquote>
<p>1、减少item布局层次  2、减少没必要的xml文件的inflate，可以使用new View()等方式(shape类型的xml 也一样)。</p>
</blockquote>
</li>
<li><p>可能的话，为 RecyclerView 设置 setHasFixedSize(true)</p>
<blockquote>
<p>这个方法的主要作用就是设置高度，来避免 rv 的 measure 和 layout 操作。比如一个垂直滚动的rv，height属性设置为 wrap_content，最初的数据集只有3条，全部展示出来也不能使rv撑满，如果我们通过notifyItemRangeInserted 添加数据，那么如果你设置了 setHasFixedSize 为true的情况下，rv高度是不会改变的。体现在diamante中就是requestLayout方法的调用。</p>
</blockquote>
</li>
<li><p>减少itemView的监听器创建    </p>
<blockquote>
<p>我们无需对每一个item 都采用匿名内部类的方式添加监听，，而应该公用一个 xxListener 对象，通过id来区分不同操作，避免频繁创建对象带来资源消耗。</p>
</blockquote>
</li>
<li><p>加大RecyclerView的缓存     </p>
<blockquote>
<p>通过设置 setItemViewCacheSize、setDrawingCacheEnabled 以及setDrawingCacheQuality 等方法增加缓存空间，以空间换时间，提升流畅性。</p>
</blockquote>
</li>
<li><p>滑动过程中停止加载    </p>
</li>
<li><p>使用 DiffUtil 工具    </p>
<blockquote>
<p>DiffUtil 工具类用来判断新数据和旧数据的差别，从而进行局部刷新，我们只需要在原来调用 mAdapter.notifiyDataSetChanged() 的地方改成下面这样：<br>DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new DiffCallBack(oldDatas, newDatas), true);<br>diffResult.dispatchUpdatesTo(mAdapter);<br>最终，mAdapter 会通过调用 notifyItemRangeInserted、notifyItemRangeRemoved 等方法进行局部刷新。</p>
</blockquote>
</li>
<li><p>公用RecycledViewPool    </p>
<blockquote>
<p>在嵌套的 rv 中，如果子 rv 具有相同的adapter ，那么可以设置 ：<br>RecyclerView.setRecycledViewPool(pool) 来公用RecycledViewPool。</p>
</blockquote>
</li>
<li><p>RecyclerView数据预取    </p>
<blockquote>
<p>默认是开启的，跟我们没关系。具体原理是，当上一帧交给gpu之后，cpu就一直处于空闲状态，需要等待下一帧才会数据处理，所以rv做了个预判，rv会取接下来可能要显示的item，在下一帧到来之前把数据提前处理好，不过呢，这个预判是不一定准确的。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>以上内容参考 <a href="https://www.jianshu.com/p/1d2213f303fc" target="_blank" rel="noopener">mandypig</a>、<a href="https://www.jianshu.com/p/bd432a3527d6" target="_blank" rel="noopener">编码前线</a> 以及 <a href="https://www.jianshu.com/p/aedb2842de30" target="_blank" rel="noopener">Blankj</a></p>
</blockquote>
</details>

<h2 id="7、引申-如何保存嵌套rv中的滑动装填"><a href="#7、引申-如何保存嵌套rv中的滑动装填" class="headerlink" title="7、引申-如何保存嵌套rv中的滑动装填"></a>7、引申-如何保存嵌套rv中的滑动装填</h2><p>比如嵌套的rv这时候左滑到第三个，这时候外层的rv滑动很长距离，当前这个嵌套的rv已经看不见了，划出好远了，如何在嵌套rv再次可见的时候，恢复当时滑到的第三个。</p>
<p>其实 Linearlayoutmanager 中有对应的 onSaveInstanceState 和 onRestoreInstanceState 方法来处理保存和恢复机制。</p>
<h2 id="8、图片加载优化"><a href="#8、图片加载优化" class="headerlink" title="8、图片加载优化"></a>8、图片加载优化</h2><ol>
<li>假设通过ImageView 显示图片，很多时候ImageView 没有原始图片尺寸那么大，把整个图片加载进内存再设置给ImageView则没必要，这时候可以在加载图片时采用低采样率加载进来。    </li>
<li>与后端配合，在url 后面接上需要的图片尺寸。(目前就是这么做)</li>
</ol>
<h2 id="9、Activity生命周期"><a href="#9、Activity生命周期" class="headerlink" title="9、Activity生命周期"></a>9、Activity生命周期</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ol>
<li>onCreate()：当 Activity 第一次创建时会被调用     </li>
<li>onRestart()：表示Activity正在重新启动。一般情况下，当当前Activity从不可见重新变为可见状态时，onRestart就会被调用。     </li>
<li>onStart(): Activity已经出现了，但是还没有出现在前台，无法与用户交互。这个时候可以理解为Activity已经显示出来，但是我们还看不到        </li>
<li>onResume():表示Activity已经可见了，并且出现在前台并开始活动。需要和onStart()对比，onStart的时候Activity还在后台，onResume的时候Activity才显示到前台       </li>
<li>onPause():表示 Activity仍可见，只是不可交互    </li>
<li>onStop():表示Activity不可见，位于后台      </li>
<li>onDestory():表示Activity即将销毁，这是Activity生命周期的最后一个回调，可以做一些回收工作和最终的资源回收</li>
</ol>
</details>

<h2 id="10、延伸-生命周期几种普通情况"><a href="#10、延伸-生命周期几种普通情况" class="headerlink" title="10、延伸-生命周期几种普通情况"></a>10、延伸-生命周期几种普通情况</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><strong>从 A 页面Activity 跳转到 B 页面Activity：</strong></p>
<p>一、 启动过程会经历：</p>
<p><strong>A</strong>:onPause-&gt; B:onCreat-&gt; B:onStart-&gt; B:onResume-&gt; <strong>A</strong>:onStop</p>
<p>所以我们可以得出结论：</p>
<ul>
<li>在A 的onPause 中不要执行耗时操作，否则会影响新打开的B，因为当前A 的 onPause 必须执行完，B 的onResume 才会执行。     </li>
<li>等 B 的onResume 执行后，A 才完全被覆盖看不见，故，B的onResume 调用完后，A的Stop 才调用。</li>
</ul>
<p>二、按返回键返回到A：</p>
<p>B:onPause-&gt; <strong>A</strong>:onRestart-&gt; <strong>A</strong>:onStart-&gt; <strong>A</strong>:onResume-&gt; B:onStop-&gt; B:onDestroy</p>
<p>我们得出结论：</p>
<ul>
<li>B 首先让出交互权力</li>
<li>A 到前台(onResume)后 ，B才退到后台，B才调用 onStop  </li>
</ul>
<p>三、按Home 键：     </p>
<p>onPause -&gt; onStop，即让出交互，退到后台</p>
<p>反之，此时再点击图标唤起：</p>
<p>onRestart-&gt; onStart-&gt; onResume，即Activity 还在，只需要重新可见即可</p>
</details>

<h2 id="11、Activity的启动模式"><a href="#11、Activity的启动模式" class="headerlink" title="11、Activity的启动模式"></a>11、Activity的启动模式</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>standard：标准启动。      </li>
<li>singleTop(栈顶复用模式)：在当前栈顶就复用，否则新建。      </li>
<li>singleTask(栈内复用模式)：在当前栈存在有实例，如果在栈顶，直接使用；如果不在栈顶，将该实例之上的Activity全部出栈。      </li>
<li>singleInstance(单例模式)：只要有这个实例，不管在哪个栈，都复用之；否则，在新的栈创建实例。    </li>
</ul>
</details>

<h2 id="12、Fragment-为何不推荐使用构造方法传递参数？"><a href="#12、Fragment-为何不推荐使用构造方法传递参数？" class="headerlink" title="12、Fragment 为何不推荐使用构造方法传递参数？"></a>12、Fragment 为何不推荐使用构造方法传递参数？</h2><p>因为activity 给fragment 传递数据时是通过 setArguments 来传递。如果采用构造方法传递，在诸如横竖屏切换的时候会调用fragment 的空的构造函数，造成数据丢失。</p>
<h2 id="13、Context-理解"><a href="#13、Context-理解" class="headerlink" title="13、Context 理解"></a>13、Context 理解</h2><p>参考以前写的博客：<a href="https://glassx.gitee.io/2019/12/06/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC5%E7%AB%A0/">https://glassx.gitee.io/2019/12/06/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC5%E7%AB%A0/</a></p>
<h2 id="14、Android-全局异常处理"><a href="#14、Android-全局异常处理" class="headerlink" title="14、Android 全局异常处理"></a>14、Android 全局异常处理</h2><p>在Application 中为 Thread 设置ExceptionHandler 即可。</p>
<p>参考：<a href="http://www.androidos.net.cn/book/android-road/android/advance/exception.html" target="_blank" rel="noopener">全局异常处理</a></p>
<h2 id="15、谈谈你对Application类的理解"><a href="#15、谈谈你对Application类的理解" class="headerlink" title="15、谈谈你对Application类的理解"></a>15、谈谈你对Application类的理解</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>说说对什么的理解，就是考察这个东西会不会用，重点有没有什么坑。有以下几点需要注意：</p>
<ul>
<li>Application 在一个虚拟机里面只有一个实例。这里不是说一个App只有一个实例，因为一个App 可能有多个进程，也就是多个虚拟机，这种情况下，每个虚拟机中都会存在一个Application 对象。      </li>
<li>Application 本质是一个Context ，继承自 ContextWrapper。      </li>
<li>Application 有 MultiDexApplication 子类，这个子类可以用来解决 65535 问题，完成多Dex 打包配置相关工作。       </li>
<li>在Application 的onCreate 方法中我们会进行各种初始化，如图片加载库、log 等，但是最好别在里面进行太多耗时操作，这会影响App启动速度，可以使用异步、懒加载、延时加载等策略来减少影响。       </li>
<li>通过Context.getApplicationContext ，不论是从Activity 中、Service中获取，都是同一个Application 对象。     </li>
<li>在低内存情况下，Application 可能会被销毁，从而导致保存在Application 中的数据错乱，所以要注意判空或者选择其他方式保存数据。      </li>
<li>Application 中几个有用的回调如 onLowMemory 、onTrimMemory ，在内存紧张的时候，在这些回调里面关闭数据库连接、移除图片缓存等方式来降低内存，降低被回收的风险。     </li>
<li>Application 的生命周期和虚拟机一样长，所以单例或者静态变量的初始化一定要使用Application 的Context 进行初始化，防止内存泄漏。     </li>
</ul>
<blockquote>
<p><a href="https://github.com/ZhaoKaiQiang/AndroidDifficultAnalysis/blob/master/01.%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Application%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3.md" target="_blank" rel="noopener">以上内容可以参考这个链接</a></p>
</blockquote>
</details>

<h2 id="16、Android-中进程通信方式"><a href="#16、Android-中进程通信方式" class="headerlink" title="16、Android 中进程通信方式"></a>16、Android 中进程通信方式</h2><p>可以翻看<a href="https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/">以前的读书笔记</a></p>
<h2 id="17、Binder-原理"><a href="#17、Binder-原理" class="headerlink" title="17、Binder 原理"></a>17、Binder 原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="为什么要使用Binder"><a href="#为什么要使用Binder" class="headerlink" title="为什么要使用Binder"></a>为什么要使用Binder</h3><ol>
<li>性能方面；Binder 数据拷贝只需要一次，而管道、Socket 等都需要2次，共享内存不需要拷贝，但是实现方式比较复杂。    </li>
<li>安全方面；传统的进程通信方式对于通信双方没有严格限制，而Binder 机制从协议本身就支持对通信双方做身份校验，所以大大提升安全性。</li>
</ol>
<h3 id="IPC-原理"><a href="#IPC-原理" class="headerlink" title="IPC 原理"></a>IPC 原理</h3><p>每个Android 进程，只能运行在自己进程所拥有的虚拟地址空间。例如，对应4G的虚拟地址空间，其中3G是用户空间，1G是内核空间，当然，内核空间大小是可以通过参数配置的。对于用户空间，进程间是不能共享的，而内核空间是可以共享的。<strong>Client 进程向Server 进程通信，恰恰是利用进程间内核空间来完成底层通信工作的。</strong></p>
<h3 id="跨进程使用服务的流程"><a href="#跨进程使用服务的流程" class="headerlink" title="跨进程使用服务的流程"></a>跨进程使用服务的流程</h3><ol>
<li>Client 通过Server 的代理接口，对Server 进行调用。    </li>
<li>代理接口中定义的方法与Server 中定义的方法是一一对应的。    </li>
<li>Client 调用某个代理中的方法时，代理会将Client 传递的参数打包成 Parcel 对象。     </li>
<li>代理将Parcel 发送给内核中的 Binder Driver。    </li>
<li>Server 读取Binder Driver 中的请求数据，解包 Parcel 对象，处理并返回。    </li>
<li>整个调用过程是一个同步过程，在Server 处理的时候，Client 将会Block 住。<strong>故Client 调用过程不应该在主线程。</strong></li>
</ol>
<p>整个流程示意图如下所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/Android%E5%9F%BA%E7%A1%80/IPC%E4%BD%BF%E7%94%A8server%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="IPC使用server的过程"></p>
<p>关于IPC，还可以参考<a href="https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/">以前的文章</a></p>
<blockquote>
<p>以上内容参考自：<a href="http://www.androidos.net.cn/book/android-road/android/advance/binder.html" target="_blank" rel="noopener">进程间通信</a></p>
</blockquote>
<p>以下内容摘自《深入理解Android：卷II》：</p>
<p>Binder 有两种调用方式： 阻塞调用方式 和 非阻塞方式。前者 调用方(客户端)会阻塞，直到服务端返回结果，这种方式和普通的函数调用是一样的；后者调用方只要把请求发送到Binder驱动即可返回，但一般还会向服务端发送一个回调(同样是跨进程的Binder调用)，不用等待服务端的结果，一旦服务端处理了该请求，就会调用此回调函数来通知客户端处理结果。</p>
<p>Handler中looper会阻塞，唤醒的时候是通过 pipe 发送 w 来唤醒的</p>
<p>在2.3以前，我们只可以从Java层向 MessageQueue 添加消息，但在2.3以后，MessageQueue 的核心部分下移到Native层，所以有时候cpu并不是很忙，但是你的sendMessage 又是等了很久才被处理，这有可能就是在处理 Native 层的 Message。</p>
</details>

<h2 id="18、延伸-Android为什么要设计出Bundle而不是直接使用HashMap来进行数据传递"><a href="#18、延伸-Android为什么要设计出Bundle而不是直接使用HashMap来进行数据传递" class="headerlink" title="18、延伸-Android为什么要设计出Bundle而不是直接使用HashMap来进行数据传递"></a>18、延伸-Android为什么要设计出Bundle而不是直接使用HashMap来进行数据传递</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>Bundle 内部是由ArrayMap 实现的，我们知道，ArrayMap 内部实现原理是两个数组，在添加、删除、查找 数据时，都会使用二分查找法，在数据量较小的情况下，相对 HashMap 而言，在效率相差不太大的情况下，更节省内存(HashMap的Entry Array 占用更多内存，并且没用到的会导致浪费)。而我们在Android中使用Bundle 传递数据都是比较少的，因此Bundle 更有效率。    </li>
<li>Android 中如果使用Intent 携带数据的话，需要数据基本类型或者是可序列化类型，HashMap 使用Serializeble 进行序列化，而Bundle 是实现了 Parcelable 进行序列化。在Android 平台中，更推荐使用 Parcelable 进行序列化，因为更少的 io 操作(但同时使用更加复杂)。</li>
</ul>
<blockquote>
<p>以上内容参考<a href="https://github.com/ZhaoKaiQiang/AndroidDifficultAnalysis/blob/master/02.Android%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E5%87%BABundle%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8HashMap%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92.md" target="_blank" rel="noopener">zhaokaiqiang的博客</a></p>
</blockquote>
</details>

<h2 id="19、Android中IPC通信的方式有哪些？使用场景是什么"><a href="#19、Android中IPC通信的方式有哪些？使用场景是什么" class="headerlink" title="19、Android中IPC通信的方式有哪些？使用场景是什么"></a>19、Android中IPC通信的方式有哪些？使用场景是什么</h2><p>参考<a href="https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/">以前写的读书笔记</a>即可</p>
<h2 id="20、SharedPreference-解析"><a href="#20、SharedPreference-解析" class="headerlink" title="20、SharedPreference 解析"></a>20、SharedPreference 解析</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="获取SharedPreference-对象"><a href="#获取SharedPreference-对象" class="headerlink" title="获取SharedPreference 对象"></a>获取SharedPreference 对象</h3><p>大概有3种方式获取：</p>
<ul>
<li>通过Context 的 getSharedPreference() 方法，指定name 和 mode；     </li>
<li>通过 Activity 的 getPreferences() 方法，它其实最终还是调用的 Context 的 getSharedPreferences() 方法，只不过我们只需要传mode参数，因为已经在方法中将 Activity 的类名作为name了；     </li>
<li>通过 PreferenceManager 的getDefaultSharedPreferences() 方法，目前基本上已经废弃    </li>
</ul>
<p>获取 SharedPreference 对象时，如果有没有存在这个xml文件，则创建，否则读取。在低于4.4 的版本上，如果name 为 null ，则会自动设置为 “null”。一直等这个 xml 文件加载解析完成，才会返回 SharedPreference 对象。   </p>
<p>获取xml 过程中，首先会读取 ContextImpl 中的 sSharedPrefsCache 缓存：</p>
<blockquote>
<p>private static ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache;</p>
</blockquote>
<p>由于sSharedPrefsCache 是static 的，并且 Android 中所有系统都使用这一个 ContextImpl 类，所以对于所有的app而言，都公用这一个 sSharedPrefsCache，因此可以理解为，系统启动后，如果有哪个应用使用过 sSharedPrefsCache ，那么它一直会留在内存中，直到系统关闭或者重启。</p>
<p>根据packageName ，可以从 sSharedPrefsCache 中获取当前应用的 ArrayMap&lt;File, SharedPreferencesImpl&gt; 列表，我们知道，根据不同的name，在文件中都会生成不同的xml 形式的 file。我们知道，SharedPreference 的xml 文件存储在 data/{packageName}/shared_prefs 目录下，所以我们name 就能获得 file 文件的路径，进而获取到这个xml 的 File 对象。根据这个对象，我们可以获取到 SharedPreferencesImpl 对象。在SharedPreferencesImpl中存在 Map&lt;String, Object&gt; 类型的 mMap 保存了xml 中key-value值 (解析完xml 后将值存入其中)。所以我们在正式使用的时候，实际上是从内存中读取的。</p>
<p>在解析这个 xml 过程中，SharedPreferenceImpl（SharedPreference 接口的实现类） 一直都是加锁的，在这个锁定状态下，我们无法调用它的 commit 和 apply 方法(处于wait状态)，直到这个解析完成，就会执行 notifyAll 方法。</p>
<h3 id="SharedPreference-的值获取"><a href="#SharedPreference-的值获取" class="headerlink" title="SharedPreference 的值获取"></a>SharedPreference 的值获取</h3><p>我们以 getBoolean 方法为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(String key, <span class="keyword">boolean</span> defValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        Boolean v = (Boolean)mMap.get(key);</span><br><span class="line">        <span class="keyword">return</span> v != <span class="keyword">null</span> ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在获取之前，首先加锁，因此这过程是线程安全的，之后 awaitLoadedLocked() 一直在等待(前面说的，在getSharedPreference() 过程中，在xml 解析完成return 之前，一直都会加锁的，完成后就会notifyAll)，直到xml 文件解析完成。可以看看 awaitLoadedLocked 的源码，可以看到它的wait过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitLoadedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SharePreferences内部类Editor"><a href="#SharePreferences内部类Editor" class="headerlink" title="SharePreferences内部类Editor"></a>SharePreferences内部类Editor</h3><p>我们来看 SharedPreference 的 edit() 方法： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">edit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            awaitLoadedLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EditorImpl();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它也得 awaitLoadedLocked() 等待SharedPreference 准备完成。<strong>从这里还可以知道，每次 edit() 都会 new 一个 EditorImpl 对象</strong>，因此，不要频繁edit() 操作。 Editor 的具体实现是 EditorImpl 。我们可以粗略地看下它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EditorImpl</span> <span class="keyword">implements</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mEditorLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"mEditorLock"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; mModified = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"mEditorLock"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mClear = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里只写这一个put 操作，其他的 putXXX操作基本上是一样的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Editor <span class="title">putBoolean</span><span class="params">(String key, <span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">            mModified.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Editor <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">            mModified.put(key, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们的put 、remove 之类的操作，只是修改了 hashmap中的值，并没有存入到 SharedPreference 中，通过我们平时使用知道，要在 commit 或者 apply 方法中来生效。</p>
<h3 id="改动提交到-SharedPreference"><a href="#改动提交到-SharedPreference" class="headerlink" title="改动提交到 SharedPreference"></a>改动提交到 SharedPreference</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.先通过commitToMemory方法提交到内存</span></span><br><span class="line">    MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    <span class="comment">//2.写文件操作</span></span><br><span class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(</span><br><span class="line">            mcr, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//阻塞等待写操作完成，UI操作需要注意！！！所以如果不关心返回值可以考虑用apply替代，具体原因等会分析apply就明白了。</span></span><br><span class="line">        mcr.writtenToDiskLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.通知数据发生变化了</span></span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">    <span class="comment">//4.返回写文件是否成功状态</span></span><br><span class="line">    <span class="keyword">return</span> mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过 commitToMemory 提交到内存，之后，<strong>直接在调用commit() 方法的线程中将数据写入文件</strong>。在真正写文件的时候，采用了数据库的事务思想，因为它有个 backfile 的备份文件。</p>
<p>接下来分析apply 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有了上面commit分析，这个雷同，写数据到内存，返回数据结构</span></span><br><span class="line">    <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    <span class="keyword">final</span> Runnable awaitCommit = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//等待写文件结束</span></span><br><span class="line">                mcr.writtenToDiskLatch.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    QueuedWork.add(awaitCommit);</span><br><span class="line">    <span class="comment">//一个收尾的Runnable</span></span><br><span class="line">    Runnable postWriteRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            awaitCommit.run();</span><br><span class="line">            QueuedWork.remove(awaitCommit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//这个上面commit已经分析过的，这里postWriteRunnable不为null，所以会在一个新的线程池调运postWriteRunnable的run方法</span></span><br><span class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Okay to notify the listeners before it's hit disk</span></span><br><span class="line">    <span class="comment">// because the listeners should always get the same</span></span><br><span class="line">    <span class="comment">// SharedPreferences instance back, which has the</span></span><br><span class="line">    <span class="comment">// changes reflected in memory.</span></span><br><span class="line">    <span class="comment">//通知变化</span></span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子线程中提交了这个写任务，这个任务是通过handler去post的，而这个handler 初始化的Looper 是从 HandlerThread 中获取到的，所以最终还是相当于在一个个的apply 提交交给了HandlerThread 去操作，即在单线程的子线程执行。</p>
<h3 id="使用时注意"><a href="#使用时注意" class="headerlink" title="使用时注意"></a>使用时注意</h3><ul>
<li>不要存储超大的key或者value    </li>
</ul>
<blockquote>
<p>获取一个sp的时候，会把它的整个xml 文件都加载进来，如果太大，比如说 100k，那就会耗费很长的时间。如果为了读取一个boolean 配置，要把整个100k文件加载进来，是很不合理的，会引起频繁gc，和大的内存占用，所以我们应该只要存储很轻量的数据。  <strong>还有，我们知道，在getBoolean 或者其他getXXX 方法的时候，会要等待SharedPreference 加载完成，况且，在xml 加载过程中，有多个地方加锁。在加载完成后，getXXX 操作才能执行，否则一直在等待，这过程的阻塞可能引起界面卡顿和掉帧。</strong>  所以我们可以在super.onCreate() 之前，可以先执行 getPreference。</p>
</blockquote>
<ul>
<li>不要在sp中存储 JSON 这种特殊符号很多的 value</li>
</ul>
<blockquote>
<p>这么做不是不可以，而是如果这个json很大，就会涉及很多转义(其实html 也会有这情况)，带来很多&amp;这种特殊符号，引发额外地字符串拼接以及函数调用开销。</p>
</blockquote>
<ul>
<li>多次edit() 和 apply()</li>
</ul>
<blockquote>
<p>通过以上的分析我们也知道了，每次 edit() 操作都会 new 一个 EditorImpl，这是一点。还有，经过上次我们知道，每次 apply 会往 HandlerThread 中post 一个 Runnable，然后他们会在单线程中依次执行。可能说到这里还没觉得有什么，但是我告诉你这会导致卡顿，不可思议吧？在子线程操作的，怎么可能导致卡顿呢？但是我们看 ActivityThread 源码，执行 handleStopActivity 的时候：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> show, <span class="keyword">int</span> configChanges, <span class="keyword">int</span> seq)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关。。</span></span><br><span class="line">    <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">    <span class="keyword">if</span> (!r.isPreHoneycomb()) &#123;</span><br><span class="line">        QueuedWork.waitToFinish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是在较老的Android版本(api 11 之前)，会等待 apply 提交的那些 runnable 执行完了才能退出，如果这个时间过长，会导致anr。</p>
<ul>
<li>不要用于跨进程</li>
</ul>
<blockquote>
<p>Android官方也不建议使用SharedPreference 跨进程(已经@deprecated)，而建议使用provider。因为它并不是在所有进程上都是可靠的。并且，它通过 MODE_MULTI_PROCESS 这个标志位来实现多进程标记，其实也只是如果sp已经读到内存了，再次获取这个sp 时，如果有这个标志位，就会重新获取一遍文件。</p>
</blockquote>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><ol>
<li>不要存放大的key和value，可能引起页面卡顿，频繁gc      </li>
<li>毫不相干的配置项不要丢在一起，文件越大越慢。这样，用户没有到达的页面的sp可以不加载进来。    </li>
<li>读取频繁的key和不易变动的key尽量不要放在一起。     </li>
<li>不要频繁 edit 和 apply ，尽量批量修改一起提交     </li>
<li>尽量不要存放 json  和 html ，防止不必要的转义     </li>
<li>不要指望用sp 来跨进程通信     </li>
</ol>
</details>

<blockquote>
<p>以上内容经过自己看代码，以及参考自<a href="https://blog.csdn.net/yanbober/article/details/47866369" target="_blank" rel="noopener">上善若水</a>、以及<a href="https://zhuanlan.zhihu.com/p/22913991" target="_blank" rel="noopener">维数不多</a> </p>
</blockquote>
<h2 id="21、常见内存泄漏场景："><a href="#21、常见内存泄漏场景：" class="headerlink" title="21、常见内存泄漏场景："></a>21、常见内存泄漏场景：</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>资源性对象未关闭</li>
</ul>
<blockquote>
<p>如 File、Cursor、stream等资源，他们的缓存不只存在java虚拟机内，还存在虚拟机外，仅仅把对象置为null而不关闭，就会引起内存泄漏</p>
</blockquote>
<ul>
<li>单例造成的内存泄漏</li>
</ul>
<blockquote>
<p>单例的静态性使得其生命周期跟app的生命周期一样长，如果使用不恰当(比如引用了非Application 的 Context)的话，很容易造成内存泄漏。</p>
</blockquote>
<ul>
<li>注册对象未注销</li>
</ul>
<blockquote>
<p>观察者模式的注册，在不使用的时候未注销，就会导致，如在Activity中监听电话服务，定义PhoneStateListener注册到TelphoneManager服务中，如果忘记注销，会导致Activity无法被Gc回收。</p>
</blockquote>
<ul>
<li>非静态内部类创建静态实例</li>
</ul>
<blockquote>
<p>首先，非静态内部类会持有外部类的引用。其次，创建的静态实例生命周期和应用的一样长。这样就导致了该静态实例一直会持有该外部类的引用，导致外部类内存资源不能正常回收。</p>
</blockquote>
<ul>
<li>匿名内部类和异步线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line"> Runnable ref1 = <span class="keyword">new</span> MyRunable();</span><br><span class="line"> Runnable ref2 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，ref2的内部类会持有MainActivity 的实例，此时引入一个异步线程，如果此线程与MainActivity 生命周期不一致，就造成MainActivity 泄漏。</p>
<ul>
<li>Handler造成的内存泄漏。</li>
</ul>
<blockquote>
<p>非静态Handler默认持有外部Activity的引用，退出Activity时，如果Looper中还有Message，就会导致Activity无法回收，可以（1）将Handler设置为静态，并且弱引用持有的对象 （2）Activity 的onDestroy的时候，一处消息队列的消息 来解决内存泄漏。</p>
</blockquote>
<ul>
<li>容器中的对象没有清理</li>
</ul>
<blockquote>
<p>容器里的对象在不需要的时候，要及时移除，使其正确及时地被回收。</p>
</blockquote>
<blockquote>
<p>以上内容参考自：<a href="https://yq.aliyun.com/articles/3009?spm=a2c4e.11153940.blogcont70277.24.6387f9c9hDGhAk#" target="_blank" rel="noopener">内存泄漏场景</a></p>
</blockquote>
</details>

<h2 id="22、延伸-内存泄露检测工具"><a href="#22、延伸-内存泄露检测工具" class="headerlink" title="22、延伸-内存泄露检测工具"></a>22、延伸-内存泄露检测工具</h2><p>项目中使用 LeakCanary，参考<a href="https://glassx.gitee.io/2019/11/20/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/">以前的 LeakCanary 源码分析</a> 即可</p>
<h2 id="23、Android应用程序启动过程"><a href="#23、Android应用程序启动过程" class="headerlink" title="23、Android应用程序启动过程"></a>23、Android应用程序启动过程</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>参考<a href="https://glassx.gitee.io/2019/11/25/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC4%E7%AB%A0/">以前的读书笔记</a>即可</p>
</details>

<h2 id="24、Apk-安装的步骤"><a href="#24、Apk-安装的步骤" class="headerlink" title="24、Apk 安装的步骤"></a>24、Apk 安装的步骤</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>分析PMS(PackageManagerService) 就能知道这个过程，总体而言有这几个步骤：</p>
<ol>
<li>首先判断安装源，诸如adb/shell/all_user 等</li>
<li>将apk 文件复制到 /data/app 目录    </li>
<li>解析apk 信息，包括签名校验、四大组件的注册等     </li>
<li>dexopt 操作，优化apk中的.dex文件，对于dalvik 虚拟机，dexopt 就是优化操作；对于art 虚拟机，dexopt 就是将.dex翻译成oat文件。        </li>
<li>更新权限信息：将app所有权限几率下来更新到PMS 中，并判定是否授予该app 请求的权限。         </li>
<li>安装完成，发送 Intent.ACTION_PACKAGE_ADDED 广播   </li>
</ol>
<blockquote>
<p>以上内容参考自：<a href="http://www.androidos.net.cn/book/android-road/android/advance/apk-install.html" target="_blank" rel="noopener">apk安装步骤</a>  </p>
</blockquote>
</details>

<h2 id="25、ANR异常发生条件？如何分析ANR？"><a href="#25、ANR异常发生条件？如何分析ANR？" class="headerlink" title="25、ANR异常发生条件？如何分析ANR？"></a>25、ANR异常发生条件？如何分析ANR？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="ANR-发生条件："><a href="#ANR-发生条件：" class="headerlink" title="ANR 发生条件："></a>ANR 发生条件：</h3><ul>
<li>5s内没有响应用户输入事件</li>
<li>10s内广播接收器没有处理完毕</li>
<li>20s内服务没有处理完毕</li>
</ul>
<h3 id="ANR-时，系统做了什么"><a href="#ANR-时，系统做了什么" class="headerlink" title="ANR 时，系统做了什么"></a>ANR 时，系统做了什么</h3><ol>
<li>弹窗    </li>
<li>将ANR 信息输出到 /data/anr/traces.txt 文件中(无需root 就能通过 adb pull 命令拷贝出来)    </li>
<li>将ANR 信息输出到 Logcat 中(包含PID、Reason、CPU负载 等)  </li>
</ol>
<blockquote>
<p>以上内容参考自： <a href="https://blog.csdn.net/c_z_w/article/details/91879572" target="_blank" rel="noopener">very_on</a>     </p>
</blockquote>
</details>

<h2 id="26、Android-热修复原理"><a href="#26、Android-热修复原理" class="headerlink" title="26、Android 热修复原理"></a>26、Android 热修复原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>DexClassLoder 可以用来从 .jar 和 .apk 类型的文件内部加载classes.dex 文件。用来执行非安装的程序代码。    </li>
<li>两个dex 中存在相同的 class 文件，则会从第一个dex 中找，找到了直接返回，第二个dex 中的class 永远不会被加载进来。   </li>
<li>阻止引用类被打上 CLASS_ISPREVERIFIED 标志。    </li>
</ul>
<blockquote>
<p>在虚拟机启动的时候，如果verify 选项打开，static、private方法、构造函数等 中的直接引用到的类都在同一个dex文件中，那么该类就会被打上  CLASS_ISPREVERIFIED 标志。    </p>
</blockquote>
<blockquote>
<p>注意，是阻止引用这的类，也就是说，假设有类叫做 LoadBugClass ，在其内部引用了 BugClass，在发布过程中发现 BugClass 有编写错误，那么想要发布一个新的 BugClass ，那么就要阻止 LoadBugClass 这个类被打上 CLASS_ISPREVERIFIED 的标志。而这个标志是在 apk 安装的时候，优化成odex 的阶段被添加的。所以在生成apk之前就要阻止 CLASS_ISPREVERIFIED。</p>
</blockquote>
<blockquote>
<p>以上内容参考自：<a href="http://www.androidos.net.cn/book/android-road/android/advance/hotfix.html" target="_blank" rel="noopener">热修复原理</a></p>
</blockquote>
</details>

<h2 id="27、插件化技术原理"><a href="#27、插件化技术原理" class="headerlink" title="27、插件化技术原理"></a>27、插件化技术原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>插件化就是让我们应用不必把所有的内容都放在一个apk中，可以把一些功能和逻辑单独抽出来放在插件apk中，然后主apk 按需调用。一来可以让主apk体积更小，二来可以做到热插拔，动态化。</p>
<p>插件化技术基础：</p>
<ul>
<li>DexClassLoader，想要实现加载外部的dex 来实现热部署，必然要把其中的class 文件加载到内存。DexClassLoader 能做到加载.jar 和 .apk 文件中的 class 文件。     </li>
<li>Java 反射：因为插件apk 与宿主apk 不再一个apk 内，那么一些类的访问必然要通过反射进行获取。    </li>
<li>插件资源访问：res 里每个资源都会在R.java里生成一个Integer 类型的id，app 启动时会把R文件注册到当前的上下文环境，我们在代码中以R文件方式访问资源正是通过这些id访问。然而，插件的R.java并没有注册到当前的上下文，所以也就无法通过id使用。</li>
</ul>
<blockquote>
<p>我们可以通过 addAssetPath 方法重新生成一个新的 Resource 对象来保存插件中的资源，避免冲突。    </p>
</blockquote>
<ul>
<li>代理模式：无论是通过activity代理还是通过DroidPlugin 去hook activity 启动过程来启动activity的方式，都是对代理模式的应用。在前一种方式中，虽然加载进来了Activity 等组件，但也仅仅是作为一个普通对象而存在，并没有在AndroidManifest中注册，没有生命周期回调。这时候通过代理即可。</li>
</ul>
<blockquote>
<p>以上内容参考自： <a href="http://www.androidos.net.cn/book/android-road/android/advance/plugin.html、virtualAPK" target="_blank" rel="noopener">http://www.androidos.net.cn/book/android-road/android/advance/plugin.html、virtualAPK</a> 实现方式可以<a href="http://www.androidos.net.cn/book/android-road/android/advance/virtualapk.html" target="_blank" rel="noopener">参考这里</a></p>
</blockquote>
</details>

<h2 id="28、轮播图实现原理？"><a href="#28、轮播图实现原理？" class="headerlink" title="28、轮播图实现原理？"></a>28、轮播图实现原理？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>原理：</p>
<ul>
<li><p>如果只有一张图，则不作处理     </p>
</li>
<li><p>如果有n张图，则在 ViewPager 的adapter中做如下处理：</p>
<ol>
<li>getAccount 返回 n * 10000</li>
<li>instantiateItem 的时候，position 需要对 n 求余</li>
</ol>
</li>
</ul>
<blockquote>
<p>源自项目代码</p>
</blockquote>
</details>

<h2 id="29、ListView-原理"><a href="#29、ListView-原理" class="headerlink" title="29、ListView 原理"></a>29、ListView 原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>ListView 原理主要要提及<strong>RecycleBin 机制</strong>，这是ListView 能够实现大量数据都不会 OOM 的一个重要原因。它包含两个数组：mActiveViews 用于存储当前显示在屏幕上的item，mScrapViews 用于存储已经不可见的item。</p>
<p>ListView 自己是没有覆写 onLayout 方法的，这个方法在父类 AbsListView 中实现。第一次 layout 操作：此时ListView 中还没有任何子 View，接着自顶至底填充ListView，这个填充过程首先尝试获取一个 active view，不过此时还没有缓存任何 active view，于是只能通过Adapter 的 getView 获取view(此时convertView 是空的，只能创建)；之后，调用 addViewInLayout 将这个view 添加到 ListView ，将第一屏加载完成后，这个getView 动作就会停止。</p>
<p>第二次Layout：如果layout执行两次的话，那么ListView 就会存在一份重复的数据了。其实第二次layout的过程中，也会去获取 active view ，不过这时候有数据了，有view了，这时候首先执行 detachAllViewsFromParent ，将ListView 中所有的item 都清除掉，detach掉，从而保证第二次 layout 过程中不会产生一份重复数据。由于这些清除掉的item 在 active view 中会有缓存，所以不会重新执行 inflate 过程。之后又重新获取active view ，获取到再 attachViewToParent 就再次添加到 ListView 中。这样经历了 detach 又 attach 过程，ListView 所有子View 就显示出来了。</p>
<p>在滑动的时候，不可见的view会 detach 之后回收到 mScrapViews 中。滑动展示新的item的时候，会从 mScrapViews 废弃的view中获取一个view，再调用 Adapter.getView ，并且将获取到的废弃 View 当做 convertView 传过去，接下来就是我们在 adapter 中常用的写法了。</p>
<p>因此，整个Listview 中总共只有那么几个固定的 item ，滑动的时候就这几个 view 在倒腾(detach 和 attach)，因此不论数据量多大，都不会导致oom。</p>
<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/guolin_blog/article/details/44996879" target="_blank" rel="noopener">郭霖的博客</a></p>
</blockquote>
</details>

<h2 id="30、android-5-0-6-0-7-0-8-0新特性"><a href="#30、android-5-0-6-0-7-0-8-0新特性" class="headerlink" title="30、android 5.0, 6.0, 7.0, 8.0新特性"></a>30、android 5.0, 6.0, 7.0, 8.0新特性</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="5-0"><a href="#5-0" class="headerlink" title="5.0"></a>5.0</h3><ul>
<li>Meterial Design     </li>
<li>ART 虚拟机        </li>
</ul>
<h3 id="6-0"><a href="#6-0" class="headerlink" title="6.0"></a>6.0</h3><ul>
<li>动态权限申请   </li>
<li>移除了 Http Client 库      </li>
<li>Dozen 模式</li>
</ul>
<blockquote>
<p>如果用户未插接设备的电源，在屏幕关闭的情况下，让设备在一段时间内保持不活动状态，那么设备就会进入低电耗模式。在低电耗模式下，系统会尝试通过限制应用访问占用大量网络和 CPU 资源的服务来节省电量。它还会阻止应用访问网络，并延迟其作业、同步和标准闹钟。</p>
</blockquote>
<p>参考<a href="https://developer.android.google.cn/training/monitoring-device-state/doze-standby" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="7-0"><a href="#7-0" class="headerlink" title="7.0"></a>7.0</h3><ul>
<li>多窗口支持(分屏模式)    </li>
<li>JIT/AOT 交叉编译(取一个平衡，节约磁盘占用)。</li>
</ul>
<h3 id="8-0"><a href="#8-0" class="headerlink" title="8.0"></a>8.0</h3><ul>
<li>画中画    </li>
<li>Notification 引入 channel 概念，必须设置    </li>
<li>TextView 自动调整文字大小</li>
</ul>
<h3 id="9-0"><a href="#9-0" class="headerlink" title="9.0"></a>9.0</h3><ul>
<li>刘海屏支持  </li>
<li>多摄像头支持    </li>
</ul>
<h3 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h3><ul>
<li>折叠设备     </li>
<li>深色主题   </li>
</ul>
</details>

<h2 id="31、如何导入外部数据库"><a href="#31、如何导入外部数据库" class="headerlink" title="31、如何导入外部数据库"></a>31、如何导入外部数据库</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>把原来数据库的文件放在 res/raw 目录下。</p>
<p>我们知道Android系统下数据库应该存放在 /data/data/(packageName)/  目录下，我们所要做的就是把已有数据库传入那个目录下。操作方法是用FileInputStream 读原数据库，再用FileOutputStream 写入到那个目录。</p>
<blockquote>
<p>以上内容参考自: <a href="http://www.jackywang.tech/AndroidInterview-Q-A/interview/%E5%A6%82%E4%BD%95%E5%AF%BC%E5%85%A5%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%B0%8F%E7%B1%B3.html" target="_blank" rel="noopener">如何导入外部数据库</a></p>
</blockquote>
</details>

<h2 id="32、Android-消息屏障"><a href="#32、Android-消息屏障" class="headerlink" title="32、Android 消息屏障"></a>32、Android 消息屏障</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Handler 中的Message 可以分为三类：同步消息、异步消息 以及消息屏障(消息屏障也是一种消息，只不过target为null)。同步屏障可以通过 MessageQueue.postSyncBarrier 函数来设置(该方法是私有方法，需要反射调用，新的api 貌似提供了public 的 postSyncBarrier方法)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看，这里就是往MessageQueue 中放入了一个Message ，和Handler 的post 及postDelay 一样，但是我们知道，Handler 的post 或者postDelay 时，Message 的target 字段会引用这个Handler，<strong>而设置同步屏障的时候，没有设置target字段。</strong></p>
<p>异步消息和普通消息一样，Message 中 setAsynchronous(true) 操作了。而通过 MessageQueue 的next() 获取需要处理的 Message 时，有没有target 会是截然不同的处理方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">        <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">        <span class="comment">// which is not supported.</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;<span class="comment">//碰到同步屏障</span></span><br><span class="line">                    <span class="comment">//一直循环，直到拿到距离表头最近的异步消息</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Got a message.</span></span><br><span class="line">                        mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将msg 从消息链表中移除</span></span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        <span class="keyword">return</span> msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// No more messages.</span></span><br><span class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">                <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">                <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">                <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">                <span class="comment">//如果能执行到这里，说明当前没有需要处理的 msg (queue 为空，或者 msg 的时间还没到)</span></span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    <span class="comment">//获取当前IdleHandler的数量</span></span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">//没有需要处理的idleHandler，退出</span></span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//用将所有的idleHandler存入mPendingIdleHandlers</span></span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Run the idle handlers.</span></span><br><span class="line">            <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">            <span class="comment">//迭代处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">                mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    keep = idler.queueIdle();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//根据返回值，选择是否remove这个idleHandler</span></span><br><span class="line">                <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">            pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">            <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">            nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果碰到没有 target 的 msg ，则会一直遍历是否有异步的消息，如果有，则马上处理，可以说设置了同步屏障后，Handler 只会处理异步消息(在达到目标后，要求手动调用 MessageQueue.removeSyncBarrier 来移除屏障)。</p>
<p>当messageQueue 中没有msg 或者最早的一个 msg 都要在一段时间之后执行，那么如果直接让线程空转有点浪费，在这个时候，系统会去调用这个IdleHandler 接口回调(如果有的话)，如果上述代码返回false，说明只需要执行一次，在执行完了之后，将会被remove掉；如果返回true，则认为会执行多次。</p>
<p>使用场景：Android系统中存在Vsync 消息，主要负责 16ms 更新一次屏幕展示，如果同步消息在16ms内没执行完成，就会出现掉帧，用户感觉卡顿。假如在 Vsync 消息加入 MessageQueue 时前面还有 10个同步消息，每个消息执行10ms，那么总共也需要100ms ，这段时间会丢掉很多帧，为了解决这种排队等候，可以使用同步屏障+异步消息。如 ViewRootImpl 的 scheduleTraversals 方法就是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上内容参考自<a href="https://blog.csdn.net/asdgbc/article/details/79148180" target="_blank" rel="noopener">Handler之同步屏障机制</a>、<a href="https://www.jianshu.com/p/2535f24d291c" target="_blank" rel="noopener">Android 源码分析 - Handler的同步屏障机制</a>、同步屏障的使用示例可以参考<a href="https://blog.csdn.net/xingzhong128/article/details/102643103" target="_blank" rel="noopener">Android中异步消息和同步屏障</a></p>
</details>

<h2 id="33、引申-IdelHandler"><a href="#33、引申-IdelHandler" class="headerlink" title="33、引申-IdelHandler"></a>33、引申-IdelHandler</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>通过以下代码可以添加IdleHandler (注意是Looper.myQueue，而不是Looper.myLooper：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getMainLooper().myQueue()或者Looper.myQueue()</span></span><br><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> IdleHandler() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//你要处理的事情</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>结合消息屏障中列出的代码可知，如果在 queueIdle 方法中返回false，则在方法执行完成之后，这个 IdleHandler 将会被移除，即只执行一次；如果return true，则会多次执行。</p>
<p>IdelHandler 的常用场景有：1、延迟执行：当Activity 启动时，需要延时执行一些操作，以免启动过慢，我们通常使用postDelay的方式执行，但是这个delay的时间不太好把握，这时候用 IdelHandler 会更优雅。  2、批量任务，只关心最终结果，例如开发im应用，通常情况下每收到一个消息都会刷新一下ui，短时间内收到多个消息，就会刷新多次界面，容易造成卡顿，影响性能，这时候可以通过子线程监听im消息，通过IdelHandler 刷新ui是比较理想的。</p>
<p>以上内容参考自<a href="https://www.jianshu.com/p/db7bda388d4a" target="_blank" rel="noopener">张小凡凡</a></p>
</details>

<h2 id="34、卡顿之-BlockCanary-原理"><a href="#34、卡顿之-BlockCanary-原理" class="headerlink" title="34、卡顿之-BlockCanary 原理"></a>34、卡顿之-BlockCanary 原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>卡顿可以使用 BlockCanary 去监测，它需要你自己指定超时的阈值，超过这个阈值就展示出来。我们只知道这个功能，但是它的原理是啥呢？我们可以首先看下 Looper 的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment"> * application's main looper. The main looper for your application</span></span><br><span class="line"><span class="comment"> * is created by the Android environment, so you should never need</span></span><br><span class="line"><span class="comment"> * to call this function yourself.  See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the application's main looper, which lives in the main thread of the application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> sMainLooper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们整个进程就只有一个主线程，主线程只有一个 mainLooper ，所以不管多少Handler 与主线程相关，最终都会让这个 mainLooper 来处理，我们再来看下 mainLooper 处理事务的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取printer</span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在执行特定message 之前打印日志</span></span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Make sure the observer won't change while processing a transaction.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理事务</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//事务处理完成后，再次打印</span></span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 Printer 类型的 mLogging，在每个 Message 处理前后都调用了一遍，printer 流程卡住了，不就是主线程卡住了吗？而我们只需要执行以下代码：</p>
<blockquote>
<p>Looper.getMainLooper().setMessageLogging();</p>
</blockquote>
<p>就可以设置自己自定义的 Printer ，这样当卡顿发生时，就能感知了。</p>
<blockquote>
<p>以上内容参考自 <a href="http://blog.zhaiyifan.cn/2016/01/16/BlockCanaryTransparentPerformanceMonitor/" target="_blank" rel="noopener">BlockCanary作者的博客</a></p>
</blockquote>
</details>

<h2 id="35、Android-跨进程通信之-Binder"><a href="#35、Android-跨进程通信之-Binder" class="headerlink" title="35、Android 跨进程通信之 Binder"></a>35、Android 跨进程通信之 Binder</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Linux 内核提供了丰富的进程间通信机制，如 管道(pipe)、信号(signal)、消息队列(Message)、共享内存(Share Memory) 以及 Socket 等。——摘自《Android系统源代码分析》</p>
<p>Android 中使用 Binder 进行多进程间通信只需要一次数据拷贝，效率上仅次于共享内存。Binder IPC 机制通过 mmap() 内存映射实现，<strong>内存映射简单讲就是将用户空间的一块内存区域映射到内核空间</strong>。Android 中Binder 进程间通信示意图如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/Android%E5%9F%BA%E7%A1%80/Binder%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.png" alt="Binder进程间通信"></p>
<h3 id="Binder-通信中的代理模式"><a href="#Binder-通信中的代理模式" class="headerlink" title="Binder 通信中的代理模式"></a>Binder 通信中的代理模式</h3><p>我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现了，但是还有问题让我们困惑：A进程想要B进程中某个对象(object) 是如何实现的呢？毕竟分数不同的进程，内存地址映射规则也不一样，A进程没法直接使用B进程中的object。</p>
<p>其实，数据流经过Binder驱动都会左一层转换。当A进程想要获取B进程中的object 时，驱动并不会真的把 object 返回给 A，而是返回一个与 object 看起来一样的代理对象 objctProxy，这个 objctProxy 有object 的所有方法，但是这些方法没有 objct 方法中的那些能力，这些方法的主要工作就是将请求参数交给 Binder 驱动，而对于A进程来讲，就和直接调用 object 对象一样一样的。</p>
<p>当Binder 驱动收到 A 进程的消息后，发现是 objctProxy ，接着查询自己维护的表单，发现它是B进程 object 的代理对象，于是就通知B进程调用 object 的指定方法，并要求将结果返回自己。之后Binder 驱动将结果转发给A进程，一次通信就完成了。具体通信过程如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/Android%E5%9F%BA%E7%A1%80/%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%80%9A%E4%BF%A1.png" alt="通过代理模式通信"></p>
<h3 id="多进程通信方式选择"><a href="#多进程通信方式选择" class="headerlink" title="多进程通信方式选择"></a>多进程通信方式选择</h3><p>如果想进程间通信，但是无需多线程，可以使用 Messenger；如果需要进程间通信，并且还需要再服务中处理多线程，那就使用AIDL(其实Socket也是能实现的)。</p>
<p>顺带一提：App实现多进程有很多弊端，比如：静态和单例会失效(不是同一规则的内存映射)、sharedPreference 会不可靠 等</p>
<blockquote>
<p>以上内容参考自<a href="https://www.cnblogs.com/sixrain/p/11149780.html" target="_blank" rel="noopener">Android进程间通信</a></p>
</blockquote>
</details>

<h2 id="36、事件分发"><a href="#36、事件分发" class="headerlink" title="36、事件分发"></a>36、事件分发</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><a href="https://glassx.gitee.io/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/">参考以前的事件分发专题</a> 即可。</p>
</details>

<h2 id="37、所谓的Android-开发高手课"><a href="#37、所谓的Android-开发高手课" class="headerlink" title="37、所谓的Android 开发高手课"></a>37、所谓的Android 开发高手课</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>bitmap 是烧内存大户，3.0~7.0中会将bitmap对象和像素数据统一放到Java堆中，不过还是会引起大量gc甚至导致oom。将Bitmap 内存放到Native 中可以做到和对象一起快速释放，Android 8.0 中提供 NativeAllocationRegistry 帮助将bitmap 放到 native 内存，同时还能满足与对象一起回收。</p>
<h3 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h3><p>首先看主线程的堆栈，查看是否因为锁等待导致。接着看 ANR 日志中的 iowait、CPU、GC、systemt server 等信息，进一步确定是否是 io 问题，或者是 CPU 竞争问题，还是由于大量 GC 导致卡死。从 Logcat 中能够看到当时系统的一些行为，比如出现 ANR 时，会有 “am_anr”，App被kill 时，会有 “am_kill”。</p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><ul>
<li>整个序列化过程使用了大量的反射和临时变量，而且在序列化对象的时候，不仅会序列化当前对象本身，还需要递归序列化对象引用的其他对象    </li>
<li>因为存在大量反射和 GC 的影响，序列化的性能会比较差。另外一方面因为序列化文件需要包含的信息非常多，导致它的大小比 Class 文件本身还要大很多，这样又会导致 I/O 读写上的性能问题    </li>
<li>Parcel 序列化和 Java 的 Serializable 序列化差别还是比较大的，Parcelable 只会在内存中进行序列化操作，并不会将数据存储到磁盘里。</li>
</ul>
<blockquote>
<p>参考自<a href="https://www.cnblogs.com/sixrain/p/11777135.html" target="_blank" rel="noopener">别人的博客</a></p>
</blockquote>
</details>

<h2 id="38、Android-中大图加载"><a href="#38、Android-中大图加载" class="headerlink" title="38、Android 中大图加载"></a>38、Android 中大图加载</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>一般为了尽可能避免OOM，图片加载都会按照如下做法：</p>
<ul>
<li>如果仅仅只需要读取大图的尺寸和类型，那我们没必要将其加载到内存，在解码的时候，指定  BitmapFactory.Options 中的inJustDecodeBounds 属性设置为true即可，这样避免为bitmap 分配内存，但是能读到图片的尺寸和类型。根据图片的大小以及ImageView 的大小，我们可以配置 BitmapFactory.Options.inSampleSize 来确定加载到内存中图片的大小。      </li>
<li>对于图片显示,根据需要显示图片空间的大小对图片进行压缩显示(我们是提交给后台的链接中拼接了所需要的尺寸)       </li>
<li>如果图片非常多，则会使用 LruCache 等缓存机制，将所有图片占据的内容维持在一个范围。详情可以参考<a href="https://blog.csdn.net/guolin_blog/article/details/9316683" target="_blank" rel="noopener">郭霖的博客</a></li>
</ul>
<p>但是，还有一种情况，如果单个图片非常巨大，并且还不允许压缩(如清明上河图、世界地图等)，那么我们可以使用 <strong>BitmapRegionDecoder</strong> 来实现。</p>
<blockquote>
<p>BitmapRegionDecoder 的原理是：给定一个矩形区域(Rect)，然后通过 Bitmap bitmap = mDecoder.decodeRegion(mRect,opthions) 方法来获取这个区域的 bitmap 展示。因此我们大图展示过程中，都是一次次分割实现的。</p>
</blockquote>
</details>

<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/lmj623565791/article/details/49300989" target="_blank" rel="noopener">鸿洋</a>、<a href="https://developer.android.google.cn/topic/performance/graphics/load-bitmap" target="_blank" rel="noopener">官方文档</a></p>
</blockquote>
<h2 id="39、关于Android绘制"><a href="#39、关于Android绘制" class="headerlink" title="39、关于Android绘制"></a>39、关于Android绘制</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>60帧的画面让人感觉不到画面的更新，因此Android系统中基本上是 60帧/s的刷新频率，也就是每16ms 发出一次 <strong>VSYNC信号</strong>触发对UI的绘制。当然，我们要明白，<strong>这个 16ms 不只是全用来绘制界面，而是会包括layout、measure</strong>。</p>
<p>整体的过程就是，<strong>cpu执行计算任务</strong>，即 layout、measure后将ui计算成多维图形(多边形、纹理)，再经过OpenGL处理，之后交给GPU 进行<strong>栅格化</strong>后显示在屏幕上。 因此，16ms的时间主要被两件事情占用，第一件:将UI对象转换为一系列多边形和纹理；第二件：CPU传递处理数据到GPU进行栅格化</p>
<h3 id="Frame-Buffer中的数据是怎么来的"><a href="#Frame-Buffer中的数据是怎么来的" class="headerlink" title="Frame Buffer中的数据是怎么来的"></a>Frame Buffer中的数据是怎么来的</h3><p>GPU 从Frame Buffer 中获取数据绘制，但其除了 Frame Buffer 外，还有缓冲的Back Buffer ，GPU 也会定时地切换这两个 Buffer 的角色(可能其中一个为Frame Buffer，另一个就为 Back Buffer)，由于16ms 发出一次 VSYNC 信号，因此这个切换也是 16ms。</p>
<p>在系统将Back Buffer 交给应用填充数据时，实际过程是将 Back Buffer 锁定，讲一个指向它的引用交给你的应用，这个<strong>引用就是Canvas对象</strong>，View的onDraw 方法中接收到的Canvas就是它。我们知道，父view在onDraw的时候，会一直调用子View的onDraw方法，这个Canvas 就会一直传递下去给每一个View。当所有的View 都通过Canvas 绘制完成后，才算完成了一帧的绘制。</p>
<h3 id="丢帧是怎么发生的"><a href="#丢帧是怎么发生的" class="headerlink" title="丢帧是怎么发生的"></a>丢帧是怎么发生的</h3><p>上面说GPU 会定期交换 Back Buffer 和 Frame Buffer ，但是有一个例外情况，当你的应用正在往 Back Buffer 中填充数据时，系统会将 Back Buffer 锁定，如果到了 GPU 交换两个Buffer 的时间点，你的应用还在往Back Buffer 中填充数据，GPU 会发现 Back Buffer 被锁定了，它会放弃这次交换(即发生Jank了)，导致的结果就是手机屏幕仍然显示原来的图像，即用户在32ms内看到的是同一帧。</p>
<h3 id="开发者如何避免"><a href="#开发者如何避免" class="headerlink" title="开发者如何避免"></a>开发者如何避免</h3><p>可以从两个方面考虑：</p>
<ul>
<li>CPU产生的问题：不必要的布局和失效</li>
<li>GPU产生的问题：过度绘制(overdraw)</li>
</ul>
<p>1、避免cpu 计算任务过重。1、减少在onDraw 方法中创建对象，尤其是复杂对象。  2、减少视图层次，尽量使用ConstrainLayout 等代替多层嵌套<br>2、避免cpu、GPU 任务过重，减少不必要的View的invalidate 调用(不invalidate可以让gpu最大限度使用缓存)<br>3、减少过度绘制。1、clipRect帮助识别可见的区域。2、去除View 中不必要的background，因为许多background 并不会显示在最终的屏幕上。比如ImageView，假如它现实的图片填满了空间，你就没有必要给它设置一个背景色。</p>
</details>

<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/wei_lei/article/details/70460132" target="_blank" rel="noopener">wei_lei</a>、<a href="https://www.jianshu.com/p/a769a6028e51" target="_blank" rel="noopener">milter</a>、<a href="https://www.jianshu.com/p/02800806356c" target="_blank" rel="noopener">jianshu</a></p>
</blockquote>
<h2 id="40、屏幕尺寸变化适配有什么手段"><a href="#40、屏幕尺寸变化适配有什么手段" class="headerlink" title="40、屏幕尺寸变化适配有什么手段"></a>40、屏幕尺寸变化适配有什么手段</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>使用 match_parent、wrap_content 等方式藐视控件大小    </li>
<li>使用宽度限定符，如 layout-w600dp    </li>
<li>屏幕方向限定符，如 layout-land、layout_port 来适配横竖屏       </li>
<li>使用Fragment，将界面组件化    </li>
<li>使用.9图片    </li>
</ul>
</details>

<h2 id="41、像素密度"><a href="#41、像素密度" class="headerlink" title="41、像素密度"></a>41、像素密度</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>为了保证在密度不同的屏幕上看起来尺寸相同，必须使用密度无关的像素(density-independent pixels，简称 dp 或者 dip) 作为单位。<strong>1dp 是以中密度屏幕(像素密度(dpi，每平方英尺上的像素个数)：160dpi)作为基准密度，在基准上1dp = 1px</strong>。不过在定义文本时，应该使用可缩放像素(scalable pixels，简称： sp)作为单位。默认情况下，dp 与sp大小相同，但是当用户在设置中调整文本大小时，sp就会变化了。还有，要注意的是，我们平时说的屏幕的尺寸是指的屏幕对角线长度。 </p>
</details>

<blockquote>
<p>以上内容参考自<a href="https://developer.android.google.cn/training/multiscreen/screendensities" target="_blank" rel="noopener">官方文档</a></p>
</blockquote>
<h2 id="42、彻底理解android-应用无响应机制"><a href="#42、彻底理解android-应用无响应机制" class="headerlink" title="42、彻底理解android 应用无响应机制"></a>42、彻底理解android 应用无响应机制</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先总结下ANR发生的情况以及阈值：</p>
<p><img src="http://gityuan.com/images/android-anr/anr_timeout.jpg" alt="Anr发生的阈值"></p>
<p>ANR的原理基本上都是<strong>执行某项操作task之前，通过Handler 发送一个延时 Message，如果在延时时间到达之前 task 执行完成，则通过handler removeMessage 将Message 移除，否则，在延时时间到达之后还未能完成，Handler 便会处理这个message，从而抛出ANR</strong>。尤其需要注意的有以下几点：</p>
<ul>
<li>通过静态注册的广播(动态广播不用考虑)在完成前会检查 SharedPreference 是否已经完成同步到磁盘，如果没有，要等其完成才能告知系统已经完成。    </li>
<li>Provider 只有在进程首次启动的时候才会检测ANR，当provider 进程已经启动，再次请求provider 不会触发超时。    </li>
<li>Activity 退出也会检查 sp 是否已经同步到磁盘，未完成的话，也会等待。</li>
</ul>
<h3 id="回答有哪些路径会导致ANR"><a href="#回答有哪些路径会导致ANR" class="headerlink" title="回答有哪些路径会导致ANR"></a>回答有哪些路径会导致ANR</h3><p>从handler 发送了 message 到 removeMessage 之前的任何一个环节都可能出现ANR，比如：service 的回调方法慢，比如主线程的消息队列存在耗时消息让service 的回调迟迟得不到执行，可能是sp操作缓慢，可以是system_server 进程的binder 线程繁忙，而导致 removeMessage 没来得及执行，也有可能是广播在等待sp操作，等等。</p>
<h3 id="ANR-避免"><a href="#ANR-避免" class="headerlink" title="ANR 避免"></a>ANR 避免</h3><ul>
<li>主线程尽量只做UI相关操作，避免耗时操作，如过度绘制、IO操作    </li>
<li>避免主线程与工作线程发生锁竞争    </li>
<li>谨慎使用SharedPreference     </li>
</ul>
</details>

<blockquote>
<p>以上内容参考自<a href="http://gityuan.com/2019/04/06/android-anr/" target="_blank" rel="noopener">gityuan的博客</a>、<a href="http://gityuan.com/2016/07/02/android-anr/" target="_blank" rel="noopener">gityuan博客</a></p>
</blockquote>
<h2 id="43、为什么要使用Binder-机制进程间通信"><a href="#43、为什么要使用Binder-机制进程间通信" class="headerlink" title="43、为什么要使用Binder 机制进程间通信"></a>43、为什么要使用Binder 机制进程间通信</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="Linux现有的IPC-方式"><a href="#Linux现有的IPC-方式" class="headerlink" title="Linux现有的IPC 方式"></a>Linux现有的IPC 方式</h3><ul>
<li><p>管道：<strong>信息复制2次</strong>。在创建时分配一个page大小的内存，缓存区大小比较有限；    </p>
</li>
<li><p>消息队列：<strong>信息复制2次</strong>。额外的CPU消耗；不合适频繁或信息量大的通信；    </p>
</li>
<li><p>共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；     </p>
</li>
<li><p>套接字(Socket)：<strong>信息复制2次</strong>。作为更通用的接口，传输效率低，主要用于同机器或跨网络的通信；   </p>
</li>
<li><p>信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。   </p>
</li>
<li><p>信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；   </p>
</li>
</ul>
<h3 id="为什么采用Binder-从5个维度"><a href="#为什么采用Binder-从5个维度" class="headerlink" title="为什么采用Binder(从5个维度)"></a>为什么采用Binder(从5个维度)</h3><p>总结下：从性能的角度、从稳定性的角度、从安全的角度、从语言层面的角度、从公司战略的角度</p>
<ul>
<li>从性能的角度:从拷贝次数看，仅次于共享内存。但是共享内存会遇到进程同步，太复杂。      </li>
<li>从稳定性的角度：Binder 基于 C/S 架构，清晰明了，Client 端与Server 端相对独立。     </li>
<li>从安全的角度：传统的Linux IPC 只能由用户在数据包里填入UID/PID，接收方无法获得对方进程可靠的 UID/PID ,从而无法鉴别对方身份。而Android 为每个安装好的应用都分配了自己的UID。此外，C/S架构有利于Server端根据UID鉴别访问权限。     </li>
<li>语言层面：Binder 这种面向对象的思想与Android 开始的开发语言 Java 高度契合。     </li>
<li>公司战略： 公司战略层面就不多说了     </li>
</ul>
<p>另外，Linux没有采用Binder 不是他们没想到，而是Binder 更适合Android这种手持设备而已。</p>
</details>

<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/Gityuan/article/details/88969180" target="_blank" rel="noopener">gityuan的csdn</a></p>
</blockquote>
<h2 id="44、Binder-机制"><a href="#44、Binder-机制" class="headerlink" title="44、Binder 机制"></a>44、Binder 机制</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>而一般的进程间通信方式(共享内存除外)，需要Client端进程空间拷贝到内核空间，再由内核空间拷贝到Server进程空间，会发生两次拷贝。</p>
<p>Binder 进程间的高效率通信的秘诀在于 binder_mmap() ，如下图示意：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/Android%E5%9F%BA%E7%A1%80/binder_mmap.jpg" alt="Binder的mmap操作"></p>
<p>虚拟进程地址空间(vm_area_struct)和虚拟内核地址空间(vm_struct)都映射到同一块物理内存空间。当Client端与Server端发送数据时，Client（作为数据发送端）先从自己的进程空间把IPC通信数据copy_from_user拷贝到内核空间，而Server端（作为数据接收端）与内核共享数据，不再需要拷贝数据，而是通过内存地址空间的偏移量，即可获悉内存地址，整个过程只发生一次内存拷贝。</p>
<p>进程和内核虚拟地址映射到同一个物理内存的操作是发生在数据接收端，而数据发送端还是需要将用户态的数据复制到内核态。</p>
<p>下图展示了通过Binder 进行进程间通信：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/Android%E5%9F%BA%E7%A1%80/binder%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.jpg" alt="Binder进程间通信示意"></p>
<p><strong>我个人理解，client 与server 双方都有进行 mmap 映射操作，但是在用户空间获取到的映射空间只能读，不能写。这样，双方发送数据时都只需要执行 copy_from_user 即可，在接收端通过地址偏移就能获取到数据</strong></p>
<p>从<a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">universus的博客(据说这篇博客是介绍binder的神级存在)</a>能看出来确实两端都有映射。</p>
</details>

<blockquote>
<p>以上内容参考自<a href="http://gityuan.com/2015/11/02/binder-driver-2/" target="_blank" rel="noopener">gityuan的博客</a></p>
</blockquote>
<h2 id="45、动画"><a href="#45、动画" class="headerlink" title="45、动画"></a>45、动画</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>帧动画、View 动画(补间动画)、属性动画</p>
<ul>
<li>帧动画就一帧帧播放     </li>
<li>View动画：指定开始状态和结束状态，中间的view会自动被补齐，主要支持 平移、缩放、透明度、旋转 四种基本效果。主要应用场景： view的动画 以及 Activity、Fragment 的切换动画。<strong>注意：View 动画执行到某个位置时，它的动作响应(比如点击)还停留在原来位置的，只有点击原来位置才有效，因为它不是真正改变View的属性。</strong>       </li>
<li>属性动画：真正的视图移动，点击移动后的视图会有效果。   </li>
</ul>
</details>

<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/f552126367/article/details/84567900" target="_blank" rel="noopener">会飞的鱼</a></p>
</blockquote>
<h2 id="46、关于Android绘制"><a href="#46、关于Android绘制" class="headerlink" title="46、关于Android绘制"></a>46、关于Android绘制</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>60帧的画面让人感觉不到画面的更新，因此Android系统中基本上是 60帧/s的刷新频率，也就是每16ms 发出一次 <strong>VSYNC信号</strong>触发对UI的绘制。当然，我们要明白，<strong>这个 16ms 不只是全用来绘制界面，而是会包括layout、measure</strong>。</p>
<p>整体的过程就是，<strong>cpu执行计算任务</strong>，即 layout、measure后将ui计算成多维图形(多边形、纹理)，再经过OpenGL处理，之后交给GPU 进行<strong>栅格化</strong>后显示在屏幕上。 因此，16ms的时间主要被两件事情占用，第一件:将UI对象转换为一系列多边形和纹理；第二件：CPU传递处理数据到GPU进行栅格化</p>
<h3 id="Frame-Buffer中的数据是怎么来的-1"><a href="#Frame-Buffer中的数据是怎么来的-1" class="headerlink" title="Frame Buffer中的数据是怎么来的"></a>Frame Buffer中的数据是怎么来的</h3><p>GPU 从Frame Buffer 中获取数据绘制，但其除了 Frame Buffer 外，还有缓冲的Back Buffer ，GPU 也会定时地切换这两个 Buffer 的角色(可能其中一个为Frame Buffer，另一个就为 Back Buffer)，由于16ms 发出一次 VSYNC 信号，因此这个切换也是 16ms。</p>
<p>在系统将Back Buffer 交给应用填充数据时，实际过程是将 Back Buffer 锁定，讲一个指向它的引用交给你的应用，这个<strong>引用就是Canvas对象</strong>，View的onDraw 方法中接收到的Canvas就是它。我们知道，父view在onDraw的时候，会一直调用子View的onDraw方法，这个Canvas 就会一直传递下去给每一个View。当所有的View 都通过Canvas 绘制完成后，才算完成了一帧的绘制。</p>
<h3 id="丢帧是怎么发生的-1"><a href="#丢帧是怎么发生的-1" class="headerlink" title="丢帧是怎么发生的"></a>丢帧是怎么发生的</h3><p>上面说GPU 会定期交换 Back Buffer 和 Frame Buffer ，但是有一个例外情况，当你的应用正在往 Back Buffer 中填充数据时，系统会将 Back Buffer 锁定，如果到了 GPU 交换两个Buffer 的时间点，你的应用还在往Back Buffer 中填充数据，GPU 会发现 Back Buffer 被锁定了，它会放弃这次交换(即发生Jank了)，导致的结果就是手机屏幕仍然显示原来的图像，即用户在32ms内看到的是同一帧。</p>
<h3 id="开发者如何避免-1"><a href="#开发者如何避免-1" class="headerlink" title="开发者如何避免"></a>开发者如何避免</h3><p>可以从两个方面考虑：</p>
<ul>
<li>CPU产生的问题：不必要的布局和失效</li>
<li>GPU产生的问题：过度绘制(overdraw)</li>
</ul>
<p>1、避免cpu 计算任务过重。1、减少在onDraw 方法中创建对象，尤其是复杂对象。  2、减少视图层次，尽量使用ConstrainLayout 等代替多层嵌套<br>2、避免cpu、GPU 任务过重，减少不必要的View的invalidate 调用(不invalidate可以让gpu最大限度使用缓存)<br>3、减少过度绘制。1、clipRect帮助识别可见的区域。2、去除View 中不必要的background，因为许多background 并不会显示在最终的屏幕上。比如ImageView，假如它现实的图片填满了空间，你就没有必要给它设置一个背景色。</p>
</details>

<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/wei_lei/article/details/70460132" target="_blank" rel="noopener">wei_lei</a>、<a href="https://www.jianshu.com/p/a769a6028e51" target="_blank" rel="noopener">milter</a>、<a href="https://www.jianshu.com/p/02800806356c" target="_blank" rel="noopener">jianshu</a></p>
</blockquote>
<h2 id="47、Kotlin-优势"><a href="#47、Kotlin-优势" class="headerlink" title="47、Kotlin 优势"></a>47、Kotlin 优势</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>按照官网上的说法：</p>
<ul>
<li>简洁。</li>
</ul>
<blockquote>
<p>判空、getter、setter 方法、命名传参(动态改变参数)无需重载，可能结合anko 之类的更加简单</p>
</blockquote>
<ul>
<li>安全</li>
</ul>
<blockquote>
<p>减少空指针等错误、类型判断过后，自动类型转换</p>
</blockquote>
<ul>
<li>兼容java</li>
</ul>
<blockquote>
<p>可以混编</p>
</blockquote>
</details>

<h2 id="48、多进程-webview"><a href="#48、多进程-webview" class="headerlink" title="48、多进程 webview"></a>48、多进程 webview</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>想着app只有一个 Cookies 的 db 文件，估摸着跨进程的 webview 能共享这个cookie数据。今天试了试，结果发现俩问题：</p>
<ul>
<li>加上跨进程后，在一加6上(Android 10 系统)运行崩了，但是在魅族15上(Android 7.1.1系统)运行良好    </li>
<li>主进程webview 的cookies 正常，但是新进程的webview 加载 cookies 缺失。      </li>
</ul>
<p>很奇怪的是，通过 adb shell ,run-as com.esun.ui ，获取app_webview 中的 Cookies 文件用sqlite3 打开，里面的 cookies 一条条又是正常的！初步断定是同步的问题，因为只有一个db文件，不可能不一样。</p>
<p>至于，一加手机不能正常使用，是因为Android P及以上的版本<strong>不支持从多个进程使用具有相同数据目录的Webview</strong>，官方的解决方法就是给不同进程的Webview 设置不同的数据目录(在Application中)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.P)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initWebViewDataDirectory</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;</span><br><span class="line">        String processName = getProcessName(context);</span><br><span class="line">        <span class="keyword">if</span> (!context.getPackageName().equals(processName)) &#123;<span class="comment">//判断是否是默认进程名称</span></span><br><span class="line">            WebView.setDataDirectorySuffix(processName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/liudave/article/details/103957340" target="_blank" rel="noopener">liudave</a>、<a href="https://www.jianshu.com/p/6c3e97a44bee" target="_blank" rel="noopener">简书上的博客</a></p>
</blockquote>
<h2 id="49、无需root，获取应用在-data-data-packageName-里面的数据"><a href="#49、无需root，获取应用在-data-data-packageName-里面的数据" class="headerlink" title="49、无需root，获取应用在/data/data{packageName}/里面的数据"></a>49、无需root，获取应用在/data/data{packageName}/里面的数据</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>在debug 包情况下，我们可以在未经授权的情况下获取 /data/data{packageName}/ 目录下的数据，比如：Cookies 的db 文件(虽然没有db后缀，但是就是个db文件)、SharedPreference 的xml 文件等。具体步骤：</p>
<ol>
<li>执行 adb shell    </li>
<li>run-as {包名}   ，例如：  run-as com.example.haha    </li>
<li>这时候 ls 命令能看到我们 app 在/data/data/ 目录下的所有文件了    </li>
</ol>
<p>如果需要将 Cookies 文件拷贝到电脑桌面的话，我们需要先将其拷贝到sd卡上：</p>
<ol>
<li>首先，拷贝到sd卡上： cp app_webview/Cookies /sdcard/    </li>
<li>其次，退出 shell 模式，执行： exit  (多次执行，直到回到初始状态)    </li>
<li>最后，使用adb pull 命令将文件拉出来    </li>
</ol>
<p>如果需要查看这个Cookies 的db 文件，可以使用以下指令即可查看：</p>
<blockquote>
<p>sqlite3 /home/sample/Desktop/Cookies<br>.dump cookies   </p>
</blockquote>
</details>

<h2 id="50、签名"><a href="#50、签名" class="headerlink" title="50、签名"></a>50、签名</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="APK-Signature-Scheme-v1"><a href="#APK-Signature-Scheme-v1" class="headerlink" title="APK Signature Scheme v1"></a>APK Signature Scheme v1</h3><p>解压一个签名后的 APK ，在 META-INF 目录下会有三个文件： MANIFEST.MF、CERT.SF、CERT.RSA。它们就是v1签名的关键。</p>
<p>其中，MANIFEST.MF存储了APK中的每个文件的文件名和摘要，类似如下形式(上面是文件名，下面是文件的 SHA256 消息摘要之后进行 Base64编码)：</p>
<blockquote>
<p>Name: AndroidManifest.xml<br>SHA-256-Digest: bWeqbdj+sLYqFQPe/j3kjv7hGZZYFm+YheK2AwGnW90=</p>
</blockquote>
<p>CERT.SF 称为二次摘要文件。它的格式和 MANIFEST.MF 的一样，也是上面name，下面摘要，只不过摘要是对 MANIFEST.MF 中的摘要条目做摘要(对MANIFEST.MF摘要条目进行SHA-256摘要再base64处理,<strong>值得注意的是，CERT.SF中存储了 MANIFEST.MF 整个文件的 摘要值</strong>)：</p>
<blockquote>
<p>Name: AndroidManifest.xml<br>SHA-256-Digest: bQWn4Jvp6bjlQUQQ8cr1NO9nl9hrMXMTbVeXGULZwSI=</p>
</blockquote>
<p>最后，CERT.RSA 文件与 CERT.SF 文件是相互对应的，二者的名字一样，它里面主要存储了证书的公钥、过期日期、发行人、加密算法、CERT.CF文件的签名(使用私钥对CERT.CF文件的签名)等。</p>
<p>从以上信息我们知道，使用不同的keystore进行签名时，除了 CERT.RSA 文件外，其余两个文件都是一样的。也就是说前两者主要保证各个文件的完整性，而 CERT.RSA 用来保证apk的来源即完整性。</p>
<h3 id="v1-签名校验过程"><a href="#v1-签名校验过程" class="headerlink" title="v1 签名校验过程"></a>v1 签名校验过程</h3><ol>
<li>检查apk中的文件对应的摘要值是否与 MANIFEST.MF 记录的一致    </li>
<li>使用 CERT.RSA 文件检验签名文件 CERT.SF 文件是否被修改过    </li>
<li>使用 CERT.SF 校验 MANIFEST.MF 文件是否被修改过    </li>
</ol>
<blockquote>
<p>为什么这个顺序呢？假设一下，如果你改了apk的文件，那么在安装apk文件时，第一步通过 MANIFEST.MF 校验不通过；假如你改了文件重新计算摘要值，更新了 MANIFEST.MF 文件，那么必定与 CERT.SF 文件中计算的值不一样。最后的保障是</p>
</blockquote>
<h3 id="v1的缺点"><a href="#v1的缺点" class="headerlink" title="v1的缺点"></a>v1的缺点</h3><ul>
<li>META_INF文件不在校验范围内，很容易绕过    </li>
<li>单个文件的完整性校验在安装的时候比较耗时     </li>
</ul>
<h3 id="APK-Signature-Scheme-v2"><a href="#APK-Signature-Scheme-v2" class="headerlink" title="APK Signature Scheme v2"></a>APK Signature Scheme v2</h3><p>v2签名不是针对单个文件，而是将apk分成 1M 大小的块，对每个块计算摘要(<strong>由于块摘要可以并行处理，因此可以提高校验速度</strong>)，之后对所有摘要进行摘要得到顶级摘要，<strong>之后利用私钥对顶级摘要签名得到数字证书(即得到数字证书)</strong>。如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/Android%E5%9F%BA%E7%A1%80/v2%E7%AD%BE%E5%90%8D.webp" alt="v2摘要生成图"></p>
<p>为了保护 APK 内容，整个 APK（ZIP文件格式）被分为以下 4 个区块：</p>
<ul>
<li>ZIP 条目的内容（从偏移量 0 处开始一直到“APK 签名分块”的起始位置)    </li>
<li>APK 签名分块    </li>
<li>ZIP 中央目录    </li>
<li>ZIP 中央目录结尾    </li>
</ul>
<p>可以看到，Android签名存放区域是zip文件的中央目录(central Directory)之前。v2对整个apk签名，因此如果需要对齐(zipalign)的话，必须先对齐后签名。</p>
</details>

<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/freekiteyu/article/details/84849651" target="_blank" rel="noopener">csdn上的博客</a>、<a href="https://www.jianshu.com/p/95096ca209e1" target="_blank" rel="noopener">简书上的博客</a>、<a href="https://www.jb51.net/article/174939.htm" target="_blank" rel="noopener">jb51</a></p>
</blockquote>
<h2 id="51、浅谈TouchDelegate的坑与用法"><a href="#51、浅谈TouchDelegate的坑与用法" class="headerlink" title="51、浅谈TouchDelegate的坑与用法"></a>51、浅谈TouchDelegate的坑与用法</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>用于扩大点击区域</p>
</details>

<blockquote>
<p>以上内容参考自<a href="https://www.jianshu.com/p/ce14c7d96b0c" target="_blank" rel="noopener">简书</a></p>
</blockquote>
<h2 id="52、BitMap-内存管理"><a href="#52、BitMap-内存管理" class="headerlink" title="52、BitMap 内存管理"></a>52、BitMap 内存管理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="Android-2-3-3即更低版本"><a href="#Android-2-3-3即更低版本" class="headerlink" title="Android 2.3.3即更低版本"></a>Android 2.3.3即更低版本</h3><p>无需使用bitmap 的时候，调用其 recycle() 方法     </p>
<h3 id="Android-3-0-及更高版本"><a href="#Android-3-0-及更高版本" class="headerlink" title="Android 3.0 及更高版本"></a>Android 3.0 及更高版本</h3><p>引入了 BitmapFactory.Options.inBitmap 字段，如果设置了此字段，那么采用 Options <strong>对象的解码方法会在加载内容时尝试重复使用现有位图</strong>。不过，使用会有一些限制，尤其是4.4以前，仅支持大小相同的位图的复用。</p>
<p>原理：当Bitmap 从 LruCache 删除时，对其的<strong>软引用</strong>会防止在HashSet 中，以供之后通过 inBitmap 重复使用。</p>
</details>

<blockquote>
<p>以上内容参考自<a href="https://developer.android.google.cn/topic/performance/graphics/manage-memory" target="_blank" rel="noopener">官方文档</a></p>
</blockquote>
<h2 id="53、epoll"><a href="#53、epoll" class="headerlink" title="53、epoll"></a>53、epoll</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>epoll机制提供了Linux平台上最高效的I/O复用机制，它的主要作用是I/O复用，<strong>即在一个地方等待多个文件句柄的I/O事件</strong>。</p>
<p>epoll的效率为什么比 select/poll高呢？有以下几个原因：</p>
<p>1、每次调用select 时，需要把感兴趣的事件都复制到内核中，二epoll 只在epll_ctl 进行加入操作的时候才复制一次<br>2、epoll内部用于保存事件的数据结构使用的是红黑树，查找速度很快，二select采用数组保存信息，不但一次能等待的句柄有限，并且在事件较多时查找起来速度很慢</p>
</details>

<blockquote>
<p>以上内容参考自《深入理解Android：卷II》</p>
</blockquote>
<h2 id="54、杂"><a href="#54、杂" class="headerlink" title="54、杂"></a>54、杂</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>系统有个 framework-res.apk ，这个APK 除了包含资源之外，还包含一些Activity(如关机对话框) ，这些Activity 实际上运行在 system_server 进程中，从这个角度看，system_server 是一个特殊的应用进程     </p>
<p>LoadedApk 用于保存一些和 APK 相关的信息(如资源文件位置、JNI 库位置等)</p>
<p>ActivityThread 中包含一个mLooper 成员，代表一个消息循环。mServices 用于保存 Service ，Activityes 用于保存 ActivityClientRecord，mAllApplications 用于保存 Appkication (注意，我们获取 ApplicationContext 的时候，首先从 LoadApk 中获取，没成功再从 ActivityThread 中获取)。</p>
</details>


<h2 id="55、BroadCastReceiver"><a href="#55、BroadCastReceiver" class="headerlink" title="55、BroadCastReceiver"></a>55、BroadCastReceiver</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>我们知道，在 BroadCastReceiver 的onReceive 中不能执行耗时操作，但是如果我们有这个需求的时候，怎么办呢？其实，如果这个处理比较耗时，可以采用异步的方式处理： 即先调用 BroadCastReceiver 的 goAsync 方法得到一个 PendingResult 对象，然后将该对象放到工作线程中处理，可以参考的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PendingResult result = goAsync();</span><br><span class="line">        wl.acquire();</span><br><span class="line">        AsyncHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                handleIntent(context, intent);<span class="comment">//耗时操作</span></span><br><span class="line">               result.finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HandlerThread sHandlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"AsyncHandler"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Handler sHandler;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        sHandlerThread.start();</span><br><span class="line">        sHandler = <span class="keyword">new</span> Handler(sHandlerThread.getLooper());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        sHandler.post(r);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AsyncHandler</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上内容参考自 《深入理解Android：卷II》第268页、<a href="https://blog.csdn.net/qq_17441227/article/details/83268992" target="_blank" rel="noopener">csdn的博客</a>、<a href="https://www.jianshu.com/p/8cc3ce5af0fc" target="_blank" rel="noopener">简书的博客</a></p>
</blockquote>
<p>Sticky 的广播，一旦有接收者注册，系统马上将该广播传递给它们。</p>
<p>动态注册的非order广播，在 sendBroadcast 的时候，可以直接发送，不需要等待上一个Receiver 接收处理完成后才发送下一个。而静态注册的广播，则必须处理完一个接收者才能处理下一个接收者。这是因为需要<strong>避免惊群效应</strong>，动态广播的接收者的进程是肯定存在的(如果不存在肯定没法注册),而静态注册的广播接收者不能保证它已经和进程绑定了(进程可能还没启动)，假如发送广播时，这些接收者进程都不存在，那么一下子就创建了多个进程，系统压力陡增。每次处理一个的recevier的坏处在于延时较长。</p>
</details>

<blockquote>
<p>以上内容参考自《深入理解Android：卷II》</p>
</blockquote>
<h2 id="56、证书校验"><a href="#56、证书校验" class="headerlink" title="56、证书校验"></a>56、证书校验</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>主要是为了更进一步的安全，防止通过 fiddler 抓包</p>
<p>crt格式的证书保存在assets文件夹中，同时，也可以从后台获取证书，保存在sp文件中，从后台获取证书时，需要将tag(标记客户端当前已有证书的版本，由于本地默认在assets文件夹中有证书，所以默认也有个tag)传过去，如果tag为空，则后台肯定返回证书，否则，判断客户端不是最新证书的情况会返回最新证书。马上判断证书中是否包含请求证书这个接口的host，包括才算成功。如果asset中的证书未失效，那么下载的证书就下次使用；反之，得后台的证书下载下来马上就使用。<strong>通过 CertificateFactory 将crt文件格式的证书转换成 x.509 格式的对象</strong>，之后，对比本地证书的公钥和服务端返回的公钥的值是否一致来决定证书是否校验通过。</p>
<p>有个细节，获取证书的这个接口请求是通过ip请求的(首先通过 114 或者 119 获取host 的ip)，然后将真正的host设置在 header 中，在从后台下载到证书后，验证证书里面是否包含有这个接口的host，包含了才算通过。</p>
</details>


<h2 id="57、RecyclerView与ListView的区别"><a href="#57、RecyclerView与ListView的区别" class="headerlink" title="57、RecyclerView与ListView的区别"></a>57、RecyclerView与ListView的区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>1、局部刷新。RecyclerView 可以局部刷新，而ListView不可以<br>2、ListView的ViewHolder 需要自己定义，并且不是强制要求的；而RecyclerView 是已经封装好了，是强制的<br>3、ListView 的Adapter 继承的是 BaseAdapter；RecyclerView 的Adapter 继承的是 RecyclerView.Adapter<br>4、ListView可以设置分割线；RecyclerView 只能自己些DecodeItem<br>5、ListView 可以针对Item直接添加点击事件，RecyclerView只能自己写回调<br>6、ListView的显示方式没有RecyclerView灵活，后者可以使设置成瀑布流、竖直的、横向的，网格的<br>7、缓存机制不同，缓存层级</p>
</details>

<blockquote>
<p>参考自<a href="https://www.jianshu.com/p/6154ccbe68c4" target="_blank" rel="noopener">简书</a>、<a href="https://www.jianshu.com/p/9f28be270b68" target="_blank" rel="noopener">简书</a></p>
</blockquote>
<h2 id="58、BitmapFactory-Options-用于-Bitmap-内存优化"><a href="#58、BitmapFactory-Options-用于-Bitmap-内存优化" class="headerlink" title="58、BitmapFactory.Options 用于 Bitmap 内存优化"></a>58、BitmapFactory.Options 用于 Bitmap 内存优化</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Options 的成员变量挺多的，类似 inBitmap、inMutable、inJustDecodeBounds、inSampleSize、outWidth、outHeight、outConfig… ，看规律可以发现有 in 和 out 两类命名风格，in 开头可以理解为设置参数，out开头可以理解为获取某些参数。</p>
<p>通过正确使用上述参数，可以很好操作 Bitmap ，减少资源滥用，减少Bitmap的内存占用。</p>
<h3 id="通过-inJustDecodeBounds-获取图片信息"><a href="#通过-inJustDecodeBounds-获取图片信息" class="headerlink" title="通过 inJustDecodeBounds 获取图片信息"></a>通过 inJustDecodeBounds 获取图片信息</h3><p>如果仅仅需要获取图片信息而不要实际使用 Bitmap ，可以为 Options 设置 inJustDecodeBounds 为 true，这样 bitmap 返回的是 null，但却可以获取图片的宽高等信息。 </p>
<h3 id="通过-inSampleSize-降低采样"><a href="#通过-inSampleSize-降低采样" class="headerlink" title="通过 inSampleSize 降低采样"></a>通过 inSampleSize 降低采样</h3><p>很多时候，我们所需要的图片比原图小，这时候可以设置 inSampleSize 来减小图片宽高，当彩艳率(inSampleSize) &gt; 1 时，长和宽对应变为原来的 1 / inSampleSize ,对应的 bitmap 也缩小为原来的 1/(inSampleSize^2)。同时强调解码器使用(我个人的理解，此处指的是inSampleSize)基于2的幂的最终值，任何其他值都将被舍入到最接近的2的幂次，示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBitmapSize</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"TestBitmapSize"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main2);</span><br><span class="line">        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test_200_200);</span><br><span class="line">        Log.i(TAG, <span class="string">"onCreate: originBitmap "</span> + bitmap.getByteCount());</span><br><span class="line">        Bitmap sampledBitmap = decodeSampledBitmapFromResource(getResources(), R.drawable.test_200_200, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">        Log.i(TAG, <span class="string">"onCreate: sampledBitmap "</span> + sampledBitmap.getByteCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeSampledBitmapFromResource</span><span class="params">(Resources res, <span class="keyword">int</span> resId, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查bitmap的大小</span></span><br><span class="line">        <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        <span class="comment">// 设置为true，BitmapFactory会解析图片的原始宽高信息，并不会加载图片</span></span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算采样率</span></span><br><span class="line">        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置为false，加载bitmap</span></span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateInSampleSize</span><span class="params">(BitmapFactory.Options options, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width = options.outWidth;</span><br><span class="line">        <span class="keyword">int</span> height = options.outHeight;</span><br><span class="line">        Log.i(TAG, <span class="string">"calculateInSampleSize: out width and height is "</span> + width + <span class="string">" height "</span> + height);</span><br><span class="line">        <span class="keyword">int</span> inSampleWidth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class="line">            <span class="keyword">int</span> halfHeight = height / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 采样率设置为2的指数</span></span><br><span class="line">            <span class="keyword">while</span> ((halfHeight / inSampleWidth) &gt;= reqHeight &amp;&amp; (halfWidth / inSampleWidth) &gt;= reqWidth) &#123;</span><br><span class="line">                inSampleWidth *= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inSampleWidth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过-inBitmap-重用-Bitmap-内存复用"><a href="#通过-inBitmap-重用-Bitmap-内存复用" class="headerlink" title="通过 inBitmap 重用 Bitmap 内存复用"></a>通过 inBitmap 重用 Bitmap 内存复用</h3><p>当需要多次重复创建 Bitmap 的时候，可以考虑使用 inBitmap 实现 Bitmap 的重用。</p>
<p>Bitmap 的复用的前提是，前一个 Bitmap 是可变的 mutable，即我们在设置 BitmapFactory 中 Options 的时候，inMutable 参数设置为true，之后，把前一个 bitmap 设置给 Options的 inBitmap，在后续的 Bitmap 创建时，如果也是使用同一个Options 的话，可以做到复用了。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试bitmap复用</span></span><br><span class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">options.inMutable = <span class="keyword">true</span>;</span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bigbackground, options);</span><br><span class="line"><span class="comment">// 对象内存地址；</span></span><br><span class="line">Log.i(TAG, <span class="string">"bitmap = "</span> + bitmap);</span><br><span class="line">Log.i(TAG, <span class="string">"bitmap：ByteCount = "</span> + bitmap.getByteCount() + <span class="string">":::bitmap：AllocationByteCount = "</span> + bitmap.getAllocationByteCount());</span><br><span class="line"></span><br><span class="line">options.inBitmap = bitmap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的bitmap还是可变的，这个属性可以不设置</span></span><br><span class="line"><span class="comment">// options.inMutable = true;</span></span><br><span class="line">Bitmap bitmapReuse = BitmapFactory.decodeResource(getResources(), R.drawable.smallbackground, options);</span><br><span class="line">Log.i(TAG, <span class="string">"onCreate: isMutable"</span> + bitmapReuse.isMutable());</span><br><span class="line"><span class="comment">// 复用对象的内存地址；</span></span><br><span class="line">Log.i(TAG, <span class="string">"bitmapReuse = "</span> + bitmapReuse);</span><br><span class="line">Log.i(TAG, <span class="string">"bitmapReuse：ByteCount = "</span> + bitmapReuse.getByteCount() + <span class="string">":::bitmapReuse：AllocationByteCount = "</span> + bitmapReuse.getAllocationByteCount());</span><br></pre></td></tr></table></figure>

</details>

<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/liu_12345_liu/article/details/109012867" target="_blank" rel="noopener">CSDN上的博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-Java基础</title>
    <url>/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="1、Java-多态"><a href="#1、Java-多态" class="headerlink" title="1、Java 多态"></a>1、Java 多态</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>多态存在的三个必要条件：一、要有继承关系  二、要重写方法 三、父类指向子类对象。</p>
<p>多态就是指允许不同类的对象(如：父类的多个子类)，对同一消息做出不同响应(同一个函数调用在不同子类中的行为不同)。</p>
<p>多态的实现：动态绑定(dynamic binding),即在执行期间判断所引用的对象的实际类型，根据实际类型再调用相应方法。</p>
<p>Java 中多态的表现：接口的实现、继承父类进行方法重写 以及 同一个类中进行方法重载。</p>
<blockquote>
<p>以上内容参考自： <a href="http://www.jackywang.tech/AndroidInterview-Q-A/interview/java%E5%A4%9A%E6%80%81-%E4%B9%90%E8%A7%86.html" target="_blank" rel="noopener">Java多态</a></p>
</blockquote>
</details><a id="more"></a>

<p><strong>Java集合</strong></p>
<h2 id="2、ArrayList-与-LinkedList的区别"><a href="#2、ArrayList-与-LinkedList的区别" class="headerlink" title="2、ArrayList 与 LinkedList的区别"></a>2、ArrayList 与 LinkedList的区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>ArrayList的特点：</p>
<ul>
<li>以数组实现，初始空间是10，节约空间    </li>
<li>有容量限制，当超出限制时，新增50%容量，即容量变为原来的1.5倍，如果还不够，则直接扩充为需求值，之后将原来数据拷贝到新的空间中，比较耗时        </li>
<li>按照数组下标访问元素——get(i)/set(i,e) 性能很高    </li>
<li>按照下标插入、删除元素，需要移动受影响的元素，性能就会变差(remove操作可以理解为删除index为0的节点，并将后面的元素移到0处)    </li>
</ul>
<p>LinkedList的特点：</p>
<ul>
<li>以双向链表实现，链表无容量限制，但是双向链表本身使用了更多空间    </li>
<li>按下标访问元素——get(i)/set(i,e)，要遍历链表将指针移动到位(如果i&gt;链表的一半，会从末尾开始移动)    </li>
<li>插入、删除元素时，只需要修改前后节点的指针即可。但如果是指定位置插入和删除，则还是需要遍历部分链表的指针才能移动到下标所指的位置。如果只是在链表两头的操作就能省掉指针的移动。 </li>
</ul>
<blockquote>
<p>参考链接：<a href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/arraylist.html" target="_blank" rel="noopener">ArrayList</a>、<a href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/linkedlist.html" target="_blank" rel="noopener">LinkedList</a>) </p>
</blockquote>
</details>

<h2 id="3、HashMap"><a href="#3、HashMap" class="headerlink" title="3、HashMap"></a>3、HashMap</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>根据官方描述，HashMap 基于 Map 接口实现，<strong>允许null 键/值</strong>，非同步、不保证有序(比如插入顺序)、顺序可能会随时间变化。</p>
<h3 id="两个重要的参数"><a href="#两个重要的参数" class="headerlink" title="两个重要的参数"></a>两个重要的参数</h3><p>容量(Capacity)就是bucket大小，负载因子(Load factor)就是bucket填满程度的最大比例。若对迭代性能要求高，则capacity不宜设置过大，同时load factor也不宜设置过小；当buckets的数目大于 capacity * load factor 时，就需要调整buckets 的大小为当前的2倍。</p>
<h3 id="hashMap的put函数实现"><a href="#hashMap的put函数实现" class="headerlink" title="hashMap的put函数实现"></a>hashMap的put函数实现</h3><ol>
<li>对key的hashCode 做hash，然后计算index；    </li>
<li>如果没有碰撞直接放到bucket里；    </li>
<li>如果碰撞了，以链表的形式存在buckets 后；    </li>
<li>如果碰撞导致链表过长，<strong>达到某个阈值后，则把链表转换成红黑树</strong>；    </li>
<li>如果节点已经存在，就替换 old value (保证key的唯一性)；    </li>
<li>如果bucket满了，就要resize；    </li>
<li>注意，<strong>插入元素采用头插法，因为HashMap的发明者认为，后插入的Entry被查找的可能性更大</strong>。</li>
</ol>
<h3 id="get函数的实现"><a href="#get函数的实现" class="headerlink" title="get函数的实现"></a>get函数的实现</h3><ol>
<li>bucket里第一个节点，则直接命中；    </li>
<li>如果有冲突，则通过 key.equals(k) 方式去查找对应的 entry。    </li>
</ol>
<blockquote>
<p>若为树，则树中通过key.equals查找，时间复杂度为 O(logn);<br>若为链表，则链表中通过key.equals查找，时间复杂度为 O(n)。</p>
</blockquote>
<h3 id="hashmap细节"><a href="#hashmap细节" class="headerlink" title="hashmap细节"></a>hashmap细节</h3><ul>
<li>hashmap的初始长度是16，并且手动初始化或者每次自动扩展时，<strong>长度必须是2的幂</strong>。</li>
</ul>
<p>这里主要强调是2的幂，至于为什么是16，主要是为了让key到index的映射更加均匀。前面提到，index = Hash(key) ，如何实现一个尽量分布均匀地hash函数。有人说可以通过求余的方式： index = hashCode(key) % length ，不过求余的方式虽然简单，但是效率不高，Hashmap中采用了位运算方式，其公式为：</p>
<blockquote>
<p>index = hashCode(key) &amp; (length - 1)</p>
</blockquote>
<p>以具体例子来说，假如某个key 的 hashCode(二进制) = 101110001110101110 1001，hashmap的默认长度length = 16 ，则 length - 1 为15，二进制数据为 1111，把两个二进制数据做位与操作得到 1001,即十进制的 9 ，所以index = 9。<strong>所以这里，index的结果完全取决于hashCode的最后4位(当然，java8中，会将这个hashCode的高16位不变，低16位和高16位做异或操作作为低16位的值，之后才与 length -1 做位与，这样避免只有低4位是有效位，从而进一步降低碰撞，因为参与的位数多了)</strong>。</p>
<p>所谓为什么要是2的幂，也即如果不是2的幂会怎样？比如hashMap的长度是 10，还是以上面的例子：hashCode(二进制) = 101110001110101110 1001，length - 1 = 9 ，即 1001，则index 也还会是1001(因为hashCode的后4位也是1001)，单独看这里没什么问题，但是从此我们可以推断：如果hashCode的后 4 位是 1001、1101、1111，1101等等，它们的结果都会是 1001，<strong>因为相当于只有第1位和第4位在起作用，这不符合index均匀分布的要求。那如果是2的幂呢？则length - 1后，所有的位数都是1，则每位都会起作用</strong>。</p>
<p>Hashmap的容量是有限的，当容量达到一定的饱和度的时候，Key映射位置发生碰撞的概率会上升，这好理解，因为如果每个坑都差不多有entry在了，无论你index是多少，都会碰撞，所以元素越多，越容易发生碰撞。java中的条件是 : hashmap.size &gt;= capacity * load factor 的时候，就需要resize，需要经历两个步骤，1、扩容，创建一个新的Entry数组，长度是以前的2倍，2、ReHash，遍历原来的 Entry数组，把所有的Entry 重新hash到新的数组，<strong>因为数组长度变化了，hash的规则也会改变，所以需要rehash</strong>。这里不需要重新计算hash，只需要判断原来的hash值新增的那位是0 还是1，如果是0的话，索引还是没变化，如果是1，则索引变成 “原索引 + oldCapacity”。</p>
<p>举个例子拉说，如果以前的capacity 是 8，则resize后变成16，以前的length - 1 为 111 现在则变成了 1111，多了一个有效位，所以只要判断 hashCode 的对应新增的那位的值是0还是1了，0的话，整个index还是不变，1的话，就在index的基础上加上老的容量 8 即可。</p>
<ul>
<li><p>前面提到，key和value都可能为null，如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中。</p>
</li>
<li><p>Hashmap的线程不安全如何体现？</p>
</li>
</ul>
<ol>
<li>如果多个线程同时使用put添加元素，如果发生碰撞，最终只有一个线程值被保存，因为另一个的会被覆盖。    </li>
<li>由于resize操作存在，hashmap在多线程的情况下，可能会出现死循环，具体参考：<a href="https://zhuanlan.zhihu.com/p/31614195" target="_blank" rel="noopener">小灰的解释</a></li>
</ol>
</details>

<blockquote>
<p>参考链接： <a href="https://zhuanlan.zhihu.com/p/31610616" target="_blank" rel="noopener">知乎链接</a>、<a href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/hashmap.html" target="_blank" rel="noopener">hashmap介绍链接</a></p>
</blockquote>
<h2 id="4、HaShMap-链表元素到达8的时候转红黑树的若干问题"><a href="#4、HaShMap-链表元素到达8的时候转红黑树的若干问题" class="headerlink" title="4、HaShMap 链表元素到达8的时候转红黑树的若干问题"></a>4、HaShMap 链表元素到达8的时候转红黑树的若干问题</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先，得满足两个条件才会转红黑树：一个是链表长度到8,一个是数组长度到64  </p>
<p>为什么到8才转成红黑树？首先根据统计节点数&gt;=8概率是很小的(千分之一)，并且到8的时候，会引起性能下降，且因为转红黑树消耗性能，所以到 8 才转。  </p>
<p>会根据红黑树状态以及红黑树节点总数到6这个阈值来将红黑树退回链表，这主要是是因为 8 和 6 这两个数字相差2，不至于插入删除一个元素导致来回转换</p>
<p>为什么不一开始就采用红黑树？因为红黑树是有额外的空间开销的，并且红黑树涉及左旋右旋等操作(我自己臆测的，也没看到有好的说法)</p>
</details>

<blockquote>
<p>以上问题参考自<a href="https://blog.csdn.net/g5zhu5896/article/details/82968287" target="_blank" rel="noopener">hashmap转红黑树的两个条件
</a>、<a href="https://blog.csdn.net/baidu_37147070/article/details/98785367" target="_blank" rel="noopener">HashMap的问题</a>、<a href="https://www.cnblogs.com/misscai/p/13234177.html" target="_blank" rel="noopener">cnblogs的博客</a>、</p>
</blockquote>
<h2 id="5、HashTable"><a href="#5、HashTable" class="headerlink" title="5、HashTable"></a>5、HashTable</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>HashTable 类似于HashMap ，它同样基于hash表实现，每个元素也是key-value 对，也是通过单链表解决冲突，容量不足时，也会resize，二者区别是：</p>
<ol>
<li>HashTable 的key和Value 都不能为null，而HashMap允许。    </li>
<li>HashTable 默认大小是 11，扩容方式是 old*2 + 1,而HashMap 默认大小是16，要求数组大小是2的幂，扩容时，直接扩为2倍。    </li>
<li>获取index的方式不一样，Hashtable 采用除余的方式，而HashMap采用 位与的方式，效率更高。    </li>
<li>HashTable 保证方法调用的线程安全，因为在每个方法前都有synchronize 关键字。而HashMap 没有，因此在线程安全条件下效率更高。</li>
</ol>
<blockquote>
<p>上文的<a href="https://zhuanlan.zhihu.com/p/24338517" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
</details>

<h2 id="6、ConcurrentHashMap"><a href="#6、ConcurrentHashMap" class="headerlink" title="6、ConcurrentHashMap"></a>6、ConcurrentHashMap</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>想要避免HashMap 的线程安全问题有很多办法，比如采用 HashTable 或者 Collections.synchronizedMap ，<strong>但是这两者有共同的问题：性能，因为无论是读还是写操作，它们都会给整个集合加锁，导致同一时间的其他操作阻塞</strong>。如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E9%9B%86%E5%90%88/HashTable%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E8%AF%BB%E5%86%99.jpg" alt="阻塞其他操作"></p>
<p>此时，ConcurrentHashMap应运而生，理解 ConcurrentHashMap 关键要理解一个概念： Segment 。Segment 本身就相当于一个 HashMap 对象，Segment 包含一个HashEntry 数组，数组中每个 HashEntry 既是一个键值对，也是一个链表的头结点，如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E9%9B%86%E5%90%88/%E5%8D%95%E4%B8%80segment.jpg" alt="单一segment结构"></p>
<p>这样的Segment 在ConcurrentHashMap 中有2 的N 次方个，共同保存在一个名为 segments 的数组中。因此，整个 ConcurrentHashMap 的结构如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E9%9B%86%E5%90%88/ConcurrentHashMap%E7%BB%93%E6%9E%84.jpg" alt="ConcurrentHashMap结构"></p>
<p>这个二级结构，和数据库的水平拆分有些相似。采取这样的结构就是<strong>锁分段技术</strong>，每个segment 就好比一个自治区，读写操作互不影响。所以，ConcurrentHashMap 操作会有以下几种可能性：</p>
<ul>
<li>不同Segment 可以并发写入。    </li>
<li>同一 Segment 可以同时读和写。     </li>
<li>同一个 Segment 并发写入时，只有一个线程可以执行，其他的线程阻塞。因为 Segment 的写入会加锁。    </li>
</ul>
<p>通过以上分析我们知道，ConcurrentHashMap 中每个 Segment 各自持有一把锁。在保证线程安全的情况下，降低了锁的粒度，让并发操作效率更高。</p>
<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><ol>
<li>为输入的key做 Hash 运算，得到hash值。    </li>
<li>通过hash值，定位到对应的 Segment 对象。    </li>
<li>再次通过 hash 值，定位到 Segment 中数组的具体位置。    </li>
</ol>
<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><ol>
<li>为输入的key 做Hash 运算，得到hash 值。    </li>
<li>通过hash值，定位到 Segment 对象。    </li>
<li>获取可重入锁。     </li>
<li>再次通过 hash 值，定位到 Segment 当中的具体位置。    </li>
<li>插入或者覆盖 HashEntry 对象。    </li>
<li>释放锁。     </li>
</ol>
<h3 id="size-方法"><a href="#size-方法" class="headerlink" title="size 方法"></a>size 方法</h3><p>获取 ConcurrentHashMap 总元素数量，自然要把各个 Segment 的元素汇总起来，但是如果在统计过程中，已经统计过的 Segment 瞬间插入新的元素，这时候怎么办呢？其实，这个size调用过程的大体逻辑如下：</p>
<ol>
<li>遍历所有 Segment。    </li>
<li>把 Segment 的元素数量累加。    </li>
<li>把 Segment 的修改次数累加起来。    </li>
<li>判断所有Segment 的总修改次数是否大于上一次的修改次数，如果大于，说明统计过程中有修改，重新统计，同时尝试次数 +1；否则，说明没有修改，统计结束。     </li>
<li>如果尝试次数超过阈值，则对每一个Segment 加锁，再重新统计。    </li>
<li>此时，统计的结果肯定正确，统计结束，释放锁。   </li>
</ol>
<p>为了尽量不锁住所有的Segment ，首先乐观假设Size过程中不会有修改，当尝试一定次数后，才无奈转换为悲观锁。</p>
<blockquote>
<p>以上文章参考<a href="https://zhuanlan.zhihu.com/p/31614308" target="_blank" rel="noopener">小灰的分析</a> </p>
</blockquote>
</details>

<h2 id="7、HashMap-、-HashTable-和-ConcurrentHashMap-的区别？"><a href="#7、HashMap-、-HashTable-和-ConcurrentHashMap-的区别？" class="headerlink" title="7、HashMap 、 HashTable 和 ConcurrentHashMap 的区别？"></a>7、HashMap 、 HashTable 和 ConcurrentHashMap 的区别？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<p>HashTable 是 HashMap 的线程安全实现，但是 HashTable在竞争激烈时效率低下，因为访问所有 HashTable 的线程都竞争同一把锁。ConcurrentHashMap 采用锁分段技术，将数据一段段存储，每段一把锁，当两个线程访问不同段数据时不受干扰，当然，contentValue和size等方法需要了解整体数据的情况下，还需要锁住整个表。</p>
</blockquote>
</details>

<h2 id="8、LinkedHashMap"><a href="#8、LinkedHashMap" class="headerlink" title="8、LinkedHashMap"></a>8、LinkedHashMap</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>LinkedHashMap 是Hash表和链表的实现，并且保存了记录的插入顺序。因为LinkedHashMap里面的Entry比HashMap多了两个字段：after和before，而以前的HashMap中的next 字段没有变化，从而额外构成一个双向链表，当然就可以在keySet()时按插入顺序输出，LinkedHashMap结构如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E9%9B%86%E5%90%88/LinkedHashMap%E5%8E%9F%E7%90%86.png" alt="LinkedHashMap原理"></p>
<p>与HashMap的区别：1、保存了记录的插入顺序，遍历的时候，首先打印最先插入的记录。2、遍历的时候比HashMap慢，因为LinkedHashMap 遍历链表，而HashMap可以说是根据capacity 遍历链表。不过如果HashMap容量很大并且实际数据比较少的情况下，遍历起来可能比LinkedHashMap慢。3、HashMap的遍历速度和容量有关，而LinkedHashMap 遍历速度只和实际数据有关。</p>
<blockquote>
<p>以上内容参考<a href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/LinkedHashMap.html" target="_blank" rel="noopener">这个链接</a>，从<a href="https://www.zhihu.com/question/278676747" target="_blank" rel="noopener">知乎这个问题</a>得到了灵感，忽然想明白了这个结构。</p>
</blockquote>
</details>

<h2 id="9、WeakHashMap"><a href="#9、WeakHashMap" class="headerlink" title="9、WeakHashMap"></a>9、WeakHashMap</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>WeakHashMap，从名字可以看出它是某种 Map。它的特殊之处在于 WeakHashMap 里的entry可能会被GC自动删除，即使程序员没有调用remove()或者clear()方法。</p>
<p>更直观的说，当使用 WeakHashMap 时，即使没有显示的添加或删除任何元素，也可能发生如下情况：</p>
<blockquote>
<ul>
<li>调用两次size()方法返回不同的值；    </li>
</ul>
</blockquote>
<ul>
<li>两次调用isEmpty()方法，第一次返回false，第二次返回true；    </li>
<li>两次调用containsKey()方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；    </li>
<li>两次调用get()方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。    </li>
</ul>
<p>遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉？其实不然，WeekHashMap 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。</p>
<blockquote>
<p>以上内容参考 <a href="https://zhuanlan.zhihu.com/p/24887482" target="_blank" rel="noopener">知乎的大神</a></p>
</blockquote>
</details>

<h2 id="10、TreeMap"><a href="#10、TreeMap" class="headerlink" title="10、TreeMap"></a>10、TreeMap</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>HashMap不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了。从官方的描述来看：</p>
<blockquote>
<p>A Red-Black tree based {@link NavigableMap} implementation.The map is sorted according to the {@linkplain Comparable natural ordering} of its keys, or by a {@link Comparator} provided at map creation time, depending on which constructor is used.</p>
</blockquote>
<p>TreeMap 是一个红黑树结构，每个key-value都作为一个红黑树的节点。它根据 key 排序(Comparable自然排序)，但假如 key 没有实现 Comparable 接口，还可以通过构造函数中传入的 Comparator 来自定义比较。并且它还间接实现了 SortedMap 接口，因此它是有序的集合。</p>
<p>使用红黑树的好处是能够使得树具有不错的平衡性，这样操作的速度就可以达到log(n)的水平了。</p>
<p>关于<strong>根据 key 排序</strong>这个表述，可能直接看代码更容易懂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        cmp = cpr.compare(key, t.key);</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">            </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>省略了很多代码，如果有自定义的 comparator，则使用自定义的 comparator 比较；否则，将 Key 强转为 Comparable 类型，再做比较。当然，这个Key肯定不能为null，此外，官方也说明了，如果Key不是 Comparable 类型的，就会抛出 ClassCastException 异常。</p>
<blockquote>
<p>以上文章参考<a href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/treemap.html" target="_blank" rel="noopener">java集合-TreeMap</a>、<a href="https://my.oschina.net/90888/blog/1626065" target="_blank" rel="noopener">oschina链接</a> 还有<a href="https://www.cnblogs.com/CarpenterLee/p/5503882.html" target="_blank" rel="noopener">这个大牛</a></p>
</blockquote>
</details>

<h2 id="11、Java泛型"><a href="#11、Java泛型" class="headerlink" title="11、Java泛型"></a>11、Java泛型</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Java 泛型主要关注几点：</p>
<h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><p>顾名思义就是匹配任意类型。如如下写法：List&lt;?&gt; list  ;</p>
<h3 id="带限通配符"><a href="#带限通配符" class="headerlink" title="带限通配符"></a>带限通配符</h3><p><font color="ff0000">上限通配符：</font>使用extends 关键字指定这个类型必须继承某个类或者实现某个接口，也可以是该类(接口)本身。如： List&lt;? extends Shape&gt;  ，表示集合中所有元素都是Shape 类型或者它的子类。</p>
<p><font color="ff0000">下限通配符：</font>使用super 关键字指定这个类型必须是某个类的父类，或者某个接口的父接口，也可以是这个类本身。如：List&lt;? super Circle&gt; ，表示集合中所有元素都是Circle 类型或者是其父类。</p>
<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><blockquote>
<p>Class c1=new ArrayList<integer>().getClass();<br>Class c2=new ArrayList<string>().getClass();<br>System.out.println(c1==c2);</string></integer></p>
</blockquote>
<p>输出 true ，也就是说编译后的class文件中不会包含任何泛型信息，泛型信息不会进入到运行时阶段。</p>
<p>由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类</p>
<blockquote>
<p>以上内容参考自<a href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/genericity.html" target="_blank" rel="noopener">Java泛型</a></p>
</blockquote>
</details>

<h2 id="12、Java抽象类和接口的区别"><a href="#12、Java抽象类和接口的区别" class="headerlink" title="12、Java抽象类和接口的区别"></a>12、Java抽象类和接口的区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>abstract class和interface是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。 </p>
<p>abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于 abstract class和interface的选择显得比较随意。</p>
<p>但是，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。</p>
<p>总结：</p>
<ul>
<li>设计理念上，接口反映的是”like-a”关系，抽象类反映的是”is-a”关系，即接口表示这个对象能做什么，抽象类表示的是这个对象是什么(想象一下，人可以吃东西，狗也能吃东西，接口反映的是吃东西这个动作，而抽象类能反映的，可能就是人这个物种)。    </li>
<li>抽象类与接口都不能直接实例化。    </li>
<li>抽象类被子类继承，接口被子类实现。    </li>
<li>接口中定义的变量只能是公共的静态常量(即 public static final)，抽象类中是普通变量。    </li>
<li>抽象类中可以没有抽象方法，接口中可以没有方法，但是有方法一定要有抽象方法。    </li>
<li>接口可以被类多实现(类可以实现多个接口)，抽象类只能被单继承。    </li>
<li>接口中没有this 指针，没有构造函数，不能拥有实例变量或实例方法。   </li>
</ul>
<p>关于接口，再多啰嗦几句：</p>
<ul>
<li>接口用于描述系统对外提供的服务，因此接口中的成员变量和方法都必须公开(public)，确保所有使用者能访问。     </li>
<li>接口仅描述系统能做什么，但不指名如何做，因此所有方法都是抽象(abstract)方法。     </li>
<li>接口不涉及任何具体实例(this关键字)的相关细节，因此接口没有构造方法，没有实例变量，只有静态(static)变量。      </li>
<li>接口中的变量是所有实现类公有的，既然公有，肯定是不变的东西，所以变量是不可变(final)的。    </li>
</ul>
<p>通俗讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中。接口对修改关闭，对扩展开放，是开闭原则的体现。</p>
<blockquote>
<p>以上内容参考自：<a href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/abstract_interface.html" target="_blank" rel="noopener">Java抽象类和接口的区别</a>、<a href="https://www.cnblogs.com/lanxuezaipiao/p/3371224.html" target="_blank" rel="noopener">程序媛想事</a></p>
</blockquote>
</details>

<h2 id="13、Java-transient关键字"><a href="#13、Java-transient关键字" class="headerlink" title="13、Java transient关键字"></a>13、Java transient关键字</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Java序列化时，transient关键字用于属性前时，该属性就不会被序列化。它的使用可以总结为下面几点：</p>
<ul>
<li>变量被 transient 修饰时，变量将不会是对象持久化的一部分。    </li>
<li>transient 只能修饰变量而不能修饰方法和类，并且也不能修饰本地变量。    </li>
<li>静态变量不管是否被 transient 修饰，均不能被序列化。    </li>
</ul>
<p>附：父类实现了Serializable，子类没有，<br>父类有int a = 1、int b = 2、int c = 3<br>子类有int d = 4、int e = 5<br>序列化子类的时候，d和e会不会被序列化？（答案：会）</p>
<p>反过来父类未实现Serializable，子类实现了，序列化子类实例的时候，父类的属性是直接被跳过不保存，还是能保存但不能还原？（答案：值不保存）</p>
<blockquote>
<p>以上内容参考自：<a href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/transient.html" target="_blank" rel="noopener">Java transient关键字</a></p>
</blockquote>
</details>

<h2 id="14、Java-finally与return执行顺序"><a href="#14、Java-finally与return执行顺序" class="headerlink" title="14、Java finally与return执行顺序"></a>14、Java finally与return执行顺序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先探讨下，try-catch-finally 块中的语句是否一定被执行？答案是否定的，原因有2个：</p>
<ul>
<li>如果try 语句没有被执行(比如在try 之前就return 了)，finally就不会执行。    </li>
<li>如果try 块中有 System.exit(0)这样的终止Java 虚拟机的语句的话，finally就不会执行。这可以理解，连JVM 都停止了，啥都没有了。</li>
</ul>
<p>关于finally 与return 的执行顺序，过程比较复杂，可以分为如下情况：</p>
<ul>
<li>正常情况下，finally 语句在return 语句执行之后，return 返回之前执行的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(test11());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"try block"</span>);</span><br><span class="line">           <span class="keyword">return</span> test12();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">"finally block"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test12</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"return statement"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"after return"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会输出：</p>
<blockquote>
<p>try block<br>return statement<br>finally block<br>after return     </p>
</blockquote>
<p>可以看出，try 中的return语句先执行了，但是值没有立即返回，等finally执行结束后再返回值。</p>
<ul>
<li>如果finnaly 块中有return 语句会覆盖 try 中的 return  返回。    </li>
<li>如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变(int 类型和 Map 类型)。     </li>
<li>try 块里的return 语句在异常情况下不会执行，怎么返回看情况。    </li>
</ul>
<blockquote>
<p>以上内容参考自：<a href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/finally-return.html" target="_blank" rel="noopener">Java finally与return执行顺序</a></p>
</blockquote>
</details>

<h2 id="15、两个对象的-hashcode-相同，是否对象相同？equal-相同呢？"><a href="#15、两个对象的-hashcode-相同，是否对象相同？equal-相同呢？" class="headerlink" title="15、两个对象的 hashcode 相同，是否对象相同？equal() 相同呢？"></a>15、两个对象的 hashcode 相同，是否对象相同？equal() 相同呢？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<blockquote>
<ol>
<li>hashCode是所有java对象的固有方法，默认返回的是该对象在jvm的堆上的内存地址，不同对象的内存地址肯定不同，所以这个hashCode也就肯定不同了。如果重载了的话，由于采用的算法的问题，有可能导致两个不同对象的hashCode相同。</li>
<li>hashCode和equals两个方法是有语义关联的，它们需要满足：<br>A.equals(B)==true –&gt; A.hashCode()==B.hashCode()，但是反之不能说hashcode相等就equals<br>因此重载其中一个方法时也需要将另一个也重载。</li>
<li>此外，请注意：hashCode的重载实现最好依赖于对象中的final属性，从而在对象初始化构造后就不再变化。一方面是jvm便于代码优化，可以缓存这个hashCode；另一方面，在使用hashMap或hashSet的场景中，如果使用的key的hashCode会变化，将会导致bug，比如放进去时key.hashCode()=1，等到要取出来时key.hashCode()=2，就取不出来数据了。<br>综上所述，hashCode相同或者equals相同并不能说明对象相同。</li>
</ol>
</blockquote>
</details>

<h2 id="16、延伸-Java-中-hashcode-的作用"><a href="#16、延伸-Java-中-hashcode-的作用" class="headerlink" title="16、延伸-Java 中 hashcode 的作用"></a>16、延伸-Java 中 hashcode 的作用</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>官方文档的定义就是：</p>
<blockquote>
<p>hashcode 方法返回对象的哈希码值，支持该方法主要是为了支持基于哈希机制的Java 集合类，如HashMap、HashSet、HashTable 等。</p>
</blockquote>
<p>hashcode的常规约定是：</p>
<blockquote>
<p>Java程序运行期间，同一个对象上多次调用 hashcode ，必须一致地返回相同的整数，而从某一应用程序的一次执行到同一程序的另一次执行，该整数无须保持一致。如果两个对象相等，那么两个对象中的每个对象上调用 hashcode 方法都必须生成相同的整数结果。</p>
</blockquote>
<blockquote>
<p>以上内容参考自：<a href="https://www.cnblogs.com/ouym/p/8963219.html" target="_blank" rel="noopener">OUYM</a></p>
</blockquote>
</details>

<h2 id="17、延伸-为什么重写了equals-方法，要求必须重写hashcode-方法？"><a href="#17、延伸-为什么重写了equals-方法，要求必须重写hashcode-方法？" class="headerlink" title="17、延伸-为什么重写了equals 方法，要求必须重写hashcode 方法？"></a>17、延伸-为什么重写了equals 方法，要求必须重写hashcode 方法？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>根据前面的内容，总结就是：为了满足常规约定-如果两个equals 满足，就一定要求返回相同的 hashcode。举个例子，如果重写了 equals 方法，对象中 num 和data 参与了equals 比较，那么 num 和data 也要参与生成hashcode，这是为了遵守上述约定。</p>
</details>

<h2 id="18、生成hashcode-注意的事项"><a href="#18、生成hashcode-注意的事项" class="headerlink" title="18、生成hashcode 注意的事项"></a>18、生成hashcode 注意的事项</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>返回的hash值是int型，防止溢出    </li>
<li>不同对象返回的hash值尽量不同(为了hashmap 等集合减少碰撞)     </li>
<li>无论何时，对同一个对象调用hashcode()都应该产生同样的值     </li>
</ul>
<p><strong>最后一点是很重要的，也是容易出隐形bug的地方，如果将一个对象put() 到HashMap 时产生了一个 hashcode 值，而 get() 取出时却产生了另外一个hashcode，那么就无法获取该对象了。所以，如果hashcode() 方法依赖于对象中易变的数据，那就要当心了。</strong></p>
<blockquote>
<p>以上内容参考自：<a href="https://www.cnblogs.com/ouym/p/8963219.html" target="_blank" rel="noopener">OUYM</a></p>
</blockquote>
</details>

<h2 id="19、下面代码输出的结果？"><a href="#19、下面代码输出的结果？" class="headerlink" title="19、下面代码输出的结果？"></a>19、下面代码输出的结果？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目1</span></span><br><span class="line">String str1 = <span class="string">"hello"</span>;</span><br><span class="line">String str2 = <span class="string">"he"</span> + <span class="keyword">new</span> String(<span class="string">"llo"</span>);</span><br><span class="line">System.err.println(str1 == str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//答案是false，因为str2中的llo是新申请的内存块，而==判断的是对象的地址而非值，所以不一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//题目2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pong();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t.run();</span><br><span class="line">        System.out.print(<span class="string">"ping"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"pong"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//输出 pongping ，这里调用的是Thread 的run 方法，与普通方法是一样的，失去线程的特性了。因此我们要启动新县城执行的时候，需要使用Thread 的 start() 方法。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//题目3，如下代码是否能正常运行？</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NULL</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"haha"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ((NULL)<span class="keyword">null</span>). test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//能正常运行，输出 haha 。首先，null 值可以强转成任何 Java 类型，所以 (NULL)null 、(String)null 等都是合法的。其次，test 方法是static 方法，只和类名绑定，不借助对象进行访问。综上，能正常输出。反之，如果 test 非static ，就只能使用对象访问，这时候使用null对象肯定会报空指针。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//题目4，如何输出</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    People father;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        father = <span class="keyword">new</span> People(name + <span class="string">":F"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会输出132，在Java 中，子类的构造过程中必须调用其父类的构造函数，因为有继承关系存在，子类要把父类的内容继承下来。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//题目5，如何输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123; </span><br><span class="line">        System.out.println(<span class="string">"I'm A class"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">"static A"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloB</span> <span class="keyword">extends</span> <span class="title">HelloA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123; </span><br><span class="line">        System.out.println(<span class="string">"I'm B class"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">"static B"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------main start-------"</span>);</span><br><span class="line">        <span class="keyword">new</span> HelloB();</span><br><span class="line">        <span class="keyword">new</span> HelloB();</span><br><span class="line">        System.out.println(<span class="string">"-------main end-------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会输出如下结果：</span></span><br><span class="line"><span class="keyword">static</span> A</span><br><span class="line"><span class="keyword">static</span> B</span><br><span class="line">-------main start-------</span><br><span class="line">I<span class="string">'m A class</span></span><br><span class="line"><span class="string">HelloA</span></span><br><span class="line"><span class="string">I'</span>m B <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">HelloB</span></span></span><br><span class="line"><span class="class"><span class="title">I</span>'<span class="title">m</span> <span class="title">A</span> <span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">HelloA</span></span></span><br><span class="line"><span class="class"><span class="title">I</span>'<span class="title">m</span> <span class="title">B</span> <span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">HelloB</span></span></span><br><span class="line"><span class="class">-------<span class="title">main</span> <span class="title">end</span>-------</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">这个题目很好，考察静态语句块、构造语句块(就只有大括号的那块) 以及 构造函数执行顺序。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">对象初始化顺序：1. 类加载之后，从父类到子类执行被<span class="title">static</span> 修饰的语句； 2.<span class="title">static</span> 执行完毕后，再执行<span class="title">main</span> 方法；  3.如果有语句<span class="title">new</span>自身对象，将从父类到子类执行构造语句块、构造器。</span></span><br></pre></td></tr></table></figure>

</details>

<h2 id="20、延伸-类的初始化步骤"><a href="#20、延伸-类的初始化步骤" class="headerlink" title="20、延伸-类的初始化步骤"></a>20、延伸-类的初始化步骤</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><strong>没有父类的情况：</strong></p>
<ol>
<li>类的静态属性</li>
<li>类的静态代码块</li>
<li>类的非静态属性</li>
<li>类的非静态代码块</li>
<li>构造方法</li>
</ol>
<p><strong>有父类的情况:</strong></p>
<ol>
<li>父类的静态属性</li>
<li>父类的静态代码块</li>
<li>子类的静态属性</li>
<li>子类的静态代码块</li>
<li>父类的非静态属性</li>
<li>父类的非静态代码块</li>
<li>父类构造方法</li>
<li>子类非静态属性</li>
<li>子类非静态代码块</li>
<li>子类构造方法</li>
</ol>
<p>以题目深化理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        counter1 ++;</span><br><span class="line">        counter2 ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getSingleton();</span><br><span class="line">        System.out.println(<span class="string">"counter1 = "</span> + singleton.counter1);</span><br><span class="line">        System.out.println(<span class="string">"counter2 = "</span> + singleton.counter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码将输出：</p>
<blockquote>
<p>counter1 = 1<br>counter2 = 0   </p>
</blockquote>
<p>根据类初始化步骤，由于 Singleton 并没有被加载过，所以首先执行类加载步骤，在“准备”阶段，首先给静态变量赋初默认值：<br>singleton = null<br>counter1 = 0<br>counter2 = 0</p>
<p>加载和连接完毕，再进行初始化工作，依照代码写的顺序依次执行，首先执行 singleton = new Singleton();这样就会执行构造方法的内部逻辑，即此时 counter1 = 1; counter2 = 1;</p>
<p>接下来，由于counter1 只进行了定义，并没有初始化，所以counter1的值仍然为1 ；接下来，counter2 进行了定义并且赋值 0 ，则初始化阶段后，counter2 的值为0；</p>
<p>初始化完毕，要调用Singleton.getSingleton() ，由于singleton 的值已经初始化过，此时直接返回即可。因此输出 counter1 = 1，counter2 = 0。</p>
<p>反之，如果将静态变量初始化的顺序改变下：     </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter1;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure>

<pre><code>则会输出 counter1 = 1，counter2 = 1 了，按照上述推理应该能够理解。</code></pre><blockquote>
<p>以上内容参考自：<a href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&mid=2247483903&idx=1&sn=c20d3172052bd7db9a1ad6a95f112bc9&chksm=96cda0b2a1ba29a4cc9912cb1bf8a955f97ee45a7b8db48e384f1694ddbabbd4d5e7fa90f880&scene=21#wechat_redirect" target="_blank" rel="noopener">码个蛋</a>，同时可以参考以前写的<a href="https://glassx.gitee.io/2019/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC7%E7%AB%A0/">虚拟机的相关文章</a></p>
</blockquote>
</details>

<h2 id="21、constructor-是否一定要与类名同名，方法名是否一定不能与类名同名？"><a href="#21、constructor-是否一定要与类名同名，方法名是否一定不能与类名同名？" class="headerlink" title="21、constructor 是否一定要与类名同名，方法名是否一定不能与类名同名？"></a>21、constructor 是否一定要与类名同名，方法名是否一定不能与类名同名？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>constructor 是一定要与类名同名的，但普通的类方法是可以和类名同名的，它与构造方法唯一的区别就是构造方法没有返回值。</p>
</details>

<h2 id="22、数据溢出与非法数据问题"><a href="#22、数据溢出与非法数据问题" class="headerlink" title="22、数据溢出与非法数据问题"></a>22、数据溢出与非法数据问题</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>存在使i + 1 &lt; i的数吗？答案是肯定的，比如i是int 类型，那么当i 是最大的整数时，i+1就溢出了，就可能&lt; i<br>。</p>
<p>是否存在 i&gt;j || i&lt;= j 不成立？答案是肯定的，比如：Double.NaN 或者 Float.NaN </p>
<blockquote>
<p>以上内容参考自<a href="https://www.cnblogs.com/lanxuezaipiao/p/3371224.html" target="_blank" rel="noopener">程序媛想事</a></p>
</blockquote>
</details>

<h2 id="23、Java-的参数传递"><a href="#23、Java-的参数传递" class="headerlink" title="23、Java 的参数传递"></a>23、Java 的参数传递</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>在讨论之前，首先看下如下代码的输出情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">"good"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] ch = &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Example ex = <span class="keyword">new</span> Example();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.print(ex.str + <span class="string">" and "</span>);</span><br><span class="line">        System.out.print(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String paramA, <span class="keyword">char</span> paramB[])</span> </span>&#123;</span><br><span class="line">        paramA = <span class="string">"test ok"</span>;</span><br><span class="line">        paramB[<span class="number">0</span>] = <span class="string">'g'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码输出good and gbc 。在Java 中没有引用传递，只有值传递，这个值指的是<strong>实参的地址的拷贝</strong>，得到这个值(地址拷贝)后，你<strong>可以通过它修改这个地址的内容，因为此时这个内容的地址和原地址是同一个地址，但是你不能改变这个地址本身使其重新引用到其他对象</strong>。以上的意思说明仅仅只是值传递。具体过程如果使用图示的话，如下所示：</p>
<p>str的传递：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%A0%E9%80%92.png" alt="字符串传递"></p>
<p>在change方法中重新为paramsA 赋值：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%94%B9%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80.png" alt="字符串传递"></p>
<p>ch的传递：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E4%BC%A0%E9%80%92.png" alt="数组传递"></p>
<p>在change方法中更改paramsB 的元素值：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E6%9B%B4%E6%94%B9%E5%80%BC.png" alt="数组更改值"></p>
<blockquote>
<p>以上内容参考自：<a href="https://www.cnblogs.com/lanxuezaipiao/p/3371224.html" target="_blank" rel="noopener">程序媛想事</a>、<a href="https://blog.csdn.net/qq_35109096/article/details/81105320" target="_blank" rel="noopener">RavenXRZ</a></p>
</blockquote>
</details>

<h2 id="24、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"><a href="#24、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？" class="headerlink" title="24、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"></a>24、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</h2><p>查看以前写的<a href="https://glassx.gitee.io/2019/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0/">这篇读书笔记</a>即可</p>
<h2 id="25、String、StringBuilder、StringBuffer、CharSequence-区别"><a href="#25、String、StringBuilder、StringBuffer、CharSequence-区别" class="headerlink" title="25、String、StringBuilder、StringBuffer、CharSequence 区别"></a>25、String、StringBuilder、StringBuffer、CharSequence 区别</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>CharSequence 是一个接口，String、StringBuilder、StringBuffer 都实现了这个接口，它们三个的本质都是通过<strong>字符数组</strong>实现的。</p>
<p>StringBuilder、StringBuffer 的char 数组开始的存储空间是16，如果append() 过程中超过这个容量，将会申请新的空间，并把老的数组一起复制过去。</p>
<p>StringBuffer 的每个处理方法都加上了 synchronized 关键字，因此可以说它是线程安全的。</p>
</details>

<h2 id="26、Java-中String-为毛要设计成不可变？"><a href="#26、Java-中String-为毛要设计成不可变？" class="headerlink" title="26、Java 中String 为毛要设计成不可变？"></a>26、Java 中String 为毛要设计成不可变？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="为什么说String-是不可变的"><a href="#为什么说String-是不可变的" class="headerlink" title="为什么说String 是不可变的"></a>为什么说String 是不可变的</h3><p>首先我们看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类使用final 修饰，说明不可继承；存放内容的 value 是个char[]数组，也是final修饰，创建以后就不可改变。说明一下，这个 value 是stack 上的一个引用，数据本身还是在heap堆上。final 修饰value ，只能是说stack 指向的引用地址是不可变的，但是堆里面的数据本身还是可变的！举例理解下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] value=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">int</span>[] another=&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">value = another;<span class="comment">//编译器报错，final不可变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] value=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">value[<span class="number">2</span>]=<span class="number">100</span>;<span class="comment">//这时候数组里已经是&#123;1,2,100&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过以上代码相信就能理解上面描述的意思了。也许有人还认为String是可以变的，并且举例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">"abcd"</span>;</span><br><span class="line">a = <span class="string">"abcdef"</span>;</span><br></pre></td></tr></table></figure>

<p>这其实不是String本身变化，只是变量a指向heap堆的指针发生了变化，而String本身并没有发生变化，示意图如下：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/java%E5%9F%BA%E7%A1%80/String%E9%87%8D%E6%96%B0%E8%B5%8B%E5%80%BC.png" alt="String重新赋值示意图"></p>
<h3 id="为什么要设计成不可变"><a href="#为什么要设计成不可变" class="headerlink" title="为什么要设计成不可变"></a>为什么要设计成不可变</h3><p>首先，先得清楚 final 这个关键字。 final的出现就是为了为了不想改变，而不想改变的理由有两点：设计(安全)或者效率。</p>
<ul>
<li>字符串常量池的需要。String 带有字符串常量池的属性，如果两个字符串one和two都指向 “something” 赋值，它们其实都指向同一个内存地址。这样在大量使用字符串的情况下，可以节省内存空间，提高效率。之所以能实现这个特性，String 的不可变是必要的(如果可变，那么一个改了，所有引用常量池这个string值都会改变)。     </li>
<li>允许String对象缓存HashCode。String 对象的哈希码被频繁使用，比如在HashMap 中。     </li>
<li>其次，为了安全。多线程安全：多个线程同时读一个资源，不会引发竞态条件，但是对资源做写操作就会有危险，这样保证String使用线程安全。url、反射所需要的参数等都是String类型，如果允许改变，会引起安全隐患(比如非法访问：如果String可变，那么可以在安全检测后，修改String值，导致非法访问)。</li>
</ul>
<h3 id="一定是不可变的吗？"><a href="#一定是不可变的吗？" class="headerlink" title="一定是不可变的吗？"></a>一定是不可变的吗？</h3><p>由以上内容可知，String 是通过字符数组实现的，这个字符数组被final 修饰，因此不能重新指向其他内存区域，但是，我们可以针对这块内存区域改变值，即改变这个数组里面的内容，比如将 value[0] 的值由 ‘a’ 改成 ‘b’(当然这个过程要通过反射去实现)。</p>
<h3 id="可能令你疑惑的操作方式"><a href="#可能令你疑惑的操作方式" class="headerlink" title="可能令你疑惑的操作方式"></a>可能令你疑惑的操作方式</h3><p>我们平日开发通常情况下少量的字符串拼接其实没太必要担心，例如:</p>
<blockquote>
<p>String str = “aa”+”bb”+”cc”;</p>
</blockquote>
<p>像这种没有变量的字符串，<strong>编译阶段就直接合成”aabbcc”了，然后看字符串常量池（下面会说到常量池）里有没有，有也直接引用，没有就在常量池中生成</strong>，返回引用。</p>
<p>如果String a = “123”;这种写法是会将 “123” 放入常量池的，但是如果使用 String b = new String(“123”); 则会在堆上分配空间存放。</p>
<p>但是如果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"aaa"</span>;</span><br><span class="line">String str2 = <span class="string">"bbb"</span>;</span><br><span class="line">String str = str1+str2;</span><br></pre></td></tr></table></figure>

<p>则在编译的时候会优化成： StringBuilder sb = StringBuilder(String.valueOf(str1))).append(str2)</p>
<p>如果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line">sb.append(s);</span><br><span class="line">System.out.println(sb.length());</span><br></pre></td></tr></table></figure>

<p>则会输出4，因为如果是null的话，则会拼接 “null”。</p>
<blockquote>
<p>以上内容参考自：<a href="https://blog.csdn.net/qingmengwuhen1/article/details/52175303?utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">qingmengwuheng1</a> 以及 <a href="https://www.cnblogs.com/lanzhi/p/6467072.html" target="_blank" rel="noopener">岚之山</a></p>
</blockquote>
</details>

<h2 id="27、成员内部类、静态内部类、局部内部类和匿名内部类的理解"><a href="#27、成员内部类、静态内部类、局部内部类和匿名内部类的理解" class="headerlink" title="27、成员内部类、静态内部类、局部内部类和匿名内部类的理解"></a>27、成员内部类、静态内部类、局部内部类和匿名内部类的理解</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类定义在另一个类的内部，它是依赖外部类而存在的，<strong>也就是说如果要创建内部类的对象，前提是必须存在一个外部类的对象</strong>，以下是两种内部类使用情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">haha</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//典型用法：在当前外部内中直接使用内部类</span></span><br><span class="line">        InnerClass innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//非典型用法：使用某个类的内部类</span></span><br><span class="line">        OutBean outBean = <span class="keyword">new</span> OutBean();</span><br><span class="line">        OutBean.InnerBean = outBean.new InnerBean();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OutBean</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerBean</span></span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意代码中典型用法和非典型用法成员内部类对象的创建，说明了内部类对象的创建是依赖于外部类对象的，尤其是： outBean.new InnerBean() 这种写法。</p>
<p>成员内部类可以用private、protected、public 及包访问权限修饰，如果成员内部类被private修饰，则只能在外部内的内部访问；如果使用public修饰，则任何地方都能访问；<strong>如果使用protected修饰，则只能在同一个包下，或者继承外部类的情况下访问</strong>；如果是默认访问权限，则只能在同一个包下访问。</p>
<p>成员内部类可以无条件访问外部类所有的成员属性和方法(包括private的和static的)，不过如果内部类和外部类有相同名称的变量或者方法时，优先访问内部类自己的，如果要访问外部类的可以如下写法：</p>
<blockquote>
<p>外部类.this.成员变量(方法)</p>
</blockquote>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于它的访问尽心阿玉方法内或者作用域内。由于类似于局部变量，所以并不能有 public、protected、private 或者 static 修饰符的。示例如如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;<span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类我们使用很多，比如在实现点击监听的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">btnOk.setOnclickListener(<span class="keyword">new</span> OnclickListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>匿名内部类是为一种没有构造器的类</strong>，大部分匿名内部类用于接口回调，一般来说，匿名内部类用于继承其他类或者接口，并不需要增加额外地方法，只是对继承方法的实现或者重写。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类定义在一个类里面，并且被static 修饰，并不需要依赖于外部类。这点和类的静态成员属性有点类似，并且它不能使用外部类的非static 成员变量或者方法。</p>
<h3 id="深入理解内部类"><a href="#深入理解内部类" class="headerlink" title="深入理解内部类"></a>深入理解内部类</h3><h4 id="1、为什么成员内部类可以无条件访问外部类成员？"><a href="#1、为什么成员内部类可以无条件访问外部类成员？" class="headerlink" title="1、为什么成员内部类可以无条件访问外部类成员？"></a>1、为什么成员内部类可以无条件访问外部类成员？</h4><p>因为编译器会默认为内部类构造器中添加一个参数，这个参数是外部类对象的一个引用，所以它能直接访问外部内的成员。这也从侧面说明成员内部类为什么要依赖于外部类的对象。</p>
<h4 id="2、为什么局部内部类和匿名内部类只能访问局部final-变量？"><a href="#2、为什么局部内部类和匿名内部类只能访问局部final-变量？" class="headerlink" title="2、为什么局部内部类和匿名内部类只能访问局部final 变量？"></a>2、为什么局部内部类和匿名内部类只能访问局部final 变量？</h4><p>我们首先看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果把变量a或者b任意一个final 去掉，代码就编译不过。至于为什么，我们首先考虑一个问题：当test 方法执行完成后，变量a的生命周期结束了，而Thread对象的生命周期可能还没结束，那么在Thread的run方法中继续访问a就实现不了了，但是又要实现这样的效果，怎么办？Java中采用了 <font color="#ff0000">复制</font> 手段来解决，也就是将a复制到Thread对象中。</p>
<p><strong>也就是说，如果局部变量的值在编译期间就能确定，则直接在匿名内部类中创建一个拷贝；如果局部变量的值无法再编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值</strong></p>
<h3 id="内部类的场景和好处"><a href="#内部类的场景和好处" class="headerlink" title="内部类的场景和好处"></a>内部类的场景和好处</h3><ul>
<li>每个内部类都能独立继承一个接口实现，所以无论外部类是否已经继承了某个实现，对内部类都没有影响。<strong>内部类使得多继承的解决方案变得完整</strong>。    </li>
<li>方便将存在一定逻辑关系的类组织在一起，又可以对外隐藏     </li>
<li>方便编写事件驱动程序(如实现点击监听)     </li>
</ul>
<blockquote>
<p>以上内容参考自：<a href="https://www.cnblogs.com/dolphin0520/p/3811445.html" target="_blank" rel="noopener">Matrix海 子</a></p>
</blockquote>
</details>


]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章：一切皆组件</title>
    <url>/2019/10/23/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8-%E7%AC%AC3%E7%AB%A0/</url>
    <content><![CDATA[<p>从布局来看，官方把 Flutter 布局分为 Basic widget、Single-child 和 Multi-child。在学习和实战中，记住一句关于 Flutter 的话：一切皆组件。</p><h2 id="基础组件-Basic-widgets"><a href="#基础组件-Basic-widgets" class="headerlink" title="基础组件(Basic widgets)"></a>基础组件(Basic widgets)</h2><p>在组件划分上，Container、Row、Column 在官方文档里属于基础组件，但是 Container 又属于单一子元素组件(Single-child)，而 Row、Column 又属于多子元素组件(Multi-child)。为了便于区分和记忆，本书约定基础组件是不能再拆分的院子组件。以下了解下常用的组件：</p><a id="more"></a>

<h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><p>Text 比较简单，基本用法如下：</p>
<blockquote>
<p>Text(“hello”);</p>
</blockquote>
<p>当然，实际应用时还会有各种效果，比如文字大小、颜色、阴影等，常用属性如下表：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>textAlign</td>
<td>对齐方式</td>
</tr>
<tr>
<td>maxLines</td>
<td>最大行数</td>
</tr>
<tr>
<td>textScaleFactor</td>
<td>缩放因子，默认 1.0</td>
</tr>
<tr>
<td>overflow</td>
<td>配合maxlines使用，超出最大行数可以用省略号或渐变效果隐藏多余行数</td>
</tr>
<tr>
<td>style</td>
<td>TextStyle对象，其属性有color、fontFamily、background、fontSize、下划线等</td>
</tr>
<tr>
<td>textSpan</td>
<td>配合Text.rich使用，可实现类似富文本效果</td>
</tr>
</tbody></table>
<h3 id="Icon"><a href="#Icon" class="headerlink" title="Icon"></a>Icon</h3><p>Icon 即图标，在Android中支持系统自带的图标，mipmap文件夹中存放的就是Icon 类型图片。使用方式如下：</p>
<blockquote>
<p>Icon(Icons.search: Colors.blue)</p>
</blockquote>
<p>可以根据AS的提示查看系统自带的Icon，这些其实是<strong>矢量图标字体(iconfont)</strong>，即这些图片的尺寸不管怎么改变，图标本身都是清晰的，且没有锯齿，我们可以像改变文字颜色一样改变图标颜色。如果系统自带的满足不了，推荐使用<strong>阿里妈妈</strong>的矢量图标字体库。Icon 除了使用图标字体以外，还支持传入图片：</p>
<blockquote>
<p>icon: “images/ic_company.png”</p>
</blockquote>
<h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p>Image 的基本使用方式是从本地加载图片，代码如下：</p>
<blockquote>
<p>//AssetImage 也能写成 Image.asset<br>Image(image: AssetImage(“images/image_icon.png”),width: 50.0)</p>
</blockquote>
<p>如果从网络加载一张图片：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image(</span><br><span class="line">    image: NetworkImage(<span class="string">"https://www.phei.com.cn/templates/images/img_logo.jpg"</span>),</span><br><span class="line">    width: <span class="number">120.0</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>除上述方式，还可以通过 Image.file、Image.memory 的方式进行加载。</p>
<h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><p>Flutter 常用的button有以下几种： RaisedButton、FlatButton、IconButton、FloatingActionButton、OutlineButton等。一般的使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">    color: Colors.blue,</span><br><span class="line">    child: Text(<span class="string">"RaisedButton"</span>),</span><br><span class="line">    textColor: Colors.white,</span><br><span class="line">    <span class="comment">//onPressed: () =&gt; &#123;&#125;,</span></span><br><span class="line">    onPressed: () &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"xxxxxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果要自定义Button，只需要把源码相关属性覆写掉，就能得到想要的效果。</p>
<h3 id="FlutterLogo"><a href="#FlutterLogo" class="headerlink" title="FlutterLogo"></a>FlutterLogo</h3><p>顾名思义，就是Flutter的Logo，使用size来改变Logo大小，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">FlutterLogo(</span><br><span class="line">    size: <span class="number">100.0</span>,</span><br><span class="line">    colors: Colors.red,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>小技巧：在做具体项目时，需要展示图片时，可以先使用FlutterLogo 作为展位图，确定下具体尺寸并预览，等整体布局完毕之后，在把FlutterLogo替换成具体图片。</strong></p>
<h2 id="单一子元素组件-Single-child"><a href="#单一子元素组件-Single-child" class="headerlink" title="单一子元素组件(Single-child)"></a>单一子元素组件(Single-child)</h2><p>单一子元素组件包括： Container、Padding、Center、Align、FittedBox、AspectRatio 等。</p>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>Container 的简单使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">    color: Colors.green,</span><br><span class="line">    alignment: Alignment(<span class="number">0.0</span>,<span class="number">0.0</span>),</span><br><span class="line">    child: <span class="keyword">new</span> Text(<span class="string">"container"</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>首先了解下它的对齐方式，即上面代码中的 alignment 属性，它接受 Alignment 对象，会传入两个参数，取值范围都在 [-1,1] 之间，如下图所示：</p>
<p><img src="/assets/Book-Notes/Flutter%E4%BB%8E0%E5%88%B01%E5%BA%94%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/%E7%AC%AC3%E7%AB%A0/container%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F.jpeg" alt="Container对齐方式"></p>
<p>从图可以看出，中间位置 x 和y都为 0，它表示内容在Container的正中间位置，上面的示例代码就是；如果要让文字在左下角，只需要把 Alignment 的值改为 (-1,1) 即可。这样子写一般比较麻烦，Fluuter提供了一些简单的映射方式，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Alignment.center == Alignment(<span class="number">0.0</span>,<span class="number">0.0</span>)</span><br><span class="line">Alignment.centerLeft == Alignment(<span class="number">-1.0</span>,<span class="number">0.0</span>)</span><br><span class="line">...</span><br><span class="line"><span class="comment">//以此类推</span></span><br></pre></td></tr></table></figure>

<h3 id="Container-的约束"><a href="#Container-的约束" class="headerlink" title="Container 的约束"></a>Container 的约束</h3><p>有时候，我们需要约束容器所占据的大小和空间，在大部分情况下，可以通过 BoxConstraint 来完成：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">child: Container(</span><br><span class="line">    child: Text(<span class="string">"dfa"</span>),</span><br><span class="line">    constraints: BoxConstraints(</span><br><span class="line">        maxHeight: <span class="number">400.0</span>,</span><br><span class="line">        minHeight: <span class="number">200.0</span></span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>有时候，我们需要把存储在child中的Container扩展到最大：</p>
<blockquote>
<p>constraints: BoxConstraints.expend()</p>
</blockquote>
<p>如果要设置容器的宽度和高度：</p>
<blockquote>
<p>constraints: BoxConstraints.expend(width: 250.0,height: 100.0)</p>
</blockquote>
<p>在Container中，可以通过以下方式来设置margin 和 padding ：</p>
<blockquote>
<p>padding: EdgeInsets.only()<br>margin: EdgeInsets.only()</p>
</blockquote>
<p>在 Container 中，要注意的一个新概念是<strong>border</strong>，padding 、margin 与 border 的关系如下图所示：</p>
<p><img src="/assets/Book-Notes/Flutter%E4%BB%8E0%E5%88%B01%E5%BA%94%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/%E7%AC%AC3%E7%AB%A0/border%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="boder示意图"></p>
<p>Container 中还有装饰器的概念(Decoration)，这个属性很强大，可以支持背景图现行或者径向渐变，也支持边框、圆角、阴影等实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">    margin: EdgeInsets.only(top: <span class="number">60.0</span>,left: <span class="number">80.0</span>),</span><br><span class="line">    constraints: BoxConstaints.tightFor(width:<span class="number">300.0</span>,height: <span class="number">300.0</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//装饰器</span></span><br><span class="line">    decoration: BoxDecoration(</span><br><span class="line">        <span class="comment">//边线</span></span><br><span class="line">        border: Border.all(width:<span class="number">3</span>,color:Colors.red),</span><br><span class="line">        <span class="comment">//阴影</span></span><br><span class="line">        boxShadow: [</span><br><span class="line">            BoxShadow(</span><br><span class="line">                color: Colors.black,</span><br><span class="line">                offset: Offset(<span class="number">2.0</span>,<span class="number">2.0</span>),</span><br><span class="line">                blurRadius: <span class="number">4.0</span></span><br><span class="line">            )</span><br><span class="line">        ],</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//实现渐背景色</span></span><br><span class="line">        gradient: LinearGradient(</span><br><span class="line">            colors: [Colors.red,Colors.blue]</span><br><span class="line">        ),</span><br><span class="line">    ),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//偏移</span></span><br><span class="line">    transform: Matrix4.rotationZ(<span class="number">.3</span>),</span><br><span class="line">    alignment: Aligment.center,</span><br><span class="line">    child: Text(</span><br><span class="line">        <span class="string">"佩奇"</span>,</span><br><span class="line">        style: TextStyle(color: Colors.white,fontsize: <span class="number">30.0</span>),</span><br><span class="line">    ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="SingleChildScrollView"><a href="#SingleChildScrollView" class="headerlink" title="SingleChildScrollView"></a>SingleChildScrollView</h3><p>与Android的ScrollView差不多，用于view滚动，里面也只能嵌套一个child，用法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SingleChildScrollView(</span><br><span class="line">    child: Column(...)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="FittedBox"><a href="#FittedBox" class="headerlink" title="FittedBox"></a>FittedBox</h3><p>它主要负责对组件进行缩放和位置调整，它里面的属性 fit 相当于Android里面的 scaleType，示意图如下：</p>
<p><img src="/assets/Book-Notes/Flutter%E4%BB%8E0%E5%88%B01%E5%BA%94%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/%E7%AC%AC3%E7%AB%A0/FittedBox%E6%95%88%E6%9E%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="FittedBox效果示意图"></p>
<h3 id="FractionallySizedBox"><a href="#FractionallySizedBox" class="headerlink" title="FractionallySizedBox"></a>FractionallySizedBox</h3><p>FractionallySizedBox 与 FittedBox 还有点类似，但是前者是基于宽度/高度 缩放因子来调整布局大小，<strong>大小有可能超出父组件的设置</strong>，如果其子组件设置了大小，也不会起作用，用法一般如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">    child: <span class="keyword">new</span> FractionallySizedBox(</span><br><span class="line">        widthFactor: <span class="number">1.5</span>,</span><br><span class="line">        heightFactor: <span class="number">0.5</span>,</span><br><span class="line">        </span><br><span class="line">        child: <span class="keyword">new</span> Container(</span><br><span class="line">            width: <span class="number">50.0</span><span class="comment">//无效</span></span><br><span class="line">            color: Colors.yellow,</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Book-Notes/Flutter%E4%BB%8E0%E5%88%B01%E5%BA%94%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/%E7%AC%AC3%E7%AB%A0/FractionallySizedBox%E7%A4%BA%E6%84%8F%E5%9B%BE.webp" alt="FractionallySizedBox示意图"></p>
<h3 id="ConstrainedBox"><a href="#ConstrainedBox" class="headerlink" title="ConstrainedBox"></a>ConstrainedBox</h3><p>它是一种有约束的限制的布局，<strong>在其约定范围内，其子组件是不能逾越的</strong>。</p>
<h3 id="BaseLine"><a href="#BaseLine" class="headerlink" title="BaseLine"></a>BaseLine</h3><p>BaseLine 是一种基线的对齐方式，可以把几个不相关的组件设置在同一条水平线上进行，使文字和图片底部对其的使用方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: <span class="keyword">new</span> Row(</span><br><span class="line">    mainAxisAlignment: mainAxisAlignment.spaceBetween,</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">        <span class="keyword">new</span> Baseline(</span><br><span class="line">            baseline: <span class="number">100.0</span>,</span><br><span class="line">            baselineType: TextBaseline.alphabetic,</span><br><span class="line">            child: <span class="keyword">new</span> Text(</span><br><span class="line">                <span class="string">"天气好"</span>,</span><br><span class="line">                style:xxxx,</span><br><span class="line">            ),</span><br><span class="line">        ),</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Baseline(</span><br><span class="line">            baseline: <span class="number">100.0</span>,</span><br><span class="line">            baselineType: TextBaseline.alphabetic,</span><br><span class="line">            child: FlutterLogo(</span><br><span class="line">                size: <span class="number">100</span>,</span><br><span class="line">            ),</span><br><span class="line">        ),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="多元素组件-Multi-child"><a href="#多元素组件-Multi-child" class="headerlink" title="多元素组件(Multi-child)"></a>多元素组件(Multi-child)</h2><h3 id="Scaffold"><a href="#Scaffold" class="headerlink" title="Scaffold"></a>Scaffold</h3><p>它是基于Material 的与路由相关的、良好的结构体，它为我们很好地集成了 AppBar、floatingActionButton 等元素。</p>
<h3 id="AppBar"><a href="#AppBar" class="headerlink" title="AppBar"></a>AppBar</h3><p>就是我们理解的App顶部导航栏，这个控件一般可以实现大部分需求，但是，在有需要的情况下，我们也可以自定义，比如，我们的左侧不一定是返回按钮，这时候，我们可以重写其leading属性，例如：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">leading: IconButton(</span><br><span class="line">    icon: <span class="keyword">new</span> Icon(Icons.face),</span><br><span class="line">    onPressed: ()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<h3 id="Row-和-Column"><a href="#Row-和-Column" class="headerlink" title="Row 和 Column"></a>Row 和 Column</h3><p>二者都属于线性布局，一个横向一个纵向，<strong>要注意的是，Column 是不支持滚动的。</strong>Row的基本属性如下：</p>
<table>
<thead>
<tr>
<th align="center">children</th>
<th align="center">子组件数组</th>
</tr>
</thead>
<tbody><tr>
<td align="center">crossAxisAlignment</td>
<td align="center">子组件在纵轴方向的对其方式</td>
</tr>
<tr>
<td align="center">mainAxisAlignment</td>
<td align="center">子组件在横轴方向的对其方式</td>
</tr>
<tr>
<td align="center">textDirection</td>
<td align="center">布局顺序，一般是从左至右</td>
</tr>
<tr>
<td align="center">mainAxisSize</td>
<td align="center">max，表示尽可能多占用水平方向的位置</td>
</tr>
</tbody></table>
<h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><p>它和Android中的Listview有些类似，有以下几种创建方式：</p>
<ul>
<li>ListView    </li>
<li>ListView.builder    </li>
<li>ListView.custom    </li>
<li>ListView.separated    </li>
</ul>
<p>第一种示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ListView(</span><br><span class="line">    padding:<span class="keyword">const</span> EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">    <span class="comment">//可以设置水平滚动或者竖直滚动</span></span><br><span class="line">    scrollDirection: Axis.vertical</span><br><span class="line">    <span class="comment">//Item 高度</span></span><br><span class="line">    itemExtent: <span class="number">30.0</span>,</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">'A'</span>),</span><br><span class="line">        Text(<span class="string">'B'</span>),</span><br><span class="line">        Text(<span class="string">'C'</span>),</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>ListView.builder 用于创建重复的子项布局：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ListView.builder(</span><br><span class="line">    padding:<span class="keyword">const</span> EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">    itemExtent: <span class="number">30.0</span>,</span><br><span class="line">    itemCount: <span class="number">5</span>,<span class="comment">//可不传</span></span><br><span class="line">    itemBuilder: (context,position)&#123;</span><br><span class="line">        <span class="keyword">return</span> ListItem();</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>ListView.separated 即带有“分割”作用，即可以在子项中夹杂其他项（比如可以用作实现分割线）：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ListView.separated(</span><br><span class="line">    itemCount: itemCount,</span><br><span class="line">    itemBuilder: (context,position)&#123;</span><br><span class="line">        <span class="keyword">return</span> ListItem();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分割项</span></span><br><span class="line">    separatorBuilder: (context,position)&#123;</span><br><span class="line">        <span class="keyword">return</span> SeparatorItem();</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>ListView.custom 可以通过 SliverChildListDelegate 来接收 IndexedWidgetBuilder，并且为 ListView 生成列表项，从而实现自定义功能。</p>
<blockquote>
<p>我们可以留意一下ListView 的physics 属性，这个属性可以帮助实现诸如 ios 地址选择器的滚轮效果等。</p>
</blockquote>
<p>还有，以下ListView属性值得注意：</p>
<table>
<thead>
<tr>
<th align="center">RepaintBoundary</th>
<th align="center">为true时，避免列表项滚动时重绘</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AutomaticKeepAlive</td>
<td align="center">为true时，被滑出的区域不会被回收</td>
</tr>
</tbody></table>
<h3 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h3><p>和Android中的类似，不再赘述</p>
<h3 id="CustomScrollView"><a href="#CustomScrollView" class="headerlink" title="CustomScrollView"></a>CustomScrollView</h3><p>如果是多个组件结合起来一起滚动，比如同时存在ListView和GridView，则可以使用CustomScrollView。这个得实践才能知道效果，不多文字描述。</p>
<h3 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h3><p>即弹性布局，该布局借鉴了前端的 Flex 布局，值得注意的属性如下：</p>
<table>
<thead>
<tr>
<th align="center">direction</th>
<th align="center">表示垂直或者水平方向(Axis.vertical 或 Axis.horizon)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">flex</td>
<td align="center">弹性系数，大于0会按照比例来分割，等于0不会扩展占用的空间</td>
</tr>
</tbody></table>
<p>flex 的效果图：</p>
<p><img src="/assets/Book-Notes/Flutter%E4%BB%8E0%E5%88%B01%E5%BA%94%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/%E7%AC%AC3%E7%AB%A0/flex%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="flex效果图"></p>
<p>对应的代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: Column(</span><br><span class="line"> children: &lt;Widget&gt;[</span><br><span class="line">   Container(</span><br><span class="line">      height: <span class="number">400.0</span>,</span><br><span class="line">      child: Flex(</span><br><span class="line">          direction: Axis.vertical,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">             Expanded(</span><br><span class="line">                flex: <span class="number">1</span>,</span><br><span class="line">                child: Container(</span><br><span class="line">                   color: Colors.red,</span><br><span class="line">                )</span><br><span class="line">             ),</span><br><span class="line">             </span><br><span class="line">             Expanded(</span><br><span class="line">                flex: <span class="number">2</span>,</span><br><span class="line">                child: Container(</span><br><span class="line">                   color: Colors.yellow,</span><br><span class="line">                )</span><br><span class="line">             ),</span><br><span class="line">          ]</span><br><span class="line">      )</span><br><span class="line">   ),</span><br><span class="line">   </span><br><span class="line">   Container(</span><br><span class="line">      height: <span class="number">120.0</span>,</span><br><span class="line">      child: <span class="keyword">new</span> Row(</span><br><span class="line">         mainAxisAlignment: MainAxisAlignment.spaceBetween,</span><br><span class="line">         children: &lt;Widget&gt;[</span><br><span class="line">             Expanded(</span><br><span class="line">                flex: <span class="number">1</span>,</span><br><span class="line">                child: Container(</span><br><span class="line">                   color: Colors.blue,</span><br><span class="line">                )</span><br><span class="line">             ),</span><br><span class="line">             </span><br><span class="line">             Expanded(</span><br><span class="line">                flex: <span class="number">2</span>,</span><br><span class="line">                child: Container(</span><br><span class="line">                   color: Colors.red,</span><br><span class="line">                )</span><br><span class="line">             ),</span><br><span class="line">          ]</span><br><span class="line">      )</span><br><span class="line">   ),</span><br><span class="line"> ]   </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面例子中，我们实现了Flex布局，这种布局还可以通过在Row组件里设置两边对齐 MainAxisAlignment.spaceBetween 来实现。</p>
<h3 id="Wrap"><a href="#Wrap" class="headerlink" title="Wrap"></a>Wrap</h3><p>Wrap 即动词“包裹”的意思，前面介绍过，可以使用Row 和Column去包裹一些组件，因为它们都是多元素组件，Column 可能还好，但Row有时候就会出问题：<strong>会把屏幕撑破：</strong></p>
<p><img src="/assets/Book-Notes/Flutter%E4%BB%8E0%E5%88%B01%E5%BA%94%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/%E7%AC%AC3%E7%AB%A0/%E5%B1%8F%E5%B9%95%E6%92%91%E7%A0%B4%E5%9B%BE.png" alt="屏幕撑破图"></p>
<p>我们使用Wrap 就不会出现这种情况。它会自适应屏幕，Wrap 可以使用spacing 和 runSpacing 分别指定水平和垂直方向的间距。</p>
<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>Context 表示组件上下文的意思，每一个Context只对应一个Widget，如果一个Context对应的是父Widget A ，则Widget A 对应的 Context 也包含了子 Widget 的Context，**通过Context可以遍历和查找当前 Widget 树。</p>
<h3 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h3><p>即无状态的 Widget ，无法通过setState设置组件的状态，它的内部属性应该设置为 final，防止被意外改变。</p>
<h3 id="StatefullWidget"><a href="#StatefullWidget" class="headerlink" title="StatefullWidget"></a>StatefullWidget</h3><p>即有状态的 Widget，当我们创建一个 StatefullWidget 组件时，它同时也创建了一个State对象，并且 StatefullWidget 通过 State 关联可以达到刷新ui 的目的。StatefullWidget 只需要调用 setState(xx) 而不是像 Android 中类似 textView.setText(xx),就能改变UI。</p>
<p>StatefullWidget 由两部分组成，第一部分为主体，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatefullWidget</span> <span class="keyword">extends</span> <span class="title">StatefullWidget</span></span>&#123;</span><br><span class="line">    MyStatefullWidget(&#123;</span><br><span class="line">      Key key,</span><br><span class="line">      <span class="keyword">this</span>.color,</span><br><span class="line">    &#125;): <span class="keyword">super</span>(key: Key)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Color color;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    _MyStatefullWidgetState createState() =&gt; <span class="keyword">new</span> _MyStatefullWidgetState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主体部分继承了 StatefullWidget，在主体部分中创建的变量是无法变更的。第二部分代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyStatefullWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyStatefullWidget</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Widget build(BuildContext context)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二部分类名以 “_” 开头，表示该类是私有的，</strong>可以通过 widget.{variable} 访问第一部分里定义的变量，比如上述定义的： widget.color 。</p>
<h3 id="State-的生命周期"><a href="#State-的生命周期" class="headerlink" title="State 的生命周期"></a>State 的生命周期</h3><p>生命周期的回调方法如下图所示：</p>
<p><img src="/assets/Book-Notes/Flutter%E4%BB%8E0%E5%88%B01%E5%BA%94%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/%E7%AC%AC3%E7%AB%A0/state%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.webp" alt="state生命周期"></p>
<p>首次启动界面会执行：</p>
<blockquote>
<p>initState -&gt; didChangeDependencies -&gt; build</p>
</blockquote>
<p>点击重载按钮(闪电图标)：</p>
<blockquote>
<p>reassemble -&gt; didUpdateWidget -&gt; build</p>
</blockquote>
<p>** reassemble 只在debug模式下生效**</p>
<p>页面发生跳转时：</p>
<blockquote>
<p>deactivate -&gt; didChangeDependencies -&gt; build</p>
</blockquote>
<h4 id="解释下State生命周期中几个重要的方法："><a href="#解释下State生命周期中几个重要的方法：" class="headerlink" title="解释下State生命周期中几个重要的方法："></a>解释下State生命周期中几个重要的方法：</h4><ul>
<li>initState: 第一个被执行的方法，一般可以在这里面初始化动画、控制器    </li>
<li>dispose： 在组件被销毁时调用，一般在initState中初始化的动作，在dispose中销毁。</li>
</ul>
<h3 id="Widget-唯一身份标识：-key"><a href="#Widget-唯一身份标识：-key" class="headerlink" title="Widget 唯一身份标识： key"></a>Widget 唯一身份标识： key</h3><p>flutter中每个Widget 都有唯一标识，这个标识在Flutter Framework 层创建和渲染时生成的，它就是key。在某些场景下，你需要保存key，并且通过key访问该Widget，可以通过 GloabalKey,LocalKey,UniqueKey 或者 ObjectKey 进行保存，如通过 GloabalKey 保存 key，并在整个应用程序中共享：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">GloabalKey myKey = GloabalKey();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyWidget(</span><br><span class="line">        key: myKey</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><p>被 InheritedWidget 暴露出来的数据，可以高效地在Widget树中从上往下传递和共享，并且支持跨级传递。这个去看具体的例子。</p>
<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>Android 使用 gradle 管理包，ios 使用 Cocoapods ，flutter 中使用 pubspec.yaml 配置文件对包进行管理。在 pubspec.yaml 里面添加了包之后，输入命令 flutter packages get 即可把包下载下来使用。</p>
<h2 id="常见代码段效果"><a href="#常见代码段效果" class="headerlink" title="常见代码段效果"></a>常见代码段效果</h2><p>在IDE 把代码敲一遍。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Flutter从0到1构建大前端应用</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章：dart语言入门</title>
    <url>/2019/10/20/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8-%E7%AC%AC2%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="编写hello-world"><a href="#编写hello-world" class="headerlink" title="编写hello world"></a>编写hello world</h2><p>使用dart 在控制台输出 hellow world 是比较简单的：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"hello world !"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><p>使用var声明一个变量，在未初始化之前，默认值为null；如果想设置一个常量，即让一个变量不可变，那么可以使用final 或者 const 修饰：</p><a id="more"></a>


<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span>;</span><br><span class="line"><span class="built_in">num</span> = <span class="number">15</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"小明的年龄是 <span class="subst">$num</span> 岁"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">num</span> = <span class="string">'20'</span>;  <span class="comment">//注意，变量的类型是可以变化的！！！</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">num</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> c= <span class="number">30</span>； <span class="comment">//final 修饰的变量只能被声明一次</span></span><br><span class="line"><span class="built_in">print</span>(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">print</span>(d);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么const 和final 的区别是什么呢？const 变量是一个编译时常量，final 变量在第一次使用时被初始化(const 是隐式的 final)，实例变量可以是 final ，但是不能 const，常量如果是类级别的，可以使用 static const，例如： const static PI = 3.1415</p>
</blockquote>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Dart 里面的字符串有以下几种创建方式：</p>
<ul>
<li>使用单引号、双引号创建字符串。     </li>
<li>使用三个引号或者双引号创建多行字符串。    </li>
<li>使用r创建原始raw字符串。    </li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">"hello"</span></span><br><span class="line"><span class="comment">//使用三个引号创建多行</span></span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">'''hello</span></span><br><span class="line"><span class="string">              Bob'''</span></span><br><span class="line"><span class="comment">//使用r创建              </span></span><br><span class="line"><span class="keyword">var</span> str4 = <span class="string">r'你好啊'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如果单引号里面嵌套单引号或者双引号里面嵌套双引号，则需要使用反斜杠进行转义。</p>
</blockquote>
<p>在Dart里，可以对字符串进行单行拼接，也可以多行拼接：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> s1 = <span class="string">'ha'</span> <span class="string">'ha'</span>; <span class="comment">//单引号空格拼接</span></span><br><span class="line"><span class="built_in">String</span> s1 = <span class="string">"ha"</span> <span class="string">"ha"</span>; <span class="comment">//双引号空格拼接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用加号(+)拼接和java一样，不赘述</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用三引号多行拼接</span></span><br><span class="line"><span class="built_in">String</span> s1 = <span class="string">'''</span></span><br><span class="line"><span class="string">        Android开发工程师</span></span><br><span class="line"><span class="string">        前端开发工程师</span></span><br><span class="line"><span class="string">        '''</span>;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">String</span> s1 = <span class="string">"""</span></span><br><span class="line"><span class="string">        Android开发工程师</span></span><br><span class="line"><span class="string">        前端开发工程师</span></span><br><span class="line"><span class="string">        """</span>;</span><br></pre></td></tr></table></figure>

<h3 id="list-与数组"><a href="#list-与数组" class="headerlink" title="list 与数组"></a>list 与数组</h3><p>Dart 中，List 表示集合，其实和数组是同一个概念，创建方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> <span class="built_in">List</span>();</span><br><span class="line"><span class="comment">//创建不可变list，如果试图改变不可变list，就会报错</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">const</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机打乱里面的元素顺序</span></span><br><span class="line">list.shuffle()</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Map</span> name = &#123;<span class="string">"name"</span>: <span class="string">"haha"</span>&#125;</span><br><span class="line"><span class="comment">//创建不可变map</span></span><br><span class="line"><span class="built_in">Map</span> name = <span class="keyword">const</span>&#123;<span class="string">"name"</span>: <span class="string">"haha"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span> name = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">name[<span class="string">'name'</span>] = <span class="string">'haha'</span></span><br></pre></td></tr></table></figure>

<h3 id="dynamic-和-Object"><a href="#dynamic-和-Object" class="headerlink" title="dynamic 和 Object"></a>dynamic 和 Object</h3><p>在Dart中，一切皆对象，而且这些对象的父类都是 Object，当没有选择明确的类型时，编译的时候回根据值去明确类型：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name1 = <span class="string">'abc'</span></span><br><span class="line"><span class="built_in">Object</span> name = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">dynamic</span> name = <span class="string">'abc'</span></span><br></pre></td></tr></table></figure>

<p>以上写法都没有问题，但是dart并不建议这样做，在实际开发中，我们尽量为变量明确类型，这样可以加快运行速度(如果不指定类型，则在debug模式下类型会是动态的)，并且提高安全性。</p>
<p><strong>使用dynamic 时则是告诉编译器，我们不用做类型检测，并且知道自己在做什么</strong>，如果我们调用一个不存在的方法时，会执行 noSuchMethod()方法，在默认情况下，会抛出NoSuchMethodError 异常。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>三目运算： 如： var a = b &gt; 10 ? a : 0      </li>
<li>~/ 除法： 返回一个整数结果(取商)：</li>
</ul>
<blockquote>
<p>var z = 12~/7<br>print(z)  //结果是3，这个结果还未验证，将信将疑？？？</p>
</blockquote>
<ul>
<li>级联操作符：类似一些语言中的链式调用，例如：</li>
</ul>
<blockquote>
<p>String s = new StringBuffer()<br>           ..write(‘a’)<br>           ..write(‘b’)<br>           .toString();    </p>
<p>print(s);// 打印出 ab</p>
</blockquote>
<ul>
<li>判断某种类型： as、is、is!  (注意感叹号在is的后面)</li>
</ul>
<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>Dart 的异常捕获比Java还要强大，可以抛出任意类型的对象，抛出异常的方式通常如下：</p>
<blockquote>
<p>throw Exception(‘我是异常’)</p>
</blockquote>
<p>使用try-catch保证程序健壮性：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125; on AuthorizationException <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">  <span class="comment">//捕获特定类型异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可以用以下方式定义一个普通函数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> getName(name)&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>可选的命名参数，即不传这些参数也可以，在定义参数是，使用{params1,params2,…}指定命名参数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> userSetting(<span class="built_in">int</span> age,<span class="built_in">String</span> name)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数中，我们可以传递age、name，或者其中一个，或者都不传递也可以。</p>
<h3 id="必传参数"><a href="#必传参数" class="headerlink" title="必传参数"></a>必传参数</h3><p>我们可以使用 @required 来修饰参数，表示参数必传：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> userSetting(&#123;<span class="meta">@Required</span> <span class="built_in">int</span> age,<span class="meta">@Required</span> <span class="built_in">String</span> name)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可选位置参数"><a href="#可选位置参数" class="headerlink" title="可选位置参数"></a>可选位置参数</h3><p>书上没有说什么叫做可选位置参数，我个人理解是，同时包含了必选参数以及可选参数，可以用[]把目标标记为可选的位置参数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> userSetting(&#123;<span class="built_in">int</span> age,<span class="built_in">String</span> name,[<span class="built_in">String</span> interestes]&#125;)&#123;</span><br><span class="line">    <span class="keyword">if</span>(interestes != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'兴趣爱好:<span class="subst">$interestes</span>'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>类似于kotlin，默认参数在参数后接 “=” :</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> userSetting(&#123;<span class="built_in">int</span> age = <span class="number">12</span>,<span class="built_in">String</span> name = <span class="string">'小明'</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="函数可作为参数传递"><a href="#函数可作为参数传递" class="headerlink" title="函数可作为参数传递"></a>函数可作为参数传递</h3><p>这个可能稍微有点费解，就是把一个函数当做一个参数传递给另外一个函数，看例子：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> printItem(<span class="built_in">String</span> item)&#123;</span><br><span class="line">    <span class="built_in">print</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> users = [<span class="string">'小明'</span>,<span class="string">'小王'</span>]</span><br><span class="line">users.forEach(printItem);</span><br></pre></td></tr></table></figure>

<h3 id="函数作为变量"><a href="#函数作为变量" class="headerlink" title="函数作为变量"></a>函数作为变量</h3><p>函数也可以直接作为一个变量使用，并且后续可以使用这个变量作为函数来调用：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> say = (name)&#123;</span><br><span class="line">    say(<span class="string">'过年了'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>Dart 和 JavaScript 的一个共同点是——<strong>单线程</strong>，同步代码会阻塞程序，因此在程序中能看到大量的异步操作。在Flutter 中，是使用 Future 对象来执行相关操作的，Futrue 支持链式操作，可以按顺序执行异步函数。</p>
<h3 id="Future-是什么"><a href="#Future-是什么" class="headerlink" title="Future 是什么"></a>Future 是什么</h3><p>一个 Future 是一个 Future 自身的泛型 Future<t> 对象，他表示一个异步操作产生的 T 类型的结果，当然，T可以是void类型，如果返回一个Future的函数被调用了，将发生以下两件事：</t></p>
<ol>
<li>这个函数加入待完成队列并且返回一个未完成的 Future 对象。    </li>
<li>当这个操作结束了，Future 对象返回一个值或者错误。   </li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; future = getFuture();</span><br><span class="line">future.then((value) =&gt; handleValue(value))</span><br><span class="line">      .catchError((error) =&gt; handleError(error))</span><br><span class="line">.whenComplete() =&gt; handlerComplete();</span><br></pre></td></tr></table></figure>

<p>我们在future.then中接受异步处理的结果，并根据业务做相应处理。而future.catchError则用于捕获并处理错误。无论失败或者成功，都需要处理的业务可以放在 whenComplete 中。</p>
<h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>当遇到有需要延迟的运算(async)时，将其放到延迟运算的队列(await)中，把不需要的延迟运算的部分先执行完，最后来处理延迟运算部分，<strong>要使用await，就必须在async标记的函数中运行，否则这个await会报错。</strong>async 和 await 是Future 的语法糖，解决了<strong>回调地狱(Callback Hell) 问题</strong>。它们的用法例子如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">steps() <span class="keyword">async</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">String</span> step1Result = <span class="keyword">await</span> step1(<span class="string">'step1'</span>);</span><br><span class="line">        <span class="built_in">String</span> step2Result = <span class="keyword">await</span> step2(step1Result);</span><br><span class="line">        <span class="built_in">String</span> step3Result = <span class="keyword">await</span> step3(step2Result);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">print</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，await 必须被包裹在async 里面，假如没有使用这两个语法糖，那么代码将会是这样的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">step1(<span class="string">'step1'</span>).then((step1Result)&#123;</span><br><span class="line">    step2(step1Result).then(step2Result)&#123;</span><br><span class="line">        step3(step2Result).then(step3Result)&#123;</span><br><span class="line">        <span class="comment">//step4</span></span><br><span class="line">        <span class="comment">//step5</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看出，这确实使代码变得整洁易读。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>Dart 的泛型和Java的很类似，如下例子，就不多说：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span> animals = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewAnimal</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Animal</span>&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">String</span> toString() =&gt; <span class="string">"创建一个新的小动物"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承、接口实现-和-混合"><a href="#继承、接口实现-和-混合" class="headerlink" title="继承、接口实现 和 混合"></a>继承、接口实现 和 混合</h3><p>dart 的继承使用 extends ，接口实现使用 implements ，同时，dart也是单继承，并且通过 @Override 来重写父类的方法，也可以通过super 来调用父类的方法，这与Java相似。另外，<strong>由于flutter没有Java中的公有和私有访问修饰符，因此可以直接访问父类中的所有变量和方法。</strong></p>
<p>接口的实现：Fluuter 是没有接口(interface)关键字的，但是每个类都是一个隐式的接口，这个接口包含类中的所有成员变量和定义的方法，当类被当做接口时，类中的所有方法就是接口中的方法，它需要在子类中被重新实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CanFixComputer</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> fixComputer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanProgramming</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> programming()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoftwareEngineer</span> <span class="keyword">extends</span> <span class="title">Engineer</span> <span class="keyword">implements</span> <span class="title">CanFixComputer</span>, <span class="title">CanProgramming</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> fixComputer()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'软件工程师修电脑'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> programming()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'码农写代码'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码将 CanProgramming 作为接口实现，因此如果不重写 programming 就会报错。</p>
<p>接下来来借料Dart提供的<strong>混合(mixins,也可理解为混入)语法特性，它的作用是在类中混入其它功能</strong>，通俗地将，mixins 是一个可以把自己方法提供给其它类使用，但却不需要称为其它类的父类的类，它以非继承的方式来复用类中的代码，mixins 使用with关键字来实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CanFixComputer</span></span>&#123;</span><br><span class="line">    <span class="keyword">factory</span> CanFixComputer._()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> fixComputer()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'软件工程师修电脑'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CanProgramming</span></span>&#123;</span><br><span class="line">    <span class="keyword">factory</span> CanProgramming._()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> programming()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'码农写代码'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> doWork();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Worker</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> doWork()&#123;</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">'工程师在工作'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoftEngineer</span> <span class="keyword">extends</span> <span class="title">Engineer</span> <span class="title">with</span> <span class="title">CanFixComputer</span>, <span class="title">CanProgramming</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在 SoftEngineer 类中就可以使用 CanFixComputer 和 CanProgramming 中的方法了，有些同学可能有疑问了，如果写成下面这样子：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Worker</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> doWork()&#123;</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">'老师在上课'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Worker</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> doWork()&#123;</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">'工程师在工作'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">Worker</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> doWork()&#123;</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">'开车'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoftEngineer</span> <span class="keyword">extends</span> <span class="title">Engineer</span> <span class="keyword">implements</span> <span class="title">Driver</span> <span class="title">with</span> <span class="title">Teacher</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> doWork()&#123;</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">'我自己的方法'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，SoftEngineer 自己有个doWork 方法，并且继承的类，实现的接口以及mixins的类都有doWork方法，那么在调用 doWork 方法时，到底怎么调用呢？它们的原则是这样的：</p>
<ul>
<li>如果类本身有这个方法，则调用本身的方法    </li>
<li>否则调用 mixins 的这个方法    </li>
<li>如果mixins 也没有这个方法，则调用 extends 的这个方法     </li>
<li>如果extends 也没有这个方法，则调用 implements 类中的这个方法    </li>
</ul>
<p>优先级方法：</p>
<p>自身方法-&gt; mixins -&gt; extends -&gt; implements</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Flutter从0到1构建大前端应用</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章：Flutter 简介</title>
    <url>/2019/10/19/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8-%E7%AC%AC1%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="Flutter-的优势"><a href="#Flutter-的优势" class="headerlink" title="Flutter 的优势"></a>Flutter 的优势</h2><ul>
<li>跨平台：开发的代码可同时部署在 Android、ios、web、桌面 环境上。    </li>
<li>流畅的跨平台UI。使用“自绘UI + 原生系统”，配合 Skia 2D 引擎，实现高帧率的流畅UI，比webview这种方式效率更高。    </li>
<li>开发过程中支持热重载，只需要保存代码即可在设备上看到更改后的效果，提高了开发效率。        </li>
<li>对开发环境要求低，目前支持 Android Studio 和 VScode 两种 IDE 。    </li>
</ul><a id="more"></a>
<h2 id="Flutter架构"><a href="#Flutter架构" class="headerlink" title="Flutter架构"></a>Flutter架构</h2><p>学习一门新技术，首先要对其整个技术体系有个大概的了解。Flutter 整体可以分为Framework 和 Engine 两个部分，官方给出的架构图如下： </p>
<p><img src="/assets/Book-Notes/Flutter%E4%BB%8E0%E5%88%B01%E5%BA%94%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/%E7%AC%AC1%E7%AB%A0/flutter%E6%9E%B6%E6%9E%84.png" alt="flutter架构图"></p>
<h3 id="Flutter-Framework"><a href="#Flutter-Framework" class="headerlink" title="Flutter Framework"></a>Flutter Framework</h3><p>Framework 是由纯 Dart 语言实现的 SDK ，Dart 也是Flutter 的官方语言。以下分别介绍各层作用：</p>
<ol>
<li>最底下的两个层：底层UI库，提供动画、手势及绘制功能供开发者调用。    </li>
<li>Rendering层：负责构建UI树，每当 UI 树上的 Element 发生变化时，都会计算出有变化的部分并且会更新UI树，最终将UI树绘制到屏幕上。    </li>
<li>Widgets 层： 基础组件库，Flutter 默认帮我们提供了 Material (即 Android 风格) 和 Cupertino(即 ios 风格) 两种视觉风格的组件库。</li>
</ol>
<h3 id="Flutter-Engine"><a href="#Flutter-Engine" class="headerlink" title="Flutter Engine"></a>Flutter Engine</h3><p>Engine 是由纯 C++ 实现的 SDK，<strong>Framework 层所有的UI库都会调用到 Engine 这一层。</strong></p>
<ol>
<li>Skia： 2D 渲染引擎(Android 系统自带，但ios 系统不自带，因此，ios 报所占的存储空间更大)。    </li>
<li>Dart： Dart 运行时。    </li>
<li>Text： 文字排版引擎。    </li>
</ol>
<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p>个人觉得，开发环境搭建按照官方文档会更好，并且官方有中文文档，唯一要注意的是，在中国使用 Flutter 需要注意资源获取的问题。附：</p>
<p>flutter官方中文文档——环境搭建：<a href="https://flutter.cn/docs/get-started/install" target="_blank" rel="noopener">https://flutter.cn/docs/get-started/install</a></p>
<p>中国网络环境的注意事项：<a href="https://flutter.cn/community/china" target="_blank" rel="noopener">https://flutter.cn/community/china</a></p>
<blockquote>
<p>还要注意的一点是，设置flutter环境变量的时候最好设置永久的环境变量，不然重启电脑环境变量就会无效了。</p>
</blockquote>
<h2 id="Flutter-升级和分支切换"><a href="#Flutter-升级和分支切换" class="headerlink" title="Flutter 升级和分支切换"></a>Flutter 升级和分支切换</h2><p>可以通过在项目的根目录中(包含pubspec.yaml的目录)输入命令：</p>
<blockquote>
<p>flutter upgrade </p>
</blockquote>
<p>对flutter 进行升级，这里还介绍下 Flutter channels 相关的概念，Flutter 有4种release channel ，即：stable、beta、dev、master，官方推荐使用 stable channel ，我们可以在命令行输入以下命令来查看当前的 channel，并会列出所有channel：</p>
<blockquote>
<p>flutter channel</p>
</blockquote>
<p>用 * 标识的位置表示当前channel ，如果想要切换channel 到stable 分支，可以用以下命令：</p>
<blockquote>
<p>flutter channel stable</p>
</blockquote>
<p><strong>这里还有需要注意的是 pubspec.yaml，这个文件掌管着 Flutter 所需要的依赖包，有点类似于 Node.js 中的 package.json ，这些 Flutter 依赖包有内置的，还有别的开发者发布的，我们可以通过命令 <em>flutter packages get</em> 获取依赖包列表，还能通过 <em>flutter pachages upgrade</em> 命令升级这些依赖包。</strong></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Flutter从0到1构建大前端应用</tag>
      </tags>
  </entry>
  <entry>
    <title>第7章：Android启动过程简析</title>
    <url>/2019/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC7%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="第一个系统进程-init"><a href="#第一个系统进程-init" class="headerlink" title="第一个系统进程(init)"></a>第一个系统进程(init)</h2><p>Android设备的启动必须经历3个阶段： Boot Loader、Linux Kernel 以及 Android 系统服务，默认情况下它们都有各自的启动画面。作为Android 中第一个被启动的进程，init的 PID 的值为 0，它通过解析 init.rc 脚本来构建出系统的初始运行形态——其中最重要的就是启动 ServiceManager、Zygote 和 SystemServer。</p><a id="more"></a>
<h3 id="Android-的“DNS服务器”——ServiceManager"><a href="#Android-的“DNS服务器”——ServiceManager" class="headerlink" title="Android 的“DNS服务器”——ServiceManager"></a>Android 的“DNS服务器”——ServiceManager</h3><p>ServiceManager 是Binder 机制中的“DNS服务器”，负责域名(某Binder服务在 ServiceManager 注册时提供的名称) 到IP地址(由底层Binder驱动分配的值)的解析。</p>
<p>ServiceManager 所属class 是core ，并且带有 critical 选项，说明它是系统的关键进程——意味着如果进程不幸在4分钟内异常退出4次，则设备将重启并进入还原模式。当 ServiceManager 重启时，zygote、media、surfaceflinger 等都会被重启。</p>
<h3 id="“孕育”-新的线程和进程——Zygote"><a href="#“孕育”-新的线程和进程——Zygote" class="headerlink" title="“孕育” 新的线程和进程——Zygote"></a>“孕育” 新的线程和进程——Zygote</h3><p>这个单词是”受精卵”的意思，正如其名所示，Android 中大多数的应用进程和系统进程都是通过 Zygote 来生成的。它所在的程序名叫做”app_process” ，而不像 ServiceManager 一样在一个独立的进程中。在init 进程的帮助下，通过zygote 逐步建立起 SystemServer 的运行环境。</p>
<h3 id="Android的“系统服务”——SystemServer"><a href="#Android的“系统服务”——SystemServer" class="headerlink" title="Android的“系统服务”——SystemServer"></a>Android的“系统服务”——SystemServer</h3><p>SystemServer 是 Android 进入 Launcher 前的最后准备。ZygoteInit 通过 Zygote.forkSystemServer 来生成一个新的进程，用于承载各系统服务。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解Android内核设计思想-林学森</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章：进程间通信——Binder</title>
    <url>/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC6%E7%AB%A0/</url>
    <content><![CDATA[<p>我们知道，同一个程序中两个函数之间能够直接调用的根本原因是他们处于相同的内存区域中，因为在同一个内存区域中，虚拟地址的映射规则完全一致，所以A函数和B函数的调用关系很简单，但两个不同进程，他们是没有办法直接通过内存地址来访问到对方内部的函数或者变量的。</p><p>既然无法直接访问，那间接的方法就是Binder。如果通观Binder的各个元素，就会惊奇地发现它和 TCP/IP 网络有很多相似之处：</p><a id="more"></a>

<ul>
<li>Binder 驱动 -&gt; 路由器</li>
<li>Service Manager（本质也是个服务器） -&gt; DNS（本质也是个服务器）</li>
<li>Binder Client -&gt; 客户端</li>
<li>Binder Server -&gt; 服务器</li>
</ul>
<p>TCP/IP中一个典型的服务连接过程如下图所示：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/%E7%AC%AC6%E7%AB%A0/binder-tcpip.png" alt="TCP/IP连接"></p>
<p>这个简化的流程图有以下几个步骤：</p>
<ul>
<li><p>Client 向dns 查询 google.com 的ip地址。<br>显然，Client 一定得先知道DNS 的 IP地址，才能向它发起查询，DNS 服务器的ip设置是在接入网络前就已经设置完成的。当然，client向DNS 查询 ip地址不一定需要，因为如果已经知晓server的ip，就无需这一步，从而加快访问速度；</p>
</li>
<li><p>DNS 将查询结果返回 Client。<br>Client的Ip地址对于 DNS 是必须的，不过这些信息会封装在 TCP/IP 包中。</p>
</li>
<li><p>Client 发起连接。这里我们没有提及Router的作用，因为它所负担的责任是将数据包投递到用户设定的目标IP中，它是整个通信结构中的基础。</p>
</li>
</ul>
<p>而对于Binder来说，Binder的 DNS (Service Manager)也不是必须的——前提是客户端能记住它要访问的进程的 Binder 标志（IP地址），<strong>尤其要注意的是，这个标志是个“动态IP”，意味着即使客户端记住了本次通信过程中目标进程的唯一标志，下一次访问仍然需要重新获取</strong>。因此，Service Manager 这个 DNS 的还是挺有必要的。</p>
<blockquote>
<p>既然Service Manager是 DNS 服务器，那么它的 IP 地址是多少呢？Binder 机制对此作了特别规定，Service Manager在Binder通信中唯一标志用于都是0。</p>
</blockquote>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>略</p>
<h2 id="进程间的数据传递载体——Parcel"><a href="#进程间的数据传递载体——Parcel" class="headerlink" title="进程间的数据传递载体——Parcel"></a>进程间的数据传递载体——Parcel</h2><p>关于进程间如何传递，我们可以使用2个生活例子来类比：</p>
<ul>
<li>用快递寄衣服：虽然快递种类比较多，但是无论用哪个快递，用哪种运输方式，“衣服”本身始终是没有变过的，接收人拿到的还是原来那件衣服。    </li>
<li>通过电子邮件发送图片：在接收人看到邮件中的图片时，我们无法确认这张图片在传输过程中被复制了多少次，但是可以肯定的是，对方看到的图片和原始图片是一样的。</li>
</ul>
<p>进程间通信的数据传递类似于第2种情况，如果只是一个int型数值，不断复制直到目标进程即可；如果是一个对象呢？我们直到，同一个进程中对象的传递实质上是传递了一个内存地址，但是在跨进程的情况下就无能为力了，因为采用了虚拟内存机制，两个进程都有自己独立的内存地址空间，所以跨进程传递的地址空间是无效的。</p>
<p>进程间的数据传递是Binder 机制中的重要环节，而担负这一重任的就是Parcel。 Parcel 的直译是 “打包” ，上面提到，进程间数据传递直接传送对象的地址是行不通的，那把对象在进程 A 中占据的内存相关数据打包起来，然后寄送到内存 B 中，由 B 在自己的进程空间中“复现”这个对象，是否可行？ Parcel 就具有这种打包能力。</p>
<p>Parcel 提供了很多接口方便程序使用，他可以存储多种类型的数据：</p>
<ul>
<li>原始数据类型 以及 原始数据类型数组     </li>
<li>Parcelable    </li>
<li>Bundle    </li>
<li>Active Objects    </li>
</ul>
<blockquote>
<p>通常我们存入Parcel 的是对象的内容，而 Active Objects 写入的则是他们的特殊标志引用。所以从 Parcel 中读取这些对象时，大家看到的并不是重新创建的对象实例，而是原来那个被写入的实例，能够以这种方式传递的对象目前主要有两类： Binder 以及 FileDescriptor (Linux 中的文件描述符)。</p>
</blockquote>
<ul>
<li>Untyped Containers    </li>
</ul>
<blockquote>
<p>它是用于读写标准的任意类型的 Java 容器，包括 ： writeArray(Object[])/readArray(ClassLoader)、writeList(list)/readList(list)</p>
</blockquote>
<p>Parcel 可以用集装箱来类比，理由如下：</p>
<ul>
<li>货物无关性： 不排斥运输的货物种类，电子产品、汽车等都可以    </li>
<li>不同的货物需要不同的打包和卸货方案： 比如运载易碎物品和坚硬物品的装箱和卸货方式就有很大的不同。</li>
</ul>
<blockquote>
<p>值得注意的是，Parcel 存/取 数据的方式都是一一对应的，如 writeByte(byte)/readByte() </p>
</blockquote>
<ul>
<li>远程运输和组装： 集装箱的货物一般需要跨洋，这类似于 Parcel 的跨进程。不过集装箱运输公司本身并不负责所运输货物的组装，而 Parcel 会依据协议为接收方提供还原冤死数据对象的业务。   </li>
</ul>
<h3 id="Parcel-的工作方式（书上没有，自己添加）"><a href="#Parcel-的工作方式（书上没有，自己添加）" class="headerlink" title="Parcel 的工作方式（书上没有，自己添加）"></a>Parcel 的工作方式（书上没有，自己添加）</h3><p> Parcel 的 Parcel.obtain() 方法可以获取一个Parcel 对象，系统预先产生了一个大小为6的 Parcel 池 sOwnedPool，在obtain 操作时，如果 sOwnedPool 中还有现成的 Parcel 对象，则直接利用，否则通过 new Parcel(0) 创建 Parcel 对象。</p>
<p> Parcel.java 实际上只是一个简单的中介，它的主要内容都是 JNI 层的 Parcel 实现的。Parcel 对象的初始化过程只是简单地给各个变量赋初始值，并没有设想中的内存分配动作，因为 Parcel 遵循的是“动态扩展”的内存申请原则，只有在需要时才申请内存，避免资源浪费。</p>
<blockquote>
<p>Parcel 提供数据当前位置的值 dataPosition，类似于游标。每当存储新数据时，都是从 dataPosition 位置接着往后存储，存储新数据时，会判断当前空间是否足够，如果不足，则申请新的空间（个人根据文中内容理解的，不太确定是否正确）。</p>
</blockquote>
<h2 id="Binder驱动与协议"><a href="#Binder驱动与协议" class="headerlink" title="Binder驱动与协议"></a>Binder驱动与协议</h2><p>Android 是 linux 内核的，因而 Binder 驱动也是标准的 linux 驱动，具体而言，Binder驱动会把自己注册成一个 misc device，并向上层提供 /dev/binder节点——但是它并不对应真实的硬件设备。Binder 驱动运行于内核态，可提供 open()、ioctl()、mmap() 等常用文件操作。</p>
<blockquote>
<p>Android 系统为什么把 Binder 注册成 misc device 类型的驱动呢？因为 linux 字符设备通常要通过 alloc_chrdev_region()、cdev_init() 等操作才能在内核中注册自己；而 misc 类型驱动相对简单，只需要 misc_register() 就可轻松解决。</p>
</blockquote>
<p>Binder 驱动为上层提供了6个接口，但一般文件操作用到的 read() 和 write() 则没有出现，这是因为它们的功能完全可以用 ioctl() 和 mmap() 来代替，并且会更灵活。这6个接口中使用得最多的是 binder_ioctl,binder_mmap 和 binder_open，，以下分别介绍这三种接口。</p>
<h3 id="打开Binder驱动——binder-open"><a href="#打开Binder驱动——binder-open" class="headerlink" title="打开Binder驱动——binder_open"></a>打开Binder驱动——binder_open</h3><p>上层进程在访问 Binder 驱动时，首先需要打开 /dev/binder 节点，这个操作最终的实现是在 binder_open() 中，在这个方法中，会创建一个 binder_proc 实体，这个实体用于记录各种管理数据(Binder 驱动会在 /proc 系统目录下生成各种管理信息)，并且，每个进程都有独立的记录。</p>
<p>在完成proc 的初始化之后，就会把这个 proc 加入到 Binder 的全局管理中，这个过程涉及资源互斥，因而需要使用保护机制。到目前为止，Binder 驱动已经为用户创建了一个它自己的 binder_proc 实体，之后用户对Binder 设备的操作都以这个对象为基础。</p>
<h3 id="binder-mmap"><a href="#binder-mmap" class="headerlink" title="binder_mmap"></a>binder_mmap</h3><p>对于 Binder 驱动来说，上层用户调用的 mmap() 最终对应了 binder_mmap()操作(<strong>应用程序最多只能申请 4M 的空间，如果超出这个大小，不会退出或者报异常，而只会满足用户 4M 的请求</strong>)，那么Binder 采用 mmap 的目的是什么呢？我们知道，mmap() 可以把设备指定的内存块直接映射到应用程序的内存空间中，但Binder 本身并不是硬件设备，而是基于内存的“伪硬件”，那么它映射了什么内存块到应用程序中呢？</p>
<p>假设有连个进程A和B，其中进程B通过 open() 和 mmap() 与Binder驱动建立了联系，如下图：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/%E7%AC%AC6%E7%AB%A0/B-mmap.png" alt="进程B连接Binder"></p>
<blockquote>
<p>可以看到 ：</p>
</blockquote>
<blockquote>
<ol>
<li>对于进程B而言，通过mmap()返回值得到一个内存地址（当然是虚拟地址），这个地址最终会指向物理内存的某个位置（通过虚拟内存转换）。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>对于Binder驱动而言，它也有个指针（binder_proc-&gt;buffer）指向某个虚拟内存地址，这个地址转换后，与进程B指向的物理内存地址位于同一个位置。</li>
</ol>
</blockquote>
<p><strong>个人理解：进程B执行 mmap() ，最终是通过 Binder 的 binder_mmap() 来实现，在 B 拿到这块内存后(当然是经过虚拟内存转换后的虚拟内存地址)，Binder 驱动同时将这块内存赋值给了 binder_proc-&gt;buffer</strong>。这样，Binder和应用程序就拥有了<strong>若干公用的物理内存块</strong>，它们对着各自内存地址的操作，实际是在同一块内存中执行，这时候我们再把A进程加入进来，如下图：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/%E7%AC%AC6%E7%AB%A0/A%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE.png" alt="进程A复制数据"></p>
<p>这时候，左半部分没有变化，右半部分Binder驱动通过copy_from_user()，把A进程中某段数据复制到其binder_proc-&gt;buffer所指向的内存空间，这时候我们惊喜发现，binder_proc-&gt;buffer在物理内存中的位置和进程B是共享的，进而，B进程可以直接访问到这段数据，<strong>也就是说，Binder驱动只用了一次复制，就实现了进程A和B之间的数据共享。</strong></p>
<blockquote>
<p>以上通过 mmap 映射的映射区是 <strong>只读</strong>的。</p>
</blockquote>
<h3 id="binder-ioctl"><a href="#binder-ioctl" class="headerlink" title="binder_ioctl"></a>binder_ioctl</h3><p>这是 Binder 接口函数中工作量最大的一个。前面提到过，Binder 并不提供 read() 和 write() 等常规文件操作，因为 ioctl 完全可以替代它们。它主要提供了以下命令：</p>
<ul>
<li>BINDER_WRITER_READ: 读写操作，可以用此命令向 Binder 读取或写入数据    </li>
<li>BINDER_SET_MAX_THREAD: 设置支持的最大线程数，因为客户端可以并发向服务器端发送请求，如果Binder 驱动发现当前的线程数量已经超过设定值，就会告知 Binder server 停止启动新的线程。     </li>
<li>BINDER_SET_CONTEXT_MGR: Service Manager 专用，让它把自己设置为“Binder”大管家。系统中只有一个 Service Manager。</li>
</ul>
<h3 id="Service-Manager"><a href="#Service-Manager" class="headerlink" title="Service Manager"></a>Service Manager</h3><p>Service Manager(后面简称 SM) 也就是Binder 中的 “DNS服务器”，既然是DNS，那么在用户可以浏览网页之前就必须就位，因此SM在有人使用Binder之前就处于正常工作状态。SM 的主要工作：</p>
<ul>
<li>从Binder驱动读取消息</li>
<li>调用binder_parse 处理解析消息</li>
<li>不断循环，而且永远不会主动退出，除非出现致命错误</li>
</ul>
<p>它提供的服务应该至少包括以下几种：</p>
<ul>
<li>注册——当一个Binder Server 创建后，它们要将自己的相关信息告知 SM 备案</li>
<li>查询——应用程序可以向 SM 发起查询请求，已获知某个 Binder Server 对应的句柄。</li>
</ul>
<blockquote>
<p>SM 的查询过程很简单，主要是调用 do_find_server 遍历内部列表，并返回目标 Server；注册 Binder server 也很简单，首先在 SM 维护的数据列表中查找是否已经有对应的节点存在，，如果没有，就创建一个新的节点记录这个 Server。</p>
</blockquote>
<p>实际上，我们获取 SM 也很简单，只需要以下几步：</p>
<ol>
<li>打开Binder设备</li>
<li>执行mmap</li>
<li>通过Binder驱动向 SM 发送请求（SM 的 handle是 0）</li>
<li>获得结果</li>
</ol>
<h3 id="Binder-客户端"><a href="#Binder-客户端" class="headerlink" title="Binder 客户端"></a>Binder 客户端</h3><p>Binder 的最大消费者是Java层的应用程序，但是在各种上层的应用场景中切换“过于丝滑”，因此我们很少能感觉到Binder的存在，但是我们能够通过Android的四大组件的行为看出蛛丝马迹：</p>
<ul>
<li>Activity：通过 startActivity 可以启动目标进程，不论它是不是属于这个应用。</li>
<li>Service：任何应用程序都可以通过startService 或者 bindService 来启动特定的服务，而不论后者是不是跨进程的。</li>
<li>BroadCast：任何应用都可以通过 sendBroadcast 来发送一个广播，且无论广播接收者是不是在同一个进程中。</li>
</ul>
<p>组件的上述操作中，多数并不会特别指明要由哪个目标应用程序来响应请求，它们只需要通过Intent表达意愿，然后由系统找出最匹配的应用进程完成工作。为了更明确地说明个中的进程间通信，这里以binderService举例说明：</p>
<ol>
<li>首先Application1 填写Intent，调用 bindService 发出请求</li>
<li>在Application1的运行空间中收到 bindService 请求，这时候会与 ActivityManagerService(AMS)，这就需要得到AMS的Binder句柄，就涉及到进程间通信了（需要ServiceManage.getService）,拿到句柄后，程序才能真正向它发起请求。</li>
<li>AMS基于“最优匹配策略”，从其存储的所有服务组件中找到最符合Intent的一个，然后向它发送Service绑定请求（这也是进程间通信），如果目标进程还不存在的话，AMS还要负责将其启动</li>
<li>“被绑定”的服务进程需要响应绑定，并在完成任务后通知AMS，然后由后者回调发起请求的Application1（回调接口是ServiceConnection）。</li>
</ol>
<h3 id="Server-服务端"><a href="#Server-服务端" class="headerlink" title="Server 服务端"></a>Server 服务端</h3><p>在建立服务之后，可以有两种方式向外面提供服务：</p>
<ul>
<li>Server在ServiceManager中注册，这样，调用者只需要通过 ServiceManager.getService(NAME)就可以获得句柄，随后与之通信。</li>
<li>所谓的“匿名Server”，并不需要在ServiceManager中注册，那么Client是如何访问的呢？其实它通过其他Server作为中介，没错，就是通过一个“第三方”实名的Server，调用者首先通过ServiceManager获取这个实名的server，在由它提供匿名者的 Binder 句柄。</li>
</ul>
<h3 id="Binder-优点"><a href="#Binder-优点" class="headerlink" title="Binder 优点"></a>Binder 优点</h3><p>基于自己的理解而言，Binder具有以下优点：</p>
<ul>
<li>性能较好</li>
</ul>
<blockquote>
<p>Binder只需要拷贝一次数据，仅次于共享内存（一次都不要），消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。</p>
</blockquote>
<ul>
<li>稳定性好</li>
</ul>
<blockquote>
<p>基于C/S架构在逻辑上更清晰，client有需求，Server完成。共享内存实现起来复杂，各方没有客户端与服务端之别，要考虑并发问题以及可能出现的死锁。</p>
</blockquote>
<ul>
<li>安全性好</li>
</ul>
<blockquote>
<p>传统 Linux IPC 的接收方要么无法获得对方进程可靠的 UID/PID ，从而无法鉴别对方身份；要么只能由用户在数据包里填入UID/PID。Android 为每个应用分配了自己的UID，前面提到 C/S 架构，Server 会根据权限控制策略判断 Client 的请求是否满足权限。并且Binder机制还有匿名 Binder ，压根无法直接获取句柄，安全性更好。</p>
</blockquote>
<ul>
<li>使用简单。</li>
</ul>
<blockquote>
<p>获得句柄之后，就像调用本地方法一样方便。并且Linux的IPC方式使用C语言，而Android应用层主要使用Java，这可能也是个因素。</p>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解Android内核设计思想-林学森</tag>
      </tags>
  </entry>
  <entry>
    <title>第12章: Java内存模型与线程</title>
    <url>/2019/09/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC12%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在许多情况下，让计算机同事去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是计算机的运算速度与它的存储和通信子系统的差距太大，大量的时间都花费在磁盘I/O 、网络通信或者数据库访问上。</p><h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但也为系统引入了一个新问题：缓存一致性(Cache coherence)。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主存(Main memory)，当多个处理器的运算任务都涉及同一块主内存区域时，可能导致各自的缓存数据不一致，此时，同步回到主存时以谁的缓存数据为准呢？</p><a id="more"></a>

<p>除高速缓存外，为了使处理器内部运算单元尽量被充分利用，处理器可能会对输入代码进行乱序执行(Out-Of-Execution)优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但是并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果某个计算任务依赖另一个计算任务的中间结果，那么其顺序性不能依靠代码的先后顺序来保证。</p>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>Java 内存模型(Java Memory Model, JMM) 是用来屏蔽各种硬件和操作系统的内存访问差异。</p>
<h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java 内存模型的主要目标是定义程序中各个变量的访问规则，此处的变量(Variables) 包括 <strong>实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不存在竞争。</strong></p>
<blockquote>
<p>注意区别：如果局部变量是个refrence类型，它引用的对象在Java堆中可能被各个线程共享，但refrence本身在Java栈的局部变量表中，是线程私有的。</p>
</blockquote>
<p>Java内存模型规定所有的变量都存储在主内存(Main Memory)，每条线程还有自己的工作内存(Working Memory)，这两个分别可以类比物理模型中的主内存以及处理器的高速缓存。线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。</p>
<blockquote>
<p>关于副本拷贝，假设线程访问一个10MB 的对象，那会不会也拷贝出来呢？虚拟机基本上不会这么实现，只有对象的引用、对象中某个在线程中访问到的字段是可能存在拷贝的。还有，<strong>这里所讲的主内存、工作内存 与 前面讲的Java堆、栈、方法区等并不是同一个层次的内存划分，二者并没有关系。</strong></p>
</blockquote>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>Java 内存模型中定义了以下8种操作来完成从主内存拷贝到工作内存，以及从工作内存同步回主内存：</p>
<ul>
<li>lock（锁定）：对主内存变量标识为某一条线程独占。    </li>
<li>unlock（锁定）：对主内存变量标识为解锁。    </li>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存，以便后面的load操作。    </li>
<li>load（载入）：作用于工作内存变量，把read操作从主内存得到的变量值放入工作内存的变量拷贝中。    </li>
<li>use（使用）：作用于工作内存变量。把工作内存中一个变量的值传递给执行引擎。当虚拟机遇到一个需要使用到变量的值的字节码指令时执行这个操作。    </li>
<li>assign（赋值）：作用于工作内存变量。把一个从执行引擎接收到的值赋值给工作内存的变量。当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。    </li>
<li>store（存储）：作用于工作内存变量。把工作内存中一个变量的值传送到主内存中，以便随后的write操作。    </li>
<li>write（写入）：作用于主内存变量。把store操作从工作内存中得到的变量的值放入主内存的变量中。    </li>
</ul>
<p>如果要把一个变量从主内存复制到工作内存，那就要顺序地执行 read 和 load 操作（<strong>只是顺序地执行，不保证连续执行，中间是可以插入其他指令的</strong>），如果要把变量从工作内存同步回主内存，就要顺序地执行 store 和 write 操作。并且，Java 内存模型要求执行上述操作必须满足下列条件：</p>
<ul>
<li>read 和 load、store 和 write  必须成对出现，不许单独出现。    </li>
<li>变量在工作内存中改变了之后，必须要同步回主内存，即不允许丢弃它最近的 assign 操作；并且如果没有发生assign，则不允许同步回主内存。     </li>
<li>对一个变量 use、store 之前，必须先执行过了 assign 和 load 。     </li>
<li>一个变量在同一时刻只允许一条线程执行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次 lock 后，只有执行相同次数的 unlock 操作后变量才能被解锁。     </li>
<li>如果对一个变量执行 lock 操作，那会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量值。     </li>
<li>如果变量没有被 lock 锁定，那就不允许对它执行 unlock ，也不允许 unlock 一个被其他线程 lock 住的变量。     </li>
<li>对变量执行 unlock 之前，必须把此变量同步回主内存中（执行 store、write 操作）。    </li>
</ul>
<h3 id="对于-volatile-型变量的特殊规则"><a href="#对于-volatile-型变量的特殊规则" class="headerlink" title="对于 volatile 型变量的特殊规则"></a>对于 volatile 型变量的特殊规则</h3><p>volatile 可以说是Java虚拟机提供的最轻量级的同步机制。这里首先以不正式但通俗易懂的语言来介绍这个关键字的作用，当一个变量定义为 volatile 后，它将具备两种特性：</p>
<ul>
<li>第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对其他线程来说是可以立即得知的。而普通变量是做不到这一点的。     </li>
<li>第二个语义是禁止指令重排序优化。    </li>
</ul>
<p>关于volatile 变量的可见性，经常会有开发人员误解，认为 “volatile 变量在各个线程中是一致的，所以基于 volatile 变量的运算在并发下是安全的”，<strong>因为事实上我们不能得出“基于 volatile 变量的运算在并发下是安全的” 这样的结论，因为虽然volatile变量在各个线程的工作内存中不存在一致性问题(由于每次使用之前都要先刷新，所以执行引擎看不到一致的情况，所以可以认为不存在一致性问题)，但Java里面的运算并非原子操作，所以导致 volatile 变量的运算在并发下一样是不安全的。</strong>通过以下简单代码可以演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                        <span class="comment">//System.out.println(race);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待所有累加线程都结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：我个人运行这段代码的时候，并不能正常打印，因为while循环中的 Thread.activeCount()  一直是2，只有把 for 循环中的 System.out.println(race) 放开才能打印，我的环境是： Android Studio 3.5 + jre1.8 。</strong>,如果并发正确的话，最终输出结果应该是 200000，但实际运行的结果大概率会是一个小于 200000 的数字。为什么呢？问题出在 increase() 方法中的 race++ 操作上，我们可以<strong>使用javap命令反编译</strong>这个函数的代码得到如下的字节码：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%89%88/%E7%AC%AC12%E7%AB%A0/increase%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="increase方法字节码"></p>
<p>发现只有一行代码的increase方法在class文件中是由4条字节码指令构成的(return 不是由 race++ 产生的)，所以很容易分析出并发失败的原因了：当getstatic 指令把 race 的值取到操作栈顶时，volatile 可以保证 race 的值是正确的、最新的，但在执行 iconst_1、iadd 这些指令的时候，其他线程可能已经把 race 的值增大了，所以最后执行 putstatic 指令后可能把较小的 race 值同步回了主内存中。</p>
<blockquote>
<p>客观地说，此处用字节码来分析问题仍然是不严谨的，因为即使编译出来只有一条字节码指令，也并不意味着这条指令就是一个原子操作，一条字节码在执行时，解释器往往要运行多行代码才能实现它的语义。如果是编译执行，一条字节码可能会转化成若干条本地机器码指令。但考虑阅读方便，并且字节码已经够说明问题，所以此处选用字节码分析。</p>
</blockquote>
<p>以上代码说明volatile 在并发运行中可能出现的问题，但是如下代码场景就很适合使用 volatile 变量来控制并发，当shutdown 方法调用时，能保证所有线程中执行的 doWork() 方法都能停下来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> stopThread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stopThread = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!stopThread)&#123;</span><br><span class="line">        <span class="comment">//do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>volatile 禁止指令重排序优化仍然不太容易理解，通过以下伪代码来看看为何指令重排序会干扰程序的并发执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="keyword">char</span>[] configText;</span><br><span class="line"><span class="comment">//此变量必须定义为 volatile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设以下代码在线程 A 中执行，模拟读取配置信息，读取</span></span><br><span class="line"><span class="comment">//完成后，将 initialized 设置为 true 以通知其他线程</span></span><br><span class="line">configOptions = <span class="keyword">new</span> HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText,configOptions);</span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设以下代码在线程 B 中执行，等待 initialized 为 true ，</span></span><br><span class="line"><span class="comment">//代表线程 A 已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span>(!initialized)&#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用线程 A 中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure>

<p>这个场景十分常见，只是我们在处理配置文件时一般不会出现并发而已。如果 initialized 没有使用 volatile 修饰，就可能由于指令重排序优化，导致 initialized = true 被提前执行(指令重排序优化是机器级的优化操作，这里说的提前执行是指对应的汇编代码提前执行)，这样线程 B 中使用配置信息的代码就可能出现错误，而volatile 可以避免此类情况发生。以下再举个例子来说明 volatile 关键字是如何禁止指令重排序优化的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingleTon instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，这段代码对instance变量赋值部分如下代码所示：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%89%88/%E7%AC%AC12%E7%AB%A0/%E5%8D%95%E4%BE%8B%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="单例编译后代码清单"></p>
<p>可以对比 instance 有被volatile修饰和没有被修饰的编译后的代码，会发现，关键变化在于有 volatile 修饰的变量，在赋值(mov %eax,0x150(%esi) 这句就是赋值操作)，之后<strong>会多执行一个 lock 操作，这个操作是一个内存屏障，令重排序时不能把后面的指令重排序到内存屏障之前的位置</strong>。只有一个cpu访问内存时，并不需要内存屏障；但如果有两个或更多cpu访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性。这操作也相当于做了一次 store 和 write 操作，引起其他cpu（或内核）对于这个变量的无效化，因此保证了 volatile 变量的修改对其他cpu立即可见。</p>
<blockquote>
<p>在某些情况下，volatile 的同步机制的性能确实要优于锁，但是虚拟机对锁实行许多消除和优化，所以我们很难量化地认为 volatile 的同步机制比锁快多少。但是可以肯定的是：volatile 变量的读操作与普通变量几乎没差别，但写操作可能会慢一些，因为它需要需要在本地代码中插入内存屏障保证处理器不乱序执行。</p>
</blockquote>
<h3 id="long-和-double-型变量的特殊规则"><a href="#long-和-double-型变量的特殊规则" class="headerlink" title="long 和 double 型变量的特殊规则"></a>long 和 double 型变量的特殊规则</h3><p>long 和double 都是64位数据类型，内存模型允许虚拟机将没有被 volatile 修饰的64位数据类型的读写操作分为两次32位操作来进行，可能会导致某些线程读到”半个变量”的数据，不过这种情况十分罕见(目前商用Java虚拟机不会出现)，所以了解这回事即可。</p>
<h3 id="原子性、可见性-与-有序性"><a href="#原子性、可见性-与-有序性" class="headerlink" title="原子性、可见性 与 有序性"></a>原子性、可见性 与 有序性</h3><p>整体回顾一下Java内存模型，Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性3个特征来建立的。</p>
<ul>
<li><p>原子性(Atomicity)：read、load、assign、use、store 和 write 操作是保证原子性的，基本数据类型的访问读写也是具有原子性的。如果要保证更大范围的原子性，Java 内存模型还提供了 lock 和 unlock 来满足这种需求。</p>
</li>
<li><p>可见性。可见性指一个线程修改了共享变量的值，其他线程能立即得知这个修改。除了volatile 之外，Java还有两个关键字能实现可见性，即 synchronize 和 final 。同步块的可见性是由 “对一个变量执行unlock操作前，必须把此变量同步回主内存中” 获得的。<strong>而final修饰的字段在构造器中一旦初始化完成，并且构造器没有把 “this”的引用传递出去(this引用逃逸是很危险的，其他线程可能通过这个引用访问到”初始化了一半”的对象)，那在其他线程中就能看到 final 字段的值。</strong></p>
</li>
<li><p>有序性。Java 程序中有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果从一个线程观察另一个线程，所有操作都是无序的。前者指“线程内表现为串行语义” ，后者指“指令重排序”和“工作内存与主内存同步延迟” 现象。Java 语言提供了 volatile 和 synchronized 来保证线程之间操作的有序性，前者本身包含了指令重排序的语义；后者通过 “一个变量在同一个时刻只允许一条线成对其进行lock操作”决定了持有同一个锁的两个同步块只能串行进入。</p>
</li>
</ul>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>这块理论性的总结性的内容，个人觉得就先不写了。</p>
<h2 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>这块的内容在<a href="https://glassx.github.io/2018/05/29/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-%E7%AC%AC2%E7%AB%A0/" target="_blank" rel="noopener">操作系统的内容</a>中有描述：</p>
<ol>
<li>使用内核线程实现（每个内核线程对应一个轻量级进程）；    </li>
<li>使用用户线程实现（创建销毁开销小，没有内核支援，处理诸如阻塞等问题异常困难）；    </li>
<li>使用用户线程+轻量级进程混合实现（即内核线程和用户线程一起使用，n: m 的关系）。    </li>
</ol>
<h3 id="Java-线程调度"><a href="#Java-线程调度" class="headerlink" title="Java 线程调度"></a>Java 线程调度</h3><p>线程调度的方式主要有两种： 协同式线程调度(Cooperative Threads-Scheduling) 和 抢占式线程调度(Preemptive Threads-Scheduling)。前者靠线程自觉，线程执行时间由线程自己控制，后者每个线程由系统分配时间，Java 使用后者。</p>
<p>虽然Java线程调度是系统自动完成的，但是我们可以给线程设置优先级来“建议”系统给某些线程多一些时间。但给线程设置优先级还是不靠谱的，原因如下：</p>
<ol>
<li><p>Java 线程是通过映射到系统的原生线程上来实现的，不同的系统上的优先级与Java的线程优先级等级基本上对应不上。可能你在Java中指定的2个优先级，在某操作系统上映射成同一个优先级。</p>
</li>
<li><p>优先级可能会被系统自行改变。</p>
</li>
</ol>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java 语言定义了5种线程状态，在任一时间点，一个线程只能有且只有其中的一种状态：</p>
<ul>
<li>新建(New)：创建后尚未启动。    </li>
<li>运行(Runnable)：可能在执行，也有可能在等待 CPU 分配时间。    </li>
<li>无限期等待(Waiting)：这种状态下不会被 CPU 分配时间，要等其他线程显式地唤醒。     </li>
</ul>
<blockquote>
<p>以下方法会让线程陷入无限期等待：<br>没有设置 Timeout 参数的 Object.wait() 方法。<br>没有设置 Timeout 参数的 Thread.join() 方法。<br>LockSupport.park() 方法。     </p>
</blockquote>
<ul>
<li>限期等待(Timed Waiting)：这种状态下不会被 CPU 分配时间，不过无需等待其他线程显式唤醒，在一定时间后由系统自动唤醒。</li>
</ul>
<blockquote>
<p>以下方法会让线程进入限期等待：<br>Thread.sleep() 方法。<br>设置了 Timeout 参数的 Object.wait() 方法。<br>设置了 Timeout 参数的 Thread.join() 方法。<br>LockSupport.parkNanos() 方法。<br>LockSupport.parkUtil() 方法。     </p>
</blockquote>
<ul>
<li><p>阻塞(Blocked)：阻塞状态是在等待获取一个排他锁。</p>
</li>
<li><p>结束(Terminated)：线程已经执行结束。</p>
</li>
</ul>
<p>线程状态转换图如下：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%89%88/%E7%AC%AC12%E7%AB%A0/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt="线程状态转换图"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章：Binder进程间通信系统</title>
    <url>/2019/09/15/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90-%E7%AC%AC5%E7%AB%A0/</url>
    <content><![CDATA[<p>Android 应用程序由 Activity、Service、Broadcast Receiver 和 Content Provider 四中组件构成，它们可能运行在不同的进程中。此外，各种系统组件也运行在独立的进程中，如 Activity 管理服务 ActivityManagerService 和 package 管理服务 PackageManagerService 都运行在系统进程 System 中。</p><a id="more"></a>
<p>Android 是基于 Linux 内核开发的，Linux 内核提供了丰富的进程间通信机制：管道(Pipe)、信号(Signal)、消息队列(Message)、共享内存(Share Memory) 和 套接字(Socket) 等。但Android 系统并没有采用这些传统的进程间通信机制，而是使用了新的机制——Binder。与传统的进程间通信机制相比，<strong>Binder 进程间通信机制在进程间传输数据时，只需要执行一次复制操作，不仅提高了效率，并且节省了内存空间。</strong></p>
<blockquote>
<p>使用共享内存在进程间传输数据的时候，虽然也只需要进行一次复制操作，但是它一般要结合其他的进程间通信机制来同步信息。</p>
</blockquote>
<p>Binder 进程间通信机制采用 C/S 通信方式，提供服务的进程称为 Server 进程，而访问服务的进程称为 Client 进程，同一个 Server 进程可以同时运行多个组件来向 Client 提供服务；而同一个 Client 进程也可以同时向多个 Service 组件请求服务。Service 组件启动时，会将自己注册到一个 Service Manager 组件中，以便 Client 组件可以通过 Service Manager 组件找到它。Binder 进程间通信机制中涉及了 Client、Service、Service Manager 和 Binder 驱动程序四个角色的关系如下图所示：</p>
<p><img src="/assets/Book-Notes/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90(%E7%AC%AC%E4%B8%89%E7%89%88)/%E7%AC%AC5%E7%AB%A0/Binder%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.png" alt="Binder通信机制"></p>
<p>Client、Service 和 Service Manager 都运行在用户控件，而Binder 驱动程序运行在内核控件。Client、Service 和 Service Manager 均是通过系统调用 open(打开)、mmap(内存映射)、ioctl(在用户空间，使用ioctl系统调用来控制设备) 来访问设备文件 /dev/binder ，从而实现与Binder驱动的程序的交互，而交互的目的就是为了能够间接执行进程间通信。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深Android系统源代码情景分析(第三版)</tag>
      </tags>
  </entry>
  <entry>
    <title>第13章: 线程安全与锁优化</title>
    <url>/2019/09/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC13%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>并发处理的广泛应用使得 Amdahl 定律替代摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程问题，更无须自己采取任何措施来保证多线程的正确调用。</p><a id="more"></a>

<h2 id="Java-线程安全"><a href="#Java-线程安全" class="headerlink" title="Java 线程安全"></a>Java 线程安全</h2><p>为了更深入地理解线程安全，在这里我们可以不把线程安全当做一个非真即假的二元排他选项来看待。按照线程安全的“安全程度”由强至弱来排序，我们可以将Java语言各种操作共享的<strong>数据</strong>分为：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>不可变(Immutable) 的对象一定是线程安全的，只要一个不可变对象被正确地创建构建出来(没有发生this引用逃逸的情况)，那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态。</p>
<p>Java 语言中，如果共享数据是一个基本数据类型，只要在定义时使用final关键字就可以保证它是不可变的；如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响，有很多途径去实现这个目的，最简单的就是把对象中带有状态的变量都声明为final，这样，在构造函数结束之后，它就是不可变的。</p>
<blockquote>
<p>Java API 中复合不可变要求的类型，有String、枚举类型、Long、Double以及BigInteger、BigDecimal等大数据类型，但同为Number的子类型的原子类 AtomicInteger 和 AtomicLong 则并非不可变的。</p>
</blockquote>
<h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><p>绝对线程安全通常需要付出很大的，甚至有时候是不切实际的代价。<strong>在Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全</strong>。我们可以通过一个不是“绝对线程安全”的线程安全类来看看这里的“绝对”是什么意思。</p>
<p>Java程序员基本上都认为 java.util.Vector 是一个线程安全的容器，因为它的add、get、size等方法都被 synchronized 修饰的，尽管这样效率很低，但确实是安全的。但是，即使所有方法都被修饰成同步，也并不意味着调用它的时候永远不需要同步手段了，看如下测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread prindThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        System.out.println(vector.get(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            removeThread.start();</span><br><span class="line">            prindThread.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不要同时产生过多线程，否则导致操作系统假死</span></span><br><span class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">20</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码运行过程中会出现 ArrayIndexOutOfBoundsException，但是在我自己写代码验证的时候，感觉这个错误还是很容易被忽略的，运行了好长时间都还在一直输出，但其实早就报错了，但不知道怎么程序还是正常运行。这点在自己验证的时候要注意一下，我的运行环境是：Android studio 3.5 + jre 1.8 。</p>
<p>可能你一开始也会和我一样懵逼了，这 Vector 里面每个方法都被 synchronized 关键字修饰，这种情况下调用方法锁定的是对象，虽说synchronized 可以重入，但是上述代码添加、删除、遍历 可是在3个线程当中啊，压根就是互斥的啊，怎么会报错呢？</p>
<p>原来，我们忽略了一个重要因素：原子操作。在 prindThread 线程中，for 循环会读取 vector.size ，它会先获取锁，然后读取值，假设值是 10，之后释放锁(注意，问题就在这了)，接下来print的时候，假设当前i是7，通过 vector.get(i) 读取元素的时候，会再次加锁，但是由于此时 vector 的size 不知道已经变成多少了，如果此时变成了 6，那么这个 get 操作就会发生越界了。</p>
<p>如果remove线程恰好在一个错误的时间里删除了一个元素，导致序号i已经不再可用的话，再用vector.get(i) 访问就会抛出 ArrayIndexOutOfBoundsException。如果要保证这段代码的正确运行，书上给出的方案是把两个thread改成如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (vector)&#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                            vector.remove(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread prindThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (vector)&#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                            System.out.println(vector.get(i));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><p>相对线程安全就是我们通常意义上所讲的线程安全，它需要保证这个对象单独的操作是线程安全的，我们在调用的时候无需做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。Java语言中，Vector、HashTable、Collections的synchronizeCollection() 方法包装的集合等。</p>
<h3 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h3><p>线程兼容指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。Java API 中大部分类都是属于线程兼容的，如 ArrayList 和 HashMap 等。</p>
<h3 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h3><p>线程对立是指无论调用端是否采取同步措施，都无法再多线程环境并发使用，如 Thread 类的suspend() 和 resume() 方法，如果两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发的话，无论是否进行了同步，都会存在死锁风险(这两个方法在jdk中已经被声明放弃了)。这类代码很少出现，我们也应该避免。</p>
<h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><p>这听起来是代码编写的问题，但虚拟机提供的同步和锁机制也起到了非常重要的作用。只要读者了解了虚拟机线程安全手段的运作过程，自己去思考代码如何编写并不是一件困难的事情。</p>
<h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只能被一个(或者是一些，使用信号量的时候)线程使用，而互斥是实现同步的一种手段。互斥是因，同步是果；互斥是方法，同步是目的。</p>
<p>Java中最基本的互斥同步手段是 synchronize 关键字，经过编译后，会在同步快的前后分别形成 monitorenter 和 monitorexit 两个字节指令，<strong>这两个字节码都需要 reference 类型的参数来指明要锁定和解锁的对象</strong>。如果Java程序中的synchronize 指明了对象参数，那就是这个对象的 reference ；<strong>如果没有明确指定，那就根据 synchronize 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。</strong></p>
<p>根据虚拟机规范，执行 monitorenter 时首先尝试获取对象的锁，如果没有被锁定，或者当前线程已经拥有这个锁，就把锁的计数器 +1 ，相应地，monitorexit 时减 1 。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被释放。</p>
<p><strong>这里有2点是要注意的：synchronize 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题；其次，同步块在已进入的线程执行完之前，会阻塞后面的线程，前面提到过，Java的线程是映射到操作系统的原生线程上的，如果要阻塞或者唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转到核心态中，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块(如被synchronize修饰的getter() 或 setter() 方法)，状态转换消费的时间可能比代码执行时间还要长，所以 synchronize 是 Java 语言中一个重量级(Heavyweight)操作。</strong></p>
<p>还可以使用 ReetrantLock 来实现同步，它的基本用法与 synchronize 相似，<strong>都具备线程重入性</strong>，只是 ReetrantLock 表现为API语法层面的互斥锁(lock 和 unlock 方法配合 try/finally 语句块来完成)，synchronize 表现为原生语法层面的互斥锁。不过，ReetrantLock 增加了一些高级功能，主要有以下3项：</p>
<ul>
<li>等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待。    </li>
<li>公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁：而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronize 是非公平的，ReetrantLock 默认也是非公平的。    </li>
<li>锁绑定多个条件是指一个 ReetrantLock 对象同时可以绑定多个 Condition 对象。而synchronize 中，锁对象的 wait 、notify或者 notifyAll 方法可以实现一个隐含的条件是：如果要和多于一个的条件关联的时候，就要额外地添加一个锁。而 ReetrantLock 无需这样做，只需要多次调用 newCondition 方法即可。</li>
</ul>
<p>在JDK 1.6以前，synchronize 的吞吐量会随着竞争的激烈程度增加而急剧下降，但 ReetrantLock 却基本保持在平稳水平。<strong>但随着后面的优化，二者的性能基本上持平了，并且虚拟机在未来的性能改进中更倾向于原生的 synchronize ，所以还是提倡在 synchronize 能实现需求的情况下，优先考虑使用 synchronize 来同步</strong>。</p>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>互斥同步最主要的问题就是线程阻塞和唤醒带来的性能问题，因此也称为阻塞同步，这是一种悲观的并发策略，总认为不去做正确的同步措施，就肯定会出问题。随着硬件指令集的发展（因为我们需要操作和冲突检测这两个步骤具备原子性，只能靠硬件来保证，如果使用互斥同步就失去意义了），我们有了另一个选择：基于冲突检测的乐观并发策略，通俗讲就是先操作，如果没有其他线程竞争，操作就成功了；如果有竞争产生了冲突，再采取其他补偿措施（常见的措施就是不断重试，直到成功）。这种策略无需把线程挂起，因此称为非阻塞同步。</p>
<blockquote>
<p>指令集发展后，可以确保一个从语义上看起来需要多次操作的行为只需要一条处理器指令就能完成，其中最重要的指令为 ：比较并交换(Compare-and-Swap) ，下文简称 CAS，它的语义是：内存地址V，旧的预期值 A,新值 B，当且仅当 V 符合旧预期值 A 是，处理器就用新值 B 更新 V，否则就不更新。</p>
</blockquote>
<p>不妨拿一段在第 12 章中没有解决的问题代码来看看如何使用CAS操作来避免阻塞同步，我们曾通过这段20个线程自增 10000 此的代码来证明 volatile 变量不具备原子性，那如何才能让它具备原子性？把 “race ++ “ 操作或 increase() 方法用同步块包裹起来当然是一个办法，但如果改成如下代码，效率会提高很多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger race = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        race.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; THREADS_COUNT;i++)&#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; <span class="number">10000</span>;i++)&#123;</span><br><span class="line">                    increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(race);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>运算结果： 200000</p>
<p>使用AtomicInteger代替int后，程序输出了正确地结果，一切要归功于incrementAndGet 方法的原子性，它的实现非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(compareAndSet(current,next))&#123;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>incrementAndGet 方法在一个无限循环中，不断尝试将一个比自己当前值大1的新值赋给自己，如果失败了，那说明在执行“获取-设置”操作的时候值已经有了修改，于是再次循环进行下一次操作，直到设置成功为止（设置成功才return 跳出循环）。</p>
<blockquote>
<p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A，这就有可能是这段期间它的值曾经被改成了B，后来又被改成了A，那 CAS 操作就会误认为它从来没被改变过，这称为 “ABA” 问题。如果需要解决 “ABA” 问题，改用传统的互斥同步会比原子类更高效。</p>
</blockquote>
<h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>如果一个方法本来就不涉及共享数据，那它自然无需任何同步措施。这种代码是天生线程安全的，这里简单介绍其中两类：</p>
<ul>
<li><p>可重入代码：这种代码可以在任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。可重入代码有一些共同特征，如 不依赖存储在堆上的数据和公用的系统资源，用到的状态量都是由参数中传入、不调用 非可重入的方法等。   </p>
</li>
<li><p>线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看这些共享数据代码是否能保证在同一个线程中执行，如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内。</p>
</li>
</ul>
<blockquote>
<p>符合这种特点的应用并不少见。一个应用实例就是web交互模型中“一个请求对应一个服务器线程”的处理方式</p>
</blockquote>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>JDK 1.6 实现了各种锁优化技术，如适应性自旋、锁消除、锁粗化、轻量级锁 和 偏向锁 等，这些技术都是为了在线程之间更高效地共享数据。</p>
<h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>在讨论互斥同步的时候，提到了阻塞对性能影响最大。虚拟机开发团队注意到在许多应用上，共享数据锁定状态只会持续很短时间，为这段时间去挂起和恢复线程不值得。我们可以让后面的请求锁的线程“稍等一下”，但不放弃处理器的执行时间，看锁是否被很快释放。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓<strong>自旋锁</strong>。</p>
<blockquote>
<p>自旋本身避免了挂起和恢复过程，但是它占用cpu时间，如果锁被占用的时间很短，这是值得的；反之，如果锁被占用的时间过长，则白白消耗处理器资源，因此需要有一定限度，限定自旋次数。</p>
</blockquote>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>如果代码上要求同步，但是被检测到不可能存在共享数据竞争，就可以对锁进行消除，锁消除的主要判定依据来源于逃逸分析的数据支持。也许读者会有疑问，变量逃逸，对于虚拟机来说需要使用数据流分析来确定，但是程序员自己应该很清楚，怎么会在明知道不存在数据竞争的情况下要求同步呢？答案是：有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中普遍存在，来看看下面例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1,String s2,String s3)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，String 是个不可变的类，对字符串的连接操作总是通过生成新的String来进行。JDK 1.5 前，String 连接会转化为 StringBuffer对象的连续 append 操作，1.5 及以后的版本会转化为 StringBuilder 对象的连续 append，即上述代码可能会变成以下的样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1,String s2,String s3)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在大家还认为这段代码没有涉及同步吗？每个 StringBuffer.append 方法中都有一个同步块，锁就是sb对象。虚拟机很快会发现它的动态作用域被限制在 concatString 方法内部，永远不会被逃逸到方法外，因此，虽然这里有锁，也可以被安全地消除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，<strong>这是为了使需要同步的操作数量尽可能变小，让等待的线程尽快拿到锁。</strong>大部分情况下这原则是正确的。</p>
<p>但是，如果一系列连续操作都是对同一个对象反复加锁和解锁，甚至加锁操作是在循环体中，频繁地进行互斥同步操作会导致不必要的性能消耗。上述代码中连续的 append 方法就属于此类范围，虚拟机会把加锁同步的范围扩展(粗化)到整个操作序列的外部，就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是相对于传统的锁机制而言的，首先强调的一点是，<strong>轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</strong></p>
<p>要理解轻量级锁，必须从HotSpot虚拟机的对象（对象头部分）的内存布局开始介绍。HotSpot虚拟机的对象头分为两部分：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄等，官方称为 “Mark Word”，它是实现轻量级锁和偏向锁的关键。第二部分用于存储指向方法区对象类型数据的指针。</p>
<p>在代码进入同步块的时候，如果此同步对象没有被锁定——Mark Word 中锁标记位为 “01”，则虚拟机首先将在当前线程的栈帧中建立一个名为<strong>锁记录(Lock Record)</strong>的空间，用于存储锁对象目前的 Mark Word 的拷贝，然后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，如果这个更新动作成功了，那么这个县城就拥有了该对象的锁，并且将对象的 Mark Word 的锁标志位转变为 “00” ，表示对象处于轻量级锁定状态。</p>
<p>如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志位变为 “10” ，后面等待锁的线程也要进入阻塞状态。</p>
<p>上面描述的是加锁过程，解锁过程也是通过CAS 操作来进行的，如果对象的 Mark Word 仍然指向线程的锁记录，那就用 CAS 操作把当前对象的的 Mark Word 和 线程中复制的 Mark Word 替换，如果替换成功，整个同步过程完成。如果替换失败，说明其他线程尝试过获取该锁，那么在释放锁的同时，唤醒被挂起的线程。</p>
<blockquote>
<p>轻量锁的依据是“绝大部分锁，在整个同步周期内都是不存在竞争的”，这是经验数据，如果没有竞争，轻量级锁使用CAS 操作避免了使用互斥量的开销；如果存在锁竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此会比传统重量级锁更慢。</p>
</blockquote>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>如果说轻量级锁是在无竞争情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</p>
<p>假设当前虚拟机启用了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机会把对象头中的标志位设置为 “01”，即偏向模式。同时，使用CAS操作把获取到这个锁的线程ID记录在对象的 Mark Word 之中，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。</p>
<p>当另外一个线程去尝试获取这个锁时，偏向模式就结束。根据锁对象目前是否处于被锁定状态，撤销偏向后恢复到 未锁定(标志位 01) 或 轻量级锁定(标志位 00)的状态，后续的同步操作就如上面介绍的轻量级锁执行。</p>
<blockquote>
<p>偏向锁可以提高带有同步但无竞争的程序的性能，它不一定总是对程序运行有利。如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。因此，有时候禁止使用偏向锁反而可以提升性能。</p>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)</tag>
      </tags>
  </entry>
  <entry>
    <title>第10章：早期（编译期）优化</title>
    <url>/2019/09/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC10%E7%AB%A0/</url>
    <content><![CDATA[<p>Java语言的“编译期”是一段“不确定”的操作过程，它可能是指一个前端编译器把.java文件转变成 .class 的过程，也可能是指JIT编译器把字节码变成机器码的过程，还能是指 ATO编译器直接把 .java 文件编译成本地代码的过程。最符合大家认知的应该是第一类，在本章中，我们提到的 “编译期” 以及 “编译器” 都指限于第一类过程。</p><a id="more"></a>
<h2 id="Javac-编译器"><a href="#Javac-编译器" class="headerlink" title="Javac 编译器"></a>Javac 编译器</h2><p>前面很多个人觉得只有写编译器才能用得着的内容，先略过。</p>
<p><strong>标注检查：</strong>javac的编译过程包含标注检查，标注检查的内容包括诸如变量使用前是否已经被声明，变量与赋值类型是否匹配等。此外，标注检查还有一个重要动作称为<strong>常量折叠</strong>，如果我们在代码中谢了如下定义：</p>
<blockquote>
<p>int a = 1 + 2;</p>
</blockquote>
<p>那么在语法树上仍然能看到字面量“1”、“2” 以及操作符 “+”，但是经过常量折叠后，他们将会被折叠为字面量 “3”，由于编译期进行了常量折叠，因此在代码中定义 “a = 1 + 2” 与直接定义 “a = 3” 的cpu指令运算量是一样的，并不会增加额外的哪怕一个cpu指令开销。数据及控制流分析是对程序上下文逻辑的进一步验证，以下举一个关于 final 修饰符的数据及控制流分析的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一有final修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二没有final修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个 foo() 方法中，在代码编写时程序肯定会受到 final 修饰符的影响，不能再改变第一个方法的 arg 和 var 变量的值，但是<strong>这两段代码编译出来的Class 文件是没有任何区别的</strong>。通过 <a href="https://glassx.github.io/2019/07/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC6%E7%AB%A0/" target="_blank" rel="noopener">第六章</a> 的内容可知，局部变量与字段(实例变量、类变量) 是有区别的，前者在常量池中没 CONSTANT_Fieldref_info 符号引用，自然也没有访问标志（Access_Flags）的信息，甚至可能连名称也不会保留下来(取决于编译时的选项)，自然在Class文件中不可能知道一个布局变量是不是声明为 final 了，因此，<strong>将局部变量声明为 final 对运行是没有影响的，变量的不可变性仅仅由编译器在编译期间保障</strong>。</p>
<h2 id="Java-语法糖的味道"><a href="#Java-语法糖的味道" class="headerlink" title="Java 语法糖的味道"></a>Java 语法糖的味道</h2><p>语法糖可以看做编译器实现的一些 “小把戏” ，这些小把戏不会提供实质性的功能改进，但它可能会使得效率“大提升”，但我们也应该去了解这些“小把戏”背后的真实世界，那样才能利用好它们，而不是被它们迷惑。</p>
<h3 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h3><p>Java中的类型，本质是<strong>参数化类型(Parametersized Type)</strong>的应用，也就是说所操作的数据类型被指定为一个参数。泛型技术在Java 和 C# 之中的使用方式看似相同，但实现上却有根本性的分期，C# 中的泛型无论在程序源码中、编译后的IL（中间语言）中或是运行期的 CLR 中，都是切实存在的， List <int> 与 List <string> 就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现方式称为类型膨胀，基于这种方法实现的泛型称为真实泛型。</string></int></p>
<p>Java 语言中的泛型规则不一样，它们只在源码中存在，在编译后的字节码文件中就已经替换为原来的原声类型了，因此，对于运行期的Java语言来说， ArraList <integer> 与 ArrayList <string> 就是同一个类，所以泛型技术实际上是Java的一颗语法糖，这种实现方法称为“类型擦除”，基于这种方法实现的泛型称为 伪泛型。可以通过代码反编译来查看Java泛型实现过程：</string></integer></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">	map.put(<span class="string">"hello"</span>,<span class="string">"你好"</span>);</span><br><span class="line">	map.put(<span class="string">"how are you"</span>,<span class="string">"吃了吗"</span>);</span><br><span class="line">	Systemt.out.println(map.get(<span class="string">"hello"</span>));</span><br><span class="line">	Systemt.out.println(map.get(<span class="string">"how are you"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把这段代码编译成 Class 文件，再用子界面反编译工具反编译成Java代码，会发现代码变成如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">	map.put(<span class="string">"hello"</span>,<span class="string">"你好"</span>);</span><br><span class="line">	map.put(<span class="string">"how are you"</span>,<span class="string">"吃了吗"</span>);</span><br><span class="line">	Systemt.out.println((String)map.get(<span class="string">"hello"</span>));</span><br><span class="line">	Systemt.out.println((String)map.get(<span class="string">"how are you"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现，反编译回来的 Map 定义都变成了 <strong>Map map = new HashMap()</strong>，输出的时候，是靠强转实现的，也就是把object转为程序员写的实际类型。Java 的伪泛型招致很多批评的声音，不过这种实现方式在某些情况下丧失了泛型思想应有的一些优雅，比如在类中存在如下两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">	    System.out.println(<span class="string">"invoke method(List&lt;String&gt; list)"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">	    System.out.println(<span class="string">"invoke method(List&lt;Integer&gt; list)"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考一下，这段代码是否正确。也许你已经知道了，这段代码是不能被编译的，因为List<string> 与 List<integer> 编译后都被擦除了，变成了一样的原生类型 List<e> ,擦除动作导致这两种方法的特征签名变得一样。初看起来，无法重载的原因找到了，但真的如此吗？其实，泛型擦除成相同的原生类型只是无法重载的原因之一，接着看下面的代码：</e></integer></string></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">	    System.out.println(<span class="string">"invoke method(List&lt;String&gt; list)"</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">	    System.out.println(<span class="string">"invoke method(List&lt;Integer&gt; list)"</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	    method(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">	    method(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行发现，不但可以编译还能正常输出结果：</p>
<blockquote>
<p>System.out.println(“invoke method(List <string> list)”)<br>System.out.println(“invoke method(List <integer> list)”)</integer></string></p>
</blockquote>
<p>为两个方法添加了不同的返回值之后，方法重载居然成功（<strong>注意，仅仅只是在jdk 1.6及以下才能编译通过，高版本是编译不通过的，但在书上是没有这个版本说明的，而我们读者只需要知道有这么个事情就行</strong>）了，这是对Java语言中返回值不参与重载选择的基本认知的挑战吗？当然不是的，之所以能够编译成功，是<strong>因为两个 method 方法加入了不同的返回值之后，能够共存在同一个 Class 文件了。</strong>由于这只是针对低版本的功能，故此处不多解释了。</p>
<h3 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h3><p>这几个专门拿出来讲只是因为它们是Java语言中使用得最多的<strong>语法糖</strong>。可以通过以下代码看看这些语法糖在编译后会发生什么变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list =  Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: list)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Systemt.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码在自动装箱、拆箱与遍历循环编译后，变成以下样式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">        Integer.valueOf(<span class="number">1</span>),</span><br><span class="line">        Integer.valueOf(<span class="number">2</span>),</span><br><span class="line">        Integer.valueOf(<span class="number">3</span>),</span><br><span class="line">        Integer.valueOf(<span class="number">4</span>),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(Iterator localIterator = list.iterator();localIterator.hasNext();)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)localIterator.next()).intValue();</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Systemt.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码一共包含自动装箱、自动拆箱、遍历循环与变长参数5种语法糖。遍历循环还原成了迭代器的实现，而变长参数则是通过数组的方式转变。语法糖看起来简单，但是也有很多需要注意的地方，如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="number">2</span>;</span><br><span class="line">Integer c = <span class="number">3</span>;</span><br><span class="line">Integer d = <span class="number">3</span>;</span><br><span class="line">Integer e = <span class="number">321</span>;</span><br><span class="line">Integer f = <span class="number">321</span>;</span><br><span class="line"></span><br><span class="line">Long g = <span class="number">3L</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(c==d);  <span class="comment">//true </span></span><br><span class="line">System.out.println(e==f);  <span class="comment">//false   Interger 128限制（缓存了 -128~127的对象，超出这个值就重新new，否则就直接取）</span></span><br><span class="line">System.out.println(c==(a+b));  <span class="comment">// true</span></span><br><span class="line">System.out.println(c.equals(a+b));  <span class="comment">//true </span></span><br><span class="line">System.out.println(g==(a+b));   <span class="comment">//true   ，这个还真没找到解释的方法</span></span><br><span class="line">System.out.println(g.equals(a+ b));   <span class="comment">//false  ,因为 g  是 Long 类型，而 a + b 后是Integer类型，类型都不一样,equals 不会自动处理数据转型</span></span><br></pre></td></tr></table></figure>

<p>结果和注释都已经写上了，关于Integer的128限制，再来例子说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i=<span class="number">127</span>;</span><br><span class="line">Integer j =<span class="number">127</span>;</span><br><span class="line">System.out.println(i==j);    <span class="comment">//true</span></span><br><span class="line">i=<span class="number">128</span>;</span><br><span class="line">j=<span class="number">128</span>;</span><br><span class="line">System.out.println(i==j);   <span class="comment">//false </span></span><br><span class="line"></span><br><span class="line">i=<span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">j=<span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">System.out.println(i==j);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>详细解释：jvm在运行时创建了一个缓存区域，并创建了一个integer的数组。这个数组存储了-128至127的值。因此如果integer的值在-128至127之间，则是去缓存里面获取。因此上面的i和j指向的是同一个内存地址。因为128超过了这个缓存区域，因此第二次赋值的时候是重新开辟了两个内存地址。第三次因为使用了new关键字，在java中。new关键字是开辟内存空间。因此第三次赋值是开辟了新的内存空间，此时发现即便i与j都是127，但内存地址不再相同。</p>
<blockquote>
<p>包装类的 “==” 运算在不遇到算术运算的情况下不会自动拆箱，并且它们的 equals() 方法不处理数据转型的关系。</p>
</blockquote>
<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>略</p>
<h2 id="实战：-插入式注解处理器"><a href="#实战：-插入式注解处理器" class="headerlink" title="实战： 插入式注解处理器"></a>实战： 插入式注解处理器</h2><p>略</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)</tag>
      </tags>
  </entry>
  <entry>
    <title>第11章: 晚期（运行期）优化</title>
    <url>/2019/09/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC11%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 程序最初是通过解释器(Interpreter)进行解释执行的，虚拟机发现某个方法或代码块运行特别频繁时，会将它们认定为“热点代码”(Hot Spot Code)。为了提高运行效率，虚拟机会把这些代码编译成本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(Just In Time Compiler, JIT编译器)。</p><a id="more"></a>
<p>JIT 不是虚拟机必需部分，Java虚拟机规范也没有规定实现，但它却是衡量一款商用虚拟机优秀与否的关键指标，也是最能体现虚拟机技术水平的部分。本章所讲的内容都是基于HotSpot虚拟机。</p>
<h2 id="HotSpot-虚拟机的JIT"><a href="#HotSpot-虚拟机的JIT" class="headerlink" title="HotSpot 虚拟机的JIT"></a>HotSpot 虚拟机的JIT</h2><p>首先看几个问题：</p>
<ul>
<li>为何要使用解释器与编译器并存架构    </li>
<li>为何要实现两个不同的JIT    </li>
<li>程序何时使用解释器执行？何时使用编译器执行？    </li>
<li>哪些程序代码会被编译为本地代码？如何编译为本地代码？    </li>
<li>如何从外部观察JIT的编译过程和编译结果？    </li>
</ul>
<h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p>第一个问题，解释器与编译器两者各有优势：当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；程序运行后，随着时间推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大时，也可以使用解释执行节约内存。同时，解释器可以作为编译器激进优化时的一个“逃生门”。因此，在整个虚拟机架构中，解释器与编译器经常配合工作。</p>
<p>第二个问题，两个不同的JIT一般称为 Client Compiler（也称为 C1 编译） 和 Server Compiler（也称为 C2 编译） 。虚拟机一般会启用分层编译策略，分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次：</p>
<ol>
<li>第0层：解释执行，解释器不开启性能监控(Profiling)，可触发第1层编译。    </li>
<li>第1层，也称C1编译，将字节码编译成本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。    </li>
<li>第2层，也称C2编译，将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li>
</ol>
<p>实施分层编译后，C1和C2将会同时工作，许多代码会被多次编译，用C1获取更高的编译速度，用C2获取更好地编译质量，并且解释执行时也无需承担收集性能监控信息的任务。</p>
<h3 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h3><p>第三个问题，上文提到，运行过程中会被即时编译器编译的“热点代码”有两类，即：</p>
<ul>
<li>被多次调用的方法。    </li>
<li>被多次执行的循环体。    </li>
</ul>
<p>解释一下第二点，这是为了解决一个方法只被调用过一次或少量几次，但是方法体内部存在循环次数较多的循环体问题。这样，循环体的代码也被重复执行多次，因此这些代码也应该认为是“热点代码”。</p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>默认设置下，无论是方法调用产生的即时编译请求还是OSR编译请求，虚拟机在代码编译器还未完成之前，都仍将按照解释方式执行。</p>
<h2 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h2><p>以如下代码清单来说明编译优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    </span><br><span class="line">    z = b.get();</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>首先说明的是，这些代码优化变换是建立在代码的某种中间表示或机器码之上，绝不是建立在Java源码之上，这里是为了展示方便，使用了Java语言的语法来表示这些优化技术所发挥的作用。</strong></p>
<p>以上的代码已经非常简单了，但仍有许多优化余地，第一步就是<strong>方法内联(Method Inlining)</strong>，内联后的foo函数代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    </span><br><span class="line">    z = b.value;</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内联的重要性高于其他优化措施，它主要有两个目的：去除方法调用的成本(如建立栈帧等)  以及为其他优化方法建立良好的基础(方法内联膨胀后可以便于在更大范围上采取后续优化手段)。</p>
<p>第二步进行 <strong>冗余访问消除(Redundant Loads Elimination)</strong>，假设上述代码中 do something 刽改变 b.value的值，那就可以将 z = b.value 替换为 z = y ，因为上一句 y = b.value 已经保证 y 与b.value 是一致的，这样就可以不用再去访问对象b的局部变量了。优化后的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    </span><br><span class="line">    z = y;</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步我们进行<strong>复写传播(Copy Propagation)</strong>，因为在这段程序的逻辑中没有必要使用 z 这个变量，它与 y 是完全相等的，因此可以用 y 来替代 z ，复写传播后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    </span><br><span class="line">    y = y;</span><br><span class="line">    sum = y + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步我们进行<strong>无用代码消除(Dead Code Elimination)</strong>。在上述代码清单中， y = y 是没有意义的，把它擦除后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    </span><br><span class="line">    sum = y + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过4次优化后，达到的效果一致，但是比原始代码省略了许多语句，执行效率也更高。接下来继续看几项有代表性的优化技术。</p>
<h3 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h3><p>这是语言无关的经典优化技术之一，普遍用于各种编译器的经典优化技术，它的含义是：如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成了公共子表达式。假设存在如下代码：</p>
<blockquote>
<p>int d = (c * b) * 12 + a + (a + b * c);</p>
</blockquote>
<p>这段代码交给JIT编译后，它将进行如下优化：因为 c * b 与 b * c 是一样的表达式，并且在计算期间 b 与 c 的值是不可变的，因此表达式可能会被视为：</p>
<blockquote>
<p>int d = E * 12 + a + (a + E);</p>
</blockquote>
<p>这时候，编译器还可能进行 <strong>代数化简(Algebraic Simplification)</strong>，把表达式变为：</p>
<blockquote>
<p>int d = E * 13 + a * 2;</p>
</blockquote>
<h3 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h3><p>如果有一个数组 foo[] ，在Java语言中访问数组元素 foo[i] 的时候系统将会自动进行上下界的范围检查，即i必须满足 i&gt;= 0 &amp;&amp; i &lt; foo.length ，否则抛出异常。 为了安全，数组边界检查是必须的，但是运行期间一次不漏地检查则优点浪费，是可以“商量”的。假如程序中访问一个对象 foo 的某个属性 value，那以Java伪代码表示虚拟机访问的过程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(foo != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> foo.value;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用隐式异常优化后，虚拟机会把上述代码变为如下伪代码过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo.value;</span><br><span class="line">&#125;<span class="keyword">catch</span>(segment_fault) &#123;</span><br><span class="line">    uncommon_trap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机会注册一个 segment_fault 信号的异常处理(uncommon_trap),这样当foo不空的时候，对value的访问是不会额外消耗一次对foo判空的开销的。代价就是当 foo 真的为空时，必须转入到异常处理器中恢复并抛出 NullPointException异常，这个过程必须从用户态转到内核态中处理，结束后再回到用户态，速度远比一次判空检查慢，但当 foo 极少为空的时候，隐式异常优化是值得的。</p>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>方法内联是编译器最重要的优化手段之一，除了消除方法调用的成本之外，它更重要的意义在于为其他优化手段建立良好的基础，如下代码就解释了内联对其他优化手段的意义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInline</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line">    foo(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上 testInline 方法的内部全部是无用代码，如果不做内联，后续即使进行了无用代码消除优化，也无法发现任何“Dead Code”，因为如果分开来看， foo() 和 testInline() 两个方法的操作都可能是有意义的。因此方法内联的意义不只是把目标方法“复制”到发起调用的方法中避免真实的方法调用。但实际上Java 虚拟机中的内联过程远没有那么简单，如果不是即时编译器做了一些努力，按照经典编译原理的优化理论，大多数的方法都无法进行内联。</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸；甚至还可能被外部线程访问到，譬如赋值给类变量或者可以在其他线程中访问的实例变量，称为线程逃逸。</p>
<p>如果能证明一个方法不会逃逸到方法或线程外，则可能为这个变量进行一些高效优化：</p>
<ul>
<li><p>栈上分配(Stack Allocation)：Java 虚拟机中，在Java 堆上分配创建对象的内存空间几乎是Java程序员都清楚的常识了，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但回收动作（无论是筛选可回收对象还是回收和整理内存）都需要耗费时间。如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁，减小垃圾收集系统的压力。</p>
</li>
<li><p>同步消除(Synchronization Elimination)：线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么变量的读写肯定不会有竞争，对这个变量实施的同步措施就可以被消除。</p>
</li>
<li><p>标量替换(Scalar Replacement)：标量(Scalar)是指一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型(int、long等数值类型及 refrence 类型等)都不能再进一步分解，它们就可以称为标量。相对地，如果一个数据可以继续分解，那它就称作聚合量，Java中的对象就是最典型的聚合量。如果把一个Java 对象拆散，根据程序访问情况将其使用到的成员变量恢复原始类型来访问就叫做标量替换。    </p>
<blockquote>
<p>如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上分配和读写外，还可以为后续进一步优化手段创建条件。</p>
</blockquote>
</li>
</ul>
<h2 id="Java-与-C-C-的编译器对比"><a href="#Java-与-C-C-的编译器对比" class="headerlink" title="Java 与 C/C++的编译器对比"></a>Java 与 C/C++的编译器对比</h2><p>有兴趣的时候再来补上，略。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)</tag>
      </tags>
  </entry>
  <entry>
    <title>deepin使用心得</title>
    <url>/2019/08/18/deepin%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在windows 10 上使用Android studio 开发，分分钟让你怀疑人生，编译运行一次看效果，5、6分钟很正常，7、8分钟是常有的事，忍无可忍，决心切换到 linux 环境。以个人的理解，Linux 的发行版都是基于相同的内核，所以比较各个发行版的时候，我个人主要比较 美观程度、使用方便程度以及可使用的软件数目。</p><a id="more"></a>
<p>在尝试包括ubuntu、中兴的新支点、优麒麟、deepin 之后，最终选择使用 deepin（深度技术）。deepin 有自己的应用商店，里面有包括 wps、qq、微信、TIM、foxmail、百度云盘、MindMaster、搜狗输入法等常用软件（有些是deepin-win版本的，但是优化得很好），并且如果需要安装其他的常用软件，也能通过deepin-wine方式安装；除此之外，deepin的界面极为美观，操作起来也特别方便，很多操作与windows类似。最重要的是，deepin天生对中文环境友好，并且无需费神选择镜像源，几乎安装上就能够正常使用，因此在这里，我强烈安利一波这个国产的，难得的linux发行版。</p>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="一、安装Android-studio"><a href="#一、安装Android-studio" class="headerlink" title="一、安装Android studio"></a>一、安装Android studio</h3><p>按照官方给的教程下载，并且解压到相应的目录即可，你可以把快捷方式的图标固定在decor上，如果之后偶尔通过这个图标不能正常启动，就进入 AS 的解压目录，进入bin 目录中，双击 studio.sh 运行就可以正常使用了。</p>
<h3 id="二、安装rtx"><a href="#二、安装rtx" class="headerlink" title="二、安装rtx"></a>二、安装rtx</h3><p>打开终端，输入以下命令：</p>
<blockquote>
<p>sudo apt install  deepin.com.qq.rtx2015</p>
</blockquote>
<p>卸载就输入：</p>
<blockquote>
<p>sudo apt remove  deepin.com.qq.rtx2015</p>
</blockquote>
<h3 id="三、安装openJdk"><a href="#三、安装openJdk" class="headerlink" title="三、安装openJdk"></a>三、安装openJdk</h3><p>Android 开发使用 openJdk 就足够了，并且安装过程也是超级方便，以下命令就能搞定：</p>
<blockquote>
<p>sudo apt-get install openjdk-8-jdk</p>
</blockquote>
<h3 id="四、安装git"><a href="#四、安装git" class="headerlink" title="四、安装git"></a>四、安装git</h3><p>作为developer，版本管理是必不可少的，git 最初是为 linux 版本管理而生，因此在linux上安装 git 也是极为方便：</p>
<blockquote>
<p>sudo apt-get install git</p>
</blockquote>
<h3 id="其他软件"><a href="#其他软件" class="headerlink" title="其他软件"></a>其他软件</h3><p>可以从deepin自带的应用商店安装。</p>
<h2 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h2><p>linux彻底卸载软件步骤:以卸载wine为例</p>
<p>1、 删除软件及配置文件</p>
<blockquote>
<p>sudo apt-get –purge remove wine</p>
</blockquote>
<p>2、 删除没用的依赖包</p>
<blockquote>
<p>sudo apt-get autoremove wine</p>
</blockquote>
<p>3、 此时dpkg的列表中有”rc”状态的软件包,可以执行以下命令进行最后清理</p>
<blockquote>
<p>sudo dpkg -l |grep ^rc|awk ‘{print $2}’ |sudo xargs dpkg -P</p>
</blockquote>
<p>4、 然后删除安装包,位于/root/.wine和/home/usrname/.wine</p>
<blockquote>
<p>sudo rm -rf /root/.wine<br>sudo rm -rf /home/usrname/.wine</p>
</blockquote>
<h2 id="Android-Studio-使用"><a href="#Android-Studio-使用" class="headerlink" title="Android Studio 使用"></a>Android Studio 使用</h2><p>有时候，需要在 Android studio 的 terminal 中输入相应的gradle 命令，尤其是build出错又找不到错误的时候，就想使用命令：</p>
<blockquote>
<p>gradlew compileDebugSources –stacktrace -info</p>
</blockquote>
<p>但是我们直接在as的terminal中输入这行命令是不行的，并且我一般也懒得去配置环境。这时候，其实我们可以在项目的根目录下能发现 gradlew 的一个文件，我们能不能使用这个gradlew呢？事实上是可以的，只需要执行：</p>
<blockquote>
<p>./gradlew compileDebugSources –stacktrace -info </p>
</blockquote>
<p>如果提示权限不足，只需要chmod 777 项目的根目录修复下权限即可：</p>
<blockquote>
<p>sudo chmod -R 777 chmod -R 777 /media/test/_dde_data/work/test</p>
</blockquote>
<h2 id="Android-源码下载"><a href="#Android-源码下载" class="headerlink" title="Android 源码下载"></a>Android 源码下载</h2><h3 id="安装repo"><a href="#安装repo" class="headerlink" title="安装repo"></a>安装repo</h3><p>Android 源码是使用 repo 管理的，所以我们首先安装repo，在安装repo前，你可能需要先安装 curl ：</p>
<blockquote>
<p>sudo apt-get install curl</p>
</blockquote>
<p>安装完成后，可以通过命令查看 curl 的版本号，同时验证 curl是否安装完成</p>
<blockquote>
<p>curl –version</p>
</blockquote>
<p>步入正题，在deepn下，我们只需要在终端输入以下3条简单的命令即可完成repo的安装：</p>
<blockquote>
<p>mkdir ~/bin<br>curl <a href="https://storage.googleapis.com/git-repo-downloads/repo" target="_blank" rel="noopener">https://storage.googleapis.com/git-repo-downloads/repo</a> &gt; ~/bin/repo<br>chmod a+x ~/bin/repo    </p>
</blockquote>
<p>接着，我们还需要为 repo 配置环境变量，在终端中输入：</p>
<blockquote>
<p>sudo vim /etc/bash.bashrc</p>
</blockquote>
<p>当然，如果你安装了 sublime 的话，可以使用如下命令会更方便一些：</p>
<blockquote>
<p>sudo subl /etc/bash.bashrc</p>
</blockquote>
<p>在这个打开的文件尾部添加你的环境变量，比如我的就是这样的(你需要把路径换成你的，一般来说你将我的例子中的 glassx 换成你的用户名即可)：</p>
<blockquote>
<p>export PATH=$PATH:/home/glassx/bin:$REPOPATH</p>
</blockquote>
<p>使环境变量生效：</p>
<blockquote>
<p>source /etc/bash.bashrc</p>
</blockquote>
<p>接下来，你可以正式下载Android 源码了。</p>
<h3 id="下载-Android-源码"><a href="#下载-Android-源码" class="headerlink" title="下载 Android 源码"></a>下载 Android 源码</h3><p>由于众所周知的原因，我们下载Android 源码链接不可能成功，因此推荐使用清华大学的源，官方主页为： <a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/</a></p>
<p>你也可以直接直接复制链接： <a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar</a> 放在迅雷中下载，这个文件略大，估计下载时间按照天来计算。</p>
<p>下载完成后，解压到指定文件夹(-C 用来指定解压后的文件存放位置)：</p>
<blockquote>
<p>tar -xvf /media/glassx/AndroidSourceCode/aosp-lastest.tar -C /media/glassx/AndroidSourceCode</p>
</blockquote>
<p>在解压后的目录下， ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录，cd 到这个文件夹下，执行 :</p>
<blockquote>
<p>repo sync</p>
</blockquote>
<p>就可以同步所有分支了，这个过程消耗的时间也略长，可能需要若干个小时，请耐心等待。至此，我们已经将 Android 源码成功下载下来并且解压同步分支了。</p>
<p>由于我同事有这个tar文件了，所以我就直接从他那里copy了过来，如果你同学或者同事也已经有这个tar文件了，可以直接复制这个文件。这里顺带说一下操作方式：如果你是windows ，并且他也是windows，则只需要他将这个文件所属的目录设置为共享文件夹，之后你在你的文件管理器中输入类似以下地址：</p>
<blockquote>
<p>\192.168.12.13\d\共享文件夹</p>
</blockquote>
<p>其中192.168.12.13 是你同事的ip，后面接的是共享文件夹的路径。</p>
<p>如果你的是deepin，你同事的也是linux，那么也好办，使用 ssh 登录你同事的电脑：</p>
<blockquote>
<p>ssh 192.168.12.13 </p>
</blockquote>
<p>登录成功后，进入你同事的电脑，通过 scp 命令可以把文件给copy到你的电脑上。</p>
<p>很多时候我们想要做的就是自己编译一个 Android 系统安装在模拟器上，这个我目前还未完成，等完成后，再来续上。</p>
<h2 id="deepin遇到的问题"><a href="#deepin遇到的问题" class="headerlink" title="deepin遇到的问题"></a>deepin遇到的问题</h2><p>今天遇到问题了，安装软件和升级都不行，报错：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树</span><br><span class="line">正在读取状态信息... 完成</span><br><span class="line"><span class="function">E: 软件包 <span class="title">mindmaster</span> 需要重新安装，但是我无法找到相应的安装文件。</span></span><br></pre></td></tr></table></figure>

<p>或者是：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mindmaster</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树</span><br><span class="line">正在读取状态信息... 完成</span><br><span class="line"><span class="function">E: 软件包 <span class="title">mindmaster</span> 需要重新安装，但是我无法找到相应的安装文件。</span></span><br></pre></td></tr></table></figure>

<p>怎么着解决也不行，最后在<a href="https://blog.csdn.net/s464036801/article/details/8463607" target="_blank" rel="noopener">网上找到这个方法</a>，首先：</p>
<blockquote>
<p>rm -rf /var/lib/dpkg/info/mindmaster*</p>
</blockquote>
<p>然后：</p>
<blockquote>
<p>sudo dpkg –remove –force-remove-reinstreq mindmaster</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>手摸手</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章：Android 进程/线程管理</title>
    <url>/2019/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC5%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="Android-进程和线程"><a href="#Android-进程和线程" class="headerlink" title="Android 进程和线程"></a>Android 进程和线程</h2><p>进程(process) 是程序的一个运行实例，而线程(Thread)则是 CPU 调度的基本单位。</p><p>对于Android应用开发者而言，通常面对的都是 Activity、Service等组件，并不需要特别关心进程是什么，因而产生了一些误区，如部分研发者认为系统四大组件就是进程的载体。</p><a id="more"></a>

<p>很遗憾，虽然四大组件很符合我们对进程的印象，但是他们不能算是完整的进程实例，最多只能算进程的组成部分，从 AndroidManifest.xml 中也可以得到一点提示（这个xml是对应用程序的声明和描述）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:label</span>=<span class="string">"launch performance"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"SimpleActivity"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>可以看到，Activity的外围有一个名为 <application> 的标签，换句话说，四大组件都只是 “application”的零件。通过例子来分析让读者有个更全面的认识，通过Activity A启动Activity B，在 B 的onCreate(Bundle savedInstanceState) 打断点，查看断点详情可以看到如下图所示的内容：</application></p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/%E7%AC%AC5%E7%AB%A0/activity%E5%90%AF%E5%8A%A8.png" alt="activity启动"></p>
<p>从这个实验中还解决了一个重要问题，即主线程到底怎么产生的，从上图的函数堆栈可以知道：主线程由ZygoteInit启动，经由一系列调用后最终才执行Activity的onCreate函数，并且，Zygote为Activity创建的主线程是 ActivityThread。以下是源码展示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只有主线程才能调用这个函数，普通线程应该使用prepare()，具体见对 Looper 的讲解</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主线程对应的handler</span></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个main()是static的，因此这里需要创建一个实例</span></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Activity是由界面显示的，这个函数将与WindowManagerService 建立联系</span></span><br><span class="line">    thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主循环开始</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果程序运行到了这里，说明退出了上面的Looper循环</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，启动Activity后，除了main thread 外还有多个binder线程，如下图所示（用于Binder的那些线程是在什么时候创建的，这个问题留到后面Binder章节详细解答）：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/%E7%AC%AC5%E7%AB%A0/%E8%BF%90%E8%A1%8C%E7%9A%84thread%E5%9B%BE.png" alt="运行的thread图"></p>
<p>图中可以看到，B 被启动之后，主线程也始终只有一个，此时A退出了运行，但没有被杀掉，只是被压入了栈中。同样，如果我们启动一个Service，并把断点打在Service的onCreate方法的中，我们会发现，Service也是寄存于ActivityThread之中的，并且启动流程和Activity基本上一致，并且启动Service时，同样有Binder线程支持。限于篇幅，这里不做截图和代码。</p>
<p>按照Android系统设计：”By default，all componets of the same application run in the same process and thread(called the “main” thread)”，这可以理解为，对于同一个AndroidManifest中定义的四大组件，除非有特别的声明，否则它们都运行在同一个进程中(并且均由主线程处理事件)。如何证明呢？根据前面操作系统的基础知识，<strong>如果两个对象处于同一个进程空间，那么内存区域应该是可共享访问的</strong>，利用这个原理我们可以论证下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第1个activity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ConstTemp = -<span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在启动SecondActivity 前，将ConstTemp值改为2，如果他们不是处于同一个进程，那么在 </span></span><br><span class="line">        <span class="comment">// SecondActivity中是无法获得更新后的值 2 的，只可能是 -1</span></span><br><span class="line">        ConstTemp = <span class="number">2</span>;</span><br><span class="line">        startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>,SecondActivity.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第2个acitivity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_second);</span><br><span class="line">        </span><br><span class="line">        Log.e(<span class="string">"SecondActivity"</span>,<span class="string">"ConstTemp = "</span> + MainActivity. ConstTemp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终输出的结果是2，说明都是在同一个进程中，当然，我们还可以通过查看二者的 PID 和 TID 的方法证明这两个Activity默认确实在同一个进程中。当然，Android还提供了特殊方式让不是同一个包的组件也可以运行于相同的进程中，这样做的优势是，它们可以方便地资源共享，而不用大费周章地进程间通信。这可以分为两种情况：</p>
<ol>
<li>在AndroidManifest中的四大组件标签中加入 android:process 来表明这一组件想要运行在哪个进程空间。</li>
<li>针对整个程序包，可以直接在 <application> 标签中，加入 android:process 属性来指明想要依存的进程环境。</application></li>
</ol>
<h2 id="Handler、MessageQueue、Runable与Looper"><a href="#Handler、MessageQueue、Runable与Looper" class="headerlink" title="Handler、MessageQueue、Runable与Looper"></a>Handler、MessageQueue、Runable与Looper</h2><p>参考专题里面的内容（现在还没放上去）<br>略</p>
<h2 id="UI主线程-ActivityThread"><a href="#UI主线程-ActivityThread" class="headerlink" title="UI主线程-ActivityThread"></a>UI主线程-ActivityThread</h2><p>前面提到Activity的部分源码，这里精简下再贴出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Looper.loop();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通线程使用Looper的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较二者的代码可知其中的区别主要体现在：</p>
<ul>
<li><p>prepareMainLooper 和 prepare，普通线程prepare就可以了，而主线程使用  prepareMainLooper ，主要是多了一步给sMainLooper 赋值的操作，这样，我们就能从主线程中通过 getMainLooper() 方式获得主线程的 Looper。</p>
</li>
<li><p>Handler不同，普通线程申城一个与Looper绑定的Handler，而主线程是从当前线程中获取的Handler，也就是说，ActivityThread 提供了一个“事件管家”，以处理主线程中各种消息。</p>
</li>
</ul>
<h2 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread 类"></a>Thread 类</h2><h3 id="Thread-类的内部原理"><a href="#Thread-类的内部原理" class="headerlink" title="Thread 类的内部原理"></a>Thread 类的内部原理</h3><p>Thread 实现了 Runnable ，也就是说线程是“可执行的代码”。我们一般通过2种方式使用Thread ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第1种</span></span><br><span class="line">MyThread thr = <span class="keyword">new</span> MyThread(...);</span><br><span class="line">thr.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第2种</span></span><br><span class="line"><span class="keyword">new</span> Thread(Runnable target).start();</span><br></pre></td></tr></table></figure>

<p>这两种方法最终都通过 start 启动，它会间接调用Runable 的 run 实现.</p>
<h3 id="线程的休眠和唤醒"><a href="#线程的休眠和唤醒" class="headerlink" title="线程的休眠和唤醒"></a>线程的休眠和唤醒</h3><p>控制线程的相关方法我们至少可以想到以下几个： wait()、notify()、notifyAll()、interrupt()、join() 和 sleep()。</p>
<ol>
<li>wait 和 notify/notifyAll</li>
</ol>
<p>和其他方法不同，这3个函数是由 Object 类定义的——意味着它们是任何类的共有“属性”，那为什么这么设计呢？官方对wait的解释是：</p>
<blockquote>
<p>Causes the calling thread to wait until another thread calls the notify() or notifyAll() method of this object</p>
</blockquote>
<p>当某个线程调用一个 Object 的wait 方法时，系统就要在这个 Object 中记录这个请求。因为调用者很可能不止一个，所以可使用列表的形式来逐一添加它们。当后期唤醒条件满足时， Object 既可以使用 notify 来唤醒列表中的一个等待线程，也可以通过 notifyAll 来唤醒列表中的所有线程。值得注意的是，调用者只有称为 Object 的 monitor 后，才能调用它的 wait 方法，而称为一个对象的 monitor 有以下3种途径：</p>
<ul>
<li>执行这个 object 的 synchronize 方法     </li>
<li>执行一段 synchronize 代码，并且是基于这个 object 做的同步    </li>
<li>如果 object 是 Class 类，可以执行它的 synchronize static 方法    </li>
</ul>
<ol start="2">
<li>interrupt ：如果说wait是自愿行为， 那 interrupt 就是 “被迫” 的了，它的意思就是“中断”。    </li>
<li>join，用以下例子说明：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadA());</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadB());</span><br><span class="line">t1.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>它希望达到的目的就是只有当 t1 线程执行完成时，我们才接着执行后面的 t2.start() 。这样就保证了两个线程顺序执行。</p>
<ol start="4">
<li>sleep：它和 wait 一样都是属于“自愿”的行为，只不过 wait 是等待某个 object ，而sleep 是等待时间，一旦设置的时间到了就会被唤醒。</li>
</ol>
<h3 id="Thread-实例"><a href="#Thread-实例" class="headerlink" title="Thread 实例"></a>Thread 实例</h3><p>讲一个典型范例来理解Thread：假如我们使用 SeekBar 开控制系统音效，要求：(1)UI界面响应流畅，(2)并且要能反映出音效的变化，(3)并且系统稳定。同时，有以下几个前提：     </p>
<ol>
<li>向系统发送音效调整的命令是个耗时操作     </li>
<li>频繁向系统发送调整命令会导致死机     </li>
<li>用户的操作是随意的，没有规律的（用户可能飞快地拉动，也有可能慢慢拉动）    </li>
</ol>
<p>对于要求1，可以将发送命令这个耗时操作放到一个独立线程执行，这样就不会影响UI，保证流畅。<br>而根据3个前提条件，条件2和条件3是有矛盾的，如果要实时听到音效变化，在seekbar进度变化错城中需要不停地发送请求，而用户快速滑动导致产生大量请求，可能会引起死机，从而违背第3个要求。</p>
<p>再来想想其它简单方法，当启动一个新的线程处理调整请求时，显然需要把这些请求先放入消息队列中再排队处理，假设用户1s内产生了24个请求，那么队列中的数量将会陆续增加（假设500ms才处理完一个），直到用户操作结束。<strong>那么，实际上这些请求值是有优先级的，即后产生的调整值更贴近用户想要的效果</strong>。根据这个思想，我们可以适当控制消息队列中元素的数量，比如：</p>
<ul>
<li>当产生新的调整值时，先清空消息队列，然后再把请求入队。     </li>
<li>当产生新的调整值时，先判断消息队列的数量，根据实际情况删除部分消息，然后才请求入队。<br>采用这种方式可以保证最后一个入队的请求总是可以被处理的，这也就意味着用户最终选择的音效值是可以体现出来的。示例代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Thread mBusinessThread = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mBusinessThreadStarted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> BusinessThreadHandler mBusinessThreadHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBusinessThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">true</span> == mBusinessThreadStarted)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mBusinessThreadStarted = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">    mBusinessThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">           Looper.prepare();</span><br><span class="line">           mBusinessThreadHandler = <span class="keyword">new</span> BusinessThreadHandler();</span><br><span class="line">           Looper.loop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    mBusinessThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码使用Looper.loop 来不断处理调整请求，这些请求是通过 mBusinessThreadHandler 发送到 mBusinessThread 的消息队列中的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessThreadHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="comment">//重写 sendMessage</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what,<span class="keyword">int</span> arg1,<span class="keyword">int</span> arg2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//清理消息队列中未处理的请求</span></span><br><span class="line">        removeMessages(what);</span><br><span class="line">        <span class="comment">//发送消息到队列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.sendMessage(obtainMessage(what,arg1,arg2));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(msg.what)&#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_CODE:</span><br><span class="line">                <span class="comment">//执行耗时操作</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendMessage 方法中首先清除了消息队列中还未被处理的请求，这样一方面降低了程序向系统发送请求的频率，加快了相应速度和UI流畅性；另一方面保证 BusinessThreadHandler 下次取到的是优先级较高的调整请求值，保证用户听到实时的音效变化。</p>
<h2 id="Android-应用程序的典型启动流程"><a href="#Android-应用程序的典型启动流程" class="headerlink" title="Android 应用程序的典型启动流程"></a>Android 应用程序的典型启动流程</h2><p>我们了解到 Android 系统中一个应用程序的主体是由 ActivityThread 构成的，并且 Android 系统是基于 Linux 的，原则上说它的应用程序并不只是 APK 一种类型，换句话说，所有 Linux 支持的应用程序都可以通过一定方式运行在 Android 上(一些系统级应用程序就是以这种方式存在的)，为了叙述统一，我们这里所指的应用程序都是 APK 类型的应用程序。它们通常由两种方式在系统中被启动：</p>
<ul>
<li>在 Launcher 中点击相应的应用程序图标启动    </li>
<li>通过 startActivity 启动</li>
</ul>
<p>这两种启动方式的流程基本上是一致的，最终都会调用 ActivityManagerService(以下简称 AMS) 的 startActivity 来完成。在新的 Activity 启动钱，原先处于 resume 状态的 Activity 会被 pause ，这种管理方式比　Windows 的多窗口系统简单得多，将一个 Activity 置为 pause 主要通过此 Activity 所属进程的 ApplicationThread.schedulePauseActivity 方法完成，ApplicationThread 是应用程序进程提供给 AMS 的一个 Binder 通道。假设即将启动的 Activity 所属的进程并不存在，那么 AMS 还需要先把它启动起来。</p>
<p>ActivityThread 启动并做好相应的初始化工作后，需要调用 attachApplication 来通知 AMS ，后者才能继续执行未完成的 startActivity 流程。具体而言， AMS 通过 ApplicationThread.scheduleLaunchActivity 请求应用程序来启动一个指定的 Activity ，之后一系列工作就要靠应用进程自己来完成，如 Activity 创建 Window，遍历 View Tree 等。</p>
<p>在进入后面的章节前，这里先大略熟悉 startActivity 的流程。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解Android内核设计思想-林学森</tag>
      </tags>
  </entry>
  <entry>
    <title>第8章: 虚拟机字节码执行引擎</title>
    <url>/2019/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，所有的虚拟机执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。</p><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的局部变量表、操作数栈、方法返回地址等信息。<strong>每一个方法从调用开始到执行完成的过程，对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</strong></p><a id="more"></a>

<p>在编译代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响。典型的栈帧结构如下图：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%89%88/%E7%AC%AC8%E7%AB%A0/%E6%A0%88%E5%B8%A7%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84.png" alt="类的生命周期"></p>
<p>一个线程中的方法调用链可能会很长，在活动线程中，只有位于栈顶的栈帧才是有效的。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表示一组变量值存储空间，<strong>用于存放 方法参数 和 方法内部蒂尼的局部变量。</strong>在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法(非static方法)，那局部变量表中<strong>第0位索引默认用于传递方法所属实例的引用，在方法中可以通过”this”关键字来访问这个隐含参数</strong>。剩下的参数则按照参数表顺序排列，参数表分配完毕后，再分配方法体内部定义的变量。</p>
<p>为了节省栈帧内存，局部变量表的空间是可以重用的，方法体中定义的变量，其作用域不一定会覆盖整个方法体，当超出作用范围时，它的空间就可能交给其他变量使用，不过这样的设计出了节省栈帧空间外，还会伴随额外的副作用，比如导致垃圾不能及时回收，以下举例说明()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中向内存中填充了64MB数据，然后通知虚拟机进行垃圾收集，但是我们可以发现结果并没有回收。不过，这里没有回收placeholder所占的内存还说得过去，<strong>因为在执行gc时，placeholder还处于作用域之呢，虚拟机自然不会回收</strong>，下面把代码改下（代码8-2）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入花括号之后，placeholder的作用域被限制在花括号之内，从代码逻辑上讲，gc的时候，placeholder就已经不可能再被访问了，但是执行以下，发现还是没有被回收。在解释之前，再次修改下代码试试（代码8-3）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;<span class="comment">//添加这句</span></span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行，发现内存被正确地回收了，看起来很莫名其妙。placeholder 能否被回收的根本原因是：局部变量表中是否还存有关于placeholder数组的引用。第一次修改中，代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder原本所占的空间还没有被其他变量复用，所以作为GC Roots一部分的局部变量表仍然保持着对它的引用。这种关联没有被及时打断，在绝大部分情况下影响都很轻微。</p>
<p>但是如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（代替上面例子中的 int a = 0，把变量对应的局部变量表中的空间清理掉）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用。</p>
<p>上述例子说明了在某些情况下赋null值操作确实是有用的，但是不应对这种操作有过多依赖，更没必要当做普遍的编码规则来推广，原因有两点：一是从编码角度讲，以恰当的变量作用域来控制变量的回收时间才是最优雅的解决方案。二是从执行角度讲，使用赋null值操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，赋null值的方式在经过JIT编译优化之后就会被消除掉，这时候将变量设置为null是没有意义的。以前面的例子来说，代码8-2 的形式经过JIT编译后，System.gc() 执行时，就可以正确地回收内存了，无需再写成代码 8-3 的样子。</p>
<p>还有一点需要注意，类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；一次在初始化阶段，赋予程序员定义的初始值，因此，即使在初始化阶段没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量不一样，它并不存在“准备阶段”，因此如果定义了局部变量但是没有赋初始值是不能使用的。</p>
<blockquote>
<p>这段做的笔记有点多，这是因为个人以前在一些书籍上看到有观点说，推荐及时将不使用的对象手动置为null，但是解释语焉不详，在这里从虚拟机角度看到了解释，故详细记下来</p>
</blockquote>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈(operand stack)是一个后入先出的栈，痛局部变量表一样，操作数栈的最大深度也在编译时写入到Code属性中了。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容。</p>
<p>举个例子，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令是，会将这两个int值出栈并相加，然后将相加的结果入栈。</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用并不等同于方法执行，方法调用唯一的任务就是确定被调用方法的版本（即调用哪一个方法），还不设计方法内部的具体运行。前面已经讲过，Class文件的编译过程不包含传统编译中的连接步骤，一切方法调用在Class文件里面都只是符号引用，而不是方法在时机运行时内存布局中的入口地址（相当于之前说的直接引用）。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>前面提到，所有方法调用中的目标方法在Class文件中都是一个<strong>常量池中的符号引用</strong>，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用。这种解析能成立的前提是：“编译期可知，运行期不可变”，这类方法的调用就称为“解析(Resolution)”。符合这种特性的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。</p>
<p>只能被invokestatic 和 invokespecial 指令调用的方法都可以在解析阶段中确定唯一的调用版本，<strong>符合这个条件的有静态方法、私有方法、实力构造器、父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用</strong>。这些方法称为非虚方法，与之对应的称为虚方法（final方法除外）。</p>
<p>被final 修饰的方法虽然是通过invokevertual 指令调用的，但是由于它无法被覆盖，没有其他版本，所以Java语言规范中明确说明final是一种非虚方法。</p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>Java具备面向对象的3个基本特征：继承、封装以及多态。分派调用过程将会揭示多态性特征的一些基本体现，如“重载”和“重写”在Java虚拟机中是如何实现的。</p>
<p><strong>1、 静态分派</strong></p>
<p>在讲解静态分派之前，看一段经常出现在面试题中的代码，方法静态分派代码如下面代码8-6所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sysHello</span><span class="params">(Human guy)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello ,guy !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sysHello</span><span class="params">(Man guy)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello ,gentleman !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sysHello</span><span class="params">(Woman guy)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello ,lady !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<blockquote>
<p>hello ,guy!<br>hello ,guy!</p>
</blockquote>
<p>这段代码实际上是考验读者对重载的理解程度，但这里为什么会选择执行参数类型为 Human 的重载呢？解决问题前，先按如下代码定义两个重要概念：</p>
<blockquote>
<p>Human man = new Man();</p>
</blockquote>
<p>上面代码中的”Human”称为变量的静态类型（Static Type）或叫做外观类型(Apparent Type)，后面的 “Main” 则称为变量的实际类型(Actual Type)。静态类型和实际类型在程序中都可以发生一些变化，**区别是，静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才确定，例如下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实际类型变化</span></span><br><span class="line">Human man = <span class="keyword">new</span> Man();</span><br><span class="line">man = <span class="keyword">new</span> Woman();</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态类型变化</span></span><br><span class="line">sr.sayHello((Man)man);</span><br><span class="line">sr.sayHello((Woman)man)</span><br></pre></td></tr></table></figure>

<p>回到上面代码 8-6 中，由于虚拟机（准确地说是编译器）在重载时是<strong>通过参数的静态类型而不是实际类型作为判定依据的</strong>，并且静态类型是编译期可知的，因此在编译阶段，根据静态类型选择了 sayHello(Human) 作为调用目标，并把这个方法的符号引用写到main方法里的两条invokevirtual指令参数中。静态分派的典型应用是方法重载，另外，编译器虽然能确定出方法的重载版本，但很多情况下这个重载版本并不是”唯一“的，往往只能确定一个”更加合适的“版本，以下代码 8-7演示了何为”更加合适“的版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sysHello</span><span class="params">(Object arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sysHello</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello int"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sysHello</span><span class="params">(<span class="keyword">long</span> arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello long"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sysHello</span><span class="params">(Character arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Character"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sysHello</span><span class="params">(<span class="keyword">char</span> arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sysHello</span><span class="params">(<span class="keyword">char</span>... arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sysHello</span><span class="params">(Serializable arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Serializable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        sayHello(<span class="string">'a'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<blockquote>
<p>hello char</p>
</blockquote>
<p>如果注释掉 sysHello(char arg) 方法，则会打印 “hello int”；再注释掉 sysHello(int arg) 方法，则会打印 “hello long”；再注释掉 sysHello(long arg) 方法，则会打印 “hello Character”；如此下去，输出的结果会不断变化。这其实也还好理解： ‘a’首先是个char，自然首先输出 hello char；如果没有该方法，则自动类型转换为int，如果再没有此方法，则会进一步转换为long类型（按照 char -&gt; int -&gt; long -&gt; float -&gt; double的顺序进行匹配，但不会匹配到byte和short类型，因为转型到这两种是不安全的）。所以上述代码在注释掉 sysHello(long arg) 后，输出变为 “hello Character” ，此时发生了自动装箱。如此注释下去，”hello char…” 将会是最后一个打印的，<strong>可见变长参数的重载优先级是最低的，甚至比Object还低</strong>。值得注意的是，有一些在单个参数中成立的自动转型，如char转型为 int，在变长参数中是不成立的。</p>
<p><strong>2、 动态分派</strong></p>
<p>动态分派和多态性的另一个重要体现——重写(Override)有很密切的关联，结合前面Man和Woman一起sayHello的例子来看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"man say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"woman say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        </span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<blockquote>
<p>man say hello<br>woman say hello<br>woman say hello</p>
</blockquote>
<p>结果不出人意料，但是虚拟机是如何知道要调用哪个方法？这里显然不能再根据静态类型来决定，因为静态类型都是Human的两个变量 man 和woman 在调用 sayHello 方法时执行了不同的行为，并且man在两次调用中执行了不同的方法。因此可以看出，这只是因为变量的实际类型不同。因为invokevirtual指令的运行时解析过程大致如下：</p>
<blockquote>
<p>第一步：找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C<br>第二步：如果在C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过，则返回方法的直接引用；否则，返回 java.lang.IllegalAccessError异常。<br>第三步：否则，按照继承关系从下往上一次对C的各个父类进行第二步的搜索和验证。<br>第四步： 如果始终没有找到合适的方法，则抛 java.lang.AbstractMethodError异常。</p>
</blockquote>
<p><strong>3、 单分派与多分派</strong></p>
<p>方法的接收者与方法的参数统称<strong>方法的宗量</strong>。根据分派基于多少种宗量，可以将分派划分为但分派和多分派，单分派是根据一个宗量对目标方法进行选择；多分派就是根据多个宗量对目标方法进行选择。定义比较拗口，对照下面这个例子，分析 Father 和 Son 做“艰难决定”之后，就不难理解了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单分派、多分派的例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        </span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>father choose 360<br>son choose qq</p>
</blockquote>
<p>根据以上代码，我们看看编译阶段编译器的选择过程，也即静态分配过程。这时候选择目标方法的依据有两点：静态类型以及参数，最终产物是产生了两条invokevirtual 指令，两条指令的参数分别为常量池中指向 Father.hardChoice(_360) 以及 Father.hardChoice(QQ) 方法的符号引用，因为是根据两个宗量选择，所以Java语言的静态分派属于多分派类型。</p>
<p>再看看运行阶段虚拟机的选择，也即动态分派的过程。在执行 “son.hardChoice(new QQ())” 时，由于编译期已经决定目标方法的签名必须为 hardChoice(QQ) ,此时，参数的静态类型和参数的实际类型都对方法的选择不会构成任何影响(只要是QQ类型，管你是“腾讯QQ”还是“奇瑞QQ”)，唯一可以影响虚拟机选择的因素只有方法接受者的实际类型是 Father 还是 Son ，因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。</p>
<p>因此，到目前为止（Java 1.8），我们可以说Java语言是一门静态多分派、动态单分派的语言。</p>
<p><strong>4、虚拟机动态分派的实现</strong></p>
<p>上述的分派结局虚拟机在分派过程中“会做什么”，具体如何做到的，不同虚拟机之间会有差异。由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜寻合适的目标方法。但是在实际实现中并不会进行如此频繁的搜索，面对这种情况，最常用的手段就是为类在方法区中建立一个**虚方法表(Vitual Method Table,即vtab)，使用虚方法表索引来替代元数据查找以提高性能.基于上方的代码，做如下虚方法表示意：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%89%88/%E7%AC%AC8%E7%AB%A0/%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8.png" alt="虚方法表"></p>
<p>虚方法表中存放着各个方法的实际入口地址，如果方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类方法相同，否则，替换为子类具体实现版本的地址入口。因此图中Son的hardChoice方法并没有和父类指向同一处。</p>
<p><strong>5、静态变量、方法的继承、重写、重载(非书本内容，自己测试过后添加)</strong></p>
<p>首先看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticClassFarther</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father 的 tt 方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticClassSon</span> <span class="keyword">extends</span> <span class="title">StaticClassFarther</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注释1</span></span><br><span class="line">    <span class="comment">/*public void tt(int b)&#123;</span></span><br><span class="line"><span class="comment">        System.out.println("son  的 非静态 tt 重载方法");</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tt</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son  的 静态 tt 重载方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注释2</span></span><br><span class="line">    <span class="comment">/*public void tt()&#123;</span></span><br><span class="line"><span class="comment">        System.out.println("son  的非静态 tt 方法");</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son  的 tt 方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMainClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticClassFarther farther = <span class="keyword">new</span> StaticClassFarther();</span><br><span class="line">        StaticClassFarther mix = <span class="keyword">new</span> StaticClassSon();</span><br><span class="line">        StaticClassSon son = <span class="keyword">new</span> StaticClassSon();</span><br><span class="line"></span><br><span class="line">        farther.tt();</span><br><span class="line">        System.out.println(<span class="string">"farther 中a = "</span> + farther.a + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mix.tt();</span><br><span class="line">        System.out.println(<span class="string">"mix 中a = "</span> + mix.a + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        son.tt();</span><br><span class="line">        son.tt(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"son 中a = "</span> + son.a + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"StaticClassFarther.a = "</span> + StaticClassFarther.a);</span><br><span class="line">        System.out.println(<span class="string">"开始调用：StaticClassFarther.tt "</span>);</span><br><span class="line">        StaticClassFarther.tt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中注释1 是非静态重载，是可以编译通过的，但是注释2非静态重写是不行的，一定要静态重写。再看看输出结果：</p>
<blockquote>
<p>father 的 tt 方法<br>farther 中a = 3    </p>
</blockquote>
<blockquote>
<p>father 的 tt 方法<br>mix 中a = 3    </p>
</blockquote>
<blockquote>
<p>son  的 tt 方法<br>son  的 静态 tt 重载方法<br>son 中a = 4   </p>
</blockquote>
<blockquote>
<p>StaticClassFarther.a = 3<br>开始调用：StaticClassFarther.tt<br>father 的 tt 方法    </p>
</blockquote>
<p>从结果可以看出，子类重写并没有改变父类的值，通过 StaticClassFarther.tt 调用结果还是没变化。并且，具体实现已经是子类的情况下：StaticClassFarther mix = new StaticClassSon();<br>输出的结果还是父类的(即输出以下内容)： father 的 tt 方法  和 mix 中a = 3</p>
<h3 id="动态语言支持"><a href="#动态语言支持" class="headerlink" title="动态语言支持"></a>动态语言支持</h3><p>略，后续看到这里补上</p>
<h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><p>Java 语言经常被人们定位为“解释执行”的语言，在Java 1.0 时代，这定义还算准确，但当主流的虚拟机中都包含了即时编译器后，Class 文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机才知道的事情。再后来，Java也发展处了可以直接生成本地代码的编译，而C/C++也出现了通过解释器执行的版本，这时候再笼统地说“解释执行”，对于整个Java语言来说几乎没有意义。</p>
<h3 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h3><p>Java 编译器输出的指令，基本上是一种基于栈的指令集架构，它们依赖操作数栈进行工作；与之相对的另一套常用的指令集架构是基于寄存器的指令集。那么二者有何不同呢？举个简单的例子，分别使用两种指令集计算“1+1”，基于栈的指令集会是这个样子：</p>
<blockquote>
<p>iconst_1<br>iconst_1<br>iadd<br>istore 0</p>
</blockquote>
<p>两条icons_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后 istore_0把栈顶的值放到局部变量表的第0个Slot中。而如果基于寄存器，那程序可能就会是这样：</p>
<blockquote>
<p>mov eax, 1<br>add eax, 1</p>
</blockquote>
<p>mov 指令把EAX寄存器的值设为 1，然后add指令再把这个值加1，结果就保存在 EAX寄存器里面。了解了区别之后，那么这两套指令集哪一种更好？其实是各有所长，基于栈的指令集的主要优点是可移植，而基于寄存器的话，程序要直接依赖于这些硬件寄存器而不可便面地受到硬件的约束。栈架构指令集的主要缺点是执行速度相对来说会稍慢一些，完成相同功能所需要的指令一般会比寄存器的要多，因为出栈和入栈操作本身就产生了相当多的指令数量，更重要的是，栈实现在内存之中，频繁的栈访问也意味着频繁的内存访问，对处理器来说，内存始终是执行速度的瓶颈。</p>
<h3 id="基于栈的解释器执行过程"><a href="#基于栈的解释器执行过程" class="headerlink" title="基于栈的解释器执行过程"></a>基于栈的解释器执行过程</h3><p>以示例讲述解释器执行过程， 略</p>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>6、7、8章，我们分析了 Java程序是如何存储的、如何载入（创建）的以及如何执行的问题，第9章将一起看看这些理论知识在具体开发中的经典应用。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)</tag>
      </tags>
  </entry>
  <entry>
    <title>第7章: 虚拟机类加载机制</title>
    <url>/2019/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC7%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>上一章了解了Class文件存储格式，在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能运行和使用，那么，虚拟机如何加载这些文件？</p><p>虚拟机把描述类的数据从Class文件加载到内存，<strong>并对数据进行校验、转换解析和初始化</strong>，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。在Java语言中，类型的加载、连接和初始化都是在程序运行期间完成的，这令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性。</p><a id="more"></a>

<blockquote>
<p>例如，可以等到运行时再指定其实际的实现类：用户可以通过Java预定义和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或者其他地方加载一个二进制流作为程序代码的一部分。</p>
</blockquote>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期如下图所示：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%89%88/%E7%AC%AC7%E7%AB%A0/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="类的生命周期"></p>
<p>总共有7个阶段，其中验证、准备、解析 这3个部分统称为<strong>连接(Linking)</strong>，并且加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载按照上述顺序按部就班地开始（不是“进行”，也不是“完成”，只是按部就班地“开始”，因为这些阶段通常都是相互交叉地混合式进行）。</p>
<p>虚拟机规范中<strong>严格规定</strong>了<strong>有且只有5种</strong>情况必须立即对类进行初始化（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<blockquote>
<p>这4条指令的最常见的Java代码中的场景是：使用new关键字实例化对象、读取或者设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）、以及调用一个类的静态方法。</p>
</blockquote>
<ol start="2">
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则先触发其初始化。</li>
<li>当初始化一个类，如果发现其父类还没有进行过初始化，则需要先触发其父类初始化。</li>
<li>虚拟机启动时，虚拟机会先初始化用户指定的主类（包含main()方法的那个类）</li>
<li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<p>以上5种场景中的行为称为对一个类进行主动引用，<strong>除此之外，所有引用类的方式都不会触发初始化，称为被动引用</strong>。以下举3个例子来说明何为被动引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被动使用类字段演示一：</span></span><br><span class="line"><span class="comment">//通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        Systemt.out.printlin(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        Systemt.out.printlin(<span class="string">"SubClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非主动使用类字段演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.printlin(Subclass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行后，只会输出 “SuperClass init!” ，对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被动使用类字段演示二：</span></span><br><span class="line"><span class="comment">//通过数组定义来引用类，不会触发此类的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里复用了上面的 SuperClass ，运行之后，发现没有输出 “SuperClass init!” ，说明没有触发 SuperClass 的初始化阶段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被动使用类字段演示二：</span></span><br><span class="line"><span class="comment">//常量在便一阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        Systemt.out.printlin(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Systemt.out.printlin(ConstClass. HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行之后，也没有输出 “ConstClass init!” ，虽然在 Java 源码中引用了 ConstClass 中的常量 HELLOWORLD ，但其实在编译阶段通过常量传播优化，已经将此常量值 “hello world” 存储到了 NotInitialization 类的常量池中，以后 NotInitialization 对常量 ConstClass. HELLOWORLD 的引用时机都被转化为 NotInitialization 对自身常量池的引用了。也就是说，实际上 NotInitialization 的 Class 文件之中并没有 ConstClass 类的符号引用入口，这两个类在编译成 Class 之后就不存在任何联系了。</p>
<p>接口的加载过程与类加载过程稍有一些不同，接口与类真正有所区别的是前面讲述的5种“有且仅有”需要开始初始化场景中的第3种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p>
<blockquote>
<p>顺带说明一下，上面的代码都是用静态语句块 “static{}”来输出初始化信息的，但接口中不能使用 “static{}”语句块。</p>
</blockquote>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>“加载”是“类加载(Class Loading)”过程的一部分，不要混淆。在加载阶段，虚拟机需要完成以下3件事情：</p>
<ol>
<li>通过类的全限定名获取类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>这3点规范并不算具体，例如第一条，并没有指明要从哪里获取，怎么获取，因此充满创造力的开发人员玩出了各种花样：</p>
<ul>
<li>从 zip 包中读取，最终成为日后 jar、ear、war 格式的基础</li>
<li>从网络中获取，比如Applet</li>
<li>运行时计算生成，这种场景用得最多的就是动态代理技术。</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击。从整体来看，验证阶段大致上会完成下面4个阶段的检验动作：</p>
<p><strong>文件格式验证</strong>  </p>
<blockquote>
<p>魔数0xCAFEBABE开头、主次版本是否在虚拟机处理范围内等。</p>
</blockquote>
<p><strong>元数据验证</strong>  </p>
<blockquote>
<p>是否有父类-除Object外，所有类都有父类、父类是否继承了不允许被继承的类-final修饰，是否实现了父类或者接口要求实现的所有方法。</p>
</blockquote>
<p><strong>字节码验证</strong>  </p>
<blockquote>
<p>通过数据流和控制流分析，确定程序语义是否合法、符合逻辑的。如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。</p>
</blockquote>
<p><strong>符号引用验证</strong>  </p>
<blockquote>
<p>这个校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段发生。通常校验：通过全限定名是否能找到对应的类、符号引用中的类、字段、方法的访问性(private、protected、public、default)是否可以被当前类访问 等等。</p>
</blockquote>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<p>这里两个容易产生的混淆的概念强调一下：首先，这时候进行内存分配的仅仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时一起分配在java堆中。其次，这里说的初始值“通常情况”下是数据类型的零值，假设一个类变量定义为： </p>
<blockquote>
<p>public static int value = 123;</p>
</blockquote>
<p>那变量value在准备阶段过后的初始值为 0 而不是 123。<strong>把value赋值为123的动作将在初始化阶段才会执行</strong>。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。</p>
<p><strong>符号引用(Symbolic References)：</strong>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</p>
<p><strong>直接引用(Symbolic References)：</strong>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>到了初始化阶段，才真正开始执行类中定义的Java程序代码(或者说是字节码)。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序自定的主观计划去初始化类变量和其他资源。换一个角度来表达就是：<strong>初始化阶段是执行类构造器<clinit>()方法的过程</clinit></strong>。以下介绍下<clinit>()方法执行过程中一些可能会影响程序运行行为的特点和细节：</clinit></p>
<ul>
<li><clinit>()方法由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句<strong>在源文件中出现的顺序决定</strong>的，静态语句块中<strong>只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问</strong>。一个例子说明：</clinit></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i =<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        Systemt.out.print(i);<span class="comment">//正常使用</span></span><br><span class="line">        </span><br><span class="line">        j = <span class="number">0</span>;<span class="comment">//给变量赋值可以正常编译</span></span><br><span class="line">        Systemt.out.print(j);<span class="comment">//这句提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> j =<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><clinit>()方法与类的构造函数（实例构造器<init>()）不同,它不需要显式地调用父类构造器，虚拟机会保证在子类的 <clinit>() 执行之前，父类的<clinit>()已经执行完毕。因此，在虚拟机中第一个被执行<clinit>()方法的类肯定是 java.lang.Object。<strong>这其实也意味着，父类定义的静态语句块要优先于子类变量赋值操作</strong>。一个例子说明：</clinit></clinit></clinit></init></clinit></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="title">extentds</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    Systemt.out.println(Sub.B)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码将打印出 2 而不是 1。</p>
<ul>
<li><p><clinit>()方法对于类或者接口不是必需的，如果类中没有静态语句块，也没有对变量的赋值，那么编译器可以不为这个类生成<clinit>()方法。</clinit></clinit></p>
</li>
<li><p>接口中不能使用静态语句块，但是可以有变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>()方法 。但接口的 <clinit>()方法 无须先执行父接口的<clinit>()方法，只有父接口中定义的变量使用时，父接口才会初始化（接口的实现类在初始化时也不会执行接口的<clinit>()方法）。</clinit></clinit></clinit></clinit></p>
</li>
<li><p>虚拟机会保证一个类的 <clinit>()方法 在多线程环境中会被正确地加锁、同步，所以，多线程同时去初始化一个类，那么只会有一个县城执行这个类的&lt;clinit&gt;()方法，其他的线程都会阻塞等待。举个例子：</clinit></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//如果不加上这个if语句，编译器将报错，并拒绝编译</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"init DeadLoopClass"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Runnable script = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Systemt.out.println(Thread.currentThread() + <span class="string">"start"</span>);</span><br><span class="line">                DeadLoopClass dlc = <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">                Systemt.out.println(Thread.currentThread() + <span class="string">"run over"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码在死循环以模拟长时间操作，另外一条线程在阻塞等待，将打印以下结果：</p>
<blockquote>
<p>Thread[Thread-0,5,main]start<br>Thread[Thread-1,5,main]start<br>Thread[Thread-0,5,main]init DeadLoopClass</p>
</blockquote>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗地说，比较两个类是否“相等”，只有在这两个类都是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，都被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<p>这里的“相等”，包括代表类的Class对象的 equals() 、isAssignableFrom()、isInstance() 方法返回的结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。以下代码演示了不同类加载器对instanceof关键字运算的结果的影响：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>);</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name,b,<span class="number">0</span>,b.length);</span><br><span class="line">                &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">"org.example.classloading. ClassLoaderTest"</span>);</span><br><span class="line">        </span><br><span class="line">        Systemt.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> org.example.classloading. ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果：   </p>
<blockquote>
<p>class org.example.classloading. ClassLoaderTest<br>false </p>
</blockquote>
<p>从结果可以看出，对象确实是类 “org.example.classloading. ClassLoaderTest” 的类，并实例化了这个类的对象。但这个对象与类 org.example.classloading. ClassLoaderTest 做所属类型检查的时候却返回了false，这是因为虚拟机中存在了两个 ClassLoaderTest 类，一个由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来自同一个Class文件，但依然是两个独立的类。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从java虚拟机角度来讲，只存在两种类加载器：一种是启动类加载器(Bootstrap ClassLoader)，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类 java.lang.ClassLoader。</p>
<p>如下图所示的类加载器之间的这种层次关系，称为双亲委派模型(Parent Delegation Model)。</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%89%88/%E7%AC%AC7%E7%AB%A0/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt="类的生命周期"></p>
<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合(Composition)关系来复用父加载器的代码。</p>
<p>双亲委派模型的工作过程是：<strong>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</strong></p>
<p>双亲委派模型一个显而易见的好处就是：<strong>Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。</strong></p>
<blockquote>
<p>例如类 java.lang.Object ，无论哪一个类加载器都要加载这个类（因为所有的类都直接或间接地继承了它），最终都是委派给处于模型最顶端的启动类加载器进行加载，因此，Object 类在程序中的各种类加载器环境中都是同一个类。相反，如果不使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在 ClassPath 中，那系统中将将会出现多个不同的Object 类，Java类型体系中最基础的行为也就无法保证。</p>
</blockquote>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><p>略</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章: 类文件结构</title>
    <url>/2019/07/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC6%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>计算机只认识0和1，但是最近10年虚拟机以及大量建立在虚拟上的语言的发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。</p><h2 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h2><p>Sun公司及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现程序的“一次编写，到处运行”。而各种不同平台的虚拟机以及平台无关的字节码（ByteCode）是构成平台无关性的基石。  </p><a id="more"></a>

<p>到目前为止，或许大部分程序员都还认为Java虚拟机执行Java程序是一件理所当然的事情，但在Java发展之初，Java的规范就分为Java语言规范以及Java虚拟机规范，时至今日，Java语言之外已经有一大批语言运行在Java虚拟机之上，如 Groovy、JRuby、Jython等。  </p>
<p>Java 虚拟机不和包括Java在内的任何语言绑定，它只与“Class 文件”这种特定的二进制文件格式所关联，任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。</p>
<h2 id="Class-类文件的结构"><a href="#Class-类文件的结构" class="headerlink" title="Class 类文件的结构"></a>Class 类文件的结构</h2><p>Class 文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有任何分隔符。遇到需要占用8位字节以上空间的数据项时，会按照高位在前的方式分割成若干个8位字节进行存储。</p>
<p>Class 文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种结构只有两种数据类型： 无符号数和表。</p>
<p>无符号数属于基本的数据类型，以u1、u2、u4、u8分别代表1、2、4、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8 编码构成的字符串值。</p>
<p>表示由多个无符号数或者其他表作为数据项的复合数据类型，表用于描述有层次关系的复合结构的数据，整个Class文件本质就是一张表。</p>
<h3 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h3><p>Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。Class 文件的魔数值为 0xCAFEBABE (咖啡宝贝？)，很有浪漫气息。紧接着魔数的4个字节存储着Class文件的版本号，高版本的JDK能乡下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p>
<blockquote>
<p>很多文件存储标准中都使用魔数来进行身份识别，如gif和jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来识别主要是基于安全考虑： 文件扩展可以随意改动。</p>
</blockquote>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%89%88/%E7%AC%AC6%E7%AB%A0/%E9%AD%94%E6%95%B0.png" alt="魔数示意图"></p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>版本号之后是常量池入口，该区域可以理解为Class文件中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值。</p>
<p>常量池中主要存放两大类常量：字面量（Literal） 和 符号引用（Symbolic References）。<strong>字面量比较接近于Java语言层面的常量概念，如 文本字符串、声明为final的常量值等</strong>，而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>
<ul>
<li>类和接口的全限定名(Fully Qualified Name)</li>
<li>字段的名称和描述符(Descriptor)</li>
<li>方法的名称和描述符</li>
</ul>
<p>Java代码在javac编译的时候，并不像c和c++那样有“连接”这一步骤，而是在虚拟机加载 Class 文件的时候进行动态连接，也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息。虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时解析、翻译到具体的内存地址中。</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>常量池结束后，紧接着2个字节代表访问标志（access_flags<br>），这个标志用于识别一些类或者接口层次的访问信息，包括： 这个Class 是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等等。</p>
<h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><p>类索引（this_class） 和父类索引(super_class)都是一个u2类型的数据，而接口索引集合(interfaces)是一组u2类型的数据的集合，class 文件中由这三项数据来确定这个类的继承关系。</p>
<p>其中，类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于Java不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此，父类索引都不为0。接口索引集合用来描述这个类实现了哪些接口，按照implement语句后的接口顺序从左到右排列在接口索引集合中。</p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>字段表(field_info)用于描述接口或者类中声明的变量，包括类级变量和实例级变量，不包括方法内的局部变量。这个描述可以包括的信息有： 字段的作用域(public、private、protected修饰符)、实例变量还是类变量(static修饰符)、可变性(final)、并发可见性(volatile 修饰符，是否强制从主内存读写)、可否被序列化(transient修饰符) 等等。</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，只是些微的区别，比如volatile关键字和transient关键字不能修饰方法 。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息(这一块内容也没耐心看下去，下次看明白再补)。</p>
<h2 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h2><p>这章离App开发比较远，因此第一遍的时候先略过。</p>
<h2 id="公有设计和私有实现"><a href="#公有设计和私有实现" class="headerlink" title="公有设计和私有实现"></a>公有设计和私有实现</h2><p>理解公有设计与私有实现之间的分界线是非常有必要的，Java虚拟机实现必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。按照Java虚拟机规范一成不变地逐字实现其中要求的内容是一种可行的途径，但是一个优秀的虚拟机实现，在满足虚拟机规范的约束下对具体实现做出修改和优化也是完全可行的。虚拟机实现的方式主要有以下两种：</p>
<ul>
<li>将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。</li>
<li>将输入的Java虚拟机代码在加载或执行翻译成宿主机CPU的本地指令集（即 JIT 代码生成技术）</li>
</ul>
<h2 id="Class-文件结构的发展"><a href="#Class-文件结构的发展" class="headerlink" title="Class 文件结构的发展"></a>Class 文件结构的发展</h2><p>略。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-新</title>
    <url>/2019/07/10/%E6%80%BB%E7%BB%93-%E6%96%B0/</url>
    <content><![CDATA[<h2 id="书籍笔记"><a href="#书籍笔记" class="headerlink" title="书籍笔记"></a>书籍笔记</h2><ol>
<li>开启多进程的方式，<a href="https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/">看这里</a>           </li>
<li>多进程缺陷(Application多次启动，静态成员失效，单例失效，sp的可靠性下降，断点调试会麻烦)，解决办法(判断主进程，aidl，断点调试先去掉多进程)    </li>
<li>Android中的IPC方式，总共7种(别漏了广播)，<a href="https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/">看这里</a>               </li>
<li>Activity 的启动模式，<a href="https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC1%E7%AB%A0/">看这里</a>                </li>
<li>standard模式的Activity 默认会进入启动它的Activity所属的任务栈中，由于非Activity类型的Context 没有所谓的任务栈，所以会报错。解决这个问题的方法是为待启动的Activity指定 FLAG_ACTIVITY_NEW_TASK 标记             </li>
<li>卡顿优化的步骤，各项指标过高代表啥(cpu、内存) ，<a href="https://glassx.gitee.io/2020/05/27/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-5,6%E8%AF%BE/">看这里</a>      </li>
<li>Bitmap 内存分配的变化过程 <a href="https://glassx.gitee.io/2020/05/27/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-3,4%E8%AF%BE/">看这里</a>       </li>
<li>如何做启动优化(预览窗口、闪屏、懒加载防止集中、业务优先级-第三方框架、线程管理-数量-线程池,启动过程勿出现io-负载高的时候，io性能下降很快、启动时只读很小的sp文件)，<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-7,8%E8%AF%BE/">看这里</a>          </li>
<li>启动耗时的监控方式(录屏、线上监控-talkingdata)              </li>
<li>ppi、dpi 概念，<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-20%E8%AF%BE/">看这里</a>                       </li>
<li>软件绘制和硬件绘制的区别，硬件加速快的原理是啥，<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-20%E8%AF%BE/">看这里</a>                  </li>
<li>SurfaceFlinger 管理Graphic Buffer (比如三缓冲就有三个 buffer)，通过<strong>匿名共享内存</strong>与App应用层交互                     </li>
<li>ui优化手段(尽量硬件加速、view创建优化-不用xml-提前-异步-重用、measure与layout优化-ui层次-constranLayout-无用背景)，<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-21%E8%AF%BE/">看这里</a>                          </li>
<li>网络优化之网络请求过程是啥，网络怎么监控？ <a href="https://glassx.gitee.io/2020/06/26/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-16,17%E8%AF%BE/">看这里</a>             </li>
<li>SELinux 进一步定义沙盒边界，即使应用进程有root权限也不能为所欲为(还得在安全策略配置文件中赋予权限)                  </li>
<li>sp的缺点(跨进程不安全、加载慢-让主线程等待、全量写入-mommit和apply都这样、卡顿-onPause强制把sp写入磁盘、json复杂格式会有转义开销)，可以使用mmkv 代替，<a href="https://glassx.gitee.io/2020/06/28/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-12%E8%AF%BE/">看这里</a>            </li>
<li>ContentProvider 的onCreate 在 Application 的 attachBaseContext 之后，在Application 的onCreate 之前，并且还是在主线程，因此在provider的构造函数、静态代码块、onCreate中不要耗时操作                       </li>
<li>ContentProvider 跨进程传递的原理：<strong>利用 Android 的 Binder 和 匿名共享内存机制。</strong>即通过Binder 传递 CursorWindow 对象内部的匿名共享内存的文件描述符，<a href="https://glassx.gitee.io/2020/06/28/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-12%E8%AF%BE/">看这里</a>                 </li>
<li>Serializable 的原理，效率低的原因，反序列的时候会执行构造函数吗？，<a href="https://glassx.gitee.io/2020/07/04/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-13%E8%AF%BE/">看这里</a>              </li>
<li>Parcelable 可以永久存储吗？原理是啥？，<a href="https://glassx.gitee.io/2020/07/04/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-13%E8%AF%BE/">看这里</a>              </li>
<li>Android 事件分发，<a href="https://glassx.gitee.io/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/">看这里</a>                </li>
<li>让一个View 滑动起来，有几种方法？  <a href="https://glassx.gitee.io/2019/07/06/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89-%E7%AC%AC3%E7%AB%A0/">看这里</a>                  </li>
<li>init 进程做了哪些事情？ <a href="https://glassx.gitee.io/2019/11/22/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC2%E7%AB%A0/">看这里</a>                  </li>
<li>Zygote 进程做了哪些事情？(创建了虚拟机，创建systemServer进程、fork应用程序、创建server类型的socket)           </li>
<li>SystemServer 的主要作用？ (创建系统服务AMS、WMS、PMS)                  </li>
<li>Android 系统启动流程，   <a href="https://glassx.gitee.io/2019/11/22/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC2%E7%AB%A0/">看这里</a>               </li>
<li>Zogote 进程 fork 自身创建应用进程的时候，会为应用进程创建Binder线程池和消息循环，会通过检查，确保Binder 进程只启动一次， <a href="https://glassx.gitee.io/2019/11/24/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC3%E7%AB%A0/">看这里</a>                   </li>
<li>应用进程创建完毕，通过反射调用 ActivityThread 的main方法，在main方法里面prepareMainLooper、创建了  ActivityThread 对象，再从这个ActivityThread 对象中获取 handler 作为成员变量保存，之后再loop，不允许退出             </li>
<li>Instrumentation 主要用于监控应用程序和系统的交互                  </li>
<li>AMS 与 应用进程通信时，是与 ApplicationThread 打交道的，而不是直接与 ActivityThread ，ApplicationThread 是 ActivityThread 的内部类                 </li>
<li>点击桌面图标，App的启动过程，<a href="https://glassx.gitee.io/2019/11/25/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC4%E7%AB%A0/">看这里</a>                 </li>
<li>获取 Application Context时，首先从 LoadApk 类型的 mPackageinfo 中获取，如果为null ，则从 ActivityThread 类型的 mMainThread 中获取                    </li>
<li>Dalvik 与 ART 的区别，art 有dalvik 堆空间划分区别？<a href="https://glassx.gitee.io/2019/11/23/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC11%E7%AB%A0/">看这里</a>              </li>
<li>热修复原理之Instant Run，自己创建一个AssetManager ，反射调用其addAssetPath 加载外部的resource。反射每个Activity 的AssetManager字段 mAsset，并将 mAsset 的值改成新建的 AssetManager即可。<a href="https://glassx.gitee.io/2020/01/15/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC13%E7%AB%A0/">看这里</a>                     </li>
<li>linux中常见的进程间通信有哪些？  （管道、信号、socket、消息队列-Message、共享内存等） <a href="https://glassx.gitee.io/2019/09/15/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90-%E7%AC%AC5%E7%AB%A0/">看这里</a>     </li>
<li>描述下 Binder 的工作流程，为什么是一次复制           </li>
<li>mmap(memory map，内存映射)将某个设备或者文件映射到应用进程的内存空间，这样，访问这块内存就相当于对设备/文件进行读写。这种基于内存共享的方式如果用于进程间通信，则需要注意实现同步，因为这个过程并没有同步机制，而Binder中是 c/s 模式，因此不存在同步问题         </li>
<li>Ashmem(Anony Shared Memory，匿名共享内存)的原理也是将指定的物理内存分别映射到各个进程的地址空间，从而实现内存共享。Ashmem 也是一个 misc 设备，<a href="https://glassx.gitee.io/2019/03/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC4%E7%AB%A0/">看这里</a>                         </li>
<li>主线程的 prepareMainLooper 和 普通线程的 prepare 方法的区别是啥？   <a href="https://glassx.gitee.io/2019/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC5%E7%AB%A0/">看这里</a>            </li>
<li>飞快拉动进度条或者音量SeekBar，如何保证界面流畅又要听到实时声音？  <a href="https://glassx.gitee.io/2019/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC5%E7%AB%A0/">看这里</a>         </li>
<li>ActivityThread 启动并做好相应的初始化工作后，需要调用 attachApplication 来通知 AMS ，后者才能继续执行未完成的 startActivity 流程,<a href="https://glassx.gitee.io/2019/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC5%E7%AB%A0/">看这里</a>                  </li>
<li>系统对 Parcel 是有缓存的，系统预先产生一个大小为6的parcel 池，所以我们可以通过 Parcel.obtain() 方法获取一个 Parcel 对象，如果还有现成Parcel 对象，则直接使用，否则new一个。<strong>并且，Parcel存储数据时，会提供数据当前位置dataPosition，类似游标，每当存储新数据时，从这个位置接着往后存，空间不够再申请</strong> <a href="https://glassx.gitee.io/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC6%E7%AB%A0/">看这里</a>                 </li>
<li>binder 主要提供open、mmap、ioctl 三个接口，接口的作用是啥？ <a href="https://glassx.gitee.io/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC6%E7%AB%A0/">看这里</a>        </li>
<li>用户申请binder 服务的流程（A、B进程间数据传递），： open-&gt;mmap-&gt;ioctl，应用程序申请binder 的空间大小？  <a href="https://glassx.gitee.io/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC6%E7%AB%A0/">看这里</a>                 </li>
<li>Binder 的优点：性能、稳定、安全、使用简单， <a href="https://glassx.gitee.io/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC6%E7%AB%A0/">看这里</a>                </li>
<li>Java 内存区域划分及可能存在的异常，啥是直接内存？ 啥叫运行时常量池，这个常量池在哪？ <a href="https://glassx.gitee.io/2019/04/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0/">看这里</a>                </li>
<li>如何产生各种异常，oom，stackoverflow ？  <a href="https://glassx.gitee.io/2019/04/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0/">看这里</a>                </li>
<li>哪些对象可以做 GCRoot ？ 谈谈引用？ 不可达非死不可吗，流程咋样？ <a href="https://glassx.gitee.io/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/">看这里</a>                          </li>
<li>垃圾收集算法，并发收集的缺点？ 内存分配策略？  <a href="https://glassx.gitee.io/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/">看这里</a>                         </li>
<li>类加载过程如何？ 各个过程做啥？ 类啥时候会初始化？特殊情形-获取父类静态值、作为数组类型-static final 字符串入常量池了、<a href="https://glassx.gitee.io/2019/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC7%E7%AB%A0/">看这里</a>               </li>
<li>虚拟机执行非静态方法时，通过局部变量表完成参数值到参数变量列表的传递，第0位索引默认用于传递方法所属实例，这样，在方法中可以使用this 关键字来访问这个实例了，<a href="https://glassx.gitee.io/2019/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0/">看这里</a>          </li>
<li>在有继承关系存在的情况下，虚拟机如何做到 方法调用分派？ 根据各个类的虚方法表中方法的指向，  <a href="https://glassx.gitee.io/2019/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0/">看这里</a>          </li>
<li>静态变量和静态方法的重写，只跟声明的类型有关， <a href="https://glassx.gitee.io/2019/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0/">看这里</a>          </li>
<li>volatile 禁止指令重排的原理？ (赋值后lock,相当于store 和 write操作) ，volatile、synchronize、final 都能保证可见性 ，volatile、synchronize、锁 可以保证有序性  <a href="https://glassx.gitee.io/2019/09/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC12%E7%AB%A0/">看这里</a>                 </li>
<li>线程状态转换？ <a href="https://glassx.gitee.io/2019/09/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC12%E7%AB%A0/">看这里</a>                 </li>
<li>实现线程安全的方法？(互斥同步、非阻塞同步-CAS操作、无同步-无共享)  synchronized 关键字原理？     <a href="https://glassx.gitee.io/2019/09/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC13%E7%AB%A0/">看这里</a>           </li>
<li>锁优化方式？(自旋、消除、粗化、轻量级、偏向)  ，<a href="https://glassx.gitee.io/2019/09/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC13%E7%AB%A0/">看这里</a>          </li>
<li>为什么不是总选择tcp，而要在有时候udp呢？ udp 首部应该包括什么呢？ <a href="https://glassx.gitee.io/2020/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87%E7%AC%AC6%E7%89%88-%E7%AC%AC3%E7%AB%A0/">看这里</a>                </li>
<li>快重传、流量控制、拥塞控制 分别是啥？拥塞控制 的确定？ 拥塞控制的算法？-慢启动、拥塞避免、快速恢复      ，<a href="https://glassx.gitee.io/2020/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87%E7%AC%AC6%E7%89%88-%E7%AC%AC3%E7%AB%A0/">看这里</a>                 </li>
<li>ssl握手流程？ <a href="https://glassx.gitee.io/2020/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87%E7%AC%AC6%E7%89%88-%E7%AC%AC8%E7%AB%A0/">看这里</a>                 </li>
<li>TCP的时延有哪些？(握手、慢启动的拥塞控制、捎带确认)，http性能提升手段？(并行连接-发起多条tcp连接、持久连接、管道化发送-同一条tcp连接连续发送多条，无需等回复)， <a href="https://glassx.gitee.io/2018/05/21/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0/">看这里</a>             </li>
<li>签名是加了密的校验和。<a href="https://glassx.gitee.io/2018/05/25/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC14%E7%AB%A0/">看这里</a>               </li>
<li>死锁条件？(互斥条件、不可剥夺、保持等待、环路等待)，<a href="https://glassx.gitee.io/2018/05/30/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-%E7%AC%AC6%E7%AB%A0/">看这里</a>          </li>
<li>第一次启动Service 会执行 onCreate，多次启动则 onStartCommand 多次启动   ，<a href="https://glassx.gitee.io/2018/07/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%8D%81%E7%AB%A0/">看这里</a>      </li>
<li>debug 包获取cookies： adb shell ，run-as ，再cd 到目录即可，  <a href="https://glassx.gitee.io/2020/02/27/Android%E8%8E%B7%E5%8F%96debug%E5%8C%85%E7%9A%84cookies%E7%9A%84db%E6%96%87%E4%BB%B6/">看这里</a>       </li>
<li>Toast显示流程 <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>             </li>
</ol><a id="more"></a>
<h2 id="Android开发高手课"><a href="#Android开发高手课" class="headerlink" title="Android开发高手课"></a>Android开发高手课</h2><ol>
<li>Android 的bitmap 内存分配随着 Android 版本的变化过程？NativeAllocationRegistry? <a href="https://glassx.gitee.io/2020/05/27/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-3,4%E8%AF%BE/">看这里</a>             </li>
<li>卡顿考虑cpu，怎么看？ 用户时间过多或者 系统调用时间过多？ <a href="https://glassx.gitee.io/2020/05/27/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-5,6%E8%AF%BE/">看这里</a>                  </li>
<li>启动优化方式？(闪屏-当做view浮、业务优先级梳理、线程优化-线程池控制总量)，监控指标？  ，<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-7,8%E8%AF%BE/">看这里</a>           </li>
<li>ppi、dpi、density？ dp * density = px ，软件绘制/硬件绘制流程 ，硬件绘制为啥快， surface 与window 关系，<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-20%E8%AF%BE/">看这里</a>            </li>
<li>ui优化方式？(硬件加速、view创建-不用xml-提前创建/异步创建-重用、measure/layout优化-减少层次-constranlayout-背景优化)  ，<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-21%E8%AF%BE/">看这里</a>                  </li>
<li>完整的网络请求？ <a href="https://glassx.gitee.io/2020/06/26/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-16,17%E8%AF%BE/">看这里</a>               </li>
<li>sp 缺点？替代方式？ContentProvider注意事项？    <a href="https://glassx.gitee.io/2020/06/28/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-12%E8%AF%BE/">看这里</a>               </li>
<li>Serializable 的原理？Parcelable 的永久存储？  <a href="https://glassx.gitee.io/2020/07/04/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-13%E8%AF%BE/">看这里</a>              </li>
</ol>
<h2 id="高级进阶课"><a href="#高级进阶课" class="headerlink" title="高级进阶课"></a>高级进阶课</h2><p><a href="https://glassx.gitee.io/2020/04/19/%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E8%AF%BE%E7%A8%8B/">全部链接</a>        </p>
<ol>
<li>如何停止线程？为什么stop和suspend会有问题？               </li>
<li>ThreadLocal 使用建议          </li>
<li>禁止指令重排的方法？可见性方法？保证原子性方法？              </li>
<li>HashTable问题？ConcurrentHashMap？ ConcurrentHashMap的解决方案？所以，如何进行锁优化？         </li>
<li>Rxjava 存在的问题？         </li>
<li>cpu 架构适配优化方案？？</li>
<li>Activity 是通过反射创建出来的，所以不要去写它的构造函数。同理，Fragment 也不要去写，因为恢复Fragment的时候，也是反射的，这也是为什么我们推荐使用argument 传递参数的原因              </li>
<li>在 resume 回调之后，才调用 makeVisible 将 DecorView 展示出来(layout,draw)，所以在resume之前我们是无法准确获得view的高度的                   </li>
<li>如何启动外部应用的Activity？ (uid、exported-且全路径，action和category)，为了避免别的应用乱启动 exported 的Acivity，可以给Activity 添加权限，没有在Manifest中声明就启动不了                </li>
<li>别人如何攻击暴露的Activity产生异常？            </li>
<li>如何在任意位置为当前Activity 添加View ？           </li>
<li>为什么不能在非主线程更新ui？一定不能吗？               </li>
<li>ANR 怎么产生的，Looper 为什么不会cpu占用过高？             </li>
<li>内存越大越好吗？不，导致gc时间长，避免oom？bitmap选择合适分辨率，不要使用帧动画，bitmap重采样，Native Heap 优雅避免堆限制  谨慎多进程？新进程会有一些公共资源，也是会消耗内存的                  </li>
<li>如何对图片进行缓存？           </li>
<li>如何计算图片大小？                 </li>
<li>图片体积优化？ 图片格式无关跟argb_8888或者565有关、裁剪合适尺寸、采样、矩阵变换来放大图片、.9             </li>
<li>如何开展优化工作？ 目标-找原因-优化           </li>
<li>如何设计短视频？视频处理、来源、分享、打赏、社交、聊天、耗电问题、防止视频泄露、防止广告劫持                </li>
<li>如何设计网络框架？  http和websocket、异步、可移植性、缓存策略、拦截器、日志、重试机制-重试多少次-间隔、结果组装            </li>
</ol>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol>
<li>mvc、mvp、mvvm 设计模式区别？ mvc中view可以直接改数据         <a href="https://glassx.gitee.io/2019/11/23/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">看这里</a>                  </li>
<li>Android中内存分配的执行流程？ Android GC 过程？ <a href="https://glassx.gitee.io/2019/11/23/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%99%9A%E6%8B%9F%E6%9C%BA/">看这里</a>                 </li>
<li>三次握手？为毛3次能2次吗？ 序列号为什么随机？握手会有什么安全问题？三次握手可以携带数据吗？ <a href="https://glassx.gitee.io/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">看这里</a>            </li>
<li>TCP与udp 区别 ？ 不用维护连接， <a href="https://glassx.gitee.io/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">看这里</a>            </li>
<li>啥是中间人攻击？  http1与http2的区别？    <a href="https://glassx.gitee.io/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/">看这里</a>          </li>
<li>RxJava 线程切换原理？<a href="https://glassx.gitee.io/2019/11/20/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/">看这里</a>       </li>
<li>为什么使用fresco？ThreadLocal 原理？LocalBroadcastManager 原理？<a href="https://glassx.gitee.io/2019/11/20/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/">看这里</a>           </li>
<li>ThreadPoolExecutor 原理？线程池异常处理？AsyncTask 源码解析？ <a href="https://glassx.gitee.io/2019/11/20/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/">看这里</a>      </li>
<li>Synchronized 与 Lock 的区别？ <a href="https://glassx.gitee.io/2019/11/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86/">看这里</a>        </li>
<li>wait、notify、notifyAll 方法在object 类中，而sleep 在Thread 类中? notify/wait 方法为什么一定要放在同步块中？ <a href="https://glassx.gitee.io/2019/11/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86/">看这里</a>      </li>
<li>synchronized原理？单例中，volatile 的作用？如何停止一个线程 ？ <a href="https://glassx.gitee.io/2019/11/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86/">看这里</a>     </li>
<li>写个死锁程序？ <a href="https://glassx.gitee.io/2019/11/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86/">看这里</a>     </li>
<li>synchronized 锁持有的object 是Thread 对象的情况?同理，Java 中的 join原理？  <a href="https://glassx.gitee.io/2019/11/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86/">看这里</a>     </li>
<li>集合-ArrayList、LinkedList、HashMap、HashTable、ConcurrentHashMap、LinkedHashMap、WeakHashMap、TreeMap <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>    </li>
<li>泛型信息不会进入到运行时阶段，由于系统中并不会真正生成泛型类，因此，instanceof运算符后不能使用泛型类          </li>
<li>抽象类和接口的区别，<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>transient 关键字， <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>        </li>
<li>Java 的finally 与 return 的执行顺序 ？system.exit(0)、正常情况return语句先返回，但没有真正返回值，等finally执行完后真正返回、finally中有return则会覆盖try中的return、finally没有return，则看情况，如果是简单类型，则在finally中改没关系，如果是复杂类型，改了就会影响最终值 <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>              </li>
<li>Java 中HashCode 与 equals 方法理解，HashCode 生成注意事项？同一个对象多次调用hashcode都是一致的、两个对象相等，则hashcode要相等、两个对象不相等，尽量hashcode不相等，避免Hashmap等冲突、int型防止溢出 <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>类的初始化步骤是啥？  <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>         </li>
<li>String、StringBuilder、StringBuffer、CharSequence 区别？本质都是通过字符数组实现的，StringBuilder 和StringBuffer 初始空间都是16，如果超过，就申请新的空间，并把老数组赋值过去。 <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>     </li>
<li>String 为毛设计成不可变？字符串常量需要、String的HashCode被频繁使用，会缓存HashCode、为了安全：用在url之类的场合。 一定不可变吗？  <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>        </li>
<li>成员内部类、静态内部类、局部内部类和匿名内部类的理解。内部类的优势：方便组织类关系、完善的Java的多继承机制、方便实现事件驱动程序(如点击事件)<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/">看这里</a>       </li>
<li>是否可以在子线程更新UI？首先settext了，然后执行ViewGroup的invalidateChild，最后在ViewRootImpl中检测线程，而在onCreate中，由于attachInfo 还是空的，所以走不到ViewRootImpl，走不了检查线程，所以可以设置。 可以参考<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">这里</a>、<a href="https://glassx.gitee.io/2020/04/19/%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E8%AF%BE%E7%A8%8B/">以及这里</a>     </li>
<li>LruCache原理。<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>Handler 机制？如何保证一个线程一个Looper？postDelay 怎么实现？ nativePollOnce 和 nativeWake 分别来阻塞和唤起线程。  Android 的消息屏障？Handler三种消息：同步消息、异步消息、消息屏障。  通过MessageQueue.postSyncBarrier 来发送屏障，消息屏障就是没有target字段的Message，需要手动移除，屏障在就会执行查询异步消息，知道移除屏障。   IdelHandler？ <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>       </li>
<li>RecyclerView 的优化方式？ 如何保存嵌套 RecyclerView 的滑动装填？ <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>     </li>
<li>Activity 生命周期几种普通情况。  <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>谈谈对Application 的理解？即有啥特性、有什么坑？ <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>Binder 理解？ 为什么要使用Binder 机制进程间通信？-五个维度 <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>    </li>
<li>Android 为什么用Bundle 而不是使用HashMap 来传递数据？  <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>       </li>
<li>SharedPreference 的理解 ？ <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>常见内存泄漏场景 ？如何监测？LeakCanary 的原理是啥？ <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>     </li>
<li>APK 安装步骤。 <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>ListView 原理？  <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>     </li>
<li>Android 5.0, 6.0, 7.0, 8.0新特性 ？   <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>        </li>
<li>UI卡顿之BlockCanary？  <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>       </li>
<li>Android 中大图加载 ？如果不需要展示，则BitmapFactory.option设置inJustDecodeBounds即可、图片非常多，可以使用LruCache、 <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>     </li>
<li>彻底理解android 应用无响应机制？<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>      </li>
<li>理解Android签名？<a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>       </li>
<li>为什么 epoll 快？   <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>        </li>
<li>BroadCastReceiver 怎么执行耗时操作(异步)？  <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里</a>       </li>
</ol>
<h2 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h2><ol>
<li>HashMap 为毛链表转成红黑树？红黑树特点？  <a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>      </li>
<li>一个无序，实际上是逆序的数组排序用什么算法好？  <a href="https://blog.csdn.net/hongtaya/article/details/105548059?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">看这里-参考别人的博客</a>            </li>
<li>Android heap 的结构？主要用来分配对象的堆空间 Zygote Space 和 Allocation Space 的底层都是匿名共享内存，使用C库的 malloc 和 free 来进行管理，<strong>通过 dlmalloc 技术来尽量解决碎片</strong>问题。 <a href="https://blog.csdn.net/luoshengyang/article/details/42492621" target="_blank" rel="noopener">看这里</a>      </li>
<li>多个Fragment 销毁后重建之后重叠？ <a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>      </li>
<li>Bitmap 能否复用？怎么复用？  <a href="https://glassx.gitee.io/2020/05/27/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-3,4%E8%AF%BE/">看这里</a>       </li>
<li>TreeMap 如何对两个元素比较？HashMap 转红黑树的时候，怎么比较？ 非compareble对象如何比较？ <a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>      </li>
<li>object 有哪些方法？ <a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>        </li>
<li>Android系统中存在的代理模式？理解动态代理和静态代理？ <a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>         </li>
<li>SharedPreference 是线程/进程 安全的吗？apply和commit 有什么区别(提交到哪？内存还是本地xml)？有什么坑？<a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>      </li>
<li>Handler 中我想指定某个消息先执行，可以吗？ <a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>         </li>
<li>http与http2的区别？http与https区别？https怎么做到安全的？ <a href="https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/">看这里</a>           </li>
<li>java中this编译时的原理？<strong>构造方法(对，构造方法也是)</strong>、实例方法第一个参数就是this，它的类型为Base，这是编译器自动添加的。 <a href="https://blog.csdn.net/weixin_41920291/article/details/98118035" target="_blank" rel="noopener">可以看别人的博客了解</a>              </li>
<li>Android 自定义控件方式？———————</li>
<li>fresco加载图片原理？ 优势是什么？ ashmem 减少gc，webp            </li>
<li>事件分发 cancel事件一般在什么时候被触发？ 某个子View处理了Down事件之后，那么接下来的 Move 和 Up 事件也会交给他处理，但在交给他处理前，父view还是可以拦截事件的，如果拦截了事件，子View就会收到一个Cancel事件，并且不会收到后续的Move 和Up事件。 <a href="https://blog.csdn.net/cufelsd/article/details/89471402" target="_blank" rel="noopener">看这里</a>       </li>
<li>onSaveInstanceState 调用时机。onSaveInstanceState是Activity的生命周期方法，主要用于在Activity 销毁时保存信息，Activity 只执行opause时(打开的另一个Activity透明)，在 Android 3.0 及以上不会执行 onSaveInstanceState，以下就会执行。当Activity 执行 onStop 时，就都会执行 onSaveInstanceState。 <a href="https://blog.csdn.net/qq_23547831/article/details/51464535" target="_blank" rel="noopener">看这里</a>        </li>
<li>Fragment View区别？ Fragment复用粒度更大、从代码设计上Fragment可以提高代码内聚、Fragment完整的生命周期、Fragment更复杂，消耗资源大。<a href="https://blog.csdn.net/mba16c35/java/article/details/44408623" target="_blank" rel="noopener">看这里</a>        </li>
<li>notifyAll方法唤醒的线程，怎么决定哪一个线程得到运行?</li>
<li>handler的sendMessage方法和postRunable方法区别?</li>
</ol>
<h2 id="针对xx的问题"><a href="#针对xx的问题" class="headerlink" title="针对xx的问题"></a>针对xx的问题</h2><p><a href="https://glassx.gitee.io/2019/03/08/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%92%88%E5%AF%B9%E7%AE%80%E5%8E%86%E7%9A%84%E9%97%AE%E9%A2%98/">统一的链接看这里</a></p>
<ol>
<li>聊聊kotlin的协程？优缺点？适用场景？kotlin 如何实现空安全？       </li>
<li>MeasureSpec 的理解？            </li>
<li>如何处理手势冲突？内部法和外部法            </li>
<li>如何优化App的性能？具体指标变化如何？               </li>
<li>ArrayMap 与 SparseArray 的原理？         </li>
<li>三次握手和四次挥手？           </li>
<li>锁的种类？       </li>
<li>HandlerThread?run的时候prepare() 了，退出的时候需要执行 handlerThread.quit() 以便退出loop        </li>
<li>IntentService 原理？多次调用Service 会咋样？为毛 onHandleIntent 之后，执行的是 stopSelf(int) ？           </li>
<li>什么是大接口？为毛要用大接口？如何实现？            </li>
<li>怎样防止劫持？             </li>
<li>聊聊内部sdk的设计？有什么收获？           </li>
<li>最有成就感的？最棘手的？          </li>
<li>为了安全，做了哪些努力？ apk签名校验、https证书校验、本地广播、sp加密             </li>
<li>平时逛论坛？关注的技术？  </li>
<li>如何做的证书校验？ <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里Android基础</a>     </li>
<li>如何移除Handler的Message？有啥坑吗？ <a href="https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/">看这里Android基础</a>       </li>
<li>如何性能优化？lint无用资源、Application减轻负担(主进程，小sp，框架减少人为)、ui绘制优化(硬件加速、view创建优化-代码创建-提前-异步-View重用、measure/layout-布局层次-ConstranLayout减少layout开销-去除无用背景-shapelayout代替xml的shape)、启动优化（flash页面、减少cpu集中）、内存(泄漏、容器避免自动装箱、正确使用引用)、cpu(解析放在子线程、sp存储json、避开高峰-IdelHandler、线程管理-数量-线程池,启动过程勿出现io-负载高的时候，io性能下降很快)、网络优化(dns加速)、结构(mvp)、尽量不要有io操作   <a href="https://glassx.gitee.io/2019/03/08/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%92%88%E5%AF%B9%E7%AE%80%E5%8E%86%E7%9A%84%E9%97%AE%E9%A2%98/">看这里</a>、<a href="https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-7,8%E8%AF%BE/">以及Android开发高手课</a></li>
</ol>
<p>ANR 定位？tcp与udp</p>
<h2 id="基本排序"><a href="#基本排序" class="headerlink" title="基本排序"></a>基本排序</h2><p>插入排序：O(n^2)复杂度，稳定的排序<br>选择排序： 复杂度总是 O(n^2)，每次挑最大最小的，因此不稳定                    </p>
<p>shell 排序： 最差的时候：O(n^2)   平均复杂度 ： nlogn，不稳定<br>冒泡：有序的情况，一趟完成，OO(n)，平均复杂度O(n^2)，稳定的排序<br>快排序： 分治思想，平均 nlogn ，最坏 O(n^2)，交换数据啊，不稳定<br>堆排序：最坏最好和平均都是   nlogn  ，不稳定<br>归并排序： 分治思想，时间复杂度  nlogn ，稳定，主要用于外部排序</p>
<p>归并和快排的平均时间复杂度差不多，但是比快排最差情况要好。但是归并使用的空间比较多，因此一般情况下选择快排               </p>
<p>不稳定的排序：希尔、堆、快排</p>
<p>初始化顺序？</p>
]]></content>
      <categories>
        <category>阶段</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章：View体系与自定义View《一》</title>
    <url>/2019/07/06/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89-%E7%AC%AC3%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>Android 系统中有两种坐标系：Android 坐标系和 View 坐标系，了解这两种坐标系能够帮助我们实现View的各种操作。</p><h3 id="Android坐标系"><a href="#Android坐标系" class="headerlink" title="Android坐标系"></a>Android坐标系</h3><p>Android坐标系中， 将屏幕左上角的顶点作为原点， 这个原点向右是X轴正方向， 向下是Y轴正方向， 如下图所示。</p><p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89/Android%E5%9D%90%E6%A0%87.png" alt="Android坐标系"></p><h3 id="View坐标系"><a href="#View坐标系" class="headerlink" title="View坐标系"></a>View坐标系</h3><p>View坐标系与Android坐标系并不冲突，两者是共同存在的，一起来帮助开发者更好地控制View。对于View坐标系，搞明白下图的信息即可：</p><a id="more"></a>



<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89/View%E5%9D%90%E6%A0%87.png" alt="View坐标系"></p>
<p><strong>MotionEvent提供的方法：</strong>假设上图中间的那个圆点就是我们触摸点，无论是View还是ViewGroup，最终的点击事件都会由onTouchEvent(MotionEvent event)方法来处理。MotionEvent提供了获取焦点坐标的各种方法：</p>
<blockquote>
<ul>
<li>getX()：获取点击事件距离控件左边的距离，即视图坐标。  </li>
</ul>
</blockquote>
<ul>
<li>getY()：获取点击事件距离控件顶边的距离，即视图坐标。  </li>
<li>getRawX()：获取点击事件距离整个屏幕左边的距离，即绝对坐标。  </li>
<li>getRawY()：获取点击事件距离整个屏幕顶边的距离，即绝对坐标。  </li>
</ul>
<h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><p>View的滑动基本思想：当点击事件传到View时，系统记下触摸点的坐标，手指移动时系统记下移动后触摸的坐标并算出偏移量，并通过偏移量来修改View的坐标。 实现View滑动有很多种方法， 在这里主要讲解6种滑动方法， 分别是layout()、offsetLeftAndRight() 与 offsetTopAndBottom()、LayoutParams、动画、scollTo 与 scollBy ，以及Scroller。</p>
<h3 id="layout方法"><a href="#layout方法" class="headerlink" title="layout方法"></a>layout方法</h3><p>View进行绘制的时候会调用onLayout()方法来设置显示的位置， 因此我们同样也可以通过修改View的left、 top、 right、 bottom属性来控制View的坐标。以下是实现一个随手指滑动的自定义view的步骤：</p>
<ol>
<li>首先获取触摸点的坐标</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取手指触摸点的横坐标和纵坐标</span></span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (event.getAction())&#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在ACTION_MOVE事件中计算偏移量,再调用layout（ ） 方法重新放置这个自定义View的位置即可:</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">    <span class="comment">//计算移动距离</span></span><br><span class="line">     <span class="keyword">int</span> offsetX = x - lastX;</span><br><span class="line">     <span class="keyword">int</span> offsetY = y - lastY;</span><br><span class="line">     <span class="comment">//调用layout方法来重新确定它的位置</span></span><br><span class="line">     layout(getLeft() + offsetX,getTop()+offsetY,</span><br><span class="line">     getRight()+offsetX,getBottom()+offsetY)</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>在每次移动时都会触发layout()方法对屏幕重新布局，从而达到移动View的效果。</p>
<h3 id="offsetLeftAndRight-与offsetTopAndBottom"><a href="#offsetLeftAndRight-与offsetTopAndBottom" class="headerlink" title="offsetLeftAndRight() 与offsetTopAndBottom()"></a>offsetLeftAndRight() 与offsetTopAndBottom()</h3><p>这两种方法和layout()方法的效果以及使用方式都差不多，只需要将上面ACTION_MOVE中的代码替换为以下代码即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">    <span class="comment">//计算移动距离</span></span><br><span class="line">     <span class="keyword">int</span> offsetX = x - lastX;</span><br><span class="line">     <span class="keyword">int</span> offsetY = y - lastY;</span><br><span class="line">     <span class="comment">//对left 及 right 进行偏移</span></span><br><span class="line">     offsetLeftAndRight(offsetX);</span><br><span class="line">     <span class="comment">//对top及bottom进行偏移</span></span><br><span class="line">     offsetTopAndBottom(offsetY);</span><br><span class="line">     <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="LayoutParams（-改变布局参数）"><a href="#LayoutParams（-改变布局参数）" class="headerlink" title="LayoutParams（ 改变布局参数）"></a>LayoutParams（ 改变布局参数）</h3><p>LayoutParams主要保存了View的布局参数， 因此可以通过改变它来达到改变View位置的效果。 我们只需将 ACTION_MOVE 中的代码替换成如下代码即可(<strong>注意是：MarginLayoutParams</strong>)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">    <span class="comment">//计算移动距离</span></span><br><span class="line">     <span class="keyword">int</span> offsetX = x - lastX;</span><br><span class="line">     <span class="keyword">int</span> offsetY = y - lastY;</span><br><span class="line">     ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams)getLayoutParams();</span><br><span class="line">     </span><br><span class="line">     params.leftMargin = getLeft() + offsetX;</span><br><span class="line">     params.topMargin = getTop() + offsetY;</span><br><span class="line">     setLayoutParams(params)</span><br><span class="line">     <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>采用动画来移动，在res目录新建anim文件夹并创建如下translate.xml文件:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fillAfter</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXDelta</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXDelta</span>=<span class="string">"300"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在Java中调用：</p>
<blockquote>
<p>view.setAnimation(AnimationUtils.loadAnimation(this,R.anim.translate))</p>
</blockquote>
<p>需要注意的是，如果动画文件中没有添加 <strong>android:fillAfter=”true”</strong> ，则方块向右平移300像素后，又返回原来的位置。并且，View动画不能改变View的位置参数，如果对一个Button加上如上的平移动画，当Button平移300像素停留在当前位置时，我们点击这个Button并不会触发点击事件，但是点击原始位置却触发了点击事件，这是因为对于系统来说，Button并没有改变原来位置。</p>
<p>在Android 3.0出现的属性动画解决了上述问题，它不仅可以执行动画，还能改变View的位置参数，其操作如下：</p>
<blockquote>
<p>ObjectAnimator.ofFloat(view,”translationX”，0，300).setDuration(1000).start()</p>
</blockquote>
<h3 id="scrollTo-与-scrollBy"><a href="#scrollTo-与-scrollBy" class="headerlink" title="scrollTo 与 scrollBy"></a>scrollTo 与 scrollBy</h3><p>scollTo、scollBy移动的是<strong>View的内容</strong>，如果在ViewGroup中使用， 则是移动<strong>其所有的子View</strong>。scrollTo(x，y)表示移动到一个具体的坐标点，而scrollBy(dx，dy)则表示移动的增量为dx、dy。 其中， scollBy最终也是要调用scollTo的。二者的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mScrollX != x || mScrollY != y)&#123;</span><br><span class="line">        <span class="keyword">int</span> oldX = mScrollX;</span><br><span class="line">        <span class="keyword">int</span> oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        </span><br><span class="line">        invalidateParentCaches();</span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        <span class="keyword">if</span>(!awakenScrollBars())&#123;</span><br><span class="line">            postInvalidateOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要实现上面view随手指滑动的效果，就需要将ACTION_MOVE中的代码替换成如下代码：</p>
<blockquote>
<p>((View)getParent()).scrollBy(-offsetX,-offsetY);</p>
</blockquote>
<p>请注意，这里是对view的parent进行scroll，这是因为如果对view本身scroll的话，就是对自己的内容进行移动，而不是整个view。并且注意，这里设置的偏移量值都为负值，以下具体讲解一下。</p>
<p><strong>假设我们正用放大镜来看报纸，放大镜用来显示字的内容。同样我们可以把放大镜看作我们的手机屏幕，它们都是负责显示内容的；而报纸则可以被看作屏幕下的画布，它们都是用来提供内容的。放大镜外的内容，也就是报纸的内容不会随着放大镜的移动而消失，它一直存在。同样，我们的手机屏幕看不到的视图并不代表其不存在。过程的示意图如下：</strong></p>
<p>scrollBy之前：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89/scrollTo%E5%88%9D%E5%A7%8B.png" alt="scrollBy初始状态"></p>
<p>调用scrollBy(50,50)之后：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89/scrollBy%E4%B9%8B%E5%90%8E.png" alt="scrollBy之后"></p>
<h3 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h3><p>我们在用scollTo/scollBy方法进行滑动时，这个过程是瞬间完成的，所以用户体验不大好。这里我们可以使用 Scroller 来实现有过渡效果的滑动，这个过程不是瞬间完成的，而是在一定的时间间隔内完成的。Scroller本身是不能实现View的滑动的，它需要与View的computeScroll() 方法配合才能实现弹性滑动的效果。具体代码如下示意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomView</span><span class="params">(Context context,AttributeSet attrs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Scroller mScroller;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">super</span>(context,attrs);</span><br><span class="line">    <span class="comment">//初始化mScroller</span></span><br><span class="line">    mScroller = <span class="keyword">new</span> Scroller(conetxt);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.computeScroll();</span><br><span class="line">        <span class="keyword">if</span>(mScroller.computeScrollOffset())&#123;</span><br><span class="line">            ((View)getParent()).scrollTo(mScroller.getCurrentX(),mScroller.getCurrentY());</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提供调用的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX,<span class="keyword">int</span> destY)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> scrollX = getScrollX();</span><br><span class="line">        <span class="keyword">int</span> scrollY = getScrollY();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> deltaX = destX - scrollX;</span><br><span class="line">        <span class="keyword">int</span> deltaY = destY - scrollY;</span><br><span class="line">        mScroller.startScroll(scrollX, scrollY, deltaX, deltaY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先初始化Scroller，之后重写computeScroll方法，系统会在绘制View的时候在 draw 方法中调用该方法。在computeScroll方法中， 我们调用父类的scrollTo() 方法并通过Scroller来不断获取当前的滚动值， 每滑动一小段距离我们就调用invalidate() 方法不断地进行重绘，重绘就会调用computeScroll()方法， 这样我们通过不断地移动一个小的距离并连贯起来就实现了平滑移动的效果。这里我们设定CustomView沿着X轴向右平移400像素(至于为什么是负数，上面已经解释过了):</p>
<blockquote>
<p>mCustomView.smoothScrollTo(-400,0);</p>
</blockquote>
<h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>在属性动画出现之前，Android系统提供的动画只有帧动画和 View 动画。View 动画我们都了解，它提供了AlphaAnimation、 RotateAnimation、 TranslateAnimation、 ScaleAnimation这4种动画方式，并提供了AnimationSet动画集合来混合使用多种动画。 随着Android 3.0属性动画的推出， View动画不再风光。 相比属性动画， View动画一个非常大的缺陷突显， 其不具有交互性。 当某个元素发生View动画后，其响应事件的位置依然在动画进行前的地方， 所以View动画只能做普通的动画效果， 要避免涉及交互操作。 但是它的优点也非常明显： 效率比较高， 使用也方便。 </p>
<p>在属性动画中使用最多的就是AnimatorSet和ObjectAnimator配合： 使用 ObjectAnimator 进行更精细化的控制， 控制一个对象和一个属性值， 而使用多个ObjectAnimator组合到AnimatorSet形成一个动画。 属性动画通<br>过调用属性get、 set方法来真实地控制一个View的属性值， 因此， 强大的属性动画框架基本可以实现所有的动画效果。</p>
<h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><p>ObjectAnimator 是属性动画最重要的类， 创建一个 ObjectAnimator 只需通过其静态工厂类直接返还一个ObjectAnimator对象。 参数包括一个对象和对象的属性名字， 但这个属性必须有get和set方法， 其内部会通<br>过Java反射机制来调用set方法修改对象的属性值。 一般使用方式如下：</p>
<blockquote>
<p>ObjectAnimator.ofFloat(view,”translationX”,200,0).start()</p>
</blockquote>
<p>ObjectAnimator的使用方法就不介绍了，需要注意的是， 在使用ObjectAnimator的时候， 要操作的属性必须要有get和set方法， 不然ObjectAnimator 就无法生效。 如果一个属性没有get、 set方法， 也可以通过自定义一个属性类或包装类来间接地给这个属性增加get和set方法。 如以下示例这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> View mTarget;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyView</span><span class="params">(View target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mTarget = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mTarget.getLayoutParams().widht</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span></span>&#123;</span><br><span class="line">        mTarget.getLayoutParams().width = width;</span><br><span class="line">        mTarget.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时只需要操作包类就可以调用get、 set方法了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyView mMyView = <span class="keyword">new</span> MyView(mButton);</span><br><span class="line">ObjectAnimator.ofInt(mMyView,<span class="string">"width,500).setDuration(500).start()</span></span><br></pre></td></tr></table></figure>

<h3 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h3><p>ValueAnimator不提供任何动画效果， 它更像一个数值发生器， 用来产生有一定规律的数字， 从而让调用者控制动画的实现过程。 通常情况下， 在ValueAnimator的AnimatorUpdateListener中监听数值的变化， 从而完成动画的变换。</p>
<h3 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a>AnimatorSet</h3><p>略</p>
<h3 id="在XML中使用属性动画"><a href="#在XML中使用属性动画" class="headerlink" title="在XML中使用属性动画"></a>在XML中使用属性动画</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectAnimator</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"3000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:propertyName</span>=<span class="string">"scaleX"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueFrom</span>=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueTo</span>=<span class="string">"2.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueType</span>=<span class="string">"floatType"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在代码中引用xml属性动画也很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animator animator = AnimatorInflater.loadAnimator(<span class="keyword">this</span>,R.anim.scale);</span><br><span class="line">animator.setTarget(view);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>

<h2 id="解析Scroller"><a href="#解析Scroller" class="headerlink" title="解析Scroller"></a>解析Scroller</h2><p>略，去看源码，看不懂再来添加这块内容</p>
<h2 id="View-事件分发机制"><a href="#View-事件分发机制" class="headerlink" title="View 事件分发机制"></a>View 事件分发机制</h2><p>这里了解Activity的构成就好了，如下图：</p>
<p><img src="/assets/Book-Notes/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89/Activity%E6%9E%84%E6%88%90.png" alt="Activity构成"></p>
<p>事件分发机制则看<a href="https://glassx.github.io/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">之前写的文章</a>还容易理解一些，这里就略过了。</p>
<h2 id="View的工作流程"><a href="#View的工作流程" class="headerlink" title="View的工作流程"></a>View的工作流程</h2><p>这一章太长，作为第二部分内容。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android进阶之光</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的git命令</title>
    <url>/2019/07/06/git%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>常用的git命令（摘抄自官网）</p><h2 id="列显已有的标签"><a href="#列显已有的标签" class="headerlink" title="列显已有的标签"></a>列显已有的标签</h2><p>列出现有标签的命令非常简单，直接运行 git tag 即可：</p><blockquote>
<p>$ git tag<br>v0.1<br>v1.3</p>
</blockquote><p>我们可以用特定的搜索模式列出符合条件的标签。在 Git 自身项目仓库中，有着超过 240 个标签，如果你只对 1.4.2 系列的版本感兴趣，可以运行下面的命令：</p><a id="more"></a>



<blockquote>
<p>$ git tag -l ‘v1.4.2.*’<br>v1.4.2.1<br>v1.4.2.2<br>v1.4.2.3<br>v1.4.2.4</p>
</blockquote>
<h2 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h2><h3 id="含附注的标签"><a href="#含附注的标签" class="headerlink" title="含附注的标签"></a>含附注的标签</h3><p>创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可：</p>
<blockquote>
<p>$ git tag -a v1.4 -m ‘my version 1.4’</p>
</blockquote>
<h2 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h2><p>轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可：</p>
<blockquote>
<p>$ git tag v1.4-lw</p>
</blockquote>
<h2 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h2><p>默认情况下，git push  并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可：</p>
<blockquote>
<p>$ git push origin v1.5</p>
</blockquote>
<p>如果要一次推送所有本地新增的标签上去，可以使用 –tags 选项：</p>
<blockquote>
<p>$ git push origin –tags</p>
</blockquote>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><p>删除本地分支可以使用一下命令：</p>
<blockquote>
<p>$ git branch -d testing</p>
</blockquote>
<p>如果删除失败，需要强制删除可以使用 -D 选项强制删除它：</p>
<blockquote>
<p>$ git branch -D testing</p>
</blockquote>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><blockquote>
<p>可以运行带有 –delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：</p>
</blockquote>
<blockquote>
<p>$ git push origin –delete serverfix<br>To <a href="https://github.com/schacon/simplegit" target="_blank" rel="noopener">https://github.com/schacon/simplegit</a></p>
<ul>
<li>[deleted]         serverfix</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>查阅工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章——View的事件体系</title>
    <url>/2019/05/12/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC3%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="View-基础知识"><a href="#View-基础知识" class="headerlink" title="View 基础知识"></a>View 基础知识</h2><h3 id="1、-MotionEvent-和-TouchSlop"><a href="#1、-MotionEvent-和-TouchSlop" class="headerlink" title="1、 MotionEvent 和 TouchSlop"></a>1、 MotionEvent 和 TouchSlop</h3><h4 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h4><p>这里只需要注意一点，通过MotionEvent 可以获得点击事件发生的x和y坐标，系统提供了两组方法，getX/getY 和 getRawX/getRawY ，他们的区别很简单，前者返回的是相对于当前View的左上角的 x 和 y 坐标，后者返回的是相对于手机屏幕左上角的 x和y 坐标。</p><a id="more"></a>
<h4 id="TouchSlop"><a href="#TouchSlop" class="headerlink" title="TouchSlop"></a>TouchSlop</h4><p>TouchSlop 是系统所能识别出的被认为是滑动的最小距离，小于这个值就不认为是滑动操作。TouchSlop 是一个常量，和设备有关，在不同的设备上这个值可能是不同的。通过如下方式可以获取这个常量：</p>
<blockquote>
<p>ViewConfiguration.get(context).getScaledTouchSlop()</p>
</blockquote>
<h3 id="2、VelocityTracker、GestureDetector-和-Scroller"><a href="#2、VelocityTracker、GestureDetector-和-Scroller" class="headerlink" title="2、VelocityTracker、GestureDetector 和 Scroller"></a>2、VelocityTracker、GestureDetector 和 Scroller</h3><h4 id="VelocityTracker"><a href="#VelocityTracker" class="headerlink" title="VelocityTracker"></a>VelocityTracker</h4><p>用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。它的使用过程很简单，首先在 View 的 onTouchEvent 方法中追踪当前单击事件的速度：</p>
<blockquote>
<p>VelocityTracker velocityTracker = VelocityTracker.obtain();<br>velocityTracker.addMovement(event);</p>
</blockquote>
<p>接着，当我们想知道当前的滑动速度时，可以采用如下方法获得：</p>
<blockquote>
<p>velocityTracker.computeCurrentVelocity(1000);<br>int xVelocity = (int)velocityTracker.getXVelocity();<br>int yVelocity = (int)velocityTracker.getYVelocity();</p>
</blockquote>
<p>这里需要注意的是： 一、获取速度之前必须先计算速度；二、这里的速度是指一段时间内手指所划过的像素数，比如将时间间隔设置为 1000ms，在 1s 内水平从左至右滑过100像素，那么水平速度就是100 。如果将时间间隔设置为100ms，在这100ms 内滑过10像素，则水平速度会变成 10 。此外，这个速度是可以为负值的，当水平方向从右往左滑动时，水平方向的速度即为负值。</p>
<h4 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h4><p>手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。比如要监听双击行为，代码如下：</p>
<blockquote>
<p>GestureDetector mGestureDetector = new GestureDetector(listener);<br>//再加上这行可以解决长按屏幕后无法拖动的现象<br>mGestureDetector.setIsLongpressEnabled(false);</p>
</blockquote>
<p>接着，接管目标View的onTouchEvent方法，在待监听View的 onTouchEvent 方法中如下实现：</p>
<blockquote>
<p>boolean consume = mGestureDetector.onTouchEvent(event);<br>return consume;</p>
</blockquote>
<p>OnGestureListener 与 OnDoubleTapListener 里面的方法有很多，常用的有：onSingleTapUp（单击）、onScroll（拖动）、onLongPress（长按）、onFling（快速滑动）、onScroll（拖动）、onDoubleTap（双击）。</p>
<h4 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h4><p>弹性滑动对象，用于实现View的弹性滑动，我们知道，当使用View的scrollTo/scrollBy方法来进行滑动时，其过程是瞬间完成的，这时候就可以使用 Scroller 来实现有过渡效果的滑动，它需要和View的conputeScroll方法配合使用才能共同完成这个功能，典型的使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scroller mScroller = newScroller(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓慢滑动到指定位置</span></span><br><span class="line"><span class="function">privte <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX,<span class="keyword">int</span> destY)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> scrollX = getScrollX();</span><br><span class="line">    <span class="keyword">int</span> delta = destX - scrollX;</span><br><span class="line">    <span class="comment">//1000ms内滑向destX就是，效果就是慢慢滑动</span></span><br><span class="line">    mScroller.startScroll(scrollX,<span class="number">0</span>,delta,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mScroller.computeScrollOffset())&#123;</span><br><span class="line">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">        postInvalidate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="View-的滑动"><a href="#View-的滑动" class="headerlink" title="View 的滑动"></a>View 的滑动</h2><p>未完待续。。。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章——IPC机制</title>
    <url>/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/</url>
    <content><![CDATA[<p>提到IPC的使用场景就必须提到多进程，如果只有一个进程，又何必使用进程间通信。多进程的情况分为两种：第一种是应用本身需要采用多进程模式实现（比如通过多个进程来获取多份内存空间）；第二种是当前应用需要向其他应用获取数据，由于是两个应用，因此必须采用跨进程通信方式。</p><h2 id="Android中的多进程模式"><a href="#Android中的多进程模式" class="headerlink" title="Android中的多进程模式"></a>Android中的多进程模式</h2><p>我们不讨论两个应用之间的多进程情况。</p><a id="more"></a>

<h3 id="1、开启多进程"><a href="#1、开启多进程" class="headerlink" title="1、开启多进程"></a>1、开启多进程</h3><p>，Android中使用多进程有两种方法：第一种是给四大组件在AndroidManifest中指定 android:process 属性；第二种是非常规方式，通过JNI在native层去fork一个新的进程。第二种情况属于特殊情况，暂时不考虑。</p>
<h3 id="2、多线程模式的运行机制"><a href="#2、多线程模式的运行机制" class="headerlink" title="2、多线程模式的运行机制"></a>2、多线程模式的运行机制</h3><p>如果用一句话形容多进程，那就是：“当应用开启了多进程以后，各种奇怪的现象都出现了”，开启多线程只需要给四大组件指定 android:process 属性，但是是否正常运行就是另外一回事了。看个例子：</p>
<blockquote>
<p>有 MainActivity 和 SecondActivity，其中 SecondActivity 指定运行在一个新的进程中，并且项目还新建一个 UserManager 类，类中有个public 的静态变量：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserManager</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sUserId = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 MainActivity 的 onCreate 中把 sUserId 的值改为2，打印sUserId，之后再启动 SecondActivity ，在 SecondActivity 中打印 sUserId 。</p>
</blockquote>
<p><strong>可以发现在 MainActivity 中打印的值是2，在 SecondActivity 中打印的值是 1 ，看到这里，大家应该明白了多进程带来的问题，绝非只是指定一个 android:process 这么简单</strong>。</p>
<p><strong>分析：</strong>我们知道，Android 系统为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类的对象会产生<strong>多份副本</strong>。拿上面的例子来说，两个进程中都存在一个 UserManager 类，并且这两个类是互相不干扰的，在一个进程中修改 sUserId 的值只会影响当前进程，对其他进程不会造成任何影响。</p>
<p>通过以上可以知道，运行在不同进程中的四大组件，只要他们之间需要通过内存来共享数据，都会共享失败，这也是多进程所带来的主要影响。一般来说，使用多进程会造成如下几个方面的问题：</p>
<ul>
<li>静态成员和单例模式完全失效  </li>
</ul>
<blockquote>
<p>上面做了分析</p>
</blockquote>
<ul>
<li>线程同步机制完全失效 </li>
</ul>
<blockquote>
<p>既然都不是一块内存了，那么不管是锁对象还是锁全局类都无法保证线程同步，因为不同进程锁的不是同一个对象</p>
</blockquote>
<ul>
<li>SharedPreference 的可靠性下降  </li>
</ul>
<blockquote>
<p>是因为 SharedPreference 不支持两个进程同时去执行写操作，否则会导致可能的数据丢失（因其本质是通过读写xml文件来实现的）</p>
</blockquote>
<ul>
<li>Application 会多次创建  </li>
</ul>
<blockquote>
<p>这个问题是显而易见的，由于系统要在创建新的进程同时分配独立的虚拟机，所以这个过程其实就是启动一个应用的过程，因此相当于系统又把应用重新启动了一遍，自然就创建了新的Application。还可以这么理解，运行在同一个进程中的组件是属于同一个虚拟机和同一个Application的；同理，运行在不同进程中的组件是属于两个不同的虚拟机和Application。</p>
</blockquote>
<h2 id="IPC-基础概念介绍"><a href="#IPC-基础概念介绍" class="headerlink" title="IPC 基础概念介绍"></a>IPC 基础概念介绍</h2><p>IPC 中的基础概念包括3方面内容： Serializable 接口、Parcelable接口、Binder。</p>
<h3 id="1、Serializable-接口"><a href="#1、Serializable-接口" class="headerlink" title="1、Serializable 接口"></a>1、Serializable 接口</h3><p>Serializable 是Java提供的一个空的序列化接口，为对象提标准的序列化和反序列化操作。使用 Serializable 实现序列化非常简单，只需要类实现 Serializable 接口，并且在类的声明中指定一个类似下面的标识：</p>
<blockquote>
<p>private static final long serialVersionUID = 12345L</p>
</blockquote>
<p>实际上，这个 serialVersionUID 也不是必需的，因为serialVersionUID 的机制是这样的： 序列化时，系统会把当前类的 serialVersionUID 写入序列化的文件中；当反序列化的时候，会去检测文件中的 serialVersionUID 是否和当前类的 serialVersionUID 一致，如果一致说明序列化的类版本和当前类的版本是相同的，就可以成功反序列化；否则的话，说明当前类和序列化的类相比发生了某些变换，就无法正常反序列化。以下例子说明 Serializable 的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">12345L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String userName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********使用*****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="number">12</span>,<span class="string">"tom"</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"cache.txt"</span>));</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化过程</span></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"cache.txt"</span>));</span><br><span class="line">User newUser = (User)in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>

<p>另外，系统默认的序列化过程也是可以改变的，通过重写 writeObject 和 readObject 方法即可，只不过大部分情况下我们无需去重写这两个方法。</p>
<h3 id="2、Parcelable-接口"><a href="#2、Parcelable-接口" class="headerlink" title="2、Parcelable 接口"></a>2、Parcelable 接口</h3><p>Parcelable 也是一个接口，只要实现这个接口，类的对象就可以实现序列化并通过 Intent 和 Binder 传递。</p>
<p>具体使用方法可以查看<a href="https://developer.android.google.cn/reference/android/os/Parcelable.html" target="_blank" rel="noopener">官方文档</a></p>
<p>既然 Parcelable 和 Serializable 都能实现序列化并且都可用于 Intent 间的数据传递，那如何取舍呢？Serializable 是Java中的序列化接口，序列化和反序列化需要大量I/O操作；而Parcelable 是 Android 中的序列化方式，主要用在内存序列化上，使用起来稍显麻烦，但是效率高，所以这是 Android 官方推荐的序列化方式。综上所述，将对象序列化存储到设备或者通过网络传输时使用 Serializable ，否则使用 Parcelable 。</p>
<h3 id="3、Binder"><a href="#3、Binder" class="headerlink" title="3、Binder"></a>3、Binder</h3><p>Binder 是 Android 中的一种 IPC 方式，还可以理解为一种虚拟的物理设备，它的设备驱动是 dev/binder。</p>
<h2 id="Android-中的-IPC-方式"><a href="#Android-中的-IPC-方式" class="headerlink" title="Android 中的 IPC 方式"></a>Android 中的 IPC 方式</h2><h3 id="使用Bundle"><a href="#使用Bundle" class="headerlink" title="使用Bundle"></a>使用Bundle</h3><p>由于Bundle 实现了 Parcelable 接口，所以它可以方便地再不同的进程间传输，基于这一点，当我们在一个进程中启动了另一个进程的 Activity、Service 和 Receiver，我们就可以在Bundle 中附加我们需要传给其他进程的信息，并通过Intent 发送出去，这是一种最简单的进程间通信方式。</p>
<h3 id="使用文件共享"><a href="#使用文件共享" class="headerlink" title="使用文件共享"></a>使用文件共享</h3><p>共享文件是一种不错的进程间通讯方式，适合在对数据同步要求不高的进程间通信。当然，SharedPreferences 是个特例，由于系统对它的读写会有一定的缓存策略，即在内存中会有一份 SharedPreferences 文件的缓存，因此在多进程模式下，面对高并发的的读写会有很大几率丢失数据，因此不建议在进程间通信中使用 SharedPreferences。</p>
<h3 id="使用-Messenger"><a href="#使用-Messenger" class="headerlink" title="使用 Messenger"></a>使用 Messenger</h3><p>顾名思义可以翻译成信使，通过它可以在不同的进程中传递 Message 对象,它是轻量级的 IPC 方案，底层实现是 AIDL 。Messenger 只是一串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务端，服务端仍然只能一个个处理。具体可以参考<a href="https://developer.android.google.cn/reference/android/os/Messenger" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="使用-AIDL"><a href="#使用-AIDL" class="headerlink" title="使用 AIDL"></a>使用 AIDL</h3><p>由于 Messenger 服务端只能串行处理，所以可以使用 AIDL 来实现跨进程调用。具体内容可以参考<a href="https://developer.android.google.cn/guide/components/aidl" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="使用-ContentProvider"><a href="#使用-ContentProvider" class="headerlink" title="使用 ContentProvider"></a>使用 ContentProvider</h3><p>这是Android 中提供的专门用于不同应用建进行数据共享的方式。</p>
<h3 id="使用-Socket"><a href="#使用-Socket" class="headerlink" title="使用 Socket"></a>使用 Socket</h3><p>Socket 是网络通信中的概念，也称为“套接字”，<strong>它分为流式套接字和用户数据报套接字两种，分别对应于网络的传输控制层中的TCP和UDP协议</strong>。</p>
<h2 id="选择合适的-IPC-方式"><a href="#选择合适的-IPC-方式" class="headerlink" title="选择合适的 IPC 方式"></a>选择合适的 IPC 方式</h2><table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Bundle</td>
<td>简单易用</td>
<td>只能传输Bundle支持的数据类型</td>
<td>四大组件之间的通信</td>
</tr>
<tr>
<td>文件共享</td>
<td>简单易用</td>
<td>不适合高并发</td>
<td>无并发，数据实时性要求不高</td>
</tr>
<tr>
<td>AIDL</td>
<td>功能强大，支持一对多，支持实时</td>
<td>使用复杂</td>
<td>一对多通信且有RPC需求</td>
</tr>
<tr>
<td>Messenger</td>
<td>一对多串行通信，支持实时</td>
<td>高并发困难，不支持RPC，只能传输Bundle支持的数据</td>
<td>低并发的一对多通信</td>
</tr>
<tr>
<td>ContentProvider</td>
<td>数据源访问功能强大</td>
<td>理解为受约束的AIDL，主要提供数据源的 CRUD 操作</td>
<td>一对多的进程间数据共享</td>
</tr>
<tr>
<td>Socket</td>
<td>支持一对多并发实时通信，支持字节流</td>
<td>实现繁琐</td>
<td>网络数据交换</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章——Activity 生命周期和启动模式</title>
    <url>/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC1%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="Activity-的生命周期全面分析"><a href="#Activity-的生命周期全面分析" class="headerlink" title="Activity 的生命周期全面分析"></a>Activity 的生命周期全面分析</h2><p>本节将分为两部分内容，一部分是典型情况下的生命周期，一部分是异常情况下的生命周期（比如被系统回收或者由于当前设备Configuration 发生改变而导致 Activity 被销毁重建）。</p><h3 id="一、典型情况下的生命周期分析"><a href="#一、典型情况下的生命周期分析" class="headerlink" title="一、典型情况下的生命周期分析"></a>一、典型情况下的生命周期分析</h3><p>正常情况下，Activity 会经历如下生命周期：</p><a id="more"></a>

<ol>
<li>onCreate ： 表示Activity 正在创建，这是生命周期第一个方法。  </li>
<li>onRestart ： 表示Activity 正在重新启动。一般情况下，当前Activity 从不可见重新变为可见时，onRestart 就会被调用。    </li>
<li>onStart ： 表示Activity 正在被启动，这时候 Activity 已经可见了，但是还没出现在前台，无法和用户交互。<strong>可以理解为 Activity 已经显示出来了，但是我们还看不到</strong>。  </li>
<li>onResume ： 表示 Activity 已经可见了，并且出现在前台可以交互。  </li>
<li>onPause： 表示 Activity 正在停止，正常情况下，紧接着 onStop 会被调用；在特殊情况下，如果这个时候快速地再回到当前 Activity ，那么 onResume 将会被调用。此时可以做一些存储数据、停止动画等工作，但是注意不能太耗时，<strong>因为onPause必须先执行完，新Acitivty 的 onResume 才会执行</strong>。    </li>
<li>onStop ： 表示 Activity 即将停止，可以做一些稍微重量级的回收工作，同样不能太耗时。  </li>
<li>onDestroy： 表示 Activity 即将被销毁，这是Activity 生命周期中的最后一个回调，我们可以做一些回收工作和最终的资源释放。  </li>
</ol>
<p>以下再针对 Activity 的生命周期具体说明：  </p>
<ul>
<li>针对特定的Activity，第一次启动回调如下： onCreate-&gt;onStart-&gt;onResume  </li>
<li>打开新的Activity 或者(按Home键)回到桌面的时候，回调 onPause-&gt;onStop ；这里有种特殊情况，打开的新Activity 如果是透明主题（意味着当前Activity还是可见的），那么当前Activity 不会回调 onStop 。  </li>
<li>当用于再次回到原来的 Activity 时，回调 onRestart-&gt;onStart-&gt;onResume  </li>
<li>当用户按返回键返回上一个页面时，回调 onPause-&gt;onStop-&gt;onDestroy  </li>
<li>从整个生命周期来看，<strong>onCreate与onDestroy是配对的，分别标识着Activity的创建与销毁；onStart与onStop是配对的，标识着Activity是否可见；onResume 与 onPause 是配对的，标识着Activity是否在前台</strong>。 </li>
</ul>
<p>一个问题：当前 Activity 标识为 A，启动一个新的Activity 标识为 B，那么B的onResume 和 A 的onPause 哪个先执行？</p>
<blockquote>
<p>由上面的描述可知是限制性A的 onPause，再执行 B 的onResume ，具体看源码，<a href="https://developer.android.google.cn/reference/android/app/Activity" target="_blank" rel="noopener">官方文档</a>也是这么解释(<strong>Always followed by onPause()</strong>)。 </p>
</blockquote>
<h3 id="二、异常情况下的生命周期分析"><a href="#二、异常情况下的生命周期分析" class="headerlink" title="二、异常情况下的生命周期分析"></a>二、异常情况下的生命周期分析</h3><h4 id="1、资源相关的系统配置发生改变导致Activity被杀死并重建"><a href="#1、资源相关的系统配置发生改变导致Activity被杀死并重建" class="headerlink" title="1、资源相关的系统配置发生改变导致Activity被杀死并重建"></a>1、资源相关的系统配置发生改变导致Activity被杀死并重建</h4><p>如果没有做特殊处理，当横竖屏切换的时候，由于系统配置发生了改变，Activity 会加载不同的资源（比如横竖屏加载两张不同图片），此时 Activity 会被销毁并且重新创建。由于 Acitivity 是在异常情况下终止的，因此在销毁Activity的时候，<strong>确切来说是在onStop之前（但是跟onPause没有顺序关系，有可能在其之前，也可能在其之后）会调用 onSaveInstanceState 来保存当前 Activity 状态</strong>；  </p>
<p>Activity 被重新创建后，会把销毁时 onSaveInstanceState 方法保存的Bundle对象作为参数传给 onCreate 方法和 onRestoreInstanceState 方法，因此可以从这两个方法恢复之前保存的数据。<strong>从时序上来说，onRestoreInstanceState 调用时机在 onStart 之后。</strong></p>
<blockquote>
<p>这两个方法恢复数据的区别是：onRestoreInstanceState 一旦被调用，其参数 savedInstanceState 是一定有值的，我们不需要额外地判空；而 onCreate 中的数据是可能为空的，官方文档建议采用 onRestoreInstanceState 去恢复数据。</p>
</blockquote>
<p>如果没有覆写的话，onSaveInstanceState 和 onRestoreInstanceState 方法中，系统会自动为我们做一定的恢复工作。</p>
<h4 id="2、资源内存不足导致低优先级Activity被杀死"><a href="#2、资源内存不足导致低优先级Activity被杀死" class="headerlink" title="2、资源内存不足导致低优先级Activity被杀死"></a>2、资源内存不足导致低优先级Activity被杀死</h4><p>Activity 按照优先级从高到低可以分为如下三种：</p>
<p>（1）前台Activity——正在和用户交互的Activity，优先级最高<br>（2）可见但非前台Activity——比如Activity中弹出了dialog，导致Activity可见但是位于后台无法和用户直接交互。<br>（3）后台Activity——已经被暂停的的Activity，优先级最低。  </p>
<p>我们知道，当系统配置发生改变时，Activity 会被销毁并重新创建，当然我们也可以通过给 Activity 指定configChanges 属性来阻止销毁重建：</p>
<blockquote>
<p>android:configChanges=”orientation”</p>
</blockquote>
<p>当然这个属性可以配置的项目还有很多，比如切换系统语言、使用了新字号、界面模式改变（比如 是否开启/关闭夜间模式）。</p>
<h2 id="Activity-的启动模式"><a href="#Activity-的启动模式" class="headerlink" title="Activity 的启动模式"></a>Activity 的启动模式</h2><ul>
<li>standard： 标准模式。不复用，每次请求都创建新实例，并且就运行在启动它的那个Activity所在的栈。    </li>
<li>singleTop： 栈顶复用模式 。如果实例位于任务栈的栈顶就复用，复用时调用 onNewIntent方法，否则就创建新的实例。       </li>
<li>singleTask： 栈内复用模式。当前栈内没有实例，则创建实例放入栈中；如果实例在当前栈内，则复用，复用时调用 onNewIntent方法，并把它之上的Activity出栈。  </li>
<li>singleInstance： 单例模式。<strong>只能单独位于一个任务栈中</strong>，只要这个实例存在，后续的请求均不会创建新的Activity。复用时调用 onNewIntent方法。  </li>
</ul>
<p>在使用 ApplicationContext 启动standard 模式的Activity时会报错：</p>
<blockquote>
<p>Callking startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag</p>
</blockquote>
<p>这是因为standard模式的Activity 默认会进入启动它的Activity所属的任务栈中，由于非Activity类型的Context 没有所谓的任务栈，所以会报错。解决这个问题的方法是为待启动的Activity指定 FLAG_ACTIVITY_NEW_TASK 标记，这样启动的时候会为它创建一个新的任务栈（体会下，这时候实际上是以singleTask模式启动的）</p>
<h3 id="参考其他博客的启动模式的原理"><a href="#参考其他博客的启动模式的原理" class="headerlink" title="参考其他博客的启动模式的原理"></a>参考其他博客的启动模式的原理</h3><p>点击launcher 的startactivity 会调用到Instrumentation的execStartActivity，之后交给AMS 来处理启动操作，之后调用 ActivityStackSupervisor 的 startActivityMayWait 方来启动，而ActivityStackSupervisor 是管理Activity堆栈的类</p>
<p>另外提一下，Activity 在AMS中的形式是 ActivityRecord，task在AMS 中的形式是 TaskRecord，进程在 AMS 中的管理形式为 ProcessRecord</p>
<p>判断启动模式，根据当前的Activity 和 要启动的Activity 的启动模式，根据相应的启动模式设置launchFlags</p>
<p>在Android 5.0上 在 ActivityStackSupervisor 类的startActivityUncheckedLocked  里面判断launchmode</p>
<blockquote>
<p>以上内容参考自<a href="https://www.jianshu.com/p/09365022adac" target="_blank" rel="noopener">简书的博客上的内容</a></p>
</blockquote>
<h3 id="Activity-的Flags"><a href="#Activity-的Flags" class="headerlink" title="Activity 的Flags"></a>Activity 的Flags</h3><p>Activity 的Flags很多，这里分析比较常用的几个:</p>
<ul>
<li>FLAG_ ACTIVITY_ NEW_ TASK</li>
</ul>
<blockquote>
<p>为Activity 指定singleTask启动模式，其效果和在XML中指定 singleTask 启动模式相同</p>
</blockquote>
<ul>
<li>FLAG_ ACTIVITY_ SINGLE_ TOP</li>
</ul>
<blockquote>
<p>为Activity 指定 singleTop 启动模式，其效果和在XML中指定 singleTop 启动模式相同</p>
</blockquote>
<ul>
<li>FLAG_ ACTIVITY_ CLEAR_ TOP</li>
</ul>
<blockquote>
<p>具有此标记的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈，这个标记为一般会和FLAG_ACTIVITY_SINGLE_TOP标记位一起出现。由前面的分析可知，singleTask启动模式默认具有此标记位效果。</p>
</blockquote>
<ul>
<li>FLAG_ ACTIVITY_ EXCLUDE_ FROM_ RECENTS</li>
</ul>
<blockquote>
<p>具有这个标记位的Activity不会出现在历史Activity列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候，这个标记比较有用。这个标记等同于xml中指定Activity 的属性 android:excludeFromRecents = “true”</p>
</blockquote>
<h4 id="IntentFilter-的匹配规则"><a href="#IntentFilter-的匹配规则" class="headerlink" title="IntentFilter 的匹配规则"></a>IntentFilter 的匹配规则</h4><p>略</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title>总结</title>
    <url>/2019/05/04/%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>别漏了BroadCastReceiver</p>
</details><blockquote>
<p>参考链接：<a href="https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/">ipc机制</a></p>
</blockquote><h2 id="零散的知识点"><a href="#零散的知识点" class="headerlink" title="零散的知识点"></a>零散的知识点</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li><p>Service 多次启动， onStartCommand 会多次    </p>
</li>
<li><p>本地广播无法通过静态方式注册    </p>
</li>
<li><p>RemoteViews 通过id来给特定的view更新UI     </p>
</li>
<li><p>为毛Thread 废弃 suspend 方法，因为如果被suspend 了一直持有锁，那就可能导致死锁了      </p>
</li>
<li><p>stop 方法废弃，主要是防止数据写了一半，导致后期数据不一致问题     </p>
</li>
<li><p>在sleep过程中，有可能会执行 thread.interrupt 方法，所以要try-catch      </p>
</li>
<li><p>如何禁止指令重排和可见性：final、volatile、加锁             </p>
</li>
<li><p>保证原子性：加锁、CAS、原子类型(AtomicInteger等)                </p>
</li>
<li><p>onSaveInstanceState 的调用时机： 销毁Activity 的时候，在 onStop 之前(与onPause没啥关系)。          </p>
</li>
<li><p>onRestoreInstanceState 的调用时机是在 onStart 之后          </p>
</li>
<li><p>开启多进程，可以指定process，还可以在native 上fork出来          </p>
</li>
<li><p>多进程问题：Application多次、单例失效、sp不可靠、锁失效(即使锁类也不行了)            </p>
</li>
<li><p>view的滑动有几种方法：layout、offsetALeftAndRight/offsetTopAndBottom、LayoutParams、动画、scrollTo、scrollBy、scroller         </p>
</li>
<li><p>Android系统分层：应用层、应用框架层、系统运行库层、硬件抽象层、Linux内核        </p>
</li>
<li><p>init 进程工作：启动属性服务和zygote 进程       </p>
</li>
<li><p>zygote启动工作：创建java虚拟机，并注册jni方法、创建       SocketServer 来监听 fork 请求         </p>
</li>
<li><p>SystemServer 的工作：启动系统服务、启动Binder 线程池(用于与其他进程通信)         </p>
</li>
<li><p>Android系统启动流程，可以参考<a href="https://glassx.gitee.io/2019/11/22/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC2%E7%AB%A0/">博客</a>           </p>
</li>
<li><p>在zygote 通过fork创建进程后，启动它的binder线程池，并通过反射调用ActivityThread 的main 方法，创建主线程环境            </p>
</li>
<li><p>ActivityThread 的 attach 方法就是初始化 Application 对象            </p>
</li>
<li><p>Launcher 启动某个app应用，首先会为启动的 Activity 的intent 设置 FLAG_ACTIVITY_NEW_TASK，在新任务栈中         </p>
</li>
<li><p>新Activity 启动经历三个阶段： Launcher经过Instrumentation 到AMS、AMS 到 ApplicationThread、ActivityThread 启动Activity         </p>
</li>
<li><p>ApplicationThread 是ActivityThread 的内部类，负责与AMS 进程间通信，收到进程消息后，在ApplicationThread 中通过 handler.sendMessager 的方式向 ActivityThread 中发送消息启动Activity          </p>
</li>
<li><p>LoadApk 用于描述已经加载进来的 APK 文件的。       </p>
</li>
<li><p>通过反射创建Activity，attach 方法将新建的Context 设置成mBase          </p>
</li>
<li><p>Context包装类目的：ContextImpl 具体实现不会暴露给使用者、组合而不是继承，更灵活          </p>
</li>
<li><p>启动应用的的第一个Activity过程中(handleMessage中)，最终会使用LoadApk.makeApplication() 方式创建Application ，同样也是通过反射的方式。        </p>
</li>
<li><p>会将 Application 缓存到LoadApk中      </p>
</li>
<li><p>Application 的attach ，就是把新建的ContextImpl 设置为mBase，并且，Application 设置为ContextImpl的 mOut变量                </p>
</li>
<li><p>获取 Application Context 的方式，首先从 LoadApk中获取，否则 调用ActivityThread 中获取         </p>
</li>
<li><p>同理，Activity 的 attach 会将ContextImpl 设置为mBase，并将Activity 对象赋值给 ContextImpl 的 mOuterContext。               </p>
</li>
<li><p>类的生命周期，  加载-验证-准备-解析-初始化-使用-卸载                </p>
</li>
<li><p>垃圾收集算法： 标记-清除、复制、标记-整理、分代         </p>
</li>
<li><p>Java API 中标称自己是线程安全的类，其实大多数不是绝对的线程安全的，如你遍历的时候，读取size 是synchronize修饰的，但是在打印过程中可能被删除了某些元素，这时候读取就会抛异常     </p>
</li>
<li><p>线程安全的实现方法： 无同步方案(不共享)、互斥同步、非阻塞同步(如CAS操作)      </p>
</li>
<li><p>锁优化：自旋、锁消除(比如在方法内部new出来StringBuffer)、锁粗化(也是StringBuffer的append)、轻量级锁(CAS操作mark word)、偏向锁       </p>
</li>
<li><p>轻量级锁，使用CAS操作尝试将对象的 MarkWord 改成轻量级锁标志，如果成功，则拥有锁；否则，判断锁是否指向当前线程，如果是，则直接进入。否则，就等待(个人觉得应该是CAS重试)。如果有两个以上线程在争用这个锁，就升级为重量级锁，后面的线程阻塞。      </p>
</li>
<li><p>偏向锁：偏向锁在轻量级锁基础上连 CAS 都不做。在对象第一次被线程获取后，把线程id写在 MarkWord 中(这个当然是CAS操作)，当另一个线程尝试获取的时候，偏向模式就结束(指的是这个CAS操作不做了)，恢复到未锁定或者轻量级锁状态，后续就是轻量级锁规则了       </p>
</li>
<li><p>轻量级锁与偏向锁不一定总是有利的，如果程序中大多数锁都被不同线程访问，竞争激烈，那它还得转换状态，因此，有时候禁止它们反而性能提高      </p>
</li>
<li><p>https在http之下，tcp之上增加一层 SSL(Secure Socket Layer)    </p>
</li>
<li><p>ssl 握手前，先要tcp 握手     </p>
</li>
<li><p>ssl握手： 算法、随机数 -&gt; 算法(对称、非对称、摘要)、随机数、证书 -&gt; 验证证书、公钥加密“前主密钥” -&gt; 握手摘要 -&gt; 握手摘要      </p>
</li>
<li><p>udp：无需握手、无需维护连接(缓存、拥塞控制、序号确认等)、头部小，8个字节，tcp有20个，值得注意的是，它有校验和，用于防止传输过程引入的差错    </p>
</li>
<li><p>快重传：收到3个相同 ack，则立即重传     </p>
</li>
<li><p>流量控制：避免接收方缓存溢出     </p>
</li>
<li><p>拥塞控制：防止整体网络质量堵塞      </p>
</li>
<li><p>确定拥塞：超时没收到ack，或者3次重复的ack    </p>
</li>
<li><p>拥塞控制方法：慢启动、拥塞避免(收到ack之后，不像慢启动翻倍增长，而是缓慢增长)、快速恢复(窗口减半，之后执行拥塞避免)        </p>
</li>
<li><p>tcp 时延：握手、拥塞控制、捎带确认、TIME-WAIT      </p>
</li>
<li><p>多线程下载大文件速度快，为啥？1、多个下载线程能够抢占更多的实时网络带宽（相当于下载进程占用了更多带宽）             </p>
</li>
<li><p>改善tcp性能的方法：并行连接、长连接、管道化连接    </p>
</li>
<li><p>死锁条件：互斥条件、不可剥夺、占有等待、环路等待，可以采用基于矩阵的算法来检测死锁       </p>
</li>
<li><p>死锁恢复：回滚、杀死进程、抢占(需要人工干预)     </p>
</li>
<li><p>按返回键，要先清完当前的栈，再清其他的栈，比如：B是singleInstance，则 A启动B，B启动C，则此时按返回键先到A，再按返回键才看到B     </p>
</li>
<li><p>如果想fragment commit 立即生效，可以在 FragmentTrasation.commit() 之后，执行 fragmentManager.executePendingTransactions()       </p>
</li>
<li><p>Fragment 生命周期： onAttach、onCreate、onCreateView、onActivityCteated、onStart、onResume、onPause、onStop、onDestroyView、onDestroy、onDetach    </p>
</li>
<li><p>避免异步使用 commit，因为感知不到Activity 生命周期，可能commit的时候，Activity 结束了      </p>
</li>
<li><p>广播分类：标准广播、有序广播、本地广播       </p>
</li>
<li><p>BroadcastReceiver 的onReceiver 中也不是不能开启子线程，只是不推荐开启，因为 BroadcastReceiver 的生命周期本身就很短，在子线程还没结束的情况下，Activity 就被退出了，所以能，BroadcastReceiver 的耗时任务建议交给 IntentService 去做        </p>
</li>
<li><p>mmkv 可以替代 SharedPreference      </p>
</li>
<li><p>MVC 在Android 中导致 Activity 的职责不明确，很臃肿。没有涉及Model 时，View 可以直接调用Controller，Controller 可以直接调用View。并且，View 还可以直接更新Model，只不过Model要更新UI必须经过 Controller 。      </p>
</li>
<li><p>二叉搜索树查找代价：logN 或者 N，插入，基本上在logN，删除：O(1) 或者 logN    </p>
</li>
<li><p>平衡二叉搜索树：查： logN，插入：logN，删除： 2logN    </p>
</li>
<li><p>红黑树：查： logN，插入：logN，删除：logN      </p>
</li>
<li><p>发起tcp请求，序列号是随机的，这是防止多次重传时候，(假如已经建立连接了)分不出是哪一次了    </p>
</li>
<li><p>三次握手，第一二次不可以携带数据(第一次允许，容易引起攻击，并且不确认有接收能力)，但是第三次是可以携带数据的     </p>
</li>
<li><p>udp 面向报文，添加首部之后就可以交给ip层，不拆分；tcp 面向字节流，对报文拆分     </p>
</li>
<li><p>udp 没有拥塞控制，tcp会有拥塞控制，tcp还有滑动窗口实现流量控制     </p>
</li>
<li><p>http2特性：服务端push、新的二进制格式(而不是文本)、多路复用、新的压缩算法、header 压缩、更安全的ssl     </p>
</li>
<li><p>RxJava 线程切换原理：将Observer 封装成 SubscribeTask ，它实现了Runnable接口，如果在main线程的话，会启用Handler(getMainLooper)将Runnable封装成Message 发送出去，其他线程则交给相应的线程池。      </p>
</li>
<li><p>LocalBroadcastManager 初始化的时候会创建一个主线程的Handler，发送广播时，根据intent获取action，依次调用    </p>
</li>
<li><p>线程池异常处理：1、继承 ThreadPoolExecutor 再重写 afterExecute ，可以得到实际异常  2、对Runnable 里面的整个try-catch   3、自己写ThreadFactory，即自己创建线程，然后实现 setUncaughtExceptionHandler 来捕捉。       </p>
</li>
<li><p>synchronize 同步原理：代码块：monitorenter指令插入到同步代码块的开始处，将monitorexit插入到结束处  ，方法同步，采用另外的标记ACC-synchronized，其实是一样的效果，都是针对monitor      </p>
</li>
<li><p>线程阻塞的原因： 调用wait、等待同步锁、执行了sleep、执行了 join      </p>
</li>
<li><p>yield 将线程状态由Running 转变为 Runnable状态，但是系统可能不理会这个请求，所以不一定可靠，官方只建议用来调试      </p>
</li>
<li><p>onCreate 中，子线程可以刷新ui，是因为ViewGroup 的attachInfo 还是空的，后续的线程检测就不进行了。还有，线程判断主要是判断和new 这个view的线程是不是同一个。      </p>
</li>
<li><p>LruCache 原理：LinkedList，最近使用过的就插在头部，淘汰的时候，淘汰尾部      </p>
</li>
<li><p>Object 的方法：  clone、equals、finalize、getClass、hashCode、identityHashCode、notify、notifyAll、toString、wait       </p>
</li>
<li><p>HashMap 中链表元素达到一定阈值(8个)，就会转化为红黑树，然后转成树key总要通过什么对比吧，其实是通过 System.identityHashCode 来对比的，它不受hashCode 的影响        </p>
</li>
<li><p>RecyclerView 的优化：数据处理与视图分开(在bindViewHolder的时候不做数据处理了)、布局优化、设置setHasFixedSize(根据最初的高度、后面就不会重新测量了)、减少item的监听器创建、滑动过程停止加载、DiffUtil工具、公用 RecycledViewPool      </p>
</li>
<li><p>嵌套的RecyclerView 中可能用得着 Linearlayoutmanager 的 onSaveInstanceState 和 onRestoreInstanceState 来恢复嵌套的recyclerview的滑动状态        </p>
</li>
<li><p>全局捕捉异常，在Application 中为Thread.setUncatchExceptionHandler      </p>
</li>
<li><p>SharedPreference 在解析xml 的时候，commit 和apply 是不可以调用的，解析完了就会notifyAll            </p>
</li>
<li><p>每次调用edit()方法时，都会创建一个 EditorImpl 对象，所以不要频繁 调用 edit() 方法         </p>
</li>
<li><p>sp 执行 commit 时，首先更新到内存，之后再在当前线程直接写入到xml文件中，所以要注意这里的耗时          </p>
</li>
<li><p>sp的apply方法，首先写到内存，然后交给HandlerThread，即在子线程中，单线程地依次提交到xml文件中           </p>
</li>
<li><p>sp  不要跨进程使用sp(会有缓存，不可靠)、不要存储超大的key或者value，因为加载xml一直会等待，然后后来会放在内存中，占用内存、不要存储JSOn等特殊字符很多的value，会触发转义、不要多次执行 edit，不要多次apply(在api 11 之前，activity 退出时，要等待apply的那些 Runnable 执行完成才能退出，如果时间过长，就导致ANR 了)         </p>
</li>
<li><p>常见内存泄露：资源性资源未关闭(buffer/cursor)、非静态内部类的静态变量、Context泄露、非静态Handler泄露、注册的对象未反注册、匿名内部类和异步的线程(线程与外部类的生命周期不一致)                 </p>
</li>
<li><p>LeakCanary原理：registerActivityLifecycleCallbacks 监听生命周期、弱引用查看对象是否存在         </p>
</li>
<li><p>apk安装过程：安装源、复制apk到/data/data 、解析apk(签名、四大组件注册)、dexopt、更新权限信息(更新到pms)，判断是否允许这些权限、安装完成，发送广播           </p>
</li>
<li><p>Android 资源替换原理：替换 AssertManager                </p>
</li>
<li><p>热修复原理：DexClassLoder 可以从外部加载 classes.dex，插件化也是利用 DexClassLoder                </p>
</li>
<li><p>新特性：5.0-材料设计，ART、6.0-动态权限，Dozen模式、7.0-JIT和ART 交叉编译 、8.0-notification、画中画、9.0-刘海屏支持、Q、文件权限，uri，深色主题、折叠设备                 </p>
</li>
<li><p>Handler 有三种Message，同步消息、异步消息(Message 中 setAsynchronous(true) 了)、消息屏障消息                   </p>
</li>
<li><p>消息屏障，MessageQueue.postSyncBarrier 可以发送消息屏障，不过这是私有方法，需要反射(新的api貌似提供了puglic的的调用了)。其实就与普通的post一样，只是它的Message的target 为空，没有handler引用。当处理到这个屏障时，会一直查找是否有异步消息，先处理异步消息，这个过程持续到手动移除消息屏障为止(MessageQueue.removeSyncBarrier)             </p>
</li>
<li><p>IdleHandler ：在没有Messager 需要处理的时候，就调用IdleHandler 来处理了                       </p>
</li>
<li><p>BlockCanary 原理：在主线程loop中，在处理msg 之前，会调用Printer类型的mLogging 来打印一下，然后处理完了也打印一下，所以通过设置我们自定义的Printer就能监听到处理msg的耗时                   </p>
</li>
<li><p>图片巨大，可以使用 BitmapRegionDecoder 来每次加载一部分          </p>
</li>
<li><p>Android 16ms 时间是包括 layout、measure、、和draw 三个部分的，cpu执行计算任务将ui计算成多边图形，在交给gpu栅格化，最后gpu绘制到屏幕上                       </p>
</li>
<li><p>避免丢帧：避免cpu任务过重，减少layout，measure，onDraw 工作量、避免GPU 任务过重，避免无谓的invalidate、减少过度绘制            </p>
</li>
<li><p>像素密度：以160dpi 作为密度基准的，1dp = 1px            </p>
</li>
<li><p>无响应：input： 5s、service：前台20s，后台200s、广播：前台：10s，后台：60s、provider：10s、Activity 退出时等待 sp 的写入完成                 </p>
</li>
<li><p>哪些产生ANR： 理论上执行业务时，handler post 这个anr msg之后的任何步骤都可能ANR，因为执行完成之后才会remove 这个 anr 的 msg                    </p>
</li>
<li><p>为什么用Binder：安全、性能、c/s架构容易管理                </p>
</li>
<li><p>动画：帧动画、补间动画、属性动画                </p>
</li>
<li><p>签名：v1和v2                     </p>
</li>
<li><p>TouchDelegate 用来扩大点击区域，如果要设置多个，就建立TouchDelegate 的 list，在onTouchEvent 的时候遍历执行               </p>
</li>
<li><p>bitmap内存优化，2.3.3及以下，记得recycle，3.0及以上，可以使用 imBitmap 字段，复用bitmap 内存(当bitmap从Lrucache删除时，其软引用会放在HashSet中，之后通过inBitmap 复用)                </p>
</li>
</ul>
<h3 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h3><h3 id="基本查找"><a href="#基本查找" class="headerlink" title="基本查找"></a>基本查找</h3><h3 id="基本排序"><a href="#基本排序" class="headerlink" title="基本排序"></a>基本排序</h3><p>插入排序：O(n^2)复杂度，稳定的排序<br>选择排序： 复杂度总是 O(n^2)，每次挑最大最小的，因此不稳定                    </p>
<p>shell 排序： 最差的时候：O(n^2)   平均复杂度 ： nlogn，不稳定<br>冒泡：有序的情况，一趟完成，OO(n)，平均复杂度O(n^2)，稳定的排序<br>快排序： 分治思想，平均 nlogn ，最坏 O(n^2)，交换数据啊，不稳定<br>堆排序：最坏最好和平均都是   nlogn  ，不稳定<br>归并排序： 分治思想，时间复杂度  nlogn ，稳定，主要用于外部排序</p>
<p>归并和快排的平均时间复杂度差不多，但是比快排最差情况要好。但是归并使用的空间比较多，因此一般情况下选择快排               </p>
<p>不稳定的排序：希尔、堆、快排</p>
</details>]]></content>
      <categories>
        <category>阶段</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章：垃圾收集器与内存分配策略</title>
    <url>/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。客观地说，引用计数法的实现简单，但它很难解决对象之间相互循环引用的问题，所以，主流实现中，并不使用这种方式。</p><a id="more"></a>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>在主流实现中，都是通过可达性分析来判定对象是否存活。这个算法的基本思路就是通过<strong>一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到GC Roots 没有任何引用链相连时，则证明此对象是不可用的</strong>。在Java语言中，可以作为 GC Roots 的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。  </li>
<li>本地方法栈中JNI引用的对象。  </li>
<li>方法区中类静态属性引用的对象。  </li>
<li>方法区中常量引用的对象。  </li>
</ul>
<h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>JDK 1.2 以前，对象只有引用和被引用两种状态，未能描述那些“食之无味，弃之可惜”的对象，我们希望描述这样一类对象：当内存还足够时，则能保留在内存之中；如果内存空间在GC后还是非常紧张，则可以抛弃这些对象。因此，JDK 1.2以后对引用的概念进行扩充，分为：</p>
<ul>
<li><p>强引用。代码中普遍存在的，类似于 Object obj = new Object() ，只要强引用还在，垃圾收集器永远不会回收被引用的对象。</p>
</li>
<li><p>软引用。是用来描述一些还有用，但是并非必需的对象，在系统将要发生内存溢出的异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
</li>
<li><p>弱引用。是用来描述非必需对象的，但是强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次GC发生之前。当GC工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>
</li>
<li><p>虚引用。是最弱的一种引用关系，不会对对象的生存时间构成影响，也无法通过虚引用获得对象实例。为对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p>
</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使在可达性分析算法中不可达的对象，也并非“非死不可”的。要真正宣告一个对象的死亡，至少要经历两次标记过程：如果对象在可达性分析后发现没有与GC Roots 相连接的引用链，那么它会被第一次标记，并进行筛选，筛选的条件是此对象是否有必要执行 finalize() 方法，当对象没有覆写 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则都没有必要执行；</p>
<p>如果对象判定有必要执行 finalize() 方法，则对象会被放入F-Queue队列中，稍后由低优先级的线程去触发 执行finalize() 方法，但不会承诺等待它运行结束。这样做的原因是防止 finalize 方法过于缓慢或者死循环。finalize() 方法是对象套多死亡命运的最后一次机会，因为稍后GC将对F-Queue中的对象进行第二次标记，如果对象要在finalize 中拯救自己————只要重新与某个引用链上的任意一个对象关联即可，那么在第二次标记的时候它将被移除出“即将回收”的集合；如果这时候对象还没逃脱，那它就会真的被回收了。</p>
<p>说明这一过程的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes,i am still alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> finalize（） <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed"</span>);</span><br><span class="line">        FinalizeEscapeGc. SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为finalize方法优先级很低，所以暂停0.5秒等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"no,i am dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为finalize方法优先级很低，所以暂停0.5秒等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"no,i am dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>finalize method executed<br>yes,i am still alive<br>no,i am dead  </p>
</blockquote>
<p>从结果可以看出，SAVE_HOOK 对象的 finalize 方法确实被GC收集器触发过，并且收集前成功逃脱。但两段完全一样的代码，第二次却被回收了，因为finalize 方法只会被自动调用一次，因此第二次不执行了，所以自救失败。</p>
<p>有些教材上认为 finalize 中适合做“关闭外部资源”之类的工作，在了解以上机制之后，可以认为这完全是一种自我安慰，finalize 能做的，try-finally 或其他方法能做得更好，更及时，所以完全可以忘记这个方法存在（它也仅仅只是Java诞生时讨好C/C++程序员的一个妥协）。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>最基础的收集算法是 标记-清除(Mark-Sweep) 算法，它分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，在标记完成后统一回收被标记的对象。它的主要不足有两个：一是效率问题，标记和清除效率都不高；二是清除后会产生大量不连续的内存碎片。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，复制算法出现了。它将可用内存分为大小相等的两块，每次只使用其中一块，当这块内存用完了，就将还存活的对象复制到另一块上，然后把当前内存空间一次清理掉。这样每次都是对整个半区回收，内存分配也不会存在碎片。缺点是可用内存缩小了一半，代价太高。</p>
<blockquote>
<p>现在商业虚拟机采用这种方式回收新生代。一般将内存分为较大的 Eden 和两块较小的 Survivor 空间（HotSpot中 Eden 与 Survivor大小比例为 8：1），每次使用Eden 和其中一块 Survivor，当内存回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor，最后清理Eden和刚才用过的Survivor空间，因此，每次只有10%的内存“被浪费”。当然这是基于统计新生代的对象生命周期都很短，差不多只有10%的对象会存活，此外，如果超出10%的存活对象，Survivor空间不够时，需要依赖老年代的空间提供担保（Survivor空间存不下的对象直接通过担保机制进入老年代），这是该分配方式能够运行下去的保障。</p>
</blockquote>
<p>复制收集算法在对象存活率较高时要进行较多的复制操作，效率将会变低，更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行担保，防止对象100%存活的极端情况。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>根据老年代特点，有人提出另外一种<strong>标记-整理(Mark-Compact)算法</strong>，标记过程仍与“标记-清除”算法一样，但后续不是直接清理可回收对象，而是所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。标记整理算法的示意图如下：</p>
<p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%89%88/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记-整理算法"></p>
<p>关于怎么个移动法，书上没有说明，这里个人做个推测：</p>
<blockquote>
<p>1、整个老年代的内存划分为 A 和 B 两个区域，区域 A 的大小是所有还存活对象的总大小，区域 B 大小是是剩余空间。<br>2、按顺序在 A 中找到第一个还存活对象，将它移动到 A 空间的最前端，接下来找第二个还存活的对象，将其移动到第一个对象的后面<br>3、以此类推，即使存活的对象在 B 中也一样顺序复制到A中，直至最后填满A空间，之后清除 B 空间。</p>
</blockquote>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>商业虚拟机都采用“分代收集”，根据各个年代的特点分别采用适当的收集算法：</p>
<ul>
<li>在新生代中，每次垃圾收集时都会发现有大批对象死去，只有少量存活（前面提到的统计数据，大部分时候只有 10% 存活），那就选用复制算法。  </li>
<li>而老年代中因对象存活率高，没有额外空间对它进行担保，就必须使用“标记-清理”或者“标记-整理”算法进行回收。</li>
</ul>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>这是自己添加的这个标题，书中的结构并不是如此，因为 Android ART 虚拟机使用的也是CMS收集方式，所以这里特意抽出来理解，方便理解Android的虚拟机。 CMS (Concurrent Mark Sweep) 收集器，并发的“标记-清除”方式实现的收集器。它是一种以获取最短回收停顿时间为目标的收集器。它的整个过程分为4个步骤：</p>
<ul>
<li>初始标记  </li>
<li>并发标记  </li>
<li>重新标记  </li>
<li>并发清除  </li>
</ul>
<p>其中，初始标记、重新标记 这两个步骤仍然需要“Stop The World”，初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快；并发标记就是进行 GC Roots Tracing 的过程（根据初始标记过程中标识出来的直接关联对象，并发标记存活的对象）；重新标记阶段则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录；</p>
<p>由于整个过程中好事最长的 <strong>并发标记 和 并发清除</strong> 过程收集器线程都可以与用户线程一起工作，所以，从总体上来讲，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>CMS 是优秀的收集器，但是它也有3个明显的缺点：</p>
<ul>
<li><p>CMS 收集器对 CPU 资源非常敏感。与其他并发设计的程序一样，CMS收集器对 CPU 同样敏感，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用变慢。 </p>
</li>
<li><p>CMS 无法处理浮动垃圾(Floating Garbage,个人认为简而言之就是GC过程中用户线程产生的垃圾，类比于你妈妈在打扫房间卫生的时候，你还在继续撕的纸)。  </p>
</li>
<li><p>还有最后一个缺点，就是CMS本质还是“标记-清除”算法实现的，这种收集方式在结束后会产生大量的碎片化的空间。</p>
</li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>以下是几条最普遍的内存分配规则，可以通过代码去验证这些规则：</p>
<h3 id="对象优先在-Eden-上分配"><a href="#对象优先在-Eden-上分配" class="headerlink" title="对象优先在 Eden 上分配"></a>对象优先在 Eden 上分配</h3><p>大多数情况下，对象在新生代 Eden 区中分配，当 Eden 区没有足够空间时，虚拟机将发起一次 Minor GC （新生代GC）。可以采用以下方式验证：</p>
<p>通过 -Xms20M、-Xmx20M、-Xmn10M 三个参数限制Java 虚拟机堆大小 20MB，不可扩展，并且其中 10M 分配给新生代，剩下的 10MB 分配给老年代，-XX:SurvivorRatio=8决定新生代中 Edun 区与 一个 Survivor区的比例是 8：1，即 Eden 大小 8192K，两个 survivor 空间分别 1024K，所以新生代总共可用空间是 9216K （Eden 区 + 1个Survivor区）。<br>执行 testAllocation()尝试分配 3个 2M 的大小和1个 4MB 大小的对象。<br>代码执行完成后，可以发现 新生代Eden区被占用了 4M，而老年代被占用了 6M。<br>解释：分配前3个对象时，没有压力，均分配在Eden区域，当分配第4个对象时，内存已经不够了（可用空间是 9216K，而 2M*3 + 4M = 10），因此触发一次Minor GC，此时发现这3个对象都存活，并且 survivor 区间不够容纳存活的对象，因此这3个对象被直接通过担保机制提前转移到老年代中；这次GC结束后，第4个对象就可以顺利分配到Eden空间中。</p>
<blockquote>
<p>新生代GC(Minor GC):发生在新生代的垃圾收集，因为Java对象大多朝生夕死，所以Minor GC非常频繁，一般回收速度也比较快<br>老年代GC(Major GC/Full GC)：指的是老年代的GC，对于许多收集器而言，这时候都会伴随至少一次的 Minor GC，老年代的GC一般会比 Minor GC 慢10倍以上。</p>
</blockquote>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓大对象是指需要大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组。当然，比大对象更糟糕的是遇到一群朝生夕死的“短命大对象”，这种应当避免。经常出现大对象容易导致内存还有不少空间就提前触发垃圾收集器以获得足够的<strong>连续空间</strong>来安置它们。</p>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>如果对象在Eden出生并经历过第一次Minor GC 后仍然存活并且能被 Survivor 容纳的话，将被移动到Survivor 中，并且年龄设置为 1，此后，每熬过一次 Minor GC ，对象的年龄就加1，当达到某个阈值（系统一般默认 15），就会被晋升到老年代中。</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>为了更好地适应不同程序内存状况，并不总是要求对象必须达到某个年龄才进入老年代。如果 Survivor 中同龄对象达到某个阈值（一般是一半）时，大于或者等于这个年龄的对象就会移动到老年代。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>发生Minor GC 前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，则 Minor GC 可以确保是安全的，如果不成立，则会判断是否允许担保失败，如果允许担保失败，则最终可能会触发一次Full GC。虽然绕了一圈还是有可能触发 Full GC，但是这种情况相对较少。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章：Java内存区域与内存溢出异常</title>
    <url>/2019/04/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>根据《Java虚拟机规范(java SE 7)》规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域：</p><p><img src="/assets/Book-Notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%89%88/java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="Java运行时数据区域"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器可以看做是当前线程执行的字节码的行号指示器，它是线程私有的。在虚拟机概念模型里（具体虚拟机可能有更高效实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖程序计数器来完成。如果线程在执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行Native方法，这个计数器值为Undefined。<strong>此内存区域是Java虚拟机规范中唯一一个没有规定任何 OutOfMemoryError情况的区域</strong>。</p><a id="more"></a>


<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>Java虚拟机栈也是线程私有的。它描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，一个方法从调用至完成，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。<strong>这个区域被规定了两种异常状况：如果线程请求的栈深度大于虚拟机允许的深度，就抛出 StackOverflowError异常；如果该区域可以动态扩展，则在扩展时无法申请到足够内存，就会抛出OutOfMemoryError异常</strong>。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈类似，区别只不过是虚拟机栈为执行Java方法(即字节码)服务，而本地方法栈为Native方法服务，同样，<strong>本地方法栈也可能抛出StackOverflowError异常以及OutOfMemoryError异常</strong>.</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆是被所有线程共享的一块内存，虚拟机启动时创建。虚拟机规范描述是，所有对象的实例以及数组都要在堆上分配(当然，不同虚拟机实现不同)。<strong>如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常</strong>。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>与Java堆一样，方法区也是各个线程共享的内存区域。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<strong>当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常</strong>。</p>
<blockquote>
<p>提到方法区，不得不提<strong>运行时常量池</strong>，它是方法区的一个部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是信息常量池，用于存放编译期生成的各种字面量和符号引用（一般来说，翻译出来的直接引用也会存储在运行时常量池中）。</p>
</blockquote>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存(Direct Memory)不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在Java 1.4中新加入了NIO（New Input/Output）类，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectBuffer对象作为这块内存额引用进行操作，这样能在一些场景中显著提高性能，因为它避免在 Java 堆和 Native 堆中来回复制数据。<strong>当然，该区域空间在动态扩展时也可能出现OutOfMemoryError异常</strong>。</p>
<h2 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>虚拟机遇到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，则必须限制性相应的类加载过程。类加载完成后，便可完全确定对象所需的内存大小，接下来为新生的对象真正分配内存。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)、和对齐填充(Padding)。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的refrence数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针，其中前者通过句柄池间接指向堆中的对象，后者直接指向堆中的对象。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="OutOfMemoryError异常"><a href="#OutOfMemoryError异常" class="headerlink" title="OutOfMemoryError异常"></a>OutOfMemoryError异常</h3><p>Java虚拟机规范中，除了程序计数器之外，其他区域都可能发生 OutOfMemoryError异常。</p>
<h3 id="JAVA堆溢出"><a href="#JAVA堆溢出" class="headerlink" title="JAVA堆溢出"></a>JAVA堆溢出</h3><p>Java堆用于存储实例对象，只要不断地创建对象，并且保证GC root 到对象之间有可达路径来避免垃圾回收，那么就能产生OutOfMemoryError异常。</p>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>虚拟机栈和本地方法栈理论上分配不到足够的内存同样会报 OutOfMemoryError异常，但是一般情况下，首先会出现StackOverflowError，OutOfMemoryError很难出现。</p>
<h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><p>由于运行时常量池是方法区的一个部分，因此这两个区域的溢出测试放在一起进行。在此之前我们先了解下String.intern()方法：</p>
<blockquote>
<p>String.intern()是一个Native方法，它的作用是，如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并返回此String对象的引用。</p>
</blockquote>
<p>在JDK1.6及以前，通过设置永久代区域的大小可以间接限制方法区大小，但是从JDK 1.7以后就“去永久代”了，因此以下代码只在JDK 1.6 ，并且设置了 MaxPermSize 时有效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用List保持常量池的引用，避免full gc 回收常量池</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        list.add(String.valueOf(i++).intern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的原因，还可以引申一个更有意思的影响，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append（“软件”）.toString();</span><br><span class="line">    Systemt.out.println(str1.intern() == str1);</span><br><span class="line">    </span><br><span class="line">    String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">    Systemt.out.println(str2.intern() == str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在JDK 1.6 中运行，会得到两个false（intern 方法会把首次遇到的字符串实例复制到永久代中，而StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用）；而在JDK 1.7 中会得到一个true（intern 实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此，intern返回的引用和由StringBuilder创建的字符串实例是同一个实例）一个false（“java”字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现，而“计算机软件”这个字符串则是首次出现的—这个解释没看懂，需要再次理解）。</p>
<h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>直接或者间接地使用NIO，就可能出现本机直接内存溢出。虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但是抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配。因此可以通过以下代码手动抛出异常，真正抛出异常的地方是unsafe.allocateMemory()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下代码能够抛出异常的前提是，设置虚拟机参数 -XX: MaxDirectMemorySize 的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">	unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">		unsafe.allocateMemory(_1MB);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-算法-基本查找</title>
    <url>/2019/03/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="704、二分查找，给定一个-n-个元素有序的（升序）整型数组-nums-和一个目标值-target-，写一个函数搜索-nums-中的-target，如果目标值存在返回下标，否则返回-1"><a href="#704、二分查找，给定一个-n-个元素有序的（升序）整型数组-nums-和一个目标值-target-，写一个函数搜索-nums-中的-target，如果目标值存在返回下标，否则返回-1" class="headerlink" title="704、二分查找，给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1"></a>704、二分查找，给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>还没写。。。。。</p>
<p>自己写的时候的问题：<strong>这题目自己写得还不错</strong></p>
</details><blockquote>
<p>参考链接：<a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 架构设计之AAC</title>
    <url>/2019/03/10/Android%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8BAAC/</url>
    <content><![CDATA[<p>照例先上<a href="https://developer.android.google.cn/topic/libraries/architecture/index.html" target="_blank" rel="noopener">官方描述</a></p><p><a href="https://developer.android.google.cn/jetpack/docs/guide" target="_blank" rel="noopener">官方提供的应用架构指南</a></p>]]></content>
      <categories>
        <category>专题</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章：操作系统基础</title>
    <url>/2019/03/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC4%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="进程间通信的经典实现"><a href="#进程间通信的经典实现" class="headerlink" title="进程间通信的经典实现"></a>进程间通信的经典实现</h2><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存的工作流程：</p><ol>
<li>创建共享区。进程1从内存中申请一块内存作为共享区域，并且将该区域与某个Key绑定  </li>
<li>映射共享区。创建共享区之后，需要将其映射到进程1的空间中才能操作。  </li>
<li>访问共享区。进程2利用第一步得到的Key，访问到共享区，之后将这块内存映射到进程2的空间中。  </li>
<li>进程间通信。各进程实现了对共享内存的映射后，便可以利用该区域进行信息交换。（注意：整个内存过程都没有实现同步机制，需要进程间自己实现）  </li>
</ol><a id="more"></a>

<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li>进程A和B分立管道两端，进行数据传输通信</li>
<li>管道是单向的，如果进程既要“读”也要“写”，就需要两根管道这点很像水管的特性  </li>
<li>管道同时具有“读取”(read end)端和“写入”(write end)端，比如进程A从 write end 写入，进程 B 就可以从 read end 端读取到数据  </li>
<li>管道容量有限制，当pipe满了后，写操作将阻塞；反之，pipe空了之后，读操作将会阻塞  </li>
<li>普通的管道是<strong>匿名的</strong>，这种匿名的管道只适合有斧子关系的进程通信，如果要实现没有任何关系的管道间的通信，就需要<strong>命名管道(Named pipe)</strong></li>
</ul>
<h3 id="UNIX-DOMAIN-SOCKET"><a href="#UNIX-DOMAIN-SOCKET" class="headerlink" title="UNIX DOMAIN SOCKET"></a>UNIX DOMAIN SOCKET</h3><ul>
<li>简称UDS,也可以说是IPC Socket，与普通的Socket不一样，专门针对单机进程间通信提出来的。  </li>
<li>大家熟知的 Network Socket 是以 TCP/IP 协议栈作为基础的，需要分包、重组 等一系列操作，而 UDS 因为是本机内的“安全可靠操作”，实现机制上并不依赖于这些协议。  </li>
<li>Android 中使用最多的一种IPC就是Binder，其次就是 UDS 。  </li>
</ul>
<h3 id="RPC（REMOTE-PROCEDURE-CALLS）"><a href="#RPC（REMOTE-PROCEDURE-CALLS）" class="headerlink" title="RPC（REMOTE PROCEDURE CALLS）"></a>RPC（REMOTE PROCEDURE CALLS）</h3><p>RPC 涉及通信双方通常运行于两台不同的机器中。</p>
<h2 id="同步机制的经典实现"><a href="#同步机制的经典实现" class="headerlink" title="同步机制的经典实现"></a>同步机制的经典实现</h2><p>###信号量（SEMAPHORE）</p>
<p>信号量与PV原语是分不开的，也是最为广泛的互斥方法之一，主要包括以下几个元素：</p>
<ul>
<li>Semaphore S（信号量，用于指示共享资源的可用数量）  </li>
<li>Operation P （可以减小S计数）  </li>
<li>Operation V （可以增加S计数）  </li>
</ul>
<blockquote>
<p>P执行：S = S -1，此时判断若 S&gt;=0 ，说明资源此时允许访问，开始操作共享资源；否则，加入等待队列，待别人释放资源后唤醒。<br>V执行：S=S+1，如果此时S&gt;0，说明当前没有希望访问资源的等待者；否则，唤醒等待队列中的相关对象。<br><strong>其中，PV源于都属于原子操作，意味着他们执行过程是不允许被中断的。</strong></p>
</blockquote>
<h3 id="互斥体（MUTEX）"><a href="#互斥体（MUTEX）" class="headerlink" title="互斥体（MUTEX）"></a>互斥体（MUTEX）</h3><p>Mutex 是 Mutual Exclusion 的缩写，释义为 互斥体。如果资源允许多个对象同时访问，成为 Counting Semaphores；而如果只允许取值0或1（lock/unlocked）的Semaphore，则叫做 Binary Semaphore。Binary Semaphore 与Mutex有相同性质，Mutex通常是对某一排他资源的共享控制——要么这个资源被占用（locked），要么是可以访问的（unlocked）。</p>
<h3 id="管程（MONITOR）"><a href="#管程（MONITOR）" class="headerlink" title="管程（MONITOR）"></a>管程（MONITOR）</h3><p>针对信号量机制的程序易读性较差，并且信号量管理分散在各个参与对象中，很难维护等缺点，管程被提出来了。管程是可以被多个进程/线程安全访问的对象或者模块，管程中的方法在同一时刻只允许一个范文这使用它们（方法受 mutual exclusion 保护的）。</p>
<h2 id="操作系统内存基础"><a href="#操作系统内存基础" class="headerlink" title="操作系统内存基础"></a>操作系统内存基础</h2><p>操作系统中任何操作都与内存息息相关，内存管理的底层原理主要注意几个核心：</p>
<ul>
<li>虚拟内存</li>
</ul>
<blockquote>
<p>内存总是“不够大”的，随着应用的增加，总会填满，虚拟内存为运行更多的程序提供了可能，其基本思想是：1.将硬盘上一部分空间作为内存的扩展；2.出现资源不足时，按照一定算法挑出优先级较低的数据块移动到第1步划出的空间；3.需要用到硬盘中的数据块时，系统将产生“缺页”，之后把硬盘中的数据交换回内存中。</p>
</blockquote>
<ul>
<li>内存分配与回收</li>
</ul>
<blockquote>
<p>分配、native层回收，java层回收</p>
</blockquote>
<ul>
<li>内存保护</li>
</ul>
<blockquote>
<p>内存分页或者分段式管理。进程的逻辑地址不是直接对应物理地址的，因此没办法访问它范围外的内存空间。</p>
</blockquote>
<p><strong>顺带一提，mmap函数（Memory Map）正如其名，可以将某个设备或者文件映射到应用进程的内存空间中，这样访问这块内存就相当于对设备/文件进行读写；可见，理论上mmap可以用于进程间通信，即通过映射同一块物理内存来共享内存，这种方式因为减少了复制次数，在一定程度上提高了进程间通信效率。</strong></p>
<h2 id="Android-匿名共享内存（Ashmem）"><a href="#Android-匿名共享内存（Ashmem）" class="headerlink" title="Android 匿名共享内存（Ashmem）"></a>Android 匿名共享内存（Ashmem）</h2><p>Ashmem 全称 Anony Shared Memory，是Android 特有的内存共享机制，它可以将指定的物理内存分别映射到各个进程的地址空间，从而便捷地实现进程间的内存共享。Ashmem 是一个 misc 设备，其实现依托于 /dev/ashmem 。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解Android内核设计思想-林学森</tag>
      </tags>
  </entry>
  <entry>
    <title>针对简历的问题</title>
    <url>/2019/03/08/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%92%88%E5%AF%B9%E7%AE%80%E5%8E%86%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><font color="ff0000">根据技术栈可能的提问</font></p><h2 id="1、聊聊-java-中-static-关键字"><a href="#1、聊聊-java-中-static-关键字" class="headerlink" title="1、聊聊 java 中 static 关键字"></a>1、聊聊 java 中 static 关键字</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>一旦什么东西设置为 static ，数据或者方法就不会同那个类的任何对象实例有联系。例如以下类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管我们可以给StaticTest 类new 出 2个对象来，但是 StaticTest.i 仍然只有一个存储空间，即两个对象共享同样的i，此时，其中一个对象执行 ++i 后，另一个对象的 i值 也会变为 48。</p>
<p>静态的变量或者方法，可以通过对象引用，也可以直接通过类引用，如以上的i，可以使用如下两种方式引用：</p>
<blockquote>
<p>假设st 是 StaticTest 类的对象： st.i = 4   或者  StaticTest.i = 4</p>
</blockquote>
</details><a id="more"></a>


<h2 id="2、Kotlin-相关"><a href="#2、Kotlin-相关" class="headerlink" title="2、Kotlin 相关"></a>2、Kotlin 相关</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="Kotlin-中的协程用过吗？聊聊？"><a href="#Kotlin-中的协程用过吗？聊聊？" class="headerlink" title="Kotlin 中的协程用过吗？聊聊？"></a>Kotlin 中的协程用过吗？聊聊？</h3><p>简单使用过，但是仅仅用于线程切换，对协程有一些简单的了解：</p>
<ul>
<li>协程是编译器级别的，进程和线程是操作系统级的</li>
<li>线程根据os的调度算法，当分配的时间片用完后，保存当前上下文，之后被强制挂起，开发者无法精确控制它们</li>
<li>协程可以看做是轻量级的用户态线程</li>
<li>协程实现的是<strong>非抢占式</strong>的调度，由当前协程控制什么时候切换到其他协程</li>
<li>每个协程池里都有一个调度器，这个<strong>调度器是被动调度的</strong>，即当前协程主动让出cpu时调度</li>
<li>目前的协程框架一般设计成 1:N 的模式，即一个线程作为容器，里面包含多个协程</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>协程轻量，创建成本小，内存消耗小    </p>
</li>
<li><p>协作式的用户态调度器，cpu上下文切换开销少    </p>
<blockquote>
<p>进程/线程 切换需要在内核完成，而协程通过用户态栈实现，速度更快，但协程也放弃了线程中优先级的概念</p>
</blockquote>
</li>
<li><p>减少同步加锁，整体性能提高    </p>
<blockquote>
<p>协程基于事件循环，减少同步加锁的频率。但若存在竞争，该上锁的地方仍需要加上协程锁    </p>
</blockquote>
</li>
<li><p>可以按照同步思维写异步代码，即用同步的逻辑，写由协程调度的回调</p>
<blockquote>
<p>协程可以减少callback 的使用，但是不能完全替代callback，基于事件驱动的变成用callback更合适</p>
</blockquote>
</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>协程中不能有阻塞操作，否则整个线程被阻塞(协程是语言级别，线程是操作系统级别)      </li>
<li>需要特别关注全部变量、对象引用的使用    </li>
<li>协程擅长处理IO密集型程序效率问题，但处理cpu密集型不是它的长处    <blockquote>
<p>假设线程中有个协程是cpu密集型，但是没有io操作，也就是一时半会不会主动触发调度器调度，从而其他协程得不到执行      </p>
</blockquote>
</li>
</ul>
<h4 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h4><ol>
<li>高性能计算，牺牲公平性换区吞吐量；          </li>
<li>在 IO 密集型程序中。由于io密集型的程序中往往需要 CPU 频繁切换线程，带来大量性能浪费。但是协程可以很好地解决这个问题：比如把一个IO操作写成一个协程，当触发IO操作时就自动让出cpu给其他协程，协程间的切换是很轻的。      </li>
<li>流式计算。消除Callback Hell。    </li>
</ol>
<h3 id="Kotlin-优势"><a href="#Kotlin-优势" class="headerlink" title="Kotlin 优势"></a>Kotlin 优势</h3><p>按照官网上的说法：</p>
<ul>
<li>简洁。语法简单，代码很少。判空、getter、setter 方法、命名传参(动态改变参数)无需重载，可能结合anko 之类的更加简单    </li>
<li>安全，减少空指针等错误、类型判断过后，自动类型转换      </li>
<li>兼容java，可以混编</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>lateinit，也容易引起空指针，即还未初始化    </li>
<li>直接使用 ArrayList 之类的list 是不能直接添加元素的，得使用 MutableList 才行     </li>
<li>引入了kotlin 支持库，apk包体积增加     </li>
<li>如果某个变量设置为可空的，那么即使你在初始化后，已经不空了，你也只能使用 ? 或者  !! 操作来使用它，感觉会有点乱     </li>
</ul>
<h3 id="kotlin如何实现空安全"><a href="#kotlin如何实现空安全" class="headerlink" title="kotlin如何实现空安全"></a>kotlin如何实现空安全</h3><ul>
<li>可空类型和不可空类型     </li>
<li>使用 ? 进行安全调用      </li>
<li>入参可以指定可空和非空类型     </li>
<li>安全的类型转换，如 a as? Int      </li>
<li>可以方便过滤非空元素，如： val intList: List<int> = nullableList.filterNotNull()      </int></li>
</ul>
<p>一定能避免空指针问题吗？我认为是不能，因为有 lateInit 变量存在，有可能这个变量还没初始化，就会导致是空的</p>
</details>

<h2 id="3、有自定义view的经验，那如何理解-MeasureSpec？"><a href="#3、有自定义view的经验，那如何理解-MeasureSpec？" class="headerlink" title="3、有自定义view的经验，那如何理解 MeasureSpec？"></a>3、有自定义view的经验，那如何理解 MeasureSpec？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>MeasureSpec 的含义是：父View传递给当前 View 的一个建议值。MeasureSpec 是个int 类型的数字，转换成二进制后，前2位代表模式(mode)，后30位代表数值(size)。模式总共分为3种：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/MeasureSpec%E6%B5%8B%E9%87%8F%E6%A8%A1%E5%BC%8F.jpg" alt="MeasureSpec测量模式"></p>
<p><strong>measureSpec &amp; MODE_MASK 即可获得mode的值；而 measureSpec &amp; ~MODE_MASK 即可获得数值</strong>。</p>
<p>那么，measureSpec 的值到底是如何计算得到的？view的 measureSpec 根据view 的布局参数(LayoutParams) 和 父容器的 MeasureSpec 值计算得到的，计算方法如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/view%E7%9A%84measureSpec%E5%80%BC.jpg" alt="view的measureSpec值"></p>
<p>由于UNSPECIFIED模式用于系统内部多次measure 的情况(如listview、gridview 等)，很少用到自定义view上，因此我们很少讨论。以下总结的规律也不讨论：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/measureSpec%E8%A7%84%E5%BE%8B.jpg" alt="measureSpec规律"></p>
<p>以上总结中，父容器的剩余空间指的是父容器除了padding之外的所剩余的空间，至于<font color="ff0000">父容器的剩余空间与大小不超过父容器的剩余空间，看代码和看图都没能理解，后续再理解吧</font></p>
<p><strong>以上内容部分<a href="https://blog.csdn.net/carson_ho/article/details/94545178" target="_blank" rel="noopener">参考自这个链接</a></strong></p>
</details>

<h2 id="4、聊聊-Android-中事件分发机制？"><a href="#4、聊聊-Android-中事件分发机制？" class="headerlink" title="4、聊聊 Android 中事件分发机制？"></a>4、聊聊 Android 中事件分发机制？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><a href="https://glassx.gitee.io/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/">参考以前写的这篇文章</a></p>
<p>上面的文章中已经写得很明白了，但是需要重点再提一下的是，如果在 onTouchEvent 中不消耗事件，则在同一个事件序列中，当前View无法再次接到事件。</p>
</details>

<h2 id="5、如何处理手势冲突？"><a href="#5、如何处理手势冲突？" class="headerlink" title="5、如何处理手势冲突？"></a>5、如何处理手势冲突？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>有外部和内部两种方式处理手势冲突。</p>
<p><strong>外部拦截</strong>：由上面的事件分配可知，点击事件都会经过父容器拦截处理，如果父容器需要此事件就拦截，否则此事件就不拦截，这样就可以解决事件冲突。外部拦截法需要重写父容器的onInterceptTouchEvent，比较符合事件分发机制。      </p>
<blockquote>
<p>这里要注意的是，还是上面的原则，在 onInterceptTouchEvent 中，首先是ACTION_DOWN 这个事件，父容器必须返回false，即不拦截，因为一旦拦截了 ACTION_DOWN ,后续的 ACTION_MOVE 和 ACTION_UP 都没法再传递给子view了； <font color="ff0000">接下来的内容辩证看待：ACTION_MOVE根据需要是否拦截；ACTION_UP 必须返回false，因为如果返回true，那么子view 是接受不到 ACTION_UP 事件，onClick 事件就无法响应。</font></p>
</blockquote>
<p><strong>内部拦截法</strong>：</p>
<p>可以利用view事件分发的原则，在适当的地方拦截就行。</p>
<p>当然，也可以让父空间不拦截，如果是ViewGroup的话，可以在 onInterceptTouchEvent 方法中请求忽略外层容器拦截事件：getParent().requestDisallowInterceptTouchEvent(true) 。如果是View的话，那么把getParent().requestDisallowInterceptTouchEvent(true) 写在setOnTouchListener 方法中可能更合适。</p>
</details>

<blockquote>
<p>以上内容参考自<a href="https://blog.csdn.net/u014628886/article/details/52222115" target="_blank" rel="noopener">一骑绝尘</a>  和 <a href="https://www.jianshu.com/p/4f3e7a057cd6" target="_blank" rel="noopener">前行的乌龟</a></p>
</blockquote>
<h2 id="6、如何优化App性能？"><a href="#6、如何优化App性能？" class="headerlink" title="6、如何优化App性能？"></a>6、如何优化App性能？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><strong>一、精简资源</strong>     </p>
<ul>
<li>lint检测，删除无用的资源           </li>
</ul>
<p><strong>二、减轻Application的负担</strong></p>
<ul>
<li>将非紧急操作，放在子线程中处理     </li>
<li>只在主进程中初始化app内容(因为接了百度地图等，会开启多个进程)    </li>
</ul>
<p><strong>三、UI绘制优化</strong></p>
<ul>
<li>布局优化，尽量使用 ConstraintLayout 减少布局层次(因为深度遍历)     </li>
<li>布局复用，比如底部的布局大体相似，都使用同一个 layout     </li>
<li>避免过度绘制。排查移除叠加的背景      </li>
<li>减少资源数目，因为shape很难复用，故shape换成 固定的控件： ShapedTextView、ShapedConstrainLayout 等      </li>
<li>提高显示速度</li>
</ul>
<blockquote>
<p>使用 viewstub 延后显示。         </p>
</blockquote>
<p><strong>四、内存相关优化</strong>      </p>
<blockquote>
<p>一言以蔽之： 开源节流</p>
</blockquote>
<ul>
<li>webview 新进程          </li>
<li>检查内存泄漏(LeakCanery)    </li>
<li>正确地使用引用，尤其Activity的context(尽量替换成Application 的context，Activity 的Context 一律弱引用)，以及强引用、弱引用、软引用的正确使用。       </li>
<li>使用正确的容器，比如避免自动装箱(使用SparseArray等)、避免hashmap内存浪费(使用ArrayMap等)       </li>
<li>枚举替换成注解。</li>
</ul>
<p><strong>五、cpu 相关优化</strong>   </p>
<ul>
<li>解析缓存数据一律放在子线程处理    </li>
<li>SharedPreference 存储json改动    </li>
<li>webview预加载</li>
</ul>
<p><strong>六、网络优化</strong>   </p>
<ul>
<li>域名替换成ip(选取响应速度最快的ip)，避免劫持同时提升响应速度，webview 中的网络请求由网络框架接管。    </li>
</ul>
<p><strong>七、结构</strong></p>
<ul>
<li>mvp</li>
</ul>
<p><strong>八、避开高峰</strong></p>
<ul>
<li>不要同时，充分利用IdleHandler，快速滑动的时候不加载图片</li>
</ul>
<p>具体优化方式：</p>
<blockquote>
<p>1、内存从经常性的 380M 左右降低到 330M 的水平(adb shell dumpsys com.esun.ui，现在可以使用profile)<br>2、页面秒开(talkingdata数据显示，优化前88%左右,93%的收集数据显示1秒以内打开，从onCreate 到onResume)<br>3、过度绘制(优化前几乎所有主要页面都是红色-蓝、绿、粉、红 分别代表过度绘制 1,2,3,4 次，优化后基本上都是蓝绿，粉色的比较少，红色的可能只有极少数小块)<br>4、App启动速度加快，冷启动，从3.5秒左右降低到1秒左右(录屏，记录从启动到展示flash页面，多次时间取平均值)<br>5、网络连接，网络的错误率4%(按次数统计出的)左右，dns加速后，网络错误率基本上保持，主要集中在网络超时、网络无连接两种异常，其中网络超时占了40%左右                 </p>
</blockquote>
</details>

<h2 id="引申-adb-shell-dumpsys-meminfo-com-esun-ui-中各数据含义"><a href="#引申-adb-shell-dumpsys-meminfo-com-esun-ui-中各数据含义" class="headerlink" title="引申-adb shell dumpsys meminfo com.esun.ui 中各数据含义"></a>引申-adb shell dumpsys meminfo com.esun.ui 中各数据含义</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>Native Heap：  Native对象malloc得到的内存<br>Dalvik Heap：  Java对象new得到的内存<br>Dalvik Other： 类数据结构和索引占据的内存<br>Stack：        栈占用的内存(栈空间使用，如函数调用、局部变量等)<br>Pss Total：    在硬盘上实际占用的空间大小<br>Heap Size：   Heap总共内存大小 = Heap Alloc + Heap Free, HeapSize 有限制，超出阈值就oom<br>Heap Alloc：  应用所有实例分配的内存，包括应用从Zygote 共享分享的内存(只是分配的虚拟空间，并没有实际占用，比如：new long[1024*1024]，此时alloc就会新增了8M，但是由于没赋值，所以物理内存上并没有占用，如果针对每个元素赋值，则pss total 就会增加8M)<br>Heap Free：   堆空闲的大小<br>Objects： 统计App内部组件对象的个数，其中Views、ViewRootImpl以及Activities个数，在Activity的onDestroy之后应该都会清零，如果未清零，就可能发生了内存泄露</p>
<p>Private Dirty： 私有的脏内存页(还在使用中)<br>Private Clean： 私有的干净内存页(现在未使用了)<br>Private Dirty + Private Clean 便是应用曾经申请过的内存空间大小</p>
</details>

<blockquote>
<p>以上内容参考自<a href="https://www.jianshu.com/p/37539308ff32" target="_blank" rel="noopener">简书上的博客</a></p>
</blockquote>
<h2 id="7、引申-ArrayMap的原理、SparseArray原理"><a href="#7、引申-ArrayMap的原理、SparseArray原理" class="headerlink" title="7、引申-ArrayMap的原理、SparseArray原理"></a>7、引申-ArrayMap的原理、SparseArray原理</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<h3 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h3><p>ArrayMap 相对HashMap 而言是以时间换空间。它使用两个数组，一个整数型数组存储 key 的 hashCode，另一个Object[] 类型的数组存储 key-value键值对，如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/ArrayMap%E5%8E%9F%E7%90%86.png" alt="ArrayMap原理"></p>
<p>这样的结构避免了为每个key创建额外的对象，也即避免了自动装箱(如需要将int包装成 Integer) ，每次put新元素时，key的hashcode 在hashCode的数组中按照顺序存储，object数组中存储key和value。查询元素时，首先获取key的hashCode，然后用二分法查找该hashCode 在第一个数组中的index，则在object 数组中，key的位置在 index&lt;&lt;1 处，而value在 index&lt;&lt;1 + 1 处，如果此时的key并不是当前的key，则认为发生了冲突，此时以该key为中心点，分别上下匹配，直到匹配到为止。</p>
<p>在插入删除元素时，由于是数组组织形式，因此需要移动相关的元素，因此效率并不高；但是在数据量相对较少的情况下(有些博客说是1000条数据以下)，ArrayMap 带来的时间开销并不明显，但是节省的内存却十分可观。</p>
<h3 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h3><p>SparseArray 用于key为int类型，value 为 Object 的情形，与HashMap 相比，它避免了Integer 自动装箱，并且没有依赖entry 数据结构，因此更高效。它的结构如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/SparseArray%E5%8E%9F%E7%90%86.png" alt="SparseArray原理"></p>
<p>因为key是int类型，所以也就不需要什么hash值来计算index了，只要int值相等，就是同一个对象。插入和查找也是二分法，所以原理与ArrayMap 基本上一致，所以不多说。为了提升性能，删除元素时，并不需要马上将元素置为空，而是先将其标记为一个需要删除的元素，等真正需要删除时，才清空处理。即如果要插入新数据，如果数组已经填满了，则尝试垃圾回收一下，把标记为DELETE 的对象回收，然后重新寻找key值对应的索引，并插入。</p>
<p>** 除了SparseArray 可以替代 HashMap&lt;Integer,V&gt;外，还有 SparseIntArray替换HashMap&lt;Integer,Integer&gt;、SparseLongArray替换HashMap&lt;Integer,Long&gt;、LongSparseArray 替换 HashMap&lt;Long,V&gt; **</p>
</details>

<blockquote>
<p>以上内容<a href="https://blog.csdn.net/chewbee/article/details/72998423" target="_blank" rel="noopener">可以参考这个链接</a></p>
</blockquote>
<h2 id="8、描述http-三次握手？为什么3次，2次或者4次不行？"><a href="#8、描述http-三次握手？为什么3次，2次或者4次不行？" class="headerlink" title="8、描述http 三次握手？为什么3次，2次或者4次不行？"></a>8、描述http 三次握手？为什么3次，2次或者4次不行？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>首先，准确地说是TCP/IP三次握手。因为http本身是应用层协议，只是因为目前http的传输层确实是TCP/IP，所以可以这么说。但是http并不依赖于tcp/ip。</p>
<p>TCP发起连接的一方A，会随机生成一个32位的序列号，比如是1000，以该序列号为原点，对自己每个将要发送的数据进行编号，连接的另一方B会对A的每次数据进行确认，如果A收到B的确认编号是2001，则意味着 1001~2000 编号已经安全到达B。握手的示意图如下所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="tcp三次握手示意图"></p>
<p>所以我们可以总结，<strong>TCP 连接握手，握的是啥？其实就是告知双方数据原点的序列号</strong>。那为什么是3次握手呢？个人认为有两个原因：</p>
<ul>
<li>确认通信双方的 接收/发送 能力是正常的。第一次握手，B可以知道自己的接收能力、A的发送能力是正常的；第二次握手，A可以知道双方的收/发能力是正常的；第三次握手，B知道双方的收/发能力都正常。       </li>
<li>节省资源。我们知道，等3次握手结束后，服务端才给这条链接分配必要端口、缓存等资源。如果是2次握手，那么在收到客户端的请求后服务端就得分配资源了，如果第2次握手由于超时丢失，那么客户端会认为服务器还未响应，可能造成两端都在等。或者客户端等到放弃这次请求，而服务端之前分配的资源会被浪费。    </li>
</ul>
<p>因此，3次握手是必需的，更多的请求次数可以，但是浪费资源，没必要。</p>
</details>

<blockquote>
<p>以上内容有部分是<a href="https://www.zhihu.com/question/67772889" target="_blank" rel="noopener">参考知乎中的内容</a></p>
</blockquote>
<h2 id="9、延伸-http-使用80端口，如果客户端一个tcp-ip在连接，那么就无法建立其他tcp-ip连接，因为80端口在占用？"><a href="#9、延伸-http-使用80端口，如果客户端一个tcp-ip在连接，那么就无法建立其他tcp-ip连接，因为80端口在占用？" class="headerlink" title="9、延伸-http 使用80端口，如果客户端一个tcp/ip在连接，那么就无法建立其他tcp/ip连接，因为80端口在占用？"></a>9、延伸-http 使用80端口，如果客户端一个tcp/ip在连接，那么就无法建立其他tcp/ip连接，因为80端口在占用？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>不是的，80端口一般只是http应用的默认监听端口，就是说新的连接都是发送到80端口的。但是监听80端口的程序会给新建立的连接分配一个可用的端口，所以实际的这条连接可能是机那里在服务端的 10010端口，客户端的8888端口上的。而80端口会继续监听是否有新的连接到来。</p>
</details>

<h2 id="10、描述4次挥手，3次行不行？为什么？"><a href="#10、描述4次挥手，3次行不行？为什么？" class="headerlink" title="10、描述4次挥手，3次行不行？为什么？"></a>10、描述4次挥手，3次行不行？为什么？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>tcp/ip 是全双工的，client 端在没有数据需要发送给server的时候，就发送FIN 信号告知Server ，然后终止对server 的数据传输，但是server 可以继续对client 发送数据包，这时候就是4次来终止连接，过程如下图所示：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/tcp%E7%9A%844%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="tcp的4次挥手"></p>
<p>但是，<strong>如果Server 收到client 的FIN 包之后，再也没有数据要发给Client 了，那么对Client 的ack 包和 Server 自己的FIN 包就能合并成一个包发送出去，4次挥手就能变成3次挥手。</strong></p>
<p>关于图中的 time_await ，它的作用主要是1、为实现TCP全双工连接的可靠释放；2、为使旧的数据包在网络因过期而消失。更详细的解释可以<a href="https://glassx.gitee.io/2018/05/21/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0/">参考以前的这篇文章</a></p>
</details>

<h2 id="11、了解哪些设计模式？写个单例模式？"><a href="#11、了解哪些设计模式？写个单例模式？" class="headerlink" title="11、了解哪些设计模式？写个单例模式？"></a>11、了解哪些设计模式？写个单例模式？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<ul>
<li>单例模式         </li>
<li>建造者模式       </li>
<li>工厂模式        </li>
<li>适配器模式       </li>
<li>装饰模式        </li>
<li>观察者模式         </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程安全的单例模式代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//注意 volatitle 关键字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> volatitle Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造函数私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
</details>

<p><font color="ff0000">以下针对项目可能的提问</font></p>
<h2 id="12、了解多线程使用，聊聊锁可以分为哪些种类"><a href="#12、了解多线程使用，聊聊锁可以分为哪些种类" class="headerlink" title="12、了解多线程使用，聊聊锁可以分为哪些种类"></a>12、了解多线程使用，聊聊锁可以分为哪些种类</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>大体可以分为，这不全部指锁的状态，有的指锁的特性，有的指锁的设计：</p>
<ul>
<li>乐观锁/悲观锁    </li>
<li>公平锁/非公平锁     </li>
<li>偏向锁    </li>
<li>轻量级锁    </li>
<li>自旋锁      </li>
<li>可重入锁    </li>
</ul>
</details>

<blockquote>
<p>具体可以<a href="https://glassx.gitee.io/2019/09/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC13%E7%AB%A0/">参考以前写的这篇博客</a></p>
</blockquote>
<h2 id="13、引申-聊聊-HandlerThread"><a href="#13、引申-聊聊-HandlerThread" class="headerlink" title="13、引申-聊聊 HandlerThread"></a>13、引申-聊聊 HandlerThread</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>HandlerThread 继承了 Thread ，所以本质上是个workThread，只不过它带了个Looper，无需开发者自己去做Looper.prepare() 操作，可以看下其关键源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以我们在使用的时候，首先new 出一个对象来，接着就要执行其start() 方法，以便完成 Looper 的初始化，其中，notifyAll() 主要用于方法 getLooper() 中通知 Looper 已经准备好，唤醒wait：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在使用完成之后，需要手动退出Thread：mHandlerThread.quit();  ，其原理不用写也知道：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper looper = getLooper();</span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">        looper.quit();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上原理我们可以知道，HandlerThread 的使用场景就是：需要在子线程执行耗时的，并且可能有多个任务的操作(每个任务都开线程导致线程太多啊)，比如多个下载任务(非同一个任务多线程下载)，还有一个典型例子就是IntentService。</p>
</details>

<h2 id="14、延伸-IntentService"><a href="#14、延伸-IntentService" class="headerlink" title="14、延伸-IntentService"></a>14、延伸-IntentService</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>我们知道，IntentService 使用非常简单，不需要自己建立线程，执行完毕后也无需我们自己关闭Service，只需要专心在 onHandleIntent(Intent intent) 方法中实现逻辑即可。IntentService 使用<strong>工作线程</strong><font color="ff0000">逐一</font>处理所有启动请求，如果不需要在Service中执行并发任务，IntentService 是最好的选择。至于如何做到的，我们只要看关键源码即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IntentService onCreate 中创建了 HandlerThread 实例，mServiceHandler 创建时使用了 HandlerThread 的 Looper，这决定了最终业务是在HandlerThread 中的子线程中执行的，在 handleMessage 方法中看到了熟悉的 onHandleIntent 方法调用，待 onHandleIntent 执行完毕后，马上执行Service 的 stopSelf(msg.arg1) 关闭自己。</p>
<p>这里使用 stopSelf(msg.arg1) 而不是 stopSelf()，而msg.arg1 即 startId，而这个 startId 就是 onStartCommand(Intent intent,int flags,int startId) 的最后一个参数。我们知道多次调用startService 来启动同一个Service ，只有第一次会执行 onCreate ，但是会多次调用onStartCommand，以及onStart(所以IntentService 中，在onStart方法里面发送Message到Handler)，并且每次 startId 并不相同，且都大于0。而stopSelf() 最终会调用 stopSelf(-1)<br>。</p>
<p>stopSelf(int startId) 中的startId 与 onStartCommand 的startId 是一一对应的关系，所以，<strong>当我们调用stopSelf(int startId)时，系统会检测是否还有其它startId 存在，有的话就不销毁当前service，没有的话则销毁。</strong></p>
<p>所以，为什么是调用stopSelf 而不是调用 stopSelf(int startId)，从上面的比较我们得出：这是为了提高 IntentService 的利用率，如果在 onHandleIntent 方法执行完毕前，又调用了startService 启动了同一个 IntentService ，那么我们就没必要销毁当前service了，直接继续使用当前service 对象执行任务即可，这样有利于减少对象的销毁及创建。再提及一句，由于是使用HandlerThread ，所以多个任务只能是串行方式依次执行。</p>
</details>

<blockquote>
<p>以上内容<a href="https://www.jianshu.com/p/bed2efd303fe" target="_blank" rel="noopener">参考俗人浮生</a> 的博客，以及 IntentService 官方源码</p>
</blockquote>
<h2 id="15、volatile-关键字有了解吗？"><a href="#15、volatile-关键字有了解吗？" class="headerlink" title="15、volatile 关键字有了解吗？"></a>15、volatile 关键字有了解吗？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>讲解之前，首先了解 原子性、可见性 以及 有序性 的基本概念：</p>
<p><img src="/assets/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/%E5%8E%9F%E5%AD%90%E6%80%A7-%E5%8F%AF%E8%A7%81%E6%80%A7-%E6%9C%89%E5%BA%8F%E6%80%A7%E6%A6%82%E5%BF%B5.jpg" alt="原子性-可见性-有序性概念"></p>
<p>一言以蔽之，volatile 保证可见性、有序性，但是不保证原子性。</p>
<p><strong>保证可见性：</strong>多个线程共享一个volatile变量k，如果一个线程在工作内存中修改k的值会立即刷新到主存，同时将其他线程中的该值设置成已过期，其他线程在下次使用k值时，需要从主内存刷新获取。<strong>在k值更改前就已经在使用的情形，比如k值在做加法的途中，如果k值改变，则是不受影响的，必须是下一次再次使用k的时候，才会从主存去刷新</strong>。还有要注意的是，子线程使用成员变量都会将变量从主存中拷贝一份，而不是直接使用。</p>
<p><strong>保证有序性：</strong>我们知道为了提高性能，cpu或者编译器会对代码重排序，代码的执行顺序不一定和我们写的顺序是一致的，它们只保证最终结果一致。volatile 保证读/写volatile 属性时，其前面的代码必须已经执行完成，它后面的代码也不能排到前面来执行。</p>
<p><strong>不保证原子性：</strong>也即前面提到的，比如在做加法途中，这个k值改变了，是无法改变正在做的加法中的k值的。这也是volatile 修饰变量并不是线程安全的原因。</p>
</details>

<blockquote>
<p>如果还不太了解，可以<a href="https://glassx.gitee.io/2019/09/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC12%E7%AB%A0/">参考以前写的这篇读书笔记</a>、还可以<a href="https://blog.csdn.net/carson_ho/article/details/83780349" target="_blank" rel="noopener">参考这篇文章，讲得很透彻</a></p>
</blockquote>
<h2 id="16、什么是大接口？"><a href="#16、什么是大接口？" class="headerlink" title="16、什么是大接口？"></a>16、什么是大接口？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>大接口就是所看到的整个页面，都是由一个接口数据决定的。当时基于的背景有几个：      </p>
<ul>
<li>这个行业决定，如果有需求，可能会要求某个版本不让用户使用了。    </li>
<li>还是行业决定，页面要求能灵活变动，随时可能某个模块没有了，或者某个tab没有了。    </li>
<li>减少接口数量，减轻后台压力，我们知道，频繁的、少量数据的接口请求对后台不友好，可能握手、header 等就能占用很大一部分资源。           </li>
</ul>
<p>怎么做的：     </p>
<p>本地有若干指定的view映射，根据后台返回，可以动态添加这些view。一般view都是占满一行，左右两边的边距确定。</p>
</details>

<h2 id="17、怎么防止劫持？"><a href="#17、怎么防止劫持？" class="headerlink" title="17、怎么防止劫持？"></a>17、怎么防止劫持？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>背景：当时有用户反馈，我们的 webview 打开慢，并且有时候弹出广告，可我们自己并没有添加广告，因此初步认定可能是运营商劫持，事实上我们在百度上搜索一下运营商劫持，就有一大把的搜索结果，看来并非我们一家。在这个基础上，分析应该是通过<strong>dns 污染导致的</strong>。</p>
<p>所以解决方案就是不使用运营商的dns，而使用119(腾讯的 119.29.29.29) 和 114(114.114.114.114) 的dns，参考网上的方案，自己写了个实现。在获取到的ip 中，随机选中一个缓存起来，缓存有效时间为15分钟。</p>
<p>在 API 的http 请求中，拦截请求，查询是否缓存该host的ip，如果有，判断是否过期。如果没有缓存或者过期，则会通过上面步骤获取ip，并把host 换成ip直连。</p>
<p>针对webview的http 类型的get请求，在WebviewClient 的 shouldInterceptRequest 回调中(执行在子线程)，使用自定义构建的网络请求(根据WebResourceRequest 的 url 以及 headers 构建 okhttp 的 okHttpRequest，其中headers也加入okHttpRequest 的headers 中)。该请求会在可能的情况下，将url替换成ip直连，获取结果后，自行重新组装 WebResourceResponse 对象return。</p>
</details>

<h2 id="18、一般走查哪些代码？"><a href="#18、一般走查哪些代码？" class="headerlink" title="18、一般走查哪些代码？"></a>18、一般走查哪些代码？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>关键代码，比如容易出现死循环的重试机制、错误上报机制、安全检测机制    </p>
</details>

<h2 id="19、如何文档归档"><a href="#19、如何文档归档" class="headerlink" title="19、如何文档归档"></a>19、如何文档归档</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>使用wiki，wiki内容包括：</p>
<ul>
<li>后端接口以及参数说明    </li>
<li>前端支持的协议以及支持的格式     </li>
<li>关键逻辑的边界和参数，如自动登录尝试的次数，防止出现死循环；网络超时时长    </li>
</ul>
<p>其他部门做业务的时候只需要看wiki就行，不用找具体的技术人员查看客户端代码     </p>
</details>

<h2 id="20、聊聊这个内部sdk的设计？"><a href="#20、聊聊这个内部sdk的设计？" class="headerlink" title="20、聊聊这个内部sdk的设计？"></a>20、聊聊这个内部sdk的设计？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>以前没有做过sdk，貌似也没地方可以参考，还有时间也很紧急，所以在技术上直接采用500里面的技术，并没有什么新意，做完之后，有小需求做的同时慢慢重构，自己得出一些经验吧：</p>
<ul>
<li>控制调用权限。只暴露几个类给用户即可，其余的类不允许用户调用。         </li>
<li>确定回调方式。1、调用接口中需要传递 activity，业务中使用用户的activity 执行activityForResult 接受业务返回数据。  2、如果使用广播，则使用本地广播                     </li>
<li>防止资源名称和宿主app冲突，资源名称添加特定前缀           </li>
<li>传入的参数各种各样，需要注意判空、检验数据格式合法性等     </li>
<li>尽量不使用第三方的类库，目前sdk中使用第三方类库，接sdk的时候要求用户添加依赖      </li>
</ul>
</details> 

<h2 id="21、最有成就感的项目？最棘手的问题？"><a href="#21、最有成就感的项目？最棘手的问题？" class="headerlink" title="21、最有成就感的项目？最棘手的问题？"></a>21、最有成就感的项目？最棘手的问题？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>最有成就感的可能就是xx app吧，接触得比较多，虽然目前的流畅度还是一般般，但是做了比较多的努力：</p>
<ul>
<li>性能优化       </li>
<li>大接口试验      </li>
<li>在以前的基础上动过网络框架和图片框架      </li>
<li>在安全上也做了一些努力     </li>
</ul>
</details> 

<h2 id="22、引申-如何重新设计网络框架？"><a href="#22、引申-如何重新设计网络框架？" class="headerlink" title="22、引申-如何重新设计网络框架？"></a>22、引申-如何重新设计网络框架？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>   

<ul>
<li>调用方式改变，不需要传递2次的 responseClass    </li>
<li>采用kotlin 的线程调度(GlobalScope.launch()) 而不是rxjava 进行线程间的切换     </li>
</ul>
</details> 

<h2 id="23、引申-安全做了哪些努力"><a href="#23、引申-安全做了哪些努力" class="headerlink" title="23、引申-安全做了哪些努力"></a>23、引申-安全做了哪些努力</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>   

<ul>
<li>在native层做app签名校验  </li>
<li>广播统一改为本地广播  </li>
<li>LeakCanary防止内存泄漏  </li>
<li>SharedPreference加密  </li>
<li>allowBackUp = false  </li>
<li>某些key生成在native代码中做  </li>
<li>https证书本地验证。</li>
</ul>
</details> 

<h2 id="24、讲一讲你看过的第三方框架的源码？"><a href="#24、讲一讲你看过的第三方框架的源码？" class="headerlink" title="24、讲一讲你看过的第三方框架的源码？"></a>24、讲一讲你看过的第三方框架的源码？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary> 

<p>可以讲讲 LeakCanary 和 阿里的框架 alpha</p>
</details>

<h2 id="25、逛哪些论坛？"><a href="#25、逛哪些论坛？" class="headerlink" title="25、逛哪些论坛？"></a>25、逛哪些论坛？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>   

<p>有逛csdn，gank.io(不过gank.io有时候更新得比较慢)，apkbus，androidweekly.cn 啊 等等。</p>
</details> 

<h2 id="26、平时关注什么技术？"><a href="#26、平时关注什么技术？" class="headerlink" title="26、平时关注什么技术？"></a>26、平时关注什么技术？</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>   

<p>目前关注的就是 flutter 了</p>
</details> 

<h2 id="27、有什么想问我的"><a href="#27、有什么想问我的" class="headerlink" title="27、有什么想问我的"></a>27、有什么想问我的</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p><strong>如果是hr初面：</strong>       </p>
<blockquote>
<p>这个岗位是新开设的还是原岗位人离职了？<br>这个岗位可以为公司带来什么价值？<br>想了解以下公司的培训机制和学习机制     </p>
</blockquote>
<p><strong>如果是技术人员：</strong>      </p>
<blockquote>
<p>你觉得我能胜任这个职位吗(看这一关是否通过了)？<br>感觉不好，就问：你觉得我还有哪些不足？</p>
</blockquote>
<p><strong>终面的话：</strong>     </p>
<blockquote>
<p>如果顺利，问下部门、公司的发展啦<br>如果觉得基本上没戏了，就问下自己的缺陷在哪<br>如果模棱两可，问下一步流程是怎么样的    </p>
</blockquote>
</details>   

]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题目</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-算法-基础排序</title>
    <url>/2019/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>思路：冒泡排序基于交换排序思想。依次比较相邻的两个数，将小数放在前面，大数放在后面。</p>
<p>即第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。之后便是重复第一趟步骤，直至全部排序完成(或者说直到某一趟没有发生交换的时候)。每一趟完成后，最后一个数肯定是最大的那个数，所以一次for循环后，会有 len – 操作，即每趟都比上一趟少比较一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort1</span><span class="params">(<span class="keyword">int</span>[] ints)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = ints.length;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ints[i - <span class="number">1</span>] &gt; ints[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = ints[i];</span><br><span class="line">                ints[i] = ints[i-<span class="number">1</span>];</span><br><span class="line">                ints[i-<span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len -- ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序在数据有序的情况下，只需要一趟即可，时间复杂度是 O(n)，在最差的情况下，每趟都有比较，时间复杂度是 O(n^2) ，平均复杂度是 O(n^2)，适合数据量较小的情况,它是稳定的排序方法，</p>
</details><a id="more"></a>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>选择排序的基本思想：每次从待排序的数据元素中选出最小(大)的一个元素，放在序列的起始位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; a.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> index = i;<span class="comment">//当前趟最小的数所在index</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j &lt; a.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[index])&#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (index != i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[index];</span><br><span class="line">            a[index] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的时间复杂度是O(n^2)，因为它总是要循环那么多次，并且每次都是从待排序的数据中挑选最小的，因此它是不稳定的排序算法。</p>
</details>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>
插入排序的原理类似于打牌的时候抓牌，每次抓牌上来，都按照顺序将其插入到之前排好序的牌堆中。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doInsertSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">1</span>; index&lt;length; index++)&#123;<span class="comment">//外层向右的index，即作为比较对象的数据的index</span></span><br><span class="line">        <span class="keyword">int</span> temp = array[index];<span class="comment">//用作比较的数据</span></span><br><span class="line">        <span class="keyword">int</span> leftindex = index-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(leftindex&gt;=<span class="number">0</span> &amp;&amp; array[leftindex]&gt;temp)&#123;<span class="comment">//当比到最左边或者遇到比temp小的数据时，结束循环</span></span><br><span class="line">            array[leftindex+<span class="number">1</span>] = array[leftindex];</span><br><span class="line">            leftindex--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[leftindex+<span class="number">1</span>] = temp;<span class="comment">//把temp放到空位上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是O(n^2)，适用于数据量较少的情况，是稳定的排序。</p>
</details>

<h2 id="shell排序"><a href="#shell排序" class="headerlink" title="shell排序"></a>shell排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>
原理： 严格来说是基于插入排序的思想，shell排序有点不大好理解，后续再看看

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路：三层循环</span></span><br><span class="line"><span class="comment"> * 第一层循环：控制增量-增量随着程序的进行依次递减一半</span></span><br><span class="line"><span class="comment"> * 第二层循环：遍历数组</span></span><br><span class="line"><span class="comment"> * 第三层循环：比较元素，交换元素。</span></span><br><span class="line"><span class="comment"> * 这里需要注意的是：比较的两个元素和交换的两个元素是不同的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> div = data.length/<span class="number">2</span>; div&gt;<span class="number">0</span>; div/=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = div; j &lt; data.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = data[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=j; k&gt;=div &amp;&amp; temp&lt;data[k-div] ; k-=div) &#123;</span><br><span class="line">                data[k] = data[k-div];</span><br><span class="line">            &#125;</span><br><span class="line">            data[k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shell排序最差的时间复杂度是 O(n^2)，平均复杂度是 O(nlogn)，是不稳定的排序</p>
</details>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>快速排序的思想是<strong>分治思想</strong>。假设我们现在对“6 1 2 7 9 3 4 5 10 8”这10个数进行排序。首先在这个序列中随便找一个数作为基准数，为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边。得到一个一个以6为中心的序列，再以6为界限，将左右两边都看成数组，分别按照刚才的方法排序。上个图会比较直观：</p>
<p><img src="/assets/%E8%B6%A3%E5%91%B3/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" alt="快速排序"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp,t;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i=low;</span><br><span class="line">    j=high;</span><br><span class="line">    <span class="comment">//temp就是基准位</span></span><br><span class="line">    temp = arr[low];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">        <span class="comment">//先看右边，依次往左递减</span></span><br><span class="line">        <span class="keyword">while</span> (temp&lt;=arr[j]&amp;&amp;i&lt;j) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再看左边，依次往右递增</span></span><br><span class="line">        <span class="keyword">while</span> (temp&gt;=arr[i]&amp;&amp;i&lt;j) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果满足条件则交换</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;j) &#123;</span><br><span class="line">            t = arr[j];</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">            arr[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后将基准为与i和j相等位置的数字交换</span></span><br><span class="line">     arr[low] = arr[i];</span><br><span class="line">     arr[i] = temp;</span><br><span class="line">    <span class="comment">//递归调用左半数组</span></span><br><span class="line">    quickSort(arr, low, j-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//递归调用右半数组</span></span><br><span class="line">    quickSort(arr, j+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快排的平均时间复杂度是 O(nlogn) ，最坏情况下为 O(n^2)，这种交换方式导致它是不稳定的排序。</p>
</details>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>堆排序是一种<strong>选择排序</strong>。</p>
<p>堆排序时，先构建堆(假设大顶堆)，将数组转换成堆，数据在堆中是按层编号的，所以数组中一个编号为 i 的结点的子结点在 2i + 1 和 2i + 2 的位置。开始构建时，首先从最后一个非叶子结点开始(叶子结点不用调，叶子结点只是非叶子结点比较时被动移动)，最后一个非叶子节点的位置在 n/2-1。 </p>
<p>构建了大顶堆后，堆顶元素与末尾元素交换，将大元素“沉”到末尾，将除尾部以外的元素再构建大顶堆，如此循环，每次找到最大的下沉的后面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arrLen = arr.length;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//建立大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLen/<span class="number">2</span> -<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">//从第一个非叶子结点(在 arrLen/2 -1 处)从下至上，从右至左调整结构</span></span><br><span class="line">        adjustHeap(arr,i,arrLen);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = arrLen -<span class="number">1</span>;j &gt;= <span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">        temp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重新对堆进行调整</span></span><br><span class="line">        adjustHeap(arr,<span class="number">0</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先取出当前元素i</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[start];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>*start + <span class="number">1</span>;k &lt; end;k = <span class="number">2</span>*k + <span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点(2i+1处)开始</span></span><br><span class="line">        <span class="keyword">if</span> (k + <span class="number">1</span> &lt; end &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">            k ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">        <span class="keyword">if</span> (arr[k] &gt; temp) &#123;</span><br><span class="line">            arr[start] = arr[k];</span><br><span class="line">            start = k;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    arr[start] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的最坏，最好以及平均复杂度都是 O(nlogn)，它是不稳定排序。</p>
<p>以上内容参考自<a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">他人的博客</a></p>
</details>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>归并排序是基于 分治法 实现的。目前还看不大懂，后续再理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//非递归算法实现二路归并排序，length代表数组长度，即数组最大下标是 legth - 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> List[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> low;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> high;</span><br><span class="line">    <span class="comment">//size 是标记当前各个归并序列的high-low，从1，2，4，8，……，2*size</span></span><br><span class="line">    <span class="keyword">while</span>(size &lt;= length - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//从第一个元素开始扫描，low代表第一个分割的序列的第一个元素</span></span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前的归并算法结束的条件</span></span><br><span class="line">        <span class="keyword">while</span>(low + size &lt;= length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//mid代表第一个分割的序列的最后一个元素</span></span><br><span class="line">            mid = low + size - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//high 代表第二个分割的序列的最后一个元素</span></span><br><span class="line">            high = mid + size;</span><br><span class="line">            <span class="comment">//判断一下：如果第二个序列个数不足size个</span></span><br><span class="line">            <span class="keyword">if</span>(high &gt; length - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//调整 high 为最后一个元素的下标即可</span></span><br><span class="line">                high = length - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用归并函数，进行分割的序列的分段排序</span></span><br><span class="line">            merge(List, low, mid, high);</span><br><span class="line">            <span class="comment">//打印出每次归并的区间</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"low:"</span> &lt;&lt; low &lt;&lt; <span class="string">" mid:"</span> &lt;&lt; mid &lt;&lt; <span class="string">" high:"</span> &lt;&lt; high &lt;&lt; endl;</span><br><span class="line">            <span class="comment">//下一次归并时第一序列的第一个元素位置</span></span><br><span class="line">            low = high + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="comment">// end of while</span></span><br><span class="line">        <span class="comment">//范围扩大一倍，二路归并的过程</span></span><br><span class="line">        size *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>归并的思想主要用于外部排序：<br>外部排序可分两步<br>①待排序记录分批读入内存，用某种方法在内存排序，组成有序的子文件，再按某种策略存入外存。<br>②子文件多路归并，成为较长有序子文件，再记入外存，如此反复，直到整个待排序文件有序。</p>
</blockquote>
</details>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述排序，稳定的排序有：冒泡、插入、合并 ，不稳定排序：选择、shell、快排、堆排</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-算法-二叉树遍历</title>
    <url>/2019/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p><img src="/assets/%E8%B6%A3%E5%91%B3/%E7%AE%97%E6%B3%95/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="先序遍历"></p><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>递归方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(BTreeNode treeNode)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(treeNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//显示节点数据</span></span><br><span class="line">        showNodeValue(treeNode);</span><br><span class="line">        <span class="comment">//先序遍历左子树</span></span><br><span class="line">        pre(treeNode.left);</span><br><span class="line">        <span class="comment">//先序遍历右子树</span></span><br><span class="line">        pre(treeNode.right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归，手算的思想，先变访问边找，找到最左下方的，然后向上再向访问右边的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePreOrder</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            visit(p);</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = stack.pop();</span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的思想，按层次倒着进栈，利用后进先出解决顺序问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePreOrder_2</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    stack.push(p);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        p = stack.pop();</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) stack.push(p.right);</span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) stack.push(p.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details><a id="more"></a>


<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p><img src="/assets/%E8%B6%A3%E5%91%B3/%E7%AE%97%E6%B3%95/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="中序遍历"></p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<p>递归方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">middle</span><span class="params">(BTreeNode treeNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(treeNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//中序遍历左子树</span></span><br><span class="line">        middle(treeNode.left);</span><br><span class="line">        <span class="comment">//显示节点数据</span></span><br><span class="line">        showNodeValue(treeNode);</span><br><span class="line">        <span class="comment">//中序遍历右子树</span></span><br><span class="line">        middle(treeNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeInOrder</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = stack.pop();</span><br><span class="line">        visit(p);</span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><img src="/assets/%E8%B6%A3%E5%91%B3/%E7%AE%97%E6%B3%95/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="后序遍历"></p>
<details>
<summary><font size="2" color="#888888">点击看答案</font></summary>
递归方法：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">behind</span><span class="params">(BTreeNode treeNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(treeNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//后序遍历左子树</span></span><br><span class="line">        behind(treeNode.left);</span><br><span class="line">        <span class="comment">//后序遍历右子树</span></span><br><span class="line">        behind(treeNode.right);</span><br><span class="line">        <span class="comment">//显示节点数据</span></span><br><span class="line">        showNodeValue(treeNode);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双栈法，易于理解</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePostOrder_3</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; result = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            result.push(p);</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty()) p = stack.pop().left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!result.empty()) &#123;</span><br><span class="line">        p = result.pop();</span><br><span class="line">        visit(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><details>
<summary><font size="2" color="#888888">点击看答案</font></summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeLevelOrder</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.offer(p);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        p = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) queue.offer(p.left);</span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) queue.offer(p.right);</span><br><span class="line">        visit(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p>以上内容可以<a href="https://www.cnblogs.com/songwenjie/p/8955856.html" target="_blank" rel="noopener">参考这篇博客</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-算法-经典问题解决</title>
    <url>/2019/03/02/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h2 id="扑克洗牌算法"><a href="#扑克洗牌算法" class="headerlink" title="扑克洗牌算法"></a>扑克洗牌算法</h2><p>打乱一个已有顺序有多种实现方式，但是要高效地实现，还需要斟酌，以下是目前能想到的最有的解决方案：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成一副牌</span></span><br><span class="line">Card[<span class="number">52</span>] oneCard = generateOneCard;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序与 随机位置交换</span></span><br><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oneCard.size(); i ++)&#123;</span><br><span class="line">    <span class="keyword">int</span> j = r.nextInt(<span class="number">52</span>);</span><br><span class="line">    Card tempCard = oneCard[i];</span><br><span class="line">    oneCard[i] = onCard[j];</span><br><span class="line">    onCard[j] = tempCard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h2 id="判断链表中是否有环"><a href="#判断链表中是否有环" class="headerlink" title="判断链表中是否有环"></a>判断链表中是否有环</h2><p><strong>快慢指针法：</strong>创建两个指针1和2同时指向这个链表的头节点，然后两个指针分别向后移动，其中指针1每次向后移动一个节点，指针2每次向后移动两个节点，每移动一次就比较两个指针指向的节点是否相同，如果相同说明出链表有环；如果不同，则继续循环，直到有环结束或者到达尾部结束。</p>
<blockquote>
<p>原理：两个人在环形跑道上同一位置开始跑，一人速度快，一人速度慢，如此持续跑一段时间，速度快的那个肯定会从速度慢的身后再次追上以及超越，这中间必然有个交汇点。如果是跑直线的话，到终点就结束了，不会再碰面。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否有环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isLoopList</span><span class="params">(ListNode&lt;T&gt; head)</span></span>&#123;</span><br><span class="line">    ListNode&lt;T&gt; slowPointer, fastPointer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用快慢指针，慢指针每次向前一步，快指针每次两步</span></span><br><span class="line">    slowPointer = fastPointer = head;</span><br><span class="line">    <span class="keyword">while</span>(fastPointer != <span class="keyword">null</span> &amp;&amp; fastPointer.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        slowPointer = slowPointer.next;</span><br><span class="line">        fastPointer = fastPointer.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两指针相遇则有环</span></span><br><span class="line">        <span class="keyword">if</span>(slowPointer == fastPointer)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引申：如何判断环的入口"><a href="#引申：如何判断环的入口" class="headerlink" title="引申：如何判断环的入口"></a>引申：如何判断环的入口</h2><p>我们假定链表头到环入口的距离是len，环入口到slow和fast交汇点的距离为x，环的长度为R。slow和fast第一次交汇时，设slow走的长度为：d = len + x，而fast走的长度为：2d = len + nR + x，(n &gt;= 1)，从而我们可以得知：2len + 2x = len + nR + x，即len = nR - x，(n &gt;= 1)。所以，要找出环入口，也要两个指针，一个指针A指向相遇时候的节点，一个指针B指向链表头，两个指针每次都走一步，A指针在遍历过程中可能多次(n &gt;= 1)经过环入口节点，但当B指针第一次达到入口节点时，A指针此时必然也指向入口节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否有环，有环就返回入口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ListNode&lt;T&gt; <span class="title">findEntranceInLoopList</span><span class="params">(ListNode&lt;T&gt; head)</span></span>&#123;</span><br><span class="line">    ListNode&lt;T&gt; slowPointer, fastPointer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用快慢指针，慢指针每次向前一步，快指针每次两步</span></span><br><span class="line">    <span class="keyword">boolean</span> isLoop = <span class="keyword">false</span>;</span><br><span class="line">    slowPointer = fastPointer = head;</span><br><span class="line">    <span class="keyword">while</span>(fastPointer != <span class="keyword">null</span> &amp;&amp; fastPointer.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        slowPointer = slowPointer.next;</span><br><span class="line">        fastPointer = fastPointer.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两指针相遇则有环</span></span><br><span class="line">        <span class="keyword">if</span>(slowPointer == fastPointer)&#123;</span><br><span class="line">            isLoop = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个指针从链表头开始，一个从相遇点开始，每次一步，再次相遇的点即是入口节点</span></span><br><span class="line">    <span class="keyword">if</span>(isLoop)&#123;</span><br><span class="line">        slowPointer = head;</span><br><span class="line">        <span class="keyword">while</span>(fastPointer != <span class="keyword">null</span> &amp;&amp; fastPointer.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//两指针相遇的点即是入口节点</span></span><br><span class="line">            <span class="keyword">if</span>(slowPointer == fastPointer)&#123;</span><br><span class="line">                <span class="keyword">return</span> slowPointer;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            slowPointer = slowPointer.next;</span><br><span class="line">            fastPointer = fastPointer.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="再引申，两个单链表是否相交"><a href="#再引申，两个单链表是否相交" class="headerlink" title="再引申，两个单链表是否相交"></a>再引申，两个单链表是否相交</h2><p>两个<strong>没有环的链表</strong>在某一节点相交，那么在这个节点之后的所有结点都是两个链表所共有的。如果它们相交，则最后一个结点一定是共有的，因此问题转化为：两个链表最后一个结点是否相同（时间复杂度为O(len1+len2)）。要找出相交的第一个结点，可以首先获得两个链表的长度，然后获得两个链表长度差值 K，之后长的链表指向第K个结点，短的链表从头开始，每次向后移动一个结点，再比较当前结点是否相等，第一次相等的那个结点点就是相交节点。</p>
<blockquote>
<p>代码略</p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-算法-类似行测</title>
    <url>/2019/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E7%B1%BB%E4%BC%BC%E8%A1%8C%E6%B5%8B/</url>
    <content><![CDATA[<p><strong>1、给100盏灯编号 1~100，开始时所有灯都是关着的<br>第1次：把所有编号是1的倍数的灯的开关状态改变一次；<br>第2次：把所有编号是2的倍数的灯的开关状态改变一次；<br>第3次，把所有编号是3的倍数的灯的开关状态改变一次；<br>…<br>第100次，把所有编号是100的倍数的灯的开关状态改变一次；<br>问：最后开着的灯的编号是哪些？</strong></p><a id="more"></a>
<blockquote>
<p>分析：最开始灯是灭的，因此只有经过<strong>奇数</strong>次开关状态改变，灯才会是亮的。从题意可知一个数字有多少约数就会状态改变多少次，因此这道题可以转换为：<strong>1~100数字中约数个数是奇数的有哪些</strong>。并且我们知道约数是成对出现的，如8的约数：（1，8）、（2，4），因此如果要出现约数的个数是奇数个，除非它是个平方数，如36的约数：（1，36）、（2，18）、（3，12）、（4，9）、（6），因此，这题又可以转换为<strong>1~100数字中的平方数有哪些</strong>，这操作。。。。666吧，这就是分析问题的乐趣吧</p>
</blockquote>
<p><strong>2、烧一根不均匀的绳子，从头烧到尾总共需要1小时，现在有若干条这样的绳子，问如何用烧绳子的方法来计时1小时15分钟呢</strong></p>
<blockquote>
<p>从题目知道，绳子不均匀，不能根据燃烧半根来计量半小时。但是还可以推断，从两头烧，只要半小时。因此可以使用3根绳子来计时：1）第1根绳子点燃两端，第2根绳子点燃一端，第三根绳子先不点燃； 2）第1根绳子烧完计时30分钟，接着第2根绳子另一端也点燃 3）第2根绳子烧完计时15分钟，此时已经计时45分钟了，剩下的半小时只需要将第3条绳子两端点燃就能计算出。</p>
</blockquote>
<p><strong>3、有12个外观一样的小球，但有一个与其他小球重量略微不同，用手感觉不出来，用一个天平，能称3次就能找到那个小球吗</strong></p>
<blockquote>
<p>把小球编号 1<del>12，然后分为3组（想想为什么是3组）：1</del>4分为A组，5<del>8分为B组，9</del>12分为C组。首先A组和B组称量比较：<br>1、天平平衡。则目标小球在C组。将C分为两组：9、10、11分为一组C1，12分为一组C2，再从B中随意拿出3个球分组为B1，C1和B1比较：<br>    1）若平衡，则12号球就是目标球。<br>    2）若不平衡，则目标球在C1内，并且根据天平倾斜，可以判断目标球比普通球重还是轻（若是天平显示B1重，则目标球比较轻；反之目标球比较重），此时随意取 C1 中的2个球放在天平上即可知道结果（如果平衡，则目标球是另一个，如果不平衡，根据轻重可知目标球）。<br>2、天平不平衡。则目标球在A或者B中。<br>    1）若A &gt; B,取（1，2，3，5）为一组X,(4,9,10,11)为一组Y，（6，7，8）为一组Z，比较X和Y，若X&gt;Y，可知不同小球在1，2，3中，且目标球重于普通球，此时再将编号 1，2，3 任取2个放上天平即可知道目标球。若X&lt;Y,则说明4号是目标球；若X=Y，则目标球在Z中（6，7，8），并且目标球轻于普通球，此时只需要将编号 其中任意两个球放上天平即可找出目标球。<br>    2）若 A &lt; B，同样按照上述分为X、Y、Z三组，同理，若X&lt;Y，则目标球在1，2，3中，且目标球轻于普通球，此时再将编号 1，2，3 任取2个放上天平即可知道目标球；若X&gt;Y,说明4号为目标球，若X=Y，则目标球在Z中（6，7，8），并且目标球重于普通球，此时再将编号 6，7，8 任取2个放上天平即可知道目标球。</p>
</blockquote>
<p><strong>3、一笔画出经过9个点的4条直线</strong></p>
<blockquote>
<p>主要是要突破点，不要局限于点上，不说了，直接上图：<br>9点4线</p>
</blockquote>
<p><img src="/assets/%E8%B6%A3%E5%91%B3/9point-4line.png" alt="9点4线"></p>
<p><strong>4、有1块钱1瓶的契税，喝完后2个空瓶换一瓶汽水，问有20块钱，可以喝几瓶汽水？</strong></p>
<blockquote>
<p>总共40瓶（不要浪费最后那个空瓶，找老板借1个，凑2瓶子再喝一瓶，最后这空瓶还给老板。。。）</p>
</blockquote>
<p><strong>5、时针分针秒针重合的次数</strong></p>
<blockquote>
<p>只有2次，一次是 00:00:00 一次是 12：00：00</p>
</blockquote>
<p><strong>假设排列100个球，两个人轮流一拿球装入口袋，能拿到第100个球为胜，条件是每次拿球至少拿1个，最多拿5个，加入你是最先拿球的人，你该拿几个，以后怎么保证拿到最后一个球？</strong></p>
<blockquote>
<p>怎样保证拿到最后一个球呢？最简单的方法是最后剩下6个，并且轮到对方来拿，这样无论对方拿几个，都能保证自己拿到最后一个。<br>（1）首先，要控制每一轮拿出的个数，但是对方拿的个数是不受控制的，假设对方拿n个，自己就拿6-n个（为什么是控制总数是6个，是因为对手最多拿5个，自己最少能拿1个，和值就是6，自己不能把和值控制得更低；而对手至少拿1个，自己最多拿5个，同样自己不能把和值控制得更高。因此只有6才是一个可控的值）。<br>（2）其次，假设第一次拿x个球，以后每次自己和对方拿的和是6，最多可以拿到15轮（除去第一轮的x个，最后留这肯定少于10个了），还剩 10-x个，为了达到之前定的目标最后留6个，所以x应该是4.<br>（3）总结而言就是第一次拿4个，以后每次对方拿了n个后，自己拿 6-n 个。</p>
</blockquote>
<h3 id="如何确定用户异地登陆。"><a href="#如何确定用户异地登陆。" class="headerlink" title="如何确定用户异地登陆。"></a>如何确定用户异地登陆。</h3>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 事件分发机制</title>
    <url>/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Android-事件分发机制"><a href="#Android-事件分发机制" class="headerlink" title="Android 事件分发机制"></a>Android 事件分发机制</h1><p>当我们点击屏幕时，事件最先传递给Activity ，在 Activity 的dispatchTouchEvent() 回调中，默认首先调用 getWindow().superDispatchTouchEvent(ev) 将事件交给window 处理，如果window 返回true之后，则直接return true。在 getWindow().superDispatchTouchEvent(ev) 调用的时候，我们能发现事件一步步传递：</p><a id="more"></a>
<p>1、PhoneWindow.superDispatchTouchEvent<br>2、DecorView.dispatchTouchEvent()<br>3、ViewGroup. dispatchTouchEvent()     </p>
<p>之后，就进入了ViewGroup的事件分发流程。用一张图(这张图转载自<a href="https://www.jianshu.com/p/38015afcdb58" target="_blank" rel="noopener">Carson_Ho</a>)来描绘下整体的过程：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/Activity%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B.webp" alt="Activity事件分发"></p>
<p>接下来主要关注的是 Android 中 ViewGroup 事件分发机制。它总体来说可以用几张图说明白，相比在代码中打印Log，这种方式更容易理解和记住。</p>
<h2 id="针对-ACTION-DOWN-事件"><a href="#针对-ACTION-DOWN-事件" class="headerlink" title="针对 ACTION_DOWN 事件"></a>针对 ACTION_DOWN 事件</h2><p>只针对 ACTION_DOWN 事件时，事件的完整流向是一个U形图，如下图所示：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/down-all.png" alt="只考虑ACTION_DOWN 事件时事件流向图"></p>
<p>如果没有中断事件，可能看起来更直观一些，Activity、ViewGroup、View的层次更加清晰：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/down-u.png" alt="不中断事件"></p>
<h2 id="针对-ACTION-MOVE-和-ACTION-UP"><a href="#针对-ACTION-MOVE-和-ACTION-UP" class="headerlink" title="针对 ACTION_MOVE 和 ACTION_UP"></a>针对 ACTION_MOVE 和 ACTION_UP</h2><p>上面讲解的都是针对ACTION_DOWN的事件传递，ACTION_MOVE和ACTION_UP在传递的过程中并不是和ACTION_DOWN 一样，你在执行ACTION_DOWN的时候返回了false，后面一系列其它的action就不会再得到执行了。简单的说，就是当dispatchTouchEvent在进行事件分发的时候，只有前一个事件（如ACTION_DOWN）返回true，才会收到ACTION_MOVE和ACTION_UP的事件。</p>
<h3 id="ViewGroup1-的dispatchTouchEvent-中返回true消费事件"><a href="#ViewGroup1-的dispatchTouchEvent-中返回true消费事件" class="headerlink" title="ViewGroup1 的dispatchTouchEvent 中返回true消费事件"></a>ViewGroup1 的dispatchTouchEvent 中返回true消费事件</h3><p>红色的箭头代表ACTION_DOWN 事件的流向，蓝色的箭头代表ACTION_MOVE 和 ACTION_UP 事件的流向：</p>
<p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-1.png" alt="viewgroup1消费"></p>
<h3 id="ViewGroup2-的dispatchTouchEvent-中返回true消费事件"><a href="#ViewGroup2-的dispatchTouchEvent-中返回true消费事件" class="headerlink" title="ViewGroup2 的dispatchTouchEvent 中返回true消费事件"></a>ViewGroup2 的dispatchTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-2.png" alt="viewgroup2消费"></p>
<blockquote>
<p>在View 的dispatchTouchEvent 返回true消费事件,就不画图了，效果和在ViewGroup2 的dispatchTouchEvent return true的差不多，同样的收到ACTION_DOWN 的dispatchTouchEvent函数都能收到 ACTION_MOVE和ACTION_UP。</p>
</blockquote>
<h3 id="在View-的onTouchEvent-中返回true消费事件"><a href="#在View-的onTouchEvent-中返回true消费事件" class="headerlink" title="在View 的onTouchEvent 中返回true消费事件"></a>在View 的onTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-3.png" alt="在View 的onTouchEvent 中返回true消费事件"></p>
<h3 id="在ViewGroup-2-的onTouchEvent-中返回true消费事件"><a href="#在ViewGroup-2-的onTouchEvent-中返回true消费事件" class="headerlink" title="在ViewGroup 2 的onTouchEvent 中返回true消费事件"></a>在ViewGroup 2 的onTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-4.png" alt="在ViewGroup 2 的onTouchEvent 中返回true消费事件"></p>
<h3 id="在ViewGroup-1-的onTouchEvent-中返回true消费事件"><a href="#在ViewGroup-1-的onTouchEvent-中返回true消费事件" class="headerlink" title="在ViewGroup 1 的onTouchEvent 中返回true消费事件"></a>在ViewGroup 1 的onTouchEvent 中返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-5.png" alt="在ViewGroup 1 的onTouchEvent 返回true消费这次事件"></p>
<h3 id="在View的dispatchTouchEvent-中返回false并且ViewGroup-1-的onTouchEvent-返回true消费事件"><a href="#在View的dispatchTouchEvent-中返回false并且ViewGroup-1-的onTouchEvent-返回true消费事件" class="headerlink" title="在View的dispatchTouchEvent 中返回false并且ViewGroup 1 的onTouchEvent 返回true消费事件"></a>在View的dispatchTouchEvent 中返回false并且ViewGroup 1 的onTouchEvent 返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-6.png" alt="在View的dispatchTouchEvent 返回false并且Activity 的onTouchEvent 返回true消费这次事件"></p>
<h3 id="在View的dispatchTouchEvent-中返回false并且Activity-的onTouchEvent-返回true消费事件"><a href="#在View的dispatchTouchEvent-中返回false并且Activity-的onTouchEvent-返回true消费事件" class="headerlink" title="在View的dispatchTouchEvent 中返回false并且Activity 的onTouchEvent 返回true消费事件"></a>在View的dispatchTouchEvent 中返回false并且Activity 的onTouchEvent 返回true消费事件</h3><p><img src="/assets/%E4%B8%93%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/move-up-7.png" alt="在View的dispatchTouchEvent 返回false并且Activity 的onTouchEvent 返回true消费这次事件"></p>
<p>经过这么多图能得出以下规律：</p>
<blockquote>
<p>ACTION_DOWN事件在哪个控件消费了（return true）， 那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。</p>
</blockquote>
<p>以上文章参考自 <a href="https://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="noopener">Kelin</a> ,这里图片形式贴出来仅仅只是个人做的笔记，方便记忆。</p>
]]></content>
      <categories>
        <category>专题</category>
      </categories>
      <tags>
        <tag>Android机制</tag>
      </tags>
  </entry>
  <entry>
    <title>黑苹果折腾记</title>
    <url>/2019/02/16/%E9%BB%91%E8%8B%B9%E6%9E%9C%E6%8A%98%E8%85%BE%E8%AE%B0/</url>
    <content><![CDATA[<p>过年在家没啥事干，折腾了下黑苹果，安装上了 OSX 10.14.3，整个过程还算顺利，最终除了睡眠和声卡之外，其他貌似ok，目前用来开发（Android studio 以及 XCode）没啥问题。此次记录主要是为了在以后还有闲心折腾黑苹果的时候，能拿出来参考，不至于从头开始爬帖。</p><p>首先，以一个过来人的身份告诉你，搞黑苹果如果不上 <a href="https://www.tonymacx86.com" target="_blank" rel="noopener">www.tonymacx86.com</a> 网站的话，等于白折腾，这上面有最简便的最新的折腾黑苹果的方法，在国内远景论坛、黑苹果社区等地方看到的清一色古老的安装方式，甚至还有变色龙安装法。不要害怕 English，对于搞黑苹果而言，只需要很简单的英语水平。我这次安装10.14.3参考的就是<a href="https://www.tonymacx86.com/threads/unibeast-install-macos-mojave-on-any-supported-intel-based-pc.259381/" target="_blank" rel="noopener">这个帖子</a>，只要一步步来，基本上是没什么问题的。</p><a id="more"></a>

<p>这个帖子主要条理清晰地通过5步，即完成了黑苹果的安装：<br>Step 1: Download macOS Mojave（第一步：下载系统）<br>Step 2: Create a Bootable USB with UniBeast（第二步：通过 UniBeast 制作 U盘启动盘）<br>Step 3: Recommended BIOS Settings（第三步：设置 BIOS ）<br>Step 4: Install macOS Mojave(第四步：安装系统)<br>Step 5: Post Installation with MultiBeast（第五步：二次安装）</p>
<p>在开始之前，首先申请 tonymacx86.com 的账号，然后 在从那里下载最新的 UniBeast 和 MultiBeast 工具，之后准备一个 32GB 的U盘吧，教程上面说 16G 以上就够了，但实际上是不够的。其中，UniBeast 的作用是 创建一个可以正常启动10.14.3 的 U盘启动盘。</p>
<h2 id="第一步-下载系统"><a href="#第一步-下载系统" class="headerlink" title="第一步 下载系统"></a>第一步 下载系统</h2><p>为了全新安装，首先可以从其他苹果系统里面下载系统，在苹果系统中：</p>
<blockquote>
<p>打开 App Store -&gt; 下载macos Mojave 更新，下载完成后，在 Applications(应用)里面能够找到它。</p>
</blockquote>
<h2 id="第二步-用-UniBeast-创建启动U盘"><a href="#第二步-用-UniBeast-创建启动U盘" class="headerlink" title="第二步 用 UniBeast 创建启动U盘"></a>第二步 用 UniBeast 创建启动U盘</h2><p>在第二步之前，首先备份好U盘的东西，因为制作启动盘会删除U盘中所有内容。</p>
<p>把U盘插到电脑上，打开：Application（应用）-&gt;Utilities（工具）-&gt; Disk Utility（磁盘工具）,从左边选中你的那个U盘，在Mojava或者更高版本中，可能你首先要设置 View(视图)-&gt;Show All Devices(显示所有设备)，才能看到你的U盘。之后执行</p>
<p>1、 点击 Erase（抹掉）按钮<br>2、填写名称，目前先命名为 USB<br>3、在Format（格式）的地方选择 Mac os Extended(Journaled)<br>4、最后，点击 Erase（抹掉） 按钮正式抹掉</p>
<p>接下来，安装你下载的 UniBeast （这里貌似要求语言是English，否则还装不上，如果有这个要求，改下系统语言就行了），只要一直continue 下去就行，之后同意协议，最后选择安装的 Destination（目的磁盘）的时候，选择刚才抹掉的 USB盘 即可；在 select os Installation （选择安装系统）界面时，选择 Mojave 就行，之后在 Bootloader Options 界面选择 UEFI Boot Mode（根据需要有可能要选择 Legacy Boot Mode）。最后 Graphics Configuration 是可选的，可以根据你的显卡来对应设置。最后确认你的安装选项，输入密码，然后 Install。这时候大概要等待个10分钟，系统会写完。</p>
<p>系统完全写入U盘之后，把下载的 MultiBeast 软件拖到 U 盘，因为安装好之后需要它。</p>
<h2 id="第三步-设置BIOS"><a href="#第三步-设置BIOS" class="headerlink" title="第三步 设置BIOS"></a>第三步 设置BIOS</h2><p>这里只针对UEFI 方式的BIOS 了（其他方式请参考原文了）。进入到 BIOS 设置中，如果CPU支持 VT-d，将其设置为 disable，CFG-Lock、Secure Boot Mode 、IO Serial Port 也 disable，设置 XHCI 为 Enable，设置 OS 为 Other OS。</p>
<h2 id="第四步-安装-macOS-Mojave"><a href="#第四步-安装-macOS-Mojave" class="headerlink" title="第四步 安装 macOS Mojave"></a>第四步 安装 macOS Mojave</h2><p>将U盘插在电脑的USB2.0口上，这点特别要注意，不然第二次安装的时候会提示找不到resource，我就在这里折腾了两回才知道。开机，选择从你的 USB 盘启动（不同的电脑主板不一样，网上搜下即可）。<br>在clover界面，通过键盘上的左右箭头（键盘右下角的上下左右箭头）选择 Boot OS X Install from macOS Mojave</p>
<p>在安装界面，首先选择顶部菜单栏的 Utilities（工具），再打开 Disk Utility（磁盘工具），在左边选中你想要安装系统的分区，之后像之前抹掉U盘那样抹掉这个分区，名字命名为 Mojave（之后你可以改这个名字），之后关闭Disk Utility（磁盘工具），即可继续安装。</p>
<p>安装的时候会提示安装到哪个盘，选择刚才抹掉的 Mojave 盘，之后会继续安装，待安装完成后会自动重启。</p>
<h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>在重启的时候要注意再次选择从U盘启动，之后在clover界面选择Mojave，之后就会自动安装，引导设置，完成。之后的事情就是安装驱动了，去论坛找各种kext即可，声卡可能就麻烦些，可能需要dsdt，这里就不细说。</p>
<h2 id="问题集锦"><a href="#问题集锦" class="headerlink" title="问题集锦"></a>问题集锦</h2><h3 id="休眠导致键盘不可用"><a href="#休眠导致键盘不可用" class="headerlink" title="休眠导致键盘不可用"></a>休眠导致键盘不可用</h3><p>如果是笔记本并且安装的是双系统（win + mac os），那么如果驱动对休眠的处理不好的话，在mac osx下发生休眠可能会导致系统重启，可能会重启进入windows系统，此时，你的键盘应该是不可用的。解决方案包括以下几个步骤：</p>
<ol>
<li>启动windows ，在登录界面使用 “轻松使用-屏幕键盘” 的方式输入密码。    </li>
<li>在windows 下使用 easyUefi 软件将 黑苹果的 efi 启动序列列为第一个，这样我们开机就会启动 clover。    </li>
<li>重启系统，进入clover，此时键盘应该是不可以使用的，左右光标也是没作用的。如果能够看到你要启动的分区，则用鼠标点击直接启动，进入mac os 后，正常关闭，键盘就能正常使用了。    </li>
<li>如果未能看到需要启动的分区，此时按字母 A 键，就会进入clover 的 “关于” 页面（这个我只在我电脑上试过，我在尝试按 A 或者 D 的时候发现的，对其他电脑的未做验证），此时，你的电脑键盘应该就可以使用了。这时候就可以退出“关于”页，之后进入黑苹果。     </li>
<li>以上操作的主要目的是要正常关闭mac os ，这样键盘才能使用（在 mac os 或者 windows 下）。</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章——理解 RemoteViews</title>
    <url>/2018/12/10/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC5%E7%AB%A0/</url>
    <content><![CDATA[<p>从字面可以看出这应该是一种远程view，与远程service概念一样，RemoteViews表示的是一种view结构，这种view能够在其他进程显示。由于需要跨进程显示，RemoteViews结构提供了一组基础功能用于跨进程更新View。RemoteViews在Android中有2种应用场景：<strong>Notification</strong>以及<strong>桌面小部件</strong>。</p><a id="more"></a>
<h3 id="RemoteViews的应用"><a href="#RemoteViews的应用" class="headerlink" title="RemoteViews的应用"></a>RemoteViews的应用</h3><p>平时的开发过程中，Notifications主要通过NotificationManager的notify方法实现的，它除了默认效果外，还可以另外定义布局。使用RemoteViews实现通知栏时无法像Activity里面一样直接更新View，这是因为RemoteView界面运行在其他进程中，确切来说是系统的SystemServer进程。使用系统默认的样式弹出一个通知是很简单的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Notification notification = newNotification();</span><br><span class="line">notification.icon = R.drawable.icon;</span><br><span class="line">notification.tickerText = <span class="string">"hello world"</span>;</span><br><span class="line">notification.when = System.currentTimeMillis();</span><br><span class="line">notification.flags = Notification.FLAG_AUTO_CANCEL;</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,DemoActivity_1.class);</span><br><span class="line">PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,intent,PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用普通样式展示一个通知</span></span><br><span class="line">notification.setLatestEventInfo(<span class="keyword">this</span>,<span class="string">"chapter_5"</span>,<span class="string">"this is notification"</span>,pendingIntent);</span><br><span class="line">NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">manager.notify(<span class="number">1</span>,notification);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用RemoteViews的方式展示第一个通知</span></span><br><span class="line">RemoteViews remoteViews = <span class="keyword">new</span> RemoteViews(getPackageName(),R.layout.layout_notification);</span><br><span class="line">remoteViews.setTextViewText(R.id.msg,<span class="string">"chapter_5"</span>);</span><br><span class="line">remoteViews.setImageViewResource(R.id.icon,R.drawable.icon1);</span><br><span class="line">PendingIntent openActivity2PendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,<span class="keyword">new</span> Intent(<span class="keyword">this</span>,DemoActivity_2.class),PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">remoteViews.setOnclickPendingIntent(R.id.open_activity2,openActivity2PendingIntent);</span><br><span class="line">notification.contentView = remoteViews;</span><br><span class="line">notification.contentIntent = pendingIntent;</span><br><span class="line">NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">manager.notify(<span class="number">2</span>,notification);</span><br></pre></td></tr></table></figure>

<p>以上代码展示只要提供当前应用的包名以及布局文件的id即可创建一个RemoteViews对象，而更新RemoteViews，由于无法直接访问里面的view，因而只能通过RemoteViews提供的一系列方法来更新，比如设置文本，需要采用 remoteViews.setTextViewText(R.id.msg,”chapter_5”) ，而更新图片则采用 remoteViews.setImageViewResource(R.id.icon,R.drawable.icon1)，如果要给一个控件添加click事件，则要使用PendingIntent并且通过setOnclickPendingIntent。关于PendingIntent，它表示一种待定的Intent，这个Intent中所包含的意图必须由用户来出发。</p>
<p><strong>RemoteViews在桌面小部件上的应用、PendingIntent概述、RemoteViews的内部机制等内容 待后续有集中的时间再添加</strong></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title>第9章-单元测试</title>
    <url>/2018/10/17/%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6-%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
    <content><![CDATA[<p>照例，如果自学不需要看我这个博客的话，资料如下：<br><a href="https://developer.android.google.cn/studio/test/?hl=zh-cn" target="_blank" rel="noopener">官网关于Android Test的介绍的地址</a><br><a href="https://github.com/googlesamples/android-testing" target="_blank" rel="noopener">Android官方关于测试的例子</a> ，需要的自取</p><p>单元测试、集成测试、黑盒测试、白盒测试等，只有单元测试是我们开发人员需要自己完成的，其余都是由测试人员完成的。单元测试本质上也是代码，是验证代码正确性的代码。</p><h2 id="为什么要做单元测试"><a href="#为什么要做单元测试" class="headerlink" title="为什么要做单元测试"></a>为什么要做单元测试</h2><a id="more"></a>

<ul>
<li>便于后期重构。单元测试为后期测试提供了保障，在重构之后，只要单元测试还是全部通过，那么在很大程度上表示重构没有引入新的bug。</li>
<li>优化设计。编写单元测试将使开发者从调用者的角度观察和思考，这样迫使开发者把程序设计成易于调用和低耦合的易测试的形式。</li>
<li>避免代码出现回归。编写完成后，可以随时随地快速运行测试，而不是要求将代码部署到设备上，再手动执行覆盖各种路径。</li>
<li>文档记录。单元测试是极好的“官方文档”，它展示函数或者类如何使用。</li>
</ul>
<h2 id="Android-测试类型-选自官网"><a href="#Android-测试类型-选自官网" class="headerlink" title="Android 测试类型(选自官网)"></a>Android 测试类型(选自官网)</h2><p>测试代码的位置取决于您要编写的测试的类型。 Android Studio 为以下两种测试类型提供了源代码目录（源集）：</p>
<h3 id="本地单元测试"><a href="#本地单元测试" class="headerlink" title="本地单元测试"></a>本地单元测试</h3><p>位于 <strong>module-name/src/test/java/</strong>目录。</p>
<p>这些测试在计算机的本地 Java 虚拟机 (JVM) 上运行。 当您的测试没有 Android 框架依赖项或当您可以模拟 Android 框架依赖项时，可以利用这些测试来尽量缩短执行时间。</p>
<p>在运行时，这些测试的执行对象是去掉了所有 final 修饰符的修改版 android.jar。 这样一来，您就可以使用 Mockito 之类的常见模拟库。</p>
<h3 id="Instrumented测试（仪器测试）"><a href="#Instrumented测试（仪器测试）" class="headerlink" title="Instrumented测试（仪器测试）"></a>Instrumented测试（仪器测试）</h3><p>位于 module-name/src/androidTest/java/。</p>
<p>这些测试在硬件设备或模拟器上运行。 这些测试有权访问 Instrumentation API，让您可以获取某些信息（例如您要测试的应用的 Context）， 并且允许您通过测试代码来控制受测应用。 可以在编写集成和功能 UI 测试来自动化用户交互时，或者在测试具有模拟对象无法满足的 Android 依赖项时使用这些测试。</p>
<p>由于仪器测试内置于 APK 中（与您的应用 APK 分离），因此它们必须拥有自己的 AndroidManifest.xml 文件。 不过，由于 Gradle 会自动在构建时生成该文件，因此它在您的项目源集中不可见。 您可以在必要时（例如需要为 <code>minSdkVersion</code> 指定其他值或注册测试专用的运行侦听器时）添加自己的清单文件。 构建应用时，Gradle 会将多个清单文件合并成一个清单。</p>
<p>Gradle 构建解读这些测试源集的方式与其解读项目应用源集的方式相同，您可以利用这一点根据构建变体创建测试。</p>
<p>以下示意图诠释了两种测试的代码结构（图中1表示的是<strong>仪器测试</strong>的代码，2表示的是<strong>单元测试</strong>的代码结构）</p>
<p><img src="https://developer.android.google.cn/studio/images/test/project-window-tests_2-2_2x.png?hl=zh-cn" alt="单元测试与仪器测试示意图"></p>
<h2 id="Junit4"><a href="#Junit4" class="headerlink" title="Junit4"></a>Junit4</h2><p>在Android测试框架中，常用的有以下几个框架和工具类：JUnit4、AndroidJUnitRunner、Mockito、Espresso，其中主要的单元测试使用Junit4。Junit4是一套基于注解的单元测试框架，在Android studio中，编写在test目录下的测试类都是基于该框架实现，该目录下的代码直接运行在本地的JVM上，不需要Android真机或者模拟器支持。常用的注解如下(更多内容可以查看<a href="https://junit.org/junit4/" target="_blank" rel="noopener">Junit4官网</a>)：</p>
<ul>
<li>@BeforeClass 测试类里所有用例运行之前，运行一次这个方法。方法必须是public static void</li>
<li>@AfterClass 与BeforeClass对应</li>
<li>@Before 在每个用测试例运行之前都运行一次。</li>
<li>@After 与Before对应</li>
<li>@Test 指定该方法为测试方法，方法必须是public void</li>
<li>@RunWith 测试类名之前，用来确定这个类的测试运行器<br>以下用一个简单的测试类来展示测试类的大概形式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaculatUtilTest</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> CaculatUtil mCaculatUtil;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Before</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">		mCaculatUtil = <span class="keyword">new</span> CaculatUtil();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTwoNumbers</span><span class="params">()</span></span>&#123;</span><br><span class="line">		assertEquals(<span class="number">3</span>,mCaculatUtil.add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">		<span class="comment">//或者如果是静态方法，就类似于以下这种静态调用方法</span></span><br><span class="line">		assertEquals(<span class="number">3</span>,Caculator.add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Junit的断言和失败提示"><a href="#Junit的断言和失败提示" class="headerlink" title="Junit的断言和失败提示"></a>Junit的断言和失败提示</h2><p>Junit提供了多个以assert开头的函数，分别用来验证各类相等性质的问题，大致有如下几类：</p>
<ul>
<li><p>assertEquals</p>
<blockquote>
<p>assertEquals的作用是判断两个值或者对象是否相等。接受2个参数，参数1为预期值，参数2为计算得到的值。</p>
</blockquote>
</li>
<li><p>assertTrue 与 assertFalse</p>
<blockquote>
<p>assertTrue 与 assertFalse顾名思义就是分别验证真与假，只需要一个boolean类型的参数。例如 assertTrue(false)测试会失败， 而 assertTrue(true) 测试通过。</p>
</blockquote>
</li>
<li><p>assertNull 与 assertNotNull</p>
<blockquote>
<p>和assertTrue、assertFalse类似，只不过是用来判断空或者非空。例如：assertNull(null) 会测试失败，因为值为null；而assertNull(“hell”)就能测试通过。</p>
</blockquote>
</li>
<li><p>assertSame 与 assertNotSame</p>
<blockquote>
<p>assertSame用于判断两个对象是否是同一个对象，与assertEquals不同的是，assertSame强调的为同一个对象，而assertEquals只要两个对象相等即可（即调用equals函数时返回true）。</p>
</blockquote>
</li>
<li><p>failNotEquals</p>
<blockquote>
<p>函数有3个参数，参数1位失败时提示信息，参数2为期望值，参数3是实际值。当两个对象不相等时抛出参数1的错误信息。</p>
</blockquote>
</li>
<li><p>failSame与failNotSame</p>
<blockquote>
<p>failNotSame与failNotEquals类似，不是同一个对象时就抛出参数1的错误信息。</p>
</blockquote>
</li>
<li><p>fail(String) 与 fail()</p>
<blockquote>
<p>fail(String)直接抛出当前测试用例参数1中的错误信息，而fail()给出默认的错误信息。</p>
</blockquote>
</li>
</ul>
<h2 id="运行多个测试类——TestSuite"><a href="#运行多个测试类——TestSuite" class="headerlink" title="运行多个测试类——TestSuite"></a>运行多个测试类——TestSuite</h2><p>如果需要同时运行两个或多个Test类，JUnit提供了Suite注解，在对应的测试目录下创建一个空Test类：</p>
<ul>
<li>@RunWith(Suite.class)：配置Runner运行环境。</li>
<li>@Suite.SuiteClasses({A.class, B.class})：添加需要一起运行的测试类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(Suite.class)</span><br><span class="line"><span class="meta">@Suite</span>.SuiteClasses(&#123;CalculatorTest.class, CalculatorWithParameterizedTest.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitTestSuite</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，UnitTestSuite成了一个空类，测试类被添加到注解中了。<br>或者，如果不用注解，可以通过JUnit4TestAdapter包装测试类，并将JUnit4TestAdapter对象添加到TestSuit中，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathTestSuite</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">suite</span><span class="params">()</span></span>&#123;</span><br><span class="line">		TestSuite suite = <span class="keyword">new</span> TestSuite(<span class="string">"com.book.jtm"</span>);</span><br><span class="line">		<span class="comment">//添加测试用例</span></span><br><span class="line">		suite.addTest(<span class="keyword">new</span> JUnit4TestAdapter(AdderTest.class));</span><br><span class="line">		suite.addTest(<span class="keyword">new</span> JUnit4TestAdapter(DiverTest.class));</span><br><span class="line">		<span class="keyword">return</span> suite;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码有一个静态的suite函数，它返回一个Test对象，这个对象是TestSuite类型的。测试时，以Junit测试用例的形式运行这个MathTestSuite即可运行这两个测试类。</p>
<h2 id="多个参数输入测试"><a href="#多个参数输入测试" class="headerlink" title="多个参数输入测试"></a>多个参数输入测试</h2><p>当需要传入多个参数进行测试时，可以使用 @Parameters 来进行单个方法的多次不同参数的测试，对于测试类，使用该方法需要如下步骤：</p>
<ul>
<li>在测试类上添加@RunWith(Parameterized.class)注解</li>
<li>添加测试类的构造函数</li>
<li>添加获取参数集合的static方法，并在方法上添加@Parameters注解</li>
<li>在需要测试的方法中直接使用成员变量，该变量由JUnit通过构造方法生成</li>
</ul>
<p>直接上示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(Parameterized.class)<span class="comment">//为测试类添加注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaculatUtilTest</span></span>&#123;</span><br><span class="line">	<span class="comment">//两个传入的参数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> paramOne;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> paramTwo;</span><br><span class="line">	<span class="comment">//期望值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> expectResult;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> CaculatUtil mCaculatUtil;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CaculatUtilTest</span><span class="params">(<span class="keyword">int</span> paramOne,<span class="keyword">int</span> paramTwo,<span class="keyword">int</span> expectResult)</span></span>&#123;<span class="comment">//添加构造函数</span></span><br><span class="line">		<span class="keyword">this</span>.paramOne = paramOne;</span><br><span class="line">		<span class="keyword">this</span>.paramTwo = paramTwo;</span><br><span class="line">		<span class="keyword">this</span>.expectResult = expectResult;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加获取参数集合的static方法，并在方法上添加@Parameters注解</span></span><br><span class="line">	<span class="meta">@Parameters</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Object[]&gt; initTestData()&#123;</span><br><span class="line">		<span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Object[][]&#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Before</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">		mCaculatUtil = <span class="keyword">new</span> CaculatUtil();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTwoNumbers</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//测试的方法中直接使用成员变量</span></span><br><span class="line">		assertEquals(expectResult,mCaculatUtil.add(paramOne,paramTwo));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AndroidJUnitRunner"><a href="#AndroidJUnitRunner" class="headerlink" title="AndroidJUnitRunner"></a>AndroidJUnitRunner</h2><p>当单元测试中涉及Android系统库的调用时，可以通过AndroidJUnitRunner方案完成测试，这样就能在测试类中使用Context、parcelable、Shareprefrence等类。使用方法是在androidTest目录下创建测试类（因为这涉及到Instrumented测试的内容），在该类上添加@RunWith(AndroidJUnit4.class)注解。如以下代码示范了如何在测试类中使用SharedPrefrences：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(AndroidJUnit4.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedPreferencesHelperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST_NAME = <span class="string">"Test name"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST_EMAIL = <span class="string">"test@email.com"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Calendar TEST_DATE_OF_BIRTH = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SharedPreferenceEntry mSharedPreferenceEntry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SharedPreferencesHelper mSharedPreferencesHelper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SharedPreferences mSharePreferences;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 上下文 */</span></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    ……</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取application的context</span></span><br><span class="line">        mContext = InstrumentationRegistry.getTargetContext();</span><br><span class="line">        <span class="comment">//实例化SharedPreferences</span></span><br><span class="line">        mSharePreferences = PreferenceManager.getDefaultSharedPreferences(mContext);</span><br><span class="line"></span><br><span class="line">        mSharedPreferenceEntry = <span class="keyword">new</span> SharedPreferenceEntry(TEST_NAME, TEST_DATE_OF_BIRTH, TEST_EMAIL);</span><br><span class="line">        <span class="comment">//实例化SharedPreferencesHelper，依赖注入SharePreferences</span></span><br><span class="line">        mSharedPreferencesHelper = <span class="keyword">new</span> SharedPreferencesHelper(mSharePreferences);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以下是在mock的相关操作，模拟commit失败</span></span><br><span class="line">        mMockSharePreferences = Mockito.mock(SharedPreferences.class);</span><br><span class="line">        mMockBrokenEditor = Mockito.mock(SharedPreferences.Editor.class);</span><br><span class="line">        when(mMockSharePreferences.edit()).thenReturn(mMockBrokenEditor);</span><br><span class="line">        when(mMockBrokenEditor.commit()).thenReturn(<span class="keyword">false</span>);</span><br><span class="line">        mMockSharedPreferencesHelper = <span class="keyword">new</span> SharedPreferencesHelper(mMockSharePreferences);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试保存数据是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sharedPreferencesHelper_SavePersonalInformation</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        assertThat(mSharedPreferencesHelper.savePersonalInfo(mSharedPreferenceEntry), is(<span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试保存数据，然后获取数据是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sharedPreferencesHelper_SaveAndReadPersonalInformation</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mSharedPreferencesHelper.savePersonalInfo(mSharedPreferenceEntry);</span><br><span class="line">        SharedPreferenceEntry sharedPreferenceEntry = mSharedPreferencesHelper.getPersonalInfo();</span><br><span class="line">        assertThat(isEquals(mSharedPreferenceEntry, sharedPreferenceEntry), is(<span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="模拟所需要的模块"><a href="#模拟所需要的模块" class="headerlink" title="模拟所需要的模块"></a>模拟所需要的模块</h2><p>有时我们测试需要依赖于其他的功能模块，但是某些原因这个功能模块不能在测试时运用或未开发完，为了不阻塞测试，我们可以Mock对象来完成测试。还有一些场景，诸如对象很难被创建、真实对象运行缓慢、真实对象的错误很难出现等，也可以通过Mock对象来测试。</p>
<h3 id="手动Mock对象"><a href="#手动Mock对象" class="headerlink" title="手动Mock对象"></a>手动Mock对象</h3><p>举个例子，开发一款记事本软件，登录成功后才能写/存笔记，小明小刘分别负责登录和写/存笔记功能，存笔记的时候时候需要用户信息User的实例，而用户信息在登录成功后才能获得。可行的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存数据的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoteDAO</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> NoteDAO noteDAO;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveNote</span><span class="params">(User user,String note)</span></span>&#123;</span><br><span class="line">		Log.d(<span class="string">"NoteDAO"</span>,<span class="string">"存储笔记"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoteTest</span></span>&#123;</span><br><span class="line">	<span class="meta">@Before</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">		noteDAO = <span class="keyword">new</span> NoteDAO();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSaveNote</span><span class="params">()</span></span>&#123;</span><br><span class="line">		MockLoginImpl loginImpl = <span class="keyword">new</span> MockLoginImpl();</span><br><span class="line">		noteDAO.saveNote(loginImpl.login(<span class="string">"dd"</span>,<span class="string">"pwd"</span>),<span class="string">"note_content"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mock类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockLoginImpl</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String name,String pwd)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> User(name,<span class="string">"1234556"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用第三方工具Mockito"><a href="#使用第三方工具Mockito" class="headerlink" title="使用第三方工具Mockito"></a>使用第三方工具Mockito</h3><p>前面有例子已经涉及到Mockito的部分使用，可以在网上搜索相关使用，这里不再详细展开，如果需要，后面会专门介绍。</p>
<h2 id="运行单元测试"><a href="#运行单元测试" class="headerlink" title="运行单元测试"></a>运行单元测试</h2><ul>
<li>在Android studio中，对指定的测试类点击鼠标右键，选择对应的Run或者debug</li>
<li>在Terminal输入gradle testDebugUnitTest或gradle testReleaseUnitTest指令来分别运行debug和release版本的unittesting，在执行的结果可以在xxx\project\app\build\reports\tests\testReleaseUnitTest中查看</li>
</ul>
<p>声明：整篇文章有部分内容摘抄自博客：<a href="https://www.jianshu.com/p/925191464389" target="_blank" rel="noopener">https://www.jianshu.com/p/925191464389</a></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-从小工到专家</tag>
      </tags>
  </entry>
  <entry>
    <title>第13章： 继续进阶——你还应该掌握的高级技巧</title>
    <url>/2018/07/15/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="全局获取Context技巧"><a href="#全局获取Context技巧" class="headerlink" title="全局获取Context技巧"></a>全局获取Context技巧</h2><p>主要就是自定义 Application ，在 Application 中实现全局获取Context，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Context mContext;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		mContext = getApplicationContext();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mContext;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<h2 id="使用Intent传递对象"><a href="#使用Intent传递对象" class="headerlink" title="使用Intent传递对象"></a>使用Intent传递对象</h2><p>Intent的putExtra()方法传递数据的时候，支持的数据类型是有限的，虽然常用的一些数据类型它都支持，但是当你想传递一些自定义对象的时候，就会无从下手。其实使用Intent来传递对象通常有两种实现方式：Serializable和Parcelable。</p>
<h3 id="Serializable-方式"><a href="#Serializable-方式" class="headerlink" title="Serializable 方式"></a>Serializable 方式</h3><p>Serializable是序列化的意思，表示将一个对象转换成可存储或可传输的状态。至于序列化的方法也很简单，只需要实现<strong>Serializable</strong>这个接口就行，如以下的Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="comment">//TODO 这行在书中是没有的，实际上我们得加上，用于区分版本这个类的版本，不同的这个id不能反序列回来</span></span><br><span class="line">	<span class="comment">//如果不写，系统会自动生成，但是如果改动了里面的属性（增加或者减少或者更改了属性），系统生成的这个值会改变</span></span><br><span class="line">	<span class="comment">//（注意，如果没有实质改动（如只是改变属性的位置，或者在类中添加了空格）则值不会改变</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID =<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要在Activity之间传递的话，只需要简单的几行代码即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setName(<span class="string">"Tom"</span>);</span><br><span class="line">person.setAge(<span class="string">"20"</span>);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line">intent.putExtra(<span class="string">"person_data"</span>,person);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>可以看到我们穿件了Person实例，之后直接将它传入putExtra()方法中了，只是因为Person实现了Serializable接口，所以才可以这么写。接下来要在SecondActivity中获取这个对象也很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = (Person)getIntent().getSerializableExtra(<span class="string">"person_data"</span>);</span><br></pre></td></tr></table></figure>

<p>这里调用了getSerializableExtra方法来获取通过参数传递过来的序列化对象，接着再向下转型得到Person对象，就成功实现了Intent传递对象。</p>
<h3 id="Parcelable方式"><a href="#Parcelable方式" class="headerlink" title="Parcelable方式"></a>Parcelable方式</h3><p>除了Serializable之外，使用Parcelable也可以实现相同的效果，不过不同于将对象进行序列化，Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现了传递对象的功能了。下面修改下Person类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">	。。。</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest,<span class="keyword">int</span> flags)</span></span>&#123;</span><br><span class="line">		dest.writeString(name);<span class="comment">//写出name</span></span><br><span class="line">		dest.writeInt(age);<span class="comment">//写出age</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Person&gt;()&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Person <span class="title">createFromParcel</span><span class="params">(Parcel source)</span></span>&#123;</span><br><span class="line">			Person person = <span class="keyword">new</span> Person();</span><br><span class="line">			person.name = source.readString();<span class="comment">//读取name</span></span><br><span class="line">			person.age = source.readInt();</span><br><span class="line">			<span class="keyword">return</span> person;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Person[] newArray(<span class="keyword">int</span> size)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Person[size];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Parcelable 的实现方式要稍微复杂些，首先继承 Parcelable 接口，这样就必须重写 describeContents() 和 writeToParcel() 两个方法。 describeContents 中直接返回0即可，writeToParcel中需要将Person类中的字段一一写出。除此之外，还得再Person类中提供一个 CREATOR 常量。接下来，我们仍然可以通过前面相同的代码来传递Person对象，只不过在SecondActivity中获取对象的时候需要稍加改动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = (Person)getIntent().getParcelableExtra(<span class="string">"person_data"</span>);</span><br></pre></td></tr></table></figure>

<p>一般来说，Serializable方式比较简单，但是这会把整个对象序列化，因此效率比Parcelable低一些，所以更加推荐Parcelable方式。</p>
<h2 id="定制自己的日志工具"><a href="#定制自己的日志工具" class="headerlink" title="定制自己的日志工具"></a>定制自己的日志工具</h2><p>实用性不太强，公司项目有更强大的日志工具，因此  略</p>
<h2 id="调试Android程序"><a href="#调试Android程序" class="headerlink" title="调试Android程序"></a>调试Android程序</h2><p>已经掌握，略</p>
<h2 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h2><p>Android中的定时任务一般有两种实现方式：一是Java API中的Timer类，二是Android中的Alarm机制。但Timer类不太适用于哪些需要长期在后台运行的定时任务，因为为了能让电池更加耐用，每种手机都会有自己的休眠策略，Android手机会在长时间不操作的情况下自动让<strong>CPU进入睡眠状态</strong>，这可能导致Timer中的定时任务无法正常运行。而Alarm则具有唤醒CPU功能，可以保证大多数情况下需要执行定时任务的时候CPU都能正常工作。<strong>注意，这里唤醒CPU和唤醒屏幕完全不是一个概念，千万不要混淆</strong>。</p>
<h3 id="Alarm机制"><a href="#Alarm机制" class="headerlink" title="Alarm机制"></a>Alarm机制</h3><p>Alarm机制用法并不复杂，主要借助于AlarmManager实现，跟NotificationManager有点类似，获取实例的方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AlarmManager manager = (AlarmManager)getSystemService(Context.ALARM_SERVICE);</span><br></pre></td></tr></table></figure>

<p>接下来使用set()方法就可以设置一个定时任务了，比如想设定一个任务在10秒钟后执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> triggerAtTime = SystemClock.elapsedRealtime() + <span class="number">10</span> * <span class="number">1000</span>;</span><br><span class="line">manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,triggerAtTime,pendingIntent);</span><br></pre></td></tr></table></figure>

<p>第一个参数是整型参数，用于指定AlarmManager的工作类型，有4种值可选：ELAPSED_REALTIME(让定时任务的触发时间从系统开机开始算，但不会唤醒CPU)、ELAPSED_REALTIME_WAKEUP（表示定时任务从系统开机开始算起，但会唤醒CPU）、RTC（让定时任务触发时间从1970年1月1日0点开始算起，但不会唤醒CPU）、RTC_WAKEUP(让定时任务触发时间从1970年1月1日0点开始算起，但会唤醒CPU)。可以使用<strong>SystemClock.elapsedRealtime()</strong>获取到系统开机至今所经历的时间的毫秒数。<strong>Systemt.currentTimeMillis()</strong>可以获取到1970年1月1日0点至今所经历的毫秒数。第二个参数就是定时任务触发的时间，如果第一个参数是ELAPSED_REALTIME或者ELAPSED_REALTIME_WAKEUP，则传入开机至今时间加上延迟执行的时间；如果是RTC或者RTC_WAKEUP，则传入1970年1月1日0点至今的时间再加上延迟执行的时间。第三个参数不多说。  </p>
<p>那么如果要实现一个长时间在后台定时运行的服务要如何做呢，其实只要建立一个普通服务，然后将触发定时任务的代码写到onStartCommand()方法中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongRuningService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onstartCommand</span><span class="params">(Intent intent,<span class="keyword">int</span> flags,<span class="keyword">int</span> startId)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//TODO 之所以要在子线程里面执行逻辑操作，是因为逻辑操作需要耗时，放在主线程中可能会对定时任务准确性产生轻微影响。</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="comment">//执行具体的逻辑操作</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		AlarmManager manager = (AlarmManager)getSystemService(ALARM_SERVICE);</span><br><span class="line">		<span class="keyword">int</span> anHour = <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;<span class="comment">//一小时</span></span><br><span class="line">		<span class="keyword">long</span> triggerAtTime = SystemClock.elapsedRealtime() + anHour;</span><br><span class="line">		Intent i = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,LongRunningService(<span class="keyword">this</span>,<span class="number">0</span>,i,<span class="number">0</span>));</span><br><span class="line">		<span class="comment">//TODO 注意，从4.4开始，Alarm任务的触发将会变得不准确，有可能会延迟一段时间后任务才能得到执行，这不是bug，</span></span><br><span class="line">		<span class="comment">//而是系统在耗电方面的优化，系统会自动检测目前有多少Alarm任务，然后将触发时间相近的几个任务放在一起执行，可以</span></span><br><span class="line">		<span class="comment">//大幅度减少CPU被唤醒的次数，从而延长电池使用。如果要求Alarm任务执行时间必须准确无误，则使用   setExact()方法替代</span></span><br><span class="line">		<span class="comment">//下面的set()方法。</span></span><br><span class="line">		manager.set(AlarmManager.ELAPSED_REALTIME_WEKEUP,triggerAtTime,pi);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent,flags,startId);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，一旦启动了LongRuningService，就会设定一个定时任务，一个小时后会再次启动LongRuningService，形成一个永久循环。</p>
<h3 id="Doze模式"><a href="#Doze模式" class="headerlink" title="Doze模式"></a>Doze模式</h3><p>在Android 6.0中，google加入了Doze模式，及大幅度延长电池使用寿命。主要表现为：如果设备未插电源，处于静止（7.0后删除这条件），并且屏幕关闭了一段时间之后，就会进入Doze模式，系统会对CPU、网络、Alarm等活动限制，当然，系统还会间歇性地退出Doze一小段时间，在这段时间，应用可以去完成他们的同步操作、Alarm任务等。如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-13/%E5%9B%BE1.png" alt="Doze模式示意图"></p>
<p>可以看到，随着设备进入Doze模式的时间越长，间歇性退出Doze模式的时间间隔也会越来越长，因为如果设备长时间不使用的话，没必要频繁退出Doze。以下列出Doze模式下有具体哪些功能会收到限制：</p>
<ul>
<li>网络访问被禁止</li>
<li>系统忽略唤醒CPU或者屏幕操作</li>
<li>系统不再执行WIFI扫描</li>
<li>系统不再执行同步服务</li>
<li>Alarm任务将会在下次退出Doze模式时候执行</li>
</ul>
<p>不过，如果你真有非常特殊需求，要求Alarm任务在Doze模式也必须正常执行，可以调用AlarmManager的setAndAllowWhileIdle()或setExactAcnAllowWhileIdle()方法就能让定时任务即使在Doze模式下也能正常执行了，这两个方法之间的区别和set()、setExact()方法之间的区别一样。</p>
<p>*** 多窗口模式</p>
<p>在一个屏幕上，同时显示两个app界面。切换到多窗口模式，Activity会经历重新创建的过程。其实这是正常现象，进入多窗口模式后，Activity的大小发生了比较大的变化，此时默认会重新创建活动的。除此之外，像横竖屏也会重新创建活动。如果此时去操作另一个窗口，则当前窗口会执行onPause，而另一个窗口会执行onResume，这很好理解，因为两个窗口都是可见的，所以只会执行到onPause即可。因此，在考虑多窗口模式下，用户仍然可以看到处于暂停状态的应用，那么像视频播放器之类的应用应该在此时能够继续播放视频才对，因此最好不要在Activity的onPause()方法中去处理播放器的暂停逻辑，而应该在onStop()方法中处理，并且在onStart()方法中恢复视频播放。<strong>另外，针对进入多窗口时活动会被重新重新创建，如果想改变这一默认行为，可以在AndroidManifest.xml中进行配置：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:name</span>=<span class="string">".MainActivity"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:configChanges</span>=<span class="string">"origintation|keyboardHidden|screenSize|screenLayout"</span></span></span><br></pre></td></tr></table></figure>

<p>这样不管进入多窗口模式还是横竖屏切换，Activity都不会被重新创建，而是会将屏幕发生变化的事件通知到Activity的onConfigurationChanged()方法中，因此，如果有这方面的需求，只需要重写onConfigurationChanged()即可。  </p>
<p><strong>当然，如果想禁用多窗口模式，只需要在 AndroidManifest.xml 中的 <application> 或者 <activity>标签中加入如下属性即可</activity></application></strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:resizeableActivity=["true" | "false"]</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是，这个属性只有在项目的targetSdkVersion指定成24或者更高的时候才会有用。不过Android规定，如果targetSdkVersion小于24,并且Activity不允许横竖屏切换，那么应用也将不支持多窗口模式，如果不允许应用横竖屏切换，只需要在AndroidManifest.xml中添加如下配置：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:screenOrientation=["portrait" | "landscape"]</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-第一行代码（第二版）</tag>
      </tags>
  </entry>
  <entry>
    <title>第10章： 后台默默的劳动者-探究服务</title>
    <url>/2018/07/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    <content><![CDATA[<p>服务非常适合执行那些不需要和用户交互还要求长期运行的任务。要注意的是，服务并不是运行在一个独立的进程当中，而是依赖于创建服务时所在的应用程序进程，当应用程序被杀掉时，所有依赖该进程的服务也会停止。不要被服务的后台概念迷惑，实际上服务并不会自动开启子线程，所有的代码都是默认运行在<strong>主线程</strong>中。因此在使用服务时要注意主线程被阻塞的情况。</p><a id="more"></a>
<h2 id="服务的基本用法"><a href="#服务的基本用法" class="headerlink" title="服务的基本用法"></a>服务的基本用法</h2><p>新建类MyService继承Service，要求重写其唯一一个抽象方法  onBind 。一般又要重写onCreate（服务创建时调用）、onStartCommand（每次服务启动的时候调用）以及onDestroy（服务销毁时调用）方法，它们是服务中最常用的3个方法。如果我们希望服务已启动就立刻执行某个动作，就可以将逻辑写在onStartCommand方法里。另外，还需要在AndroidManifest文件中做如下声明（四大组件都得声明）：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:name</span>=<span class="string">".MyService"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line">&lt;/service</span><br></pre></td></tr></table></figure>
<p>其中export属性表示是否允许除了当前程序之外的其他程序访问这个服务，enable表示是否启用这个服务。</p>
<h3 id="启动和停止服务"><a href="#启动和停止服务" class="headerlink" title="启动和停止服务"></a>启动和停止服务</h3><p>通过以下代码可以简单地实现启动和停止服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(v.getId())&#123;</span><br><span class="line">		<span class="keyword">case</span> R.id.start_service:</span><br><span class="line">			Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyService.class);</span><br><span class="line">			startService(startIntent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.stop_service:</span><br><span class="line">			Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyService.class);</span><br><span class="line">			stopService(startIntent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建出Intent对象，使用startService即可启动MyService，会依次执行onCreate-&gt;onStartCommand；同理，使用stopService即可停止，onDestroy就会执行。如果在service里面，那么使用stopSelf即可停止自己。由于刚才点击start的时候，onCreate和onStartCommand都执行了，也许你会疑惑，这两个方法到底有什么区别呢？其实onCreate方法在服务第一次创建时调用，而onStartCommand则在每次启动服务时调用，由于是第一次创建，所以两个方法都执行了，如果多次点击start service按钮，那就只有onStartCommand方法执行了。</p>
<h3 id="活动和服务通信"><a href="#活动和服务通信" class="headerlink" title="活动和服务通信"></a>活动和服务通信</h3><p>上一节虽然在活动中启动和停止了服务，但是启动服务之后，活动与服务基本上就没关系了，没法控制服务。如果希望控制服务执行，比如MyService提供下载功能，则希望可以决定什么时候开始下载，以及查看下载进度等，主要的思路是创建一个专门的Binder对象来对下载功能进行管理，然后通过ServiceConnection来实现通信。简易代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//service代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> DownloadBinder mBinder = <span class="keyword">new</span> DownloadBinder();</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">DownloadBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownload</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProgress</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mBinder;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Activity代码</span></span><br><span class="line"><span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span></span>&#123;<span class="comment">//解除绑定时调用</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name,Ibinder service)</span></span>&#123;<span class="comment">//绑定时调用</span></span><br><span class="line">		downloadBinder = (MyService.DownloadBinder)service;</span><br><span class="line">		downloadBinder.startDownload();</span><br><span class="line">		downloadBinder.getProgress();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(v.getId())&#123;</span><br><span class="line">		<span class="keyword">case</span> R.id.bind_service:</span><br><span class="line">			Intent bindIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyService.class);</span><br><span class="line">			bindService(bindIntent,connection,BIND_AUTO_CREATE);<span class="comment">//绑定服务</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.unbind_service:</span><br><span class="line">			unbindService(connection);<span class="comment">//解绑服务</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务生命周期"><a href="#服务生命周期" class="headerlink" title="服务生命周期"></a>服务生命周期</h3><p>一旦在任何位置调用了Context的startService方法，相应的服务就会启动，如果服务还没创建过，onCrete先执行，在执行onStartCommand，如果已经创建了，则只会执行onStartCommand了，启动后该服务一直运行，直到调用stopService或者stopSelf为止。虽然多次启动服务onStartCommand会被多次执行，但是服务只会存在一个实例。<br>另外，还可以调用Context的bindService来获取一个服务的持久连接，这时会回调服务的onBind方法，类似地，如果之前没创建过该服务，就会先执行onCreate在执行onBind，之后，调用方可以获取到onBind方法里返回的IBinder对象实例，就能自由和服务进行通信。调用unbind方法，也会执行Myservice的onDestroy方法，即销毁服务。</p>
<h2 id="服务的更多技巧"><a href="#服务的更多技巧" class="headerlink" title="服务的更多技巧"></a>服务的更多技巧</h2><h3 id="使用前台服务"><a href="#使用前台服务" class="headerlink" title="使用前台服务"></a>使用前台服务</h3><p>由于服务运行在后台，因此其系统优先级比较低，当出现内存不足的情况时，容易被回收，这就考虑使用前台服务。前台服务和普通服务最大的区别在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉可以看到更详细的信息，非常<strong>类似</strong>于通知效果。其主要实现方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate();</span><br><span class="line">		Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MainActivity.class);</span><br><span class="line">		PendingIntent pi = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,intent,<span class="number">0</span>);</span><br><span class="line">		Notification notification = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>)</span><br><span class="line">			.setContentTitle(<span class="string">"title"</span>)</span><br><span class="line">			.***<span class="comment">//其他配置省略了</span></span><br><span class="line">			.build();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//没有像普通Notification一样使用NotificationManager将通知展示出来，而是使用</span></span><br><span class="line">			<span class="comment">//startForeground方法</span></span><br><span class="line">		**startForeground(<span class="number">1</span>,notification);<span class="comment">//与普通Notification和普通的Service区别的关键在这里**</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用IntentService"><a href="#使用IntentService" class="headerlink" title="使用IntentService"></a>使用IntentService</h3><p>服务中的代码都是默认运行在主线程当中的，如果直接在服务里处理耗时操作，很容易出现ANR。当然，为了避免这种情况，你可以在onStartCommand方法中new 一个Thread来处理耗时逻辑，写法并不复杂，但是程序员容易忘记开启线程或者忘记调用stopSelf。为了简单地创建一个异步的、能够自动停止的服务，Android专门提供了IntentService，在继承Intentservice之后，你可以直接在它的 onHandleIntent方法中执行耗时操作（这是在新的线程里面，可以通过Thread.currentThread<br>().getId()方法查看线程ID，跟主线程不是同一个），在耗时操作执行完毕之后，这个IntentService会自动调用onDestroy停止。</p>
<h3 id="服务的最佳实践——完整版下载示例"><a href="#服务的最佳实践——完整版下载示例" class="headerlink" title="服务的最佳实践——完整版下载示例"></a>服务的最佳实践——完整版下载示例</h3><p>直接上代码吧，多说无益。用于执行异步任务的AsyncTask：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里AsyncTask传入3个参数类型，第一个泛型指定为String，表示在执行AsyncTask时需要传入一个</span></span><br><span class="line"><span class="comment">//字符串给后台任务，第二个指定为Integer，表示使用整型数据作为进度显示单位，第三个泛型Intege则表示使用整数型</span></span><br><span class="line"><span class="comment">//数据来反馈执行结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>,<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SUCCESS = <span class="number">1</span>;<span class="comment">//成功</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_FAILED = <span class="number">2</span>;<span class="comment">//失败</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_PAUSED = <span class="number">3</span>;<span class="comment">//暂停</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_CANCELED = <span class="number">4</span>;<span class="comment">//取消</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DownloadListener downloadListener = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPaused = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isCancled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lastProgress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadTask</span><span class="params">(DownloadListener listener)</span></span>&#123;</span><br><span class="line">        downloadListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;<span class="comment">//用于后台执行下载逻辑</span></span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        RandomAccessFile savedFile = <span class="keyword">null</span>;</span><br><span class="line">        File file = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">long</span> downloadedLength = <span class="number">0</span>;<span class="comment">//记录已经下载的文件长度</span></span><br><span class="line">            String downloadUrl = params[<span class="number">0</span>];</span><br><span class="line">            String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(<span class="string">"/"</span>));</span><br><span class="line">            <span class="comment">//SD卡的Download目录</span></span><br><span class="line">            String directory = Environment.getExternalStoragePublicDirectory(</span><br><span class="line">                    Environment.DIRECTORY_DOWNLOADS).getPath();</span><br><span class="line">            file = <span class="keyword">new</span> File(directory + fileName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果已经存在要下载的文件了，则读取已经下载的字节数，这样就可以在后面启动端点续传功能</span></span><br><span class="line">            <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">                downloadedLength = file.length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取文件总长</span></span><br><span class="line">            <span class="keyword">long</span> contentLength = getContentLength(downloadUrl);</span><br><span class="line">            <span class="keyword">if</span>(contentLength == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> TYPE_FAILED;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(contentLength == downloadedLength)&#123;</span><br><span class="line">                <span class="comment">//已下载的字节和总字节相等，说明已经下载完成</span></span><br><span class="line">                <span class="keyword">return</span> TYPE_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">            OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">            Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                    <span class="comment">//断点下载，指定从哪个字节开始下载</span></span><br><span class="line">                    .addHeader(<span class="string">"RANGE"</span>,<span class="string">"bytes="</span> + downloadedLength + <span class="string">"-"</span>)</span><br><span class="line">                    .url(downloadUrl)</span><br><span class="line">                    .build();</span><br><span class="line">            Response response = client.newCall(request).execute();</span><br><span class="line">            <span class="keyword">if</span>(response != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//以下读取服务器响应的数据，并使用Java文件流方式，不断从网络读取数据，不断写到本地，知道</span></span><br><span class="line">                <span class="comment">//文件全部下载完成为止</span></span><br><span class="line">                is = response.body().byteStream();</span><br><span class="line">                savedFile = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">                savedFile.seek(downloadedLength);<span class="comment">//跳过已下载的字节</span></span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> len;</span><br><span class="line">                <span class="keyword">while</span> ((len = is.read(b)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isCancled)&#123;</span><br><span class="line">                        <span class="keyword">return</span> TYPE_CANCELED;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isPaused)&#123;</span><br><span class="line">                        <span class="keyword">return</span> TYPE_PAUSED;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        total += len;</span><br><span class="line">                        savedFile.write(b,<span class="number">0</span>,len);</span><br><span class="line">                        <span class="comment">//计算已下载的百分比</span></span><br><span class="line">                        <span class="keyword">int</span> progress = (<span class="keyword">int</span>) ((total + downloadedLength) * <span class="number">100</span>/contentLength);</span><br><span class="line">                        publishProgress(progress);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                response.body().close();</span><br><span class="line">                <span class="keyword">return</span> TYPE_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (is != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (savedFile != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    savedFile.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isCancled &amp;&amp; file != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    file.delete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TYPE_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span> </span>&#123;<span class="comment">//用于在界面上更新当前的下载进度</span></span><br><span class="line">        <span class="keyword">int</span> progress = values[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (progress &gt; lastProgress)&#123;</span><br><span class="line">            downloadListener.onProgress(progress);</span><br><span class="line">            lastProgress = progress;</span><br><span class="line">            Log.e(<span class="string">"进度"</span>,progress+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Integer status)</span> </span>&#123;<span class="comment">//用于通知最终的下载结果</span></span><br><span class="line">        <span class="keyword">switch</span> (status)&#123;</span><br><span class="line">            <span class="keyword">case</span> TYPE_SUCCESS:</span><br><span class="line">                downloadListener.onSuccess();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TYPE_FAILED:</span><br><span class="line">                downloadListener.onFailed();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TYPE_PAUSED:</span><br><span class="line">                downloadListener.onPaused();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TYPE_CANCELED:</span><br><span class="line">                downloadListener.onCancled();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pauseDownload</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isPaused = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelDownload</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isCancled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取要下载的内容的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getContentLength</span><span class="params">(String downloadUrl)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(downloadUrl)</span><br><span class="line">                .build();</span><br><span class="line">        Response response = client.newCall(request).execute();</span><br><span class="line">        <span class="keyword">if</span>(response != <span class="keyword">null</span> &amp;&amp; response.isSuccessful())&#123;</span><br><span class="line">            <span class="keyword">long</span> contentLength = response.body().contentLength();</span><br><span class="line">            response.close();</span><br><span class="line">            <span class="keyword">return</span> contentLength;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于执行后台任务的Service</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DownloadTask downloadTask;</span><br><span class="line">    <span class="keyword">private</span> String downloadUrl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DownloadListener listener = <span class="keyword">new</span> DownloadListener()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgress</span><span class="params">(<span class="keyword">int</span> progress)</span> </span>&#123;</span><br><span class="line">            getNotificationManager().notify(<span class="number">1</span>,getNotification(<span class="string">"Downloading..."</span>,progress));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            downloadTask = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//下载成功时将前台服务通知关闭，并创建一个下载成功的通知</span></span><br><span class="line">            <span class="comment">//这句代码将服务创建成前台服务</span></span><br><span class="line">            stopForeground(<span class="keyword">true</span>);</span><br><span class="line">            getNotificationManager().notify(<span class="number">1</span>,getNotification(<span class="string">"Download Success"</span>,-<span class="number">1</span>));</span><br><span class="line">            Toast.makeText(DownloadService.<span class="keyword">this</span>,<span class="string">"Download success"</span>,Toast.LENGTH_LONG).show();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            downloadTask = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//下载失败将前台服务通知关闭，并创建一个下载失败的通知</span></span><br><span class="line">            stopForeground(<span class="keyword">true</span>);</span><br><span class="line">            getNotificationManager().notify(<span class="number">1</span>,getNotification(<span class="string">"Download Failed"</span>,-<span class="number">1</span>));</span><br><span class="line">            Toast.makeText(DownloadService.<span class="keyword">this</span>,<span class="string">"Download failed"</span>,Toast.LENGTH_LONG).show();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPaused</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            downloadTask = <span class="keyword">null</span>;</span><br><span class="line">            Toast.makeText(DownloadService.<span class="keyword">this</span>,<span class="string">"Paused"</span>,Toast.LENGTH_LONG).show();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            downloadTask = <span class="keyword">null</span>;</span><br><span class="line">            stopForeground(<span class="keyword">true</span>);</span><br><span class="line">            Toast.makeText(DownloadService.<span class="keyword">this</span>,<span class="string">"Canceled"</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了让service可以和Activity通信，创了这个binder</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownload</span><span class="params">(String url)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(downloadTask == <span class="keyword">null</span>)&#123;</span><br><span class="line">                downloadUrl = url;</span><br><span class="line">                downloadTask = <span class="keyword">new</span> DownloadTask(listener);</span><br><span class="line">                downloadTask.execute(downloadUrl);</span><br><span class="line">                startForeground(<span class="number">1</span>,getNotification(<span class="string">"Downloading..."</span>,<span class="number">0</span>));</span><br><span class="line">                Toast.makeText(DownloadService.<span class="keyword">this</span>,<span class="string">"Downloading..."</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pauseDownload</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (downloadTask != <span class="keyword">null</span>)&#123;</span><br><span class="line">                downloadTask.pauseDownload();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelDownload</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (downloadTask != <span class="keyword">null</span>)&#123;</span><br><span class="line">                downloadTask.cancelDownload();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (downloadUrl != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//取消下载时需要将文件删除，并将通知关闭</span></span><br><span class="line">                    String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(<span class="string">"/"</span>));</span><br><span class="line">                    String directory = Environment.getExternalStoragePublicDirectory(</span><br><span class="line">                            Environment.DIRECTORY_DOWNLOADS).getPath();</span><br><span class="line">                    File file = <span class="keyword">new</span> File(directory + fileName);</span><br><span class="line">                    <span class="keyword">if</span>(file.exists())&#123;<span class="comment">//如果已经存在要下载的文件了，则读取已经下载的字节数，这样就可以在后面启动端点续传功能</span></span><br><span class="line">                        file.delete();</span><br><span class="line">                    &#125;</span><br><span class="line">                    getNotificationManager().cancel(<span class="number">1</span>);</span><br><span class="line">                    stopForeground(<span class="keyword">true</span>);</span><br><span class="line">                    Toast.makeText(DownloadService.<span class="keyword">this</span>,<span class="string">"Canceled"</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DownloadBinder mBinder = <span class="keyword">new</span> DownloadBinder();</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> NotificationManager <span class="title">getNotificationManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Notification <span class="title">getNotification</span><span class="params">(String title,<span class="keyword">int</span> progress)</span></span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MainActivity.class);</span><br><span class="line">        PendingIntent pi = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,intent,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        NotificationCompat.Builder builder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO 注意这段代码，在8.0以后通知要求设置 NotificationChannel，否则会报错</span></span><br><span class="line">        <span class="comment">//TODO 在书本中的代码没有这一段</span></span><br><span class="line">        <span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O )&#123;</span><br><span class="line">            NotificationChannel channel = <span class="keyword">new</span> NotificationChannel(<span class="string">"im_channel_id"</span>,<span class="string">"System"</span>, NotificationManager.IMPORTANCE_LOW);</span><br><span class="line">            NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">            <span class="keyword">if</span>(manager != <span class="keyword">null</span>)&#123;</span><br><span class="line">                **manager.createNotificationChannel(channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//书上是 builder = new NotificationCompat.Builder(this);  ，但是这个方法现在已经废弃了</span></span><br><span class="line">        builder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>,<span class="string">"im_channel_id"</span>);</span><br><span class="line">        builder.setSmallIcon(R.mipmap.ic_launcher);</span><br><span class="line">        builder.setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher));</span><br><span class="line">        builder.setContentIntent(pi);</span><br><span class="line">        builder.setContentTitle(title);</span><br><span class="line">        <span class="keyword">if</span> (progress &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//当progress大于或者等于0才需显示下载进度</span></span><br><span class="line">            builder.setContentText(progress + <span class="string">"%"</span>);</span><br><span class="line">            builder.setProgress(<span class="number">100</span>,progress,<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Activity中的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DownloadService.DownloadBinder downloadBinder;</span><br><span class="line">    <span class="comment">//为了能够控制service的行为</span></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            downloadBinder = (DownloadService.DownloadBinder) service;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        findViewById(R.id.start).setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        findViewById(R.id.pause).setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        findViewById(R.id.cancel).setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,DownloadService.class);</span><br><span class="line">        startService(intent);</span><br><span class="line">        bindService(intent,connection,BIND_AUTO_CREATE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.0及以上要求动态申请权限，有权限才能使用这个下载功能</span></span><br><span class="line">        <span class="keyword">if</span>(ContextCompat.checkSelfPermission(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">                Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">            ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]</span><br><span class="line">                    &#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先判断downloadBinder是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (downloadBinder == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.start:</span><br><span class="line">                String url = <span class="string">"https://raw.githubusercontent.com/guolindev/eclipse/master/eclipse-inst-win64.exe"</span>;</span><br><span class="line">                downloadBinder.startDownload(url);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.pause:</span><br><span class="line">                downloadBinder.pauseDownload();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.cancel:</span><br><span class="line">                downloadBinder.cancelDownload();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, @NonNull String[] permissions, @NonNull <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">        <span class="keyword">switch</span> (requestCode)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (grantResults.length &gt; <span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">"拒绝权限无法使用程序"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">                    finish();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unbindService(connection);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>当然，还有要注意的是，要在AndroidManifest.xml中注册Service：</strong></p>
<blockquote>
<p>service android:name=”.DownloadService”</p>
</blockquote>
<p>还有，在AndroidManifest.xml中需要标明网络权限和存储权限：</p>
<blockquote>
<p>uses-permission android:name=”android.permission.INTERNET”<br>    uses-permission android:name=”android.permission.WRITE_EXTERNAL_STORAGE”</p>
</blockquote>
<p>最后，针对本例子，例子中使用了okhttp，需要在buildgradle中添加依赖：</p>
<blockquote>
<p>implementation ‘com.squareup.okhttp3:okhttp:3.9.0’</p>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-第一行代码（第二版）</tag>
      </tags>
  </entry>
  <entry>
    <title>第9章： 看看精彩的世界-使用网络技术</title>
    <url>/2018/06/23/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="webview的用法"><a href="#webview的用法" class="headerlink" title="webview的用法"></a>webview的用法</h2><p>这节描述得比较简单，因此记住以下内容就行：</p><blockquote>
<p>webview.setWebClient(new WebViewClient);</p>
</blockquote><p>为webview设置webViewClient，其主要作用是当需要从一个网页跳转到另一个网页时，我们希望目标网页仍然在当前WebView中显示，而不是打开系统浏览器。</p><a id="more"></a>


<h2 id="使用HTTP协议访问网络"><a href="#使用HTTP协议访问网络" class="headerlink" title="使用HTTP协议访问网络"></a>使用HTTP协议访问网络</h2><p>介绍了HttpURLConnection 使用方法，简单上个图：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-9/%E5%9B%BE0.png" alt="HttpURLConnection使用"></p>
<p>OkHttp的简单使用，并不复杂，略。</p>
<h2 id="解析XML格式数据"><a href="#解析XML格式数据" class="headerlink" title="解析XML格式数据"></a>解析XML格式数据</h2><p>在网络上传输数据时最常用的格式有两种，XML和JSON，首先学习解析XML。</p>
<h3 id="搭建简易服务器提供数据"><a href="#搭建简易服务器提供数据" class="headerlink" title="搭建简易服务器提供数据"></a>搭建简易服务器提供数据</h3><p>学习解析xml和json之前，先搭建一个简易服务器提供解析的数据，按照以下步骤即可：</p>
<ol>
<li><p>下载一个Apache服务器的安装包，官方下载地址<a href="http://httpd.apache.org/download.cgi" target="_blank" rel="noopener">http://httpd.apache.org/download.cgi</a></p>
</li>
<li><p>一路默认Next，域名随意填写如test.com，安装路径的话，可以选择安装在 C:\Apache 目录</p>
</li>
<li><p>为了验证安装是否成功，可以打开电脑的浏览器验证，输入 127.0.0.1 出现 It works 界面即可。</p>
</li>
</ol>
<p>接下来进入到安装目录的htdocs目录下，按照上述安装过程应该是C:\Apache\htdocs目录，新建get_data.xml文件，编辑，并加入内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">apps</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">app</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>google map<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">app</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>google map<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">app</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">apps</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打开浏览器访问 <a href="http://127.0.0.1/get_data.xml就会显示上述内容，同理，如果在其中新建" target="_blank" rel="noopener">http://127.0.0.1/get_data.xml就会显示上述内容，同理，如果在其中新建</a> get_data.json文件，并添加以下数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">"id"</span>:<span class="string">"5"</span>,<span class="attr">"version"</span>:<span class="string">"5.5"</span>,<span class="attr">"name"</span>:<span class="string">"map"</span>&#125;,</span><br><span class="line">&#123;<span class="attr">"id"</span>:<span class="string">"6"</span>,<span class="attr">"version"</span>:<span class="string">"6.6"</span>,<span class="attr">"name"</span>:<span class="string">"boom"</span>&#125;,</span><br><span class="line">&#123;<span class="attr">"id"</span>:<span class="string">"7"</span>,<span class="attr">"version"</span>:<span class="string">"3.5"</span>,<span class="attr">"name"</span>:<span class="string">"clash"</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>打开浏览器访问 <a href="http://127.0.0.1/get_data.json" target="_blank" rel="noopener">http://127.0.0.1/get_data.json</a> 就会返回上述json。</p>
<h3 id="Pull解析方式"><a href="#Pull解析方式" class="headerlink" title="Pull解析方式"></a>Pull解析方式</h3><p>解析XML格式的数据有多重方式，主要是Pull和SAX两种方式。通过自己搭建的服务器拉取XML数据之后通过Pull解析的示例如下：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-9/%E5%9B%BE1.jpg" alt="pull解析方式代码"></p>
<h3 id="SAX解析"><a href="#SAX解析" class="headerlink" title="SAX解析"></a>SAX解析</h3><p>Pull解析方式虽然非常好用，它比XML解析方式要复杂一些，但是语义方面更清楚，通常情况下，我们都会新建一个雷继承自DefaultHandler，并重写父类的5个方法：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-9/%E5%9B%BE2.jpg" alt="继承DefaultHandler"></p>
<p>每当解析某个节点的时候，startElement方法就会得到调用，其中localName记录当前节点的名字。接下来的工作就非常简单了，修改MainActivity中的代码，如下所示：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-9/%E5%9B%BE3.jpg" alt="SAX解析"></p>
<h2 id="解析JSON格式数据"><a href="#解析JSON格式数据" class="headerlink" title="解析JSON格式数据"></a>解析JSON格式数据</h2><p>JSON相对XML而言优势在于它体积更小，在网络上传输的时候可以更省流量，但缺点是语义性较差。</p>
<h3 id="使用JSONObject"><a href="#使用JSONObject" class="headerlink" title="使用JSONObject"></a>使用JSONObject</h3><p>比较简单，直接上截图的例子：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-9/%E5%9B%BE4.png" alt="JSONObject解析"></p>
<h3 id="使用GSON"><a href="#使用GSON" class="headerlink" title="使用GSON"></a>使用GSON</h3><p>解析单个的对象比较简单，比如解析：</p>
<blockquote>
<p>{“name”:”Tom”,”age”:20}</p>
</blockquote>
<p>那只需要定义Person类，有String类型的name字段以及int类型的age字段，则可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">Person person = gson.fromJson(jsonData,Person.class);</span><br></pre></td></tr></table></figure>

<p>解析数组稍微麻烦点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; people = gson.fromJson(jsonData,<span class="keyword">new</span> TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;.getType());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-第一行代码（第二版）</tag>
      </tags>
  </entry>
  <entry>
    <title>第8章：丰富你的程序-使用手机多媒体</title>
    <url>/2018/06/22/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="使用通知"><a href="#使用通知" class="headerlink" title="使用通知"></a>使用通知</h2><p>我们可以在Activity中、BroadcastReceiver以及Service中创建通知，不论在哪里创建，整体步骤是相同的，下面通过示例演示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、需要NotificationManager管理通知，通过调用Context的getSystemService方法获得</span></span><br><span class="line">NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、创建一个延迟意图（PendingIntent），标明点击notification时的响应，这里可以启动Activity，Broadcast以及service等</span></span><br><span class="line"><span class="comment">//PendingIntent有点类似于Intent，不过前者倾向于在某个合适的时机去执行某个动作，而后者倾向于立即执行某个动作</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line"><span class="comment">//根据启动的对象（Activity、Broadcast或service），可以使用getActivity()/getBroadcast()/getService()</span></span><br><span class="line">PendingIntent pi = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,intent,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、通过Builder构造器创建Notification对象，几乎Android每个版本都会对通知这部分进行修改，因此我们需要使用</span></span><br><span class="line"><span class="comment">//support-v4包提供的NotificationCompat类来兼容性地实现，保证在各个版本上都能正常使用通知</span></span><br><span class="line">Notification notification = <span class="keyword">new</span> NotificationCompat.Builder(context)</span><br><span class="line">			.setContentTitle(<span class="string">"title"</span>)</span><br><span class="line">			.setContentText(<span class="string">"content"</span>)</span><br><span class="line">			.setSound(Uri.from(<span class="string">""</span>))<span class="comment">//控制通知的声音</span></span><br><span class="line">			<span class="comment">//设置通知来的时候震动，数组中的值为时长，单位为毫秒，下标0表示手机静止时长，下标1为手机震动时长，下标2为手机静止</span></span><br><span class="line">			<span class="comment">//时长，以此类推，这就实现了通知来时立刻震动1秒，静止1秒，再震动1秒</span></span><br><span class="line">			<span class="comment">//注意震动需要权限 &lt;uses-permission android:name="android.permission.VIBRATE"&gt;</span></span><br><span class="line">			.setVibrate(<span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">0</span>,<span class="number">1000</span>,<span class="number">1000</span>,<span class="number">1000</span>&#125;)</span><br><span class="line">			.setWhen(System.currentMillis())<span class="comment">//指定通知被创建的时间，下拉时这个时间会显示在通知上</span></span><br><span class="line">			.setSmallIcon(R.drawable.small_icon)<span class="comment">//显示在顶部状态栏上的图标</span></span><br><span class="line">			.setLargeIcon(BitmapFactory.decodeResource(gerResources(),R.drawable.large_icon))<span class="comment">//下拉时显示在通知左边</span></span><br><span class="line">			.setContentIntent(pi)<span class="comment">//指明点击之后的意图</span></span><br><span class="line">			<span class="comment">//通知自动消失,第二种取消方式是，将notification的id传入SecondActivity中，在进入到SecondActivity后，在SecondActivity</span></span><br><span class="line">			<span class="comment">//的onCreate方法中重新获取manager，并且关闭这个通知：</span></span><br><span class="line">			<span class="comment">//NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);  manager.cancel(id);</span></span><br><span class="line">			.setLights(Color.GREEN,<span class="number">1000</span>,<span class="number">1000</span>)<span class="comment">//设置灯光绿色和一闪一闪的效果</span></span><br><span class="line">			.setAutoCancel(<span class="keyword">true</span>)</span><br><span class="line">			<span class="comment">//设置style，一般通知只会显示很短的内容文字，但如果真的非常需要长文字，也是支持的，这样设置style，如果要显示一张大图片，</span></span><br><span class="line">			<span class="comment">//以下换成NotificationCompat.BigTextStyle().bigPicture(bitmap)即可</span></span><br><span class="line">			.setStyle(<span class="keyword">new</span> NotificationCompat.BigTextStyle().bigText(<span class="string">"fdasfdsafdsafdafdasfsdafadsfdsfasdffasdfdsfdsfsda"</span>))</span><br><span class="line">			<span class="comment">//设置通知优先级，如果设置为最高的话，即要求用户立刻看，不会像普通通知只在状态栏显示一个图标，而是弹出一个横幅</span></span><br><span class="line">			<span class="comment">//不论你当前在玩游戏还是看电影，这个横幅都会弹</span></span><br><span class="line">			.setPriority(NotificationCompat.PRIORITY_MAX)</span><br><span class="line">			.build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、发出通知</span></span><br><span class="line">manager.notify(<span class="number">1</span>,notification);<span class="comment">//第一个参数指定notification的id</span></span><br></pre></td></tr></table></figure><a id="more"></a>



<h2 id="调用摄像头和相册"><a href="#调用摄像头和相册" class="headerlink" title="调用摄像头和相册"></a>调用摄像头和相册</h2><p>平时使用QQ或者微信的时候经常要别人分享图片，这些图片可以使手机摄像头拍摄也可以从相册中选取，这种功能非常普遍。</p>
<h3 id="摄像头拍照"><a href="#摄像头拍照" class="headerlink" title="摄像头拍照"></a>摄像头拍照</h3><p>直接上代码展示可能更加清晰：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">takePhoto.setOnclickListener(<span class="keyword">new</span> View.OnclickListener()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建File对象，用于存储拍照后的图片</span></span><br><span class="line">		File outputImage = <span class="keyword">new</span> File(getExternalCacheDir(),<span class="string">"output.jpg"</span>);</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(outputImage.exists())&#123;<span class="comment">//存在了</span></span><br><span class="line">				outputImage.delete();</span><br><span class="line">			&#125;</span><br><span class="line">			outputImage.createNewFile();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= <span class="number">24</span>)&#123;</span><br><span class="line">			imageUri = FileProvider.getUriForFile(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">				<span class="string">"com.example.fileprovider"</span>,outputImage);</span><br><span class="line"></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			imageUri = Uri.fromFile(outputImage);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//启动相机</span></span><br><span class="line">		Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.media.action.IMAGE_CAPTURE"</span>);</span><br><span class="line">		intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);</span><br><span class="line">		startActivityForResult(intent,TAKE_PHOTO);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode,<span class="keyword">int</span> resultCode,Intent data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(requestCode)&#123;</span><br><span class="line">		<span class="keyword">case</span> TAKE_PHOTO:</span><br><span class="line">			<span class="keyword">if</span>(resultCode == RESULT_OK)&#123;</span><br><span class="line">				<span class="keyword">try</span>&#123;</span><br><span class="line">					<span class="comment">//将拍摄的照片显示出来</span></span><br><span class="line">					Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver()</span><br><span class="line">						.openInputStream(imageUri));</span><br><span class="line">					ivPic.setImageBitmap(bitmap);</span><br><span class="line">				&#125;<span class="keyword">catch</span> (FileNotFoundException e)&#123;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们用了内容提供器，因此还需要在AndroidManifest.xml中声明这个提供器(<strong>有一点要注意的是,在4.4以前（4.4及以后不需要）访问SD卡得应用关联目录也是要声明权限的，为了兼容老版本的手机，需要声明 WRITE_EXTERNAL_STORAGE 权限</strong>)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">users-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">...</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">privider</span></span></span><br><span class="line">		&lt;!--这里，android:name属性的值是固定的，android:authorities属性的值必须要和刚才FileProvider.getUriForFile()--&gt;</span><br><span class="line">		<span class="comment">&lt;!--方法中的第二个参数一致，另外，meta-data中用resource指定了Uri的共享路径--&gt;</span></span><br><span class="line">		android:name="android.support.v4.content.FileProvider"</span><br><span class="line">		android:authorities="com.example.fileprovider"</span><br><span class="line">		android:exported="false"</span><br><span class="line">		android:grantUriPermissions="true"&gt;</span><br><span class="line">		<span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，provider声明中使用了@xml/file_paths资源，这个资源我们还没创建，因此在res目录下可以创建这么个xml，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"&gt;</span></span><br><span class="line"><span class="meta">&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt;</span></span><br><span class="line"><span class="meta">	&lt;!--这里面external-path指定Uri共享的，name属性随便填，path属性表示共享的具体路径，这里设置空值就表示将整个SD卡进行共享--&gt;</span></span><br><span class="line"><span class="meta">	&lt;!--当然，你可以仅仅共享我们存放output.jpg这张图片的路径--&gt;</span></span><br><span class="line"><span class="meta">	&lt;external-path name="my_images" path=""&gt;</span></span><br><span class="line"><span class="meta">&lt;/paths&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上整个代码首先创建了一个File对象，用于存放摄像头拍下的图片，我们将其命名为output.jpg，并将它存放在手机SD卡的应用关联缓存目录（指SD卡中专门用于存放当前应用缓存数据的位置，路径为/sdcard/Android/data/<package name>/cache，调用getExternalCacheDir()方法就可以得到这个目录）下。<strong>为什么使用应用关联缓存目录来存放图片呢？因为从Android 6.0开始，读写SD卡被列为危险权限，如果将图片存放SD卡得任何其他目录，都要进行运行时权限处理才行，而使用应用关联目录则可以跳过这一步</strong>。  </package></p>
<p>接着会判断如果设备版本低于7.0，就调用Uri.fromFile()方法将File对象转换为Uri对象，这个Uri标识着图片的本地真实路径。否则就调用FileProvider的getUriForFile()方法获得Uri对象。之所以这样是因为从7.0开始，直接使用本地真实路径的Uri被认为是不安全的，会抛出异常，而FileProvider则是一种特殊的内容提供器，可以选择性地将封装过的Uri共享给外部，提高应用安全性。  </p>
<p>最后就是启动摄像头拍照并且回调获取图片了。</p>
<h3 id="从相册中选择照片"><a href="#从相册中选择照片" class="headerlink" title="从相册中选择照片"></a>从相册中选择照片</h3><p>直接选取一张现有图片比打开相机拍一张照片更加常用，一个优秀的应用应该将这两种方式都提供给用户。废话不多说直接上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">chooseFromAlbum.setOnclickListener(<span class="keyword">new</span> View.OnclickListener()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(ContextCompat.checkSelfPermission(MainActivity.<span class="keyword">this</span>,Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line"></span><br><span class="line">			ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>,<span class="keyword">new</span> String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			openAlbum();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openAlbum</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.intent.action.GET_CONTENT"</span>);</span><br><span class="line">	intent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">	startActivityForResult(intent,CHOOSE_PHOTO);<span class="comment">//打开相册</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode,String[] permissions,<span class="keyword">int</span>[] grantResults)</span></span>&#123;</span><br><span class="line">	swithc(requestCode)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">if</span>(grantResults.lenght &gt; <span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">				openAlbum();</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				Toast.makeText(<span class="keyword">this</span>,<span class="string">"you denied the permission"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode,<span class="keyword">int</span> resultCode,Intent data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(requestCode)&#123;</span><br><span class="line">		<span class="keyword">case</span> CHOOSE_PHOTO:</span><br><span class="line">			<span class="keyword">if</span>(resultCode == RESULT_OK)&#123;</span><br><span class="line">				<span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= <span class="number">19</span>)&#123;<span class="comment">//4.4及以上</span></span><br><span class="line">					handleImageOnKitKat(data);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;<span class="comment">//4.4以下</span></span><br><span class="line">					handleImageBeforeKitKat(data);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.4及以上处理方式</span></span><br><span class="line"><span class="meta">@TargetApi</span>(<span class="number">19</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleImageOnKitKat</span><span class="params">(Intent data)</span></span>&#123;</span><br><span class="line">	String imagePath = <span class="keyword">null</span>;</span><br><span class="line">	Uri uri = data.getData();</span><br><span class="line">	<span class="comment">//如果是document类型Uri，则通过document id处理</span></span><br><span class="line">	<span class="keyword">if</span>(DocumentsContract.isDocumentUri(<span class="keyword">this</span>,uri))&#123;</span><br><span class="line">		String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">"com.android.providers.media.documents"</span>.equals(uri.getAuthority())&#123;</span><br><span class="line">			<span class="comment">//解析出数字格式的id</span></span><br><span class="line">			String selection = MediaStore.Images.Media._ID + <span class="string">"="</span> + id;</span><br><span class="line">			imagePath = getImagePaht(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,selection);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"com.android.providers.downloads.documents"</span>.equals(uri.getAuthority()))&#123;</span><br><span class="line">			Uri contentUri = ContentUris.withAppendedId(Uri.parse(<span class="string">"content://downloads/public_downloads"</span>),Long.valueOf(docId));</span><br><span class="line">			imagePath = getImagePath(contentUri,<span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"content"</span>.equalsIgnoreCase(uri.getScheme()))&#123;<span class="comment">//如果是content类型的uri，则使用普通方式处理</span></span><br><span class="line">		imagePath = getImagePath(uri,<span class="keyword">null</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"file"</span>.eualsIgnoreCase(uri.getScheme()))&#123;<span class="comment">//如果是file类型的uri，直接获取推按路径即可</span></span><br><span class="line">		imagePath = uri.getPath();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据路径显示图片</span></span><br><span class="line">	displayImage(imagePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.4以前处理方式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleImageBeforeKitKat</span><span class="params">(Intent data)</span></span>&#123;</span><br><span class="line">	Uri uri = data.getData();</span><br><span class="line">	<span class="comment">//因为他的Uri没有封装过的，不需要任何解析直接去获取真实路径即可</span></span><br><span class="line">	String imagePath = getImagePath(uri,<span class="keyword">null</span>);</span><br><span class="line">	displayImage(imagePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Uri和selection来获取真实的图片路径</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getImagePath</span><span class="params">(Uri uri,String selection)</span></span>&#123;</span><br><span class="line">	String path = <span class="keyword">null</span>;</span><br><span class="line">	Cursor cursor = getContentResolver().query(uri,<span class="keyword">null</span>,selection,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">if</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(cursor.moveToFirst())&#123;</span><br><span class="line">			path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));</span><br><span class="line">		&#125;</span><br><span class="line">		cursor.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据路径显示图片</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String imagePath)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(imagePath != <span class="keyword">null</span>)&#123;</span><br><span class="line">		Bitmap bitmap  = BitmapFactory.decodeFile(imagePath);</span><br><span class="line">		ivPicture.setImageBitmap(bitmap);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		Toast.makeText(<span class="keyword">this</span>,<span class="string">"failed to get image"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>因为照片是存在SD卡上的，所以我们首先进行权限处理，WRITE_EXTERNAL_STORAGE表示授予了对SD卡的读和写的能力。在onActivityResult回调中针对不同版本使用不同方式处理图片，因为从4.4开始，选取相册中的图片不再返回真实的Uri了，而是一个封装过的Uri，因此必须对这个Uri解析才行，在handleImageOnKitKat()方法中，如果返回的Uri是document类型的话，就取出document id进行处理，如果Uri的authority是media格式的话，document id还需要进行一次解析，要通过字符串分割的方式取出后半部分才能得到真正的数字id。</p>
<h2 id="播放多媒体文件"><a href="#播放多媒体文件" class="headerlink" title="播放多媒体文件"></a>播放多媒体文件</h2><p>播放音频和视频比较简单，没有兼容性等复杂问题，仅仅只需要记住：</p>
<ol>
<li><p>申请 WRITE_EXTENAL_STORAGE 权限</p>
</li>
<li><p>使用 MediaPlayer 播放音频结束时，在 onDestroy方法中要进行 MediaPlayer.stop() 和 MediaPlayer.release() ，将资源释放掉;</p>
</li>
<li><p>使用 VideoView 播放视频结束时，在 onDestroy方法中要进行 VideoView.suspend() ，将资源释放掉;</p>
</li>
</ol>
<p>其他内容略过。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-第一行代码（第二版）</tag>
      </tags>
  </entry>
  <entry>
    <title>第7章： 数据存储全方案——跨程序共享数据：探究内容提供器</title>
    <url>/2018/06/21/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
    <content><![CDATA[<p>可能你会有些疑惑，为什么要将我们程序中的数据共享给其他程序呢？当然，这是视情况而定的，比如账号密码之类的隐私数据显然是不能共享给其他程序的，不过一些可以让其他程序进行二次开发的基础性数据，我们还是可以选择共享。例如联系人程序、短信程序、多媒体库等，它们的数据库中保存了很多基础数据，如果不允许其他应用进行访问，则方便性就会大打折扣。</p><a id="more"></a>
<h3 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h3><p>Android的权限机制在一开始就存在，但是在6.0以前保护隐私方面比较有限，因为像微信这种大家都离不开的软件，容易“店大欺客”，不同意它所有的权限只能不安装，这并不合理。</p>
<h4 id="权限机制详解"><a href="#权限机制详解" class="headerlink" title="权限机制详解"></a>权限机制详解</h4><p>开发者在AndroidManifest.xml中声明权限，一种情况是，用户如果在低于6.0的系统上安装该程序，会在安装时列出该应用所需要的权限，从而决定是否要安装这个程序，并且在用户安装成功之后，还能在<strong>设置</strong>中查看程序所申请的权限，但是对于那些离不开的程序（比如微信）来说，要么全部同意它申请的权限，要么不安装，这不太合理；如果在6.0及以上的系统中安装，则用户不必在安装时一次性授权所有申请的权限，而是在软件使用的过程中再对<strong>危险权限</strong>进行授权，就算拒绝了这个权限，仍然可以使用应用的其他功能，而不是以前那样直接无法安装。</p>
<p>Android 6.0 及以上将所有权限分为两类，<strong>普通权限和危险权限</strong>，普通权限是指不会直接威胁用户的安全和隐私的权限，这部分权限系统自动帮我们授权，避免用户不停地手动授权；危险权限则表示会触及用户隐私或者设备安全性的权限，如获取联系人、定位设备位置等，必须由程序员动态申请，由用户手动点击授权才可以，否则无法使用相应功能。目前为止，Android中的危险权限有9组共24个权限，如下列表所示（图片来自<a href="https://developer.android.google.cn/guide/topics/security/permissions#normal-dangerous" target="_blank" rel="noopener">官网</a>）：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-7/%E5%9B%BE1.png" alt="危险权限列表"></p>
<p>这张表格无需记住，在使用的时候作为参照，如果权限在这张表中，则进行运行时处理就好。<strong>另外注意一下，表格中每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权了，那么该权限对应的权限组中所有的其他权限也会同时被授权</strong>。</p>
<h3 id="在程序运行时申请权限"><a href="#在程序运行时申请权限" class="headerlink" title="在程序运行时申请权限"></a>在程序运行时申请权限</h3><p>以拨打电话的权限为例来说明权限的申请，点击一个按钮，就拨打指定的号码，在6.0以前可能是这样实现的：</p>
<ol>
<li>在AndroidManifest.xml中申请权限：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CALL_PHONE"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>在代码中实现：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">btnCall.setOnclickListener(<span class="keyword">new</span> View.OnclickListener()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">		Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CALL);</span><br><span class="line">		intent.setData(Uri.parse(<span class="string">"tel:10086"</span>));</span><br><span class="line">		startActivity(Intent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在6.0以下系统上能正常拨打电话，但是在6.0或者以上系统运行，会报错<strong>Permission Denial</strong>，可以看出是由于权限被禁止导致的，因此我们应该尝试使用以下方式来申请权限：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">btnCall.setOnclickListener(<span class="keyword">new</span> View.OnclickListener()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(ContextCompat.checkSelfPermission(MainActivity.<span class="keyword">this</span>,Manifest.permission.CALL_PHONE) !=   </span><br><span class="line">		PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">			ActivityCompat.requestPermission(MainActivity.<span class="keyword">this</span>,<span class="keyword">new</span> </span><br><span class="line">			String[]&#123;Manifest.permission.CALL_PHONE&#125;,<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			call();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CALL);</span><br><span class="line">	intent.setData(Uri.parse(<span class="string">"tel:10086"</span>));</span><br><span class="line">	startActivity(Intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionResult</span><span class="params">(<span class="keyword">int</span> requestCode,String[] permissions,<span class="keyword">int</span>[] grantResults)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(requestCode)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">if</span>(grantResults.lenght &gt; <span class="number">0</span> &amp;&amp; grantResults(<span class="number">0</span>) == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">				call();</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				Toast.makeText(<span class="keyword">this</span>,<span class="string">"You denied the permission"</span>,Toast.LEGHTH_SHORT).show();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述第一步先判断用户是不是已经给我们授权了，使用的是<strong>ContextCompat.checkSelfPermission</strong>，如果已经授权，直接拨打电话，否则调用<strong>ActivityCompat.requestPermission</strong>方法向用户申请授权，这时候用户可以选择同意或者拒绝我们的申请，不论哪种结果，都会通过回调<strong>onRequestPermissionResult</strong>告知，在回调中根据不同的结果做不同的处理。<strong>记住，在动态声明权限后，AndroidManifest中还得添加<uses-permission android:name="android.permission.CALL_PHONE"> 声明</uses-permission></strong>。</p>
<h3 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h3><p>内容提供器的用法一般有两种，一是使用现有的内容提供器来读取和操作响应程序中的数据，另一种是创建自己的内容提供器给我们的数据提供外部访问接口。</p>
<h4 id="ContentResolver的基本使用"><a href="#ContentResolver的基本使用" class="headerlink" title="ContentResolver的基本使用"></a>ContentResolver的基本使用</h4><p>如果想要访问内容提供器共享的数据，就一定要借助ContentResolver类，可以通过Context中的getContentResolver方法获取到该类的实例。可以对内容进行CRUD操作，不同于SQLiteDatabase，ContentResolver增删改查不接收表名参数，而是使用Uri参数代替，该Uri主要由两部分组成：<strong>authority和path</strong>，前者用于对不同的应用程序做区分，一般采用程序包名形式，如某个程序的包名是com.example.app，那么对应的authority就可以命名为com.example.app.provider；path则是对同一应用程序中不同表做区分的，通常会添加到authority后面，所以内容Uri的形式一般如下所示(带协议声明)：</p>
<blockquote>
<p>content://com.example.app.provicer/table1<br>content://com.example.app.provicer/table2</p>
</blockquote>
<p>正式查询的时候，将Uri作为参数传入，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">"content://com.example.app.provicer/table1"</span>);</span><br><span class="line">Cuisor cursor = getContentResolver().query(uri,projection,selection,selectionArgs,sortOrder);</span><br></pre></td></tr></table></figure>

<p>其中，query方法中各个参数对应的含义如下所示：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-7/%E5%9B%BE2.png" alt="参数对应的含义"></p>
<p>接下来便可以进行相应的增删改查操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查</span></span><br><span class="line"><span class="keyword">if</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">	<span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">		String colomn1 = cursor.getString(cursor.getColumnIndex(<span class="string">"column1"</span>));</span><br><span class="line">		<span class="keyword">int</span> colomn2 = cursor.getInt(cursor.getColumnIndex(<span class="string">"column2"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增</span></span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"column1"</span>,<span class="string">"text"</span>);</span><br><span class="line">values.put(<span class="string">"column2"</span>,<span class="number">1</span>);</span><br><span class="line">getContentResolver().insert(uri,values);</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//改，把column1的值清空</span></span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"column1"</span>,<span class="string">""</span>);</span><br><span class="line">getContentResolver().update(uri,values,<span class="string">"column1 = ? and column2 = ?"</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"text"</span>,<span class="string">"1"</span>&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line">getContentResolver().delete(uri,<span class="string">"column2 = ?"</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>其实整体就相当于sql语句，因此并不太难。</p>
<h3 id="创建自己的内容提供器"><a href="#创建自己的内容提供器" class="headerlink" title="创建自己的内容提供器"></a>创建自己的内容提供器</h3><p>因为基本上没有这样的需求，暂时略后续补上</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-第一行代码（第二版）</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章：数据存储全方案：详解持久化技术</title>
    <url>/2018/06/11/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    <content><![CDATA[<p>Android系统主要提供了3种方式用于简单地实现数据持久化功能——文件存储、SharedPreference存储以及数据库存储。</p><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>文件存储是Android中最基本的存储方式，它不对存储内容进行任何的格式化处理，因而比较适合用于存储一些<strong>简单的文本数据</strong>或者<strong>二进制数据</strong>。</p><h3 id="将数据存储到文件"><a href="#将数据存储到文件" class="headerlink" title="将数据存储到文件"></a>将数据存储到文件</h3><p>Context类提供了一个openFileOutput()方法，可以用于将数据存储到指定文件，需要两个参数，第一个参数是文件名，纯粹的名称，不可以包含路径，因为所有的文件都是默认存储到<strong>/data/data/<packagename>/files/</packagename></strong>目录下；还有个参数是操作模式，主要有两种（其他2种在4.2被废弃了）：</p><a id="more"></a>


<ul>
<li>MODE_PRIVATE:默认的操作模式，表示当指定同样文件名的时候，所写入的内容将会覆盖原来文件中的内容。</li>
<li>MODE_APPEND:表示如果该文件已经存在，就往文件里面追加内容，不存在就创建新文件。</li>
</ul>
<p>保存文件的一般如以下代码操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String dataStr = <span class="string">"data to save"</span>;</span><br><span class="line">	FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">	BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="comment">//文件名是data</span></span><br><span class="line">		out = openFileOutput(<span class="string">"data"</span>,Context.MODE_PRIVATE);</span><br><span class="line">		writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out));</span><br><span class="line">		writer.write(dataStr);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;finnaly&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(writer != <span class="keyword">null</span>)&#123;</span><br><span class="line">				writer.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储成功后，可以通过Android Device Monitor 进入File Explorer标签，在目录中/data/data/<packagename>/files/中就能找到 data 文件。同理，读取存到文件中的代码应如下所示：</packagename></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">()</span></span>&#123;</span><br><span class="line">	FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">	BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">	StringBuilder content = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		in = openFileInput(<span class="string">"data"</span>);</span><br><span class="line">		reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">		String line = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">while</span>((line = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">			content.append(line);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;finnaly&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(reader != <span class="keyword">null</span>)&#123;</span><br><span class="line">				reader.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> content.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SharedPreference"><a href="#SharedPreference" class="headerlink" title="SharedPreference"></a>SharedPreference</h2><p>SharedPreference是使用键值对的方式来存储数据的，保存一条数据的时候，需要给这条数据提供一个对应的键，读取数据时通过这个键把对应的值读取出来，SharedPreference文件都是存放在/data/data/<packagename>/shared_prefs目录下。要想存储数据，首先要获取到SharedPreference对象，Android主要提供了3中方式：</packagename></p>
<ul>
<li><p>Context类中的getSharedPreference()方法：此方法接收两个参数，第一个用于指定文件名称，第二个用于指定操作模式，目前只有MODE_PRIVATE可选（其他的几种在4.2或者6.0版本被废弃了），并且是默认的操作模式，表示只有当前应用程序才可以对这个文件进行读写。</p>
</li>
<li><p>Activity中的getPreferences()方法：和Context类中的getSharedPreference()方法类似，只不过它只接受一个操作模式参数，因为使用这个方法时会自动将当前Activity的类名作为SharedPreference的文件名。</p>
</li>
<li><p>PreferenceManager类中的getDefaultSharedPreferences()方法：它接受一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreference文件。</p>
</li>
</ul>
<p>获取到SharedPreference对象之后，就可以开始存储数据了，主要分为3步实现：</p>
<ol>
<li>调用SharedPreference对象的edit()方法获取SharedPreference.Editor对象</li>
<li>向SharedPreference.Editor对象添加数据。</li>
<li>调用apply()方法提交，从而完成存储操作。</li>
</ol>
<p>代码形式应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SharedPreferences.Editor editor = getSharedPreferences(<span class="string">"data"</span>,MODE_PRIVATE).edit();</span><br><span class="line">editor.putString(<span class="string">"name"</span>,<span class="string">"Tom"</span>);</span><br><span class="line">editor.apply();</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储完成后，读取数据</span></span><br><span class="line">SharedPreferences pref = getSharedPreferences(<span class="string">"data"</span>,MODE_PRIVATE);</span><br><span class="line">String name = pref.getString(<span class="string">"name"</span>,<span class="string">""</span>);</span><br></pre></td></tr></table></figure>

<h2 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a>SQLite数据库存储</h2><p>文件存储和SharedPrefrences存储只适用于保存一些简单的数据和键值对，要存储大量复杂的关系型数据的时候，有点难以应付了。</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>Android为了让我们更方便地管理数据库，专门提供了一个SQLiteOpenHelper抽象类，要想使用的话，我们就需要创建一个自己的类去继承它，它有两个抽象方法，onCreate和onUpgrade用来创建和升级数据库，其它两个重要的实例方法：getReadableDatabase和getWritableDatabase，他们都可以创建或者打开一个现有的数据库（没有就创建），在数据库不可写入的时候（如磁盘满了），前者以只读的形式打开数据库，后者会出现异常。它有两个构造方法可重写，一般使用哪个参数较少的即可，总共4个参数，第一个context，第二个是数据库名，第三个是自定义的Cursor，一般传null，第四个表示当前的数据库版本号，用于对数据库进行升级操作。一般代码如下图所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CREATE_BOOK = <span class="string">"create table Book ("</span></span><br><span class="line">		+ <span class="string">"id integer primary key autoincrement,"</span></span><br><span class="line">		+ <span class="string">"author text,"</span></span><br><span class="line">		+ <span class="string">"price real,"</span></span><br><span class="line">		+ <span class="string">"pages integer,"</span></span><br><span class="line">		+<span class="string">"name text)"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span>&#123;</span><br><span class="line">			db.exeSQL(CREATE_BOOK);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候应该是这样子的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>,<span class="string">"BookStore.db"</span>,<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//就会创建成功了</span></span><br><span class="line">dbHelper.getWritableDatabase();</span><br></pre></td></tr></table></figure>

<p>上例创建了一个Book表，使用primary key 将id设置为主键，并用autoincrement关键字表示id是自增长的。可以使用</p>
<blockquote>
<p>adb shell</p>
</blockquote>
<p>命令，之后cd到/data/data/<packagename>/databases/目录下用<strong>ls</strong>列出该目录的文件，可以看到BookStore.db文件，以及BookStore.db-journal文件，后者是数据库的临时文件。SQLite没有其他数据库一样有很多繁杂的数据类型，它的数据类型很简单：<strong>integer表示整型，real表示浮点型，text表示文本，blob表示二进制类型</strong>；</packagename></p>
<h3 id="升级数据库"><a href="#升级数据库" class="headerlink" title="升级数据库"></a>升级数据库</h3><p>此时项目中有一张Book表用于存放输的各种详细数据了，但是如果再想添加一张Category表用于记录图书的分类，如果仅仅直接在MyDatabaseHelper的onCreate中写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span>&#123;</span><br><span class="line">	db.exeSQL(CREATE_BOOK);</span><br><span class="line">	db.exeSQL(CREATE_CATEGORY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是行不通的，因为使用的时候先初始化helper：<strong>dbHelper = new MyDatabaseHelper(this,”BookStore.db”,null,1)</strong>再获取数据库：<strong>dbHelper.getWritableDatabase()</strong>，而由于此时已经存在数据库BookStore.db了，因此不会再执行helper的onCreate方法了。此时清除app数据可以做到创建Category表，但是这在实际应用中不合理，而我们可以用<strong>onUpgrade</strong>方法来解决，我们前面构造了MyDatabaseHelper，第4个参数是版本号，我们目前是1，所以只要传入的值大于当前版本号1，onUpgrade方法就可以执行，因此我们可以这样增加Category表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db,<span class="keyword">int</span> oldVersion,<span class="keyword">int</span> newVersion)</span></span>&#123;</span><br><span class="line">		db.exeSQL(<span class="string">"drop table if exists Book"</span>);</span><br><span class="line">		db.exeSQL(<span class="string">"drop table if exists Category"</span>);</span><br><span class="line">		onCreate(db);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码执行了两条drop语句，发现数据库已经存在Book表和Category表了就删除，然后调用onCreate方法重新创建，因此在onCreate中也得写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span>&#123;</span><br><span class="line">	db.exeSQL(CREATE_BOOK);</span><br><span class="line">	db.exeSQL(CREATE_CATEGORY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时候也得升级版本号：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>,<span class="string">"BookStore.db"</span>,<span class="keyword">null</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//就会创建成功了</span></span><br><span class="line">dbHelper.getWritableDatabase();</span><br></pre></td></tr></table></figure>

<p>获取到数据库，接下来可以对其CRUD操作，其中C代表添加（Create），R代表查询（retrieve），U代表更新（Update），D代表删除（Delete）。Android开发者水平参差不齐，并非每一个都会SQL语言，Android提供了一系列的辅助性方法，是的在Android中即使不去编写SQL语句，也能轻松完成所有CRUD操作。getReadableDatabase与getWriteableDatabase方法不仅可以用来创建和升级数据库，他们还会返回一个SQLiteDatabase对象，借助这个对象就可以轻松CRUD：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**添加数据**/</span></span><br><span class="line">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"name"</span>,<span class="string">"thinking in java"</span>);</span><br><span class="line">values.put(<span class="string">"price"</span>,<span class="number">16.96</span>);</span><br><span class="line">values.put(<span class="string">"pages"</span>,<span class="number">512</span>);</span><br><span class="line"><span class="comment">//插入时指定表名为"Book"</span></span><br><span class="line">db.insert(<span class="string">"Book"</span>,<span class="keyword">null</span>,values);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**以下是更新**/</span></span><br><span class="line">values.clear();</span><br><span class="line">values.put(<span class="string">"price"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//第三个参数对应SQL语句中的where部分，表示更新所有name等于?的行，而?是一个占位符，</span></span><br><span class="line"><span class="comment">//可以通过第四个参数提供的一个字符串数组为第三个参数中的每个占位符指定相应内容</span></span><br><span class="line">db.update(<span class="string">"Book"</span>,values,<span class="string">"name=?"</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"thinking in java"</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**以下是删除**/</span></span><br><span class="line"><span class="comment">//表示删除pages的值大于500的数据</span></span><br><span class="line">db.delete(<span class="string">"Book"</span>,<span class="string">"pages &gt; ?"</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"500"</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**以下是查询**/</span></span><br><span class="line">Cursor cusor = db.query(<span class="string">"Book"</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span>(cursor.moveToFirst())&#123;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		String name = cursor.getString(cursor.getColumnIndex(<span class="string">"name"</span>));</span><br><span class="line">		String pages = cursor.Double(cursor.getColumnIndex(<span class="string">"price"</span>));</span><br><span class="line">	&#125;<span class="keyword">while</span>(cursor.moveToNext());</span><br><span class="line">&#125;</span><br><span class="line">cusor.close();</span><br></pre></td></tr></table></figure>

<p>当然，可以直接使用SQL语句直接完成上述操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//添加</span><br><span class="line">db.execSQL("<span class="keyword">insert</span> <span class="keyword">into</span> Book (<span class="keyword">name</span>,pages,price) <span class="keyword">values</span>(?,?,?)<span class="string">",new String[]&#123;"</span>thinking <span class="keyword">in</span> <span class="keyword">java</span><span class="string">","</span><span class="number">512</span><span class="string">","</span><span class="number">20</span><span class="string">"&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//升级</span></span><br><span class="line"><span class="string">db.execSQL("</span><span class="keyword">update</span> Book <span class="keyword">set</span> price = ? <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">",new String[]&#123;"</span><span class="number">20</span><span class="string">","</span>thinking <span class="keyword">in</span> <span class="keyword">java</span><span class="string">"&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//删除</span></span><br><span class="line"><span class="string">db.execSQL("</span><span class="keyword">delete</span> <span class="keyword">from</span> Book <span class="keyword">where</span> pages &gt; ?<span class="string">",new String[]&#123;"</span><span class="number">500</span><span class="string">"&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//查询</span></span><br><span class="line"><span class="string">db.execSQL("</span><span class="keyword">select</span> * <span class="keyword">from</span> Book<span class="string">",null);</span></span><br></pre></td></tr></table></figure>



<h2 id="使用LitePal"><a href="#使用LitePal" class="headerlink" title="使用LitePal"></a>使用LitePal</h2><p><strong>略</strong></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-第一行代码（第二版）</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章： 全局大喇叭：详解广播机制</title>
    <url>/2018/06/10/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    <content><![CDATA[<h3 id="广播机制介绍"><a href="#广播机制介绍" class="headerlink" title="广播机制介绍"></a>广播机制介绍</h3><p>Android中广播分为<strong>标准广播</strong>和<strong>有序广播</strong>，标准广播是一种完全异步执行的广播，广播发出后，所有广播接收器机会会在同一时刻接收到广播，但同时意味着它也是无法被截断的。有序广播是一种同步执行的广播，同一时刻只有一个广播接收器能收到这条消息，当这个广播接收器的逻辑执行完毕之后才会继续传递，优先级高的广播接收器可以先收到广播，并且还可以阶段正在传递的广播，这样后面的广播接收器就收不到这条广播消息。</p><a id="more"></a>
<h4 id="动态注册和静态注册广播"><a href="#动态注册和静态注册广播" class="headerlink" title="动态注册和静态注册广播"></a>动态注册和静态注册广播</h4><p>动态注册一般在Activity的onCreate方法中写上类似于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">receiver = <span class="keyword">new</span> MyReceiver();</span><br><span class="line">registerReceiver(receiver,filter);</span><br></pre></td></tr></table></figure>

<p>并且在onDestroy方法中注销广播：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; unregisterReceiver(receiver);</span><br></pre></td></tr></table></figure>

<p>然后，完善一般是内部类的MyReceiver：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context,Intent intent)</span></span>&#123;</span><br><span class="line">		Toast.makeText(context,<span class="string">"receive the broadcast"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后得在适当的时候发送广播：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p><strong>当然，如果你是用广播在APP中实现强制退出登录（如QQ账号在另一台设备上登录了），那你只需要在当前Activity上弹一个窗提示已经被强制下线即可，因此有必要将广播在BaseActivity中注册，并且在BaseActivity的onPause方法（注意不是onDestroy方法了，因为我们只需要栈顶的Activity能够响应就行）中注销广播即可。如果是接收系统级广播，可能还得在AndroidManife.xml中声明相关权限</strong>。APP中实现强制退出登录时的广播接收器可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForceOfflineReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(<span class="keyword">final</span> Context context,Intent intent)</span></span>&#123;</span><br><span class="line">		AltertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(context);</span><br><span class="line">		builder.setTitle(<span class="string">"warning"</span>);</span><br><span class="line">		builder.setMessage(<span class="string">"force offline"</span>);</span><br><span class="line">		builder.setCancelable(<span class="keyword">false</span>);</span><br><span class="line">		builder.setPositiveButton(<span class="string">"ok"</span>,<span class="keyword">new</span> DialogInterface.OnclickListener()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onclick</span><span class="params">(DialogInterface dialog,<span class="keyword">int</span> which)</span></span>&#123;</span><br><span class="line">				ActivityCollector.finishAll();<span class="comment">//销毁所有活动</span></span><br><span class="line">				Intent intent = <span class="keyword">new</span> Intent(context,LoginActivity.class);</span><br><span class="line">				context.startActivity(intent);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>静态注册广播是在AndroidManife.xml中做如下的声明，<strong>其中MyReceiver类一般不是内部类，因为即使app未启动也能接收广播</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:label</span>=<span class="string">"@string/appname"</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:name</span>=<span class="string">".MyReceiver"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.MyReceiver"</span></span></span><br><span class="line"> &lt;/receiver&gt;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果要发送有序广播，只需要将以上发送广播的代码<strong>sendBroadcast(intent)</strong>替换成<strong>sendOrderedBroadcast(intent,null);</strong>即可。设置广播的优先级只需要设置intentFilter的priority属性即可（AndroidManifest文件中是intent-filter属性）。</p>
<h3 id="使用本地广播"><a href="#使用本地广播" class="headerlink" title="使用本地广播"></a>使用本地广播</h3><p>前面发送的广播属于系统全局广播，发出的广播可以被任何应用接收到，并且我们也可以接受来自其它任何应用发出的广播，这容易引起安全性问题，比如关键数据广播被其他应用截获，或者其他应用发送各种垃圾广播。本地广播的发送有些不同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalBroadcastManager manager = LocalBroadcastManager.getInstance(<span class="keyword">this</span>);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">manager.sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p>注册：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(<span class="string">"com.example.MyReceiver"</span>);</span><br><span class="line">localReceiver = <span class="keyword">new</span> LocalReceiver();</span><br><span class="line">manager.registerReceiver(localReceiver,filter);</span><br></pre></td></tr></table></figure>
<p>同样注销广播：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">manager.unregisterReceiver(localReceiver);</span><br></pre></td></tr></table></figure>

<p>本地广播的几点优势：</p>
<ul>
<li>可以明确地知道正在发送的广播不会离开我们的程序，因此不必担心机密数据泄露。</li>
<li>其他的程序无法将广播发送到我们程序内部，因此不用担心会有安全漏洞隐患。</li>
<li>发送本地广播比发送系统全局广播更加高效。</li>
</ul>
<p><strong>另有一点需要说明：本地广播是无法通过静态注册方式来接收的，其实这也完全可以理解，因为静态注册主要就是为了让程序在未启动的情况下也能接收广播，而发送本地广播时，我们的程序肯定是已经启动了；此外，不要再onReceive方法中添加过多的逻辑或者进行任何耗时的操作，因为广播接收器中是不允许开启线程的，当onReceive方法运行了较长时间而没有结束时，程序就会报错。因此它更多的只是扮演一种打开程序其他组件的角色，如弹一条通知，或者启动一个服务等。</strong></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-第一行代码（第二版）</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章：手机平板要兼顾：探究fragment</title>
    <url>/2018/06/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    <content><![CDATA[<p>这一章前面部分主要讲解Fragment的基本使用，这点我觉得官方文档关于fragment的知识可能会更好一些，以下是官方的阐述：</p><p>主要是平时使用Fragment时，对其使用方法有疑惑，以下或许能解释部分：</p><h3 id="为什么使用Fragment"><a href="#为什么使用Fragment" class="headerlink" title="为什么使用Fragment"></a>为什么使用Fragment</h3><p><strong>参考自官方</strong>：主要是为了在大屏幕手机（如平板电脑）上更加零落的UI设计，可以更方便地组合和交换UI组件。</p><a id="more"></a>


<h3 id="Fragment的创建"><a href="#Fragment的创建" class="headerlink" title="Fragment的创建"></a>Fragment的创建</h3><p>想为Fragment提供布局，则必须实现onCreateView()回调，可以通过xml定义布局资源，为此，onCreateView()提供了一个LayoutInflater对象：</p>
<pre><code>public static class ExampleFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.example_fragment, container, false);
    }
}</code></pre><h3 id="向Activity中添加Fragment"><a href="#向Activity中添加Fragment" class="headerlink" title="向Activity中添加Fragment"></a>向Activity中添加Fragment</h3><h4 id="1、在Activity的布局文件中声明："><a href="#1、在Activity的布局文件中声明：" class="headerlink" title="1、在Activity的布局文件中声明："></a>1、在Activity的布局文件中声明：</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;horizontal&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;fragment android:name=&quot;com.example.ListFragment&quot;
            android:id=&quot;@+id/list&quot;
            android:layout_weight=&quot;1&quot;
            android:layout_width=&quot;0dp&quot;
            android:layout_height=&quot;match_parent&quot; /&gt;

    &lt;fragment android:name=&quot;com.example.AticleFragment&quot;
            android:id=&quot;@+id/viewer&quot;
            android:layout_weight=&quot;2&quot;
            android:layout_width=&quot;0dp&quot;
            android:layout_height=&quot;match_parent&quot; /&gt;
&lt;/LinearLayout&gt;</code></pre><blockquote>
<p><strong>官方解释</strong>:Activity初始化布局时，会实例化布局中指定的每个fragment，并为每个Fragment调用onCreateView()方法，系统会直接插入Fragment返回的View来替代<fragment>元素。</fragment></p>
</blockquote>
<h4 id="2、通过编程方式将Fragment添加到某个现有的ViewGroup："><a href="#2、通过编程方式将Fragment添加到某个现有的ViewGroup：" class="headerlink" title="2、通过编程方式将Fragment添加到某个现有的ViewGroup："></a>2、通过编程方式将Fragment添加到某个现有的ViewGroup：</h4><p>可以在Activity运行期间将Fragment添加进去，你只需要指定Fragment要放入哪个ViewGroup，这需要使用FragmentTransaction：</p>
<pre><code>FragmentManager fragmentManager = getFragmentManager();
FragmentTransaction transaction = fragmentManager.beginTransaction();</code></pre><p>然后，你可以使用add()方法添加一个fragment：</p>
<pre><code>ExampleFragment fragment = new ExampleFragment();
transaction.add(R.id.fragment_container,fragment);
transaction.commit();</code></pre><blockquote>
<p>一旦通过FragmentTransaction做出了更改，就必须commit以使更改生效。</p>
</blockquote>
<h4 id="3、添加没有UI的Fragment："><a href="#3、添加没有UI的Fragment：" class="headerlink" title="3、添加没有UI的Fragment："></a>3、添加没有UI的Fragment：</h4><p>你可以使用Fragment为Activity提供后台行为，而不显示额外的UI。使用函数：</p>
<pre><code>add(Fragment,String)</code></pre><p>String类型参数为Fragment提供一个唯一的字符串标记，由于Fragment没有雨Activity中的视图关联，因此不会收到onCreate()调用，因此你可以不实现这个方法。如果你稍后想从Activity中获取到这个Fragment，可以使用findFragmentByTag()。</p>
<blockquote>
<p>可以在SDK的sample中查看具体用法：<sdk_root>/APIDemos/app/src/main/java/com/example/android/apis/app/FragmentRetainInstance.java </sdk_root></p>
</blockquote>
<h3 id="执行Fragment事务"><a href="#执行Fragment事务" class="headerlink" title="执行Fragment事务"></a>执行Fragment事务</h3><p>需要使用FragmentTransaction，可以使用：</p>
<pre><code>add() 、remove() 、replace()</code></pre><p>等方法设置想要执行的更改，然后commit生效。</p>
<p>不过在commit之前你可能想调用 addToBackStack()将其添加到Fragment事务返回栈，允许用户按返回键返回上一Fragment状态。</p>
<p>来个例子：</p>
<pre><code>/**create new fragment and transaction**/

Fragment newFragment = new ExampleFragment();
FragmentTransaction transaction = getFragment().beginTransaction();

/**Replace whatever is in the fragment_container view with this fragment
and add the transaction to the back stack**/

transaction.replace(R.id.fragment_container,newFragment);
transaction.addToBackStack(null);

//commit the transaction
transaction.commit();</code></pre><p>向FragmentTransaction添加更改的顺序无关紧要，但有一些注意事项：</p>
<blockquote>
<p>commit操作不会立即执行，而是等主线程认为可以执行的时候再运行，不过，如果有必要，你也可以从主线程调用executePendingTransactions() 以立即执行commit。</p>
</blockquote>
<blockquote>
<p>最后必须调用commit，而且只能在用户离开Activity之前commit，否则会引发异常，如果对于需要commit的更改无关紧要，可以使用commitAllowingStateLoss()。</p>
</blockquote>
<blockquote>
<p>可以向同一个容器中添加多个fragment，你添加的顺序决定他们在视图层次结构中出现的顺序。</p>
</blockquote>
<h3 id="管理Fragment"><a href="#管理Fragment" class="headerlink" title="管理Fragment"></a>管理Fragment</h3><p>需要使用FragmentManager，你可以使用它执行以下操作：</p>
<ul>
<li><p>findFragmentById() （<strong>对于在Activity布局中提供UI的Fragment</strong>）或者findFragmentByTag()（<strong>对于提供或者不提供UI的Fragment都可</strong>）。</p>
</li>
<li><p>popBackStack() (<strong>模拟用户发出的返回命令</strong>)，将Fragment从返回栈中弹出。</p>
</li>
<li><p>addOnBackStackChangedListener() 监听返回栈变化</p>
</li>
</ul>
<h3 id="与Activity通信"><a href="#与Activity通信" class="headerlink" title="与Activity通信"></a>与Activity通信</h3><p>Fragment可以通过getActivity()访问Activity实例，并轻松执行诸如在Activity布局中查找视图等任务：</p>
<pre><code>View listView = getActivity().findViewById(R.id.list);</code></pre><p>同样，Activity也可以使用findFragmentById 或者 findFragmentByTag,通过从FragmentManager获取Fragment的引用来调用Fragment中的方法：</p>
<pre><code>ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);</code></pre><h3 id="一个应用场景例子"><a href="#一个应用场景例子" class="headerlink" title="一个应用场景例子"></a>一个应用场景例子</h3><p>一个新闻应用中Activity两个Fragment，Fragment A放列表list，Fragment B 放对应内容，那么A在列表项选定后，告诉Activity，以便Activity通知B显示该新闻。其方案可以这样设计：</p>
<p>在A中声明接口OnArticleSelectedListener ：</p>
<pre><code>public static class FragmentA extends ListFragment {
    ...
    // Container Activity must implement this interface
    public interface OnArticleSelectedListener {
        public void onArticleSelected(Uri articleUri);
    }
    ...
}</code></pre><p>同事在Activity中实现接口OnArticleSelectedListener，在A的onAttach方法时判断Activity是否这样做了：</p>
<pre><code>public static class FragmentA extends ListFragment {
    OnArticleSelectedListener mListener;
    ...
    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        try {
            mListener = (OnArticleSelectedListener) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException(activity.toString() + &quot; must implement OnArticleSelectedListener&quot;);
        }
    }
    ...
}</code></pre><p>当有点击事件的时候，A看起来是这样子的：</p>
<pre><code>public static class FragmentA extends ListFragment {
    OnArticleSelectedListener mListener;
    ...
    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        // Append the clicked item&apos;s row ID with the content provider Uri
        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);
        // Send the event and Uri to the host activity
        mListener.onArticleSelected(noteUri);
    }
    ...
}</code></pre><p>Fragment的生命周期如下图：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-4/fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="fragment生命周期"></p>
<p>其中将fragment进行至fragment的resume状态（即可以跟用户交互）的核心序列如下：</p>
<ul>
<li><p>onAttach(Activity) ：activity与fragment关联的时候调用.</p>
</li>
<li><p>onCreate(Bundle) ：fragment初始化的时候调用.</p>
</li>
<li><p>onCreateView(LayoutInflater, ViewGroup, Bundle) ：为fragment创建返回view界面.</p>
</li>
<li><p>onActivityCreated(Bundle): 通知fragment它绑定的那个Activity已经执行完了onCreate()操作.</p>
</li>
<li><p>onViewStateRestored(Bundle)： 通知fragment它保存的view state已经被恢复了.</p>
</li>
<li><p>onStart()： fragment对用户可见 (还要取决于包含这个fragment的activity是否已经启动了).</p>
</li>
<li><p>onResume()： 使fragment可以和用户交互了 (还要取决于包含这个fragment的activity是否已经resume了).<br>如果一个fragment不再使用了，它会执行一系列相反的过程:</p>
</li>
<li><p>onPause()： fragment不能与用户交互（可能是由于activity的pause）。 </p>
</li>
<li><p>onStop()： fragment不可见了（可能是由于activitystop了）。</p>
</li>
<li><p>onDestroyView()：通知fragment清理与它相关的view资源。</p>
</li>
<li><p>onDestroy()：在完全清理fragment的状态时调用。</p>
</li>
<li><p>onDetach()：当fragment与activity解除绑定时调用。</p>
</li>
</ul>
<h3 id="动态加载布局的技巧"><a href="#动态加载布局的技巧" class="headerlink" title="动态加载布局的技巧"></a>动态加载布局的技巧</h3><h4 id="使用限定符"><a href="#使用限定符" class="headerlink" title="使用限定符"></a>使用限定符</h4><p>如果使用平板就会发现里面的应用基本上是双页模式，但是在手机上限于屏幕大小，都是单页模式。如果判断该使用双页模式还是单页模式，这就要借助<strong>限定符（qualifiers）</strong>来实现了，我们可以有两个布局文件，一个 layout_single.xml 单页模式布局放在layout目录，一个 layout_double.xml 双页模式布局放在 layout-large 目录，其中的large是个限定符。Android中常用限定符如下：<br><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-4/%E9%99%90%E5%AE%9A%E7%AC%A61.png" alt="android限定符1"><br><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-4/%E9%99%90%E5%AE%9A%E7%AC%A62.png" alt="android限定符2"></p>
<h4 id="使用最小限定符"><a href="#使用最小限定符" class="headerlink" title="使用最小限定符"></a>使用最小限定符</h4><p>前面解决了单页双页模式，但是到底怎么才算large，我们需要更精确地控制的话，需要最小限定符。我们新建layout-600dp文件夹，将双页布局文件放入其中，这样就会意味着，当程序运行在宽度小于600dp的设备上时，显示的是单页布局，否则使用的是双页布局。</p>
<p>以上两种技巧可以将手机版和pad版都使用同一个app，避免维护多个app，一处改动，需要在两个app中同步改动。注意在代码中区别目前是双页模式还是单页模式，可以用以下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(findViewById(R.id.anotherpageid) == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//单页</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//双页</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中R.id.anotherpageid是在单页中所没有的那个布局的id。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-第一行代码（第二版）</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章：软件和也要拼脸蛋</title>
    <url>/2018/06/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<p>布局文件中如果添加Button，并指定其text为”button”的话，但是显示的是”BUTTON”，全部变为大写了，要去掉这一效果，可以添加属性<strong>android:textAllCaps=”false”</strong></p><p>RelativeLayout 中还有另外一组对于控件进行定位的属性，android:layout_alignLeft表示让一个控件的左边缘和另一个控件的左边缘对齐，同理，还有android:layout_alignRight、Top、Bottom 。</p><a id="more"></a>

<h3 id="创建自定义控件"><a href="#创建自定义控件" class="headerlink" title="创建自定义控件"></a>创建自定义控件</h3><p>我们所用的所有控件都是直接或者间接继承自View的，所有的布局都是直接或者间接继承ViewGroup，View是Android中最基本的一种UI组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是在View的基础上添加各自特有功能；而ViewGroup则是一种特殊的View，它可以包含很多子View和子ViewGroup，是一个防止控件和布局的容器。常用控件和布局的继承结构如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-3/%E5%9B%BE1.png" alt="view继承关系"></p>
<p>App中的标题栏几乎在每个界面都是一样的，除了标题不一样，其他的诸如左边按钮点击就finish当前页面，右边的是菜单按钮，这些功能基本上一样，如果在每个页面都单独为这些按钮重复添加相同的监听，比较繁琐。所以可以将标题栏单独封装成单独的一个TitleLayout的，每次只需要引入到布局中即可。</p>
<h3 id="使用listview"><a href="#使用listview" class="headerlink" title="使用listview"></a>使用listview</h3><p>可以继承ArrayAdapter简化操作，类似如下(当然，这里在getView的时候没有进行复用优化，仅仅只是示例)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Fruit</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> resourceId;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FruitAdapter</span><span class="params">(Context context,<span class="keyword">int</span> resourceId,List&lt;Fruit&gt; objects)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(context,resourceId,objects);</span><br><span class="line">		<span class="keyword">this</span>.resourceId = resourceId;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position,View convertView,ViewGroup parent)</span></span>&#123;</span><br><span class="line">		Fruit fruit = getItemt(position);</span><br><span class="line">		View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,<span class="keyword">false</span>);</span><br><span class="line">		ImageView ivFruit = view.findViewById(R.id.img);</span><br><span class="line">		TextView tvFruit = view.findViewById(R.id.txt);</span><br><span class="line">		ivFruit.setImageResource(fruit.getImageId());</span><br><span class="line">		tvFruit.setText(fruit.getName());</span><br><span class="line">		<span class="keyword">return</span> view;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用更强大的RecyclerView"><a href="#使用更强大的RecyclerView" class="headerlink" title="使用更强大的RecyclerView"></a>使用更强大的RecyclerView</h3><p>在设置LayoutManager的时候，可以指定排布的方向比如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinearLayoutManager manager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">manager.setOrientation(LinearLayoutManager.HORIZONTAL);<span class="comment">//平时一般使用竖直方向，这里特意指定横向</span></span><br></pre></td></tr></table></figure>

<p>为什么Listview很难或者根本无法实现这种效果呢，其实这主要得益于RecyclerView的出色设计，ListView的布局排列是由自身去管理的，，而RecyclerView则将这个工作交给了LayoutManager，LayoutManager指定了一套可扩展的布局排列接口，自雷只要按照接口的规范来实现，就能定制出不同排列方式的布局了。</p>
<p>实现点击事件，可以在Adapter中的<strong>onCreateViewHolder</strong>方法中来做到，诸如以下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent,<span class="keyword">int</span> viewType)</span></span>&#123;</span><br><span class="line">	View view = LayoutInflater.from(parent.getContext).inflate(R.layout.fruit_item,parent,<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">final</span> ViewHolder holder = <span class="keyword">new</span> ViewHolder(view);</span><br><span class="line">	holder.ivFruit.setOnclickListener(<span class="keyword">new</span> View.OnclickListener()&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">			<span class="keyword">int</span> postion = holder.getAdapterPosition();</span><br><span class="line">			<span class="comment">//doSomeThing you want</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-第一行代码（第二版）</tag>
      </tags>
  </entry>
  <entry>
    <title>Intent 传递的数据过大</title>
    <url>/2018/06/07/Intent%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7/</url>
    <content><![CDATA[<p>这个问题源于最近做的项目中出现的bug，一个Activity A通过startActivity(intent)的方式（intent中携带了String类型的data）启动另一个Activity B时，发生了崩溃，查看错误日志如下：</p><p><img src="/assets/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/intent%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97.png" alt="启动Activity时的错误日志"></p><p>可以看到，这是 <strong>android.os.TransactionTooLargeException</strong> ，字面意思是事务太大。这就很好理解了，因为笔者使用了intent携带数据，在事后分析这个data在传入的时候大约50k，因此导致了这个问题。后来使用<strong>SharedPreference</strong>将数据捎带过去解决了问题，这个bug本身看懂了报错就很简单，因此不再赘述。后面有空有兴趣之后再补上分析Intent传递数据到底是多大的限制。</p>]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Listview 中 CheckBox 状态错误问题原因及解决方案</title>
    <url>/2018/06/05/listview%E6%90%AD%E9%85%8Dcheckbox%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在开发过程中碰到很多问题，有些问题在锤子便签中记录了一个概要，有的问题甚至连记录都没有，此次开个头，将碰到的问题记录下来。</p><p>今天要写的问题跟Listview有关，顺便复习下ListView的相关复用机制，以及Listview的Adapter中getView方法为什么需要ViewHolder，是怎么提高加载效率的。下面开始进入回忆状态，事情的经过是这样的：</p><a id="more"></a>

<p>在平时的 Android 开发过程中，我们可能需要去实现以下效果：</p>
<p><img src="/assets/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/listview%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98/%E5%9C%BA%E6%99%AF.png" alt="使用场景"></p>
<p>在 Listview 中使用CheckBox，但是会碰到 CheckBox 选中/非选中 这种状态错乱的问题，笔者最近在项目中就碰到了，比如我选中了 id0、id1、id2 三个 CheckBox ，再想选择 id15 ，这就要求滑动 Listview 了，滑到 id15 CheckBox 将其选中，再滑动到顶部，握草，发现 id0、id1、id2 已经变成 非选中 状态了，莫非是我记错了？再重新来一次，还是一样！这就不科学了，一定是哪里出了问题，我当时的代码是这样的：</p>
<pre><code>@Override
public View getView(final int i, View view, ViewGroup viewGroup) {
    ViewHolder viewHolder = null;
    if(view == null){
        viewHolder = new ViewHolder();
        view = LayoutInflater.from(context).inflate(R.layout.layout,null);
        viewHolder.cb = (CheckBox) view.findViewById(R.id.select_cb);
        viewHolder.tvName = (TextView) view.findViewById(R.id.name_tv);
        view.setTag(viewHolder);
    }else{
        viewHolder = (ViewHolder) view.getTag();
    }
    viewHolder.cb.setChecked(data.get(i).isSlected());
    viewHolder.tvName.setText(data.get(i).getName());
    viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
        @Override
        public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked)     {
            data.get(i).setSlected(isChecked);
        }
    });
    return view;
}</code></pre><p>脑子里第一反应是各处的 item 串了，联想到使用 viewholder 来复用 item ，于是就去了解了一番 Listview 对 item 的复用机制。</p>
<h3 id="复用机制"><a href="#复用机制" class="headerlink" title="复用机制"></a>复用机制</h3><p>我们知道，listview 需要承载大量的数据，并且需要写一个 Adapter 与其适配，这样数据就能展现出来了，但是不知道大家有没有仔细想过，为什么需要 Adapter 这个东西，它到底起了个什么作用。</p>
<h5 id="从-Adapter-说起"><a href="#从-Adapter-说起" class="headerlink" title="从 Adapter 说起"></a>从 Adapter 说起</h5><p>说到底，Android 中控件就是为了展示数据以及交互用，只不过Listview特殊些，它用于展示大量的信息的，但是 Listview 只承担交互和展示工作的，至于数据来自哪里，它不care。这样，listview工作最基本需要一个 Listview 控件和一个数据源，但是数据源可能是数组，可能是集合，甚至可能是数据库表中查询出来的游标，如果 Listview 要去为每一种数据源进行匹配的话，它一定会变得非常臃肿了，于是 Adapter 出现了。</p>
<p>顾名思义，Adapter 是适配器的意思，它在 Listview 与数据源之间起了一个桥梁作用，与之前的情况不同的是，Adapter 的接口都是统一的，因此 Listview 不需要担心任何适配问题。而 Adapter 是个接口（interface），它可以有各种子类，比如 ArrayAdapter 可用于数组和 List 类型的数据源匹配，SimpleCursorAdapter 可以用于游标类型的数据源匹配，这样把适配问题解决了，并且扩展性不错。</p>
<h5 id="RecycleBin-类"><a href="#RecycleBin-类" class="headerlink" title="RecycleBin 类"></a>RecycleBin 类</h5><p>在解释复用机制之前，还有必要说一下 RecycleBin 类，因为它是 Listview 能够展现成百上千条数据并且不会 OOM 的关键，RecycleBin 是 AbsListview 的一个内部类，其主要代码如下：</p>
<pre><code>/**
 * The RecycleBin facilitates reuse of views across layouts. The RecycleBin
 * has two levels of storage: ActiveViews and ScrapViews. ActiveViews are
 * those views which were onscreen at the start of a layout. By
 * construction, they are displaying current information. At the end of
 * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews
 * are old views that could potentially be used by the adapter to avoid
 * allocating views unnecessarily.
 */
class RecycleBin {
    private RecyclerListener mRecyclerListener;

    /**
     * The position of the first view stored in mActiveViews.
     */
    private int mFirstActivePosition;

    /**
     * Views that were on screen at the start of layout. This array is
     * populated at the start of layout, and at the end of layout all view
     * in mActiveViews are moved to mScrapViews. Views in mActiveViews
     * represent a contiguous range of Views, with position of the first
     * view store in mFirstActivePosition.
     */
    private View[] mActiveViews = new View[0];

    /**
     * Unsorted views that can be used by the adapter as a convert view.
     */
    private ArrayList&lt;View&gt;[] mScrapViews;

    private int mViewTypeCount;

    private ArrayList&lt;View&gt; mCurrentScrap;

    /**
     * Fill ActiveViews with all of the children of the AbsListView.
     * 
     * @param childCount
     *            The minimum number of views mActiveViews should hold
     * @param firstActivePosition
     *            The position of the first view that will be stored in
     *            mActiveViews
     */
    void fillActiveViews(int childCount, int firstActivePosition) {
        if (mActiveViews.length &lt; childCount) {
            mActiveViews = new View[childCount];
        }
        mFirstActivePosition = firstActivePosition;
        final View[] activeViews = mActiveViews;
        for (int i = 0; i &lt; childCount; i++) {
            View child = getChildAt(i);
            AbsListView.LayoutParams lp = (AbsListView.LayoutParams)     child.getLayoutParams();
            // Don&apos;t put header or footer views into the scrap heap
            if (lp != null &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                // Note: We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in
                // active views.
                // However, we will NOT place them into scrap views.
                activeViews[i] = child;
            }
        }
    }

    /**
     * Get the view corresponding to the specified position. The view will
     * be removed from mActiveViews if it is found.
     * 
     * @param position
     *            The position to look up in mActiveViews
     * @return The view if it is found, null otherwise
     */
    View getActiveView(int position) {
        int index = position - mFirstActivePosition;
        final View[] activeViews = mActiveViews;
        if (index &gt;= 0 &amp;&amp; index &lt; activeViews.length) {
            final View match = activeViews[index];
            activeViews[index] = null;
            return match;
        }
        return null;
    }

    /**
     * Put a view into the ScapViews list. These views are unordered.
     * 
     * @param scrap
     *            The view to add
     */
    void addScrapView(View scrap) {
        AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
        if (lp == null) {
            return;
        }
        // Don&apos;t put header or footer views or views that should be ignored
        // into the scrap heap
        int viewType = lp.viewType;
        if (!shouldRecycleViewType(viewType)) {
            if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                removeDetachedView(scrap, false);
            }
            return;
        }
        if (mViewTypeCount == 1) {
            dispatchFinishTemporaryDetach(scrap);
            mCurrentScrap.add(scrap);
        } else {
            dispatchFinishTemporaryDetach(scrap);
            mScrapViews[viewType].add(scrap);
        }

        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }

    /**
     * @return A view from the ScrapViews collection. These are unordered.
     */
    View getScrapView(int position) {
        ArrayList&lt;View&gt; scrapViews;
        if (mViewTypeCount == 1) {
            scrapViews = mCurrentScrap;
            int size = scrapViews.size();
            if (size &gt; 0) {
                return scrapViews.remove(size - 1);
            } else {
                return null;
            }
        } else {
            int whichScrap = mAdapter.getItemViewType(position);
            if (whichScrap &gt;= 0 &amp;&amp; whichScrap &lt; mScrapViews.length) {
                scrapViews = mScrapViews[whichScrap];
                int size = scrapViews.size();
                if (size &gt; 0) {
                    return scrapViews.remove(size - 1);
                }
            }
        }
        return null;
    }

    public void setViewTypeCount(int viewTypeCount) {
        if (viewTypeCount &lt; 1) {
            throw new IllegalArgumentException(&quot;Can&apos;t have a viewTypeCount &lt; 1&quot;);
        }
        // noinspection unchecked
        ArrayList&lt;View&gt;[] scrapViews = new ArrayList[viewTypeCount];
        for (int i = 0; i &lt; viewTypeCount; i++) {
            scrapViews[i] = new ArrayList&lt;View&gt;();
        }
        mViewTypeCount = viewTypeCount;
        mCurrentScrap = scrapViews[0];
        mScrapViews = scrapViews;
    }

}</code></pre><ul>
<li><p>注释说 RecycleBin 用于view的reuse，它维持了两个存储空间，ActiveViews 和 ScrapViews，前者存放显示在屏幕上的view，到列表最后的时候，它里面的view都会去到 ScrapViews 中。而后者用于存放 old views ，这些view可能可以直接以convertView的形式直接利用，避免没必要的 allocat 内存，这就是Adapter中convertView的由来。</p>
</li>
<li><p>fillActiveViews() :这个方法会根据传入的参数来将 Listview 中指定的元素存储到 mActiveViews 数组中。</p>
</li>
<li><p>getActiveView() :跟 fillActiveViews 方法对应，用于从 mActiveViews 中获取数据，需要注意的是，一旦第 position 个数据被获取成功之后，该view就会从 mActiveViews 中移除，下次再获取第position个位置将会返回 null，也就是说mActiveViews不能复用。</p>
</li>
<li><p>addScrapView() :用于将一个废弃的view进行缓存，当一个view要废弃的时候（比如滚出屏幕），就调用该方法缓存，以便下次使用。</p>
</li>
<li><p>getScrapView() :从 ScrapViews 中取出一个view，这些废弃缓存中的view是没有顺序可言的，因此取的算法也非常简单，获取尾部的就行。</p>
</li>
<li><p>setViewTypeCount() :我们知道在 adapter 中我们可以重写 getViewTypeCount() 来表示Listview中有几种类型的数据项，而setViewTypeCount()的作用就是为每种类型的数据项都单独启用一个 RecycleBin 缓存机制。</p>
</li>
</ul>
<h5 id="扯点view的绘制"><a href="#扯点view的绘制" class="headerlink" title="扯点view的绘制"></a>扯点view的绘制</h5><p>Listview 再牛逼，也是继承自view的，而view的执行流程就是3步，onMeasure() 用于测量 view 的大小，onLayout() 用于确定 View 的布局，onDraw() 用于将 view 绘制到界面上。</p>
<p>Listview 最特殊的地方在于 onLayout() ,而这是在它父类 AbsListview 中实现的，它主要就一个重要判断：如果 Listview 的大小或者位置发生了变化，那就要求所有子布局强制重绘。而 layoutchildren() 方法是用来进行子元素布局的，具体由 Listview 自己实现，可以解析下。</p>
<p>刚开始，Listview 中没有任何子view，因此会去调用 fillActiveViews() 方法，这是为了将 Listview 中的子 view 进行缓存的，由于此时子 view 为空，因此会调用 fillFromTop() ，最终调用到 fillDown() 方法，进行 Listview 的填充操作。fillDown() 中有个while循环，当遍历完从 Listview 顶部到底部的距离的item或者 adapter 中的数据遍历结束，while就跳出。在while中，执行 makeAndAddView() ，它会尝试从 RecycleBin 中快速获取 active view ，但此时 RecycleBin 中还未缓存任何view，因此获得null，所以就会尝试调用 obtainView() ，它是可以保证返回一个 view 的，于是将获取到的view立刻传入到了 setupChild() 中。</p>
<p>那到底 obtainView() 怎么保证获取到view的？不夸张地说，Listview 中最重要的内容都在 obtainView() 中了，该方法里首先调用了 RecycleBin 的 getScrapView() 方法尝试获取一个废弃缓存中的 view ，当然这时候是获取不到的，得到null，之后再调用 mAdapter 的 getView() 方法来获取一个 view ，这时候似曾相识了，有 adapter 和 getView() 方法了，对，就是我们平常写的那个 adapter，然后重写的那个 getView(),这时候会传入 position，convertView (此时为null)，parent (当然是 this 了)。</p>
<h5 id="捋一下item的复用"><a href="#捋一下item的复用" class="headerlink" title="捋一下item的复用"></a>捋一下item的复用</h5><p>一切从 onLayout 开始，当大小或者位置发生了变化，就会调用onLayout，onLayout完毕之后，就剩下 ondraw 去绘制了。onLayout中，（为了叙述方便，不考虑数据不足以填满Listview的情况），首先要拿item的view放到Listview中，先从ActiveViews中拿，如果为空，则打算从 ScrapViews 中拿，还是为空，则利用 adapter 去创造，创造一屏 itemview 填充于 ActiveViews 中，之后 Listview 从 ActiveViews 中取出 itemview ，ActiveViews 删除该 itemview ，如果 itemview 滑动隐藏了，就会丢弃到 ScrapViews 中，这样滑动的时候触发 onLayout ，onLayout 再去找 itemview 填充，如果有现成的就用，没有就创造。 </p>
<h3 id="分析源码谈原因"><a href="#分析源码谈原因" class="headerlink" title="分析源码谈原因"></a>分析源码谈原因</h3><p>再来看源码，为了更方便，加上toast提示：</p>
<pre><code>@Override
public View getView(final int i, View view, ViewGroup viewGroup) {
    ViewHolder viewHolder = null;
    if(view == null){
        viewHolder = new ViewHolder();
        view = LayoutInflater.from(context).inflate(R.layout.layout,null);
        viewHolder.cb = (CheckBox) view.findViewById(R.id.select_cb);
        viewHolder.tvName = (TextView) view.findViewById(R.id.name_tv);
        view.setTag(viewHolder);
    }else{
        viewHolder = (ViewHolder) view.getTag();
    }
    viewHolder.cb.setChecked(data.get(i).isSlected());
    viewHolder.tvName.setText(data.get(i).getName());
    viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
        @Override
        public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked)     {

        Toast.makeText(context,&quot;这是点击了第&quot; + i + &quot;个&quot; ,Toast.LENGTH_SHORT).show();
            data.get(i).setSlected(isChecked);
        }
    });
    return view;
}</code></pre><p>运行之后我们看到整个列表，选中第1个，会弹toast “这是点击了第0个” 接着往上慢慢滑动，直至将第一个item隐藏的时候，发现 toast 弹出来了，显示 <strong>这是点击了第0个</strong>！而这个时候最下面之前被第一条隐藏的item也展现出来了，综合上面的知识，可以知道，这个隐藏的item是复用了第1个item的view，复用view的时候，由于该隐藏item是<strong>未checked</strong>，而第一条item是<strong>已经checked</strong>，因此它执行     </p>
<blockquote>
<p>viewHolder.cb.setChecked(data.get(i).isSlected());</p>
</blockquote>
<p>的时候，会触发 OnCheckedChangeListener ，由于之前第一个 item 设置了监听：</p>
<pre><code>viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            @Override
            public void onCheckedChanged(CompoundButton compoundButton, boolean     isChecked)     {

            Toast.makeText(context,&quot;这是点击了第&quot; + i + &quot;个&quot; ,Toast.LENGTH_SHORT).show();
                data.get(i).setSlected(isChecked);
            }
        });</code></pre><p>这时候就触发了监听事件，因此toast就弹出来了，并且把第一条item的数据也由checked改成unchecked，因此你下次再见到第一个item的时候，状态就变成unchecked了。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>最后可以说结论了，这个现象是由于listview中item复用导致，如果你不用viewholder是不会有这问题的，其实这个结论并不重要，重要的是理解这里面的发生机制。当然，说了问题起因，当然得给个解决方案，方法不止一种，我个人用的一种方法是在</p>
<blockquote>
<p>viewHolder.cb.setChecked(data.get(i).isSlected());</p>
</blockquote>
<p>之前添加一句：</p>
<blockquote>
<p>viewHolder.cb.setOnCheckedChangeListener(null);</p>
</blockquote>
<p>我想你肯定知道为什么。</p>
<p><strong>注：参考（引用）以下博客劳动成果：</strong></p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/44996879" target="_blank" rel="noopener">郭霖 ： Android ListView工作原理完全解析，带你从源码的角度彻底理解</a></p>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章：先从看得到的入手</title>
    <url>/2018/06/01/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="Intent使用"><a href="#Intent使用" class="headerlink" title="Intent使用"></a>Intent使用</h2><p>显式地就不说了，使用隐式的Intent时并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，并帮我们找出合适的活动去启动。</p><h3 id="普通的隐式Intent使用"><a href="#普通的隐式Intent使用" class="headerlink" title="普通的隐式Intent使用"></a>普通的隐式Intent使用</h3><p>比如在AndroidManifest.xml中声明activity的时候，可以添加：</p><a id="more"></a>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.ACTION_START"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在代码中就能以下面代码来启动这个activity了（由于category是DEFAULT，所以在intent中并未指定category了）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.ACTION_START"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>如果在AndroidManifest.xml中声明activity的时候同时指定了<strong>action</strong>和<strong>category</strong>，那么必须要在Intent中严格匹配才能打开，否则可能报错，比如写成：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.ACTION_START"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"com.example.MY_CATEGORY"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>则代码中必须添加以下代码才能正确运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.ACTION_START"</span>);</span><br><span class="line">**intent.addCategory(<span class="string">"com.example.MY_CATEGORY"</span>);**</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h3 id="更多隐式Intent用法"><a href="#更多隐式Intent用法" class="headerlink" title="更多隐式Intent用法"></a>更多隐式Intent用法</h3><p>使用隐式的Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，比如说要在应用程序中点击一个按钮，然后要在浏览器中打开一个网页，则使用以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"http://www.baidu.com"</span>));</span><br><span class="line">startActivity(Intent);</span><br></pre></td></tr></table></figure>

<p>这里面，setData()接收一个Uri对象，主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传入到Uri.parse()方法中解析产生的。那如果我们要自己写个浏览器应用，让其它应用也能像这样利用我们的APP打开网页，又该怎么做呢，这就要求在<intent-filter>中添加一个&lt;data标签&gt;，用于更精确地指定当前活动能够响应什么类型的数据。<data>标签中可以配置以下内容：</data></intent-filter></p>
<ul>
<li>android:scheme。用于指定数据的协议部分，例如上例中的http部分。</li>
<li>android:host。用于指定数据的主机名部分，如上例中的<a href="http://www.baidu.com。" target="_blank" rel="noopener">www.baidu.com。</a></li>
<li>android:port。用于指定数据的端口部分。</li>
<li>android:path。用于指定主机名和端口之后的部分。</li>
</ul>
<p>所以，如果我们要做一个浏览器，至少要在AndroidManifest.xml对主activity声明：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.ACTION_START"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下次其他APP需要用http协议打开网页时，我们的APP也会在候选列表中了。除了http协议意外，我们还可以指定很多其他协议，比如<strong>geo</strong>表示地理位置、<strong>tel</strong>表示拨打电话。</p>
<h2 id="活动的生命周期"><a href="#活动的生命周期" class="headerlink" title="活动的生命周期"></a>活动的生命周期</h2><ul>
<li>onCreate()，活动第一次被创建的时候调用，应该在这里面完成活动的初始化操作。</li>
<li>onStart()，在活动由不可见变为课件的时候调用。</li>
<li>onResume()，在活动准备好和用户进行交互的时候调用，此时活动一定位于返回栈的栈顶，并且处于运行状态。</li>
<li>onPause()，在系统准备去启动或者恢复另一个活动的时候调用，通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但是工作不能太多，不然会影响下一个Activity的使用。</li>
<li>onStop(),活动完全不可见的时候调用，它和onPause主要的区别在于，如果启动的新活动是一个对话框式的活动，那么onPause方法会得到执行，而onStop不会执行。</li>
<li>onDestroy()，活动晓辉之前调用。</li>
<li>onRestart()，由停止状态变为运行状态之前调用。一般是由上一个活动返回到当前活动。</li>
</ul>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-2/%E5%9B%BE1.png" alt="Activity声明周期"></p>
<h3 id="活动回收了怎么办"><a href="#活动回收了怎么办" class="headerlink" title="活动回收了怎么办"></a>活动回收了怎么办</h3><p>想象以下场景，应用中有活动A，在A的基础上启动活动B，活动A此时进入了停止状态，此时由于内存不足，将活动A回收了，然后用户按Back键返回活动A，会出现什么情况呢？其实还是会正常显示A，只不过这是并不会执行onRestart方法，而是会执行活动A的onCreate方法，因为活动A在这种情况下会被重新创建一次。</p>
<p>如果A进程中有输入框，并且已经输入了一些文字了，如果回收被重新创建，那么会丢失输入的信息，影响用户体验。Activity中还提供了一个onSaveInstanceState()回调方法，这个方法可以保证在活动回收之前一定会被调用，这个方法会携带一个Bundle类型的参数，它允许以key-value的形式存取值，我们可以这样将要保存的数据存下来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">        outState.putString(<span class="string">"name"</span>,<span class="string">"glassx"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>数据已经保存下来了，但是在哪里恢复呢？其实我们一直使用的onCreate方法其实也有一个Bundle类型的参数，这个参数一般情况下是null，如果在活动呗系统回收之前有通过onSaveInstanceState保存的话，这个参数就会带有之前所保存的全部数据，因此通过以下方法取即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(savedInstanceState != <span class="keyword">null</span>)&#123;</span><br><span class="line">        	String name = savedInstanceState.getString(<span class="string">"glassx"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h2><p>在实际项目中我们应该根据特定的需求为每个活动指定恰当的启动模式，启动模式一种四种：<strong>standard、singleTop、singleTask、singleInstance</strong>。</p>
<ul>
<li><p>standard是默认的启动模式。每次启动都会创建一个新的实例。</p>
</li>
<li><p>singleTop：有些情况下，可能会觉得standard不太合理，活动明明已经在栈顶了，为毛还要再创建新的实例呢？singleTop模式可以解决这个问题，当活动以该模式启动时，如果发现返回栈的栈顶已经是该活动，那就直接使用它，不创建新的实例，并且调用栈顶实例的<strong>onNewIntent</strong>方法；如果栈顶不是该活动，就创建该活动的新的实例。</p>
</li>
<li><p>singleTask：如果活动的启动模式指定为singleTask，那么每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果有，把这个活动之上的所有活动统统出栈，并且直接使用该实例，并调用该实例的<strong>onNewIntent</strong>方法？？（存疑，等会实践下）。反之没有的话就创建该活动的实例。</p>
</li>
<li><p>singleInstance：指定为singleInstance模式的活动会启用一个新的返回栈来管理这个活动（其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈）。</p>
<blockquote>
<p>那么这样做有什么意义呢？想象以下场景，我们的程序中有一个活动是允许其他程序调用的，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，应该如何实现呢？前面3中模式做不到，因为每个应用程序都会有自己的返回栈，同一个活动在不同的返回栈中入栈必然是创建了新的实例。而使用singleInstance模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活动，不管哪个应用来访问这个活动，都公用一个返回栈，也就解决了共享活动实例的问题。</p>
</blockquote>
</li>
</ul>
<p><strong>注意：如果三个活动，A和C都是standard模式，B是singleInstance模式，那么A启动B，B启动C后，在C界面按返回键是回退到A，再按返回键回退到B，接着按返回键才会退出应用，因为A和C是同一个回退栈中，B单独在一个栈中，可以用如下图来理解这一过程</strong>。</p>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-2/%E5%9B%BE2.png" alt="Activity声明周期"></p>
<h2 id="活动的最佳实践"><a href="#活动的最佳实践" class="headerlink" title="活动的最佳实践"></a>活动的最佳实践</h2><h3 id="知晓当前是在哪一个活动"><a href="#知晓当前是在哪一个活动" class="headerlink" title="知晓当前是在哪一个活动"></a>知晓当前是在哪一个活动</h3><p>建一个BaseActivity，在onCreate的时候打印出来当前实例的类名，之后其他的activity都继承这个activity即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        </span><br><span class="line">        Log.d(<span class="string">"BaseActivity"</span>,getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="随时随地退出app"><a href="#随时随地退出app" class="headerlink" title="随时随地退出app"></a>随时随地退出app</h3><p>如果你在第三个activity界面，这个时候想要退出App是非常不方便的，可以新建一个类来管理所有Activity：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityController</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Activity&gt; activities = <span class="keyword">new</span> ArrayList&lt;Activity&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addActivity</span><span class="params">(Activity ac)</span></span>&#123;</span><br><span class="line">		activities.add(ac);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeActivity</span><span class="params">(Activity ac)</span></span>&#123;</span><br><span class="line">		activities.remove(ac);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finishAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Activity ac : activities)&#123;</span><br><span class="line">			ac.finish();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样只需要在BaseActivity的onCreate里面执行ActivityController的<strong>addActivity</strong>方法，即可把Activity添加进去，在BaseActivity的onDestroy方法中执行<strong>removeActivity</strong>，将其移除，在需要退出app的时候，只需要执行finishAll即可。</p>
<h3 id="启动活动最佳写法"><a href="#启动活动最佳写法" class="headerlink" title="启动活动最佳写法"></a>启动活动最佳写法</h3><p>每个Activity中都写上启动自己的方法：</p>
<pre><code class="Java">
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span></span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">actionStart</span><span class="params">(Context context,String name,String sex)</span></span>{
        Intent intent  = <span class="keyword">new</span> Intent(context,TestActivity.class);
        intent.putExtra(<span class="string">"name"</span>,name);
        intent.putExtra(<span class="string">"sex"</span>,sex);
        context.startActivity(intent);
    }
}</code></pre>
<p>这样做的一个好处就是，启动这个activity所需要的参数一目了然，而无需阅读这个activity的源码就可以直接调用方法就能避免漏掉参数。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-第一行代码（第二版）</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章：开启启程</title>
    <url>/2018/05/31/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h4 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h4><ol>
<li><p>最底层是Linux内核层。</p>
<blockquote>
<p>为Android设备各种硬件提供了底层驱动，如显示驱动，音频驱动等。</p>
</blockquote>
</li>
<li><p>系统运行库层。</p>
<blockquote>
<p>这层通过一些C/C++库来为Android系统提供主要的特性支持。如Sqlite库提供了数据库支持，OpenGL|ES提供提供3D绘图等。</p>
</blockquote>
</li>
<li><p>应用框架层。</p>
<blockquote>
<p>主要提供了构建应用程序可能用到的各种API。</p>
</blockquote>
</li>
<li><p>应用层。</p>
<blockquote>
<p>所有安装在手机上的应用程序都属于这一层。比如系统自带的联系人、短信等程序，自己开发的应用。</p>
</blockquote>
</li>
</ol><a id="more"></a>
<p><img src="/assets/Book-Notes/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/chapter-1/%E5%9B%BE1.png" alt="Android系统层次"></p>
<h3 id="Android应用开发特色"><a href="#Android应用开发特色" class="headerlink" title="Android应用开发特色"></a>Android应用开发特色</h3><h4 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h4><p>四大组件分别是活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）和内容提供器（Content Provider）</p>
<p>build.gradle 文件中，<strong>compileSdkVersion</strong>用于指定项目的编译版本；<strong>buildToolsVersion</strong>用于指定项目构建工具的版本；<strong>applicationId</strong>用于指定项目的包名，并且它的优先级高于在 AndroidManifest.xml<br>中指定的包名；<strong>minSdkVersion</strong>用于指定项目最低兼容的Android版本;<strong>targetSdkVersion</strong>表明你在该目标版本上做过了充分的测试，系统将为你的应用程序启用一些最新的功能和特性。比如说Android6.0 系统中引入了运行时权限这个功能，如果你将targetSdkVersion指定成23或者更高，那么系统就会为你的程序启用运行时权限功能；否则就不会启用运行时权限功能。</p>
<p>而在build.gradle的<strong>dependencies</strong>闭包中，声明了当前项目所有的依赖关系，Android studio 项目一共有3中依赖方式，本地依赖、库依赖和远程依赖，本地依赖可以对本地的jar包或者目录添加依赖关系，形式如：<strong>compile fileTree(dir: ‘libs’, include: [‘*.jar’])</strong>；库依赖可以对项目中的库模块添加依赖关系，如<strong>compile(name: ‘testsdk’, ext: ‘aar’)</strong>；远程依赖则可以对jcenter库上的开源项目添加依赖关系，如<strong>compile ‘com.android.support.constraint:constraint-layout:1.0.2’</strong>，其中，com.android.support.constraint是域名，用于和其他公司的库作区分，constraint-layout是组名称，用于和同一个公司其他库作区分。</p>
<p><strong>关于日志：</strong>不用System.out.println()，因为Log系统可以对日志分级，可以展示打印时间，可以添加过滤器等等。<strong>Log快捷键：如果要打Log.d，则输入logd，按tab键即可，同理Log.i只需要logi之后按Tab键，以此类推，四种级别的日志都能快捷打出来。还有，如果在oncreate方法外面输入logt，然后按下Tab键，就会以当前的类名作为值自动生成一个类似下面的TAG常量：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"HelloWorldActivity"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-第一行代码（第二版）</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章：死锁</title>
    <url>/2018/05/30/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-%E7%AC%AC6%E7%AB%A0/</url>
    <content><![CDATA[<p>如果有两个进程A和B需要将扫描的文档记录到CD上，进程A请求扫描仪并被授权使用，请求CD时发现已被B占用了，于是被拒绝，同理，B请求扫描仪也会被拒绝，于是产生<strong>死锁</strong>。在一个数据库系统中，为了避免竞争，可对若干记录加锁，如果进程A对R1加锁了，进程B对R2加了锁，接着这两个进程又试图把各自对方的记录也加锁，这是也会产生死锁。所以，<strong>软硬件资源都可能出现死锁</strong>。</p><a id="more"></a>
<h2 id="资源和死锁条件"><a href="#资源和死锁条件" class="headerlink" title="资源和死锁条件"></a>资源和死锁条件</h2><p><strong>资源</strong>分为两类，一类是<em>可抢占资源（preemptable resource）</em> 可以从拥有它的进程中枪战而不产生任何副作用，比如存储器。一个系统拥有256M的用户内存和一条打印机，如果有两个256M内存的进程都想打印，进程A获得了打印机，而B战友内存，但是幸运的是可以通过把进程B患处内存、把进程A换入内存可以实现抢占B的内存，这样，进程A继续运行并执行打印任务，然后释放打印机和内存。另一类是<em>不可抢占资源（nonpreemptable resource）</em>是指在不引起相关的计算失败的情况下，无法把它从占有它的进程中抢占过来，如CD刻录机。如果一个进程已经在开始刻盘，突然将刻录机分配给另一个进程，那么将划坏CD盘。</p>
<p>因此，总的来说，死锁和不可抢占资源有关，有关可抢占资源的潜在死锁通常可以通过在进程之间重新分配资源而化解，所以我们主要关注不可抢占资源上。当然，Coffman等人总结了发生（资源）死锁需要具备四个必要条件：</p>
<ul>
<li><p><strong>不可抢占</strong>。</p>
<blockquote>
<p>已经分配给一个进程的资源不能强制性地被抢占，他只能被占有它的进程显式地释放。</p>
</blockquote>
</li>
<li><p><strong>互斥条件。</strong></p>
<blockquote>
<p>每个资源要么已经分配了一个进程，要么就是可用的。</p>
</blockquote>
</li>
<li><p><strong>占有和等待</strong>。</p>
<blockquote>
<p>已经得到了某个资源的进程还可以再请求新的资源。</p>
</blockquote>
</li>
<li><p><strong>环路等待</strong>。</p>
<blockquote>
<p>死锁发生时，系统中一定有由两个或者以上的进程组成一条环路，该环路中每个进程都在等待着下一个进程所占有的资源。</p>
</blockquote>
</li>
</ul>
<p><strong>注意：死锁发生时，以上四个条件一定是同时满足的。任何一个不成立就不会发生死锁</strong></p>
<h2 id="死锁建模"><a href="#死锁建模" class="headerlink" title="死锁建模"></a>死锁建模</h2><p>在讨论死锁解决方案之前，讨论如何对死锁建模是有意义的。有个叫Holt的人指出可以利用有向图建立死锁四个条件的模型——在有向图中有两类节点：用圆形表示进程，用方形表示资源。从资源节点到进程节点的有向边代表该资源已被请求、授权并被进程占用，由进程节点到资源节点的有向边表明当前进程正在请求该资源。以下是一个示意图：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE1.png" alt="死锁建模示意图"></p>
<p>图中，当前资源R整备进程A占用，进程B正等待着资源S，图c)进入了死锁状态，进程C等待着资源T，资源T被进程D占用，进程D又等待着由进程C占用的资源U。</p>
<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><p>总而言之，有四种处理死锁的策略：</p>
<ul>
<li><p>忽略该问题。也许如果你忽略它，他也会忽略你。</p>
</li>
<li><p>检测死锁并恢复。</p>
<blockquote>
<p>让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题。</p>
</blockquote>
</li>
<li><p>仔细对资源进行分配，动态地避免死锁。</p>
</li>
<li><p>破坏引起死锁的四个必要条件之一，防止死锁产生。</p>
</li>
</ul>
<p>以下对这四种策略分别阐述。</p>
<h3 id="忽略问题"><a href="#忽略问题" class="headerlink" title="忽略问题"></a>忽略问题</h3><p>最简单的方法是<strong>鸵鸟算法：</strong>把头埋进沙子里，假装根本没有问题发生。不同人对于该方法的看法不同，数学家认为这种方法不能接受，不管代价多大，都要彻底防止死锁产生；而对于工程师，它们会考量死锁发生的频率和严重性，如果平均5年一次死锁，那么大多数工程师不会以性能损失和可用性代价去防止死锁。</p>
<h3 id="检测死锁和死锁恢复"><a href="#检测死锁和死锁恢复" class="headerlink" title="检测死锁和死锁恢复"></a>检测死锁和死锁恢复</h3><h4 id="每种类型一个资源的死锁检测"><a href="#每种类型一个资源的死锁检测" class="headerlink" title="每种类型一个资源的死锁检测"></a>每种类型一个资源的死锁检测</h4><p>从最简单的例子开始，假定每种类型的资源只有一个，即排除了同时有两台打印机的情况。我们假设一个系统包括A到G共7个进程，R到W共6中资源，资源的占有情况和进程对资源的请求情况如下：<br>（1）A进程持有R资源，且需要S资源。<br>（2）B进程不持有任何资源，但需要T资源。<br>（3）C进程不吃油任何资源，但需要S资源。<br>（4）D进程持有U资源，且需要S资源和T资源。<br>（5）E进程持有T资源，且需要V资源。<br>（6）F进程持有W资源，且需要S资源。<br>（7）G进程持有V资源，且需要U资源。</p>
<p><strong>问：系统是否存在死锁？如果存在，涉及哪些进程？</strong></p>
<p>回答这一问题，初看很难，但是建模构造一张资源分配图之后，可以直观地看到图中包含了一个环，如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE2.png" alt="对问题建模"></p>
<p>在换种，可以看出进程D、E、G已经死锁，A、C、F没有死锁，因为可以把资源S分配给它们中的任意一个。</p>
<h4 id="每种类型有多个资源的死锁检测"><a href="#每种类型有多个资源的死锁检测" class="headerlink" title="每种类型有多个资源的死锁检测"></a>每种类型有多个资源的死锁检测</h4><p>如果一类资源可能存在多个，就需要采用另一个方法来检测死锁。现在我们提供一种基于矩阵的算法来检测从P1到Pn这n个进程中的死锁。假设资源类型数为m，E1代表资源类型1，E2代表资源类型2，以此类推。E是<strong>现有资源向量</strong>，代表每种已存在的资源总数，比如资源类型1代表磁带机，那么E1=2就表示系统有两台磁带机。</p>
<p>在任意时刻，某些资源已被分配所以不可用，假设A是<strong>可用资源向量</strong>，那么Ai表示当前可供使用的资源数（即没有被分配的资源）。如果仅有的两台磁带机都已经分配出去了，那么A1的值为0 。</p>
<p>现在我们需要两个数组：C代表当前<strong>当前分配矩阵</strong>，R代表<strong>请求矩阵</strong>。C的第i行代表Pi当前所持有的每一种类型资源的资源数，所以Cij代表进程i所持有的资源j的数量，同理Rij代表Pi所需要的资源j的数量，数据结构如下图：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE3.png" alt="矩阵数据结构"></p>
<p>这四种数据结构之间有一个重要的恒等式，具体地说，某种资源要么已分配，要么可用，这个结论意味着：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE4.png" alt="资源等式"></p>
<p>换言之，如果我们将所有已分配的资源j的数量加起来在和所有可供使用的资源数相加，结果就是该类资源的资源总数。死锁检测算法就是给予向量的比较，我们定义向量A和向量B之间的关系为A小于或等于B以表明A的每一个分量要么等于要么小于和B向量对应的分量。</p>
<p>每个进程起初是没有被标记的，算法开始会对进程做标记，进程被标记后就表明它们能够被执行，不会进入死锁，死锁检测算法如下：</p>
<ol>
<li>寻找一个没有标记的进程Pi，对于它而言，R矩阵的第i行向量小于或等于A。</li>
<li>如果找到了这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转到第1步。</li>
<li>如果没有这样的进程，算法终止。</li>
</ol>
<p>算法的第1步是寻找可以运行完毕的进程，该进程有资源请求并且该请求可被当前的可用资源满足。这一选中的进程随后就被运行完毕，在这段时间内它释放自己持有的所有资源并将它们返回到可用资源库中，然后，这一进程被标记为完成，如果所有的进程最终都能运行完的话，就不存在死锁，如果进程一直不能被运行，那它们就是死锁进程。</p>
<h4 id="从死锁恢复"><a href="#从死锁恢复" class="headerlink" title="从死锁恢复"></a>从死锁恢复</h4><p>我们讨论各种从死锁中恢复的方法，尽管这些方法看起来都不那么令人满意：</p>
<ul>
<li><p>利用抢占恢复。</p>
<blockquote>
<p>临时将资源从当前所有者哪里转移到另一个进程，许多情况下这是需要人工敢于的。比如，要将激光打印机从它持有的进程那里拿走，管理员可以收集已打印好的文档，然后该进程被挂起，接着打印机被分配给另一个进程。</p>
</blockquote>
</li>
<li><p>利用回滚恢复。</p>
<blockquote>
<p>周期性地将进程的状态写入一个文件以备重启。一旦检测到死锁，拥有所需要资源的进程会回滚到一个时间点，在此时间点之前该进程获得了一些其他资源，在该检查点之后所做的工作都丢失。实际上，是将该进程复位到一个更早的状态，那时候它还没取得所需的这个资源。接着就把这个资源分配给一个死锁进程。</p>
</blockquote>
</li>
<li><p>杀死进程恢复。</p>
<blockquote>
<p>杀死环中的一个进程。或者杀死环外带有该资源的一个进程。</p>
</blockquote>
</li>
</ul>
<h3 id="动态避免死锁"><a href="#动态避免死锁" class="headerlink" title="动态避免死锁"></a>动态避免死锁</h3><p>利用资源轨迹图、安全状态和不安全状态、银行家算法去解决。这里略复杂，暂时先不深入研究。</p>
<h3 id="破坏引起死锁的四个条件之一"><a href="#破坏引起死锁的四个条件之一" class="headerlink" title="破坏引起死锁的四个条件之一"></a>破坏引起死锁的四个条件之一</h3><ul>
<li><p>破坏互斥条件，如果资源不被一个进程独占，那么死锁肯定不会产生。</p>
<blockquote>
<p>当然，允许两个进程同时使用打印机会造成混乱，通过采用<strong>假脱机（spooling printer）</strong>技术可以允许若干个进程同时产生输出。该模型中唯一真正请求使用物理打印机的进程是打印机守护进程，由于守护进程绝不会请求其他资源，因此不会产生死锁。</p>
</blockquote>
</li>
<li><p>破坏占有和等待条件。只要禁止已持有资源的进程再等待其他资源便可以消除死锁。</p>
<blockquote>
<p>一种实现方法是规定所有进程在开始执行前请求所需的全部资源。如果所需的全部资源可用，那么就将它们分配给这个进程，于是该进程肯定能够运行结束。如果一个或者多个资源正被使用，那么就不分配，进程等待。<strong>另一种</strong>方案是，要求当一个进程请求资源时，先暂时释放其当前占用的所有资源，然后再尝试一次获得所需要的全部资源。</p>
</blockquote>
</li>
<li><p>破坏不可抢占条件。</p>
<blockquote>
<p>假如一个进程已分配到一台打印机且正在进行打印输出，如果由于它需要的绘图仪无法获得而强制性把打印机抢占掉，则会引起混乱。但是，一些资源可以通过虚拟化的形式来避免发生这样的情况，假脱机打印机向磁盘输出，并且只允许打印机守护进程访问真正的物理打印机，就可以消除涉及打印机的死锁。<strong>然而，不是所有资源都可以进行类似的虚拟化，比如数据库中的记录在操作的时候必须要锁定，因此存在死锁的可能</strong></p>
</blockquote>
</li>
<li><p>破坏环路等待。</p>
<blockquote>
<p>消除环路有几种方法。比较靠谱的方案是，对所有的资源统一编号，现在的规则是，进程可以在任何时刻提出资源请求，但是所有请求必须按照资源编号的顺序（升序）提出，如下图所示，进程可以先请求打印机后请求磁带机，但不可以先请求绘图仪后请求打印机。</p>
</blockquote>
</li>
</ul>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE5.png" alt="资源排序"></p>
<p><strong>最后，总结一张图用于预防死锁：</strong></p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-6/%E5%9B%BE6.png" alt="预防死锁的方法汇总"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-现代操作系统（第三版）</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章：进程与线程</title>
    <url>/2018/05/29/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-%E7%AC%AC2%E7%AB%A0/</url>
    <content><![CDATA[<p>进程是操作系统提供的最古老也是最重要的抽象概念之一。即使CPU只有一个，但他们也支持（伪）并发操作的能力。他们将一个单独的CPU变换成多个虚拟的CPU，没有进程的抽象，现代计算将不复存在。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>在任何多道程序设计系统中，CPU由一个进程快速切换到另一个进程，使每个进程各运行几十或者几百个毫秒，严格地来说，在某一个瞬间，CPU只能运行一个进程，但在1秒钟期间，它可能运行多个进程，这样就能产生并行的错觉，这就是伪并行。伪并行概念用来区分<strong>多处理器系统</strong>（系统有两个或者更多CPU并共享同一个物理内存）的真正硬件并行。</p><a id="more"></a>

<h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><p>一个进程就是一个正在执行的程序的实例，包括程序计数器、寄存器和变量当前值。从概念上讲，每个进程拥有它自己的CPU，当然，真正的CPU在各进程间来回切换，这种快速的切换称作<strong>多道程序设计</strong>。在多道程序计算机内存中有若干道程序，这些程序被抽象为若干个各自拥有自己控制流程（即每个程序自己的逻辑程序计数器）的进程，并且每个程序都独立地运行。当然，实际上只有一个物理程序计数器，所以程序运行时，它的逻辑程序计数器被装入实际的程序计数器，当该程序结束（或暂停）执行时，物理程序计数器被保存在内存中该进程的逻辑程序计数器中。</p>
<p>由于CPU在各进程之间来回快速切换，所以每个进程执行器运算的速度是不确定的，并且当同一进程再次运行时，器运算速度通常也不可再现。例如，考虑一个 I/O 进程，它执行一个10000次的空循环以等待磁带机达到正常速度，然后发出命令读取第一个记录。如果CPU决定在空循环期间切换到其他进程，则磁带机进程可能在第一条记录通过磁头之后还未被再次执行。</p>
<p>进程和程序间的却别是微妙的，但是非常重要。想象以为父亲正在为他的女儿烘制生日蛋糕，则做蛋糕的食谱就是程序（即用适当形式描述的算法），这位父亲是处理器（CPU），而做蛋糕各种原料（面粉、糖、鸡蛋等）就是输入的数据，<strong>进程就是他阅读食谱、取各种原料以及烘制蛋糕等一系列动作的总和</strong>。现假设他的儿子被蜜蜂蛰了哭着跑进来，父亲于是就记录下当前照着食谱做到哪里了（保存进程当前状态），拿出急救手册，为儿子处理蜇伤，我们看到处理机从一个进程（做蛋糕）切换到另一个优先级高的进程（医疗救治），每个进程有各自的程序（食谱和急救手册）。当急救完成之后，父亲又继续做蛋糕，从离开时的那一步继续做下去。值得注意的是，我们可能经常两次去启动同一个字处理软件，即一个程序运行了两遍，这也要算作两个进程。</p>
<h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>有4中主要事件导致进程创建：</p>
<ul>
<li><p>系统初始化</p>
<blockquote>
<p>启动操作系统时，通常会创建若干进程，这些进程中有些是前台进程，用于同用户（人类）交互。其他的是后台进程，后台进程一般具有某些专门的功能，例如，设计一个后台进程接收发来的电子邮件，这个进程在一天的大部分时间都在睡眠，但是当电子邮件达到时就被唤醒了。停留在后台处理诸如电子邮件、web页面、新闻、打印之类的活动的进程称为<strong>守护进程（daemon）</strong>。</p>
</blockquote>
</li>
<li><p>正在运行的进程进行系统调用创建</p>
<blockquote>
<p>正在运行的进程发出系统调用，以便创建一个或者多个线程协助其工作。</p>
</blockquote>
</li>
<li><p>用户请求创建一个新的进程。</p>
<blockquote>
<p>用户双击图标或者输入命令行，启动一个新的程序。</p>
</blockquote>
</li>
<li><p>一个批处理作业的初始化</p>
<blockquote>
<p>仅在大型机的批处理系统中应用，用户在这种系统中提交批处理作业，在操作系统认为有资源科运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。</p>
</blockquote>
</li>
</ul>
<p>在Unix系统中，只有一个系统调用可以创建新的进程：<strong>fork</strong>。它会创建一个与调用进程相同的副本，这两个进程（父进程和子进程）拥有相同的存储镜像、同样的环境字符串和同样的打开文件，这就是全部情形。通常，子进程接着执行execve或者一个类似的系统调用，以修改器存储镜像并运行一个新的程序。例如，当一个用户在shell中输入sort时，shell就创建一个子进程，然后这个子进程执行sort。在Windows中，情形正相反，一个win32函数调用 CreateProcess既处理进程的创建，也负责把正确的程序装入新的进程。不论在Unix还是Windows中，进程创建后，父进程和子进程有各自不同的地址空间。</p>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>进程终止，通常由下列条件引起：</p>
<ul>
<li><p>正常退出（自愿）</p>
<blockquote>
<p>进程完成了自己的工作，调用系统调用，通知工作已经完成。</p>
</blockquote>
</li>
<li><p>出错退出（自愿）</p>
<blockquote>
<p>进程发现了严重错误，如要编译某个文件，但是该文件不存在，于是编译器就会退出。再给出了错误参数时，面向屏幕的交互式进程通常不退出，相反，这些程序会弹出一个对话框，并要求用户再试一次。</p>
</blockquote>
</li>
<li><p>严重错误（非自愿）</p>
<blockquote>
<p>进程引起的错误，通常是由于程序中的错误导致，例如执行了非法指令，引用不存在的内存等。在这类错误中，进程会收到信号（被中断），而不是在这类错误出现时终止。</p>
</blockquote>
</li>
<li><p>被其他进程杀死（非自愿）</p>
</li>
</ul>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但进城之间经常需要相互作用，一个进程的输出结果可能作为另一个进程的输入，在shell命令：</p>
<blockquote>
<p>cat chapter1 chapter2 chapter3 | grep tree</p>
</blockquote>
<p>中，第一个进程运行cat，将三个文件链接并输出，第二个进程运行grep，它从输入中选择所有包含单词tree的那些行。根据这两个进程的相对速度，可能发生这种情况：grep准备就绪可以运行，但输入还没有完成，于是必须阻塞grep；还有可能是：一个概念上能够运行的进程被迫停止，因为操作系统调度另一个进程占用了CPU。下图可以看到显示进程的三种状态的状态图：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE1.png" alt="进程三种状态"></p>
<p>运行态和就绪态在逻辑上是类似的，二者都可以运行，只是后者还没有CPU分配给它，阻塞态就完全不同，处于该状态的进程不能运行，即使CPU空闲也不行。在操作系统发现进程不能继续运行下去时，发生转换1；转换2和3是由于进程调度引起的；当进程等待的一个外部事件发生时（如一些输入到达），则发生转换4。</p>
<h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p>操作系统维护者一张表格，即进程表（process table）。每个进程占用一个进程表项，该表项包含了进程状态的重要信息，诸如程序计数器、堆栈指针，内存分配状况、所打开的文件的状态、账号和调度信息等。下图展示了典型系统中的关键字段：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE2.png" alt="典型的进程表项字段"></p>
<h3 id="多道程序设计模型"><a href="#多道程序设计模型" class="headerlink" title="多道程序设计模型"></a>多道程序设计模型</h3><p>采用多道程序设计可以提高CPU利用率，从概率的角度来看cpu的利用率是比较好。假设一个进程等待I/O操作的时间与其停留在内存中的时间比是<em>p</em>,当内存中有n个进程时，则所有n个进程都在等待I/O（此时CPU空转）的概率是p的n次方，CPU的利用率由一下公式给出：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE3.png" alt="CPU利用率公式"></p>
<p>从完全精确的角度考虑，应该指出此概率模型只是描述了一个大致的状况。它假设所有n个进程都是独立的，即内存中的5个进程中，3个运行，2个等待是完全可以接受的，但在单cpu中，不能同时运行3个进程，所以当CPU忙时，已就绪的进程必须等待CPU，因而，进程不是独立的，更精确的模型应该使用排队论构造，但它仍然是具有参考意义的，下图以n为变量的函数表示CPU的利用率，n称为多道程序设计的<strong>道数（degree of multiprogramming）</strong>。</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE4.png" alt="CPU利用率-道数的关系"></p>
<p>从图中可以看到，如果进程花费80%的时间等待I/O，为使CPU的浪费低于10%，至少要有10个进程同时在内存中。当读者认识到一个等待用户从终端输入的交互式进程是处于I/O等待状态时，很明显，80%甚至更多的I/O等待时间是普遍的，即使是在服务器中，做大量磁盘I/O操作的进程也会花费同样或更多的等待时间。虽然图中的模型很粗略，但它依然对预测CPU的性能很有效。例如，假设计算机有512MB内存，操作系统占128MB，每个用户程序占128MB，那么这些内存允许3个用户程序同时驻留内存，若80%时间用于I/O等待，则CPU利用率大约是1-0.8<em>0.8</em>0.8 ，大约49%，在增加512MB内存后，CPU利用率可以提高到79%，换而言之，第二个512M内存提高了30%的吞吐量。但是增加第三个512MB内存只能讲CPU利用率提高到91%，吞吐量仅提高12%，因此可以确定第一次增加内存是合算的投资，第二个则不是。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><p>人们认为需要使用线程的理由如下：</p>
<ul>
<li><p>并行的线程可以共享同一个地址空间和所有可用数据的。</p>
<blockquote>
<p>对于某些应用而言，这是必需的，二者正式多进程模型（它们具有不同的地址空间）所无法表达的。</p>
</blockquote>
</li>
<li><p>线程比进程更轻量级，更快捷地创建和撤销。</p>
<blockquote>
<p>在许多系统中，创建一个线程较一个进程要快10~100倍。在有大量线程需要动态和快速修改时，这一特性很有用。</p>
</blockquote>
</li>
<li><p>若多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行，从而加快应用程序执行速度。</p>
</li>
<li><p>在多CPU系统中，多线程是有益的，在这样的系统中，真正的并行有了实现的可能。</p>
</li>
</ul>
<p>假如字处理软件被编写成含有3个线程的程序，一个与用户交互，另一个在后台重新进行格式处理，一旦有某一句语句被删掉，交互线程就通知格式化线程对整个文档重新进行处理，同时交互线程继续监控键盘和鼠标，并相应诸如滚动到第一页之类的简单命令。剩下那个每隔一段时间进行磁盘备份，防止程序崩溃或者系统崩溃。拥有三个线程的情形如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE5.png" alt="三个线程协同"></p>
<p>如果程序是单线程的，那么在进行磁盘备份时，来自键盘和鼠标的命令就会被忽略，直到备份工作完成为止。并且，很显然在这里三个不同的进程是不能工作的，这是因为三个线程都需要在同一个文件上进行操作，通过让三个线程代替三个进程，三个线程共享公共内存，于是它们都可以访问同一个正在编辑的文件。</p>
<p>现在考虑另一个多线程发挥作用的例子，一个web服务器，某些页面较其它页面相比，有更多的访问，比如对主页的访问比其它更深层次的页面访问次数更多。利用这一事实，web服务器可以把获得大量访问的页面集合保存在内存中，这样的一种页面集合称为<strong>高速缓存（cache）</strong>，高速缓存也应用在其它很多场合。一种组织web服务器的方式如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE6.png" alt="多线程web服务器"></p>
<p>上图中，一个称为分派程序（dispatcher）的线程从网络中读入工作请求，在检查请求之后，分派现成挑选一个空转的（即被阻塞的）工作线程（worker thread）提交该请求。接着分派现成唤醒该工作线程，将它由阻塞状态转变为就绪状态。工作线程被唤醒后，它检查有关的请求是否在web页面的cache中，这个高速缓存是所有线程都可以访问的，如果没有，该线程开始执行从磁盘中调入页面的I/O操作，并且进入阻塞直到磁盘操作完成。当上述工作线程阻塞在磁盘操作时，为了完成更多操作，分派线程可能挑选另一个工作线程运行，也可以把另一个已经就绪的工作线程投入运行。</p>
<p>这种模型允许把服务器编写为一个集合，在分派线程的程序中包含一个无限循环，该循环用来获得工作请求并把工作请求派给工作线程。每个工作线程的代码包含一个从分派线程接收请求的无限循环，收到请求后，如果页面存在，则返回给客户机，接着该工作线程阻塞，等待一个新的请求到来。</p>
<p>在没有多线程的情况下，编写web服务器。一种可能的方式是：web服务器的主循环获得请求，检查请求，并在取下一个请求之前完成整个工作。在等待磁盘操作时，服务器空转，不处理任何到来的其他请求。课件线程较好地改善了web服务器的性能。如果对于这种性能的降低不可接受，那如果使用read系统调用，则还有一种可能的方式。在请求到来时，这个唯一的线程对请求进行考察，如果请求能在高速缓存中得到满足，那么一切都好，否则，就启动一个非阻塞的磁盘操作。服务器在表格中记录当前请求的状态，然后去处理下一个事件。下一个事件可能是一个新工作的请求，或是磁盘对先前操作的回答。如果是新工作的请求，就开始该工作；如果是磁盘的回答，就从表格中取出对应的信息，并处理该回答。对于非阻塞磁盘I/O而言，这种回答多数会以信号或者中断的形式出现。<strong>注意，这种情况下，“顺序进程”模型消失了，每次服务器从为某个请求工作的状态切换到另一个状态时，都必须显式地保存或者重新装入相应的计算状态。</strong>这里，每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，我们把这类设计称为<strong>有限状态机（finite-state machine）</strong>。</p>
<p>现在很清楚多线程必须提供的是什么了，多线程使得“顺序进程”的思想得以保留下来，这种顺序进程阻塞了系统调用（如磁盘I/O），但是仍旧实现了并行性。</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE7.png" alt="构造服务器三种方法"></p>
<h3 id="经典线程模型"><a href="#经典线程模型" class="headerlink" title="经典线程模型"></a>经典线程模型</h3><p>进程用于把资源集中到一起，而线程是在CPU上被调度执行的实体。在同一个进程环境中，多个线程共享一个地址空间和其他资源，这意味着线程间共享同样的全局变量，一个线程也可以读、写甚至清除另一个线程的堆栈，线程间是没有保护的，因为这是没有必要的，因为同一个进程中的多个线程是合作而不是竞争关系。线程之间对于资源的持有如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE8.png" alt="线程与资源"></p>
<p>和传统进程一样（即只有一个线程的进程），线程可以处于若干种状态的任何一个：运行、阻塞、就绪或者终止。认识到每个线程有其自己的堆栈很重要，下图展示这一状况：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE9.png" alt="每个线程有自己的堆栈"></p>
<p>每个线程的堆栈有一帧，供各个被调用但是还没有从中返回的过程使用。例如，如果过程X调用过程Y，而Y又调用Z，那么当Z执行时，供X、Y和Z使用的帧会全部存在堆栈中。通常每个线程会调用不同的过程，从而有一个各自不同的执行历史，这就是为什么每个线程需要有自己的堆栈的原因。这里还可以了解线程的<strong>join</strong>操作和<strong>yield</strong>操作。</p>
<h3 id="POSIX-线程"><a href="#POSIX-线程" class="headerlink" title="POSIX 线程"></a>POSIX 线程</h3><p>POSIX线程是线程的POSIX（Portable Operating System Interface of UNIX，可移植操作系统接口）标准。它定义的线程包叫做Pthread。有两种主要的方法实现线程包：<strong>在用户空间中和在内核中</strong>。这两种方法互有利弊，不过混合实现方式也是可能的。</p>
<h3 id="在用户空间中实现线程"><a href="#在用户空间中实现线程" class="headerlink" title="在用户空间中实现线程"></a>在用户空间中实现线程</h3><p>这种方法是把整个线程包放在用户空间，内核对线程包一无所知，从内核角度考虑，就是按单线程进程方式管理。这种方法的优点：</p>
<ul>
<li>最明显的优点是：用户级线程包可以在不支持线程的操作系统上实现。<blockquote>
<p>线程在一个运行时系统的顶部运行，这个运行时系统是一个管理线程的过程的集合。在用户空间管理线程时，每个进程需要有其专用的<strong>线程表（thread table）</strong>，用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器等。该线程表由运行时系统管理，当一个线程转换到就绪态或者阻塞态时，需要在线程表中存放重新启动该线程所需的信息。如下图可以对比不同方式实现的线程包：</p>
</blockquote>
</li>
</ul>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE10.png" alt="用户级和内核级线程包"></p>
<ul>
<li><p>可以方便地在进程内调度切换到另一个线程，并且线程切换非常快捷。</p>
<blockquote>
<p>在线程运行完成，例如，线程调用thread_yield ，就可以把线程的信息保存在线程表中，进而，线程调度程序来选择另一个要运行的线程。保存该线程状态的过程和调度程序都只是本地过程，所以启动它们比进行内核调用效率更高。</p>
</blockquote>
</li>
<li><p>允许进程有自己定制的调度算法。</p>
<blockquote>
<p>例如，那些有垃圾收集线程的应用程序就不用担心线程会在不合适的时刻停止。</p>
</blockquote>
</li>
</ul>
<p>尽管用户级线程具有上述的优点，但是它的缺点也明显：</p>
<ul>
<li><p>第一个问题是如何实现阻塞系统调用。</p>
<blockquote>
<p>假设在还没有任何按键动作之前，一个线程读取键盘，让该线程时机进行该系统调用时不可接受的，因为这会停止所有的线程。使用线程的一个主要目标是：首先要允许每个线程使用阻塞调用，但是还要避免被阻塞的线程影响其他的线程。有了阻塞系统的调用，这个目标不太容易实现。</p>
</blockquote>
</li>
<li><p>页面故障问题。</p>
<blockquote>
<p>如果某个程序调用或者跳转到了一条不在内存的指令上，而操作系统将到磁盘上取回这个丢失的指令（和该指令的“邻居们”），这就称为<strong>页面故障</strong>。如果有一个线程引起页面故障，内核甚至不知道有线程存在，通常会把整个进程阻塞，直到磁盘I/O完成为止，尽管其他线程是可以运行的。</p>
</blockquote>
</li>
<li><p>如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU。</p>
<blockquote>
<p>在一个单独的进程内部，没有时间中断，所以不可能用轮转调度（轮流）的方式调度进程。</p>
</blockquote>
</li>
<li><p>可能反对用户级线程的最大负面意见是，程序员通常在经常发生线程阻塞的应用中才希望使用多个线程。</p>
</li>
</ul>
<h3 id="在内核中实现线程"><a href="#在内核中实现线程" class="headerlink" title="在内核中实现线程"></a>在内核中实现线程</h3><p>由上面在用户空间实现的线程和在内核空间实现的线程对比图可以看出，在内核中实现线程不在需要运行时系统，另外，每个进程中也没有线程表。所有能够阻塞线程的调用都以系统调用的形式实现，这与运行时系统过程相比，代价是相当可观的。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程或者运行另一个进程中的线程。而在用户级线程中，运行时始终运行自己进程的线程，直到内核剥夺它的CPU。如果某个进程中的线程引起页面故障，内核可以很方便地检查该进程是否还有其他可运行的线程，如果有，在等待所需要的页面从磁盘读入时，就选择一个线程运行。</p>
<p>在内核中实现线程有以下缺点：</p>
<ul>
<li><p>但是内核中创建、撤销、切换线程操作代价都比较大。</p>
<blockquote>
<p>在内核中尽量减少创建和撤销线程，最好能实现复用（在执行完成后，标记为不可运行，当要创建新线程时，再将其启用）。</p>
</blockquote>
</li>
<li><p>信号是发给进程而不是线程，当信号达到时要考虑将信号交给哪个线程处理。</p>
<blockquote>
<p>即使线程可以注册感兴趣的信号，但是多个线程注册同一个信号如何处理也是个问题。</p>
</blockquote>
</li>
</ul>
<h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3><p>有试图将用户级线程的优点与内核级线程的优点结合起来的方法，一种方法是使用内核级线程，然后将用户级线程与某些内核线程多路复用起来，如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE11.png" alt="用户级和内核级线程混合实现"></p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><em>这个部分看了两次都不甚明白，先跳过。</em></p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="进程行为"><a href="#进程行为" class="headerlink" title="进程行为"></a>进程行为</h3><p>几乎所有进程的（磁盘）I/O请求或计算都是交替突发的。如下图所示，CPU不停顿地运行一段时间，然后发出一个系统调用以便读写文件。如下图所示：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE12.png" alt="突发进行"></p>
<p>图中有一件事值得注意，某些进程花了大多数时间在计算上，称为计算密集型；有些在等待I/O上花了大多数啊时间，称为I/O密集型。有必要指出，随着CPU越来越快，更多的进程倾向于I/O密集型，这里的基本思想是，如果需要运行I/O密集型进程，那么就应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙碌。</p>
<h3 id="何时调度"><a href="#何时调度" class="headerlink" title="何时调度"></a>何时调度</h3><ul>
<li>创建新进程后，决定运行父进程还是子进程。</li>
<li>在一个进程退出时必须做出调度决策。</li>
<li>一个进程阻塞时，必须选择另一个进程运行。</li>
<li>发生I/O中断时，做出调度决策。</li>
</ul>
<h3 id="调度算法的目标"><a href="#调度算法的目标" class="headerlink" title="调度算法的目标"></a>调度算法的目标</h3><p>在讨论目标前，有必要了解我们会处于那些环境中，在不同的应用领域有不同的环境，可以将其分为三类：</p>
<ul>
<li>批处理</li>
<li>交互式</li>
<li>实时</li>
</ul>
<p>下图针对所有环境列出不同的目标：</p>
<p><img src="/assets/Book-Notes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/chapter-2/%E5%9B%BE13.png" alt="不同环境不同目标"></p>
<p><strong>批处理系统的调度算法</strong></p>
<blockquote>
<p>先来先服务<br>最短作业优先<br>最短剩余时间优先</p>
</blockquote>
<p><strong>交互式系统调度算法</strong></p>
<blockquote>
<p>轮转调度<br>优先级调度<br>多级队列调度：<br>最短进程优先<br>保证调度<br>彩票调度<br>公平分享调度</p>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-现代操作系统（第三版）</tag>
      </tags>
  </entry>
  <entry>
    <title>第14章：安全HTTP</title>
    <url>/2018/05/25/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC14%E7%AB%A0/</url>
    <content><![CDATA[<p>前面讨论的基本认证方式和摘要认证以及报文完整性检查都是轻量级的方法，但对于重要的如银行业务处理，大规模网上购物来说，这还不够，我们需要一种能够提供下列功能的HTTP安全技术：</p><ul>
<li>服务器验证，客户端验证服务器是真的还是伪造的</li>
<li>客户端认证，服务器验证客户端是真的还是伪造的</li>
<li>完整性，客户端和服务器的数据不被修改</li>
<li>加密，无需担心会话被窃听</li>
<li>效率，算法的运行要求足够快</li>
<li>普适性，基本上所有的客户端和服务器都支持这种协议</li>
<li>其他</li>
</ul><a id="more"></a>

<h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>https是最流行的HTTP安全形式，它的URL以** https:// ** 而不是  http:// 开头。所有的HTTP请求和响应数据在发送到网络之前都要进行加密，HTTPS在HTTP下面提供了一个安全层，可以使用SSL，也可以使用其后继者TSL（Transport Layer Security，传输层安全），由于二者十分类似，所以一般不太严格地用SSL来表示SSL和TSL。</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-14/layer-with-https.png" alt="http与https的层次"></p>
<h4 id="数字加密"><a href="#数字加密" class="headerlink" title="数字加密"></a>数字加密</h4><p>概念</p>
<ul>
<li><p>密码：对文本进行编码的算法。</p>
</li>
<li><p>密钥：改变密码行为的数字化参数</p>
</li>
<li><p>对称密钥加密系统：编/解码使用相同密钥的算法</p>
</li>
<li><p>不对称密钥加密系统：编/解码使用不同密钥的算法</p>
</li>
<li><p>公开密钥加密算法：一种能够使数百万计算机便捷地发送机密报文的系统</p>
</li>
<li><p>数字签名：用来验证报文是否被改动的校验和。</p>
</li>
<li><p>数字证书：由可信的组织验证和签发的识别信息</p>
</li>
</ul>
<p>假如使用rot3（循环移位3字符）方式对报文加密，则 明文 meet 加密后为 phhw，示意图如下：</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-14/N=3-example.png" alt="循环移位3字符"></p>
<p>那在概念中，<strong>密码</strong>就是 “循环移位N字符” ，N的值是由<strong>密钥</strong>控制的，在这里N的值是3。 改变密钥的值就能产生不同的密文。编码算法和编码机器都可能落入敌人手中，但是只要没有正确的号盘设置（密钥值），也无法实现解码。这种属于使用了密钥的密码。</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-14/same-pass-diff-key.png" alt="相同密码不同密钥"></p>
<p><strong>数字密码：</strong>数字密码只是一些数字，这些数字密钥值是编码/解码算法的输入，编码算法就是一些函数，这些函数会读取一块数据，并根据算法和密钥的值对其进行编码/解码。给定一段明文P、一个编码函数E和一个数字编码密钥e，就可以生成一段经过编码的密文C，通过解码函数D和解码密钥d，就可以将密文C解码为原始的明文P，当然，编码/解码函数互为反函数。</p>
<h4 id="对称密钥加密技术"><a href="#对称密钥加密技术" class="headerlink" title="对称密钥加密技术"></a>对称密钥加密技术</h4><p><strong>对称密钥加密</strong>在编码时候使用的密钥值和解码时候的密钥值一样的。保持密钥的机密很重要，在很多情况下，编码解码算法都是众所周知的，因此密钥是唯一保密的东西了。可用密钥的数量取决于密钥中的位数，以及可能的密钥中有多少是有效的。就对称加密而言，通常所有的密钥值都是有效的（知名的非对称密钥加密系统RSA中，有效密钥必须以某种方式与质数相关，因此并非所有的密钥都有效）。8位的密钥只有256个可能，40位的密钥可以有2的40次方个可能的密钥值等等。</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-14/key-len-with-crack-time.png" alt="密钥长度与破解难度"></p>
<blockquote>
<p>流行的对称密钥加密算法有:DES/Triple-DES、RC2、RC4</p>
</blockquote>
<p><strong>缺点：</strong>发送者和接收者在对话前一定要有一个共享的保密密钥，服务器与每个客户端都需要有一个独立的密钥，以致如果客户端数量过多的情况下，服务器保存的密钥数量可观。如果N个节点，每个节点都要和其他所有N-1个节点通信，总共大概会保存N的平方个密钥，这将是一个管理噩梦。</p>
<h4 id="公开密钥加密技术"><a href="#公开密钥加密技术" class="headerlink" title="公开密钥加密技术"></a>公开密钥加密技术</h4><p>公开密钥加密技术使用了两个非对称密钥，一个用来对报文编码，一个用来对报文解码。编码密钥是可以公之于众的，每个<strong>不同的客户端</strong>可以用<strong>相同的编码密钥</strong>进行加密，但是只有主机自己才知道私有的解密密钥，只有解密密钥才能解码。</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-14/diff-encry-method.png" alt="对称加密与公开密钥技术"></p>
<p>在引入公钥加密机制之前，可以先看两个问题：</p>
<blockquote>
<p>问题1:314159265358979 × 314159265358979 的结果是多少？<br>问题2： 3912571506419387090594828508241 的平方根是多少？</p>
</blockquote>
<p>如果不用计算器，第一个问题，相信大多数人花上一两个小时用纸笔能够计算出来，而第二个问题，即使花上一两天，估计也基本上没人能解出来。虽然平方和开方互为逆运算，但是它们的复杂度差异却很大，这种不对称性构成了公钥密码体系的基础。一种叫做RSA的公钥机制表明，对计算机来说，大数的乘法比对大数进行因式分解要容易得多。所有公开密钥非对称加密系统的要求是，即便拥有以下线索：</p>
<ul>
<li>公开密钥（共有的，每个人都可以获得）</li>
<li>一小片拦截下来的密文（可以网络嗅探获得）</li>
<li>一条报文以及与之相关的密文（对一段文本使用公钥加密就可以得到）</li>
</ul>
<p>也无法计算出保密的私有密钥。</p>
<p>RSA 就是满足这些条件的流行的公开机密要加密系统。RSA的算法是公开的，源代码也可以获得，破解的难度与一个极大的数字进行质因数分解的难度一样。</p>
<h4 id="混合加密系统和会话密钥"><a href="#混合加密系统和会话密钥" class="headerlink" title="混合加密系统和会话密钥"></a>混合加密系统和会话密钥</h4><p>任何人只要知道了公开密钥，就可以向一台公共服务器发送安全报文，所以非对称的公开密钥加密系统是很好用的，两个节点无须为了进行安全的通信而先交换私有密钥。但公开密钥加密算法的计算可能会很慢，比较常见的做法是在两个节点之间通过便捷的公开密钥加密技术建立起安全通信，然后再利用那条安全通道产生并发送临时的随机对称密钥，通过更快的对称加密技术对其余的数据进行加密。</p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>除了加密/解密报文之外，还可以用加密系统对报文进行<strong>签名（sign）</strong>，以说明是谁编写的报文，同时证明报文未被篡改过，这种技术被称为<strong>数字签名（digital signing）</strong>。签名是加了密的校验和，使用数字签名有以下两个好处：</p>
<ul>
<li><p>签名可以证明是作者编写了这条报文。</p>
<blockquote>
<p>只有作者才有最机密的私有密钥，因此只有作者才能计算出这些校验和。</p>
</blockquote>
</li>
<li><p>签名可以防止报文被篡改。</p>
<blockquote>
<p>如果恶意攻击者在传输过程中修改了报文，则校验和就不再匹配了，攻击者没有私钥，无法为篡改的报文伪造正确的验证码。</p>
</blockquote>
</li>
</ul>
<p>以下例子说明了节点A是如何向节点B发送一条报文，并对其进行签名：</p>
<ol>
<li>节点A将变长报文提取为定长摘要。</li>
<li>节点A对摘要应用一个“签名”函数，这个函数会将用户的私有秘钥作为参数。因为只有A知道私有密钥，所以正确的签名函数会说明签名者就是所有者。在下图中，由于解码函数D中包含了用户的私有密码，所以我们将其作为签名函数使用。</li>
<li>一旦计算出签名，节点A就将其附加在报文末尾，并将报文和签名都发给B</li>
<li>在接收端，如果B需要确定报文确实是A写的，而且没有被篡改过，节点B就可以对签名进行检查。节点B接收经过私有秘钥扰码的签名，并应用了使用公开密钥的反函数，如果拆包后的摘要与节点B自己的摘要版本不匹配，就说明要么被篡改了，要么发送者不是A。</li>
</ol>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-14/msg-sign-example.png" alt="报文签名例子"></p>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>数字证书都是由可信任的颁发机构颁发，它通常包括 对象的名称、过期时间，证书颁发者，来自证书发布者的数字签名、通常还包括对象的公开密钥以及对象使用签名算法的描述性信息。典型的数字签名格式如下：</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-14/typical-digital-signing.png" alt="典型的数字签名"></p>
<p>数字证书没有单一的全球标准，但现在大多数证书都以一种标准格式 ——X.509 v3 描述。</p>
<h4 id="用证书对服务器进行认证"><a href="#用证书对服务器进行认证" class="headerlink" title="用证书对服务器进行认证"></a>用证书对服务器进行认证</h4><p>通过https建立一个安全的web事务之后，现代的浏览器会自动获取所连接服务器的数字证书，如果如武器没有证书，安全连接就会失败，服务器证书中包含很多字段，包括：</p>
<ul>
<li>web站点的名称和主机名；</li>
<li>web站点的公开密钥；</li>
<li>颁发机构的名称；</li>
<li>颁发机构的签名。</li>
</ul>
<p>浏览器收到证书时会对签名颁发机构进行检查，如果这个机构是很权威的公司，那浏览器一般已经知道其公开密钥了（浏览器会预先安装很多签名颁发机构的证书），就能像之前那样验证签名了。如果对签名颁发机构一无所知，浏览器就无法确定是否应该信任这个签名颁发机构，它通常会向用户展示一个对话框，看用户是否相信这个签名发布者，因为发布者可能是本地IT部门。以下展示了验证签名的过程：</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-14/verify-the-sign.png" alt="验证签名"></p>
<h3 id="HTTPS-细节介绍"><a href="#HTTPS-细节介绍" class="headerlink" title="HTTPS-细节介绍"></a>HTTPS-细节介绍</h3><p>https就是在安全的传输层上发送的http，它在将http报文发送给TCP之前，先将其发送给一个安全层，对其进行加密。对web服务器发起请求时，我们需要一种方式来告知web服务器去执行http的安全协议版本，这是在URL的方案中实现的，对web资源执行某事务时，它会检查URL方案：</p>
<ol>
<li>如果URL方案是http，客户端会打开一条到服务器端口80的连接（默认情况下），并发送http命令。</li>
<li>如果URL的方案是https，客户端就会打开一条到服务器端口443（默认情况）的连接，然后与服务器握手，以二进制格式与服务器交换一些SSL安全参数，附上加密的http命令。</li>
</ol>
<p>在https中，客户端首先打开一条到web服务器端口443（默认情况）的连接，一旦建立了TCP连接，客户端和服务器就会初始化SSL层，对加密参数进行沟通，并交换密钥，握手完成后，SSL就初始化完成了，客户端就可以将请求报文发送给安全层了，在将这些报文发送给TCP之前，要先对其进行加密。http和https的对比：</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-14/http-with-https.png" alt="验证签名"></p>
<h4 id="SSL握手"><a href="#SSL握手" class="headerlink" title="SSL握手"></a>SSL握手</h4><p>在发送已加密的HTTP报文之前，客户端和服务端要进行一次SSL握手，主要完成以下工作：</p>
<ul>
<li>交换协议版本号</li>
<li>选择一个两端都了解的密码</li>
<li>对两端身份进行验证</li>
<li>生成临时会话密钥，以便加密信道</li>
</ul>
<p>SSL握手简化版示意图如下：</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-14/simple-SSL-handshake.png" alt="SSL简化版握手"></p>
<p>在一个web服务器上执行安全事务，比如提交银行卡信息时，总是希望在于你所认为的那个组织对话，因此https事务总是要求使用服务器证书的。站点证书有效性检查步骤如下：</p>
<ol>
<li><strong>日期检测</strong>。检查证书的起始日期和结束日期。</li>
<li><strong>签名颁发者可信度检测</strong>。每个证书是由某个证书颁发机构（CA）签发的，它们负责位服务器担保，证书有不同的等级，每种证书都要求不同级别的背景验证。比如申请某个电子商务服务证书，通常要求提供一个营业的合法证明。</li>
<li><strong>签名检测</strong>。一旦判定签名授权是可信的，浏览器就要对签名使用颁发机构的公开密钥，并将其与校验码比较，以查看证书的完整性。</li>
<li><strong>站点身份检测</strong>。为防止服务器复制其他人的证书，或拦截他人流量，大部分浏览器都会试着去验证证书中的域名与它们所对话的服务器的域名是否匹配。</li>
</ol>
<h4 id="虚拟主机与证书"><a href="#虚拟主机与证书" class="headerlink" title="虚拟主机与证书"></a>虚拟主机与证书</h4><p>对于虚拟主机（一台服务器上有多个主机名），有些流行的web服务器程序只支持一个证书，如果用户请求的是虚拟主机名，与证书名称并不完全匹配，浏览器就会显示警告框。比如cajun-shop.com网站，站点的托管服务提供商提供的官方名称位 cajun-shop.securesites.com。 用户进入<a href="http://www.cajun-shop.com时，服务器证书中列出的官方主机名（*.securesites.com）与用户浏览的虚拟主机名（www.cajun-shop.com）不匹配，以至于出现警告。" target="_blank" rel="noopener">http://www.cajun-shop.com时，服务器证书中列出的官方主机名（*.securesites.com）与用户浏览的虚拟主机名（www.cajun-shop.com）不匹配，以至于出现警告。</a></p>
<p>为了防止出现这个问题，cajun-shop.com的所有者会在开始处理安全事务时，将所有用户都重定向到cajun-shop.securesites.com。</p>
<h4 id="通多代理以隧道形式传输安全流量"><a href="#通多代理以隧道形式传输安全流量" class="headerlink" title="通多代理以隧道形式传输安全流量"></a>通多代理以隧道形式传输安全流量</h4><p>很多公司都会在公司网络和公共因特网的安全边界上放置一个代理，代理是防火墙路由器唯一允许进行http流量交换的设备，它可能会进行病毒检测或者其他的内容控制工作。</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-14/server-agent.png" alt="公司的代理"></p>
<p>但只要客户端开始用服务器的公开密钥对发往服务器的数据进行加密，代理就再也不能读取http首部了！代理不能读取首部，意味着无法知道应该将请求转向何处。</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-14/cannot-transmit.png" alt="代理不能转发"></p>
<p>这种情况一种常用的技术就是https SSL 隧道协议，客户端首先要告知代理，他想要连接的安全主机和端口，这是在开始加密之前以明文形式告知的，所以代理可以理解这条信息。</p>
<blockquote>
<p>http通过新的名为connect的扩展方法来发送明文形式的端点信息，connect方法会告诉代理，打开一条到期望主机和端口号的连接，这项工作完成之后，直接在客户端和服务器之间以隧道形式传输数据。</p>
</blockquote>
<p>以下示意了一个connet：</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-14/connect-sample.png" alt="connect实例"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-HTTP 权威指南</tag>
      </tags>
  </entry>
  <entry>
    <title>第12、13章：认证机制</title>
    <url>/2018/05/23/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC12%E3%80%8113%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="第12章——基本认证机制"><a href="#第12章——基本认证机制" class="headerlink" title="第12章——基本认证机制"></a>第12章——基本认证机制</h2><p>当访问某些需要授权才能访问的资源时，服务器会返回401要求登录认证，web服务器会将受保护的文档组织成一个 安全域（security realm），每个安全域可以有不同的授权用户集。</p><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>假设web服务器建立了两个安全域，一个用于公司的财务信息，一个用于个人家庭的文档，那么公司的CEO应当能够访问销售额预测资料，但不应该允许CEO访问员工和其家人度假的照片。</p><a id="more"></a>

<p>下面是一个假想的基本认证质询，它指定了一个域：</p>
<blockquote>
<p>HTTP/1.0 401 Unauthorized<br>WWW-Authenticate：Basic realm=”Family”</p>
</blockquote>
<p>域应该有一个描述性字符名，比如 Family（员工个人家庭照片），以帮助用户了解应该使用哪个用户名和密码。</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-12and13/basic-auth-example.png" alt="基本认证实例"></p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>基本认证的机制很简单，但是存在以下主要的安全隐患：</p>
<ul>
<li>基本认证以  username:pwd  的形式将用户名密码拼接起来，并且通过Base-64的加密后通过网络发送用户名和密码，这基本上相当于明文传输（base-64很容易破解）。</li>
<li>即使使用其他更难解密的方式加密，也没有机制防止重放攻击。</li>
<li>没有针对中间节点的防护，头部不被更改，能通过认证，但是报文内容更改了也能造成很大的危害。</li>
</ul>
<h2 id="第13章——摘要认证"><a href="#第13章——摘要认证" class="headerlink" title="第13章——摘要认证"></a>第13章——摘要认证</h2><p>摘要认证试图修复基本认证协议的严重缺陷，它遵循的箴言是“绝不通过网络发送密码”，相对基本认证，它做了如下改进：</p>
<ul>
<li>永远不以明文在网络上发送密码</li>
<li>可以防止恶意用户捕获并且重放的握手过程</li>
<li>可以选择性地防止对报文内容的篡改</li>
<li>防范其他常见形式的攻击</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>摘要认证的主要原理是<strong>“对信息主体的浓缩”</strong>，它认证的主要流程如下：</p>
<ol>
<li>客户端请求了某个受保护的文档。</li>
<li>在客户端能够证明身份前，服务器拒绝提供文档，并向客户端发起质询，询问用户名和摘要形式的密码。</li>
<li>客户端传递用户名和密码的摘要。服务器知道所有用户的密码，将收到的摘要与自己用密码计算出来的摘要对比，即可校验用户身份真伪。</li>
<li>如果验证通过，则开始向客户端提供文档。</li>
</ol>
<p><strong>注意：整个过程都没有在网络上发送密码！而是发送密码的“摘要”或者说是指纹</strong></p>
<p>整个过程图示如下：</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-12and13/degist-flow.png" alt="摘要认证流程"></p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>摘要是一种单向函数，主要用于将无限的输入值转换为有限的浓缩输出值，有时也将摘要函数称为加密的校验和、单向散列函数或者指纹函数。常见的摘要函数是  MD5 ，会将任意长度的字节序列转换为一个128位的摘要。MD5输出的128位的摘要通常会被写成32个16进制的字符，每个字符表示4位。</p>
<h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>使用单向摘要就无需以明文发送密码了，但是别有用心的人还是可以截获摘要，并一遍遍地重放给服务器，进行重放攻击，在这点上，摘要和密码一样好用。</p>
<p>为了防止重放攻击，服务器可以向客户端发送一个称为 <strong>随机数（nonce）</strong>的特殊令牌，这个数会经常发生变化（根据具体规则来定，可以每次认证都变化），客户端在计算摘要之前要先将这个随机数令牌附加到密码上去。在密码中加入随机数就会使摘要随着随机数的每次变化而变化，没有密码就无法计算出正确的摘要。</p>
<h3 id="摘要认证的握手机制"><a href="#摘要认证的握手机制" class="headerlink" title="摘要认证的握手机制"></a>摘要认证的握手机制</h3><p>摘要认证的握手步骤流程如下：</p>
<ol>
<li>客户端请求被保护的文档。</li>
<li>服务器计算出一个随机数，放入质询报文（WWW-Authenticate）中，与服务器支持的算法列表一同发给客户端。</li>
<li>客户端选择其中一个算法，计算出密码和其他数据的摘要。并将摘要放在认证报文（Authorization）中发回服务器，如果客户端要对服务器进行质询，可以发送客户端的随机数。</li>
<li>服务器接受摘要、选中的算法以及支撑数据，在本地生成摘要，并与客户端发来的摘要对比验证。如果客户端有对服务器进行质询，就会创建服务端摘要。</li>
</ol>
<h3 id="摘要认证会话过程优化"><a href="#摘要认证会话过程优化" class="headerlink" title="摘要认证会话过程优化"></a>摘要认证会话过程优化</h3><h4 id="预授权"><a href="#预授权" class="headerlink" title="预授权"></a>预授权</h4><p>普通的认证方式中，事务结束前，每条请求都要有一次 请求/质询 的循环，如果客户端事先知道下一个随机数是什么，就可以取消这个 请求/质询 循环，这样客户端就可以在服务端发出请求之前，正确地生成Authorization首部了。这样就能减少报文的数量，对性能也有很大的提升，如图：</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-12and13/pre-auth-reduce-amount.png" alt="预授权减少报文数量"></p>
<p>此外，还有几种预授权的方式：</p>
<ul>
<li><p>服务器预先在Authentication-info成功首部中发送下一个随机数。</p>
<blockquote>
<p>这虽然避免了 请求/质询 循环，但是它也破坏了对同一条服务器的多条请求进行管道化的功能，因为在发布下一条请求之前，一定要收到下一个随机值才行。</p>
</blockquote>
</li>
<li><p>服务器允许在一段时间内使用同一个随机数。</p>
<blockquote>
<p>可能会有一定次数的重放攻击的可能性。</p>
</blockquote>
</li>
<li><p>客户端和服务器使用同步的、可以预测的随机数生成方法。</p>
</li>
</ul>
<h4 id="报文完整性保护"><a href="#报文完整性保护" class="headerlink" title="报文完整性保护"></a>报文完整性保护</h4><p>如果使用了完整性保护（qop=”auth-init”），对应的内容就是对实体主体部分，而不是报文主体部分的散列，对于发送者，要在应用任意传输编码方式之前计算，而对于接收者，则应在去除所有传输编码之后计算。</p>
<h3 id="总结安全隐患和相应解决方案"><a href="#总结安全隐患和相应解决方案" class="headerlink" title="总结安全隐患和相应解决方案"></a>总结安全隐患和相应解决方案</h3><ul>
<li><p>重放攻击。</p>
<blockquote>
<p>用生成随机数解决，可能可以包括IP地址、时间戳、资源Etag等计算摘要。</p>
</blockquote>
</li>
<li><p>多重认证机制。</p>
<blockquote>
<p>比如同时存在基本认证和摘要认证时。可以考虑使用最强认证方案。</p>
</blockquote>
</li>
<li><p>首部篡改。</p>
<blockquote>
<p>防范方式：要么端到端加密，要么对首部进行数字签名，最好二者结合。</p>
</blockquote>
</li>
<li><p>词典攻击。</p>
<blockquote>
<p>没有好的对策，设置合理的密码过期策略，和难以猜测和破译的密码吧。</p>
</blockquote>
</li>
<li><p>恶意代理攻击和中间人攻击。</p>
<blockquote>
<p>没有更好的方法，唯一方式是使用SSL。</p>
</blockquote>
</li>
<li><p>选择明文攻击。</p>
<blockquote>
<p>利用摘要词典获取密码明文，或者暴力枚举可能的密码。</p>
</blockquote>
</li>
<li><p>存储密码。</p>
<blockquote>
<p>如果摘要认证密码文件被入侵，攻击者就获取到域中所有文件，而无需进行解码了。消除这个问题的方法：（1）加强保护  （2）确保域名在所有域中是唯一的。如果密码文件被入侵，所造成的破坏也局限于某一特定域。</p>
</blockquote>
</li>
</ul>
<p><strong>摘要加密没有为内容的安全提供保障，可能可以知道内容是否被篡改，真正安全的事务是通过SSL才能实现。</strong></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-HTTP 权威指南</tag>
      </tags>
  </entry>
  <entry>
    <title>第11章：客户端识别与cookie机制</title>
    <url>/2018/05/22/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC11%E7%AB%A0/</url>
    <content><![CDATA[<p>HTTP提供匿名、无状态的请求/响应 服务，为了给用户个性化的服务，有必要识别用户，主要的方式有：</p><ul>
<li>HTTP首部承载用户身份信息<blockquote>
<p>HTTP请求首部有From （用户的email地址）、user-agent（用户的浏览器软件）、Referer（用户是从这个页面跳转过去的）、Authorization（用户名和密码）等字段，利用这些字段可以识别用户。</p>
</blockquote>
</li>
</ul><a id="more"></a>

<p>以下是首部承载的信息：</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-11/header-info.png" alt="首部承载的信息"></p>
<ul>
<li><p>跟踪客户端IP地址，通过IP地址识别用户。</p>
<blockquote>
<p>IP识别有弊端，（1）它识别的是及其，不是用户  （2）网络服务提供商可能会提供动态的IP  （3）如果使用了代理，那获取到的IP可能只是代理的IP.<br>（4）为了安全，用户可能通过网络地址转换（Network Address Translation， NAT） 防火墙来浏览网络内容，这些NAT设备隐藏了防火墙后面的那些实际客户端的IP。</p>
</blockquote>
</li>
<li><p>用户登录，用认证方式识别用户。</p>
<blockquote>
<p>如果服务器希望在为用户提供对站点的访问前先登录，则可以返回 401 Login Required ,然后浏览器会弹出登录框。这样就能显式地询问用户是谁。</p>
</blockquote>
</li>
<li><p>胖UTL，在URL中嵌入识别信息的技术</p>
<blockquote>
<p>有些web站点会为每个用户生成特定版本的URL来追踪身份，用户浏览站点时，web服务器会动态生成一些超链，继续维护URL中的信息。但是，这种方案有几点问题：</p>
</blockquote>
</li>
</ul>
<ol>
<li>无法共享URL，包含了特定用户的信息，如果分享出去，无意中将积累的个人信息共享出去了</li>
<li>需要对每个用户动态生成胖URL，额外的服务器负荷</li>
<li>破坏缓存。为每个URL生成用户特有的版本，意味着不再有供公共访问的URL缓存了。</li>
</ol>
<ul>
<li>cookie<blockquote>
<p>是目前识别用户，实现持久会话的最好方式。包括 会话cookie 和 持久cookie ，他们之间的唯一区别就是他们的过期时间。浏览器会记住从服务器返回的set-cookies或者set-cookie2首部中的cookie内容，并将cookie存储在cookie数据库，将来用户访问同一站点时，浏览器会按照某些规则将cookie放在<br>cookie请求首部中将其传回去。</p>
</blockquote>
</li>
</ul>
<p>以下是为用户设置cookie的情形：</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-11/cookie-for-user.png" alt="为用户设置cookie"></p>
<p>cookie的域属性：</p>
<p>产生cookie的服务器可以向set-cookie响应首部添加一个Domain属性来控制哪些站点可以看到那个cookie，比如，下面的HTTP响应首部告知浏览器将 cookie user=”haha” 发送给域 “.baidu.com”中的所有站点：</p>
<p>set-cookie: user=”haha”;domain=”baidu.com”</p>
<p>如果访问的是<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>  、news.baidu.com 或其他任何以 .baidu.com 结尾的站点，下列的cookie都会被发布出去；</p>
<p>Cookie :user=”haha”</p>
<p>cookie 规范甚至允许用户将cookie域部分web站点关联起来，可以通过path属性来实现：</p>
<p>例如，某个web服务器可能是由两个组织共享的，每个组织都有独立的cookie，站点 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 可能会将部分web站点用于外卖，如 <a href="http://www.baidu.com/waimai/" target="_blank" rel="noopener">www.baidu.com/waimai/</a>  ，可以用一个独立的cookie来记录用户喜欢的外卖口味，如：</p>
<p>Set-cookie: taste=hot; domain=”baidu.com”; path=/waimai/</p>
<p>如果用户访问  <a href="http://www.baidu.com/waimai/bj/index.html" target="_blank" rel="noopener">http://www.baidu.com/waimai/bj/index.html</a> 时就会获得两个cookie：</p>
<p>Cookie: user=”haha”<br>Cookie: taste=”hot”</p>
<p>因此，可以理解为：cookie就是由服务器贴到客户端上，由客户端维护的状态片段，只会回送给那些合适的站点。</p>
<p>我们有Set-Cookie  和 Set-Cookie2 两种，后者属于更新的版本。Cookie2首部告知服务器，用户Agent代理理解新形势的cookie，病提供了所支持的cookie标准版本，：<br>Cookie2： $Version=”1”<br>如果服务器理解新形式的cookie，就能识别出Cookie2首部，并在响应首部发送Set-Cookie2（而不是Set-Cookie），如果客户端从同一个响应中既获得了Set-Cookie 首部又获得了 Set-cookie2首部，就会忽略老的 Set-cookie首部。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-HTTP 权威指南</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章：连接管理</title>
    <url>/2018/05/21/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p>HTTP的连接实际上就是TCP的连接和一些使用连接的规则。</p><p><strong>TCP是可靠的数据管道：</strong>TCP为HTTP提供了一条可靠的比特传输管道，从TCP连接一端输入的字节会从另一端以原有顺序、正确地传送出来。</p><p><strong>TCP流是分段的，由IP分组传送：</strong>HTTP以流的形式将报文数据通过一条打开的TCP连接传输，TCP会将数据流分成若干段，每个TCP段都是由IP分组承载，从一个IP地址发送到另一个IP地址。</p><a id="more"></a>


<p>任意时刻计算机都可以有多条TCP连接处于打开状态，<strong>TCP是通过端口号来保持这些连接的正确运行。</strong></p>
<blockquote>
<p>TCP的连接是通过4个值来识别的：&lt;源IP地址、源端口号、目的IP地址、目的端口号&gt; ，这4个值定义了唯一一条连接，IP地址可以将你连接到正确地计算机，而端口号可以将你连接到正确的应用程序。</p>
</blockquote>
<p>以下表示四条不同的TCP连接，各连接要么源IP不同，要么目的IP不同，要么源端口不同，要么目的端口不同：</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-4/four_different_tcp.png" alt="四条不同的TCP连接"></p>
<p>利用套接字操纵TCP客户端和服务器之间的连接：</p>
<p><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-4/tcp-client-server.png" alt="http通过tcp发送数据的过程"></p>
<h2 id="HTTP性能讨论"><a href="#HTTP性能讨论" class="headerlink" title="HTTP性能讨论"></a>HTTP性能讨论</h2><h3 id="性能概述"><a href="#性能概述" class="headerlink" title="性能概述"></a>性能概述</h3><p>HTTP事务流程主要包括几个方面：</p>
<ol>
<li>客户端首先根据URI确定WEB服务器的IP和端口，如果没有DNS缓存的话，这个过程可能花费数十秒。</li>
<li>接下来，客户端向服务器发送TCP连接请求，并等待服务器应答，每条新的TCP连接都会有连接建立时延。</li>
<li>一旦连接建立起来，服务器处理请求、因特网传输请求报文都需要时间。</li>
</ol>
<p>HTTP位于TCP上层，所以HTTP事务的性能很大程度上取决于TCP通道的性能。这其中，对HTTP性能影响最常见的是TCP相关的时延，包括：</p>
<ul>
<li><p>TCP连接建立握手</p>
<blockquote>
<p>小的HTTP事务可能会在TCP建立上花费50%的时间，这是不合理的。</p>
</blockquote>
</li>
<li><p>用于捎带确认的TCP延迟确认算法</p>
<blockquote>
<p>每个TCP段都有一个序列号和数据完整性校验和，每个段的接收者收到完好的段时，都会向发送者回送确认分组。如果发送者没有在指定的时间窗口收到确认信息，发送者就认为分组已损坏，并重新发送数据。由于确认报文很小，所以TCP允许TCP将返回的确认信息与输出的数据分组结合在一起，可以更有效地利用网络。为了增加确认报文找到输出数据分组的可能性，很多TCP栈都实现了一种“延迟确认”算法，延迟确认算法会在一个特定的窗口时间（通常100~200毫秒）内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组，如果那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。</p>
</blockquote>
</li>
<li><p>TCP慢启动拥塞(se)控制</p>
<blockquote>
<p>TCP数据传输的性能还取决于TCP连接的使用期（age）。TCP连接会随着时间进行自我“调谐”——期初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输速度，这种“调谐”称为 TCP慢启动，用于防止因特网的突然过载和拥塞。例如，如果HTTP事务有大量的数据要发送，是不能一次将所有分组发送出去的，必须发送一个分组等待确认，然后可以发送两个分组，每个分组都必须确认，这样就可以发送四个分组了，这种方式被称为“打开拥塞窗口”。由于存在这种拥塞控制，所以新连接的传输速度会比已经传输过一定量数据的“已调谐”的连接慢一些。由于已“调谐”的连接快，因此HTTP中有一些可以重用现存连接的工具，提高效率。</p>
</blockquote>
</li>
<li><p>数据聚集的Nagle算法与TCP_NODELAY</p>
<blockquote>
<p>如果每次发送的数据量很少，但是传输的次数很多，就会产生大量包含少量数据的分组，网络性能就会下降，Nagle算法鼓励发送全尺寸（LAN上最大尺寸的分组大约1500字节，因特网上是几百字节）的段，试图在发送一个分组前，将大量TCP数据绑在一起，提高网络效率，毕竟每个TCP段中哪怕只放了一个字节，也至少装载了40个字节的标记和首部。但是这也会引发HTTP性能问题，首先，可能某个小的HTTP报文无法填满一个分组，但等待那些永远不会到来的额外数据而产生时延。其次，Nagle算法与前面体积的延迟确认似乎是矛盾的 —— Nagle算法会阻止数据发送，直到有确认分组抵达为止，但是确认分组会被延迟确认算法延迟100~200毫秒。</p>
</blockquote>
</li>
<li><p>TIME_WAIT时延和端口耗尽</p>
<blockquote>
<p>当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，这类信息指挥维持一小段时间，通常是所估计的最大分段使用期的2倍（称为2MSL，通常为2分钟）。</p>
</blockquote>
</li>
</ul>
<h3 id="HTTP的性能改善"><a href="#HTTP的性能改善" class="headerlink" title="HTTP的性能改善"></a>HTTP的性能改善</h3><p>有几种方法可以提高HTTP的性能：</p>
<ol>
<li>并行连接，通过发起多条TCP连接发起并发的HTTP请求。这样可以避免单条连接的空载时间和没有充分利用带宽。以下两个图为对比：<br>串行：<br><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-4/serial-http.png" alt="串行"></li>
</ol>
<p>并行：<br><img src="/assets/Book-Notes/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/chapter-4/parallel-http.png" alt="并行"><br>2. 持久连接，用于消除连接及关闭的时延。 以前使用 keep-alive 字段，现在使用  persistent。<br>3. 管道化连接。通常，http请求总是顺序发送的，下一个请求只有在当前请求的响应被完全接受的时候才会被发送。由于网络延迟和带宽的限制，这样会导致在服务器发送下一个响应的时候中间有很大的延迟。管道化连接可以将多条连接放入队列，当第一条请求发出之后，第二条第三条请求也可以开始发送了，这样做可以降低网络环回时间，提高性能。</p>
<blockquote>
<p>如果一个事务，不管是执行一次还是很多次，得到的结果都是相同的，那我们说这个事务是幂等的。  GET、HEAD  PUT DELETE TRACE  OPTIONS  是幂等的，但POST不是幂等的，所以不应该以管道化的方式发送POST请求。</p>
</blockquote>
<h2 id="书本之外：关于TIME-WAIT"><a href="#书本之外：关于TIME-WAIT" class="headerlink" title="书本之外：关于TIME_WAIT"></a>书本之外：关于TIME_WAIT</h2><p><strong>以下内容参考自博客：</strong></p>
<p><a href="https://blog.csdn.net/u013616945/article/details/77510925" target="_blank" rel="noopener">https://blog.csdn.net/u013616945/article/details/77510925</a> </p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>首先调用close()发起主动关闭的一方，在发送最后一个ACK之后会进入time_wait的状态，也就说该发送方会保持2MSL时间之后才会回到初始状态。MSL值得是数据包在网络中的最大生存时间。产生这种结果使得这个TCP连接在2MSL连接等待期间，定义这个连接的四元组（客户端IP地址和端口，服务端IP地址和端口号）不能被使用。</p>
<h3 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h3><ul>
<li>为实现TCP全双工连接的可靠释放</li>
</ul>
<blockquote>
<p>假设发起主动关闭的一方（client）最后发送的ACK在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前，client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常。</p>
</blockquote>
<ul>
<li>为使旧的数据包在网络因过期而消失<blockquote>
<p>为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。</p>
</blockquote>
</li>
</ul>
<h4 id="time-wait状态如何避免"><a href="#time-wait状态如何避免" class="headerlink" title="time_wait状态如何避免"></a>time_wait状态如何避免</h4><p>首先服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记-HTTP 权威指南</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下利用github和hexo搭建自己的博客</title>
    <url>/2018/05/03/Ubuntu%E4%B8%8B%E5%88%A9%E7%94%A8github%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>最近打算开始写点东西，发出来，一来可以督促自己持续地将所学所感悟的东西记录下来，二来，以前一直在自己遇到问题解决不了的时候去google，获取他人的答疑解惑，而自己写的总结性的东西都在有道云笔记上（主要怕误导大家），这次重新搭建自己的博客，附上了评论系统，所以希望即使写出来的东西不完善也能让大家留个评论，能够及时改正，因此就膨胀发出来了。同时希望这个教程能够帮到一些人亲手搭建自己的博客。</p><a id="more"></a>
<p><strong>根据一直以来的经验，使用第三方框架之前一定要仔细阅读官方的文档，先不要去获取网上所谓的教程，因为每个教程里面针对的 操作系统、搭设的环境等 不一定和你的一模一样，而官方文档一般是能涵盖你所碰到的大多数问题的</strong></p>
<p>先放上官方的（<strong>语言可以选择中文的哦</strong>）：</p>
<p>hexo的主页在这里：<a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a>  </p>
<p>hexo的文档在这里：<a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></p>
<p>如果你自己能看文档解决，那是再好不过了，如果根据官方文档踩到坑跳不出来，可以参考参考以下的教程。</p>
<h2 id="一、安装nodejs-与-npm"><a href="#一、安装nodejs-与-npm" class="headerlink" title="一、安装nodejs 与 npm"></a>一、安装nodejs 与 npm</h2><p>首先声明，博主目前主要使用Ubuntu进行Android开发，然后进行一些简单的日常使用，对Ubuntu玩得并非很6，看到hexo官网上说要先安装nodejs和npm，首先想到的是去<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs官网</a>，但是下载下来解压之后，一脸懵逼，不知道怎么操作了。官网上没有很直观的文档(是不仔细找还不好发现)，google 上也是众说纷纭，遂又硬着头皮去官网上找找解决方法，我最后找到的<a href="https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions" target="_blank" rel="noopener">官方指引，点击这里就是</a>，有针对各种系统安装nodejs的说明（同时会自动安装 npm），为了节约大家去看文档的时间，以下还是列出ubuntu环境下nodejs的安装过程：</p>
<p>在终端输入：</p>
<blockquote>
<p>curl -sL <a href="https://deb.nodesource.com/setup_8.x" target="_blank" rel="noopener">https://deb.nodesource.com/setup_8.x</a> | sudo -E bash -</p>
</blockquote>
<p><strong>注：在写本教程的时候，最新的LTS版本的nodejs是 8.11.1，所以我这里是8.x，这个版本号可以依据自己需要的版本而改动</strong></p>
<p>当然，如果提示你还未安装curl，则使用以下命令安装即可：</p>
<blockquote>
<p>$ sudo apt-get install curl</p>
</blockquote>
<p>完成之后，再在终端输入：</p>
<blockquote>
<p>$ sudo apt-get install -y nodejs</p>
</blockquote>
<p>最后，输入以下命令检测是否安装成功 ：</p>
<blockquote>
<p>$ nodejs -v</p>
</blockquote>
<blockquote>
<p>v8.11.1 </p>
</blockquote>
<blockquote>
<p>$ npm -v </p>
</blockquote>
<blockquote>
<p>5.6.0 </p>
</blockquote>
<p>如果显示这些版本号，说明安装成功。</p>
<h2 id="二、安装hexo"><a href="#二、安装hexo" class="headerlink" title="二、安装hexo"></a>二、安装hexo</h2><p>根据<a href="https://hexo.io/docs/" target="_blank" rel="noopener">hexo的官方介绍</a>，里面很详细地介绍了安装过程：</p>
<p>1、安装hexo(<strong>如果提示权限问题请在命令前加上   sudo</strong>)</p>
<blockquote>
<p>$ npm install -g hexo-cli</p>
</blockquote>
<p>2、初始化hexo</p>
<p>在终端cd到你想要存放blog的目录，执行</p>
<blockquote>
<p>$ hexo init BLOG </p>
</blockquote>
<p>这行命令会帮你创建一个BLOG文件夹，并且做一些初始化操作，这里BLOG是你想要新建的存放hexo必要文件的文件夹。</p>
<p>3、安装依赖</p>
<blockquote>
<p>$ cd BLOG</p>
</blockquote>
<blockquote>
<p>$ npm install</p>
</blockquote>
<h2 id="三、配置github"><a href="#三、配置github" class="headerlink" title="三、配置github"></a>三、配置github</h2><p>申请github账号，并且在本地电脑上安装git ，并且将本地生成的公钥更新到github上，以便本机有权限将生成的静态网页push到github服务器。<br><strong>参考附件：</strong>github官方提供的ssh设定：<a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">https://help.github.com/articles/connecting-to-github-with-ssh/</a></p>
<h4 id="在github上新建project"><a href="#在github上新建project" class="headerlink" title="在github上新建project"></a>在github上新建project</h4><p>在github上新建project ，只需要注意project的名字一定得是  username.github.io 就行了，像我的博客地址是  glassx.github.io，因此我的project的名字是  glassx.github.io  。</p>
<h2 id="四、配置hexo-以及-关联hexo与github"><a href="#四、配置hexo-以及-关联hexo与github" class="headerlink" title="四、配置hexo 以及 关联hexo与github"></a>四、配置hexo 以及 关联hexo与github</h2><p>在正式写作之前，我们需要配置hexo，并且将hexo与github关联起来。</p>
<h4 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h4><p>首先是选择 <strong>主题（theme）</strong>，当然也可以使用hexo的默认主题，我目前使用的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia主题</a>，这个纯属个人爱好，你可以去知乎上搜索好看的hexo主题，也能从<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">我认为的hexo主题大全</a>中选择你中意的主题。只需将下载好的主题放到  *<em>BLOG/themes/  *</em>目录下备用。</p>
<p>用yilia主题的话，别忘了在BLOG目录下终端执行：</p>
<blockquote>
<p> $ npm i hexo-generator-json-content –save</p>
</blockquote>
<h4 id="修改hexo的配置文件"><a href="#修改hexo的配置文件" class="headerlink" title="修改hexo的配置文件"></a>修改hexo的配置文件</h4><p>打开 ** BLOG/ <strong>目录下的  **_config.yml</strong> 文件，找到 theme 字段，将它的值改成你需要的主题名称，比如我的就是 ：</p>
<blockquote>
<p>theme: yilia</p>
</blockquote>
<p>除此之外，还需要找到 <strong>deploy</strong> 字段，将它下面的字段配置成类似于：</p>
<pre><code>deploy:
  type: git
  repository: https://github.com/glassx/glassx.github.io.git
  branch: master</code></pre><p>将 <a href="https://github.com/glassx/glassx.github.io.git" target="_blank" rel="noopener">https://github.com/glassx/glassx.github.io.git</a>  换成你自己的就好了（其实这里整个就是你前面在github上新建的仓库的地址）。</p>
<h4 id="安装必要控件"><a href="#安装必要控件" class="headerlink" title="安装必要控件"></a>安装必要控件</h4><p>使用以下命令安装deploy的git工具：</p>
<blockquote>
<p>$ npm install hexo-deployer-git –save</p>
</blockquote>
<p>如果不安装，在部署的时候会报错： <strong>ERROR Deployer not found: git</strong></p>
<p><strong>注意：一定要在第三步的时候将你的公钥上传到github上去，也就是第三步中的 github提供的ssh设定  那个部分，否则在部署的时候会提示没有权限</strong></p>
<h2 id="五、开始写作"><a href="#五、开始写作" class="headerlink" title="五、开始写作"></a>五、开始写作</h2><p>准备工作终于做完了，开始发挥吧！<br>首先新建博文：</p>
<p>在终端里定位到上述的BLOG文件夹下，执行</p>
<blockquote>
<p>$ hexo new post “firstpage”</p>
</blockquote>
<p>之后会在 <strong>BLOG/source/_post/</strong> 目录下生成 <strong>firstpage.md</strong> 文件，编辑firstpage.md 文件，注意该文件的编辑使用的是 markdown 语法，如果不懂这个语法的话，就去google一下吧，语法很简单。</p>
<p>关于Ubuntu下的编辑器，我目前在使用的是 <a href="https://remarkable.com/" target="_blank" rel="noopener">Remarkable</a>，个人觉得挺好用，因此也安利一波。</p>
<p>编辑完成之后，终端中定位到 BLOG/ 目录，使用hexo命令生成静态文件：</p>
<blockquote>
<p>$ hexo generate</p>
</blockquote>
<p>生成静态文件命令也可以直接简化成： </p>
<blockquote>
<p>$ hexo g</p>
</blockquote>
<p>生成静态文件的过程就是将markdown文件 firstpage.md导出成index.html之类的静态文件，静态文件生成之后，便只需要部署了：</p>
<blockquote>
<p>$ hexo deploy</p>
</blockquote>
<p>同样，部署命令也可以简化成：</p>
<blockquote>
<p>hexo d</p>
</blockquote>
<p>部署过程实际上是将静态文件push到github指定仓库的过程，期间需要输入你的github的username，比如我的就是glassx ，之后回车；再提示你输入github登录密码（输入密码是看不见的，输入了看不见不要慌），输完回车就OK了。</p>
<p>当然你可以做到一行命令生成静态文件后自动部署：</p>
<blockquote>
<p>$ hexo generate –deploy</p>
</blockquote>
<p>或者 </p>
<blockquote>
<p>$ hexo deploy –generate</p>
</blockquote>
<p>二者的效果是一样的，都是生成静态文件后自动部署。</p>
<p>部署成功之后，就可以通过  username.github.io  访问你的页面了（username换成你的名字，比如我的就是  glassx.github.io）</p>
<p><strong>总结一下，在整个过程中，hexo的安装按照官方给出的步骤一步步执行就可以了，nodejs的安装也不困难，建立的github仓库其实就是为了存放静态页面，只有在deploy的时候将静态文件推送上去，当然，github提供的page功能会将你的静态页面展示出来。</strong></p>
<p><strong>建议：为了能够在不同的平台上方便地更新博客，并且防止系统损坏等意外导致博客丢失，建议在github上另外建立一个仓库，用于存放BLOG文件夹的内容</strong></p>
<p>更多的博客装修内容可以参考：<a href="https://blog.csdn.net/weidong_y/article/details/90904781" target="_blank" rel="noopener">https://blog.csdn.net/weidong_y/article/details/90904781</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>手摸手</tag>
      </tags>
  </entry>
</search>
