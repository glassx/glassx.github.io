<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="glassx的小黑屋" type="application/atom+xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="类的构造方法Kotlin 中的类及接口 Kotlin中的类与Java的很像： 12345class Bird {	val weight: Double &#x3D; 500.0	val color: String &#x3D; &quot;blue&quot;	fun fly()}  反编译成Java的版本： 123456789101112131415161718public final class Bird {	private fin">
<meta property="og:type" content="article">
<meta property="og:title" content="第3章：面向对象">
<meta property="og:url" content="https://glassx.github.io/2021/08/12/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0/index.html">
<meta property="og:site_name" content="glassx的小黑屋">
<meta property="og:description" content="类的构造方法Kotlin 中的类及接口 Kotlin中的类与Java的很像： 12345class Bird {	val weight: Double &#x3D; 500.0	val color: String &#x3D; &quot;blue&quot;	fun fly()}  反编译成Java的版本： 123456789101112131415161718public final class Bird {	private fin">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://glassx.github.io/assets/Book-Notes/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0/%E9%92%BB%E7%9F%B3%E9%97%AE%E9%A2%98.png">
<meta property="article:published_time" content="2021-08-12T02:25:00.000Z">
<meta property="article:modified_time" content="2021-08-12T10:21:29.794Z">
<meta property="article:author" content="glassx">
<meta property="article:tag" content="读书笔记-Kotlin核心编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://glassx.github.io/assets/Book-Notes/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0/%E9%92%BB%E7%9F%B3%E9%97%AE%E9%A2%98.png">

<link rel="canonical" href="https://glassx.github.io/2021/08/12/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>第3章：面向对象 | glassx的小黑屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">glassx的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">小黑屋</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">162</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://glassx.github.io/2021/08/12/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="glassx">
      <meta itemprop="description" content="生活是天籁，需要凝神静听">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="glassx的小黑屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          第3章：面向对象
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-12 10:25:00 / 修改时间：18:21:29" itemprop="dateCreated datePublished" datetime="2021-08-12T10:25:00+08:00">2021-08-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <html><head></head><body></body></html><html><head></head><body><h2 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h2><h3 id="Kotlin-中的类及接口"><a href="#Kotlin-中的类及接口" class="headerlink" title="Kotlin 中的类及接口"></a>Kotlin 中的类及接口</h3><p> Kotlin中的类与Java的很像：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> weight: <span class="built_in">Double</span> = <span class="number">500.0</span></span><br><span class="line">	<span class="keyword">val</span> color: String = <span class="string">"blue"</span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>反编译成Java的版本：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> double weight = <span class="number">500.0D</span>;</span><br><span class="line">	<span class="meta">@NotNull</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String color = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> double getWeight() {</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@NotNull</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> String getColor() {</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> void fly() {</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由此可以看出，虽然声明方式很像，但是也存在很多不同：</p>
<ul>
<li>属性默认值。Kotlin中，除非显式声明延迟初始化，不然就需要指定默认值。</li>
<li>不同的可访问修饰符。Kotlin类中的成员默认是全局可见的(public)，而Java默认可见域是包作用域。  </li>
<li>方法默认是final修饰的。意味着不能覆写(这条是自己添加的)。</li>
</ul>
<p><strong>可带有属性和默认方法的接口</strong></p>
<p>我们知道，Java 8 之后，接口支持<strong>默认实现</strong>，如下所示：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flayer</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">kind</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>{</span><br><span class="line">	    System.out.println(<span class="string">"I can fly"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来看下Kotlin的接口实现：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> speed: <span class="built_in">Int</span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> {</span><br><span class="line">	    println(<span class="string">"I can fly"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同样，<strong>我们可以用Kotlin 定义一个带有方法实现的接口</strong>，同时，它还支持抽象属性（如例子中的speed属性），然而，Kotlin是基于Java6实现的，那它是如何支持的呢？转换为Java代码看下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getSpeed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">kind</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultImpls</span> </span>{</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(Flyer $<span class="keyword">this</span>)</span> </span>{</span><br><span class="line">	        String var1 = <span class="string">"I can fly"</span>;</span><br><span class="line">	        System.out.println(var1);</span><br><span class="line">	    }</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由此我们发现，Kotlin编译器<strong>通过定义一个静态内部类 DefaultImpls 来提供fly方法的默认实现</strong>。同时，<strong>抽象属性是通过一个get方法来实现的！</strong>所以呢，我们不能像Java一样，为属性直接赋值，如下这样是错误的：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> height = <span class="number">1000</span>;<span class="comment">//error Property initializers are not allowed in interfaces</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是Kotlin 提供了另外一种方式来实现这种效果：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">	<span class="keyword">val</span> height</span><br><span class="line">	    <span class="keyword">get</span>() = <span class="number">1000</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="更简洁地构造类的对象"><a href="#更简洁地构造类的对象" class="headerlink" title="更简洁地构造类的对象"></a>更简洁地构造类的对象</h3><p>如果要在Java中实现参数个数不同的构造方法，那我们就要重载很多个构造方法，这种方式主要存在2个缺点：</p>
<ul>
<li>如果要支持任意参数组合来创建对象，那么需要实现的构造方法非常多</li>
<li>每个构造方法中的代码都会冗余，如在构造方法中可能都需要对 age 和color 进行相同的赋值操作。</li>
</ul>
<p>Kotlin 通过引入新的构造语法来解决这些问题。比如我们可以用一行代码来表示复杂的构造方式：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span> = <span class="number">0.00</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">0</span>, <span class="keyword">val</span> color: String = <span class="string">"blue"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>如果用Java实现这种参数任意组合的效果，那是非常复杂的。但是如果不写入全部的参数，而只用其中某些参数的时候，需要写参数名，否则会报错：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的</span></span><br><span class="line"><span class="keyword">val</span> bird1 = Bird(<span class="number">1000.00</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确示例</span></span><br><span class="line"><span class="keyword">val</span> bird2 = Bird(weight = <span class="number">1000.00</span>, color = <span class="string">"black"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>init方法：事实上，<strong>我们的构造方法可以拥有多个 init，他们会在对象创建时按照类中从上到下的顺序先后执行</strong></p>
<p><strong>延迟初始化： by lazy 和 lateinit</strong></p>
<p>在Kotlin中，主要使用lateinit 和 by lazy 这两种语法来实现延迟初始化的效果。如果这是一个用 val 声明的变量，我们用 by lazy 来修饰：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> color: String) {</span><br><span class="line">	<span class="keyword">val</span> sex: String <span class="keyword">by</span> lazy {</span><br><span class="line">	    <span class="keyword">if</span>(color == <span class="string">"yellow"</span>) <span class="string">"male"</span> <span class="keyword">else</span> <span class="string">"female"</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结 by lazy 语法的特点如下：</p>
<ul>
<li>该变量必须是引用不可变的，而不能通过var声明</li>
<li>被首次调用时，才会进行赋值操作，一旦赋值，后续将不能更改。</li>
</ul>
<p>需要注意的是，系统会给 lazy属性默认加上同步锁，也就是 LazyThreadSafetyMode.SYNCHRONIZED ，它在同一时刻只允许一个线程对lazy属性初始化，<strong>所以，lazy是线程安全的</strong>。当然，你可以自己给lazy指定参数，如： <code>val sex: String by lazy(LazyThreadSafetyMode.NONE)</code>。</p>
<p>与lazy 不同，<strong>lateinit 主要用于 var 声明的变量，然而它不能用于基本数据类型，如 Int、Long 等</strong>，我们需要使用Integet这种包装类作为替代。lateinit 的用法如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> color: String) {</span><br><span class="line">	<span class="keyword">lateinit</span> <span class="keyword">var</span> sex: String</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">printSex</span><span class="params">()</span></span> {</span><br><span class="line">	    sex = <span class="keyword">if</span>(color == <span class="string">"yellow"</span>) <span class="string">"male"</span> <span class="keyword">else</span> <span class="string">"female"</span></span><br><span class="line">	    println(sex)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Kotlin只用一个构造方法实现了Java中需要重载才能实现的功能，那么，Kotlin中是否真的只需要一个构造方法呢？</p>
<h3 id="主从构造方法"><a href="#主从构造方法" class="headerlink" title="主从构造方法"></a>主从构造方法</h3><p>前面似乎遗漏了一些情况，简化前面的Bird类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(age: <span class="built_in">Int</span>) {</span><br><span class="line">	<span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">init</span> {</span><br><span class="line">	    <span class="keyword">this</span>.age = age</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>假设当前我们知道鸟的生日，希望可以通过生日来得到鸟的年龄，然后创建一个Bird对象，如何实现？有一种方案就是在别处定义一个工厂方法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Bird</span><span class="params">(birth: <span class="type">DateTme</span>)</span></span> = Bird(getAgeByBirth(birth))</span><br></pre></td></tr></tbody></table></figure>

<p>在哪声明这个工厂方法呢？这种方式的缺点在于，Bird 方法与Bird类在代码层面的分离不够直观。其实我们可以像Java那样新增一个构造方法来解决，Kotlin 也支持多构造方法，与Java的区别是，<strong>Kotlin中多个构造方法之间存在主从关系</strong>：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(age: <span class="built_in">Int</span>) {</span><br><span class="line">	<span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">init</span> {</span><br><span class="line">	    <span class="keyword">this</span>.age = age</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">constructor</span>(birth: DateTime) : <span class="keyword">this</span>(getAgeByBirth(birth)){</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码的运作方式是：</p>
<ul>
<li>通过constructor方法定义一个新的构造方法，称为<strong>从构造方法</strong>。相应地，我们熟悉的构造方法叫做<strong>主构造方法</strong>，每个类最多存在一个主构造方法，但是可以存在多个从构造方法</li>
<li>如果一个类存在主构造方法，那么每个从构造方法都要直接或间接地委托给它。</li>
</ul>
<h2 id="不同的访问控制原则"><a href="#不同的访问控制原则" class="headerlink" title="不同的访问控制原则"></a>不同的访问控制原则</h2><p>构造完对象，就要考虑访问控制了。</p>
<h3 id="限制修饰符"><a href="#限制修饰符" class="headerlink" title="限制修饰符"></a>限制修饰符</h3><p>我们知道，Kotlin中的类和方法默认实现反编译成 Java的时候，会被final修饰，所以，类默认是不能被继承的，方法默认也不能被覆写的，如果要实现继承，类之前需要用open修饰： <code>open class Bird {}</code> ，方法也需要使用open 修饰： <code>open fun fly()</code> </p>
<h4 id="类默认final-真的好吗？"><a href="#类默认final-真的好吗？" class="headerlink" title="类默认final 真的好吗？"></a>类默认final 真的好吗？</h4><p>网上有很多人认为默认final有很多缺点，那为什么Kotlin要设计成默认final呢？主要有2个原因：</p>
<ul>
<li>Kotlin 当前是一门以Android为平台的开发语言，在开发中，我们很少会频繁继承一个类，默认final会更加安全。</li>
<li>Kotlin的扩展手段更加丰富。不像Java，Kotlin 可以通过多种方式去扩展，而不是通过原始类的手段，典型的莫过于 Android 的Kotlin 扩展库 android-ktx，Google就是通过Kotlin的扩展语法而不是继承来实现。</li>
</ul>
<p>此外，Kotlin还可以利用<strong>密封类</strong>来限制一个类的继承，如下所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> = <span class="string">"I can fly"</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Eagle</span>: <span class="type">Bird</span></span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Kotlin通过 <strong>sealed 关键字</strong>来修饰一个类为密封类，<strong>若要继承则需要将子类定义在同一个文件中，其他文件中的类将无法继承它</strong>。但是这种方式有它的局限性，即它不能被初始化，为什么呢？<strong>这是因为它是基于抽象类实现的</strong>，我们看反编译后的Java代码就知道了：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Bird</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(DefaultConstructorMarker $constrctor_maker)</span> </span>{</span><br><span class="line">	    <span class="keyword">this</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Eagle</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>{</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">Eagle</span><span class="params">()</span> </span>{</span><br><span class="line">	        <span class="keyword">super</span>((DefaultConstructorMarker)<span class="keyword">null</span>)</span><br><span class="line">	    }</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>密封类的使用场景优先，它其实可以看成一种功能更强大的枚举，所以它在模式匹配中可以起到很大的作用</strong>。</p>
<h3 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h3><p>除了限制类修饰符外，还有一种可见性修饰符。Kotlin与Java的不同在于：</p>
<ul>
<li>默认修饰符不同，Kotlin是public，而Java是default</li>
<li>Kotlin中有一个独特的 internal    </li>
<li>Java类只有内部类可以用private修饰，其他类不允许；而Kotlin可以</li>
<li>protected访问范围不同。<strong>Java中是包、类及子类可访问，而Kotlin只有类和子类可以访问</strong>。</li>
</ul>
<p>说下Kotlin 独特的 internal 修饰符，它的作用域被称作<strong>模块内访问</strong>，那到底什么是模块？以下几种情况可以算作一个模块：</p>
<ul>
<li>一个Eclipse项目</li>
<li>一个 Intellij IDEA项目</li>
<li>一个Maven项目</li>
<li>一个Gradle项目</li>
<li>一组由一次Ant任务执行编译的代码</li>
</ul>
<p>那为什么要这种修饰符呢？Java的包内访问不好吗？Java包内访问确实是有问题的，举个例子，你再Java项目中定义了一个类，默认修饰符，那就是包私有的，其他地方将无法访问。然后你id啊宝诚一个类库，供三方使用。但如果有个开发者想使用这个类，除了copy源码以外，还有一个方式就是<strong>在程序中创建一个与该类相同名字的包，那么这个包下面的其他类就能直接使用我们前面定义的类了！</strong></p>
<p>而Kotlin这种，模块内可见指的是该类只对一起编译的其他Kotlin文件可见，开发工程与第三方类库不属于同一模块，这时候如果还想用，就只能复制源码了。</p>
<p>Java中我们很少见到private修饰的类，因为Java中的类或者方法没有单独属于某个文件的概念。若要用provate修饰，那么这个只能是其他类的内部类，而Kotlin中则可以用private给单独的类修饰，它的作用域就是当前这个Kotlin文件：</p>
<h2 id="解决多继承问题"><a href="#解决多继承问题" class="headerlink" title="解决多继承问题"></a>解决多继承问题</h2><p>Java和Kotlin都不支持多继承。为什么这样呢？是因为多继承会导致继承关系语义上的混淆。</p>
<h3 id="骡子的多继承困惑"><a href="#骡子的多继承困惑" class="headerlink" title="骡子的多继承困惑"></a>骡子的多继承困惑</h3><p>C++支持多继承，然而C++中存在一个经典的<strong>钻石问题</strong>。假如我们有个抽象的 Animal 类，它有个 run() 方法，Horse （马） 和 Donkey（驴） 都继承了Animal，假如支持多继承，Mule（驴）继承了 Horse 和 Donkey ，那么，在 Mule 中的 run() 到底是继承了谁的呢？这就是典型的钻石问题，因为继承关系像个钻石图，如下：</p>
<p><img src="/assets/Book-Notes/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0/%E9%92%BB%E7%9F%B3%E9%97%AE%E9%A2%98.png" alt="钻石问题"></p>
<h3 id="接口实现多继承"><a href="#接口实现多继承" class="headerlink" title="接口实现多继承"></a>接口实现多继承</h3><p>在Java中我们经常提及使用接口来实现多继承，其实，如果多个接口中都存在同样的方法，比如上述的 run() ，同样也会导致钻石问题。不过，<strong>Kotlin 通过提供 super 关键字来指定继承那个父接口的方法，从而解决了这个问题</strong>，如下：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyer</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="string">"flying animals"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="string">"flying animals"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(): Flyer, Animal {</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">kind</span><span class="params">()</span></span> = <span class="keyword">super</span>&lt;Flyer&gt;.kind()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过 <code>super&lt;Flyer&gt;.kind()</code>来指定继承哪个父接口的方法！当然，子类也可以自己实现这个方法，不用父类的，完全没问题。</p>
<h3 id="内部类解决多继承问题"><a href="#内部类解决多继承问题" class="headerlink" title="内部类解决多继承问题"></a>内部类解决多继承问题</h3><p>Kotlin的内部类的定义方式和Java 还不一样，如果我们按照Java的习惯来定义 Kotlin中的内部类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterKotlin</span> </span>{</span><br><span class="line">  <span class="keyword">val</span> name = <span class="string">"not kotlin inner class"</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ErrorInnerKotlin</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span> {</span><br><span class="line">      print(<span class="string">"thie name is <span class="variable">$name</span>"</span>)<span class="comment">//报错，不能访问name</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>报错了，和Java 还真不一样。其实，我们这样声明的是Kotlin 的 <strong>嵌套类</strong>，并非内部类。如果要在Kotlin中声明一个内部类，必须在这个类前面加一个 inner 关键字，即这样子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterKotlin</span> </span>{</span><br><span class="line">  <span class="keyword">val</span> name = <span class="string">"kotlin inner class"</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerKotlin</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span> {</span><br><span class="line">      print(<span class="string">"thie name is <span class="variable">$name</span>"</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>我们知道，Java中在内部类的语法上增加一个 static 关键字，就可以变成 嵌套类；Kotlin则是相反的思路，默认是嵌套类，必须加上 inner 关键字才是一个内部类。</p>
</blockquote>
<p>了解内部类之后，可以通过内部类实现上述的骡子类：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mule</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">runFast</span><span class="params">()</span></span> {</span><br><span class="line">    HorseC().runFast()</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">runSlow</span><span class="params">()</span></span> {</span><br><span class="line">    DonkeyC().runSlow()</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseC</span>: <span class="type">Horse</span></span>()</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">DonkeyC</span>: <span class="type">Donkey</span></span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用委托代替多继承"><a href="#使用委托代替多继承" class="headerlink" title="使用委托代替多继承"></a>使用委托代替多继承</h3><p><strong>Kotlin中的委托只需要通过 by 关键字就可以实现，比如之前学习的 by lazy 语法，其实就是利用了委托实现了延迟初始化</strong>。我们看下如何通过委托代替多继承需求：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Caneat</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyer</span>: <span class="type">CanFly {</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> {</span><br><span class="line">    println(<span class="string">"I can fly"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> : <span class="type">CanEat {</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> {</span><br><span class="line">    println(<span class="string">"I can eat"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(flyer: Flyer, animal: Animal): CanFly <span class="keyword">by</span> flyer, CanEat <span class="keyword">by</span> animal {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">  <span class="keyword">val</span> fyler = Flyer()</span><br><span class="line">  <span class="keyword">val</span> animal = Animal()</span><br><span class="line">  <span class="keyword">val</span> b = Bird(flyer, animal)</span><br><span class="line">  b.fly()</span><br><span class="line">  b.eat()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="真正的数据类"><a href="#真正的数据类" class="headerlink" title="真正的数据类"></a>真正的数据类</h2><h3 id="繁琐的JavaBean"><a href="#繁琐的JavaBean" class="headerlink" title="繁琐的JavaBean"></a>繁琐的JavaBean</h3><p>JavaBean中需要各种setter和getter，如果要支持对象值的比较，还得重写hashCode 和 equals 等方法。</p>
<h3 id="用data-class创建数据类"><a href="#用data-class创建数据类" class="headerlink" title="用data class创建数据类"></a>用data class创建数据类</h3><p>data class 顾名思义就是<strong>数据类</strong>，这不是Kotlin首创，在Scala等语言中也有。一般我们只需要如下定义即可：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">var</span> weight: <span class="built_in">Double</span>, <span class="keyword">var</span> age: <span class="built_in">Int</span>, <span class="keyword">var</span> color: String)</span><br></pre></td></tr></tbody></table></figure>

<p>这么一行代码，编译器为我们做了很多事情，来看看反编译后的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>{</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">double</span> var1)</span> </span>{</span><br><span class="line">      <span class="keyword">this</span>.weight = var1;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>{</span><br><span class="line">      <span class="keyword">this</span>.age = var1;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getColor</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="meta">@NotNull</span> String var1)</span> </span>{</span><br><span class="line">      Intrinsics.checkNotNullParameter(var1, <span class="string">"&lt;set-?&gt;"</span>);</span><br><span class="line">      <span class="keyword">this</span>.color = var1;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(<span class="keyword">double</span> weight, <span class="keyword">int</span> age, <span class="meta">@NotNull</span> String color)</span> </span>{</span><br><span class="line">      Intrinsics.checkNotNullParameter(color, <span class="string">"color"</span>);</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.weight = weight;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">      <span class="keyword">this</span>.color = color;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">component1</span><span class="params">()</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">component2</span><span class="params">()</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">component3</span><span class="params">()</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Bird <span class="title">copy</span><span class="params">(<span class="keyword">double</span> weight, <span class="keyword">int</span> age, <span class="meta">@NotNull</span> String color)</span> </span>{<span class="comment">//Java中没有的</span></span><br><span class="line">      Intrinsics.checkNotNullParameter(color, <span class="string">"color"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Bird(weight, age, color);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Bird copy$<span class="keyword">default</span>(Bird var0, <span class="keyword">double</span> var1, <span class="keyword">int</span> var3, String var4, <span class="keyword">int</span> var5, Object var6) {</span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">1</span>) != <span class="number">0</span>) {</span><br><span class="line">         var1 = var0.weight;<span class="comment">//copy时，若未指定具体属性的值，则使用被copy对象的属性值，这是浅拷贝</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">2</span>) != <span class="number">0</span>) {</span><br><span class="line">         var3 = var0.age;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((var5 &amp; <span class="number">4</span>) != <span class="number">0</span>) {</span><br><span class="line">         var4 = var0.color;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> var0.copy(var1, var3, var4);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Bird(weight="</span> + <span class="keyword">this</span>.weight + <span class="string">", age="</span> + <span class="keyword">this</span>.age + <span class="string">", color="</span> + <span class="keyword">this</span>.color + <span class="string">")"</span>;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{</span><br><span class="line">      <span class="keyword">int</span> var10000 = (Double.hashCode(<span class="keyword">this</span>.weight) * <span class="number">31</span> + Integer.hashCode(<span class="keyword">this</span>.age)) * <span class="number">31</span>;</span><br><span class="line">      String var10001 = <span class="keyword">this</span>.color;</span><br><span class="line">      <span class="keyword">return</span> var10000 + (var10001 != <span class="keyword">null</span> ? var10001.hashCode() : <span class="number">0</span>);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="meta">@Nullable</span> Object var1)</span> </span>{</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> != var1) {</span><br><span class="line">         <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Bird) {</span><br><span class="line">            Bird var2 = (Bird)var1;</span><br><span class="line">            <span class="keyword">if</span> (Double.compare(<span class="keyword">this</span>.weight, var2.weight) == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.age == var2.age &amp;&amp; Intrinsics.areEqual(<span class="keyword">this</span>.color, var2.color)) {</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这就和JavaBean很相似了，同时还有 equals 和 hashCode 的实现。同时，我们发现里面有几个JavaBean中没有的方法，比如 copy、component1、component2、component3。下一节来介绍它们。</p>
<h3 id="copy-、componentN-与-结构"><a href="#copy-、componentN-与-结构" class="headerlink" title="copy 、componentN 与 结构"></a>copy 、componentN 与 结构</h3><p>上上述代码可以看到，两个copy方法，可以传入响应的参数来生成不同的对象；同时，如果你未指定具体属性的值，那么新生成的对象的属性值将使用被copy对象的属性值，这就是我们常说的浅拷贝。看个例子：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果Bird的属性是var，即可变的</span></span><br><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>,<span class="number">1</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="keyword">val</span> b2 = b1</span><br><span class="line">b2.age = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果Bird的属性是val，不可变的，那么更改属性只能通过copy</span></span><br><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>,<span class="number">1</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="keyword">val</span> b2 = b1.copy(age = <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>



<p><strong>注意，Kotlin提供的上述copy方法是浅拷贝的，所以我们要注意使用场景。</strong>因为数据类的属性可以被修饰为var，所以不能保证不会出现引用被修改的情况。</p>
<p>接下来看 componentN (其中N为1，2，3…，根据参数个数来定)，这个设计到底有什么用？我们或多或少直到怎么将属性绑定到类上，但是对于如何将类的属性绑定到响应变量上却不是很熟悉，比如：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>,<span class="number">1</span>, <span class="string">"blue"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通常方法，也符合Java的思维逻辑</span></span><br><span class="line"><span class="keyword">val</span> weight = b1.weight</span><br><span class="line"><span class="keyword">val</span> age = b1.age</span><br><span class="line"><span class="keyword">val</span> color = b1.color</span><br><span class="line"></span><br><span class="line"><span class="comment">//Kotlin 进阶方法</span></span><br><span class="line"><span class="keyword">val</span> (weight, age, color) = b1</span><br></pre></td></tr></tbody></table></figure>

<p>看到进阶方法的时候，一定感到兴奋了吧，普通方法确实很繁琐。还有一种情形，看Java的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String birdInfo = <span class="string">"20.0,1, blue"</span>;</span><br><span class="line"><span class="comment">//如果要把值取出来，就得split</span></span><br><span class="line">String[] temps = birdInfo(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">double</span> weight = Double.valueOf(temps[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> age = Integer.valueOf(temps[<span class="number">1</span>]);</span><br><span class="line">String color = temps[<span class="number">2</span>];</span><br></pre></td></tr></tbody></table></figure>

<p>在我们明明直到值得情况下，还需要这样分割，很繁琐，好在Kotlin提供了更优雅的做法：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (weight, age, color) = birdInfo.split(<span class="string">","</span>)</span><br></pre></td></tr></tbody></table></figure>



<p>这个语法也很简洁和直观，其原理也很简单，就是 <strong>解构</strong>，通过编译器的约定实现解构。当然，<strong>Kotlin对于解构也有限制，在数组中它默认最多允许赋值5个变量，因为如果变量过多，效果反而会适得其反，因为到后期你都搞不清哪个值要赋给哪个变量了</strong>。除了利用编译器自动生成的 componentN之外，你还可以实现自己的 componentN，比如：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>(<span class="keyword">var</span> weight: <span class="built_in">Double</span>, <span class="keyword">var</span> age: <span class="built_in">Int</span>, <span class="keyword">var</span> color: String) {</span><br><span class="line">  <span class="keyword">var</span> sex = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> component4: <span class="built_in">Int</span> {//注意 <span class="keyword">operator</span> 关键字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sex</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(weight: <span class="built_in">Double</span>, age: <span class="built_in">Int</span>, color: String, sex: <span class="built_in">Int</span>) : <span class="keyword">this</span>(weight, age, color) {</span><br><span class="line">    <span class="keyword">this</span>.sex = sex</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//使用</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> {</span><br><span class="line">    <span class="keyword">val</span> b1 = Bird(<span class="number">20.0</span>, <span class="number">1</span>, <span class="string">"blue"</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> (weight, age, color, sex) = b1</span><br><span class="line">    ...</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>除了数组支持解构外，Kotlin也提供了其他常用数据类型，分别是 Pair 和 Triple 前者是二元组，后者是 三元组，，我们可以</p>
<p>用类似以下方法来使用它们：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pair = Pair(<span class="number">20.0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">//利用属性顺序获取</span></span><br><span class="line"><span class="keyword">val</span> weightP = pair.first</span><br><span class="line"><span class="keyword">val</span> ageP = pair.second</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用解构</span></span><br><span class="line"><span class="keyword">val</span> (weightP, ageP) = Pair(<span class="number">20.0</span>,<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>



<h2 id="从static-到-object"><a href="#从static-到-object" class="headerlink" title="从static 到 object"></a>从static 到 object</h2><p>Kotlin中告别了static，因为有了 object 关键字，除了替代static外，它还有更多的功能实现，比如单例对象以及简化匿名表达式等。</p>
<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>看一段常见的Java代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prize</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> TYPE_REDPACK = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRedpack</span><span class="params">(Prize prize)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> prize.type == TYPE_REDPACK;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这个类中既有静态变量、静态方法，也有普通变量、普通方法，然而，静态变量和静态方法是属于类的，普通变量和普通方法是属于具体对象的，所以在代码解构上职能并不清晰。Kotlin中利用 companion object 两个关键字引入伴生对象来清晰区分。</p>
<blockquote>
<p>顾名思义，“伴生”即伴随某个类的对象，它属于这个类所有，全局只有一个单例，因此伴生对象跟Java中static修饰的效果一样，<strong>在类装载的时候被初始化</strong>。</p>
</blockquote>
<p>companion object 用花括号包裹了所有静态属性和方法，使得将普通方法和属性清晰区分开来。此外，伴生对象很适合作为工厂，这里就不展开。</p>
<h3 id="天生的单例：-object"><a href="#天生的单例：-object" class="headerlink" title="天生的单例： object"></a>天生的单例： object</h3><p>单例模式最大的一个特点就是在系统中只能存在一个实例对象，所以在java中我们必须通过设置构造方法私有化，以及提供静态方法创建实例的方式来创建单例。在Kotlin中，由于object的存在，我们可以直接用它来实现单例，如下所示：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DatabaseConfig {</span><br><span class="line">  <span class="keyword">var</span> host: String = <span class="string">"127.0.0.1"</span></span><br><span class="line">  <span class="keyword">var</span> port: <span class="built_in">Int</span> = <span class="number">3306</span></span><br><span class="line">  <span class="keyword">var</span> userName: String = <span class="string">"root"</span></span><br><span class="line">  <span class="keyword">var</span> password: String = <span class="string">""</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>由于object全局声明的对象只有一个，所以它并不用语法上的初始化，甚至都不需要构造方法，因此，我们可以说object创造的是天生的单例</strong>。此外，由于 DatabaseConfig 的属性是 var 声明的属性，我们还能修改它们： </p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatabaseConfig.host = <span class="string">"localhost"</span></span><br><span class="line">DatabaseConfig.port = <span class="number">3307</span></span><br></pre></td></tr></tbody></table></figure>



<p>由于<strong>单例也可以和普通类一样实现接口和继承类</strong>，所以可以将其看成一种不需要主动初始化的类，它也<strong>可以拥有扩展方法</strong>，<strong>单例对象会在系统加载的时候初始化</strong>。</p>
<h3 id="object-表达式"><a href="#object-表达式" class="headerlink" title="object 表达式"></a>object 表达式</h3><p>主要说的是，利用object来完善匿名内部类，这里不展开说。</p>
</body></html>
    </div>

    
    
    
        <div class="reward-container">
  <div>谢谢你的鼓励</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/WechatReward.png" alt="glassx 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" rel="tag"># 读书笔记-Kotlin核心编程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2021/08/10/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E7%AC%AC2%E7%AB%A0/" rel="next" title="第2章：基础语法">
                  <i class="fa fa-chevron-left"></i> 第2章：基础语法
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2021/08/18/%E4%B9%A6-kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E8%87%AA%E5%B7%B1%E5%8A%A0%E7%9A%84%E7%89%B9%E5%88%AB%E7%AF%87/" rel="prev" title="自己编的-特殊函数">
                  自己编的-特殊函数 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">类的构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Kotlin-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8F%8A%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.</span> <span class="nav-text">Kotlin 中的类及接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E7%AE%80%E6%B4%81%E5%9C%B0%E6%9E%84%E9%80%A0%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.</span> <span class="nav-text">更简洁地构造类的对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">主从构造方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%8E%9F%E5%88%99"><span class="nav-number">2.</span> <span class="nav-text">不同的访问控制原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">2.1.</span> <span class="nav-text">限制修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E9%BB%98%E8%AE%A4final-%E7%9C%9F%E7%9A%84%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="nav-number">2.1.1.</span> <span class="nav-text">类默认final 真的好吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">2.2.</span> <span class="nav-text">可见性修饰符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">解决多继承问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%A1%E5%AD%90%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%9B%B0%E6%83%91"><span class="nav-number">3.1.</span> <span class="nav-text">骡子的多继承困惑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">3.2.</span> <span class="nav-text">接口实现多继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.</span> <span class="nav-text">内部类解决多继承问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%94%E6%89%98%E4%BB%A3%E6%9B%BF%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">3.4.</span> <span class="nav-text">使用委托代替多继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">真正的数据类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B9%81%E7%90%90%E7%9A%84JavaBean"><span class="nav-number">4.1.</span> <span class="nav-text">繁琐的JavaBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8data-class%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%B1%BB"><span class="nav-number">4.2.</span> <span class="nav-text">用data class创建数据类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy-%E3%80%81componentN-%E4%B8%8E-%E7%BB%93%E6%9E%84"><span class="nav-number">4.3.</span> <span class="nav-text">copy 、componentN 与 结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8Estatic-%E5%88%B0-object"><span class="nav-number">5.</span> <span class="nav-text">从static 到 object</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.1.</span> <span class="nav-text">伴生对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A9%E7%94%9F%E7%9A%84%E5%8D%95%E4%BE%8B%EF%BC%9A-object"><span class="nav-number">5.2.</span> <span class="nav-text">天生的单例： object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#object-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.3.</span> <span class="nav-text">object 表达式</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="glassx"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">glassx</p>
  <div class="site-description" itemprop="description">生活是天籁，需要凝神静听</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">162</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://atyxia.github.io/" title="https:&#x2F;&#x2F;atyxia.github.io&#x2F;" rel="noopener" target="_blank">传说中的伟哥</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">glassx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_pv">
    本站访问量:<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">
    本站总访客量：<span id="busuanzi_value_site_uv"></span>人
  </span>
</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共341.2k字</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>















  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '014f25b646a6b4e4caf9',
      clientSecret: '1874f37da4d837c5866039f706ec722ea42d790d',
      repo: 'comments',
      owner: 'glassx',
      admin: ['glassx'],
      id: '8c9cb8dffddbf308ad6f9684a8fdf191',
        language: 'zh-CN',
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

</body>
</html>
