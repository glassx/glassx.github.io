{"meta":{"title":"glassx的小黑屋","subtitle":"小黑屋","description":"glassx的小黑屋,读书笔记","author":"glassx","url":"https://glassx.gitee.io","root":"/"},"pages":[],"posts":[{"title":"第2章：dart语言入门","slug":"Flutter从0到1构建大前端应用-第2章","date":"2019-10-20T02:13:00.000Z","updated":"2019-10-20T13:26:56.609Z","comments":true,"path":"2019/10/20/Flutter从0到1构建大前端应用-第2章/","link":"","permalink":"https://glassx.gitee.io/2019/10/20/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8-%E7%AC%AC2%E7%AB%A0/","excerpt":"","text":"编写hello world使用dart 在控制台输出 hellow world 是比较简单的： 123void main()&#123; print(\"hello world !\")&#125; 变量与常量使用var声明一个变量，在未初始化之前，默认值为null；如果想设置一个常量，即让一个变量不可变，那么可以使用final 或者 const 修饰： 123456789101112var num;num = 15;print(\"小明的年龄是 $num 岁\");num = '20'; //注意，变量的类型是可以变化的！！！print(num);final c= 30； //final 修饰的变量只能被声明一次print(c);const d = 50;print(d); 那么const 和final 的区别是什么呢？const 变量是一个编译时常量，final 变量在第一次使用时被初始化(const 是隐式的 final)，实例变量可以是 final ，但是不能 const，常量如果是类级别的，可以使用 static const，例如： const static PI = 3.1415 字符串Dart 里面的字符串有以下几种创建方式： 使用单引号、双引号创建字符串。 使用三个引号或者双引号创建多行字符串。 使用r创建原始raw字符串。 1234567var str1 = 'hello'var str2 = \"hello\"//使用三个引号创建多行var str3 = '''hello Bob'''//使用r创建 var str4 = r'你好啊' 注意，如果单引号里面嵌套单引号或者双引号里面嵌套双引号，则需要使用反斜杠进行转义。 在Dart里，可以对字符串进行单行拼接，也可以多行拼接： 123456789101112131415String s1 = 'ha' 'ha'; //单引号空格拼接String s1 = \"ha\" \"ha\"; //双引号空格拼接//使用加号(+)拼接和java一样，不赘述//使用三引号多行拼接String s1 = ''' Android开发工程师 前端开发工程师 '''; String s1 = \"\"\" Android开发工程师 前端开发工程师 \"\"\"; list 与数组Dart 中，List 表示集合，其实和数组是同一个概念，创建方式如下： 12345678var list = [1,2,3];var list = new List();//创建不可变list，如果试图改变不可变list，就会报错var list = const[1,2,3];//随机打乱里面的元素顺序list.shuffle() map123456Map name = &#123;\"name\": \"haha\"&#125;//创建不可变mapMap name = const&#123;\"name\": \"haha\"&#125;Map name = new Map();name['name'] = 'haha' dynamic 和 Object在Dart中，一切皆对象，而且这些对象的父类都是 Object，当没有选择明确的类型时，编译的时候回根据值去明确类型： 123var name1 = 'abc'Object name = 'abc'dynamic name = 'abc' 以上写法都没有问题，但是dart并不建议这样做，在实际开发中，我们尽量为变量明确类型，这样可以加快运行速度(如果不指定类型，则在debug模式下类型会是动态的)，并且提高安全性。 使用dynamic 时则是告诉编译器，我们不用做类型检测，并且知道自己在做什么，如果我们调用一个不存在的方法时，会执行 noSuchMethod()方法，在默认情况下，会抛出NoSuchMethodError 异常。 运算符 三目运算： 如： var a = b &gt; 10 ? a : 0 ~/ 除法： 返回一个整数结果(取商)： var z = 12~/7print(z) //结果是3，这个结果还未验证，将信将疑？？？ 级联操作符：类似一些语言中的链式调用，例如： String s = new StringBuffer() ..write(‘a’) ..write(‘b’) .toString(); print(s);// 打印出 ab 判断某种类型： as、is、is! (注意感叹号在is的后面) 异常捕获Dart 的异常捕获比Java还要强大，可以抛出任意类型的对象，抛出异常的方式通常如下： throw Exception(‘我是异常’) 使用try-catch保证程序健壮性： 12345678try&#123;//do something&#125; on AuthorizationException catch(e)&#123; //捕获特定类型异常&#125;catch(e)&#123; //...&#125;finally&#123;&#125; 函数可以用以下方式定义一个普通函数： 123bool getName(name)&#123; return name;&#125; 可选参数可选的命名参数，即不传这些参数也可以，在定义参数是，使用{params1,params2,…}指定命名参数： 12void userSetting(int age,String name)&#123;&#125; 这个函数中，我们可以传递age、name，或者其中一个，或者都不传递也可以。 必传参数我们可以使用 @required 来修饰参数，表示参数必传： 12void userSetting(&#123;@Required int age,@Required String name)&#123;&#125; 可选位置参数书上没有说什么叫做可选位置参数，我个人理解是，同时包含了必选参数以及可选参数，可以用[]把目标标记为可选的位置参数： 12345void userSetting(&#123;int age,String name,[String interestes]&#125;)&#123; if(interestes != null)&#123; print('兴趣爱好:$interestes'); &#125;&#125; 默认参数类似于kotlin，默认参数在参数后接 “=” : 1void userSetting(&#123;int age = 12,String name = '小明'&#125;) 函数可作为参数传递这个可能稍微有点费解，就是把一个函数当做一个参数传递给另外一个函数，看例子： 123456void printItem(String item)&#123; print(item);&#125;var users = ['小明','小王']users.forEach(printItem); 函数作为变量函数也可以直接作为一个变量使用，并且后续可以使用这个变量作为函数来调用： 123var say = (name)&#123; say('过年了');&#125; 异步编程Dart 和 JavaScript 的一个共同点是——单线程，同步代码会阻塞程序，因此在程序中能看到大量的异步操作。在Flutter 中，是使用 Future 对象来执行相关操作的，Futrue 支持链式操作，可以按顺序执行异步函数。 Future 是什么一个 Future 是一个 Future 自身的泛型 Future 对象，他表示一个异步操作产生的 T 类型的结果，当然，T可以是void类型，如果返回一个Future的函数被调用了，将发生以下两件事： 这个函数加入待完成队列并且返回一个未完成的 Future 对象。 当这个操作结束了，Future 对象返回一个值或者错误。 1234Future&lt;int&gt; future = getFuture();future.then((value) =&gt; handleValue(value)) .catchError((error) =&gt; handleError(error)).whenComplete() =&gt; handlerComplete(); 我们在future.then中接受异步处理的结果，并根据业务做相应处理。而future.catchError则用于捕获并处理错误。无论失败或者成功，都需要处理的业务可以放在 whenComplete 中。 async 和 await当遇到有需要延迟的运算(async)时，将其放到延迟运算的队列(await)中，把不需要的延迟运算的部分先执行完，最后来处理延迟运算部分，要使用await，就必须在async标记的函数中运行，否则这个await会报错。async 和 await 是Future 的语法糖，解决了回调地狱(Callback Hell) 问题。它们的用法例子如下： 123456789steps() async&#123; try&#123; String step1Result = await step1('step1'); String step2Result = await step2(step1Result); String step3Result = await step3(step2Result); &#125;catch(e)&#123; print(e); &#125;&#125; 从代码可以看出，await 必须被包裹在async 里面，假如没有使用这两个语法糖，那么代码将会是这样的： 123456789step1('step1').then((step1Result)&#123; step2(step1Result).then(step2Result)&#123; step3(step2Result).then(step3Result)&#123; //step4 //step5 ... &#125; &#125;&#125;) 可以看出，这确实使代码变得整洁易读。 泛型Dart 的泛型和Java的很类似，如下例子，就不多说： 12345List animals = new List&lt;String&gt;();class NewAnimal&lt;T extends Animal&gt;&#123; String toString() =&gt; \"创建一个新的小动物\"&#125; 继承、接口实现 和 混合dart 的继承使用 extends ，接口实现使用 implements ，同时，dart也是单继承，并且通过 @Override 来重写父类的方法，也可以通过super 来调用父类的方法，这与Java相似。另外，由于flutter没有Java中的公有和私有访问修饰符，因此可以直接访问父类中的所有变量和方法。 接口的实现：Fluuter 是没有接口(interface)关键字的，但是每个类都是一个隐式的接口，这个接口包含类中的所有成员变量和定义的方法，当类被当做接口时，类中的所有方法就是接口中的方法，它需要在子类中被重新实现： 1234567891011121314151617181920abstract class CanFixComputer&#123; void fixComputer();&#125;class CanProgramming&#123; void programming()&#123; &#125;&#125;class SoftwareEngineer extends Engineer implements CanFixComputer, CanProgramming&#123; @Override void fixComputer()&#123; print('软件工程师修电脑'); &#125; @Override void programming()&#123; print('码农写代码'); &#125;&#125; 上面的代码将 CanProgramming 作为接口实现，因此如果不重写 programming 就会报错。 接下来来借料Dart提供的混合(mixins,也可理解为混入)语法特性，它的作用是在类中混入其它功能，通俗地将，mixins 是一个可以把自己方法提供给其它类使用，但却不需要称为其它类的父类的类，它以非继承的方式来复用类中的代码，mixins 使用with关键字来实现： 12345678910111213141516171819202122232425262728293031323334abstract class CanFixComputer&#123; factory CanFixComputer._()&#123; return null; &#125; void fixComputer()&#123; print('软件工程师修电脑'); &#125;&#125;abstract class CanProgramming&#123; factory CanProgramming._()&#123; return null; &#125; void programming()&#123; print('码农写代码'); &#125;&#125;abstract class Work&#123; void doWork();&#125;class Engineer extends Worker&#123; void doWork()&#123; print('工程师在工作'); &#125;&#125;class SoftEngineer extends Engineer with CanFixComputer, CanProgramming&#123; &#125; 这样，在 SoftEngineer 类中就可以使用 CanFixComputer 和 CanProgramming 中的方法了，有些同学可能有疑问了，如果写成下面这样子： 1234567891011121314151617181920212223class Teacher extends Worker&#123; void doWork()&#123; print('老师在上课'); &#125;&#125;class Engineer extends Worker&#123; void doWork()&#123; print('工程师在工作'); &#125;&#125;class Driver extends Worker&#123; void doWork()&#123; print('开车'); &#125;&#125;class SoftEngineer extends Engineer implements Driver with Teacher&#123; void doWork()&#123; print('我自己的方法'); &#125;&#125; 上述代码中，SoftEngineer 自己有个doWork 方法，并且继承的类，实现的接口以及mixins的类都有doWork方法，那么在调用 doWork 方法时，到底怎么调用呢？它们的原则是这样的： 如果类本身有这个方法，则调用本身的方法 否则调用 mixins 的这个方法 如果mixins 也没有这个方法，则调用 extends 的这个方法 如果extends 也没有这个方法，则调用 implements 类中的这个方法 优先级方法： 自身方法-&gt; mixins -&gt; extends -&gt; implements","categories":[],"tags":[{"name":"Flutter从0到1构建大前端应用","slug":"Flutter从0到1构建大前端应用","permalink":"https://glassx.gitee.io/tags/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/"}]},{"title":"第1章：Flutter 简介","slug":"Flutter从0到1构建大前端应用-第1章","date":"2019-10-19T14:21:00.000Z","updated":"2019-10-19T14:02:15.495Z","comments":true,"path":"2019/10/19/Flutter从0到1构建大前端应用-第1章/","link":"","permalink":"https://glassx.gitee.io/2019/10/19/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8-%E7%AC%AC1%E7%AB%A0/","excerpt":"","text":"Flutter 的优势 跨平台：开发的代码可同时部署在 Android、ios、web、桌面 环境上。 流畅的跨平台UI。使用“自绘UI + 原生系统”，配合 Skia 2D 引擎，实现高帧率的流畅UI，比webview这种方式效率更高。 开发过程中支持热重载，只需要保存代码即可在设备上看到更改后的效果，提高了开发效率。 对开发环境要求低，目前支持 Android Studio 和 VScode 两种 IDE 。 Flutter架构学习一门新技术，首先要对其整个技术体系有个大概的了解。Flutter 整体可以分为Framework 和 Engine 两个部分，官方给出的架构图如下： Flutter FrameworkFramework 是由纯 Dart 语言实现的 SDK ，Dart 也是Flutter 的官方语言。以下分别介绍各层作用： 最底下的两个层：底层UI库，提供动画、手势及绘制功能供开发者调用。 Rendering层：负责构建UI树，每当 UI 树上的 Element 发生变化时，都会计算出有变化的部分并且会更新UI树，最终将UI树绘制到屏幕上。 Widgets 层： 基础组件库，Flutter 默认帮我们提供了 Material (即 Android 风格) 和 Cupertino(即 ios 风格) 两种视觉风格的组件库。 Flutter EngineEngine 是由纯 C++ 实现的 SDK，Framework 层所有的UI库都会调用到 Engine 这一层。 Skia： 2D 渲染引擎(Android 系统自带，但ios 系统不自带，因此，ios 报所占的存储空间更大)。 Dart： Dart 运行时。 Text： 文字排版引擎。 开发环境搭建个人觉得，开发环境搭建按照官方文档会更好，并且官方有中文文档，唯一要注意的是，在中国使用 Flutter 需要注意资源获取的问题。附： flutter官方中文文档——环境搭建：https://flutter.cn/docs/get-started/install 中国网络环境的注意事项：https://flutter.cn/community/china 还要注意的一点是，设置flutter环境变量的时候最好设置永久的环境变量，不然重启电脑环境变量就会无效了。 Flutter 升级和分支切换可以通过在项目的根目录中(包含pubspec.yaml的目录)输入命令： flutter upgrade 对flutter 进行升级，这里还介绍下 Flutter channels 相关的概念，Flutter 有4种release channel ，即：stable、beta、dev、master，官方推荐使用 stable channel ，我们可以在命令行输入以下命令来查看当前的 channel，并会列出所有channel： flutter channel 用 * 标识的位置表示当前channel ，如果想要切换channel 到stable 分支，可以用以下命令： flutter channel stable 这里还有需要注意的是 pubspec.yaml，这个文件掌管着 Flutter 所需要的依赖包，有点类似于 Node.js 中的 package.json ，这些 Flutter 依赖包有内置的，还有别的开发者发布的，我们可以通过命令 flutter packages get 获取依赖包列表，还能通过 flutter pachages upgrade 命令升级这些依赖包。","categories":[],"tags":[{"name":"Flutter从0到1构建大前端应用","slug":"Flutter从0到1构建大前端应用","permalink":"https://glassx.gitee.io/tags/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/"}]},{"title":"第7章：Android启动过程简析","slug":"深入理解Android内核设计思想-第7章","date":"2019-10-09T14:00:00.000Z","updated":"2019-10-09T14:37:24.344Z","comments":true,"path":"2019/10/09/深入理解Android内核设计思想-第7章/","link":"","permalink":"https://glassx.gitee.io/2019/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC7%E7%AB%A0/","excerpt":"","text":"第一个系统进程(init)Android设备的启动必须经历3个阶段： Boot Loader、Linux Kernel 以及 Android 系统服务，默认情况下它们都有各自的启动画面。作为Android 中第一个被启动的进程，init的 PID 的值为 0，它通过解析 init.rc 脚本来构建出系统的初始运行形态——其中最重要的就是启动 ServiceManager、Zygote 和 SystemServer。 Android 的“DNS服务器”——ServiceManagerServiceManager 是Binder 机制中的“DNS服务器”，负责域名(某Binder服务在 ServiceManager 注册时提供的名称) 到IP地址(由底层Binder驱动分配的值)的解析。 ServiceManager 所属class 是core ，并且带有 critical 选项，说明它是系统的关键进程——意味着如果进程不幸在4分钟内异常退出4次，则设备将重启并进入还原模式。当 ServiceManager 重启时，zygote、media、surfaceflinger 等都会被重启。 “孕育” 新的线程和进程——Zygote这个单词是”受精卵”的意思，正如其名所示，Android 中大多数的应用进程和系统进程都是通过 Zygote 来生成的。它所在的程序名叫做”app_process” ，而不像 ServiceManager 一样在一个独立的进程中。在init 进程的帮助下，通过zygote 逐步建立起 SystemServer 的运行环境。 Android的“系统服务”——SystemServerSystemServer 是 Android 进入 Launcher 前的最后准备。ZygoteInit 通过 Zygote.forkSystemServer 来生成一个新的进程，用于承载各系统服务。","categories":[],"tags":[{"name":"深入理解Android内核设计思想-林学森","slug":"深入理解Android内核设计思想-林学森","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E6%9E%97%E5%AD%A6%E6%A3%AE/"}]},{"title":"第6章：进程间通信——Binder","slug":"深入理解Android内核设计思想-第6章","date":"2019-09-26T13:36:00.000Z","updated":"2019-09-28T13:58:06.929Z","comments":true,"path":"2019/09/26/深入理解Android内核设计思想-第6章/","link":"","permalink":"https://glassx.gitee.io/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC6%E7%AB%A0/","excerpt":"","text":"我们知道，同一个程序中两个函数之间能够直接调用的根本原因是他们处于相同的内存区域中，因为在同一个内存区域中，虚拟地址的映射规则完全一致，所以A函数和B函数的调用关系很简单，但两个不同进程，他们是没有办法直接通过内存地址来访问到对方内部的函数或者变量的。 既然无法直接访问，那间接的方法就是Binder。如果通观Binder的各个元素，就会惊奇地发现它和 TCP/IP 网络有很多相似之处： Binder 驱动 -&gt; 路由器 Service Manager（本质也是个服务器） -&gt; DNS（本质也是个服务器） Binder Client -&gt; 客户端 Binder Server -&gt; 服务器 TCP/IP中一个典型的服务连接过程如下图所示： 这个简化的流程图有以下几个步骤： Client 向dns 查询 google.com 的ip地址。显然，Client 一定得先知道DNS 的 IP地址，才能向它发起查询，DNS 服务器的ip设置是在接入网络前就已经设置完成的。当然，client向DNS 查询 ip地址不一定需要，因为如果已经知晓server的ip，就无需这一步，从而加快访问速度； DNS 将查询结果返回 Client。Client的Ip地址对于 DNS 是必须的，不过这些信息会封装在 TCP/IP 包中。 Client 发起连接。这里我们没有提及Router的作用，因为它所负担的责任是将数据包投递到用户设定的目标IP中，它是整个通信结构中的基础。 而对于Binder来说，Binder的 DNS (Service Manager)也不是必须的——前提是客户端能记住它要访问的进程的 Binder 标志（IP地址），尤其要注意的是，这个标志是个“动态IP”，意味着即使客户端记住了本次通信过程中目标进程的唯一标志，下一次访问仍然需要重新获取。因此，Service Manager 这个 DNS 的还是挺有必要的。 既然Service Manager是 DNS 服务器，那么它的 IP 地址是多少呢？Binder 机制对此作了特别规定，Service Manager在Binder通信中唯一标志用于都是0。 智能指针略 进程间的数据传递载体——Parcel关于进程间如何传递，我们可以使用2个生活例子来类比： 用快递寄衣服：虽然快递种类比较多，但是无论用哪个快递，用哪种运输方式，“衣服”本身始终是没有变过的，接收人拿到的还是原来那件衣服。 通过电子邮件发送图片：在接收人看到邮件中的图片时，我们无法确认这张图片在传输过程中被复制了多少次，但是可以肯定的是，对方看到的图片和原始图片是一样的。 进程间通信的数据传递类似于第2种情况，如果只是一个int型数值，不断复制直到目标进程即可；如果是一个对象呢？我们直到，同一个进程中对象的传递实质上是传递了一个内存地址，但是在跨进程的情况下就无能为力了，因为采用了虚拟内存机制，两个进程都有自己独立的内存地址空间，所以跨进程传递的地址空间是无效的。 进程间的数据传递是Binder 机制中的重要环节，而担负这一重任的就是Parcel。 Parcel 的直译是 “打包” ，上面提到，进程间数据传递直接传送对象的地址是行不通的，那把对象在进程 A 中占据的内存相关数据打包起来，然后寄送到内存 B 中，由 B 在自己的进程空间中“复现”这个对象，是否可行？ Parcel 就具有这种打包能力。 Parcel 提供了很多接口方便程序使用，他可以存储多种类型的数据： 原始数据类型 以及 原始数据类型数组 Parcelable Bundle Active Objects 通常我们存入Parcel 的是对象的内容，而 Active Objects 写入的则是他们的特殊标志引用。所以从 Parcel 中读取这些对象时，大家看到的并不是重新创建的对象实例，而是原来那个被写入的实例，能够以这种方式传递的对象目前主要有两类： Binder 以及 FileDescriptor (Linux 中的文件描述符)。 Untyped Containers 它是用于读写标准的任意类型的 Java 容器，包括 ： writeArray(Object[])/readArray(ClassLoader)、writeList(list)/readList(list) Parcel 可以用集装箱来类比，理由如下： 货物无关性： 不排斥运输的货物种类，电子产品、汽车等都可以 不同的货物需要不同的打包和卸货方案： 比如运载易碎物品和坚硬物品的装箱和卸货方式就有很大的不同。 值得注意的是，Parcel 存/取 数据的方式都是一一对应的，如 writeByte(byte)/readByte() 远程运输和组装： 集装箱的货物一般需要跨洋，这类似于 Parcel 的跨进程。不过集装箱运输公司本身并不负责所运输货物的组装，而 Parcel 会依据协议为接收方提供还原冤死数据对象的业务。 Parcel 的工作方式（书上没有，自己添加） Parcel 的 Parcel.obtain() 方法可以获取一个Parcel 对象，系统预先产生了一个大小为6的 Parcel 池 sOwnedPool，在obtain 操作时，如果 sOwnedPool 中还有现成的 Parcel 对象，则直接利用，否则通过 new Parcel(0) 创建 Parcel 对象。 Parcel.java 实际上只是一个简单的中介，它的主要内容都是 JNI 层的 Parcel 实现的。Parcel 对象的初始化过程只是简单地给各个变量赋初始值，并没有设想中的内存分配动作，因为 Parcel 遵循的是“动态扩展”的内存申请原则，只有在需要时才申请内存，避免资源浪费。 Parcel 提供数据当前位置的值 dataPosition，类似于游标。每当存储新数据时，都是从 dataPosition 位置接着往后存储，存储新数据时，会判断当前空间是否足够，如果不足，则申请新的空间（个人根据文中内容理解的，不太确定是否正确）。 Binder驱动与协议Android 是 linux 内核的，因而 Binder 驱动也是标准的 linux 驱动，具体而言，Binder驱动会把自己注册成一个 misc device，并向上层提供 /dev/binder节点——但是它并不对应真实的硬件设备。Binder 驱动运行于内核态，可提供 open()、ioctl()、mmap() 等常用文件操作。 Android 系统为什么把 Binder 注册成 misc device 类型的驱动呢？因为 linux 字符设备通常要通过 alloc_chrdev_region()、cdev_init() 等操作才能在内核中注册自己；而 misc 类型驱动相对简单，只需要 misc_register() 就可轻松解决。 Binder 驱动为上层提供了6个接口，但一般文件操作用到的 read() 和 write() 则没有出现，这是因为它们的功能完全可以用 ioctl() 和 mmap() 来代替，并且会更灵活。这6个接口中使用得最多的是 binder_ioctl,binder_mmap 和 binder_open，，以下分别介绍这三种接口。 打开Binder驱动——binder_open上层进程在访问 Binder 驱动时，首先需要打开 /dev/binder 节点，这个操作最终的实现是在 binder_open() 中，在这个方法中，会创建一个 binder_proc 实体，这个实体用于记录各种管理数据(Binder 驱动会在 /proc 系统目录下生成各种管理信息)，并且，每个进程都有独立的记录。 在完成proc 的初始化之后，就会把这个 proc 加入到 Binder 的全局管理中，这个过程涉及资源互斥，因而需要使用保护机制。到目前为止，Binder 驱动已经为用户创建了一个它自己的 binder_proc 实体，之后用户对Binder 设备的操作都以这个对象为基础。 binder_mmap对于 Binder 驱动来说，上层用户调用的 mmap() 最终对应了 binder_mmap()操作(应用程序最多只能申请 4M 的空间，如果超出这个大小，不会退出或者报异常，而只会满足用户 4M 的请求)，那么Binder 采用 mmap 的目的是什么呢？我们知道，mmap() 可以把设备指定的内存块直接映射到应用程序的内存空间中，但Binder 本身并不是硬件设备，而是基于内存的“伪硬件”，那么它映射了什么内存块到应用程序中呢？ 假设有连个进程A和B，其中进程B通过 open() 和 mmap() 与Binder驱动建立了联系，如下图： 可以看到 ： 对于进程B而言，通过mmap()返回值得到一个内存地址（当然是虚拟地址），这个地址最终会指向物理内存的某个位置（通过虚拟内存转换）。 对于Binder驱动而言，它也有个指针（binder_proc-&gt;buffer）指向某个虚拟内存地址，这个地址转换后，与进程B指向的物理内存地址位于同一个位置。 个人理解：进程B执行 mmap() ，最终是通过 Binder 的 binder_mmap() 来实现，在 B 拿到这块内存后(当然是经过虚拟内存转换后的虚拟内存地址)，Binder 驱动同时将这块内存赋值给了 binder_proc-&gt;buffer。这样，Binder和应用程序就拥有了若干公用的物理内存块，它们对着各自内存地址的操作，实际是在同一块内存中执行，这时候我们再把A进程加入进来，如下图： 这时候，左半部分没有变化，右半部分Binder驱动通过copy_from_user()，把A进程中某段数据复制到其binder_proc-&gt;buffer所指向的内存空间，这时候我们惊喜发现，binder_proc-&gt;buffer在物理内存中的位置和进程B是共享的，进而，B进程可以直接访问到这段数据，也就是说，Binder驱动只用了一次复制，就实现了进程A和B之间的数据共享。 以上通过 mmap 映射的映射区是 只读的。 binder_ioctl这是 Binder 接口函数中工作量最大的一个。前面提到过，Binder 并不提供 read() 和 write() 等常规文件操作，因为 ioctl 完全可以替代它们。它主要提供了以下命令： BINDER_WRITER_READ: 读写操作，可以用此命令向 Binder 读取或写入数据 BINDER_SET_MAX_THREAD: 设置支持的最大线程数，因为客户端可以并发向服务器端发送请求，如果Binder 驱动发现当前的线程数量已经超过设定值，就会告知 Binder server 停止启动新的线程。 BINDER_SET_CONTEXT_MGR: Service Manager 专用，让它把自己设置为“Binder”大管家。系统中只有一个 Service Manager。 Service ManagerService Manager(后面简称 SM) 也就是Binder 中的 “DNS服务器”，既然是DNS，那么在用户可以浏览网页之前就必须就位，因此SM在有人使用Binder之前就处于正常工作状态。SM 的主要工作： 从Binder驱动读取消息 调用binder_parse 处理解析消息 不断循环，而且永远不会主动退出，除非出现致命错误 它提供的服务应该至少包括以下几种： 注册——当一个Binder Server 创建后，它们要将自己的相关信息告知 SM 备案 查询——应用程序可以向 SM 发起查询请求，已获知某个 Binder Server 对应的句柄。 SM 的查询过程很简单，主要是调用 do_find_server 遍历内部列表，并返回目标 Server；注册 Binder server 也很简单，首先在 SM 维护的数据列表中查找是否已经有对应的节点存在，，如果没有，就创建一个新的节点记录这个 Server。 实际上，我们获取 SM 也很简单，只需要以下几步： 打开Binder设备 执行mmap 通过Binder驱动向 SM 发送请求（SM 的 handle是 0） 获得结果 Binder 客户端Binder 的最大消费者是Java层的应用程序，但是在各种上层的应用场景中切换“过于丝滑”，因此我们很少能感觉到Binder的存在，但是我们能够通过Android的四大组件的行为看出蛛丝马迹： Activity：通过 startActivity 可以启动目标进程，不论它是不是属于这个应用。 Service：任何应用程序都可以通过startService 或者 bindService 来启动特定的服务，而不论后者是不是跨进程的。 BroadCast：任何应用都可以通过 sendBroadcast 来发送一个广播，且无论广播接收者是不是在同一个进程中。 组件的上述操作中，多数并不会特别指明要由哪个目标应用程序来响应请求，它们只需要通过Intent表达意愿，然后由系统找出最匹配的应用进程完成工作。为了更明确地说明个中的进程间通信，这里以binderService举例说明： 首先Application1 填写Intent，调用 bindService 发出请求 在Application1的运行空间中收到 bindService 请求，这时候会与 ActivityManagerService(AMS)，这就需要得到AMS的Binder句柄，就涉及到进程间通信了（需要ServiceManage.getService）,拿到句柄后，程序才能真正向它发起请求。 AMS基于“最优匹配策略”，从其存储的所有服务组件中找到最符合Intent的一个，然后向它发送Service绑定请求（这也是进程间通信），如果目标进程还不存在的话，AMS还要负责将其启动 “被绑定”的服务进程需要响应绑定，并在完成任务后通知AMS，然后由后者回调发起请求的Application1（回调接口是ServiceConnection）。 Server 服务端在建立服务之后，可以有两种方式向外面提供服务： Server在ServiceManager中注册，这样，调用者只需要通过 ServiceManager.getService(NAME)就可以获得句柄，随后与之通信。 所谓的“匿名Server”，并不需要在ServiceManager中注册，那么Client是如何访问的呢？其实它通过其他Server作为中介，没错，就是通过一个“第三方”实名的Server，调用者首先通过ServiceManager获取这个实名的server，在由它提供匿名者的 Binder 句柄。 Binder 优点基于自己的理解而言，Binder具有以下优点： 性能较好 Binder只需要拷贝一次数据，仅次于共享内存（一次都不要），消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。 稳定性好 基于C/S架构在逻辑上更清晰，client有需求，Server完成。共享内存实现起来复杂，各方没有客户端与服务端之别，要考虑并发问题以及可能出现的死锁。 安全性好 传统 Linux IPC 的接收方要么无法获得对方进程可靠的 UID/PID ，从而无法鉴别对方身份；要么只能由用户在数据包里填入UID/PID。Android 为每个应用分配了自己的UID，前面提到 C/S 架构，Server 会根据权限控制策略判断 Client 的请求是否满足权限。并且Binder机制还有匿名 Binder ，压根无法直接获取句柄，安全性更好。 使用简单。 获得句柄之后，就像调用本地方法一样方便。并且Linux的IPC方式使用C语言，而Android应用层主要使用Java，这可能也是个因素。","categories":[],"tags":[{"name":"深入理解Android内核设计思想-林学森","slug":"深入理解Android内核设计思想-林学森","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E6%9E%97%E5%AD%A6%E6%A3%AE/"}]},{"title":"第12章: Java内存模型与线程","slug":"深入理解Java虚拟机-第12章","date":"2019-09-22T23:46:00.000Z","updated":"2019-09-23T23:43:09.467Z","comments":true,"path":"2019/09/23/深入理解Java虚拟机-第12章/","link":"","permalink":"https://glassx.gitee.io/2019/09/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC12%E7%AB%A0/","excerpt":"","text":"概述在许多情况下，让计算机同事去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是计算机的运算速度与它的存储和通信子系统的差距太大，大量的时间都花费在磁盘I/O 、网络通信或者数据库访问上。 硬件的效率与一致性高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但也为系统引入了一个新问题：缓存一致性(Cache coherence)。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主存(Main memory)，当多个处理器的运算任务都涉及同一块主内存区域时，可能导致各自的缓存数据不一致，此时，同步回到主存时以谁的缓存数据为准呢？ 除高速缓存外，为了使处理器内部运算单元尽量被充分利用，处理器可能会对输入代码进行乱序执行(Out-Of-Execution)优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但是并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果某个计算任务依赖另一个计算任务的中间结果，那么其顺序性不能依靠代码的先后顺序来保证。 Java 内存模型Java 内存模型(Java Memory Model, JMM) 是用来屏蔽各种硬件和操作系统的内存访问差异。 主内存与工作内存Java 内存模型的主要目标是定义程序中各个变量的访问规则，此处的变量(Variables) 包括 实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不存在竞争。 注意区别：如果局部变量是个refrence类型，它引用的对象在Java堆中可能被各个线程共享，但refrence本身在Java栈的局部变量表中，是线程私有的。 Java内存模型规定所有的变量都存储在主内存(Main Memory)，每条线程还有自己的工作内存(Working Memory)，这两个分别可以类比物理模型中的主内存以及处理器的高速缓存。线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。 关于副本拷贝，假设线程访问一个10MB 的对象，那会不会也拷贝出来呢？虚拟机基本上不会这么实现，只有对象的引用、对象中某个在线程中访问到的字段是可能存在拷贝的。还有，**这里所讲的主内存、工作内存 与 前面讲的Java堆、栈、方法区等并不是同一个层次的内存划分，二者并没有关系。 内存间交互操作Java 内存模型中定义了以下8中操作来完成从主内存拷贝到工作内存，以及从工作内存同步回主内存： lock（锁定）：对主内存变量标识为某一条线程独占。 unlock（锁定）：对主内存变量标识为解锁。 read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存，以便后面的load操作。 load（载入）：作用于工作内存变量，把read操作从主内存得到的变量值放入工作内存的变量拷贝中。 use（使用）：作用于工作内存变量。把工作内存中一个变量的值传递给执行引擎。当虚拟机遇到一个需要使用到变量的值的字节码指令时执行这个操作。 assign（赋值）：作用于工作内存变量。把一个从执行引擎接收道德值赋值给工作内存的变量。当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存变量。把工作内存中一个变量的值传送到主内存中，以便随后的write操作。 write（写入）：作用于主内存变量。把store操作从工作内存中得到的变量的值放入主内存的变量中。 如果要把一个变量从主内存复制到工作内存，那就要顺序地执行 read 和 load 操作（只是顺序地执行，不保证连续执行，中间是可以插入其他指令的），如果要把变量从工作内存同步回主内存，就要顺序地执行 store 和 write 操作。并且，Java 内存模型要求执行上述操作必须满足下列条件： read 和 load、store 和 write 必须成对出现，不许单独出现。 变量在工作内存中改变了之后，必须要同步回主内存，即不允许丢弃它最近的 assign 操作；并且如果没有发生assign，则不允许同步回主内存。 对一个变量 use、store 之前，必须先执行过了 assign 和 load 。 一个变量在同一时刻只允许一条线程执行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次 lock 后，只有执行相同次数的 unlock 操作后变量才能被解锁。 如果对一个变量执行 lock 操作，那会清空工作内存中此变量的值，在执行引擎使用这个变量迁，需要重新执行 load 或 assign 操作初始化变量值。 如果变量没有被 lock 锁定，那就不允许对它执行 unlock ，也不允许 unlock 一个被其他线程 lock 住的变量。 对变量执行 unlock 之前，必须把此变量同步回主内存中（执行 store、write 操作）。 对于 volatile 型变量的特殊规则volatile 可以说是Java虚拟机提供的最轻量级的同步机制。这里首先以不正式但通俗易懂的语言来介绍这个关键字的作用，当一个变量定义为 volatile 后，它将具备两种特性： 第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对其他线程来说是可以立即得知的。而普通变量是做不到这一点的。 第二个语义是禁止指令重排序优化。 关于volatile 变量的可见性，经常会有开发人员误解，认为 “volatile 变量在各个线程中是一致的，所以基于 volatile 变量的运算在并发下是安全的”，因为事实上我们不能得出“基于 volatile 变量的运算在并发下是安全的” 这样的结论，因为虽然volatile变量在各个线程的工作内存中不存在一致性问题(由于每次使用之前都要先刷新，所以执行引擎看不到一致的情况，所以可以认为不存在一致性问题)，但Java里面的运算并非原子操作，所以导致 volatile 变量的运算在并发下一样是不安全的。通过以下简单代码可以演示： 123456789101112131415161718192021222324252627282930313233public static volatile int race = 0; private static final int THREADS_COUNT = 20; private static void increase() &#123; race++; &#125; public static void main(String[] args) &#123; Thread[] threads = new Thread[THREADS_COUNT]; for (int i = 0; i &lt; THREADS_COUNT; i++) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; increase(); //System.out.println(race); &#125; &#125; &#125;); threads[i].start(); &#125; //等待所有累加线程都结束 while (Thread.activeCount() &gt; 1) &#123; Thread.yield(); &#125; System.out.println(race); &#125; 注意：我个人运行这段代码的时候，并不能正常打印，因为while循环中的 Thread.activeCount() 一直是2，只有把 for 循环中的 System.out.println(race) 放开才能打印，我的环境是： Android Studio 3.5 + jre1.8 。,如果并发正确的话，最终输出结果应该是 200000，但实际运行的结果大概率会是一个小于 200000 的数字。为什么呢？问题出在 increase() 方法中的 race++ 操作上，我们可以使用javap命令反编译这个函数的代码得到如下的字节码： 发现只有一行代码的increase方法在class文件中是由4条字节码指令构成的(return 不是由 race++ 产生的)，所以很容易分析出并发失败的原因了：当getstatic 指令把 race 的值取到操作栈顶时，volatile 可以保证 race 的值是正确的、最新的，但在执行 iconst_1、iadd 这些指令的时候，其他线程可能已经把 race 的值增大了，所以最后执行 putstatic 指令后可能把较小的 race 值同步回了主内存中。 客观地说，此处用字节码来分析问题仍然是不严谨的，因为即使编译出来只有一条字节码指令，也并不意味着这条指令就是一个原子操作，一条字节码在执行时，解释器往往要运行多行代码才能实现它的语义。如果是编译执行，一条字节码可能会转化成若干条本地机器码指令。但考虑阅读方便，并且字节码已经够说明问题，所以此处选用字节码分析。 以上代码说明volatile 在并发运行中可能出现的问题，但是如下代码场景就很适合使用 volatile 变量来控制并发，当shutdown 方法调用时，能保证所有线程中执行的 doWork() 方法都能停下来： 1234567891011volatile boolean stopThread;public void shutdown()&#123; stopThread = true;&#125;public void doWork()&#123; while(!stopThread)&#123; //do stuff &#125;&#125; volatile 禁止指令重排序优化仍然不太容易理解，通过以下伪代码来看看为何指令重排序会干扰程序的并发执行： 123456789101112131415161718Map configOptions;char[] configText;//此变量必须定义为 volatile//假设以下代码在线程 A 中执行，模拟读取配置信息，读取//完成后，将 initialized 设置为 true 以通知其他线程configOptions = new HashMap();configText = readConfigFile(fileName);processConfigOptions(configText,configOptions);initialized = true;//假设以下代码在线程 B 中执行，等待 initialized 为 true ，//代表线程 A 已经把配置信息初始化完成while(!initialized)&#123; sleep();&#125;//使用线程 A 中初始化好的配置信息doSomethingWithConfig(); 这个场景十分常见，只是我们在处理配置文件时一般不会出现并发而已。如果 initialized 没有使用 volatile 修饰，就可能由于指令重排序优化，导致 initialized = true 被提前执行(指令重排序优化是机器级的优化操作，这里说的提前执行是指对应的汇编代码提前执行)，这样线程 B 中使用配置信息的代码就可能出现错误，而volatile 可以避免此类情况发生。以下再举个例子来说明 volatile 关键字是如何禁止指令重排序优化的： 123456789101112131415161718public class Singleton&#123; private volatile static SingleTon instance; public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; public static void main()&#123; Singleton.getInstance(); &#125;&#125; 编译后，这段代码对instance变量赋值部分如下代码所示： 可以对比 instance 有被volatile修饰和没有被修饰的编译后的代码，会发现，关键变化在于有 volatile 修饰的变量，在赋值(mov %eax,0x150(%esi) 这句就是赋值操作)，之后会多执行一个 lock 操作，这个操作是一个内存屏障，令重排序时不能把后面的指令重排序到内存屏障之前的位置。只有一个cpu访问内存时，并不需要内存屏障；但如果有两个或更多cpu访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性。这操作也相当于做了一次 store 和 write 操作，引起其他cpu（或内核）对于这个变量的无效化，因此保证了 volatile 变量的修改对其他cpu立即可见。 在某些情况下，volatile 的同步机制的性能确实要优于锁，但是虚拟机对锁实行许多消除和优化，所以我们很难量化地认为 volatile 的同步机制比锁快多少。但是可以肯定的是：volatile 变量的读操作与普通变量几乎没差别，但写操作可能会慢一些，因为它需要需要在本地代码中插入内存屏障保证处理器不乱序执行。 long 和 double 型变量的特殊规则long 和double 都是64未数据类型，内存模型允许虚拟机将没有被 volatile 修饰的64位数据类型的读写操作分为两次32位操作来进行，可能会导致某些线程读到”半个变量”的数据，不过这种情况十分罕见(目前商用Java虚拟机不会出现)，所以了解这回事即可。 原子性、可见性 与 有序性整体回顾一下Java内存模型，Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性3个特征来建立的。 原子性(Atomicity)：read、load、assign、use、store 和 write 操作是保证原子性的，基本数据类型的访问读写也是具有原子性的。如果要保证更大范围的原子性，Java 内存模型还提供了 lock 和 unlock 来满足这种需求。 可见性。可见性指一个线程修改了共享变量的值，其他线程能立即得知这个修改。除了volatile 之外，Java还有两个关键字能实现可见性，即 synchronize 和 final 。同步块的可见性是由 “对一个变量执行unlock操作前，必须把此变量同步回主内存中” 获得的。而final修饰的字段在构造器中一旦初始化完成，并且构造器没有把 “this”的引用传递出去(this引用逃逸是很危险的，其他线程可能通过这个引用访问到”初始化了一半”的对象)，那在其他线程中就能看到 final 字段的值。 有序性。Java 程序中有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果从一个线程观察另一个线程，所有操作都是无序的。前者指“线程内表现为串行语义” ，后者指“指令重排序”和“工作内存与主内存同步延迟” 现象。Java 语言提供了 volatile 和 synchronized 来保证线程之间操作的有序性，前者本身包含了指令重排序的语义；后者通过 “一个变量在同一个时刻只允许一条线成对其进行lock操作”决定了持有同一个锁的两个同步块只能串行进入。 先行发生原则这块理论性的总结性的内容，个人觉得就先不写了。 Java 线程线程的实现这块的内容在操作系统的内容中有描述： 使用内核线程实现（每个内核线程对应一个轻量级进程）； 使用用户线程实现（创建销毁开销小，没有内核支援，处理诸如阻塞等问题异常困难）； 使用用户线程+轻量级进程混合实现（即内核线程和用户线程一起使用，n: m 的关系）。 Java 线程调度线程调度的方式主要有两种： 协同式线程调度(Cooperative Threads-Scheduling) 和 抢占式线程调度(Preemptive Threads-Scheduling)。前者靠线程自觉，线程执行时间由线程自己控制，后者每个线程由系统分配时间，Java 使用后者。 虽然Java线程调度是系统自动完成的，但是我们可以给线程设置优先级来“建议”系统给某些线程多一些时间。但给线程设置优先级还是不靠谱的，原因如下： Java 线程是通过映射到系统的原生线程上来实现的，不同的系统上的优先级与Java的线程优先级等级基本上对应不上。可能你在Java中指定的2个优先级，在某操作系统上映射成同一个优先级。 优先级可能会被系统自行改变。 状态转换Java 语言定义了5种线程状态，在任一时间点，一个线程只能有且只有其中的一种状态： 新建(New)：创建后尚未启动。 运行(Runnable)：可能在执行，也有可能在等待 CPU 分配时间。 无限期等待(Waiting)：这种状态下不会被 CPU 分配时间，要等其他线程显式地唤醒。 以下方法会让线程陷入无限期等待：没有设置 Timeout 参数的 Object.wait() 方法。没有设置 Timeout 参数的 Thread.join() 方法。LockSupport.park() 方法。 限期等待(Timed Waiting)：这种状态下不会被 CPU 分配时间，不过无需等待其他线程显式唤醒，在一定时间后由系统自动唤醒。 以下方法会让线程进入限期等待：Thread.sleep() 方法。设置了 Timeout 参数的 Object.wait() 方法。设置了 Timeout 参数的 Thread.join() 方法。LockSupport.parkNanos() 方法。LockSupport.parkUtil() 方法。 阻塞(Blocked)：阻塞状态是在等待获取一个排他锁。 结束(Terminated)：线程已经执行结束。 线程状态转换图如下：","categories":[],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"第5章：Binder进程间通信系统","slug":"Android系统源代码情景分析-第5章","date":"2019-09-15T07:48:00.000Z","updated":"2019-09-15T13:47:16.306Z","comments":true,"path":"2019/09/15/Android系统源代码情景分析-第5章/","link":"","permalink":"https://glassx.gitee.io/2019/09/15/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90-%E7%AC%AC5%E7%AB%A0/","excerpt":"","text":"Android 应用程序由 Activity、Service、Broadcast Receiver 和 Content Provider 四中组件构成，它们可能运行在不同的进程中。此外，各种系统组件也运行在独立的进程中，如 Activity 管理服务 ActivityManagerService 和 package 管理服务 PackageManagerService 都运行在系统进程 System 中。 Android 是基于 Linux 内核开发的，Linux 内核提供了丰富的进程间通信机制：管道(Pipe)、信号(Signal)、消息队列(Message)、共享内存(Share Memory) 和 套接字(Socket) 等。但Android 系统并没有采用这些传统的进程间通信机制，而是使用了新的机制——Binder。与传统的进程间通信机制相比，Binder 进程间通信机制在进程间传输数据时，只需要执行一次复制操作，不仅提高了效率，并且节省了内存空间。 使用共享内存在进程间传输数据的时候，虽然也只需要进行一次复制操作，但是它一般要结合其他的进程间通信机制来同步信息。 Binder 进程间通信机制采用 C/S 通信方式，提供服务的进程称为 Server 进程，而访问服务的进程称为 Client 进程，同一个 Server 进程可以同时运行多个组件来向 Client 提供服务；而同一个 Client 进程也可以同时向多个 Service 组件请求服务。Service 组件启动时，会将自己注册到一个 Service Manager 组件中，以便 Client 组件可以通过 Service Manager 组件找到它。Binder 进程间通信机制中涉及了 Client、Service、Service Manager 和 Binder 驱动程序四个角色的关系如下图所示： Client、Service 和 Service Manager 都运行在用户控件，而Binder 驱动程序运行在内核控件。Client、Service 和 Service Manager 均是通过系统调用 open(打开)、mmap(内存映射)、ioctl(在用户空间，使用ioctl系统调用来控制设备) 来访问设备文件 /dev/binder ，从而实现与Binder驱动的程序的交互，而交互的目的就是为了能够间接执行进程间通信。","categories":[],"tags":[{"name":"深Android系统源代码情景分析(第三版)","slug":"深Android系统源代码情景分析-第三版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/"}]},{"title":"第13章: 线程安全与锁优化","slug":"深入理解Java虚拟机-第13章","date":"2019-09-14T02:12:00.000Z","updated":"2019-09-15T07:11:20.681Z","comments":true,"path":"2019/09/14/深入理解Java虚拟机-第13章/","link":"","permalink":"https://glassx.gitee.io/2019/09/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC13%E7%AB%A0/","excerpt":"","text":"概述并发处理的广泛应用使得 Amdahl 定律替代摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。 线程安全线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程问题，更无须自己采取任何措施来保证多线程的正确调用。 Java 线程安全为了更深入地理解线程安全，在这里我们可以不把线程安全当做一个非真即假的二元排他选项来看待。按照线程安全的“安全程度”由强至弱来排序，我们可以将Java语言各种操作共享的数据分为：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。 不可变不可变(Immutable) 的对象一定是线程安全的，只要一个不可变对象被正确地创建构建出来(没有发生this引用逃逸的情况)，那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态。 Java 语言中，如果共享数据是一个基本数据类型，只要在定义时使用final关键字就可以保证它是不可变的；如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响，有很多途径去实现这个目的，最简单的就是把对象中带有状态的变量都声明为final，这样，在构造函数结束之后，它就是不可变的。 Java API 中复合不可变要求的类型，有String、枚举类型、Long、Double以及BigInteger、BigDecimal等大数据类型，但同为Number的子类型的原子类 AtomicInteger 和 AtomicLong 则并非不可变的。 绝对线程安全绝对线程安全通常需要付出很大的，甚至有时候是不切实际的代价。在Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全。我们可以通过一个不是“绝对线程安全”的线程安全类来看看这里的“绝对”是什么意思。 Java程序员基本上都认为 java.util.Vector 是一个线程安全的容器，因为它的add、get、size等方法都被 synchronized 修饰的，尽管这样效率很低，但确实是安全的。但是，即使所有方法都被修饰成同步，也并不意味着调用它的时候永远不需要同步手段了，看如下测试代码： 123456789101112131415161718192021222324252627282930313233private static Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;(); public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; vector.add(i); &#125; Thread removeThread = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125;); Thread prindThread = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; System.out.println(vector.get(i)); &#125; &#125; &#125;); removeThread.start(); prindThread.start(); //不要同时产生过多线程，否则导致操作系统假死 while (Thread.activeCount() &gt; 20) ; &#125; &#125; 这段代码运行过程中会出现 ArrayIndexOutOfBoundsException，但是在我自己写代码验证的时候，感觉这个错误还是很容易被忽略的，运行了好长时间都还在一直输出，但其实早就报错了，但不知道怎么程序还是正常运行。这点在自己验证的时候要注意一下，我的运行环境是：Android studio 3.5 + jre 1.8 。 虽然我个人认为作者说的是有道理的，因为如果remove线程恰好在一个错误的时间里删除了一个元素，导致序号i已经不再可用的话，再用vector.get(i) 访问就会抛出 ArrayIndexOutOfBoundsException。如果要保证这段代码的正确运行，书上给出的方案是把两个thread改成如下代码： 1234567891011121314151617181920212223Thread removeThread = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (vector)&#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125; &#125;); Thread prindThread = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (vector)&#123; for (int i = 0; i &lt; vector.size(); i++) &#123; System.out.println(vector.get(i)); &#125; &#125; &#125; &#125;); 相对线程安全相对线程安全就是我们通常意义上所讲的线程安全，它需要保证这个对象单独的操作是线程安全的，我们在调用的时候无需做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。Java语言中，Vector、HashTable、Collections的synchronizeCollection() 方法包装的集合等。 线程兼容线程兼容指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。Java API 中大部分类都是属于线程兼容的，如 ArrayList 和 HashMap 等。 线程对立线程对立是指无论调用端是否采取同步措施，都无法再多线程环境并发使用，如 Thread 类的suspend() 和 resume() 方法，如果两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发的话，无论是否进行了同步，都会存在死锁风险(这两个方法在jdk中已经被声明放弃了)。这类代码很少出现，我们也应该避免。 线程安全的实现方法这听起来是代码编写的问题，但虚拟机提供的同步和锁机制也起到了非常重要的作用。只要读者了解了虚拟机线程安全手段的运作过程，自己去思考代码如何编写并不是一件困难的事情。 互斥同步同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只能被一个(或者是一些，使用信号量的时候)线程使用，而互斥是实现同步的一种手段。互斥是因，同步是果；互斥是方法，同步是目的。 Java中最基本的互斥同步手段是 synchronize 关键字，经过编译后，会在同步快的前后分别形成 monitorenter 和 monitorexit 两个字节指令，这两个字节码都需要 reference 类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronize 指明了对象参数，那就是这个对象的 reference ；如果没有明确指定，那就根据 synchronize 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。 根据虚拟机规范，执行 monitorenter 时首先尝试获取对象的锁，如果没有被锁定，或者当前线程已经拥有这个锁，就把锁的计数器 +1 ，相应地，monitorexit 时减 1 。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被释放。 这里有2点是要注意的：synchronize 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题；其次，同步块在已进入的线程执行完之前，会阻塞后面的线程，前面提到过，Java的线程是映射到操作系统的原生线程上的，如果要阻塞或者唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转到核心态中，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块(如被synchronize修饰的getter() 或 setter() 方法)，状态转换消费的时间可能比代码执行时间还要长，所以 synchronize 是 Java 语言中一个重量级(Heavyweight)操作。 还可以使用 ReetrantLock 来实现同步，它的基本用法与 synchronize 相似，都具备线程重入性，只是 ReetrantLock 表现为API语法层面的互斥锁(lock 和 unlock 方法配合 try/finally 语句块来完成)，synchronize 表现为原生语法层面的互斥锁。不过，ReetrantLock 增加了一些高级功能，主要有以下3项： 等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待。 公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁：而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronize 是非公平的，ReetrantLock 默认也是非公平的。 锁绑定多个条件是指一个 ReetrantLock 对象同时可以绑定多个 Condition 对象。而synchronize 中，锁对象的 wait 、notify或者 notifyAll 方法可以实现一个隐含的条件是：如果要和多于一个的条件关联的时候，就要额外地添加一个锁。而 ReetrantLock 无需这样做，只需要多次调用 newCondition 方法即可。 在JDK 1.6以前，synchronize 的吞吐量会随着竞争的激烈程度增加而急剧下降，但 ReetrantLock 却基本保持在平稳水平。但随着后面的优化，二者的性能基本上持平了，并且虚拟机在未来的性能改进中更倾向于原生的 synchronize ，所以还是提倡在 synchronize 能实现需求的情况下，优先考虑使用 synchronize 来同步。 非阻塞同步互斥同步最主要的问题就是线程阻塞和唤醒带来的性能问题，因此也称为阻塞同步，这是一种悲观的并发策略，总认为不去做正确的同步措施，就肯定会出问题。随着硬件指令集的发展（因为我们需要操作和冲突检测这两个步骤具备原子性，只能靠硬件来保证，如果使用互斥同步就失去意义了），我们有了另一个选择：基于冲突检测的乐观并发策略，通俗讲就是先操作，如果没有其他线程竞争，操作就成功了；如果有竞争产生了冲突，再采取其他补偿措施（常见的措施就是不断重试，直到成功）。这种策略无需把线程挂起，因此称为非阻塞同步。 指令集发展后，可以确保一个从语义上看起来需要多次操作的行为只需要一条处理器指令就能完成，其中最重要的指令为 ：比较并交换(Compare-and-Swap) ，下文简称 CAS，它的语义是：内存地址V，旧的预期值 A,新值 B，当且仅当 V 符合旧预期值 A 是，处理器就用新值 B 更新 V，否则就不更新。 不妨拿一段在第 12 章中没有解决的问题代码来看看如何使用CAS操作来避免阻塞同步，我们曾通过这段20个线程自增 10000 此的代码来证明 volatile 变量不具备原子性，那如何才能让它具备原子性？把 “race ++ “ 操作或 increase() 方法用同步块包裹起来当然是一个办法，但如果改成如下代码，效率会提高很多： 12345678910111213141516171819202122232425262728private static AtomicInteger race = new AtomicInteger(0);private static final int THREADS_COUNT = 20; private static void increase()&#123; race.incrementAndGet(); &#125; public static void main(String[] args) &#123; Thread[] threads = new Thread[THREADS_COUNT]; for (int i = 0;i&lt; THREADS_COUNT;i++)&#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0;i&lt; 10000;i++)&#123; increase(); &#125; &#125; &#125;); threads[i].start(); &#125; while (Thread.activeCount() &gt; 1)&#123; Thread.yield(); &#125; System.out.println(race); &#125; 运算结果： 200000 使用AtomicInteger代替int后，程序输出了正确地结果，一切要归功于incrementAndGet 方法的原子性，它的实现非常简单： 123456789public final int incrementAndGet()&#123; for(;;)&#123; int current = get(); int next = current + 1; if(compareAndSet(current,next))&#123; return next; &#125; &#125;&#125; incrementAndGet 方法在一个无限循环中，不断尝试将一个比自己当前值大1的新值赋给自己，如果失败了，那说明在执行“获取-设置”操作的时候值已经有了修改，于是再次循环进行下一次操作，直到设置成功为止（设置成功才return 跳出循环）。 如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A，这就有可能是这段期间它的值曾经被改成了B，后来又被改成了A，那 CAS 操作就会误认为它从来没被改变过，这称为 “ABA” 问题。如果需要解决 “ABA” 问题，改用传统的互斥同步会比原子类更高效。 无同步方案如果一个方法本来就不涉及共享数据，那它自然无需任何同步措施。这种代码是天生线程安全的，这里简单介绍其中两类： 可重入代码：这种代码可以在任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。可重入代码有一些共同特征，如 不依赖存储在堆上的数据和公用的系统资源，用到的状态量都是由参数中传入、不调用 非可重入的方法等。 线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看这些共享数据代码是否能保证在同一个线程中执行，如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内。 符合这种特点的应用并不少见。一个应用实例就是web交互模型中“一个请求对应一个服务器线程”的处理方式 锁优化JDK 1.6 实现了各种锁优化技术，如适应性自旋、锁消除、锁粗化、轻量级锁 和 偏向锁 等，这些技术都是为了在线程之间更高效地共享数据。 自旋锁与自适应自旋在讨论互斥同步的时候，提到了阻塞对性能影响最大。虚拟机开发团队注意到在许多应用上，共享数据锁定状态只会持续很短时间，为这段时间去挂起和恢复线程不值得。我们可以让后面的请求锁的线程“稍等一下”，但不放弃处理器的执行时间，看锁是否被很快释放。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓自旋锁。 自旋本身避免了挂起和恢复过程，但是它占用cpu时间，如果锁被占用的时间很短，这是值得的；反之，如果锁被占用的时间过长，则白白消耗处理器资源，因此需要有一定限度，限定自旋次数。 锁消除如果代码上要求同步，但是被检测到不可能存在共享数据竞争，就可以对锁进行消除，锁消除的主要判定依据来源于逃逸分析的数据支持。也许读者会有疑问，变量逃逸，对于虚拟机来说需要使用数据流分析来确定，但是程序员自己应该很清楚，怎么会在明知道不存在数据竞争的情况下要求同步呢？答案是：有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中普遍存在，来看看下面例子： 123public String concatString(String s1,String s2,String s3)&#123; return s1 + s2 + s3;&#125; 我们知道，String 是个不可变的类，对字符串的连接操作总是通过生成新的String来进行。JDK 1.5 前，String 连接会转化为 StringBuffer对象的连续 append 操作，1.5 及以后的版本会转化为 StringBuilder 对象的连续 append，即上述代码可能会变成以下的样子： 1234567public String concatString(String s1,String s2,String s3)&#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); sb.append(s3); return sb.toString();&#125; 现在大家还认为这段代码没有涉及同步吗？每个 StringBuffer.append 方法中都有一个同步块，锁就是sb对象。虚拟机很快会发现它的动态作用域被限制在 concatString 方法内部，永远不会被逃逸到方法外，因此，虽然这里有锁，也可以被安全地消除。 锁粗化原则上，编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，这是为了使需要同步的操作数量尽可能变小，让等待的线程尽快拿到锁。大部分情况下这原则是正确的。 但是，如果一系列连续操作都是对同一个对象反复加锁和解锁，甚至加锁操作是在循环体中，频繁地进行互斥同步操作会导致不必要的性能消耗。上述代码中连续的 append 方法就属于此类范围，虚拟机会把加锁同步的范围扩展(粗化)到整个操作序列的外部，就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。 轻量级锁轻量级锁是相对于传统的锁机制而言的，首先强调的一点是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 要理解轻量级锁，必须从HotSpot虚拟机的对象（对象头部分）的内存布局开始介绍。HotSpot虚拟机的对象头分为两部分：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄等，官方称为 “Mark Word”，它是实现轻量级锁和偏向锁的关键。第二部分用于存储指向方法区对象类型数据的指针。 在代码进入同步块的时候，如果此同步对象没有被锁定——Mark Word 中锁标记位为 “01”，则虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的 Mark Word 的拷贝，然后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，如果这个更新动作成功了，那么这个县城就拥有了该对象的锁，并且将对象的 Mark Word 的锁标志位转变为 “00” ，表示对象处于轻量级锁定状态。 如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志位变为 “10” ，后面等待锁的线程也要进入阻塞状态。 上面描述的是加锁过程，解锁过程也是通过CAS 操作来进行的，如果对象的 Mark Word 仍然指向线程的锁记录，那就用 CAS 操作把当前对象的的 Mark Word 和 线程中复制的 Mark Word 替换，如果替换成功，整个同步过程完成。如果替换失败，说明其他线程尝试过获取该锁，那么在释放锁的同时，唤醒被挂起的线程。 轻量锁的依据是“绝大部分锁，在整个同步周期内都是不存在竞争的”，这是经验数据，如果没有竞争，轻量级锁使用CAS 操作避免了使用互斥量的开销；如果存在锁竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此会比传统重量级锁更慢。 偏向锁如果说轻量级锁是在无竞争情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。 假设当前虚拟机启用了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机会把对象头中的标志位设置为 “01”，即偏向模式。同时，使用CAS操作把获取到这个锁的线程ID记录在对象的 Mark Word 之中，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。 当另外一个线程去尝试获取这个锁时，偏向模式就结束。根据锁对象目前是否处于被锁定状态，撤销偏向后恢复到 未锁定(标志位 01) 或 轻量级锁定(标志位 00)的状态，后续的同步操作就如上面介绍的轻量级锁执行。 偏向锁可以提高带有同步但无竞争的程序的性能，它不一定总是对程序运行有利。如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。因此，有时候禁止使用偏向锁反而可以提升性能。","categories":[],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"第10章：早期（编译期）优化","slug":"深入理解Java虚拟机-第10章","date":"2019-09-13T13:10:00.000Z","updated":"2019-09-15T07:11:29.104Z","comments":true,"path":"2019/09/13/深入理解Java虚拟机-第10章/","link":"","permalink":"https://glassx.gitee.io/2019/09/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC10%E7%AB%A0/","excerpt":"","text":"Java语言的“编译期”是一段“不确定”的操作过程，它可能是指一个前端编译器把.java文件转变成 .class 的过程，也可能是指JIT编译器把字节码变成机器码的过程，还能是指 ATO编译器直接把 .java 文件编译成本地代码的过程。最符合大家认知的应该是第一类，在本章中，我们提到的 “编译期” 以及 “编译器” 都指限于第一类过程。 Javac 编译器前面很多个人觉得只有写编译器才能用得着的内容，先略过。 标注检查：javac的编译过程包含标注检查，标注检查的内容包括诸如变量使用前是否已经被声明，变量与赋值类型是否匹配等。此外，标注检查还有一个重要动作称为常量折叠，如果我们在代码中谢了如下定义： int a = 1 + 2; 那么在语法树上仍然能看到字面量“1”、“2” 以及操作符 “+”，但是经过常量折叠后，他们将会被折叠为字面量 “3”，由于编译期进行了常量折叠，因此在代码中定义 “a = 1 + 2” 与直接定义 “a = 3” 的cpu指令运算量是一样的，并不会增加额外的哪怕一个cpu指令开销。数据及控制流分析是对程序上下文逻辑的进一步验证，以下举一个关于 final 修饰符的数据及控制流分析的例子： 123456789101112//方法一有final修饰public void foo(final int arg)&#123; final int var = 0; //do something&#125;//方法二没有final修饰public void foo(int arg)&#123; int var = 0; //do something&#125; 这两个 foo() 方法中，在代码编写时程序肯定会受到 final 修饰符的影响，不能再改变第一个方法的 arg 和 var 变量的值，但是这两段代码编译出来的Class 文件是没有任何区别的。通过 第六章 的内容可知，局部变量与字段(实例变量、累变量) 是有区别的，前者在常量池中没 CONSTANT_Fieldref_info 符号引用，自然也没有访问标志（Access_Flags）的信息，甚至可能连名称也不会保留下来(取决于编译时的选项)，自然在Class文件中不可能知道一个布局变量是不是声明为 final 了，因此，**将局部变量声明为 final 对运行是没有影响的，变量的不可变性仅仅由编译器在编译期间保障。 Java 语法糖的味道语法糖可以看做编译器实现的一些 “小把戏” ，这些小把戏不会提供实质性的功能改进，但它可能会使得效率“大提升”，但我们也应该去了解这些“小把戏”背后的真实世界，那样才能利用好它们，而不是被它们迷惑。 泛型与类型擦除Java中的类型，本质是参数化类型(Parametersized Type)的应用，也就是说所操作的数据类型被指定为一个参数。泛型技术在Java 和 C# 之中的使用方式看似相同，但实现上却有根本性的分期，C# 中的泛型无论在程序源码中、编译后的IL（中间语言）中或是运行期的 CLR 中，都是切实存在的， List 与 List 就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现方式称为类型膨胀，基于这种方法实现的泛型称为真实泛型。 Java 语言中的泛型规则不一样，它们只在源码中存在，在编译后的字节码文件中就已经替换为原来的原声类型了，因此，对于运行期的Java语言来说， ArraList 与 ArrayList 就是同一个类，所以泛型技术实际上是Java的一颗语法糖，这种实现方法称为“类型擦除”，基于这种方法实现的泛型称为 伪泛型。可以通过代码反编译来查看Java泛型实现过程： 1234567public static void main(String[] args)&#123; Map&lt;String,String&gt; map = new HashMap(); map.put(\"hello\",\"你好\"); map.put(\"how are you\",\"吃了吗\"); Systemt.out.println(map.get(\"hello\")); Systemt.out.println(map.get(\"how are you\"));&#125; 把这段代码编译成 Class 文件，再用子界面反编译工具反编译成Java代码，会发现代码变成如下形式： 1234567public static void main(String[] args)&#123; Map map = new HashMap(); map.put(\"hello\",\"你好\"); map.put(\"how are you\",\"吃了吗\"); Systemt.out.println((String)map.get(\"hello\")); Systemt.out.println((String)map.get(\"how are you\"));&#125; 会发现，反编译回来的 Map 定义都变成了 Map map = new HashMap()，输出的时候，是靠强转实现的，也就是把object转为程序员写的实际类型。Java 的伪泛型招致很多批评的声音，不过这种实现方式在某些情况下丧失了泛型思想应有的一些优雅，比如在类中存在如下两个方法： 123456789public class GenericTypes&#123; public static void method(List&lt;String&gt; list)&#123; System.out.println(\"invoke method(List&lt;String&gt; list)\"); &#125; public static void method(List&lt;Integer&gt; list)&#123; System.out.println(\"invoke method(List&lt;Integer&gt; list)\"); &#125;&#125; 思考一下，这段代码是否正确。也许你已经知道了，这段代码是不能被编译的，因为List 与 List 编译后都被擦除了，变成了一样的原生类型 List ,擦除动作导致这两种方法的特征签名变得一样。初看起来，无法重载的原因找到了，但真的如此吗？其实，泛型擦除成相同的原生类型只是无法重载的原因之一，接着看下面的代码： 12345678910111213141516public class GenericTypes&#123; public static String method(List&lt;String&gt; list)&#123; System.out.println(\"invoke method(List&lt;String&gt; list)\"); return \"\"; &#125; public static int method(List&lt;Integer&gt; list)&#123; System.out.println(\"invoke method(List&lt;Integer&gt; list)\"); return 1; &#125; public static void main(String[] args)&#123; method(new ArrayList&lt;String&gt;()); method(new ArrayList&lt;Integer&gt;()); &#125;&#125; 编译执行发现，不但可以编译还能正常输出结果： System.out.println(“invoke method(List list)”)System.out.println(“invoke method(List list)”) 为两个方法添加了不同的返回值之后，方法重载居然成功（注意，仅仅只是在jdk 1.6及以下才能编译通过，高版本是编译不通过的，但在书上是没有这个版本说明的，而我们读者只需要知道有这么个事情就行）了，这是对Java语言中返回值不参与重载选择的基本认知的挑战吗？当然不是的，之所以能够编译成功，是因为两个 method 方法加入了不同的返回值之后，能够共存在同一个 Class 文件了。由于这只是针对低版本的功能，故此处不多解释了。 自动装箱、拆箱与遍历循环这几个专门拿出来讲只是因为它们是Java语言中使用得最多的语法糖。可以通过以下代码看看这些语法糖在编译后会发生什么变化： 123456789public static void main(String[] args)&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4); int sum = 0; for(int i: list)&#123; sum += i; &#125; Systemt.out.println(sum);&#125; 上述代码在自动装箱、拆箱与遍历循环编译后，变成以下样式： 123456789101112131415public static void main(String[] args)&#123; List&lt;Integer&gt; list = Arrays.asList(new Integer[]&#123; Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3), Integer.valueOf(4), &#125;); int sum = 0; for(Iterator localIterator = list.iterator();localIterator.hasNext();)&#123; int i = ((Integer)localIterator.next()).intValue(); sum += i; &#125; Systemt.out.println(sum);&#125; 代码一共包含自动装箱、自动拆箱、遍历循环与变长参数5种语法糖。遍历循环还原成了迭代器的实现，而变长参数则是通过数组的方式转变。语法糖看起来简单，但是也有很多需要注意的地方，如以下代码： 123456789101112131415Integer a = 1;Integer b = 2;Integer c = 3;Integer d = 3;Integer e = 321;Integer f = 321;Long g = 3L;System.out.println(c==d); //true System.out.println(e==f); //false Interger 128限制（缓存了 -128~127的对象，超出这个值就重新new，否则就直接取）System.out.println(c==(a+b)); // trueSystem.out.println(c.equals(a+b)); //true System.out.println(g==(a+b)); //true ，这个还真没找到解释的方法System.out.println(g.equals(a+ b)); //false ,因为 g 是 Long 类型，而 a + b 后是Integer类型，类型都不一样,equals 不会自动处理数据转型 结果和注释都已经写上了，关于Integer的128限制，再来例子说明： 12345678910Integer i=127;Integer j =127;System.out.println(i==j); //truei=128;j=128;System.out.println(i==j); //false i=new Integer(127);j=new Integer(127);System.out.println(i==j); //false 详细解释：jvm在运行时创建了一个缓存区域，并创建了一个integer的数组。这个数组存储了-128至127的值。因此如果integer的值在-128至127之间，则是去缓存里面获取。因此上面的i和j指向的是同一个内存地址。因为128超过了这个缓存区域，因此第二次赋值的时候是重新开辟了两个内存地址。第三次因为使用了new关键字，在java中。new关键字是开辟内存空间。因此第三次赋值是开辟了新的内存空间，此时发现即便i与j都是127，但内存地址不再相同。 包装类的 “==” 运算在不遇到算术运算的情况下不会自动拆箱，并且它们的 equals() 方法不处理数据转型的关系。 条件编译略 实战： 插入式注解处理器略","categories":[],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"第11章: 晚期（运行期）优化","slug":"深入理解Java虚拟机-第11章","date":"2019-09-08T08:24:00.000Z","updated":"2019-09-08T13:00:33.597Z","comments":true,"path":"2019/09/08/深入理解Java虚拟机-第11章/","link":"","permalink":"https://glassx.gitee.io/2019/09/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC11%E7%AB%A0/","excerpt":"","text":"概述Java 程序最初是通过解释器(Interpreter)进行解释执行的，虚拟机发现某个方法或代码块运行特别频繁时，会将它们认定为“热点代码”(Hot Spot Code)。为了提高运行效率，虚拟机会把这些代码编译成本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(Just In Time Compiler, JIT编译器)。 JIT 不是虚拟机必需部分，Java虚拟机规范也没有规定实现，但它却是衡量一款商用虚拟机优秀与否的关键指标，也是最能体现虚拟机技术水平的部分。本章所讲的内容都是基于HotSpot虚拟机。 HotSpot 虚拟机的JIT首先看几个问题： 为何要使用解释器与编译器并存架构 为何要实现两个不同的JIT 程序何时使用解释器执行？何时使用编译器执行？ 哪些程序代码会被编译为本地代码？如何编译为本地代码？ 如何从外部观察JIT的编译过程和编译结果？ 解释器与编译器第一个问题，解释器与编译器两者各有优势：当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；程序运行后，随着时间推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大时，也可以使用解释执行节约内存。同时，解释器可以作为编译器激进优化时的一个“逃生门”。因此，在整个虚拟机架构中，解释器与编译器经常配合工作。 第二个问题，两个不同的JIT一般称为 Client Compiler（也称为 C1 编译） 和 Server Compiler（也称为 C2 编译） 。虚拟机一般会启用分层编译策略，分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次： 第0层：解释执行，解释器不开启性能监控(Profiling)，可触发第1层编译。 第1层，也称C1编译，将字节码编译成本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。 第2层，也称C2编译，将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。 实施分层编译后，C1和C2将会同时工作，许多代码会被多次编译，用C1获取更高的编译速度，用C2获取更好地编译质量，并且解释执行时也无需承担收集性能监控信息的任务。 编译对象与触发条件第三个问题，上文提到，运行过程中会被即时编译器编译的“热点代码”有两类，即： 被多次调用的方法。 被多次执行的循环体。 解释一下第二点，这是为了解决一个方法只被调用过一次或少量几次，但是方法体内部存在循环次数较多的循环体问题。这样，循环体的代码也被重复执行多次，因此这些代码也应该认为是“热点代码”。 编译过程默认设置下，无论是方法调用产生的即时编译请求还是OSR编译请求，虚拟机在代码编译器还未完成之前，都仍将按照解释方式执行。 编译优化技术以如下代码清单来说明编译优化： 12345678910111213141516static class B &#123; int value; final int get() &#123; return value; &#125;&#125;public void foo() &#123; y = b.get(); //do something z = b.get(); sum = y + z;&#125; 首先说明的是，这些代码优化变换是建立在代码的某种中间表示或机器码之上，绝不是建立在Java源码之上，这里是为了展示方便，使用了Java语言的语法来表示这些优化技术所发挥的作用。 以上的代码已经非常简单了，但仍有许多优化余地，第一步就是方法内联(Method Inlining)，内联后的foo函数代码如下： 12345678public void foo() &#123; y = b.value; //do something z = b.value; sum = y + z;&#125; 方法内联的重要性高于其他优化措施，它主要有两个目的：去除方法调用的成本(如建立栈帧等) 以及为其他优化方法建立良好的基础(方法内联膨胀后可以便于在更大范围上采取后续优化手段)。 第二步进行 冗余访问消除(Redundant Loads Elimination)，假设上述代码中 do something 刽改变 b.value的值，那就可以将 z = b.value 替换为 z = y ，因为上一句 y = b.value 已经保证 y 与b.value 是一致的，这样就可以不用再去访问对象b的局部变量了。优化后的代码: 12345678public void foo() &#123; y = b.value; //do something z = y; sum = y + z;&#125; 第三步我们进行复写传播(Copy Propagation)，因为在这段程序的逻辑中没有必要使用 z 这个变量，它与 y 是完全相等的，因此可以用 y 来替代 z ，复写传播后的代码如下： 12345678public void foo() &#123; y = b.value; //do something y = y; sum = y + y;&#125; 第四步我们进行无用代码消除(Dead Code Elimination)。在上述代码清单中， y = y 是没有意义的，把它擦除后的代码如下： 1234567public void foo() &#123; y = b.value; //do something sum = y + y;&#125; 经过4次优化后，达到的效果一致，但是比原始代码省略了许多语句，执行效率也更高。接下来继续看几项有代表性的优化技术。 公共子表达式消除这是语言无关的经典优化技术之一，普遍用于各种编译器的经典优化技术，它的含义是：如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成了公共子表达式。假设存在如下代码： int d = (c * b) * 12 + a + (a + b * c); 这段代码交给JIT编译后，它将进行如下优化：因为 c * b 与 b * c 是一样的表达式，并且在计算期间 b 与 c 的值是不可变的，因此表达式可能会被视为： int d = E * 12 + a + (a + E); 这时候，编译器还可能进行 代数化简(Algebraic Simplification)，把表达式变为： int d = E * 13 + a * 2; 数组边界检查消除如果有一个数组 foo[] ，在Java语言中访问数组元素 foo[i] 的时候系统将会自动进行上下界的范围检查，即i必须满足 i&gt;= 0 &amp;&amp; i &lt; foo.length ，否则抛出异常。 为了安全，数组边界检查是必须的，但是运行期间一次不漏地检查则优点浪费，是可以“商量”的。假如程序中访问一个对象 foo 的某个属性 value，那以Java伪代码表示虚拟机访问的过程如下： 12345if(foo != null) &#123; return foo.value;&#125;else &#123; throw new NullPointException();&#125; 在使用隐式异常优化后，虚拟机会把上述代码变为如下伪代码过程： 12345try &#123; return foo.value;&#125;catch(segment_fault) &#123; uncommon_trap();&#125; 虚拟机会注册一个 segment_fault 信号的异常处理(uncommon_trap),这样当foo不空的时候，对value的访问是不会额外消耗一次对foo判空的开销的。代价就是当 foo 真的为空时，必须转入到异常处理器中恢复并抛出 NullPointException异常，这个过程必须从用户态转到内核态中处理，结束后再回到用户态，速度远比一次判空检查慢，但当 foo 极少为空的时候，隐式异常优化是值得的。 方法内联方法内联是编译器最重要的优化手段之一，除了消除方法调用的成本之外，它更重要的意义在于为其他优化手段建立良好的基础，如下代码就解释了内联对其他优化手段的意义： 12345678910public static void foo(Object obj)&#123; if(obj != null)&#123; System.out.println(\"do something\"); &#125;&#125;public static void testInline(String[] args)&#123; Object obj = null; foo(obj);&#125; 事实上 testInline 方法的内部全部是无用代码，如果不做内联，后续即使进行了无用代码消除优化，也无法发现任何“Dead Code”，因为如果分开来看， foo() 和 testInline() 两个方法的操作都可能是有意义的。因此方法内联的意义不只是把目标方法“复制”到发起调用的方法中避免真实的方法调用。但实际上Java 虚拟机中的内联过程远没有那么简单，如果不是即时编译器做了一些努力，按照经典编译原理的优化理论，大多数的方法都无法进行内联。 逃逸分析逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸；甚至还可能被外部线程访问到，譬如赋值给类变量或者可以在其他线程中访问的实例变量，称为线程逃逸。 如果能证明一个方法不会逃逸到方法或线程外，则可能为这个变量进行一些高效优化： 栈上分配(Stack Allocation)：Java 虚拟机中，在Java 堆上分配创建对象的内存空间几乎是Java程序员都清楚的常识了，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但回收动作（无论是筛选可回收对象还是回收和整理内存）都需要耗费时间。如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁，减小垃圾收集系统的压力。 同步消除(Synchronization Elimination)：线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么变量的读写肯定不会有竞争，对这个变量实施的同步措施就可以被消除。 标量替换(Scalar Replacement)：标量(Scalar)是指一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型(int、long等数值类型及 refrence 类型等)都不能再进一步分解，它们就可以称为标量。相对地，如果一个数据可以继续分解，那它就称作聚合量，Java中的对象就是最典型的聚合量。如果把一个Java 对象拆散，根据程序访问情况将其使用到的成员变量恢复原始类型来访问就叫做标量替换。 如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上分配和读写外，还可以为后续进一步优化手段创建条件。 Java 与 C/C++的编译器对比有兴趣的时候再来补上，略。","categories":[],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"deepin使用心得","slug":"deepin使用心得","date":"2019-08-18T03:40:00.000Z","updated":"2019-09-06T15:17:15.617Z","comments":true,"path":"2019/08/18/deepin使用心得/","link":"","permalink":"https://glassx.gitee.io/2019/08/18/deepin%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/","excerpt":"","text":"背景在windows 10 上使用Android studio 开发，分分钟让你怀疑人生，编译运行一次看效果，5、6分钟很正常，7、8分钟是常有的事，忍无可忍，决心切换到 linux 环境。以个人的理解，Linux 的发行版都是基于相同的内核，所以比较各个发行版的时候，我个人主要比较 美观程度、使用方便程度以及可使用的软件数目。 在尝试包括ubuntu、中兴的新支点、优麒麟、deepin 之后，最终选择使用 deepin（深度技术）。deepin 有自己的应用商店，里面有包括 wps、qq、微信、TIM、foxmail、百度云盘、MindMaster、搜狗输入法等常用软件（有些是deepin-win版本的，但是优化得很好），并且如果需要安装其他的常用软件，也能通过deepin-wine方式安装；除此之外，deepin的界面极为美观，操作起来也特别方便，很多操作与windows类似。最重要的是，deepin天生对中文环境友好，并且无需费神选择镜像源，几乎安装上就能够正常使用，因此在这里，我强烈安利一波这个国产的，难得的linux发行版。 软件安装一、安装Android studio按照官方给的教程下载，并且解压到相应的目录即可，你可以把快捷方式的图标固定在decor上，如果之后偶尔通过这个图标不能正常启动，就进入 AS 的解压目录，进入bin 目录中，双击 studio.sh 运行就可以正常使用了。 二、安装rtx打开终端，输入以下命令： sudo apt install deepin.com.qq.rtx2015 卸载就输入： sudo apt remove deepin.com.qq.rtx2015 三、安装openJdkAndroid 开发使用 openJdk 就足够了，并且安装过程也是超级方便，以下命令就能搞定： sudo apt-get install openjdk-8-jdk 四、安装git作为developer，版本管理是必不可少的，git 最初是为 linux 版本管理而生，因此在linux上安装 git 也是极为方便： sudo apt-get install git 其他软件可以从deepin自带的应用商店安装。 卸载软件linux彻底卸载软件步骤:以卸载wine为例 1、 删除软件及配置文件 sudo apt-get –purge remove wine 2、 删除没用的依赖包 sudo apt-get autoremove wine 3、 此时dpkg的列表中有”rc”状态的软件包,可以执行以下命令进行最后清理 sudo dpkg -l |grep ^rc|awk ‘{print $2}’ |sudo xargs dpkg -P 4、 然后删除安装包,位于/root/.wine和/home/usrname/.wine sudo rm -rf /root/.winesudo rm -rf /home/usrname/.wine Android Studio 使用有时候，需要在 Android studio 的 terminal 中输入相应的gradle 命令，尤其是build出错又找不到错误的时候，就想使用命令： gradlew compileDebugSources –stacktrace -info 但是我们直接在as的terminal中输入这行命令是不行的，并且我一般也懒得去配置环境。这时候，其实我们可以在项目的根目录下能发现 gradlew 的一个文件，我们能不能使用这个gradlew呢？事实上是可以的，只需要执行： ./gradlew compileDebugSources –stacktrace -info 如果提示权限不足，只需要chmod 777 项目的根目录修复下权限即可： sudo chmod -R 777 chmod -R 777 /media/test/_dde_data/work/test Android 源码下载安装repoAndroid 源码是使用 repo 管理的，所以我们首先安装repo，在安装repo前，你可能需要先安装 curl ： sudo apt-get install curl 安装完成后，可以通过命令查看 curl 的版本号，同时验证 curl是否安装完成 curl –version 步入正题，在deepn下，我们只需要在终端输入以下3条简单的命令即可完成repo的安装： mkdir ~/bincurl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo 接着，我们还需要为 repo 配置环境变量，在终端中输入： sudo vim /etc/bash.bashrc 当然，如果你安装了 sublime 的话，可以使用如下命令会更方便一些： sudo subl /etc/bash.bashrc 在这个打开的文件尾部添加你的环境变量，比如我的就是这样的(你需要把路径换成你的，一般来说你将我的例子中的 glassx 换成你的用户名即可)： export PATH=$PATH:/home/glassx/bin:$REPOPATH 使环境变量生效： source /etc/bash.bashrc 接下来，你可以正式下载Android 源码了。 下载 Android 源码由于众所周知的原因，我们下载Android 源码链接不可能成功，因此推荐使用清华大学的源，官方主页为： https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ 你也可以直接直接复制链接： https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar 放在迅雷中下载，这个文件略大，估计下载时间按照天来计算。 下载完成后，解压到指定文件夹(-C 用来指定解压后的文件存放位置)： tar -xvf /media/glassx/AndroidSourceCode/aosp-lastest.tar -C /media/glassx/AndroidSourceCode 在解压后的目录下， ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录，cd 到这个文件夹下，执行 : repo sync 就可以同步所有分支了，这个过程消耗的时间也略长，可能需要若干个小时，请耐心等待。至此，我们已经将 Android 源码成功下载下来并且解压同步分支了。 由于我同事有这个tar文件了，所以我就直接从他那里copy了过来，如果你同学或者同事也已经有这个tar文件了，可以直接复制这个文件。这里顺带说一下操作方式：如果你是windows ，并且他也是windows，则只需要他将这个文件所属的目录设置为共享文件夹，之后你在你的文件管理器中输入类似以下地址： \\192.168.12.13\\d\\共享文件夹 其中192.168.12.13 是你同事的ip，后面接的是共享文件夹的路径。 如果你的是deepin，你同事的也是linux，那么也好办，使用 ssh 登录你同事的电脑： ssh 192.168.12.13 登录成功后，进入你同事的电脑，通过 scp 命令可以把文件给copy到你的电脑上。 很多时候我们想要做的就是自己编译一个 Android 系统安装在模拟器上，这个我目前还未完成，等完成后，再来续上。","categories":[],"tags":[{"name":"手摸手","slug":"手摸手","permalink":"https://glassx.gitee.io/tags/%E6%89%8B%E6%91%B8%E6%89%8B/"}]},{"title":"第5章：Android 进程/线程管理","slug":"深入理解Android内核设计思想-第5章","date":"2019-08-06T13:40:00.000Z","updated":"2019-09-26T13:34:02.484Z","comments":true,"path":"2019/08/06/深入理解Android内核设计思想-第5章/","link":"","permalink":"https://glassx.gitee.io/2019/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC5%E7%AB%A0/","excerpt":"","text":"Android 进程和线程进程(process) 是程序的一个运行实例，而线程(Thread)则是 CPU 调度的基本单位。 对于Android应用开发者而言，通常面对的都是 Activity、Service等组件，并不需要特别关心进程是什么，因而产生了一些误区，如部分研发者认为系统四大组件就是进程的载体。 很遗憾，虽然四大组件很符合我们对进程的印象，但是他们不能算是完整的进程实例，最多只能算进程的组成部分，从 AndroidManifest.xml 中也可以得到一点提示（这个xml是对应用程序的声明和描述）： 1234&lt;application android:label=\"launch performance\"&gt; &lt;activity android:name=\"SimpleActivity\"&gt; ... 可以看到，Activity的外围有一个名为 的标签，换句话说，四大组件都只是 “application”的零件。通过例子来分析让读者有个更全面的认识，通过Activity A启动Activity B，在 B 的onCreate(Bundle savedInstanceState) 打断点，查看断点详情可以看到如下图所示的内容： 从这个实验中还解决了一个重要问题，即主线程到底怎么产生的，从上图的函数堆栈可以知道：主线程由ZygoteInit启动，经由一系列调用后最终才执行Activity的onCreate函数，并且，Zygote为Activity创建的主线程是 ActivityThread。以下是源码展示： 1234567891011121314151617181920212223public static void main(String[] args) &#123; CloseGuard.setEnabled(false); //只有主线程才能调用这个函数，普通线程应该使用prepare()，具体见对 Looper 的讲解 Looper.prepareMainLooper(); //主线程对应的handler if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; //这个main()是static的，因此这里需要创建一个实例 ActivityThread thread = new ActivityThread(); //Activity是由界面显示的，这个函数将与WindowManagerService 建立联系 thread.attach(false, startSeq); //主循环开始 Looper.loop(); //如果程序运行到了这里，说明退出了上面的Looper循环 throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 其实，启动Activity后，除了main thread 外还有多个binder线程，如下图所示（用于Binder的那些线程是在什么时候创建的，这个问题留到后面Binder章节详细解答）： 图中可以看到，B 被启动之后，主线程也始终只有一个，此时A退出了运行，但没有被杀掉，只是被压入了栈中。同样，如果我们启动一个Service，并把断点打在Service的onCreate方法的中，我们会发现，Service也是寄存于ActivityThread之中的，并且启动流程和Activity基本上一致，并且启动Service时，同样有Binder线程支持。限于篇幅，这里不做截图和代码。 按照Android系统设计：”By default，all componets of the same application run in the same process and thread(called the “main” thread)”，这可以理解为，对于同一个AndroidManifest中定义的四大组件，除非有特别的声明，否则它们都运行在同一个进程中(并且均由主线程处理事件)。如何证明呢？根据前面操作系统的基础知识，如果两个对象处于同一个进程空间，那么内存区域应该是可共享访问的，利用这个原理我们可以论证下： 12345678910111213141516171819202122232425262728//第1个activitypublic class MainActivity extends BaseActivity &#123; static int ConstTemp = -1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //在启动SecondActivity 前，将ConstTemp值改为2，如果他们不是处于同一个进程，那么在 // SecondActivity中是无法获得更新后的值 2 的，只可能是 -1 ConstTemp = 2; startActivity(new Intent(this,SecondActivity.class)); &#125;&#125;//第2个acitivitypublic class SecondActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); Log.e(\"SecondActivity\",\"ConstTemp = \" + MainActivity. ConstTemp); &#125;&#125; 最终输出的结果是2，说明都是在同一个进程中，当然，我们还可以通过查看二者的 PID 和 TID 的方法证明这两个Activity默认确实在同一个进程中。当然，Android还提供了特殊方式让不是同一个包的组件也可以运行于相同的进程中，这样做的优势是，它们可以方便地资源共享，而不用大费周章地进程间通信。这可以分为两种情况： 在AndroidManifest中的四大组件标签中加入 android:process 来表明这一组件想要运行在哪个进程空间。 针对整个程序包，可以直接在 标签中，加入 android:process 属性来指明想要依存的进程环境。 Handler、MessageQueue、Runable与Looper参考专题里面的内容（现在还没放上去）略 UI主线程-ActivityThread前面提到Activity的部分源码，这里精简下再贴出来： 1234567891011121314public static void main(String[] args) &#123; Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 普通线程使用Looper的代码如下： 1234567891011class LooperThread extends Thread&#123; public Handler mHandler; public void run()&#123; Looper.prepare(); mHandler = new Handler()&#123; public void handleMessage(Message msg)&#123;&#125; &#125; Looper.loop(); &#125;&#125; 比较二者的代码可知其中的区别主要体现在： prepareMainLooper 和 prepare，普通线程prepare就可以了，而主线程使用 prepareMainLooper ，主要是多了一步给sMainLooper 赋值的操作，这样，我们就能从主线程中通过 getMainLooper() 方式获得主线程的 Looper。 Handler不同，普通线程申城一个与Looper绑定的Handler，而主线程是从当前线程中获取的Handler，也就是说，ActivityThread 提供了一个“事件管家”，以处理主线程中各种消息。 Thread 类Thread 类的内部原理Thread 实现了 Runnable ，也就是说线程是“可执行的代码”。我们一般通过2种方式使用Thread ： 123456//第1种MyThread thr = new MyThread(...);thr.start();//第2种new Thread(Runnable target).start(); 这两种方法最终都通过 start 启动，它会间接调用Runable 的 run 实现. 线程的休眠和唤醒控制线程的相关方法我们至少可以想到以下几个： wait()、notify()、notifyAll()、interrupt()、join() 和 sleep()。 wait 和 notify/notifyAll 和其他方法不同，这3个函数是由 Object 类定义的——意味着它们是任何类的共有“属性”，那为什么这么设计呢？官方对wait的解释是： Causes the calling thread to wait until another thread calls the notify() or notifyAll() method of this object 当某个线程调用一个 Object 的wait 方法时，系统就要在这个 Object 中记录这个请求。因为调用者很可能不止一个，所以可使用列表的形式来逐一添加它们。当后期唤醒条件满足时， Object 既可以使用 notify 来唤醒列表中的一个等待线程，也可以通过 notifyAll 来唤醒列表中的所有线程。值得注意的是，调用者只有称为 Object 的 monitor 后，才能调用它的 wait 方法，而称为一个对象的 monitor 有以下3种途径： 执行这个 object 的 synchronize 方法 执行一段 synchronize 代码，并且是基于这个 object 做的同步 如果 object 是 Class 类，可以执行它的 synchronize static 方法 interrupt ：如果说wait是自愿行为， 那 interrupt 就是 “被迫” 的了，它的意思就是“中断”。 join，用以下例子说明： 12345Thread t1 = new Thread(new ThreadA());Thread t2 = new Thread(new ThreadB());t1.start();t1.join();t2.start(); 它希望达到的目的就是只有当 t1 线程执行完成时，我们才接着执行后面的 t2.start() 。这样就保证了两个线程顺序执行。 sleep：它和 wait 一样都是属于“自愿”的行为，只不过 wait 是等待某个 object ，而sleep 是等待时间，一旦设置的时间到了就会被唤醒。 Thread 实例讲一个典型范例来理解Thread：假如我们使用 SeekBar 开控制系统音效，要求：(1)UI界面响应流畅，(2)并且要能反映出音效的变化，(3)并且系统稳定。同时，有以下几个前提： 向系统发送音效调整的命令是个耗时操作 频繁向系统发送调整命令会导致死机 用户的操作是随意的，没有规律的（用户可能飞快地拉动，也有可能慢慢拉动） 对于要求1，可以将发送命令这个耗时操作放到一个独立线程执行，这样就不会影响UI，保证流畅。而根据3个前提条件，条件2和条件3是有矛盾的，如果要实时听到音效变化，在seekbar进度变化错城中需要不停地发送请求，而用户快速滑动导致产生大量请求，可能会引起死机，从而违背第3个要求。 再来想想其它简单方法，当启动一个新的线程处理调整请求时，显然需要把这些请求先放入消息队列中再排队处理，假设用户1s内产生了24个请求，那么队列中的数量将会陆续增加（假设500ms才处理完一个），直到用户操作结束。那么，实际上这些请求值是有优先级的，即后产生的调整值更贴近用户想要的效果。根据这个思想，我们可以适当控制消息队列中元素的数量，比如： 当产生新的调整值时，先清空消息队列，然后再把请求入队。 当产生新的调整值时，先判断消息队列的数量，根据实际情况删除部分消息，然后才请求入队。采用这种方式可以保证最后一个入队的请求总是可以被处理的，这也就意味着用户最终选择的音效值是可以体现出来的。示例代码如下： 12345678910111213141516171819private Thread mBusinessThread = null;private boolean mBusinessThreadStarted = false;private BusinessThreadHandler mBusinessThreadHandler = null;private void startBusinessThread()&#123; if(true == mBusinessThreadStarted) return; else mBusinessThreadStarted = true; mBusinessThread = new Thread(new Runnable()&#123; @Override public void run()&#123; Looper.prepare(); mBusinessThreadHandler = new BusinessThreadHandler(); Looper.loop(); &#125; &#125;); mBusinessThread.start();&#125; 上述代码使用Looper.loop 来不断处理调整请求，这些请求是通过 mBusinessThreadHandler 发送到 mBusinessThread 的消息队列中的，如下所示： 1234567891011121314151617181920public class BusinessThreadHandler extends Handler&#123; //重写 sendMessage @Override public boolean sendMessage(int what,int arg1,int arg2)&#123; //清理消息队列中未处理的请求 removeMessages(what); //发送消息到队列 return super.sendMessage(obtainMessage(what,arg1,arg2)); &#125; public void handleMessage(Message msg)&#123; switch(msg.what)&#123; case MSG_CODE: //执行耗时操作 break; default: break; &#125; &#125;&#125; sendMessage 方法中首先清除了消息队列中还未被处理的请求，这样一方面降低了程序向系统发送请求的频率，加快了相应速度和UI流畅性；另一方面保证 BusinessThreadHandler 下次取到的是优先级较高的调整请求值，保证用户听到实时的音效变化。 Android 应用程序的典型启动流程我们了解到 Android 系统中一个应用程序的主体是由 ActivityThread 构成的，并且 Android 系统是基于 Linux 的，原则上说它的应用程序并不只是 APK 一种类型，换句话说，所有 Linux 支持的应用程序都可以通过一定方式运行在 Android 上(一些系统级应用程序就是以这种方式存在的)，为了叙述统一，我们这里所指的应用程序都是 APK 类型的应用程序。它们通常由两种方式在系统中被启动： 在 Launcher 中点击相应的应用程序图标启动 通过 startActivity 启动 这两种启动方式的流程基本上是一致的，最终都会调用 ActivityManagerService(以下简称 AMS) 的 startActivity 来完成。在新的 Activity 启动钱，原先处于 resume 状态的 Activity 会被 pause ，这种管理方式比 Windows 的多窗口系统简单得多，将一个 Activity 置为 pause 主要通过此 Activity 所属进程的 ApplicationThread.schedulePauseActivity 方法完成，ApplicationThread 是应用程序进程提供给 AMS 的一个 Binder 通道。假设即将启动的 Activity 所属的进程并不存在，那么 AMS 还需要先把它启动起来。 ActivityThread 启动并做好相应的初始化工作后，需要调用 attachApplication 来通知 AMS ，后者才能继续执行未完成的 startActivity 流程。具体而言， AMS 通过 ApplicationThread.scheduleLaunchActivity 请求应用程序来启动一个指定的 Activity ，之后一系列工作就要靠应用进程自己来完成，如 Activity 创建 Window，遍历 View Tree 等。 在进入后面的章节前，这里先大略熟悉 startActivity 的流程。","categories":[],"tags":[{"name":"深入理解Android内核设计思想-林学森","slug":"深入理解Android内核设计思想-林学森","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E6%9E%97%E5%AD%A6%E6%A3%AE/"}]},{"title":"第8章: 虚拟机字节码执行引擎","slug":"深入理解Java虚拟机-第8章","date":"2019-08-01T13:00:00.000Z","updated":"2019-08-18T06:37:56.522Z","comments":true,"path":"2019/08/01/深入理解Java虚拟机-第8章/","link":"","permalink":"https://glassx.gitee.io/2019/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0/","excerpt":"","text":"概述在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，所有的虚拟机执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。 运行时栈帧结构栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的局部变量表、操作数栈、方法返回地址等信息。每一个方法从调用开始到执行完成的过程，对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。 在编译代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响。典型的栈帧结构如下图： 一个线程中的方法调用链可能会很长，在活动线程中，只有位于栈顶的栈帧才是有效的。 局部变量表局部变量表示一组变量值存储空间，用于存放 方法参数 和 方法内部蒂尼的局部变量。在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法(非static方法)，那局部变量表中第0位索引默认用于传递方法所属实例的引用，在方法中可以通过”this”关键字来访问这个隐含参数。剩下的参数则按照参数表顺序排列，参数表分配完毕后，再分配方法体内部定义的变量。 为了节省栈帧内存，局部变量表的空间是可以重用的，方法体中定义的变量，其作用域不一定会覆盖整个方法体，当超出作用范围时，它的空间就可能交给其他变量使用，不过这样的设计出了节省栈帧空间外，还会伴随额外的副作用，比如导致垃圾不能及时回收，以下举例说明()： 1234public static void main(String args)&#123; byte[] placeholder = new byte[64 * 1024 * 1024]; System.gc();&#125; 代码中向内存中填充了64MB数据，然后通知虚拟机进行垃圾收集，但是我们可以发现结果并没有回收。不过，这里没有回收placeholder所占的内存还说得过去，因为在执行gc时，placeholder还处于作用域之呢，虚拟机自然不会回收，下面把代码改下（代码8-2）： 12345678public static void main(String args)&#123; &#123; byte[] placeholder = new byte[64 * 1024 * 1024]; &#125; System.gc();&#125; 加入花括号之后，placeholder的作用域被限制在花括号之内，从代码逻辑上讲，gc的时候，placeholder就已经不可能再被访问了，但是执行以下，发现还是没有被回收。在解释之前，再次修改下代码试试（代码8-3）： 123456789public static void main(String args)&#123; &#123; byte[] placeholder = new byte[64 * 1024 * 1024]; &#125; int a = 0;//添加这句 System.gc();&#125; 再次运行，发现内存被正确地回收了，看起来很莫名其妙。placeholder 能否被回收的根本原因是：局部变量表中是否还存有关于placeholder数组的引用。第一次修改中，代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder原本所占的空间还没有被其他变量复用，所以作为GC Roots一部分的局部变量表仍然保持着对它的引用。这种关联没有被及时打断，在绝大部分情况下影响都很轻微。 但是如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（代替上面例子中的 int a = 0，把变量对应的局部变量表中的空间清理掉）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用。 上述例子说明了在某些情况下赋null值操作确实是有用的，但是不应对这种操作有过多依赖，更没必要当做普遍的编码规则来推广，原因有两点：一是从编码角度讲，以恰当的变量作用域来控制变量的回收时间才是最优雅的解决方案。二是从执行角度讲，使用赋null值操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，赋null值的方式在经过JIT编译优化之后就会被消除掉，这时候将变量设置为null是没有意义的。以前面的例子来说，代码8-2 的形式经过JIT编译后，System.gc() 执行时，就可以正确地回收内存了，无需再写成代码 8-3 的样子。 还有一点需要注意，类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；一次在初始化阶段，赋予程序员定义的初始值，因此，即使在初始化阶段没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量不一样，它并不存在“准备阶段”，因此如果定义了局部变量但是没有赋初始值是不能使用的。 这段做的笔记有点多，这是因为个人以前在一些书籍上看到有观点说，推荐及时将不使用的对象手动置为null，但是解释语焉不详，在这里从虚拟机角度看到了解释，故详细记下来 操作数栈操作数栈(operand stack)是一个后入先出的栈，痛局部变量表一样，操作数栈的最大深度也在编译时写入到Code属性中了。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容。 举个例子，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令是，会将这两个int值出栈并相加，然后将相加的结果入栈。 方法调用方法调用并不等同于方法执行，方法调用唯一的任务就是确定被调用方法的版本（即调用哪一个方法），还不设计方法内部的具体运行。前面已经讲过，Class文件的编译过程不包含传统编译中的连接步骤，一切方法调用在Class文件里面都只是符号引用，而不是方法在时机运行时内存布局中的入口地址（相当于之前说的直接引用）。 解析前面提到，所有方法调用中的目标方法在Class文件中都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用。这种解析能成立的前提是：“编译期可知，运行期不可变”，这类方法的调用就称为“解析(Resolution)”。符合这种特性的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。 只能被invokestatic 和 invokespecial 指令调用的方法都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实力构造器、父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法称为非虚方法，与之对应的称为虚方法（final方法除外）。 被final 修饰的方法虽然是通过invokevertual 指令调用的，但是由于它无法被覆盖，没有其他版本，所以Java语言规范中明确说明final是一种非虚方法。 分派Java具备面向对象的3个基本特征：继承、封装以及多态。分派调用过程将会揭示多态性特征的一些基本体现，如“重载”和“重写”在Java虚拟机中是如何实现的。 1、 静态分派 在讲解静态分派之前，看一段经常出现在面试题中的代码，方法静态分派代码如下面代码8-6所示： 123456789101112131415161718192021222324252627282930public class StaticDispatch&#123; static abstract class Human&#123; &#125; static class Man extends Human&#123; &#125; static class Woman extends Human&#123; &#125; public void sysHello(Human guy)&#123; System.out.println(\"hello ,guy !\"); &#125; public void sysHello(Man guy)&#123; System.out.println(\"hello ,gentleman !\"); &#125; public void sysHello(Woman guy)&#123; System.out.println(\"hello ,lady !\"); &#125; public static void main(String[] args)&#123; Human man = new Man(); Human woman = new Woman(); StaticDispatch sr = new StaticDispatch(); sr.sayHello(man); sr.sayHello(woman); &#125;&#125; 打印结果： hello ,guy!hello ,guy! 这段代码实际上是考验读者对重载的理解程度，但这里为什么会选择执行参数类型为 Human 的重载呢？解决问题前，先按如下代码定义两个重要概念： Human man = new Man(); 上面代码中的”Human”称为变量的静态类型（Static Type）或叫做外观类型(Apparent Type)，后面的 “Main” 则称为变量的实际类型(Actual Type)。静态类型和实际类型在程序中都可以发生一些变化，**区别是，静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才确定，例如下面代码： 1234567//实际类型变化Human man = new Man();man = new Woman();//静态类型变化sr.sayHello((Man)man);sr.sayHello((Woman)man) 回到上面代码 8-6 中，由于虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的，并且静态类型是编译期可知的，因此在编译阶段，根据静态类型选择了 sayHello(Human) 作为调用目标，并把这个方法的符号引用写到main方法里的两条invokevirtual指令参数中。静态分派的典型应用是方法重载，另外，编译器虽然能确定出方法的重载版本，但很多情况下这个重载版本并不是”唯一“的，往往只能确定一个”更加合适的“版本，以下代码 8-7演示了何为”更加合适“的版本： 123456789101112131415161718192021222324252627282930313233public class Overload&#123; public static void sysHello(Object arg)&#123; System.out.println(\"hello Object\"); &#125; public static void sysHello(int arg)&#123; System.out.println(\"hello int\"); &#125; public static void sysHello(long arg)&#123; System.out.println(\"hello long\"); &#125; public static void sysHello(Character arg)&#123; System.out.println(\"hello Character\"); &#125; public static void sysHello(char arg)&#123; System.out.println(\"hello char\"); &#125; public static void sysHello(char... arg)&#123; System.out.println(\"hello char...\"); &#125; public static void sysHello(Serializable arg)&#123; System.out.println(\"hello Serializable\"); &#125; public static void main(String[] args)&#123; sayHello('a') &#125;&#125; 打印结果： hello char 如果注释掉 sysHello(char arg) 方法，则会打印 “hello int”；再注释掉 sysHello(int arg) 方法，则会打印 “hello long”；再注释掉 sysHello(long arg) 方法，则会打印 “hello Character”；如此下去，输出的结果会不断变化。这其实也还好理解： ‘a’首先是个char，自然首先输出 hello char；如果没有该方法，则自动类型转换为int，如果再没有此方法，则会进一步转换为long类型（按照 char -&gt; int -&gt; long -&gt; float -&gt; double的顺序进行匹配，但不会匹配到byte和short类型，因为转型到这两种是不安全的）。所以上述代码在注释掉 sysHello(long arg) 后，输出变为 “hello Character” ，此时发生了自动装箱。如此注释下去，”hello char…” 将会是最后一个打印的，可见变长参数的重载优先级是最低的，甚至比Object还低。值得注意的是，有一些在单个参数中成立的自动转型，如char转型为 int，在变长参数中是不成立的。 2、 动态分派 动态分派和多态性的另一个重要体现——重写(Override)有很密切的关联，结合前面Man和Woman一起sayHello的例子来看如下代码： 123456789101112131415161718192021222324252627282930public class DynamicDispatch&#123; static abstract class Human&#123; protected abstract void sayHello(); &#125; static class Man extends Human&#123; @Override protected void sayHello()&#123; System.out.println(\"man say hello\"); &#125; &#125; static class Woman extends Human&#123; @Override protected void sayHello()&#123; System.out.println(\"woman say hello\"); &#125; &#125; public static void main(String[] args)&#123; Human man = new Man(); Human woman = new Woman(); man.sayHello(); woman.sayHello(); man = new Woman(); man.sayHello(); &#125;&#125; 打印结果： man say hellowoman say hellowoman say hello 结果不出人意料，但是虚拟机是如何知道要调用哪个方法？这里显然不能再根据静态类型来决定，因为静态类型都是Human的两个变量 man 和woman 在调用 sayHello 方法时执行了不同的行为，并且man在两次调用中执行了不同的方法。因此可以看出，这只是因为变量的实际类型不同。因为invokevirtual指令的运行时解析过程大致如下： 第一步：找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C第二步：如果在C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过，则返回方法的直接引用；否则，返回 java.lang.IllegalAccessError异常。第三步：否则，按照继承关系从下往上一次对C的各个父类进行第二步的搜索和验证。第四步： 如果始终没有找到合适的方法，则抛 java.lang.AbstractMethodError异常。 3、 单分派与多分派 方法的接收者与方法的参数统称方法的宗量。根据分派基于多少种宗量，可以将分派划分为但分派和多分派，单分派是根据一个宗量对目标方法进行选择；多分派就是根据多个宗量对目标方法进行选择。定义比较拗口，对照下面这个例子，分析 Father 和 Son 做“艰难决定”之后，就不难理解了： 1234567891011121314151617181920212223242526272829303132333435//单分派、多分派的例子public class Dispatch&#123; static class QQ &#123;&#125; static class _360 &#123;&#125; public static class Father&#123; public void hardChoice(QQ arg)&#123; System.out.println(\"father choose qq\"); &#125; public void hardChoice(_360 arg)&#123; System.out.println(\"father choose 360\"); &#125; &#125; public static class Son extends Father&#123; public void hardChoice(QQ arg)&#123; System.out.println(\"son choose qq\"); &#125; public void hardChoice(_360 arg)&#123; System.out.println(\"son choose 360\"); &#125; &#125; public static void main(String[] args)&#123; Father father = new Father(); Father son = new Son(); father.hardChoice(new _360()); son.hardChoice(new QQ()); &#125;&#125; 运行结果： father choose 360son choose qq 根据以上代码，我们看看编译阶段编译器的选择过程，也即静态分配过程。这时候选择目标方法的依据有两点：静态类型以及参数，最终产物是产生了两条invokevirtual 指令，两条指令的参数分别为常量池中指向 Father.hardChoice(_360) 以及 Father.hardChoice(QQ) 方法的符号引用，因为是根据两个宗量选择，所以Java语言的静态分派属于多分派类型。 再看看运行阶段虚拟机的选择，也即动态分派的过程。在执行 “son.hardChoice(new QQ())” 时，由于编译期已经决定目标方法的签名必须为 hardChoice(QQ) ,此时，参数的静态类型和参数的实际类型都对方法的选择不会构成任何影响(只要是QQ类型，管你是“腾讯QQ”还是“奇瑞QQ”)，唯一可以影响虚拟机选择的因素只有方法接受者的实际类型是 Father 还是 Son ，因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。 因此，到目前为止（Java 1.8），我们可以说Java语言是一门静态多分派、动态单分派的语言。 4、虚拟机动态分派的实现 上述的分派结局虚拟机在分派过程中“会做什么”，具体如何做到的，不同虚拟机之间会有差异。由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜寻合适的目标方法。但是在实际实现中并不会进行如此频繁的搜索，面对这种情况，最常用的手段就是为类在方法区中建立一个**虚方法表(Vitual Method Table,即vtab)，使用虚方法表索引来替代元数据查找以提高性能.基于上方的代码，做如下虚方法表示意： 虚方法表中存放着各个方法的实际入口地址，如果方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类方法相同，否则，替换为子类具体实现版本的地址入口。因此图中Son的hardChoice方法并没有和父类指向同一处。 动态语言支持略，后续看到这里补上 基于栈的字节码解释执行引擎Java 语言经常被人们定位为“解释执行”的语言，在Java 1.0 时代，这定义还算准确，但当主流的虚拟机中都包含了即时编译器后，Class 文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机才知道的事情。再后来，Java也发展处了可以直接生成本地代码的编译，而C/C++也出现了通过解释器执行的版本，这时候再笼统地说“解释执行”，对于整个Java语言来说几乎没有意义。 基于栈的指令集与基于寄存器的指令集Java 编译器输出的指令，基本上是一种基于栈的指令集架构，它们依赖操作数栈进行工作；与之相对的另一套常用的指令集架构是基于寄存器的指令集。那么二者有何不同呢？举个简单的例子，分别使用两种指令集计算“1+1”，基于栈的指令集会是这个样子： iconst_1iconst_1iaddistore 0 两条icons_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后 istore_0把栈顶的值放到局部变量表的第0个Slot中。而如果基于寄存器，那程序可能就会是这样： mov eax, 1add eax, 1 mov 指令把EAX寄存器的值设为 1，然后add指令再把这个值加1，结果就保存在 EAX寄存器里面。了解了区别之后，那么这两套指令集哪一种更好？其实是各有所长，基于栈的指令集的主要优点是可移植，而基于寄存器的话，程序要直接依赖于这些硬件寄存器而不可便面地受到硬件的约束。栈架构指令集的主要缺点是执行速度相对来说会稍慢一些，完成相同功能所需要的指令一般会比寄存器的要多，因为出栈和入栈操作本身就产生了相当多的指令数量，更重要的是，栈实现在内存之中，频繁的栈访问也意味着频繁的内存访问，对处理器来说，内存始终是执行速度的瓶颈。 基于栈的解释器执行过程以示例讲述解释器执行过程， 略 本章小结6、7、8章，我们分析了 Java程序是如何存储的、如何载入（创建）的以及如何执行的问题，第9章将一起看看这些理论知识在具体开发中的经典应用。","categories":[],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"第7章: 虚拟机类加载机制","slug":"深入理解Java虚拟机-第7章","date":"2019-07-28T03:00:00.000Z","updated":"2019-08-01T13:29:46.417Z","comments":true,"path":"2019/07/28/深入理解Java虚拟机-第7章/","link":"","permalink":"https://glassx.gitee.io/2019/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC7%E7%AB%A0/","excerpt":"","text":"概述上一章了解了Class文件存储格式，在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能运行和使用，那么，虚拟机如何加载这些文件？ 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。在Java语言中，类型的加载、连接和初始化都是在程序运行期间完成的，这令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性。 例如，可以等到运行时再指定其实际的实现类：用户可以通过Java预定义和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或者其他地方加载一个二进制流作为程序代码的一部分。 类加载的时机类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期如下图所示： 总共有7个阶段，其中验证、准备、解析 这3个部分统称为连接(Linking)，并且加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载按照上述顺序按部就班地开始（不是“进行”，也不是“完成”，只是按部就班地“开始”，因为这些阶段通常都是相互交叉地混合式进行）。 虚拟机规范中严格规定了有且只有5种情况必须立即对类进行初始化（而加载、验证、准备自然需要在此之前开始）： 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。 这4条指令的最常见的Java代码中的场景是：使用new关键字实例化对象、读取或者设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）、以及调用一个类的静态方法。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则先触发其初始化。 当初始化一个类，如果发现其父类还没有进行过初始化，则需要先触发其父类初始化。 虚拟机启动时，虚拟机会先初始化用户指定的主类（包含main()方法的那个类） 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 以上5种场景中的行为称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用。以下举3个例子来说明何为被动引用。 1234567891011121314151617181920212223//被动使用类字段演示一：//通过子类引用父类的静态字段，不会导致子类初始化public class SuperClass&#123; static&#123; Systemt.out.printlin(\"SuperClass init!\"); &#125; public static int value = 123;&#125;public class SubClass extends SuperClass&#123; static&#123; Systemt.out.printlin(\"SubClass init!\"); &#125;&#125;//非主动使用类字段演示public class NotInitialization&#123; public static void main(String[] args)&#123; System.out.printlin(Subclass.value); &#125;&#125; 上述代码运行后，只会输出 “SuperClass init!” ，对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。 12345678//被动使用类字段演示二：//通过数组定义来引用类，不会触发此类的初始化public class NotInitialization&#123; public static void main(String[] args)&#123; SuperClass[] sca = new SuperClass[10]; &#125;&#125; 这里复用了上面的 SuperClass ，运行之后，发现没有输出 “SuperClass init!” ，说明没有触发 SuperClass 的初始化阶段。 12345678910111213141516//被动使用类字段演示二：//常量在便一阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化public class ConstClass&#123; static&#123; Systemt.out.printlin(\"ConstClass init!\"); &#125; public static final String HELLOWORLD = \"hello world\";&#125;public class NotInitialization&#123; public static void main(String[] args)&#123; Systemt.out.printlin(ConstClass. HELLOWORLD); &#125;&#125; 上述代码运行之后，也没有输出 “ConstClass init!” ，虽然在 Java 源码中引用了 ConstClass 中的常量 HELLOWORLD ，但其实在编译阶段通过常量传播优化，已经将此常量值 “hello world” 存储到了 NotInitialization 类的常量池中，以后 NotInitialization 对常量 ConstClass. HELLOWORLD 的引用时机都被转化为 NotInitialization 对自身常量池的引用了。也就是说，实际上 NotInitialization 的 Class 文件之中并没有 ConstClass 类的符号引用入口，这两个类在编译成 Class 之后就不存在任何联系了。 接口的加载过程与类加载过程稍有一些不同，接口与类真正有所区别的是前面讲述的5种“有且仅有”需要开始初始化场景中的第3种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。 顺带说明一下，上面的代码都是用静态语句块 “static{}”来输出初始化信息的，但接口中不能使用 “static{}”语句块。 类加载过程加载“加载”是“类加载(Class Loading)”过程的一部分，不要混淆。在加载阶段，虚拟机需要完成以下3件事情： 通过类的全限定名获取类的二进制字节流 将字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。 这3点规范并不算具体，例如第一条，并没有指明要从哪里获取，怎么获取，因此充满创造力的开发人员玩出了各种花样： 从 zip 包中读取，最终成为日后 jar、ear、war 格式的基础 从网络中获取，比如Applet 运行时计算生成，这种场景用得最多的就是动态代理技术。 验证验证是连接阶段的第一步，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击。从整体来看，验证阶段大致上会完成下面4个阶段的检验动作： 文件格式验证 魔数0xCAFEBABE开头、主次版本是否在虚拟机处理范围内等。 元数据验证 是否有父类-除Object外，所有类都有父类、父类是否继承了不允许被继承的类-final修饰，是否实现了父类或者接口要求实现的所有方法。 字节码验证 通过数据流和控制流分析，确定程序语义是否合法、符合逻辑的。如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。 符号引用验证 这个校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段发生。通常校验：通过全限定名是否能找到对应的类、符号引用中的类、字段、方法的访问性(private、protected、public、default)是否可以被当前类访问 等等。 准备准备阶段正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。 这里两个容易产生的混淆的概念强调一下：首先，这时候进行内存分配的仅仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时一起分配在java堆中。其次，这里说的初始值“通常情况”下是数据类型的零值，假设一个类变量定义为： public static int value = 123; 那变量value在准备阶段过后的初始值为 0 而不是 123。把value赋值为123的动作将在初始化阶段才会执行。 解析解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。 符号引用(Symbolic References)：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。 直接引用(Symbolic References)：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。 初始化到了初始化阶段，才真正开始执行类中定义的Java程序代码(或者说是字节码)。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序自定的主观计划去初始化类变量和其他资源。换一个角度来表达就是：初始化阶段是执行类构造器()方法的过程。以下介绍下()方法执行过程中一些可能会影响程序运行行为的特点和细节： ()方法由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。一个例子说明： 12345678910111213public class Test&#123; static int i =1; static&#123; Systemt.out.print(i);//正常使用 j = 0;//给变量赋值可以正常编译 Systemt.out.print(j);//这句提示“非法向前引用” &#125; static int j =1;&#125; ()方法与类的构造函数（实例构造器()）不同,它不需要显式地调用父类构造器，虚拟机会保证在子类的 () 执行之前，父类的()已经执行完毕。因此，在虚拟机中第一个被执行()方法的类肯定是 java.lang.Object。这其实也意味着，父类定义的静态语句块要优先于子类变量赋值操作。一个例子说明： 123456789101112131415static class Parent&#123; public static A = 1; static&#123; A = 2; &#125;&#125;static class Sub extentds Parent&#123; public static int B = A;&#125;public static void main(String args[])&#123; Systemt.out.println(Sub.B)&#125; 以上代码将打印出 2 而不是 1。 ()方法对于类或者接口不是必需的，如果类中没有静态语句块，也没有对变量的赋值，那么编译器可以不为这个类生成()方法。 接口中不能使用静态语句块，但是可以有变量初始化的赋值操作，因此接口与类一样都会生成 ()方法 。但接口的 ()方法 无须先执行父接口的()方法，只有父接口中定义的变量使用时，父接口才会初始化（接口的实现类在初始化时也不会执行接口的()方法）。 虚拟机会保证一个类的 ()方法 在多线程环境中会被正确地加锁、同步，所以，多线程同时去初始化一个类，那么只会有一个县城执行这个类的&lt;clinit&gt;()方法，其他的线程都会阻塞等待。举个例子： 12345678910111213141516171819202122232425262728static class DeadLoopClass&#123; static&#123; //如果不加上这个if语句，编译器将报错，并拒绝编译 if(true)&#123; System.out.println(Thread.currentThread() + \"init DeadLoopClass\"); while(true)&#123; &#125; &#125; &#125; public static void main(String[] args)&#123; Runnable script = new Runnable()&#123; public void run()&#123; Systemt.out.println(Thread.currentThread() + \"start\"); DeadLoopClass dlc = new DeadLoopClass(); Systemt.out.println(Thread.currentThread() + \"run over\"); &#125; &#125;; Thread thread1 = new Thread(script); Thread thread2 = new Thread(script); thread1.start(); thread2.start(); &#125;&#125; 上述代码在死循环以模拟长时间操作，另外一条线程在阻塞等待，将打印以下结果： Thread[Thread-0,5,main]startThread[Thread-1,5,main]startThread[Thread-0,5,main]init DeadLoopClass 类加载器虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。 类与类加载器对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗地说，比较两个类是否“相等”，只有在这两个类都是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，都被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 这里的“相等”，包括代表类的Class对象的 equals() 、isAssignableFrom()、isInstance() 方法返回的结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。以下代码演示了不同类加载器对instanceof关键字运算的结果的影响： 1234567891011121314151617181920212223242526public class ClassLoaderTest&#123; public static void main(String[] args) throws Exception&#123; ClassLoader myLoader = new ClassLoader()&#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException&#123; try&#123; String fileName = name.substring(name.lastIndexOf(\".\") + 1); InputStream is = getClass().getResourceAsStream(fileName); if(is == null)&#123; return super.loadClass(name); &#125; byte[] b = new byte[is.available()]; is.read(b); return defineClass(name,b,0,b.length); &#125;catch()&#123; throw new ClassNotFoundException(); &#125; &#125; &#125; Object obj = myLoader.loadClass(\"org.example.classloading. ClassLoaderTest\"); Systemt.out.println(obj.getClass()); System.out.println(obj instanceof org.example.classloading. ClassLoaderTest); &#125;&#125; 返回结果： class org.example.classloading. ClassLoaderTestfalse 从结果可以看出，对象确实是类 “org.example.classloading. ClassLoaderTest” 的类，并实例化了这个类的对象。但这个对象与类 org.example.classloading. ClassLoaderTest 做所属类型检查的时候却返回了false，这是因为虚拟机中存在了两个 ClassLoaderTest 类，一个由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来自同一个Class文件，但依然是两个独立的类。 双亲委派模型从java虚拟机角度来讲，只存在两种类加载器：一种是启动类加载器(Bootstrap ClassLoader)，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类 java.lang.ClassLoader。 如下图所示的类加载器之间的这种层次关系，称为双亲委派模型(Parent Delegation Model)。 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合(Composition)关系来复用父加载器的代码。 双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 双亲委派模型一个显而易见的好处就是：Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。 例如类 java.lang.Object ，无论哪一个类加载器都要加载这个类（因为所有的类都直接或间接地继承了它），最终都是委派给处于模型最顶端的启动类加载器进行加载，因此，Object 类在程序中的各种类加载器环境中都是同一个类。相反，如果不使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在 ClassPath 中，那系统中将将会出现多个不同的Object 类，Java类型体系中最基础的行为也就无法保证。 破坏双亲委派模型略","categories":[],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"第6章: 类文件结构","slug":"深入理解Java虚拟机-第6章","date":"2019-07-27T06:56:00.000Z","updated":"2019-07-28T03:00:00.881Z","comments":true,"path":"2019/07/27/深入理解Java虚拟机-第6章/","link":"","permalink":"https://glassx.gitee.io/2019/07/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC6%E7%AB%A0/","excerpt":"","text":"概述计算机只认识0和1，但是最近10年虚拟机以及大量建立在虚拟上的语言的发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。 无关性的基石Sun公司及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现程序的“一次编写，到处运行”。而各种不同平台的虚拟机以及平台无关的字节码（ByteCode）是构成平台无关性的基石。 到目前为止，或许大部分程序员都还认为Java虚拟机执行Java程序是一件理所当然的事情，但在Java发展之初，Java的规范就分为Java语言规范以及Java虚拟机规范，时至今日，Java语言之外已经有一大批语言运行在Java虚拟机之上，如 Groovy、JRuby、Jython等。 Java 虚拟机不和包括Java在内的任何语言绑定，它只与“Class 文件”这种特定的二进制文件格式所关联，任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。 Class 类文件的结构Class 文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有任何分隔符。遇到需要占用8位字节以上空间的数据项时，会按照高位在前的方式分割成若干个8位字节进行存储。 Class 文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种结构只有两种数据类型： 无符号数和表。 无符号数属于基本的数据类型，以u1、u2、u4、u8分别代表1、2、4、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8 编码构成的字符串值。 表示由多个无符号数或者其他表作为数据项的复合数据类型，表用于描述有层次关系的复合结构的数据，整个Class文件本质就是一张表。 魔数与Class文件的版本Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。Class 文件的魔数值为 0xCAFEBABE (咖啡宝贝？)，很有浪漫气息。紧接着魔数的4个字节存储着Class文件的版本号，高版本的JDK能乡下兼容以前版本的Class文件，但不能运行以后版本的Class文件。 很多文件存储标准中都使用魔数来进行身份识别，如gif和jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来识别主要是基于安全考虑： 文件扩展可以随意改动。 常量池版本号之后是常量池入口，该区域可以理解为Class文件中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值。 常量池中主要存放两大类常量：字面量（Literal） 和 符号引用（Symbolic References）。字面量比较接近于Java语言层面的常量概念，如 文本字符串、声明为final的常量值等，而符号引用则属于编译原理方面的概念，包括了下面三类常量： 类和接口的全限定名(Fully Qualified Name) 字段的名称和描述符(Descriptor) 方法的名称和描述符 Java代码在javac编译的时候，并不像c和c++那样有“连接”这一步骤，而是在虚拟机加载 Class 文件的时候进行动态连接，也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息。虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时解析、翻译到具体的内存地址中。 访问标志常量池结束后，紧接着2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括： 这个Class 是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等等。 类索引、父类索引与接口索引集合类索引（this_class） 和父类索引(super_class)都是一个u2类型的数据，而接口索引集合(interfaces)是一组u2类型的数据的集合，class 文件中由这三项数据来确定这个类的继承关系。 其中，类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于Java不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此，父类索引都不为0。接口索引集合用来描述这个类实现了哪些接口，按照implement语句后的接口顺序从左到右排列在接口索引集合中。 字段表集合字段表(field_info)用于描述接口或者类中声明的变量，包括类级变量和实例级变量，不包括方法内的局部变量。这个描述可以包括的信息有： 字段的作用域(public、private、protected修饰符)、实例变量还是类变量(static修饰符)、可变性(final)、并发可见性(volatile 修饰符，是否强制从主内存读写)、可否被序列化(transient修饰符) 等等。 方法表集合Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，只是些微的区别，比如volatile关键字和transient关键字不能修饰方法 。 属性表集合在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息(这一块内容也没耐心看下去，下次看明白再补)。 字节码指令简介这章离App开发比较远，因此第一遍的时候先略过。 公有设计和私有实现理解公有设计与私有实现之间的分界线是非常有必要的，Java虚拟机实现必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。按照Java虚拟机规范一成不变地逐字实现其中要求的内容是一种可行的途径，但是一个优秀的虚拟机实现，在满足虚拟机规范的约束下对具体实现做出修改和优化也是完全可行的。虚拟机实现的方式主要有以下两种： 将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。 将输入的Java虚拟机代码在加载或执行翻译成宿主机CPU的本地指令集（即 JIT 代码生成技术） Class 文件结构的发展略。","categories":[],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"第3章：View体系与自定义View《一》","slug":"Android进阶之光-第3章","date":"2019-07-06T13:00:00.000Z","updated":"2019-07-07T08:18:44.058Z","comments":true,"path":"2019/07/06/Android进阶之光-第3章/","link":"","permalink":"https://glassx.gitee.io/2019/07/06/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89-%E7%AC%AC3%E7%AB%A0/","excerpt":"","text":"坐标系Android 系统中有两种坐标系：Android 坐标系和 View 坐标系，了解这两种坐标系能够帮助我们实现View的各种操作。 Android坐标系Android坐标系中， 将屏幕左上角的顶点作为原点， 这个原点向右是X轴正方向， 向下是Y轴正方向， 如下图所示。 View坐标系View坐标系与Android坐标系并不冲突，两者是共同存在的，一起来帮助开发者更好地控制View。对于View坐标系，搞明白下图的信息即可： MotionEvent提供的方法：假设上图中间的那个圆点就是我们触摸点，无论是View还是ViewGroup，最终的点击事件都会由onTouchEvent(MotionEvent event)方法来处理。MotionEvent提供了获取焦点坐标的各种方法： getX()：获取点击事件距离控件左边的距离，即视图坐标。 getY()：获取点击事件距离控件顶边的距离，即视图坐标。 getRawX()：获取点击事件距离整个屏幕左边的距离，即绝对坐标。 getRawY()：获取点击事件距离整个屏幕顶边的距离，即绝对坐标。 View的滑动View的滑动基本思想：当点击事件传到View时，系统记下触摸点的坐标，手指移动时系统记下移动后触摸的坐标并算出偏移量，并通过偏移量来修改View的坐标。 实现View滑动有很多种方法， 在这里主要讲解6种滑动方法， 分别是layout()、offsetLeftAndRight() 与 offsetTopAndBottom()、LayoutParams、动画、scollTo 与 scollBy ，以及Scroller。 layout方法View进行绘制的时候会调用onLayout()方法来设置显示的位置， 因此我们同样也可以通过修改View的left、 top、 right、 bottom属性来控制View的坐标。以下是实现一个随手指滑动的自定义view的步骤： 首先获取触摸点的坐标 123456789101112public boolean onTouchEvent(MotionEvent event)&#123; //获取手指触摸点的横坐标和纵坐标 int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: lastX = x; lastY = y; break; &#125;&#125; 在ACTION_MOVE事件中计算偏移量,再调用layout（ ） 方法重新放置这个自定义View的位置即可: 123456789case MotionEvent.ACTION_MOVE: //计算移动距离 int offsetX = x - lastX; int offsetY = y - lastY; //调用layout方法来重新确定它的位置 layout(getLeft() + offsetX,getTop()+offsetY, getRight()+offsetX,getBottom()+offsetY) break 在每次移动时都会触发layout()方法对屏幕重新布局，从而达到移动View的效果。 offsetLeftAndRight() 与offsetTopAndBottom()这两种方法和layout()方法的效果以及使用方式都差不多，只需要将上面ACTION_MOVE中的代码替换为以下代码即可： 123456789case MotionEvent.ACTION_MOVE: //计算移动距离 int offsetX = x - lastX; int offsetY = y - lastY; //对left 及 right 进行偏移 offsetLeftAndRight(offsetX); //对top及bottom进行偏移 offsetTopAndBottom(offsetY); break; LayoutParams（ 改变布局参数）LayoutParams主要保存了View的布局参数， 因此可以通过改变它来达到改变View位置的效果。 我们只需将 ACTION_MOVE 中的代码替换成如下代码即可(注意是：MarginLayoutParams)： 12345678910case MotionEvent.ACTION_MOVE: //计算移动距离 int offsetX = x - lastX; int offsetY = y - lastY; ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams)getLayoutParams(); params.leftMargin = getLeft() + offsetX; params.topMargin = getTop() + offsetY; setLayoutParams(params) break; 动画采用动画来移动，在res目录新建anim文件夹并创建如下translate.xml文件: 1234567&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:fillAfter=\"true\"&gt; &lt;translate android:duration=\"1000\" android:fromXDelta=\"0\" android:toXDelta=\"300\"/&gt;&lt;/set&gt; 在Java中调用： view.setAnimation(AnimationUtils.loadAnimation(this,R.anim.translate)) 需要注意的是，如果动画文件中没有添加 android:fillAfter=”true” ，则方块向右平移300像素后，又返回原来的位置。并且，View动画不能改变View的位置参数，如果对一个Button加上如上的平移动画，当Button平移300像素停留在当前位置时，我们点击这个Button并不会触发点击事件，但是点击原始位置却触发了点击事件，这是因为对于系统来说，Button并没有改变原来位置。 在Android 3.0出现的属性动画解决了上述问题，它不仅可以执行动画，还能改变View的位置参数，其操作如下： ObjectAnimator.ofFloat(view,”translationX”，0，300).setDuration(1000).start() scrollTo 与 scrollByscollTo、scollBy移动的是View的内容，如果在ViewGroup中使用， 则是移动其所有的子View。scrollTo(x，y)表示移动到一个具体的坐标点，而scrollBy(dx，dy)则表示移动的增量为dx、dy。 其中， scollBy最终也是要调用scollTo的。二者的源码如下： 123456789101112131415161718public void scrollTo(int x,int y)&#123; if(mScrollX != x || mScrollY != y)&#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if(!awakenScrollBars())&#123; postInvalidateOnAnimation(); &#125; &#125;&#125;public void scrollBy(int x,int y)&#123; scrollTo(mScrollX + x, mScrollY + y)&#125; 如果要实现上面view随手指滑动的效果，就需要将ACTION_MOVE中的代码替换成如下代码： ((View)getParent()).scrollBy(-offsetX,-offsetY); 请注意，这里是对view的parent进行scroll，这是因为如果对view本身scroll的话，就是对自己的内容进行移动，而不是整个view。并且注意，这里设置的偏移量值都为负值，以下具体讲解一下。 假设我们正用放大镜来看报纸，放大镜用来显示字的内容。同样我们可以把放大镜看作我们的手机屏幕，它们都是负责显示内容的；而报纸则可以被看作屏幕下的画布，它们都是用来提供内容的。放大镜外的内容，也就是报纸的内容不会随着放大镜的移动而消失，它一直存在。同样，我们的手机屏幕看不到的视图并不代表其不存在。过程的示意图如下： scrollBy之前： 调用scrollBy(50,50)之后： Scroller我们在用scollTo/scollBy方法进行滑动时，这个过程是瞬间完成的，所以用户体验不大好。这里我们可以使用 Scroller 来实现有过渡效果的滑动，这个过程不是瞬间完成的，而是在一定的时间间隔内完成的。Scroller本身是不能实现View的滑动的，它需要与View的computeScroll() 方法配合才能实现弹性滑动的效果。具体代码如下示意： 12345678910111213141516171819202122232425262728public CustomView(Context context,AttributeSet attrs)&#123; private Scroller mScroller; super(context,attrs); //初始化mScroller mScroller = new Scroller(conetxt); @Override public void computeScroll()&#123; super.computeScroll(); if(mScroller.computeScrollOffset())&#123; ((View)getParent()).scrollTo(mScroller.getCurrentX(),mScroller.getCurrentY()); invalidate(); &#125; &#125; //提供调用的方法 public void smoothScrollTo(int destX,int destY)&#123; int scrollX = getScrollX(); int scrollY = getScrollY(); int deltaX = destX - scrollX; int deltaY = destY - scrollY; mScroller.startScroll(scrollX, scrollY, deltaX, deltaY); &#125;&#125; 我们首先初始化Scroller，之后重写computeScroll方法，系统会在绘制View的时候在 draw 方法中调用该方法。在computeScroll方法中， 我们调用父类的scrollTo() 方法并通过Scroller来不断获取当前的滚动值， 每滑动一小段距离我们就调用invalidate() 方法不断地进行重绘，重绘就会调用computeScroll()方法， 这样我们通过不断地移动一个小的距离并连贯起来就实现了平滑移动的效果。这里我们设定CustomView沿着X轴向右平移400像素(至于为什么是负数，上面已经解释过了): mCustomView.smoothScrollTo(-400,0); 属性动画在属性动画出现之前，Android系统提供的动画只有帧动画和 View 动画。View 动画我们都了解，它提供了AlphaAnimation、 RotateAnimation、 TranslateAnimation、 ScaleAnimation这4种动画方式，并提供了AnimationSet动画集合来混合使用多种动画。 随着Android 3.0属性动画的推出， View动画不再风光。 相比属性动画， View动画一个非常大的缺陷突显， 其不具有交互性。 当某个元素发生View动画后，其响应事件的位置依然在动画进行前的地方， 所以View动画只能做普通的动画效果， 要避免涉及交互操作。 但是它的优点也非常明显： 效率比较高， 使用也方便。 在属性动画中使用最多的就是AnimatorSet和ObjectAnimator配合： 使用 ObjectAnimator 进行更精细化的控制， 控制一个对象和一个属性值， 而使用多个ObjectAnimator组合到AnimatorSet形成一个动画。 属性动画通过调用属性get、 set方法来真实地控制一个View的属性值， 因此， 强大的属性动画框架基本可以实现所有的动画效果。 ObjectAnimatorObjectAnimator 是属性动画最重要的类， 创建一个 ObjectAnimator 只需通过其静态工厂类直接返还一个ObjectAnimator对象。 参数包括一个对象和对象的属性名字， 但这个属性必须有get和set方法， 其内部会通过Java反射机制来调用set方法修改对象的属性值。 一般使用方式如下： ObjectAnimator.ofFloat(view,”translationX”,200,0).start() ObjectAnimator的使用方法就不介绍了，需要注意的是， 在使用ObjectAnimator的时候， 要操作的属性必须要有get和set方法， 不然ObjectAnimator 就无法生效。 如果一个属性没有get、 set方法， 也可以通过自定义一个属性类或包装类来间接地给这个属性增加get和set方法。 如以下示例这种情况： 123456789101112131415private static class MyView&#123; private View mTarget; private MyView(View target)&#123; this.mTarget = target; &#125; public int getWidth()&#123; return mTarget.getLayoutParams().widht &#125; public void setWidth(int width)&#123; mTarget.getLayoutParams().width = width; mTarget.requestLayout(); &#125;&#125; 使用时只需要操作包类就可以调用get、 set方法了： 12MyView mMyView = new MyView(mButton);ObjectAnimator.ofInt(mMyView,\"width,500).setDuration(500).start() ValueAnimatorValueAnimator不提供任何动画效果， 它更像一个数值发生器， 用来产生有一定规律的数字， 从而让调用者控制动画的实现过程。 通常情况下， 在ValueAnimator的AnimatorUpdateListener中监听数值的变化， 从而完成动画的变换。 AnimatorSet略 在XML中使用属性动画12345678&lt;objectAnimator android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:duration=\"3000\" android:propertyName=\"scaleX\" android:valueFrom=\"1.0\" android:valueTo=\"2.0\" android:valueType=\"floatType\"/&gt; 在代码中引用xml属性动画也很简单： 123Animator animator = AnimatorInflater.loadAnimator(this,R.anim.scale);animator.setTarget(view);animator.start(); 解析Scroller略，去看源码，看不懂再来添加这块内容 View 事件分发机制这里了解Activity的构成就好了，如下图： 事件分发机制则看之前写的文章还容易理解一些，这里就略过了。 View的工作流程这一章太长，作为第二部分内容。","categories":[],"tags":[{"name":"读书笔记-Android进阶之光","slug":"读书笔记-Android进阶之光","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89/"}]},{"title":"常用的git命令","slug":"git常用用法","date":"2019-07-06T08:57:00.000Z","updated":"2019-07-06T08:58:53.925Z","comments":true,"path":"2019/07/06/git常用用法/","link":"","permalink":"https://glassx.gitee.io/2019/07/06/git%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95/","excerpt":"","text":"常用的git命令（摘抄自官网） 列显已有的标签列出现有标签的命令非常简单，直接运行 git tag 即可： $ git tagv0.1v1.3 我们可以用特定的搜索模式列出符合条件的标签。在 Git 自身项目仓库中，有着超过 240 个标签，如果你只对 1.4.2 系列的版本感兴趣，可以运行下面的命令： $ git tag -l ‘v1.4.2.*’v1.4.2.1v1.4.2.2v1.4.2.3v1.4.2.4 新建标签含附注的标签创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可： $ git tag -a v1.4 -m ‘my version 1.4’ 轻量级标签轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可： $ git tag v1.4-lw 分享标签默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可： $ git push origin v1.5 如果要一次推送所有本地新增的标签上去，可以使用 –tags 选项： $ git push origin –tags 删除分支删除本地分支删除本地分支可以使用一下命令： $ git branch -d testing 如果删除失败，需要强制删除可以使用 -D 选项强制删除它： $ git branch -D testing 删除远程分支 可以运行带有 –delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令： $ git push origin –delete serverfixTo https://github.com/schacon/simplegit [deleted] serverfix","categories":[],"tags":[{"name":"随时翻阅的工具","slug":"随时翻阅的工具","permalink":"https://glassx.gitee.io/tags/%E9%9A%8F%E6%97%B6%E7%BF%BB%E9%98%85%E7%9A%84%E5%B7%A5%E5%85%B7/"}]},{"title":"第3章——View的事件体系","slug":"Android 开发艺术探索-第3章","date":"2019-05-12T14:42:00.000Z","updated":"2019-05-12T14:42:25.778Z","comments":true,"path":"2019/05/12/Android 开发艺术探索-第3章/","link":"","permalink":"https://glassx.gitee.io/2019/05/12/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC3%E7%AB%A0/","excerpt":"","text":"View 基础知识1、 MotionEvent 和 TouchSlopMotionEvent这里只需要注意一点，通过MotionEvent 可以获得点击事件发生的x和y坐标，系统提供了两组方法，getX/getY 和 getRawX/getRawY ，他们的区别很简单，前者返回的是相对于当前View的左上角的 x 和 y 坐标，后者返回的是相对于手机屏幕左上角的 x和y 坐标。 TouchSlopTouchSlop 是系统所能识别出的被认为是滑动的最小距离，小于这个值就不认为是滑动操作。TouchSlop 是一个常量，和设备有关，在不同的设备上这个值可能是不同的。通过如下方式可以获取这个常量： ViewConfiguration.get(context).getScaledTouchSlop() 2、VelocityTracker、GestureDetector 和 ScrollerVelocityTracker用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。它的使用过程很简单，首先在 View 的 onTouchEvent 方法中追踪当前单击事件的速度： VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event); 接着，当我们想知道当前的滑动速度时，可以采用如下方法获得： velocityTracker.computeCurrentVelocity(1000);int xVelocity = (int)velocityTracker.getXVelocity();int yVelocity = (int)velocityTracker.getYVelocity(); 这里需要注意的是： 一、获取速度之前必须先计算速度；二、这里的速度是指一段时间内手指所划过的像素数，比如将时间间隔设置为 1000ms，在 1s 内水平从左至右滑过100像素，那么水平速度就是100 。如果将时间间隔设置为100ms，在这100ms 内滑过10像素，则水平速度会变成 10 。此外，这个速度是可以为负值的，当水平方向从右往左滑动时，水平方向的速度即为负值。 GestureDetector手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。比如要监听双击行为，代码如下： GestureDetector mGestureDetector = new GestureDetector(listener);//再加上这行可以解决长按屏幕后无法拖动的现象mGestureDetector.setIsLongpressEnabled(false); 接着，接管目标View的onTouchEvent方法，在待监听View的 onTouchEvent 方法中如下实现： boolean consume = mGestureDetector.onTouchEvent(event);return consume; OnGestureListener 与 OnDoubleTapListener 里面的方法有很多，常用的有：onSingleTapUp（单击）、onScroll（拖动）、onLongPress（长按）、onFling（快速滑动）、onScroll（拖动）、onDoubleTap（双击）。 Scroller弹性滑动对象，用于实现View的弹性滑动，我们知道，当使用View的scrollTo/scrollBy方法来进行滑动时，其过程是瞬间完成的，这时候就可以使用 Scroller 来实现有过渡效果的滑动，它需要和View的conputeScroll方法配合使用才能共同完成这个功能，典型的使用如下： 123456789101112131415161718Scroller mScroller = newScroller(context);//缓慢滑动到指定位置privte void smoothScrollTo(int destX,int destY)&#123; int scrollX = getScrollX(); int delta = destX - scrollX; //1000ms内滑向destX就是，效果就是慢慢滑动 mScroller.startScroll(scrollX,0,delta,0,1000); invalidate();&#125;@Overridepublic void computeScroll()&#123; if(mScroller.computeScrollOffset())&#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate() &#125;&#125; View 的滑动未完待续。。。","categories":[],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}]},{"title":"第2章——IPC机制","slug":"Android 开发艺术探索-第2章","date":"2019-05-11T14:40:00.000Z","updated":"2019-05-12T04:57:09.696Z","comments":true,"path":"2019/05/11/Android 开发艺术探索-第2章/","link":"","permalink":"https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/","excerpt":"","text":"提到IPC的使用场景就必须提到多进程，如果只有一个进程，又何必使用进程间通信。多进程的情况分为两种：第一种是应用本身需要采用多进程模式实现（比如通过多个进程来获取多份内存空间）；第二种是当前应用需要向其他应用获取数据，由于是两个应用，因此必须采用跨进程通信方式。 Android中的多进程模式我们不讨论两个应用之间的多进程情况。 1、开启多进程，Android中使用多进程有两种方法：第一种是给四大组件在AndroidManifest中指定 android:process 属性；第二种是非常规方式，通过JNI在native层去fork一个新的进程。第二种情况属于特殊情况，暂时不考虑。 2、多线程模式的运行机制如果用一句话形容多进程，那就是：“当应用开启了多进程以后，各种奇怪的现象都出现了”，开启多线程只需要给四大组件指定 android:process 属性，但是是否正常运行就是另外一回事了。看个例子： 有 MainActivity 和 SecondActivity，其中 SecondActivity 指定运行在一个新的进程中，并且项目还新建一个 UserManager 类，类中有个public 的静态变量： 123public class UserManager&#123; public static int sUserId = 1;&#125; 在 MainActivity 的 onCreate 中把 sUserId 的值改为2，打印sUserId，之后再启动 SecondActivity ，在 SecondActivity 中打印 sUserId 。 可以发现在 MainActivity 中打印的值是2，在 SecondActivity 中打印的值是 1 ，看到这里，大家应该明白了多进程带来的问题，绝非只是指定一个 android:process 这么简单。 分析：我们知道，Android 系统为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类的对象会产生多份副本。拿上面的例子来说，两个进程中都存在一个 UserManager 类，并且这两个类是互相不干扰的，在一个进程中修改 sUserId 的值只会影响当前进程，对其他进程不会造成任何影响。 通过以上可以知道，运行在不同进程中的四大组件，只要他们之间需要通过内存来共享数据，都会共享失败，这也是多进程所带来的主要影响。一般来说，使用多进程会造成如下几个方面的问题： 静态成员和单例模式完全失效 上面做了分析 线程同步机制完全失效 既然都不是一块内存了，那么不管是锁对象还是锁全局类都无法保证线程同步，因为不同进程锁的不是同一个对象 SharedPreference 的可靠性下降 是因为 SharedPreference 不支持两个进程同时去执行写操作，否则会导致可能的数据丢失（因其本质是通过读写xml文件来实现的） Application 会多次创建 这个问题是显而易见的，由于系统要在创建新的进程同时分配独立的虚拟机，所以这个过程其实就是启动一个应用的过程，因此相当于系统又把应用重新启动了一遍，自然就创建了新的Application。还可以这么理解，运行在同一个进程中的组件是属于同一个虚拟机和同一个Application的；同理，运行在不同进程中的组件是属于两个不同的虚拟机和Application。 IPC 基础概念介绍IPC 中的基础概念包括3方面内容： Serializable 接口、Parcelable接口、Binder。 1、Serializable 接口Serializable 是Java提供的一个空的序列化接口，为对象提标准的序列化和反序列化操作。使用 Serializable 实现序列化非常简单，只需要类实现 Serializable 接口，并且在类的声明中指定一个类似下面的标识： private static final long serialVersionUID = 12345L 实际上，这个 serialVersionUID 也不是必需的，因为serialVersionUID 的机制是这样的： 序列化时，系统会把当前类的 serialVersionUID 写入序列化的文件中；当反序列化的时候，会去检测文件中的 serialVersionUID 是否和当前类的 serialVersionUID 一致，如果一致说明序列化的类版本和当前类的版本是相同的，就可以成功反序列化；否则的话，说明当前类和序列化的类相比发生了某些变换，就无法正常反序列化。以下例子说明 Serializable 的使用： 1234567891011121314151617181920//序列化的类public class User implements Serializable&#123; private static final long serialVersionUID = 12345L; public int id; public String userName;&#125;/**********使用*****************///序列化User user = new User(12,\"tom\");ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"cache.txt\"));out.writeObject(user);out.close();//反序列化过程ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"cache.txt\"));User newUser = (User)in.readObject();in.close(); 另外，系统默认的序列化过程也是可以改变的，通过重写 writeObject 和 readObject 方法即可，只不过大部分情况下我们无需去重写这两个方法。 2、Parcelable 接口Parcelable 也是一个接口，只要实现这个接口，类的对象就可以实现序列化并通过 Intent 和 Binder 传递。 具体使用方法可以查看官方文档 既然 Parcelable 和 Serializable 都能实现序列化并且都可用于 Intent 间的数据传递，那如何取舍呢？Serializable 是Java中的序列化接口，序列化和反序列化需要大量I/O操作；而Parcelable 是 Android 中的序列化方式，主要用在内存序列化上，使用起来稍显麻烦，但是效率高，所以这是 Android 官方推荐的序列化方式。综上所述，将对象序列化存储到设备或者通过网络传输时使用 Serializable ，否则使用 Parcelable 。 3、BinderBinder 是 Android 中的一种 IPC 方式，还可以理解为一种虚拟的物理设备，它的设备驱动是 dev/binder。 Android 中的 IPC 方式使用Bundle由于Bundle 实现了 Parcelable 接口，所以它可以方便地再不同的进程间传输，基于这一点，当我们在一个进程中启动了另一个进程的 Activity、Service 和 Receiver，我们就可以在Bundle 中附加我们需要传给其他进程的信息，并通过Intent 发送出去，这是一种最简单的进程间通信方式。 使用文件共享共享文件是一种不错的进程间通讯方式，适合在对数据同步要求不高的进程间通信。当然，SharedPreferences 是个特例，由于系统对它的读写会有一定的缓存策略，即在内存中会有一份 SharedPreferences 文件的缓存，因此在多进程模式下，面对高并发的的读写会有很大几率丢失数据，因此不建议在进程间通信中使用 SharedPreferences。 使用 Messenger顾名思义可以翻译成信使，通过它可以在不同的进程中传递 Message 对象,它是轻量级的 IPC 方案，底层实现是 AIDL 。Messenger 只是一串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务端，服务端仍然只能一个个处理。具体可以参考官方文档 使用 AIDL由于 Messenger 服务端只能串行处理，所以可以使用 AIDL 来实现跨进程调用。具体内容可以参考官方文档 使用 ContentProvider这是Android 中提供的专门用于不同应用建进行数据共享的方式。 使用 SocketSocket 是网络通信中的概念，也称为“套接字”，它分为流式套接字和用户数据报套接字两种，分别对应于网络的传输控制层中的TCP和UDP协议。 选择合适的 IPC 方式 名称 优点 缺点 适用场景 Bundle 简单易用 只能传输Bundle支持的数据类型 四大组件之间的通信 文件共享 简单易用 不适合高并发 无并发，数据实时性要求不高 AIDL 功能强大，支持一对多，支持实时 使用复杂 一对多通信且有RPC需求 Messenger 一对多串行通信，支持实时 高并发困难，不支持RPC，只能传输Bundle支持的数据 低并发的一对多通信 ContentProvider 数据源访问功能强大 理解为受约束的AIDL，主要提供数据源的 CRUD 操作 一对多的进程间数据共享 Socket 支持一对多并发实时通信，支持字节流 实现繁琐 网络数据交换","categories":[],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}]},{"title":"第1章——Activity 生命周期和启动模式","slug":"Android 开发艺术探索-第1章","date":"2019-05-11T07:42:00.000Z","updated":"2019-05-11T14:41:51.693Z","comments":true,"path":"2019/05/11/Android 开发艺术探索-第1章/","link":"","permalink":"https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC1%E7%AB%A0/","excerpt":"","text":"Activity 的生命周期全面分析本节将分为两部分内容，一部分是典型情况下的生命周期，一部分是异常情况下的生命周期（比如被系统回收或者由于当前设备Configuration 发生改变而导致 Activity 被销毁重建）。 一、典型情况下的生命周期分析正常情况下，Activity 会经历如下生命周期： onCreate ： 表示Activity 正在创建，这是生命周期第一个方法。 onRestart ： 表示Activity 正在重新启动。一般情况下，当前Activity 从不可见重新变为可见时，onRestart 就会被调用。 onStart ： 表示Activity 正在被启动，这时候 Activity 已经可见了，但是还没出现在前台，无法和用户交互。可以理解为 Activity 已经显示出来了，但是我们还看不到。 onResume ： 表示 Activity 已经可见了，并且出现在前台可以交互。 onPause： 表示 Activity 正在停止，正常情况下，紧接着 onStop 会被调用；在特殊情况下，如果这个时候快速地再回到当前 Activity ，那么 onResume 将会被调用。此时可以做一些存储数据、停止动画等工作，但是注意不能太耗时，因为onPause必须先执行完，新Acitivty 的 onResume 才会执行。 onStop ： 表示 Activity 即将停止，可以做一些稍微重量级的回收工作，同样不能太耗时。 onDestroy： 表示 Activity 即将被销毁，这是Activity 生命周期中的最后一个回调，我们可以做一些回收工作和最终的资源释放。 以下再针对 Activity 的生命周期具体说明： 针对特定的Activity，第一次启动回调如下： onCreate-&gt;onStart-&gt;onResume 打开新的Activity 或者(按Home键)回到桌面的时候，回调 onPause-&gt;onStop ；这里有种特殊情况，打开的新Activity 如果是透明主题（意味着当前Activity还是可见的），那么当前Activity 不会回调 onStop 。 当用于再次回到原来的 Activity 时，回调 onRestart-&gt;onStart-&gt;onResume 当用户按返回键返回上一个页面时，回调 onPause-&gt;onStop-&gt;onDestroy 从整个生命周期来看，onCreate与onDestroy是配对的，分别标识着Activity的创建与销毁；onStart与onStop是配对的，标识着Activity是否可见；onResume 与 onPause 是配对的，标识着Activity是否在前台。 一个问题：当前 Activity 标识为 A，启动一个新的Activity 标识为 B，那么B的onResume 和 A 的onPause 哪个先执行？ 由上面的描述可知是限制性A的 onPause，再执行 B 的onResume ，具体看源码，官方文档也是这么解释(Always followed by onPause())。 二、异常情况下的生命周期分析1、资源相关的系统配置发生改变导致Activity被杀死并重建如果没有做特殊处理，当横竖屏切换的时候，由于系统配置发生了改变，Activity 会加载不同的资源（比如横竖屏加载两张不同图片），此时 Activity 会被销毁并且重新创建。由于 Acitivity 是在异常情况下终止的，因此在销毁Activity的时候，确切来说是在onStop之前（但是跟onPause没有顺序关系，有可能在其之前，也可能在其之后）会调用 onSaveInstanceState 来保存当前 Activity 状态； Activity 被重新创建后，会把销毁时 onSaveInstanceState 方法保存的Bundle对象作为参数传给 onCreate 方法和 onRestoreInstanceState 方法，因此可以从这两个方法恢复之前保存的数据。从时序上来说，onRestoreInstanceState 调用时机在 onStart 之后。 这两个方法恢复数据的区别是：onRestoreInstanceState 一旦被调用，其参数 savedInstanceState 是一定有值的，我们不需要额外地判空；而 onCreate 中的数据是可能为空的，官方文档建议采用 onRestoreInstanceState 去恢复数据。 如果没有覆写的话，onSaveInstanceState 和 onRestoreInstanceState 方法中，系统会自动为我们做一定的恢复工作。 2、资源内存不足导致低优先级Activity被杀死Activity 按照优先级从高到低可以分为如下三种： （1）前台Activity——正在和用户交互的Activity，优先级最高（2）可见但非前台Activity——比如Activity中弹出了dialog，导致Activity可见但是位于后台无法和用户直接交互。（3）后台Activity——已经被暂停的的Activity，优先级最低。 我们知道，当系统配置发生改变时，Activity 会被销毁并重新创建，当然我们也可以通过给 Activity 指定configChanges 属性来阻止销毁重建： android:configChanges=”orientation” 当然这个属性可以配置的项目还有很多，比如切换系统语言、使用了新字号、界面模式改变（比如 是否开启/关闭夜间模式）。 Activity 的启动模式 standard： 标准模式。不复用，每次请求都创建新实例，并且就运行在启动它的那个Activity所在的栈。 singleTop： 栈顶复用模式 。如果实例位于任务栈的栈顶就复用，复用时调用 onNewIntent方法，否则就创建新的实例。 singleTask： 栈内复用模式。当前栈内没有实例，则创建实例放入栈中；如果实例在当前栈内，则复用，复用时调用 onNewIntent方法，并把它之上的Activity出栈。 singleInstance： 单例模式。只能单独位于一个任务栈中，只要这个实例存在，后续的请求均不会创建新的Activity。复用时调用 onNewIntent方法。 在使用 ApplicationContext 启动standard 模式的Activity时会报错： Callking startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag 这是因为standard模式的Activity 默认会进入启动它的Activity所属的任务栈中，由于非Activity类型的Context 没有所谓的任务栈，所以会报错。解决这个问题的方法是为待启动的Activity指定 FLAG_ACTIVITY_NEW_TASK 标记，这样启动的时候会为它创建一个新的任务栈（体会下，这时候实际上是以singleTask模式启动的） Activity 的FlagsActivity 的Flags很多，这里分析比较常用的几个: FLAG_ ACTIVITY_ NEW_ TASK 为Activity 指定singleTask启动模式，其效果和在XML中指定 singleTask 启动模式相同 FLAG_ ACTIVITY_ SINGLE_ TOP 为Activity 指定 singleTop 启动模式，其效果和在XML中指定 singleTop 启动模式相同 FLAG_ ACTIVITY_ CLEAR_ TOP 具有此标记的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈，这个标记为一般会和FLAG_ACTIVITY_SINGLE_TOP标记位一起出现。由前面的分析可知，singleTask启动模式默认具有此标记位效果。 FLAG_ ACTIVITY_ EXCLUDE_ FROM_ RECENTS 具有这个标记位的Activity不会出现在历史Activity列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候，这个标记比较有用。这个标记等同于xml中指定Activity 的属性 android:excludeFromRecents = “true” IntentFilter 的匹配规则略","categories":[],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}]},{"title":"第3章：垃圾收集器与内存分配策略","slug":"深入理解Java虚拟机-第3章","date":"2019-04-03T13:10:00.000Z","updated":"2019-05-01T16:16:40.243Z","comments":true,"path":"2019/04/03/深入理解Java虚拟机-第3章/","link":"","permalink":"https://glassx.gitee.io/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/","excerpt":"","text":"对象已死吗引用计数法很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。客观地说，引用计数法的实现简单，但它很难解决对象之间相互循环引用的问题，所以，主流实现中，并不使用这种方式。 可达性分析在主流实现中，都是通过可达性分析来判定对象是否存活。这个算法的基本思路就是通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到GC Roots 没有任何引用链相连时，则证明此对象是不可用的。在Java语言中，可以作为 GC Roots 的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象。 本地方法栈中JNI引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 再谈引用JDK 1.2 以前，对象只有引用和被引用两种状态，未能描述那些“食之无味，弃之可惜”的对象，我们希望描述这样一类对象：当内存还足够时，则能保留在内存之中；如果内存空间在GC后还是非常紧张，则可以抛弃这些对象。因此，JDK 1.2以后对引用的概念进行扩充，分为： 强引用。代码中普遍存在的，类似于 Object obj = new Object() ，只要强引用还在，垃圾收集器永远不会回收被引用的对象。 软引用。是用来描述一些还有用，但是并非必需的对象，在系统将要发生内存溢出的异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。 弱引用。是用来描述非必需对象的，但是强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次GC发生之前。当GC工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 虚引用。是最弱的一种引用关系，不会对对象的生存时间构成影响，也无法通过虚引用获得对象实例。为对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 生存还是死亡即使在可达性分析算法中不可达的对象，也并非“非死不可”的。要真正宣告一个对象的死亡，至少要经历两次标记过程：如果对象在可达性分析后发现没有与GC Roots 相连接的引用链，那么它会被第一次标记，并进行筛选，筛选的条件是此对象是否有必要执行 finalize() 方法，当对象没有覆写 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则都没有必要执行； 如果对象判定有必要执行 finalize() 方法，则对象会被放入F-Queue队列中，稍后由低优先级的线程去触发 执行finalize() 方法，但不会承诺等待它运行结束。这样做的原因是防止 finalize 方法过于缓慢或者死循环。finalize() 方法是对象套多死亡命运的最后一次机会，因为稍后GC将对F-Queue中的对象进行第二次标记，如果对象要在finalize 中拯救自己————只要重新与某个引用链上的任意一个对象关联即可，那么在第二次标记的时候它将被移除出“即将回收”的集合；如果这时候对象还没逃脱，那它就会真的被回收了。 说明这一过程的示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142public class FinalizeEscapeGC&#123; public static FinalizeEscapeGC SAVE_HOOK = null; public void isAlive()&#123; System.out.println(\"yes,i am still alive\"); &#125; @Override protected void finalize（） throws Throwable&#123; super.finalize(); System.out.println(\"finalize method executed\"); FinalizeEscapeGc. SAVE_HOOK = this; &#125; public static void main(String[] args) throws Throwable&#123; SAVE_HOOK = new FinalizeEscapeGC(); //对象第一次成功拯救自己 SAVE_HOOK = null; System.gc(); //因为finalize方法优先级很低，所以暂停0.5秒等待它 Thread.sleep(500); if(SAVE_HOOK != null)&#123; SAVE_HOOK.isAlive(); &#125;else&#123; System.out.println(\"no,i am dead\"); &#125; //下面这段代码与上面的完全相同，但是这次自救却失败了 SAVE_HOOK = null; System.gc(); //因为finalize方法优先级很低，所以暂停0.5秒等待它 Thread.sleep(500); if(SAVE_HOOK != null)&#123; SAVE_HOOK.isAlive(); &#125;else&#123; System.out.println(\"no,i am dead\"); &#125; &#125;&#125; 运行结果： finalize method executedyes,i am still aliveno,i am dead 从结果可以看出，SAVE_HOOK 对象的 finalize 方法确实被GC收集器触发过，并且收集前成功逃脱。但两段完全一样的代码，第二次却被回收了，因为finalize 方法只会被自动调用一次，因此第二次不执行了，所以自救失败。 有些教材上认为 finalize 中适合做“关闭外部资源”之类的工作，在了解以上机制之后，可以认为这完全是一种自我安慰，finalize 能做的，try-finally 或其他方法能做得更好，更及时，所以完全可以忘记这个方法存在（它也仅仅只是Java诞生时讨好C/C++程序员的一个妥协）。 垃圾收集算法标记-清除算法最基础的收集算法是 标记-清除(Mark-Sweep) 算法，它分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，在标记完成后统一回收被标记的对象。它的主要不足有两个：一是效率问题，标记和清除效率都不高；二是清除后会产生大量不连续的内存碎片。 复制算法为了解决效率问题，复制算法出现了。它将可用内存分为大小相等的两块，每次只使用其中一块，当这块内存用完了，就将还存活的对象复制到另一块上，然后把当前内存空间一次清理掉。这样每次都是对整个半区回收，内存分配也不会存在碎片。缺点是可用内存缩小了一半，代价太高。 现在商业虚拟机采用这种方式回收新生代。一般将内存分为较大的 Eden 和两块较小的 Survivor 空间（HotSpot中 Eden 与 Survivor大小比例为 8：1），每次使用Eden 和其中一块 Survivor，当内存回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor，最后清理Eden和刚才用过的Survivor空间，因此，每次只有10%的内存“被浪费”。当然这是基于统计新生代的对象生命周期都很短，差不多只有10%的对象会存活，此外，如果超出10%的存活对象，Survivor空间不够时，需要依赖老年代的空间提供担保（Survivor空间存不下的对象直接通过担保机制进入老年代），这是该分配方式能够运行下去的保障。 复制收集算法在对象存活率较高时要进行较多的复制操作，效率将会变低，更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行担保，防止对象100%存活的极端情况。 标记-整理算法根据老年代特点，有人提出另外一种标记-整理(Mark-Compact)算法，标记过程仍与“标记-清除”算法一样，但后续不是直接清理可回收对象，而是所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。标记整理算法的示意图如下： 关于怎么个移动法，书上没有说明，这里个人做个推测： 1、整个老年代的内存划分为 A 和 B 两个区域，区域 A 的大小是所有还存活对象的总大小，区域 B 大小是是剩余空间。2、按顺序在 A 中找到第一个还存活对象，将它移动到 A 空间的最前端，接下来找第二个还存活的对象，将其移动到第一个对象的后面3、以此类推，即使存活的对象在 B 中也一样顺序复制到A中，直至最后填满A空间，之后清除 B 空间。 分代收集算法商业虚拟机都采用“分代收集”，根据各个年代的特点分别采用适当的收集算法： 在新生代中，每次垃圾收集时都会发现有大批对象死去，只有少量存活（前面提到的统计数据，大部分时候只有 10% 存活），那就选用复制算法。 而老年代中因对象存活率高，没有额外空间对它进行担保，就必须使用“标记-清理”或者“标记-整理”算法进行回收。 CMS 收集器这是自己添加的这个标题，书中的结构并不是如此，因为 Android ART 虚拟机使用的也是CMS收集方式，所以这里特意抽出来理解，方便理解Android的虚拟机。 CMS (Concurrent Mark Sweep) 收集器，并发的“标记-清除”方式实现的收集器。它是一种以获取最短回收停顿时间为目标的收集器。它的整个过程分为4个步骤： 初始标记 并发标记 重新标记 并发清除 其中，初始标记、重新标记 这两个步骤仍然需要“Stop The World”，初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快；并发标记就是进行 GC Roots Tracing 的过程（根据初始标记过程中标识出来的直接关联对象，并发标记存活的对象）；重新标记阶段则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录； 由于整个过程中好事最长的 并发标记 和 并发清除 过程收集器线程都可以与用户线程一起工作，所以，从总体上来讲，CMS收集器的内存回收过程是与用户线程一起并发执行的。 CMS 是优秀的收集器，但是它也有3个明显的缺点： CMS 收集器对 CPU 资源非常敏感。与其他并发设计的程序一样，CMS收集器对 CPU 同样敏感，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用变慢。 CMS 无法处理浮动垃圾(Floating Garbage,个人认为简而言之就是GC过程中用户线程产生的垃圾，类比于你妈妈在打扫房间卫生的时候，你还在继续撕的纸)。 还有最后一个缺点，就是CMS本质还是“标记-清除”算法实现的，这种收集方式在结束后会产生大量的碎片化的空间。 内存分配与回收策略以下是几条最普遍的内存分配规则，可以通过代码去验证这些规则： 对象优先在 Eden 上分配大多数情况下，对象在新生代 Eden 区中分配，当 Eden 区没有足够空间时，虚拟机将发起一次 Minor GC （新生代GC）。可以采用以下方式验证： 通过 -Xms20M、-Xmx20M、-Xmn10M 三个参数限制Java 虚拟机堆大小 20MB，不可扩展，并且其中 10M 分配给新生代，剩下的 10MB 分配给老年代，-XX:SurvivorRatio=8决定新生代中 Edun 区与 一个 Survivor区的比例是 8：1，即 Eden 大小 8192K，两个 survivor 空间分别 1024K，所以新生代总共可用空间是 9216K （Eden 区 + 1个Survivor区）。执行 testAllocation()尝试分配 3个 2M 的大小和1个 4MB 大小的对象。代码执行完成后，可以发现 新生代Eden区被占用了 4M，而老年代被占用了 6M。解释：分配前3个对象时，没有压力，均分配在Eden区域，当分配第4个对象时，内存已经不够了（可用空间是 9216K，而 2M*3 + 4M = 10），因此触发一次Minor GC，此时发现这3个对象都存活，并且 survivor 区间不够容纳存活的对象，因此这3个对象被直接通过担保机制提前转移到老年代中；这次GC结束后，第4个对象就可以顺利分配到Eden空间中。 新生代GC(Minor GC):发生在新生代的垃圾收集，因为Java对象大多朝生夕死，所以Minor GC非常频繁，一般回收速度也比较快老年代GC(Major GC/Full GC)：指的是老年代的GC，对于许多收集器而言，这时候都会伴随至少一次的 Minor GC，老年代的GC一般会比 Minor GC 慢10倍以上。 大对象直接进入老年代所谓大对象是指需要大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组。当然，比大对象更糟糕的是遇到一群朝生夕死的“短命大对象”，这种应当避免。经常出现大对象容易导致内存还有不少空间就提前触发垃圾收集器以获得足够的连续空间来安置它们。 长期存活的对象进入老年代如果对象在Eden出生并经历过第一次Minor GC 后仍然存活并且能被 Survivor 容纳的话，将被移动到Survivor 中，并且年龄设置为 1，此后，每熬过一次 Minor GC ，对象的年龄就加1，当达到某个阈值（系统一般默认 15），就会被晋升到老年代中。 动态对象年龄判定为了更好地适应不同程序内存状况，并不总是要求对象必须达到某个年龄才进入老年代。如果 Survivor 中同龄对象达到某个阈值（一般是一半）时，大于或者等于这个年龄的对象就会移动到老年代。 空间分配担保发生Minor GC 前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，则 Minor GC 可以确保是安全的，如果不成立，则会判断是否允许担保失败，如果允许担保失败，则最终可能会触发一次Full GC。虽然绕了一圈还是有可能触发 Full GC，但是这种情况相对较少。","categories":[],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"第2章：Java内存区域与内存溢出异常","slug":"深入理解Java虚拟机-第2章","date":"2019-04-02T13:10:00.000Z","updated":"2019-05-01T16:07:17.221Z","comments":true,"path":"2019/04/02/深入理解Java虚拟机-第2章/","link":"","permalink":"https://glassx.gitee.io/2019/04/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0/","excerpt":"","text":"运行时数据区域根据《Java虚拟机规范(java SE 7)》规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域： 程序计数器程序计数器可以看做是当前线程执行的字节码的行号指示器，它是线程私有的。在虚拟机概念模型里（具体虚拟机可能有更高效实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖程序计数器来完成。如果线程在执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行Native方法，这个计数器值为Undefined。此内存区域是Java虚拟机规范中唯一一个没有规定任何 OutOfMemoryError情况的区域。 Java虚拟机栈Java虚拟机栈也是线程私有的。它描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，一个方法从调用至完成，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。这个区域被规定了两种异常状况：如果线程请求的栈深度大于虚拟机允许的深度，就抛出 StackOverflowError异常；如果该区域可以动态扩展，则在扩展时无法申请到足够内存，就会抛出OutOfMemoryError异常。 本地方法栈本地方法栈与虚拟机栈类似，区别只不过是虚拟机栈为执行Java方法(即字节码)服务，而本地方法栈为Native方法服务，同样，本地方法栈也可能抛出StackOverflowError异常以及OutOfMemoryError异常. Java堆Java堆是被所有线程共享的一块内存，虚拟机启动时创建。虚拟机规范描述是，所有对象的实例以及数组都要在堆上分配(当然，不同虚拟机实现不同)。如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区与Java堆一样，方法区也是各个线程共享的内存区域。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常。 提到方法区，不得不提运行时常量池，它是方法区的一个部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是信息常量池，用于存放编译期生成的各种字面量和符号引用（一般来说，翻译出来的直接引用也会存储在运行时常量池中）。 直接内存直接内存(Direct Memory)不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在Java 1.4中新加入了NIO（New Input/Output）类，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectBuffer对象作为这块内存额引用进行操作，这样能在一些场景中显著提高性能，因为它避免在 Java 堆和 Native 堆中来回复制数据。当然，该区域空间在动态扩展时也可能出现OutOfMemoryError异常。 HotSpot 虚拟机对象探秘对象的创建虚拟机遇到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，则必须限制性相应的类加载过程。类加载完成后，便可完全确定对象所需的内存大小，接下来为新生的对象真正分配内存。 对象的内存布局对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)、和对齐填充(Padding)。 对象的访问定位建立对象是为了使用对象，我们的Java程序需要通过栈上的refrence数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针，其中前者通过句柄池间接指向堆中的对象，后者直接指向堆中的对象。 实战OutOfMemoryError异常Java虚拟机规范中，除了程序计数器之外，其他区域都可能发生 OutOfMemoryError异常。 JAVA堆溢出Java堆用于存储实例对象，只要不断地创建对象，并且保证GC root 到对象之间有可达路径来避免垃圾回收，那么就能产生OutOfMemoryError异常。 虚拟机栈和本地方法栈溢出虚拟机栈和本地方法栈理论上分配不到足够的内存同样会报 OutOfMemoryError异常，但是一般情况下，首先会出现StackOverflowError，OutOfMemoryError很难出现。 方法区和运行时常量池溢出由于运行时常量池是方法区的一个部分，因此这两个区域的溢出测试放在一起进行。在此之前我们先了解下String.intern()方法： String.intern()是一个Native方法，它的作用是，如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并返回此String对象的引用。 在JDK1.6及以前，通过设置永久代区域的大小可以间接限制方法区大小，但是从JDK 1.7以后就“去永久代”了，因此以下代码只在JDK 1.6 ，并且设置了 MaxPermSize 时有效： 12345678public static void main(String[] args)&#123; //使用List保持常量池的引用，避免full gc 回收常量池 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); int i = 0; while(true)&#123; list.add(String.valueOf(i++).intern()); &#125;&#125; 同样的原因，还可以引申一个更有意思的影响，如下代码： 1234567public static void main(String[] args)&#123; String str1 = new StringBuilder(\"计算机\").append（“软件”）.toString(); Systemt.out.println(str1.intern() == str1); String str2 = new StringBuilder(\"ja\").append(\"va\").toString(); Systemt.out.println(str2.intern() == str2);&#125; 这段代码在JDK 1.6 中运行，会得到两个false（intern 方法会把首次遇到的字符串实例复制到永久代中，而StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用）；而在JDK 1.7 中会得到一个true（intern 实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此，intern返回的引用和由StringBuilder创建的字符串实例是同一个实例）一个false（“java”字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现，而“计算机软件”这个字符串则是首次出现的—这个解释没看懂，需要再次理解）。 本机直接内存溢出直接或者间接地使用NIO，就可能出现本机直接内存溢出。虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但是抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配。因此可以通过以下代码手动抛出异常，真正抛出异常的地方是unsafe.allocateMemory()。 1234567891011//以下代码能够抛出异常的前提是，设置虚拟机参数 -XX: MaxDirectMemorySize 的值private static final int _1MB = 1024 * 1024;public static void main(String[] args) throws Exception&#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true)&#123; unsafe.allocateMemory(_1MB); &#125;&#125;","categories":[],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"Android 架构设计之AAC","slug":"Android 架构设计之AAC","date":"2019-03-10T14:00:00.000Z","updated":"2019-05-01T09:46:21.769Z","comments":true,"path":"2019/03/10/Android 架构设计之AAC/","link":"","permalink":"https://glassx.gitee.io/2019/03/10/Android%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8BAAC/","excerpt":"","text":"照例先上官方描述 官方提供的应用架构指南","categories":[],"tags":[{"name":"专题","slug":"专题","permalink":"https://glassx.gitee.io/tags/%E4%B8%93%E9%A2%98/"}]},{"title":"第4章：操作系统基础","slug":"深入理解Android内核设计思想-第4章","date":"2019-03-09T13:10:00.000Z","updated":"2019-05-02T14:08:41.131Z","comments":true,"path":"2019/03/09/深入理解Android内核设计思想-第4章/","link":"","permalink":"https://glassx.gitee.io/2019/03/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC4%E7%AB%A0/","excerpt":"","text":"进程间通信的经典实现共享内存共享内存的工作流程： 创建共享区。进程1从内存中申请一块内存作为共享区域，并且将该区域与某个Key绑定 映射共享区。创建共享区之后，需要将其映射到进程1的空间中才能操作。 访问共享区。进程2利用第一步得到的Key，访问到共享区，之后将这块内存映射到进程2的空间中。 进程间通信。各进程实现了对共享内存的映射后，便可以利用该区域进行信息交换。（注意：整个内存过程都没有实现同步机制，需要进程间自己实现） 管道 进程A和B分立管道两端，进行数据传输通信 管道是单向的，如果进程既要“读”也要“写”，就需要两根管道这点很像水管的特性 管道同时具有“读取”(read end)端和“写入”(write end)端，比如进程A从 write end 写入，进程 B 就可以从 read end 端读取到数据 管道容量有限制，当pipe满了后，写操作将阻塞；反之，pipe空了之后，读操作将会阻塞 普通的管道是匿名的，这种匿名的管道只适合有斧子关系的进程通信，如果要实现没有任何关系的管道间的通信，就需要命名管道(Named pipe) UNIX DOMAIN SOCKET 简称UDS,也可以说是IPC Socket，与普通的Socket不一样，专门针对单机进程间通信提出来的。 大家熟知的 Network Socket 是以 TCP/IP 协议栈作为基础的，需要分包、重组 等一系列操作，而 UDS 因为是本机内的“安全可靠操作”，实现机制上并不依赖于这些协议。 Android 中使用最多的一种IPC就是Binder，其次就是 UDS 。 RPC（REMOTE PROCEDURE CALLS）RPC 涉及通信双方通常运行于两台不同的机器中。 同步机制的经典实现###信号量（SEMAPHORE） 信号量与PV原语是分不开的，也是最为广泛的互斥方法之一，主要包括以下几个元素： Semaphore S（信号量，用于指示共享资源的可用数量） Operation P （可以减小S计数） Operation V （可以增加S计数） P执行：S = S -1，此时判断若 S&gt;=0 ，说明资源此时允许访问，开始操作共享资源；否则，加入等待队列，待别人释放资源后唤醒。V执行：S=S+1，如果此时S&gt;0，说明当前没有希望访问资源的等待者；否则，唤醒等待队列中的相关对象。其中，PV源于都属于原子操作，意味着他们执行过程是不允许被中断的。 互斥体（MUTEX）Mutex 是 Mutual Exclusion 的缩写，释义为 互斥体。如果资源允许多个对象同时访问，成为 Counting Semaphores；而如果只允许取值0或1（lock/unlocked）的Semaphore，则叫做 Binary Semaphore。Binary Semaphore 与Mutex有相同性质，Mutex通常是对某一排他资源的共享控制——要么这个资源被占用（locked），要么是可以访问的（unlocked）。 管程（MONITOR）针对信号量机制的程序易读性较差，并且信号量管理分散在各个参与对象中，很难维护等缺点，管程被提出来了。管程是可以被多个进程/线程安全访问的对象或者模块，管程中的方法在同一时刻只允许一个范文这使用它们（方法受 mutual exclusion 保护的）。 操作系统内存基础操作系统中任何操作都与内存息息相关，内存管理的底层原理主要注意几个核心： 虚拟内存 内存总是“不够大”的，随着应用的增加，总会填满，虚拟内存为运行更多的程序提供了可能，其基本思想是：1.将硬盘上一部分空间作为内存的扩展；2.出现资源不足时，按照一定算法挑出优先级较低的数据块移动到第1步划出的空间；3.需要用到硬盘中的数据块时，系统将产生“缺页”，之后把硬盘中的数据交换回内存中。 内存分配与回收 分配、native层回收，java层回收 内存保护 内存分页或者分段式管理。进程的逻辑地址不是直接对应物理地址的，因此没办法访问它范围外的内存空间。 顺带一提，mmap函数（Memory Map）正如其名，可以将某个设备或者文件映射到应用进程的内存空间中，这样访问这块内存就相当于对设备/文件进行读写；可见，理论上mmap可以用于进程间通信，即通过映射同一块物理内存来共享内存，这种方式因为减少了复制次数，在一定程度上提高了进程间通信效率。 Android 匿名共享内存（Ashmem）Ashmem 全称 Anony Shared Memory，是Android 特有的内存共享机制，它可以将指定的物理内存分别映射到各个进程的地址空间，从而便捷地实现进程间的内存共享。Ashmem 是一个 misc 设备，其实现依托于 /dev/ashmem 。","categories":[],"tags":[{"name":"深入理解Android内核设计思想-林学森","slug":"深入理解Android内核设计思想-林学森","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E6%9E%97%E5%AD%A6%E6%A3%AE/"}]},{"title":"针对简历的问题","slug":"针对简历的问题","date":"2019-03-08T13:10:00.000Z","updated":"2019-05-01T15:50:02.195Z","comments":true,"path":"2019/03/08/针对简历的问题/","link":"","permalink":"https://glassx.gitee.io/2019/03/08/%E9%92%88%E5%AF%B9%E7%AE%80%E5%8E%86%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"1、了解哪些设计模式？写个单例模式？ 单例建造者模式工厂模式适配器模式装饰模式观察者模式 12345678910111213141516171819202122//线程安全的单例模式代码public class Singleton&#123; //注意 volatitle 关键字 private static volatitle Singleton instance = null; //构造函数私有 private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if (instance == null)&#123; synchronized(Singleton.class)&#123; if (instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 2、安全隐患 okhttp ssl校验native层keystore校验本地广播LeakCanary防止内存泄漏SharedPreference加密allowBackUp = false某些key生成在native代码中做 3、怎么DNS加速？怎么防止劫持？ 114、119 获取ip，而不是用host直接访问，避免后续的dns请求，节省时间114、119 防止运营商流氓接管webview的网络请求，同上 5、怎样结构重构？ 确定rxjava+fresco+okhttp 结构引入MVP模式kotlin语言 6、bug率下降怎么做到的？ 合并代码前检查重要功能过代码，作者讲思路，看代码TalkingData Bug线上监测减少内存使用图片url后面带上图片尺寸 7、如何稳定性？流畅性？如何页面秒开？对App进行优化吗？从哪些方面优化？ 进入App的流畅性：提前加载数据，提前绘制完成后进入，但在flash页面会卡顿布局优化：基本上要求使用 ConstranLayout，减少布局层次排除App中使用的容器，尽量使用SpaseArray、ArrayMaploadCache 使用异步 8、如何文档归档 使用wikiwiki内容 包括后端接口，包括前端支持的协议以及支持的格式其他部门只需要看wiki就行，不用问技术人员 10、举例技术推进项目精进 推动使用Fresco推动使用RxJava做过两次性能优化引入TalkingData监测App开发者模式建议图片请求带上尺寸推动使用ConstranLayout 11、提出什么产品建议？ 大神推单彩种排列方案（周边带阴影的） 12、MVP怎么改进 Presenter 中再额外分出来一层，与业务无关的层次，比如登录页面的更新用户数据的操作 14、开发者选项有啥？ 启用哪个webview是否对网络请求校验","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"内存泄漏","slug":"内存泄漏","date":"2019-03-07T14:00:00.000Z","updated":"2019-05-01T09:43:16.777Z","comments":true,"path":"2019/03/07/内存泄漏/","link":"","permalink":"https://glassx.gitee.io/2019/03/07/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/","excerpt":"","text":"常见内存泄漏场景： 资源性对象未关闭 如 File、Cursor、stream等资源，他们的缓存不只存在java虚拟机内，还存在虚拟机外，仅仅把对象置为null而不关闭，就会引起内存泄漏 注册对象未注销 观察者模式的注册，在不使用的时候未注销，就会导致，如在Activity中监听电话服务，定义PhoneStateListener注册到TelphoneManager服务中，如果忘记注销，会导致Activity无法被Gc回收。 非静态内部类创建静态实例 Handler造成的内存泄漏。 非静态Handler默认持有外部Activity的引用，退出Activity时，如果Looper中还有Message，就会导致Activity无法回收，可以（1）将Handler设置为静态，并且弱引用持有的对象 （2）Activity 的onDestroy的时候，一处消息队列的消息 来解决内存泄漏。 容器中的对象没有清理 容器里的对象在不需要的时候，要及时移除，使其正确及时地被回收。 优化内存空间总体来说即是开源节流 开源 large heap 对象引用入手 强引用、软引用、弱引用。 减少不必要的装箱机制 sparseArray，类似的还有 SparseLongArray，LongSpaseArray等。 使用最优数据类型 （1）需要限制输入参数的时候，使用注解而不是枚举 （2）谨慎选择 HashMap 、ArrayMap 以及 SparseArray。 顺带一提UI绘制优化 减少布局层级 （1） 合理使用 merge （2）合理使用 ConstranLayout 提高显示速度 使用 viewstub 延后显示。 减少wrap_content 尽量使用match_parent 或者 确定的宽高度 避免过度绘制 （1）移除布局中非必须的背景 （2）可能的话，移除window的默认背景 （3）自定义view，要注意重叠部分，可以通过canvas.clipRect()帮助系统识别可见的区域，减少过度绘制","categories":[],"tags":[{"name":"专题","slug":"专题","permalink":"https://glassx.gitee.io/tags/%E4%B8%93%E9%A2%98/"}]},{"title":"可能的面试题","slug":"可能的面试题","date":"2019-03-06T13:10:00.000Z","updated":"2019-05-01T15:45:56.964Z","comments":true,"path":"2019/03/06/可能的面试题/","link":"","permalink":"https://glassx.gitee.io/2019/03/06/%E5%8F%AF%E8%83%BD%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"1、简述Android事件分发机制 之前写过专题，直接参考这里 2、TCP/IP 三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）3次握手的示意图如下： 三次握手过程：TCP发起的一方A，由操作系统生成一个序列号 n，以这个n为原点，对自己每个将要发送的数据进行编号，连接的另一方 B 会对A每次发送的数据进行确认，如果A收到B的确认编号2001，则可以认为 n~2000编号已经全部到达B。 所以我们可以说，TCP连接的是啥，就是告知双方数据原点的序列号，并且这可以确认双方的收发功能正常：第一次握手告知原始序列号，服务端确认client具有发送功能，第二次握手可以确定server具有正常的收发功能，第三次握手可以确认client具有正常收发功能，所以 一定要3次，少了哪次都不行。 4次挥手示意图： 由上图看出，由client端发起挥手，server给client的2次回复中，一次是确认信息ack，一次是数据的传送，那可不可以只要3次挥手呢？答案是可能的，TCP是全双工的，Client在没有数据需要发送给Server后，就发送FIN告知server，然后终止对server发送消息，但这个时候server还以发送数据给client，这时候需要4次；但是如果server收到client的FIN后再也没有数据要发给client了，那么 对client的ack包和server自己的FIN包就能合并成一个包发送过去，四次挥手变成3次。 了解完挥手完成后，可能还想更深入了解 TIME_WAIT，可以查看之前写的这篇。 3、IP地址分类（A/B/C/D类） IP地址由四段组成，每个字段是一个字节，即4个字节、 每个字节有8位，最大值是255，IP地址 = 网络号+主机号。分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用。 由图可知： A类：前1个字节(8位)为网络号，后3个字节(24位)为主机号。A类第1位必须是0B类：前2个字节(16位)为网络号，后2个字节(16位)为主机号。B类前两位固定为10C类：前3个字节(24位)为网络号，后1个字节(8位)为主机号。C类前3位固定为110D类： 是多播地址，一般用于多路广播用户。该类IP地址的最前面为1110E类： 是保留地址。该类IP地址的最前面为1111 4、TCP与UDP区别 1、UDP发送数据前无需简历连接，TCP需要握手建立连接。2、UDP不保证可靠交付，只尽最大努力交付；TCP提供可靠交付。3、UDP面向保温，对应用程序交下来的报文，在添加首部之后就交付给Ip层，不会对报文拆分；TCP面向字节流，会对应用程序的报文进行拆分。4、UDP支持一对一、一对多、多对一和多对一的通信；TCP只能点对点通信，它提供全双工通信，允许通信双方在任何时候均能通信。5、UDP首部开销小，TCP开销大（UDP 8个字节，TCP20个字节）。6、UDP没有拥塞控制，在网络条件差的情况下发送端也不会降低发送速率；TCP有拥塞控制 3、谈谈对RxJava的理解/okhttp的理解/fresco的理解（或者问看过哪些源码） 5、怎么处理滑动冲突 6、如何理解Java类加载机制 7、聊聊handler机制？ 一个线程是否只有一个Looper？如何保证一个线程只有一个Looper？ Handler 初始化的时候会通过 Looper.myLooper（实际上只是返回了 sThreadLocal.get()） 获取当前线程的Looper。之后通过 looper 获取当前线程的 mQueue 。当然，如果在子线程中new Handler ，基本上会提示 您还未执行Looper.prepare();Looper.prepare() 会判断当前 sThreadLocal.get()是否已经存在了，如果已经存在了，就会提示 “一个线程只能有一个Looper”（注意，就是在这里保证了一个线程只有一个Looper）。Looper.prepare() 只是执行了sThreadLocal.set(new Looper())，在这里给线程设置了Looper。而在主线程中，ActivityThread 的main 方法中会执行 Looper.prepareMainLooper（）来设置Looper，故我们可以直接new Handler，而在子线程中要手动Looper.prepare()才行，并且还要Looper.loop()，让消息循环。接下来就是 handler 的 sendMessage 和post 方法，其实两个方法都是调用 sendMessageDelay 方法，只不过post方法首先将 Runnable封装成Message，变成Message的CallBack。在最终send的时候，Message会持有handler的引用，叫做target，之后，message被丢到handler所持有的MessageQueue中。之后，在主线程中，Looper一直在循环，取出queue中的Message，然后执行message.target.dispatchMessage，在这个方法中，最终会调用到我们写handler时候覆写的 handleMessage 方法。至此，整个流程走完。 8、手写算法题。猫扑素数；1到n，求1的个数；单词反转。 9、 Activity的加载模式。 standard标准启动。singleTop在当前栈顶就复用，否则新建。singleTask：在当前栈存在有实例，如果在栈顶，直接使用；如果不在栈顶，将该实例之上的Activity全部出栈。singleInstance：只要有这个实例，不管在哪个栈，都复用之；否则，在新的栈创建实例。 10、ANR异常发生条件？1)5s内没有响应用户输入事件2)10s内广播接收器没有处理完毕3)20s内服务没有处理完毕 5.1 如何分析ANR？（log+trace.txt） 11、简述下GC，垃圾回收算法，gc什么时候回收？同时看看 这个链接 12、Dalvik和Art区别？(Just In Time和Ahead Of Time) Dalvik采用JIT（just in time，即时编译），每次运行，字节码边转换为机器码边执行；Art采用AOT(Ahead-of-time，预编译)技术，在第一次安装的时候即预编译成机器码，当然，这也会导致应用安装占用的存储空间增大。（关于回收，还有待看官网之后回来review）Dalvik 在Gc时，会有2次虚拟机暂停（遍历阶段和标记阶段分别暂停一次；除了GC线程外，其余线程都挂起，stop the world），而Art在Gc开始时，首先锁住java堆，扫描并标记，完成后，挂起所有线程，之后挥手垃圾，最后回复所有线程现场，即Art只有一次暂停。运行时堆得区域划分不同，Dalvic 每次GC完毕后，基本上都千疮百孔，空间碎片化严重；而ART多了两个空间，即 ImageSpace 和Large Object space，前者用于预加载类，后者用于存放大对象，这样可以大大减少碎片化。ART支持64位系统 参考官方说明链接 13、说说四大引用？强，软，弱，虚，并说明下合适GC 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。 软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，只有在内存不足的时候 JVM 才会回收该对象。这一点可以很好地用来解决 OOM 的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。 “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。要注意的是，虚引用必须和引用队列关联使用. 14、Android动画种类，各自特征 15、Http和Https的区别？ Https是ssl加密传输，Http是明文传输Https是使用端口443，而Http使用80HttpsSSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比Http协议安全Https协议需要到CA申请证书 16、最有成就感的项目？最棘手的问题？ 18、有了解热修复技术吗？ 20、TCP/IP 流量控制，拥塞避免，可以结合这篇文章 21、HashMap 、 HashTable 和 ConcurrentHashMap 的区别？ HashTable 是 HashMap 的线程安全实现，但是 HashTable在竞争激烈时效率低下，因为访问所有 HashTable 的线程都竞争同一把锁。ConcurrentHashMap 采用锁分段技术，将数据一段段存储，每段一把锁，当两个线程访问不同段数据时不受干扰，当然，contentValue和size等方法需要了解整体数据的情况下，还需要锁住整个表。 22、两个对象的 hashcode 相同，是否对象相同？equal() 相同呢？ hashCode是所有java对象的固有方法，默认返回的是该对象在jvm的堆上的内存地址，不同对象的内存地址肯定不同，所以这个hashCode也就肯定不同了。如果重载了的话，由于采用的算法的问题，有可能导致两个不同对象的hashCode相同。 hashCode和equals两个方法是有语义关联的，它们需要满足：A.equals(B)==true –&gt; A.hashCode()==B.hashCode()，但是反之不能说hashcode相等就equals因此重载其中一个方法时也需要将另一个也重载。 此外，请注意：hashCode的重载实现最好依赖于对象中的final属性，从而在对象初始化构造后就不再变化。一方面是jvm便于代码优化，可以缓存这个hashCode；另一方面，在使用hashMap或hashSet的场景中，如果使用的key的hashCode会变化，将会导致bug，比如放进去时key.hashCode()=1，等到要取出来时key.hashCode()=2，就取不出来数据了。综上所述，hashCode相同或者equals相同并不能说明对象相同。 23、Session 和 Cookie 的区别？ HTTP是一种无状态的协议，为了分辨链接是谁发起的，Session和Cookie就是为解决这个问题而提出来的两个机制。Cookies是服务器下发，存储到本地机器上的一段文本，并随每一个请求发回服务器，是在客户端保持状态的方案。浏览器第一次发送请求时，服务器自动生成了一HashTable和一个Session ID来唯一标识这个HashTable，并将其通过响应发送回浏览器。Session的实现方式和Cookie有一定关系，一般会把session id存在Cookie中（也可以依赖于url重写），每次访问的时候将Session id带过去，服务器就根据id查找hashtable就可以识别当前用户状态了。所以可以总结，cookie存在本地，session存在服务器；父路径不能享用子路径的cookies，而同一个session的窗口可以共享session；cookie没有session可靠。 24、线程同步，你了解哪几种方式？ 数据同步：可以使用Android 提供的同步容器。如： CopyOnWriteArrayList（当某个线程要修改list的元素时，首先copy一份出来，然后在修改前加锁，防止多个线程同时修改而copy多个副本，读的时候无需加锁，读的是副本）、concurrentHashMap（分段锁）、BlockingQueue（队列满了，在调用put，会阻塞，直到不再是满的；同理，取也是一样）。 用锁。同步锁：synchronize（无论synchronized关键字加在方法上还是对象上，他锁的都是对象，而不是把一段代码或函数当作锁）、ReentrantLock 25、synchronized 与 Lock。讲下 RecentLock 可重入锁？ 什么是可重入锁？为什么要设计可重入锁？ 介绍：synchronized：无论synchronized关键字加在方法上还是对象上，他锁的都是对象，而不是把一段代码或函数当作锁。Lock：一般使用ReentrantLock类做为锁，需要显式指出加锁与释放锁的位置，在加锁和解锁处通过lock()和unlock()显示指出，所以一般会在finally块中写unlock()以防死锁。 区别： synchronized 是个关键字，而 Lock 是个接口 synchronized 使用简单，会自动释放；Lock需要显式加锁与释放，要防止死锁 synchronized是悲观锁，其他线程只能阻塞来等待线程释放锁；Lock是乐观锁。 lock可以使我们多线程交互变得方便，而使用synchronized则无法做到这点。如：某个线程在等待锁的过程中需要中断、或者获知某个线程有没有获取到锁、或者需要指定notify哪个线程 26、讲下 Volatile 吧？他是怎样做到同步的？Volatile 为什么不支持原子性？notify、wait 27、网络状态码？以 2、3、4、5 开头的代表什么意思。 28、算法：排序、二叉树遍历、红黑树了解。常见的数据结构主要有数组、链表、栈、队列、二叉堆、树、图等，红黑树和BL树的区别 29、谈谈你对Application类的理解 30、Android为什么要设计出Bundle而不是直接使用HashMap来进行数据传递 31、Android中IPC通信的方式有哪些？使用场景是什么 32、SharedPreference在使用过程中有什么注意点？ 33、[内存泄露检测工具,anr检测工具] 34、了解协程吗 35、Android应用启动过程，Android应用打包过程 36、如何判断一个单链表是否有环 37、android 5.0, 6.0, 7.0, 8.0新特性 38、内存泄漏场景 40、volatitle 关键字的作用","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"常用的有意思的算法(三)","slug":"常用的有意思的算法(三)","date":"2019-03-04T13:10:00.000Z","updated":"2019-05-01T15:21:35.890Z","comments":true,"path":"2019/03/04/常用的有意思的算法(三)/","link":"","permalink":"https://glassx.gitee.io/2019/03/04/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%AE%97%E6%B3%95(%E4%B8%89)/","excerpt":"","text":"冒泡排序算法思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。即第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。之后便是重复第一趟步骤，直至全部排序完成。 第一趟比较完成后，最后一个数一定是数组中最大的一个数，所以第二趟比较的时候最后一个数不参与比较；第二趟比较完成后，倒数第二个数也一定是数组中第二大的数，所以第三趟比较的时候最后两个数不参与比较；依次类推，每一趟比较次数-1; 1234567891011121314151617181920 private static void bubbleSort1(int[] ints) &#123; int len = ints.length; boolean flag = true; while (flag) &#123; flag = false; for (int i = 1; i &lt; len; i++) &#123; if (ints[i - 1] &gt; ints[i]) &#123; int temp = ints[i]; ints[i] = ints[i-1]; ints[i-1] = temp; flag = true; &#125; &#125; len -- ; &#125; foreach(int i : ints)&#123; print(i); &#125;&#125; 选择排序选择排序的基本思想：给定数组：int[] arr={里面n个数据}；第1趟排序，在待排序数据arr[1]arr[n]中选出最小的数据，将它与arrr[1]交换；第2趟，在待排序数据arr[2]arr[n]中选出最小的数据，将它与r[2]交换；以此类推，第i趟在待排序数据arr[i]~arr[n]中选出最小的数据，将它与r[i]交换，直到全部排序完成。 12345678910111213141516171819202122public static void selectSort(int[] a)&#123; for (int i = 0; i&lt; a.length - 1; i++)&#123; int index = i;//当前趟最小的数所在index for (int j=i+1; j &lt; a.length; j++)&#123; if (a[j] &lt; a[index])&#123; index = j; &#125; &#125; if (index != i)&#123; int temp = a[i]; a[i] = a[index]; a[index] = temp; &#125; &#125; //排序结束 for (int h = 0; h &lt; a.length; h++)&#123; System.out.print(\"\" + a[h]); &#125;&#125; 插入排序 以数组的某一位作为分隔位，比如 index = 1 ，假设左面的都是有序的。 将 index 位的数据拿出来，放到临时变量里，这时index位置就空出来了。 从 leftindex = index-1 开始将左面的数据与当前 index 位的数据（即temp）进行比较，如果 array[leftindex] &gt; temp ，则将 array[leftindex] 后移一位，即 array[leftindex+1] = array[leftindex] ,此时 leftindex 就空出来了。 再用 index-2 (即leftindex=leftindex-1)位的数据和temp比，重复步骤3，直到找到 &lt;=temp 的数据或者比到了最左面（说明temp最小），停止比较，将temp放在当前空的位置上。 index 向后挪1，即 index=index+1 ，temp=array[index] ，重复步骤2~4，直到index=array.length，排序结束，此时数组中的数据即为从小到大的顺序。 1234567891011public void doInsertSort()&#123; for(int index = 1; index&lt;length; index++)&#123;//外层向右的index，即作为比较对象的数据的index int temp = array[index];//用作比较的数据 int leftindex = index-1; while(leftindex&gt;=0 &amp;&amp; array[leftindex]&gt;temp)&#123;//当比到最左边或者遇到比temp小的数据时，结束循环 array[leftindex+1] = array[leftindex]; leftindex--; &#125; array[leftindex+1] = temp;//把temp放到空位上 &#125;&#125; shell排序123456789101112131415161718/** * 思路：三层循环 * 第一层循环：控制增量-增量随着程序的进行依次递减一半 * 第二层循环：遍历数组 * 第三层循环：比较元素，交换元素。 * 这里需要注意的是：比较的两个元素和交换的两个元素是不同的。 */public static shellSort(int[] data) &#123; for (int div = data.length/2; div&gt;0; div/=2) &#123; for (int j = div; j &lt; data.length; j++) &#123; int temp = data[j]; for (int k=j; k&gt;=div &amp;&amp; temp&lt;data[k-div] ; k-=div) &#123; data[k] = data[k-div]; &#125; data[k] = temp; &#125; &#125;&#125; 快速排序假设我们现在对“6 1 2 7 9 3 4 5 10 8”这个10个数进行排序。首先在这个序列中随便找一个数作为基准数，为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边。得到一个一个以6为中心的序列，再以6为界限，将左右两边都看成数组，分别按照刚才的方法排序。上个图会比较直观： 代码如下： 1234567891011121314151617181920212223242526272829303132333435public static void quickSort(int[] arr,int low,int high)&#123; int i,j,temp,t; if(low&gt;high)&#123; return; &#125; i=low; j=high; //temp就是基准位 temp = arr[low]; while (i&lt;j) &#123; //先看右边，依次往左递减 while (temp&lt;=arr[j]&amp;&amp;i&lt;j) &#123; j--; &#125; //再看左边，依次往右递增 while (temp&gt;=arr[i]&amp;&amp;i&lt;j) &#123; i++; &#125; //如果满足条件则交换 if (i&lt;j) &#123; t = arr[j]; arr[j] = arr[i]; arr[i] = t; &#125; &#125; //最后将基准为与i和j相等位置的数字交换 arr[low] = arr[i]; arr[i] = temp; //递归调用左半数组 quickSort(arr, low, j-1); //递归调用右半数组 quickSort(arr, j+1, high);&#125; 堆排序1234567891011121314151617181920212223242526272829303132 //非递归算法实现二路归并排序，length代表数组长度，即数组最大下标是 legth - 1void mergeSort(int List[],int length)&#123; int size = 1; int low; int mid; int high; //size 是标记当前各个归并序列的high-low，从1，2，4，8，……，2*size while(size &lt;= length - 1)&#123; //从第一个元素开始扫描，low代表第一个分割的序列的第一个元素 low = 0; //当前的归并算法结束的条件 while(low + size &lt;= length - 1)&#123; //mid代表第一个分割的序列的最后一个元素 mid = low + size - 1; //high 代表第二个分割的序列的最后一个元素 high = mid + size; //判断一下：如果第二个序列个数不足size个 if(high &gt; length - 1)&#123; //调整 high 为最后一个元素的下标即可 high = length - 1; &#125; //调用归并函数，进行分割的序列的分段排序 merge(List, low, mid, high); //打印出每次归并的区间 cout &lt;&lt; \"low:\" &lt;&lt; low &lt;&lt; \" mid:\" &lt;&lt; mid &lt;&lt; \" high:\" &lt;&lt; high &lt;&lt; endl; //下一次归并时第一序列的第一个元素位置 low = high + 1; &#125;// end of while //范围扩大一倍，二路归并的过程 size *= 2; &#125;&#125; 归并的思想主要用于外部排序：外部排序可分两步①待排序记录分批读入内存，用某种方法在内存排序，组成有序的子文件，再按某种策略存入外存。②子文件多路归并，成为较长有序子文件，再记入外存，如此反复，直到整个待排序文件有序。 总结上述排序，稳定的排序有：冒泡、插入、合并 ，不稳定排序：选择、shell、快排、堆排","categories":[],"tags":[{"name":"趣味题","slug":"趣味题","permalink":"https://glassx.gitee.io/tags/%E8%B6%A3%E5%91%B3%E9%A2%98/"}]},{"title":"常用的有意思的算法(二)","slug":"常用的有意思的算法(二)","date":"2019-03-03T12:10:00.000Z","updated":"2019-05-01T15:14:23.673Z","comments":true,"path":"2019/03/03/常用的有意思的算法(二)/","link":"","permalink":"https://glassx.gitee.io/2019/03/03/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%AE%97%E6%B3%95(%E4%BA%8C)/","excerpt":"","text":"1、字符串匹配主要是利用KMP算法，这个很令人头大，这里贴出算法代码，如果需要详细了解，可以去查看July大神的这篇文章。 12345678910111213141516171819202122232425262728public static int kmp(String str, String dest,int[] next)&#123;//str文本串 dest 模式串 for(int i = 0, j = 0; i &lt; str.length(); i++)&#123; while(j &gt; 0 &amp;&amp; str.charAt(i) != dest.charAt(j))&#123; j = next[j - 1]; &#125; if(str.charAt(i) == dest.charAt(j))&#123; j++; &#125; if(j == dest.length())&#123; return i-j+1; &#125; &#125; return 0; &#125; public static int[] kmpnext(String dest)&#123; int[] next = new int[dest.length()]; next[0] = 0; for(int i = 1,j = 0; i &lt; dest.length(); i++)&#123; while(j &gt; 0 &amp;&amp; dest.charAt(j) != dest.charAt(i))&#123; j = next[j - 1]; &#125; if(dest.charAt(i) == dest.charAt(j))&#123; j++; &#125; next[i] = j; &#125; return next; &#125; next数组的计算主要跟模式串有关，与文本串并没有关系，因为，模式串前后公共最长子序列。这样才会让我们跳过大量的重复计算 数字排列题目：用1，2，2，3，4，5 这6个数字，写一个方法，打印出所有不同的排列，如 512234、412235等，要求4不能再第三位，3与5不能相连。 思路：问题可以归结为图的遍历，实际上6个数字就是6个结点，把6个结点连成无向连通图，对于每个结点求这个图形的遍历路径，所有结点的遍历路径就是最后对这6个数字的排列组合结果集。当然，这样获取的结果集未达到题目要求：（1）3与5不能相连，这个可以在构造图的时候就满足条件；（2）不能重复，有两个2，明显会存在重复结果，得最后去重（可以放在treeSet中）；（3）4不能排在第三位，这个仍旧在结果集中排除即可。 具体代码略。 二叉树遍历先序遍历 123456789101112131415161718192021222324252627//手算的思想，先变访问边找，找到最左下方的，然后向上再向访问右边的public static void iterativePreOrder(TreeNode p) &#123; if (p == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while (!stack.empty() || p != null) &#123; while (p != null) &#123; visit(p); stack.push(p); p = p.left; &#125; p = stack.pop(); p = p.right; &#125;&#125;//栈的思想，按层次倒着进栈，利用后进先出解决顺序问题public static void iterativePreOrder_2(TreeNode p) &#123; if (p == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); stack.push(p); while (!stack.empty()) &#123; p = stack.pop(); visit(p); if (p.right != null) stack.push(p.right); if (p.left != null) stack.push(p.left); &#125;&#125; 中序遍历 12345678910111213public static void iterativeInOrder(TreeNode p) &#123; if (p == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while (!stack.empty() || p != null) &#123; while (p != null) &#123; stack.push(p); p = p.left; &#125; p = stack.pop(); visit(p); p = p.right; &#125;&#125; 后序遍历 123456789101112131415161718//双栈法，易于理解public static void iterativePostOrder_3(TreeNode p) &#123; if (p == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); Stack&lt;TreeNode&gt; result = new Stack&lt;TreeNode&gt;(); while (!stack.empty() || p != null) &#123; while (p != null) &#123; stack.push(p); result.push(p); p = p.right; &#125; if (!stack.empty()) p = stack.pop().left; &#125; while (!result.empty()) &#123; p = result.pop(); visit(p); &#125;&#125; 层次遍历1234567891011public static void iterativeLevelOrder(TreeNode p) &#123; if (p == null) return; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(p); while (!queue.isEmpty()) &#123; p = queue.poll(); if (p.left != null) queue.offer(p.left); if (p.right != null) queue.offer(p.right); visit(p); &#125;&#125;","categories":[],"tags":[{"name":"趣味题","slug":"趣味题","permalink":"https://glassx.gitee.io/tags/%E8%B6%A3%E5%91%B3%E9%A2%98/"}]},{"title":"常用的有意思的算法(一)","slug":"常用的有意思的算法(一)","date":"2019-03-02T12:10:00.000Z","updated":"2019-05-01T10:11:29.331Z","comments":true,"path":"2019/03/02/常用的有意思的算法(一)/","link":"","permalink":"https://glassx.gitee.io/2019/03/02/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%AE%97%E6%B3%95(%E4%B8%80)/","excerpt":"","text":"扑克洗牌算法打乱一个已有顺序有多种实现方式，但是要高效地实现，还需要斟酌，以下是目前能想到的最有的解决方案： 1234567891011//生成一副牌Card[52] oneCard = generateOneCard;//顺序与 随机位置交换Random r = new Random();for (int i = 0; i &lt; oneCard.size(); i ++)&#123; int j = r.nextInt(52); Card tempCard = oneCard[i]; oneCard[i] = onCard[j]; onCard[j] = tempCard;&#125; 判断链表中是否有环快慢指针法：创建两个指针1和2同时指向这个链表的头节点，然后两个指针分别向后移动，其中指针1每次向后移动一个节点，指针2每次向后移动两个节点，每移动一次就比较两个指针指向的节点是否相同，如果相同说明出链表有环；如果不同，则继续循环，直到有环结束或者到达尾部结束。 原理：两个人在环形跑道上同一位置开始跑，一人速度快，一人速度慢，如此持续跑一段时间，速度快的那个肯定会从速度慢的身后再次追上以及超越，这中间必然有个交汇点。如果是跑直线的话，到终点就结束了，不会再碰面。 1234567891011121314151617//判断是否有环public static &lt;T&gt; boolean isLoopList(ListNode&lt;T&gt; head)&#123; ListNode&lt;T&gt; slowPointer, fastPointer; //使用快慢指针，慢指针每次向前一步，快指针每次两步 slowPointer = fastPointer = head; while(fastPointer != null &amp;&amp; fastPointer.next != null)&#123; slowPointer = slowPointer.next; fastPointer = fastPointer.next.next; //两指针相遇则有环 if(slowPointer == fastPointer)&#123; return true; &#125; &#125; return false;&#125; 引申：如何判断环的入口我们假定链表头到环入口的距离是len，环入口到slow和fast交汇点的距离为x，环的长度为R。slow和fast第一次交汇时，设slow走的长度为：d = len + x，而fast走的长度为：2d = len + nR + x，(n &gt;= 1)，从而我们可以得知：2len + 2x = len + nR + x，即len = nR - x，(n &gt;= 1)。所以，要找出环入口，也要两个指针，一个指针A指向相遇时候的节点，一个指针B指向链表头，两个指针每次都走一步，A指针在遍历过程中可能多次(n &gt;= 1)经过环入口节点，但当B指针第一次达到入口节点时，A指针此时必然也指向入口节点。 123456789101112131415161718192021222324252627282930313233//判断是否有环，有环就返回入口public static &lt;T&gt; ListNode&lt;T&gt; findEntranceInLoopList(ListNode&lt;T&gt; head)&#123; ListNode&lt;T&gt; slowPointer, fastPointer; //使用快慢指针，慢指针每次向前一步，快指针每次两步 boolean isLoop = false; slowPointer = fastPointer = head; while(fastPointer != null &amp;&amp; fastPointer.next != null)&#123; slowPointer = slowPointer.next; fastPointer = fastPointer.next.next; //两指针相遇则有环 if(slowPointer == fastPointer)&#123; isLoop = true; break; &#125; &#125; //一个指针从链表头开始，一个从相遇点开始，每次一步，再次相遇的点即是入口节点 if(isLoop)&#123; slowPointer = head; while(fastPointer != null &amp;&amp; fastPointer.next != null)&#123; //两指针相遇的点即是入口节点 if(slowPointer == fastPointer)&#123; return slowPointer; &#125; slowPointer = slowPointer.next; fastPointer = fastPointer.next; &#125; &#125; return null;&#125; 再引申，两个单链表是否相交两个没有环的链表在某一节点相交，那么在这个节点之后的所有结点都是两个链表所共有的。如果它们相交，则最后一个结点一定是共有的，因此问题转化为：两个链表最后一个结点是否相同（时间复杂度为O(len1+len2)）。要找出相交的第一个结点，可以首先获得两个链表的长度，然后获得两个链表长度差值 K，之后长的链表指向第K个结点，短的链表从头开始，每次向后移动一个结点，再比较当前结点是否相等，第一次相等的那个结点点就是相交节点。 代码略","categories":[],"tags":[{"name":"趣味题","slug":"趣味题","permalink":"https://glassx.gitee.io/tags/%E8%B6%A3%E5%91%B3%E9%A2%98/"}]},{"title":"趣味烧脑题","slug":"趣味烧脑题","date":"2019-03-01T12:10:00.000Z","updated":"2019-05-01T10:07:23.749Z","comments":true,"path":"2019/03/01/趣味烧脑题/","link":"","permalink":"https://glassx.gitee.io/2019/03/01/%E8%B6%A3%E5%91%B3%E7%83%A7%E8%84%91%E9%A2%98/","excerpt":"","text":"1、给100盏灯编号 1~100，开始时所有灯都是关着的第1次：把所有编号是1的倍数的灯的开关状态改变一次；第2次：把所有编号是2的倍数的灯的开关状态改变一次；第3次，把所有编号是3的倍数的灯的开关状态改变一次；…第100次，把所有编号是100的倍数的灯的开关状态改变一次；问：最后开着的灯的编号是哪些？ 分析：最开始灯是灭的，因此只有经过奇数次开关状态改变，灯才会是亮的。从题意可知一个数字有多少约数就会状态改变多少次，因此这道题可以转换为：1~100数字中约数个数是奇数的有哪些。并且我们知道约数是成对出现的，如8的约数：（1，8）、（2，4），因此如果要出现约数的个数是奇数个，除非它是个平方数，如36的约数：（1，36）、（2，18）、（3，12）、（4，9）、（6），因此，这题又可以转换为1~100数字中的平方数有哪些，这操作。。。。666吧，这就是分析问题的乐趣吧 2、烧一根不均匀的绳子，从头烧到尾总共需要1小时，现在有若干条这样的绳子，问如何用烧绳子的方法来计时1小时15分钟呢 从题目知道，绳子不均匀，不能根据燃烧半根来计量半小时。但是还可以推断，从两头烧，只要半小时。因此可以使用3根绳子来计时：1）第1根绳子点燃两端，第2根绳子点燃一端，第三根绳子先不点燃； 2）第1根绳子烧完计时30分钟，接着第2根绳子另一端也点燃 3）第2根绳子烧完计时15分钟，此时已经计时45分钟了，剩下的半小时只需要将第3条绳子两端点燃就能计算出。 3、有12个外观一样的小球，但有一个与其他小球重量略微不同，用手感觉不出来，用一个天平，能称3次就能找到那个小球吗 把小球编号 112，然后分为3组（想想为什么是3组）：14分为A组，58分为B组，912分为C组。首先A组和B组称量比较：1、天平平衡。则目标小球在C组。将C分为两组：9、10、11分为一组C1，12分为一组C2，再从B中随意拿出3个球分组为B1，C1和B1比较： 1）若平衡，则12号球就是目标球。 2）若不平衡，则目标球在C1内，并且根据天平倾斜，可以判断目标球比普通球重还是轻（若是天平显示B1重，则目标球比较轻；反之目标球比较重），此时随意取 C1 中的2个球放在天平上即可知道结果（如果平衡，则目标球是另一个，如果不平衡，根据轻重可知目标球）。2、天平不平衡。则目标球在A或者B中。 1）若A &gt; B,取（1，2，3，5）为一组X,(4,9,10,11)为一组Y，（6，7，8）为一组Z，比较X和Y，若X&gt;Y，可知不同小球在1，2，3中，且目标球重于普通球，此时再将编号 1，2，3 任取2个放上天平即可知道目标球。若X&lt;Y,则说明4号是目标球；若X=Y，则目标球在Z中（6，7，8），并且目标球轻于普通球，此时只需要将编号 其中任意两个球放上天平即可找出目标球。 2）若 A &lt; B，同样按照上述分为X、Y、Z三组，同理，若X&lt;Y，则目标球在1，2，3中，且目标球轻于普通球，此时再将编号 1，2，3 任取2个放上天平即可知道目标球；若X&gt;Y,说明4号为目标球，若X=Y，则目标球在Z中（6，7，8），并且目标球重于普通球，此时再将编号 6，7，8 任取2个放上天平即可知道目标球。 3、一笔画出经过9个点的4条直线 主要是要突破点，不要局限于点上，不说了，直接上图：9点4线 4、有1块钱1瓶的契税，喝完后2个空瓶换一瓶汽水，问有20块钱，可以喝几瓶汽水？ 总共40瓶（不要浪费最后那个空瓶，找老板借1个，凑2瓶子再喝一瓶，最后这空瓶还给老板。。。） 5、时针分针秒针重合的次数 只有2次，一次是 00:00:00 一次是 12：00：00 假设排列100个球，两个人轮流一拿球装入口袋，能拿到第100个球为胜，条件是每次拿球至少拿1个，最多拿5个，加入你是最先拿球的人，你该拿几个，以后怎么保证拿到最后一个球？ 怎样保证拿到最后一个球呢？最简单的方法是最后剩下6个，并且轮到对方来拿，这样无论对方拿几个，都能保证自己拿到最后一个。（1）首先，要控制每一轮拿出的个数，但是对方拿的个数是不受控制的，假设对方拿n个，自己就拿6-n个（为什么是控制总数是6个，是因为对手最多拿5个，自己最少能拿1个，和值就是6，自己不能把和值控制得更低；而对手至少拿1个，自己最多拿5个，同样自己不能把和值控制得更高。因此只有6才是一个可控的值）。（2）其次，假设第一次拿x个球，以后每次自己和对方拿的和是6，最多可以拿到15轮（除去第一轮的x个，最后留这肯定少于10个了），还剩 10-x个，为了达到之前定的目标最后留6个，所以x应该是4.（3）总结而言就是第一次拿4个，以后每次对方拿了n个后，自己拿 6-n 个。","categories":[],"tags":[{"name":"趣味题","slug":"趣味题","permalink":"https://glassx.gitee.io/tags/%E8%B6%A3%E5%91%B3%E9%A2%98/"}]},{"title":"Android 事件分发机制","slug":"Android 事件分发机制","date":"2019-02-25T14:00:00.000Z","updated":"2019-05-01T09:19:36.197Z","comments":true,"path":"2019/02/25/Android 事件分发机制/","link":"","permalink":"https://glassx.gitee.io/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Android 事件分发机制Android 事件分发机制总体来说可以用几张图说明白，相比在代码中打印Log，这种方式更容易理解和记住。 针对 ACTION_DOWN 事件只针对 ACTION_DOWN 事件时，事件的完整流向是一个U形图，如下图所示： 如果没有中断事件，可能看起来更直观一些，Activity、ViewGroup、View的层次更加清晰： 针对 ACTION_MOVE 和 ACTION_UP上面讲解的都是针对ACTION_DOWN的事件传递，ACTION_MOVE和ACTION_UP在传递的过程中并不是和ACTION_DOWN 一样，你在执行ACTION_DOWN的时候返回了false，后面一系列其它的action就不会再得到执行了。简单的说，就是当dispatchTouchEvent在进行事件分发的时候，只有前一个事件（如ACTION_DOWN）返回true，才会收到ACTION_MOVE和ACTION_UP的事件。 ViewGroup1 的dispatchTouchEvent 中返回true消费事件红色的箭头代表ACTION_DOWN 事件的流向，蓝色的箭头代表ACTION_MOVE 和 ACTION_UP 事件的流向： ViewGroup2 的dispatchTouchEvent 中返回true消费事件 在View 的dispatchTouchEvent 返回true消费事件,就不画图了，效果和在ViewGroup2 的dispatchTouchEvent return true的差不多，同样的收到ACTION_DOWN 的dispatchTouchEvent函数都能收到 ACTION_MOVE和ACTION_UP。 在View 的onTouchEvent 中返回true消费事件 在ViewGroup 2 的onTouchEvent 中返回true消费事件 在ViewGroup 1 的onTouchEvent 中返回true消费事件 在View的dispatchTouchEvent 中返回false并且ViewGroup 1 的onTouchEvent 返回true消费事件 在View的dispatchTouchEvent 中返回false并且Activity 的onTouchEvent 返回true消费事件 经过这么多图能得出以下规律： ACTION_DOWN事件在哪个控件消费了（return true）， 那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。 以上文章参考自 Kelin ,这里图片形式贴出来仅仅只是个人做的笔记，方便记忆。","categories":[],"tags":[{"name":"专题","slug":"专题","permalink":"https://glassx.gitee.io/tags/%E4%B8%93%E9%A2%98/"}]},{"title":"黑苹果折腾记","slug":"黑苹果折腾记","date":"2019-02-16T14:10:00.000Z","updated":"2019-09-14T00:48:26.164Z","comments":true,"path":"2019/02/16/黑苹果折腾记/","link":"","permalink":"https://glassx.gitee.io/2019/02/16/%E9%BB%91%E8%8B%B9%E6%9E%9C%E6%8A%98%E8%85%BE%E8%AE%B0/","excerpt":"","text":"过年在家没啥事干，折腾了下黑苹果，安装上了 OSX 10.14.3，整个过程还算顺利，最终除了睡眠和声卡之外，其他貌似ok，目前用来开发（Android studio 以及 XCode）没啥问题。此次记录主要是为了在以后还有闲心折腾黑苹果的时候，能拿出来参考，不至于从头开始爬帖。 首先，以一个过来人的身份告诉你，搞黑苹果如果不上 www.tonymacx86.com 网站的话，等于白折腾，这上面有最简便的最新的折腾黑苹果的方法，在国内远景论坛、黑苹果社区等地方看到的清一色古老的安装方式，甚至还有变色龙安装法。不要害怕 English，对于搞黑苹果而言，只需要很简单的英语水平。我这次安装10.14.3参考的就是这个帖子，只要一步步来，基本上是没什么问题的。 这个帖子主要条理清晰地通过5步，即完成了黑苹果的安装：Step 1: Download macOS Mojave（第一步：下载系统）Step 2: Create a Bootable USB with UniBeast（第二步：通过 UniBeast 制作 U盘启动盘）Step 3: Recommended BIOS Settings（第三步：设置 BIOS ）Step 4: Install macOS Mojave(第四步：安装系统)Step 5: Post Installation with MultiBeast（第五步：二次安装） 在开始之前，首先申请 tonymacx86.com 的账号，然后 在从那里下载最新的 UniBeast 和 MultiBeast 工具，之后准备一个 32GB 的U盘吧，教程上面说 16G 以上就够了，但实际上是不够的。其中，UniBeast 的作用是 创建一个可以正常启动10.14.3 的 U盘启动盘。 第一步 下载系统为了全新安装，首先可以从其他苹果系统里面下载系统，在苹果系统中： 打开 App Store -&gt; 下载macos Mojave 更新，下载完成后，在 Applications(应用)里面能够找到它。 第二步 用 UniBeast 创建启动U盘在第二步之前，首先备份好U盘的东西，因为制作启动盘会删除U盘中所有内容。 把U盘插到电脑上，打开：Application（应用）-&gt;Utilities（工具）-&gt; Disk Utility（磁盘工具）,从左边选中你的那个U盘，在Mojava或者更高版本中，可能你首先要设置 View(视图)-&gt;Show All Devices(显示所有设备)，才能看到你的U盘。之后执行 1、 点击 Erase（抹掉）按钮2、填写名称，目前先命名为 USB3、在Format（格式）的地方选择 Mac os Extended(Journaled)4、最后，点击 Erase（抹掉） 按钮正式抹掉 接下来，安装你下载的 UniBeast （这里貌似要求语言是English，否则还装不上，如果有这个要求，改下系统语言就行了），只要一直continue 下去就行，之后同意协议，最后选择安装的 Destination（目的磁盘）的时候，选择刚才抹掉的 USB盘 即可；在 select os Installation （选择安装系统）界面时，选择 Mojave 就行，之后在 Bootloader Options 界面选择 UEFI Boot Mode（根据需要有可能要选择 Legacy Boot Mode）。最后 Graphics Configuration 是可选的，可以根据你的显卡来对应设置。最后确认你的安装选项，输入密码，然后 Install。这时候大概要等待个10分钟，系统会写完。 系统完全写入U盘之后，把下载的 MultiBeast 软件拖到 U 盘，因为安装好之后需要它。 第三步 设置BIOS这里只针对UEFI 方式的BIOS 了（其他方式请参考原文了）。进入到 BIOS 设置中，如果CPU支持 VT-d，将其设置为 disable，CFG-Lock、Secure Boot Mode 、IO Serial Port 也 disable，设置 XHCI 为 Enable，设置 OS 为 Other OS。 第四步 安装 macOS Mojave将U盘插在电脑的USB2.0口上，这点特别要注意，不然第二次安装的时候会提示找不到resource，我就在这里折腾了两回才知道。开机，选择从你的 USB 盘启动（不同的电脑主板不一样，网上搜下即可）。在clover界面，通过键盘上的左右箭头（键盘右下角的上下左右箭头）选择 Boot OS X Install from macOS Mojave 在安装界面，首先选择顶部菜单栏的 Utilities（工具），再打开 Disk Utility（磁盘工具），在左边选中你想要安装系统的分区，之后像之前抹掉U盘那样抹掉这个分区，名字命名为 Mojave（之后你可以改这个名字），之后关闭Disk Utility（磁盘工具），即可继续安装。 安装的时候会提示安装到哪个盘，选择刚才抹掉的 Mojave 盘，之后会继续安装，待安装完成后会自动重启。 第五步在重启的时候要注意再次选择从U盘启动，之后在clover界面选择Mojave，之后就会自动安装，引导设置，完成。之后的事情就是安装驱动了，去论坛找各种kext即可，声卡可能就麻烦些，可能需要dsdt，这里就不细说。 问题集锦休眠导致键盘不可用如果是笔记本并且安装的是双系统（win + mac os），那么如果驱动对休眠的处理不好的话，在mac osx下发生休眠可能会导致系统重启，可能会重启进入windows系统，此时，你的键盘应该是不可用的。解决方案包括以下几个步骤： 启动windows ，在登录界面使用 “轻松使用-屏幕键盘” 的方式输入密码。 在windows 下使用 easyUefi 软件将 黑苹果的 efi 启动序列列为第一个，这样我们开机就会启动 clover。 重启系统，进入clover，此时键盘应该是不可以使用的，左右光标也是没作用的。如果能够看到你要启动的分区，则用鼠标点击直接启动，进入mac os 后，正常关闭，键盘就能正常使用了。 如果未能看到需要启动的分区，此时按字母 A 键，就会进入clover 的 “关于” 页面（这个我只在我电脑上试过，我在尝试按 A 或者 D 的时候发现的，对其他电脑的未做验证），此时，你的电脑键盘应该就可以使用了。这时候就可以退出“关于”页，之后进入黑苹果。 以上操作的主要目的是要正常关闭mac os ，这样键盘才能使用（在 mac os 或者 windows 下）。","categories":[],"tags":[{"name":"手摸手","slug":"手摸手","permalink":"https://glassx.gitee.io/tags/%E6%89%8B%E6%91%B8%E6%89%8B/"}]},{"title":"第五章——理解 RemoteViews","slug":"Android 开发艺术探索-第5章","date":"2018-12-10T14:00:00.000Z","updated":"2019-05-01T09:48:00.432Z","comments":true,"path":"2018/12/10/Android 开发艺术探索-第5章/","link":"","permalink":"https://glassx.gitee.io/2018/12/10/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC5%E7%AB%A0/","excerpt":"","text":"从字面可以看出这应该是一种远程view，与远程service概念一样，RemoteViews表示的是一种view结构，这种view能够在其他进程显示。由于需要跨进程显示，RemoteViews结构提供了一组基础功能用于跨进程更新View。RemoteViews在Android中有2种应用场景：Notification以及桌面小部件。 RemoteViews的应用平时的开发过程中，Notifications主要通过NotificationManager的notify方法实现的，它除了默认效果外，还可以另外定义布局。使用RemoteViews实现通知栏时无法像Activity里面一样直接更新View，这是因为RemoteView界面运行在其他进程中，确切来说是系统的SystemServer进程。使用系统默认的样式弹出一个通知是很简单的： 1234567891011121314151617181920212223Notification notification = newNotification();notification.icon = R.drawable.icon;notification.tickerText = \"hello world\";notification.when = System.currentTimeMillis();notification.flags = Notification.FLAG_AUTO_CANCEL;Intent intent = new Intent(this,DemoActivity_1.class);PendingIntent pendingIntent = PendingIntent.getActivity(this,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);//使用普通样式展示一个通知notification.setLatestEventInfo(this,\"chapter_5\",\"this is notification\",pendingIntent);NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);manager.notify(1,notification);//使用RemoteViews的方式展示第一个通知RemoteViews remoteViews = new RemoteViews(getPackageName(),R.layout.layout_notification);remoteViews.setTextViewText(R.id.msg,\"chapter_5\");remoteViews.setImageViewResource(R.id.icon,R.drawable.icon1);PendingIntent openActivity2PendingIntent = PendingIntent.getActivity(this,0,new Intent(this,DemoActivity_2.class),PendingIntent.FLAG_UPDATE_CURRENT);remoteViews.setOnclickPendingIntent(R.id.open_activity2,openActivity2PendingIntent);notification.contentView = remoteViews;notification.contentIntent = pendingIntent;NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);manager.notify(2,notification); 以上代码展示只要提供当前应用的包名以及布局文件的id即可创建一个RemoteViews对象，而更新RemoteViews，由于无法直接访问里面的view，因而只能通过RemoteViews提供的一系列方法来更新，比如设置文本，需要采用 remoteViews.setTextViewText(R.id.msg,”chapter_5”) ，而更新图片则采用 remoteViews.setImageViewResource(R.id.icon,R.drawable.icon1)，如果要给一个控件添加click事件，则要使用PendingIntent并且通过setOnclickPendingIntent。关于PendingIntent，它表示一种待定的Intent，这个Intent中所包含的意图必须由用户来出发。 RemoteViews在桌面小部件上的应用、PendingIntent概述、RemoteViews的内部机制等内容 待后续有集中的时间再添加","categories":[],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}]},{"title":"第9章-单元测试","slug":"从小工到专家-第九章","date":"2018-10-17T14:30:00.000Z","updated":"2018-10-17T14:50:05.000Z","comments":true,"path":"2018/10/17/从小工到专家-第九章/","link":"","permalink":"https://glassx.gitee.io/2018/10/17/%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6-%E7%AC%AC%E4%B9%9D%E7%AB%A0/","excerpt":"","text":"照例，如果自学不需要看我这个博客的话，资料如下：官网关于Android Test的介绍的地址Android官方关于测试的例子 ，需要的自取 单元测试、集成测试、黑盒测试、白盒测试等，只有单元测试是我们开发人员需要自己完成的，其余都是由测试人员完成的。单元测试本质上也是代码，是验证代码正确性的代码。 为什么要做单元测试 便于后期重构。单元测试为后期测试提供了保障，在重构之后，只要单元测试还是全部通过，那么在很大程度上表示重构没有引入新的bug。 优化设计。编写单元测试将使开发者从调用者的角度观察和思考，这样迫使开发者把程序设计成易于调用和低耦合的易测试的形式。 避免代码出现回归。编写完成后，可以随时随地快速运行测试，而不是要求将代码部署到设备上，再手动执行覆盖各种路径。 文档记录。单元测试是极好的“官方文档”，它展示函数或者类如何使用。 Android 测试类型(选自官网)测试代码的位置取决于您要编写的测试的类型。 Android Studio 为以下两种测试类型提供了源代码目录（源集）： 本地单元测试位于 module-name/src/test/java/目录。 这些测试在计算机的本地 Java 虚拟机 (JVM) 上运行。 当您的测试没有 Android 框架依赖项或当您可以模拟 Android 框架依赖项时，可以利用这些测试来尽量缩短执行时间。 在运行时，这些测试的执行对象是去掉了所有 final 修饰符的修改版 android.jar。 这样一来，您就可以使用 Mockito 之类的常见模拟库。 Instrumented测试（仪器测试）位于 module-name/src/androidTest/java/。 这些测试在硬件设备或模拟器上运行。 这些测试有权访问 Instrumentation API，让您可以获取某些信息（例如您要测试的应用的 Context）， 并且允许您通过测试代码来控制受测应用。 可以在编写集成和功能 UI 测试来自动化用户交互时，或者在测试具有模拟对象无法满足的 Android 依赖项时使用这些测试。 由于仪器测试内置于 APK 中（与您的应用 APK 分离），因此它们必须拥有自己的 AndroidManifest.xml 文件。 不过，由于 Gradle 会自动在构建时生成该文件，因此它在您的项目源集中不可见。 您可以在必要时（例如需要为 minSdkVersion 指定其他值或注册测试专用的运行侦听器时）添加自己的清单文件。 构建应用时，Gradle 会将多个清单文件合并成一个清单。 Gradle 构建解读这些测试源集的方式与其解读项目应用源集的方式相同，您可以利用这一点根据构建变体创建测试。 以下示意图诠释了两种测试的代码结构（图中1表示的是仪器测试的代码，2表示的是单元测试的代码结构） Junit4在Android测试框架中，常用的有以下几个框架和工具类：JUnit4、AndroidJUnitRunner、Mockito、Espresso，其中主要的单元测试使用Junit4。Junit4是一套基于注解的单元测试框架，在Android studio中，编写在test目录下的测试类都是基于该框架实现，该目录下的代码直接运行在本地的JVM上，不需要Android真机或者模拟器支持。常用的注解如下(更多内容可以查看Junit4官网)： @BeforeClass 测试类里所有用例运行之前，运行一次这个方法。方法必须是public static void @AfterClass 与BeforeClass对应 @Before 在每个用测试例运行之前都运行一次。 @After 与Before对应 @Test 指定该方法为测试方法，方法必须是public void @RunWith 测试类名之前，用来确定这个类的测试运行器以下用一个简单的测试类来展示测试类的大概形式： 123456789101112131415public class CaculatUtilTest&#123; private CaculatUtil mCaculatUtil; @Before public void setUp()&#123; mCaculatUtil = new CaculatUtil(); &#125; @Test public void addTwoNumbers()&#123; assertEquals(3,mCaculatUtil.add(1,2)); //或者如果是静态方法，就类似于以下这种静态调用方法 assertEquals(3,Caculator.add(1,2)); &#125;&#125; Junit的断言和失败提示Junit提供了多个以assert开头的函数，分别用来验证各类相等性质的问题，大致有如下几类： assertEquals assertEquals的作用是判断两个值或者对象是否相等。接受2个参数，参数1为预期值，参数2为计算得到的值。 assertTrue 与 assertFalse assertTrue 与 assertFalse顾名思义就是分别验证真与假，只需要一个boolean类型的参数。例如 assertTrue(false)测试会失败， 而 assertTrue(true) 测试通过。 assertNull 与 assertNotNull 和assertTrue、assertFalse类似，只不过是用来判断空或者非空。例如：assertNull(null) 会测试失败，因为值为null；而assertNull(“hell”)就能测试通过。 assertSame 与 assertNotSame assertSame用于判断两个对象是否是同一个对象，与assertEquals不同的是，assertSame强调的为同一个对象，而assertEquals只要两个对象相等即可（即调用equals函数时返回true）。 failNotEquals 函数有3个参数，参数1位失败时提示信息，参数2为期望值，参数3是实际值。当两个对象不相等时抛出参数1的错误信息。 failSame与failNotSame failNotSame与failNotEquals类似，不是同一个对象时就抛出参数1的错误信息。 fail(String) 与 fail() fail(String)直接抛出当前测试用例参数1中的错误信息，而fail()给出默认的错误信息。 运行多个测试类——TestSuite如果需要同时运行两个或多个Test类，JUnit提供了Suite注解，在对应的测试目录下创建一个空Test类： @RunWith(Suite.class)：配置Runner运行环境。 @Suite.SuiteClasses({A.class, B.class})：添加需要一起运行的测试类。 12345@RunWith(Suite.class)@Suite.SuiteClasses(&#123;CalculatorTest.class, CalculatorWithParameterizedTest.class&#125;)public class UnitTestSuite&#123; &#125; 上述代码中，UnitTestSuite成了一个空类，测试类被添加到注解中了。或者，如果不用注解，可以通过JUnit4TestAdapter包装测试类，并将JUnit4TestAdapter对象添加到TestSuit中，示例代码如下： 123456789public class MathTestSuite&#123; public static Test suite()&#123; TestSuite suite = new TestSuite(\"com.book.jtm\"); //添加测试用例 suite.addTest(new JUnit4TestAdapter(AdderTest.class)); suite.addTest(new JUnit4TestAdapter(DiverTest.class)); return suite; &#125;&#125; 上述代码有一个静态的suite函数，它返回一个Test对象，这个对象是TestSuite类型的。测试时，以Junit测试用例的形式运行这个MathTestSuite即可运行这两个测试类。 多个参数输入测试当需要传入多个参数进行测试时，可以使用 @Parameters 来进行单个方法的多次不同参数的测试，对于测试类，使用该方法需要如下步骤： 在测试类上添加@RunWith(Parameterized.class)注解 添加测试类的构造函数 添加获取参数集合的static方法，并在方法上添加@Parameters注解 在需要测试的方法中直接使用成员变量，该变量由JUnit通过构造方法生成 直接上示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637@RunWith(Parameterized.class)//为测试类添加注解public class CaculatUtilTest&#123; //两个传入的参数 private final int paramOne; private final int paramTwo; //期望值 private final int expectResult; private CaculatUtil mCaculatUtil; public CaculatUtilTest(int paramOne,int paramTwo,int expectResult)&#123;//添加构造函数 this.paramOne = paramOne; this.paramTwo = paramTwo; this.expectResult = expectResult; &#125; //添加获取参数集合的static方法，并在方法上添加@Parameters注解 @Parameters public static Collection&lt;Object[]&gt; initTestData()&#123; return Arrays.asList(new Object[][]&#123; &#123;0,0,0&#125;, &#123;1,1,2&#125;, &#123;1,5,6&#125; &#125;); &#125; @Before public void setUp()&#123; mCaculatUtil = new CaculatUtil(); &#125; @Test public void addTwoNumbers()&#123; //测试的方法中直接使用成员变量 assertEquals(expectResult,mCaculatUtil.add(paramOne,paramTwo)); &#125;&#125; AndroidJUnitRunner当单元测试中涉及Android系统库的调用时，可以通过AndroidJUnitRunner方案完成测试，这样就能在测试类中使用Context、parcelable、Shareprefrence等类。使用方法是在androidTest目录下创建测试类（因为这涉及到Instrumented测试的内容），在该类上添加@RunWith(AndroidJUnit4.class)注解。如以下代码示范了如何在测试类中使用SharedPrefrences： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@RunWith(AndroidJUnit4.class)public class SharedPreferencesHelperTest &#123; private static final String TEST_NAME = \"Test name\"; private static final String TEST_EMAIL = \"test@email.com\"; private static final Calendar TEST_DATE_OF_BIRTH = Calendar.getInstance(); private SharedPreferenceEntry mSharedPreferenceEntry; private SharedPreferencesHelper mSharedPreferencesHelper; private SharedPreferences mSharePreferences; /** 上下文 */ private Context mContext; …… @Before public void setUp() throws Exception &#123; //获取application的context mContext = InstrumentationRegistry.getTargetContext(); //实例化SharedPreferences mSharePreferences = PreferenceManager.getDefaultSharedPreferences(mContext); mSharedPreferenceEntry = new SharedPreferenceEntry(TEST_NAME, TEST_DATE_OF_BIRTH, TEST_EMAIL); //实例化SharedPreferencesHelper，依赖注入SharePreferences mSharedPreferencesHelper = new SharedPreferencesHelper(mSharePreferences); //以下是在mock的相关操作，模拟commit失败 mMockSharePreferences = Mockito.mock(SharedPreferences.class); mMockBrokenEditor = Mockito.mock(SharedPreferences.Editor.class); when(mMockSharePreferences.edit()).thenReturn(mMockBrokenEditor); when(mMockBrokenEditor.commit()).thenReturn(false); mMockSharedPreferencesHelper = new SharedPreferencesHelper(mMockSharePreferences); &#125; /** * 测试保存数据是否成功 */ @Test public void sharedPreferencesHelper_SavePersonalInformation() throws Exception &#123; assertThat(mSharedPreferencesHelper.savePersonalInfo(mSharedPreferenceEntry), is(true)); &#125; /** * 测试保存数据，然后获取数据是否成功 */ @Test public void sharedPreferencesHelper_SaveAndReadPersonalInformation() throws Exception &#123; mSharedPreferencesHelper.savePersonalInfo(mSharedPreferenceEntry); SharedPreferenceEntry sharedPreferenceEntry = mSharedPreferencesHelper.getPersonalInfo(); assertThat(isEquals(mSharedPreferenceEntry, sharedPreferenceEntry), is(true)); &#125; ……&#125; 模拟所需要的模块有时我们测试需要依赖于其他的功能模块，但是某些原因这个功能模块不能在测试时运用或未开发完，为了不阻塞测试，我们可以Mock对象来完成测试。还有一些场景，诸如对象很难被创建、真实对象运行缓慢、真实对象的错误很难出现等，也可以通过Mock对象来测试。 手动Mock对象举个例子，开发一款记事本软件，登录成功后才能写/存笔记，小明小刘分别负责登录和写/存笔记功能，存笔记的时候时候需要用户信息User的实例，而用户信息在登录成功后才能获得。可行的代码如下： 123456789101112131415161718192021222324252627282930//保存数据的类public class NoteDAO&#123; private NoteDAO noteDAO; public void saveNote(User user,String note)&#123; Log.d(\"NoteDAO\",\"存储笔记\"); &#125;&#125;//测试类public class NoteTest&#123; @Before public void setUp()&#123; noteDAO = new NoteDAO(); &#125; @Test public void testSaveNote()&#123; MockLoginImpl loginImpl = new MockLoginImpl(); noteDAO.saveNote(loginImpl.login(\"dd\",\"pwd\"),\"note_content\"); &#125;&#125;//Mock类public class MockLoginImpl &#123; public User login(String name,String pwd)&#123; return new User(name,\"1234556\"); &#125;&#125; 使用第三方工具Mockito前面有例子已经涉及到Mockito的部分使用，可以在网上搜索相关使用，这里不再详细展开，如果需要，后面会专门介绍。 运行单元测试 在Android studio中，对指定的测试类点击鼠标右键，选择对应的Run或者debug 在Terminal输入gradle testDebugUnitTest或gradle testReleaseUnitTest指令来分别运行debug和release版本的unittesting，在执行的结果可以在xxx\\project\\app\\build\\reports\\tests\\testReleaseUnitTest中查看 声明：整篇文章有部分内容摘抄自博客：https://www.jianshu.com/p/925191464389","categories":[],"tags":[{"name":"读书笔记-从小工到专家","slug":"读书笔记-从小工到专家","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6/"}]},{"title":"第5章： 函数","slug":"第一季kotlin崛起-第5章","date":"2018-10-11T14:00:00.000Z","updated":"2019-05-01T08:43:24.937Z","comments":true,"path":"2018/10/11/第一季kotlin崛起-第5章/","link":"","permalink":"https://glassx.gitee.io/2018/10/11/%E7%AC%AC%E4%B8%80%E5%AD%A3kotlin%E5%B4%9B%E8%B5%B7-%E7%AC%AC5%E7%AB%A0/","excerpt":"","text":"第五章：函数函数的定义和使用Kotlin中典型的函数如下所示： 123456789//模板，Unit代表无须返回，花括号里不用写return语句fun (x: Any, y: Any): Unit&#123; &#125;//实际函数fun suare(r: Double) : Double&#123; return Math.PI * r * r&#125; 以上函数整体只有一条语句，只有一条语句的函数可以省略返回类型、花括号以及return关键字。从而简化成单行表达式函数： 1fun suare(r: Double) = Math.PI * r * r 如果有个函数，需要接受若干个参数，参数个数不确定，那该如何定义？只需要在参数前加一个vararg修饰符就行，如下所示： 123456789101112//可变参数修饰符varargfun sum(vararg x: Int): Int&#123; var total = 0 for(i in x)&#123; total += i &#125; return total&#125;//一旦定义成可变参数，调用时可以给一个对应类型的数组，数组名前加一个星号(*)val a = intArrayOf(1,2,3,4,5,6)println(sum(*a)) 上面的代码中，加在变量名前的星号是“展开操作符(Spread operator)”，指的是把数组a全部展开，此处星号紧跟在变量名前，所以是一元操作符，而乘法的星号是二元操作符。 函数的作用范围Kotlin中函数根据作用范围可以分为： 成员函数、本地函数、顶层函数 成员函数跟java中一样，略过介绍。 本地函数(Local function)Kotlin可以允许把小函数声明在其它函数内部，这些小函数被称为本地函数或者嵌套函数（Nested）。甚至可以多层嵌套。这样的好处是，一个大的函数可以分为很多小的函数，可以做到每一个函数只做一件事。用法如以下例子： 12345678910fun printArea(w: Int,h: Int)&#123; fun area(w: Int,h: Int): Int &#123; return w * h; &#125; //也能写成这样： fun area() = w * h val area = area(w,h) println(\"面积=$area\")&#125; 当然，以上方法也能简化写成这样： 12345678910fun printArea(w: Int,h: Int)&#123; fun area(w: Int,h: Int): Int &#123; return w * h; &#125; //也能写成这样： fun area() = w * h val area = area(w,h) println(\"面积=$area\")&#125; 但是看到的本地函数 area() 在 printArea()方法外部就无效了，它只服务于printArea()方法。这在实现一个大函数时隐藏实现的细节是非常有用的，虽然Kotlin中使用private声明也能达到同样的隐藏效果，但是本地函数还能直接访问主函数中的变量，减少变量传递，减少代码，如上面的例子还可以简化为： 123456fun printArea(w: Int,h: Int)&#123; fun area() = w * h val area = area() print(\"面积=$area\")&#125; 再来一个例子，说明使用本地结合本地函数一步步精简代码（代码越少，出bug的几率就越低，这也是Kotlin奉行的准则）： 1234567891011121314//一般写法fun checkNumber(start: Int, end: Int)&#123; for(number in start..end)&#123; if(number % 3 == 0)&#123; println(\"$number被3整除\") &#125;else if(number % 5 == 0)&#123; println(\"$number被5整除\") &#125;else if(number % 3 == 0 &amp;&amp; number % 5 == 0)&#123; println(\"$number既能被3整除，也能被5整除\") &#125;else&#123; println(number) &#125; &#125;&#125; 以上的代码首先的问题是，“被3整除”这段代码重复了1次，这就意味着双倍bug的可能性（当然，例子太简单了，基本上不会出错）。现在声明本地函数，以便消除重复： 12345678910111213141516fun checkNumber(start: Int, end: Int)&#123; fun isThrees(x: Int) = (x % 3 == 0) fun isFives(x: Int) = (x % 5 == 0) for(number in start..end)&#123; if(isThrees(number))&#123; println(\"$number被3整除\") &#125;else if(isFives(number))&#123; println(\"$number被5整除\") &#125;else if(isThrees(number) &amp;&amp; isFives(number))&#123; println(\"$number既能被3整除，也能被5整除\") &#125;else&#123; println(number) &#125; &#125;&#125; 判断条件都换成本地函数了，出错的概率降低了，但是貌似重复 传递number值 多次，能不能再精简？肯定如此，把本地函数放在for循环中，代码如下： 1234567891011121314151617fun checkNumber(start: Int, end: Int)&#123; for(number in start..end)&#123; fun isThrees() = (number % 3 == 0) fun isFives() = (number % 5 == 0) if(isThrees())&#123; println(\"$number被3整除\") &#125;else if(isFives())&#123; println(\"$number被5整除\") &#125;else if(isThrees() &amp;&amp; isFives())&#123; println(\"$number既能被3整除，也能被5整除\") &#125;else&#123; println(number) &#125; &#125;&#125; 但是怎么还有如此多的if-else，还能精简么，当然，代码如下： 1234567891011121314fun checkNumber(start: Int, end: Int)&#123; for(number in start..end)&#123; fun isThrees() = (number % 3 == 0) fun isFives() = (number % 5 == 0) when&#123; isThrees() -&gt; println(\"$number被3整除\") isFives() -&gt; println(\"$number被5整除\") isThrees() &amp;&amp; isFives() -&gt; println(\"$number既能被3整除，也能被5整除\") else -&gt; println(number) &#125; &#125;&#125; 顶层函数（Top-level function）书本上语焉不详，没咋看懂，后续专门了解 命名参数和默认参数命名参数有如下函数： 12val book = \"基于kotlin的Android\"printlin(book.regionMatches(9,\"深入Android\",2,7,true)) 这个函数参数非常多，初看很难理解各个参数的作用，很不直观。但是使用命名参数就可以很直观，调用时把参数名写出来： 12345book.regionMatches(thisOffset = 9, other = \"深入Android\", length = 2, otherOffset = 7, ignoreCase = true) 这种调用可读性就强太多了，虽然稍显啰嗦，不过这点代价是值得的。使用这种写法的时候，kotlin并不强制要求写出所有参数的命名参数，比如以下示例代码（但是有个不成文的规定，如果写了命名参数，就全部写上）。 1delFiles(\"*.apk\",ignoreCase = true,includeDirs = false,recursive = true) 命名参数的另一个好处是可以更换参数的调用位置，如以下两种调用是等价的： 12book.endsWith(suffix = \"1\",ignoreCase = true)book.endsWith(ignoreCase = true,suffix = \"1\") 注：命名参数仅适用于kotlin定义的函数，并不适用java定义的函数，因为java代码编译成字节码时并不总是保存参数名称 默认参数有时候需要给函数的某些参数提供默认值，当用户没有给这个参数值的时候，函数使用默认值，如String的endWith函数： 12book.endsWith(suffix = &quot;1&quot;,ignoreCase = false)book.endsWith(suffix = &quot;1&quot;) 如果需要严格的后缀匹配，可以忽略掉ignoreCase参数的调用，因为ignoreCase的默认值是false。kotlin中可以定义一个或者多个默认参数，在被调用时如果不指定，则使用默认值。比如，可以将默认参数用到构造函数中，从而避免产生更多的二次构造函数(当然，使用在普通函数上的效果也一样)： 12345678//一般写法class User (val name: String, val isVip: Boolean,credits: Int)&#123; constructor(name: String) : this(name,false,0) constructor(name: String,isVip: Boolean) : this(name,isVip,0)&#125;//使用默认参数写法class User(val name: String, val isVip: Boolean = false, credits: Int = 0) 函数操作符操作符重载使用操作符定义函数的能力称为操作符重载，kotlin让操作重载以一个可控的方式使用，有一组固定的操作符名单可以用作函数，但禁止组合使用，要创建这样一个函数，必须冠以operator关键字且必须有对应的英文单词做函数名。注意：操作符仅可定义为成员函数或者扩展函数，以矩阵相加的例子来说明： 12345678910class Matrix(val a: Int, val b: Int, val c: Int, val d: Int)&#123; operator fun plus(m: Matrix): Matrix &#123; return Matrix(a + m.a,b+m.b,c+m.c,d+m.d) &#125;&#125;//使用val m = Matrix(8,8,8,8)val n = Matrix(9,9,9,9)val mn = m.plus(n) 操作符函数不限于相同的类，如我们定义一个Array类可以用”+”添加元素或者用”-“移除元素。这一节看得云里雾里，一知半解，应该不止这么简单的使用，需要另外查资料。 这书看不下去了，不建议大家看了，接下来会直接看《Kotlin实战》","categories":[],"tags":[{"name":"读书笔记-第一季kotlin崛起(次时代Android开发)","slug":"读书笔记-第一季kotlin崛起-次时代Android开发","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E5%AD%A3kotlin%E5%B4%9B%E8%B5%B7-%E6%AC%A1%E6%97%B6%E4%BB%A3Android%E5%BC%80%E5%8F%91/"}]},{"title":"第3、4章： 控制流和字符串","slug":"第一季kotlin崛起-第3、4章","date":"2018-07-27T00:00:00.000Z","updated":"2019-05-01T08:43:16.702Z","comments":true,"path":"2018/07/27/第一季kotlin崛起-第3、4章/","link":"","permalink":"https://glassx.gitee.io/2018/07/27/%E7%AC%AC%E4%B8%80%E5%AD%A3kotlin%E5%B4%9B%E8%B5%B7-%E7%AC%AC3%E3%80%814%E7%AB%A0/","excerpt":"","text":"第三章：控制流if-elseKotlin中if-else可以做表达式的特性，甚至可以实现一个类型不定的变量(虽然官方不建议这么做)： 1val result = if(a &gt; b) \"大于\" else b - a 多元判断针对某个值可能的多种状况，可以使用when语句做一个比较细致的判断： 12345678910111213141516171819202122when(result)&#123; in 1..5 -&gt; &#123; printlin(\"在1到5之间\") &#125; in 1,3,5 -&gt; &#123; printlin(\"是1或者3或者5\") &#125; (9 - 6) -&gt; &#123; printlin(\"值是3\") &#125; is Int -&gt; &#123;//is用于判断是某种类型 printlin(\"是整数\") &#125; else -&gt; &#123; printlin(\"其他情况\") &#125;&#125; 第四章——字符串和字符 Kotlin中字符串和字符相关的方法非常丰富，字符串可以通过“+”连接，也可以往字符串中插入变量创建字符串“模板”。字符串还有常用的2个功能，判断字符串为空(isEmpty())和字符串中字符的数目(count()或者length)，字符串的一些例子如下： 123456789101112131415161718192021222324252627282930313233343536println(name.count())//字符串中字符数目println(name.isEmpty())//是否为空println(name.length)//这个length不是方法，而是“成员”//以下方法可以获取指定位置的字符println(name.get(3))//或println(name[3])//或println(name.elementAt(3))//获取头或者尾println(name.first())//获取第一个字符println(name.last())//获取最后一个字符//还有subString用法println(name.substring(3))//要注意，这是去掉字符串前面4个字符//取字符串中间某一段println(name.substring(5,10))//索引加substring使用println(name.substring(name.indexOf(\"好\"))) //去掉“好”字之前的字符//截取 “好”以及其后面一个字符println(name.substring(name.indexOf(\"好\"),2))//最后一个索引println(name.lastIndex(\"好\"))//indices显示索引范围println(name.indices) //获得索引区间，这是个属性，不用给任何参数，结果打印： 0..6//是否包含某个字符或者子串println(name.contains(\"google\")) //返回true或者false//判断字符串内容是否相同，以下两种写法都可以println(name1 == name2)println(name1.contentEquals(name2)) 上述代码中，两个方法是带括号”()”的，而length不带括号。带括号的称为方法或者函数；不带括号的称为属性成员，是变量。关于字符串操作，还有专业的“舍弃”系列，一般以drop开头，用它去掉字符串中的子串，有时候比substring更方便，不用跟索引打交道，看看例子： 123456789101112//舍弃前3个字符println(name.drop(3)) //舍弃后3个字符println(name.dropLast(3))//有条件的舍弃，去掉字符串开头的空格，中间的不会被去掉val name = \" 我前面有空格 哈哈\"println(name.dropWhile &#123;it.isWhitespace()&#125;) //结果：我前面有空格 哈哈//当然，还能接连操作println(title.dropWhile &#123;it.isWhitespace()&#125;. dropLastWhile &#123;it = '哈' || it.isWhitespace()&#125; // 结果：我前面有空格 上述看到，舍弃操作可以无限连接，因为drop系列完成后还是一个string，其中dropWhile 后面的 “{}” 里面的代码是判断条件，it是系统提供的变量，指的是字符串中单个的字符，”{}”本身做了一个循环，检查字符串中的每一个字符。”||”还是与Java中一样，是或操作。跟丢弃系列相对的是捡取系列，以take开头： 123456789//取前6个println(name.take(6))//取后7个println(name.takeLast(7))//顺带提一下替换功能，跟Java一样println(name.replace(\"哈哈\",\"嘎嘎\"))//这里要注意下，单个字符用单引号包含println(name.replace('哈','嘎'')) 转义字符处理：Java中会对字符串中的“控制字符”进行特殊处理，这才有了转义字符，如 println(“\\n\\r\\&quot;&#39;“) 只会打印出 &quot;‘ ，这样写起来比较麻烦，当然Kotlin保留了这个功能，并且创新地使用三个引号来解决这个问题： 12345val name = \"\"\"\\\"'\"\"\"println(name) //会打印：\\\"'//顺便记下这种用法，为每个字符之间插入一个逗号name.toCharArray().forEach &#123;println(it + \"，\")&#125; //又用到 it 字符字符可以判断是否是数字或者文字： 123456789101112println(five.isDigit())println(five.isLetter())//字符的上一个/下一个字符println(five - 1)println(five + 1)//转成编码println(five.toInt())//“我”到“你”之间有多远println('我'.until('你')) //打印结果： 我..佟 ，即说明 '你'之前的那个字是 '佟'","categories":[],"tags":[{"name":"读书笔记-第一季kotlin崛起(次时代Android开发)","slug":"读书笔记-第一季kotlin崛起-次时代Android开发","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E5%AD%A3kotlin%E5%B4%9B%E8%B5%B7-%E6%AC%A1%E6%97%B6%E4%BB%A3Android%E5%BC%80%E5%8F%91/"}]},{"title":"第2章： kotlin基础","slug":"第一季kotlin崛起-第2章","date":"2018-07-22T04:00:00.000Z","updated":"2019-05-01T08:39:23.670Z","comments":true,"path":"2018/07/22/第一季kotlin崛起-第2章/","link":"","permalink":"https://glassx.gitee.io/2018/07/22/%E7%AC%AC%E4%B8%80%E5%AD%A3kotlin%E5%B4%9B%E8%B5%B7-%E7%AC%AC2%E7%AB%A0/","excerpt":"","text":"Kotlin跟Java还是有很大区别的，看这一章的时候，时不时会带来惊喜： 还能有这操作 ？？？ 常量与变量写法（常量一旦赋值，就不能改变，不能二次赋值）： 常量： val constant = 123; 变量： var a = 3; 整数类型和推断类型定义一个整数型变量的形式(注意是 Int ，首字母是大写的)： var num: Int = 3; 但是Kotlin有优秀的推断系统，”:Int”可以省去不写，编译器就“知道”这是整数类型，这与C/C++/JAVA/C#等强制标明变量类型非常不同。这也是现代编程语言的一大进步，Swift等语言都吸收了这个优点，从而让语言本身变得非常简洁。定义其他类型的数字例子： 123456val 整数 = 1237val 长整数 = 12666Lval 双精度浮点数 = 22.64val 单精度浮点数 = 12.34Fval 八进制数 = 0xACFval 二进制数 = 0b01010111 注意长整数数字后有后缀L，单精度小数后缀是F，如果不写，默认整数类型是Int，小数类型是Double，八进制和二进制数字分别以前缀 0x和0b开头。 字符串模板：就是指把一个变量插入到文本的技术，一般类似这样： “${}”，”${}”是一个变量的占位符，一个例子如下： 12345fun main(args: Array&lt;String&gt;)&#123; var run = 5 run = 6 print(\"每天坚持跑$&#123;run&#125;公里\")&#125; Tips：如果整数位数太多，可以用下划线分割出千分位或者万分位，如： var 房贷 = 150_0000 //与 var 房贷 = 1500000等价。 Kotlin不支持自动扩展数字范围，转换必须手动进行，每一种数字都有一个转换成其他数字类型的函数，例如，把普通整数转换成长整数，可以用如下代码： 123val intNum = 9999val longNum = intNum.toLong();val doubleNum = intNum.toDouble(); 上面提到了二进制数字，相关的位运算操作在Kotlin中也是支持的，例如左移右移、逻辑与/或运算、异或 和 取反运算，与Java不同的是，这些不是内建运算符，而是用中缀函数来代替的： 1234567val 左移二位 = 1 shl 2val 右移三位 = 1 shr 3val 无符号右移二位 = 1 ushr 2val 逻辑与 = 1 and 0x00001111val 逻辑或 = 1 or 0x00001111val 异或 = 1 xor 0x00001111val 取反 = 1.inv() 注意，取反不是中缀操作符，而是一个一元操作符。 小数Kotlin中小数现在默认也是Double类型（双精度），而原先的Float类型处于兼容目的而保留，但官方不建议使用。可以用Double类型的toInt将小数截成整数，注意不是四舍五入，而是把小数部分完全砍掉，如 3.14进行toInt()的结果是 3。 类型安全类型安全是指，变量一旦定义，其类型不可更改。了解C/Java语言的可能非常不适应，因为这些语言要求把类型写出来，而没有类型推断这个概念。JavaScript语言也是不写类型的，这是为了求快，语法并不严谨，而且它不但类型不用写，并且变量的类型可以任意改变，这留下了安全隐患（微软的TypeScript就是一种安全的JavaScript改进）。这个缺陷在Kotlin和Swift中得到了平衡，这两种语言同时引入了类型推断和类型安全的概念。如以下代码Kotlin会提示错误： 12var 电费 = 3.6电费 = \"五毛\" 布尔型布尔型：Boolean。Kolin中布尔型只有2个值：true 和 false。 1234567var isVip = trueif(isVip)&#123; print(\"欢迎vip会员！\")&#125;else&#123; print(\"请考虑充值成为vip！\")&#125; 元组通常情况下，变量只带一个值，但有时候为了处理更精致简单，必须把描述进行分割。例如，课程 《3天免费学会Kotlin》，这个标题可以分解成学时、动作、技术名、学费等，这时候元祖就可以派上用场了。元组(Tuple)，可以把多个值同时赋值给一个变量，或者叫给多个变量同时赋值。不过Kotlin中只有二元组(Pair)和三元组(Triple)，也就是最多一次容纳3个值。直接看个例子比较直观： 12345val 课程 = Triple(3,\"学会\",\"Kotlin\")val 费用 = Pair(\"学费\",0)print(\"$&#123;课程.first&#125;天$&#123;课程.second&#125;$&#123;课程.third&#125;\")print(\",$&#123;费用.first&#125;$&#123;费用.second&#125;元！\") 运行结果是：3天学会Kotlin，学费0元！ 可空类型——nullable所有“实体的”类型与空的组合，称为可空类型，写法上是在原类型名后紧跟一个问号:Int?、String?、Boolean?，这里”?”指空值null，表示什么也没有。用法示例如下（以个人资料为例）： 12var addr: String? = \"清华大学\"var sex: Boolean? 假设这是某人的淘宝账号个人资料一部分，addr是选填地址信息，虽然地址可以不填，但买东西的时候要填写；虽然性别sex是二选一的，但是对于业务不重要，所以也可以写成可空类型。定义好之后，使用场景可以用如下代码表示： 123456sex = falseif(sex != null &amp;&amp; sex == true)&#123;//还需要先判空 print(\"先生，你好\")&#125;else&#123; print(\"美女，全场八折\")&#125; 还有，如果导入多个不同包的同名类，可以给某些导入起一个别名，如下所示： import com.test.MyKotlinProject.Bookimport com.myspace.Book as SpaceBook 异常处理和类初始化Kotlin中异常处理与Java几乎一模一样，只有一条不同，即Kotlin中所有异常都不是必检的。所谓必检异常，是指必须定义成方法的一部分或者在方法内部处理，一个典型例子就是IOException。Kotlin中，因为所有异常都不是必检的，所以异常不必成为函数的组成部分。如果要捕捉异常，跟java一样，使用try-catch： 12345try&#123; var byte = input.read();&#125;catch(e: IOException)&#123; println(\"读取文件错误，因为：$&#123;e.message&#125;\")&#125; 关于类初始化，Java语言一般会用一个new关键字来创建类的实例，Kotlin中移除了new，对待构造函数的调用和普通函数一样，这样就不需要new了，如下所示： 12val file = File(\"/usr/bin/ruby\")val date = Date(20170702) 引用相等和结构相等要检查两个引用是否引用相等，用“===”(类似Java的 ==)，或者用“!==”来说明不等，用”==”来检查是否结构相等（类似于java中的equals方法）： 12345678val file1 = File(\"/usr/bin/ruby\")val file2 = File(\"/usr/bin/ruby\")val sameRef = (file1 === file2)println(sameRef)//打印false，因为 file1 与 file2 不是同一个对象val sameStruct = (file1 == file2)println(sameRef) //打印true，因为两个File对象的指定的文件路径是一样的 区间（Range）一个区间是有一个起始值和终止值得间隔。任意可以进行比较大小的类型都可以创建一个区间，使用”..”操作符，这里的区间是数学意义上的全闭区间，包括起始和终止边界的值。以下是例子： 12val a到z = \"a\"..\"z\"val 一到一百 = 1..100 一旦建好，就可以用in操作来测试指定的一个值是否包含在其中： 12val chars = \"a\"..\"z\"val d在其中 = \"d\" in chars 围绕着区间还有更深入的函数可以用，如downTo()可以创建一个倒序排列的区间，rangeTo可以生成区间： 12val 倒计时 = 10.downTo(0)val 一到一百 = 1.rangeTo(100) 区间创建后可以更改，更改后的区间生成一个新区间，还可以用reversed()函数进行翻转。还可以更改区间中的每一个单向前进的幅度，即步进（step）： 1234567val 一到一百 = 1.rangeTo(100)//一到一百.reversed() 如果添加这句代码，那么就是打印 99,98...1val 一到一百奇数 = 一到一百.step(2)for(i in 一到一百奇数)&#123; print(i) //会打印 1,3,5,7，...99&#125; 控制流作为表达式令常规编程语言程序员大跌眼镜的是，Kotlin中控制流语句可以做表达式，一般的语言 if-else 、try-catch等控制流表达式不会返回任何值，如java： 12345if(x == 0)&#123; isZero = true;&#125;else&#123; isZero = false;&#125; 但是在Kotlin中，if-else 与try-catch 控制流本身就是表达式。这种变化可以可以省了很多重复的代码模板，省了一些变量的声明，来看看例子： 1234567891011121314val a = 5val b = 3val isLarger = if(a &gt; b) true else false //用if语句做表达式的时候，必须包含else语句，否则编译器无从得知if为else的情况print(isLarger) //打印true//或者val readSuccess = try&#123; readFile(/usr/bin/ruby.md) true&#125;catch(e: IOException)&#123; false&#125;print(readSuccess) //代码try中代码执行顺利打印true， Kotlin中的 when语句是Java中的switch语句的强力升级版： 12345when(a)&#123; 0 -&gt; println(\"a是0\") 1 -&gt; println(\"a是1\") else -&gt; println(\"a不是0或1\")&#125; when 的最后一个分支else是所有其他情况外的处理，这样可以把a的所有情况进行列举处理。当然，when语句也是可以作为值赋予给变量的： 1234val isZero = when(a)&#123; 0 -&gt; true else -&gt; false&#125; 更进一步的用法，常量可以合并在同一条分支上： 1234val isZeroOrOne = when(a)&#123; 0,1 -&gt; true //0 或者1 都返回true else -&gt; false&#125; 与switch不同的是，when不限于对常量的每一种情况判断，还可以加上函数，当函数被调用后满足分支条件，这个分支就被执行了： 12345678fun isPositive(x: Int): Boolean&#123; return when(x)&#123; Math.abs(x) -&gt; true else -&gt; false &#125;&#125;println(isPositive(2)); Math.abs是数学库中的绝对值函数，这个方法用来判断一个数字是否是正数，如果输入的值与绝对值之后的值相等，说明是正数，返回true，否则返回false。当然，这段代码还可以简化： 12345678fun isPositive(x: Int) = //这里加个等号就没有返回值类型了 when(x)&#123; Math.abs(x) -&gt; true else -&gt; false &#125;println(isPositive(2)); 当然，这也适用于区间： 123456789fun cardNum(x: Int): Boolean&#123; return when(x)&#123; in -9..9 -&gt; true //in arrayOf(1,2,3,4,5,6) -&gt; true //或者这样 else -&gt; false &#125;&#125;println(cardNum(2)); 最后，when还可以用智能转换类型，智能转换可以让编译器在运行时校验变量类型： 123456fun preIsKotlin(any:Any): Boolean&#123; return when(any)&#123; is String -&gt; any.startWith(\"Kotlin\") else -&gt; false &#125;&#125; 上述的函数参数是Any类型，所有对其类型实际是无任何限制的，这样类型只能在运行时检测，如果遇到输入的是String类型（is String，is的用法感觉有点像Java中的 instanceOf ），则判断String是否以Kotlin开头，如果是就返回true，不满足以上条件的都返回false。 无参数的when语句，类似多分支的if-else 1234567fun noParamWhen(a: Int,b: Int)&#123; when&#123; a &lt; b -&gt; println(\"a 小于b\") a &gt; b -&gt; println(\"a 大于b\") else -&gt; println(\"a 等于b\") &#125;&#125; 函数返回Kotlin的函数返回前面已经演示过： 123fun addNum(a: Int,b: Int): Double&#123; return a + b;&#125; 默认情况下，return会从最近的嵌套函数或者匿名函数返回，所以，如果在一个嵌套函数内，return只会返回最内层的函数： 12345678fun maxNum(a: Int,b: Int,c: Int): Int&#123; fun maxNum(a: Int,b :Int): Int&#123; if(a &gt; b) return a else return b &#125; return maxNum(maxNum(a,b),maxNum(b,c))&#125; 在这个优点强行重名刻意为之的例子里，最后一个return调用的是最近的maxNumber()嵌套函数，如果最内层的函数是一个匿名函数，return在其中只会退出匿名函数而已： 123456789fun lessThanNine()&#123; val list = listOf(-1,0,2,5,99) list.forEach(fun(x)&#123; if(x &lt; 9) println(x) else return &#125;) println(\"此行会继续执行\")&#125; 类型层级Kotlin中最上层的类型是Any，意为任意类型，是所有类型的父类，这与Java的Object类型相似。Any类型定义了众所周知的toString 、hashCode以及equals方法。Unit类型相当于Java中的void，但是二者间有微妙的区别，void不是一个类型，而是一个特殊的个例，Unit是一个合适的类型，如此一来，Kotlin中所有的函数都可以定义一个返回值了（至少是个Unit型）。另一个显著区别于Java的地方是增加了一个最底层的类型——Nothing，它是所有类型的子类，后面可以详细了解这玩意儿。 循环Kotlin支持while和for循环。while循环和C语言一模一样。for循环用于迭代任何一个预定义或者扩展了iterator的函数。所有集合类型都提供了这个函数： 123456789101112131415161718192021222324val listOne = listOf(1,2,3,4) //链表val setOne = setOf(1,2,3,4) //集合val arrayOne = arrayOf(1,2,3,4) //数组val oneToTen = 1..10;//区间val slogan = \"我爱Kotlin\" //字符串，String中已经实现了iterator扩展函数，所以for循环可以迭代其中的单个字符for(k in listOne)&#123; println(k)&#125;for(k in setOne)&#123; println(k)&#125;for(k in arrayOne)&#123; println(k)&#125;for(k in oneToTen)&#123; println(k)&#125;for(char in slogan)&#123; println(char)&#125; 注意循环中in操作符，经常用于for循环中。","categories":[],"tags":[{"name":"读书笔记-第一季kotlin崛起(次时代Android开发)","slug":"读书笔记-第一季kotlin崛起-次时代Android开发","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E5%AD%A3kotlin%E5%B4%9B%E8%B5%B7-%E6%AC%A1%E6%97%B6%E4%BB%A3Android%E5%BC%80%E5%8F%91/"}]},{"title":"第13章： 继续进阶——你还应该掌握的高级技巧","slug":"第一行代码（第二版）-第十三章","date":"2018-07-15T10:00:00.000Z","updated":"2019-05-01T08:44:39.809Z","comments":true,"path":"2018/07/15/第一行代码（第二版）-第十三章/","link":"","permalink":"https://glassx.gitee.io/2018/07/15/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/","excerpt":"","text":"全局获取Context技巧主要就是自定义 Application ，在 Application 中实现全局获取Context，代码如下： 123456789101112public class MyApplication extends Application&#123; private static Context mContext; @Override public void onCreate()&#123; mContext = getApplicationContext(); &#125; public static Context getContext()&#123; return mContext; &#125;&#125; 使用Intent传递对象Intent的putExtra()方法传递数据的时候，支持的数据类型是有限的，虽然常用的一些数据类型它都支持，但是当你想传递一些自定义对象的时候，就会无从下手。其实使用Intent来传递对象通常有两种实现方式：Serializable和Parcelable。 Serializable 方式Serializable是序列化的意思，表示将一个对象转换成可存储或可传输的状态。至于序列化的方法也很简单，只需要实现Serializable这个接口就行，如以下的Person类： 12345678910111213141516171819202122232425public class Person implements Serializable&#123; //TODO 这行在书中是没有的，实际上我们得加上，用于区分版本这个类的版本，不同的这个id不能反序列回来 //如果不写，系统会自动生成，但是如果改动了里面的属性（增加或者减少或者更改了属性），系统生成的这个值会改变 //（注意，如果没有实质改动（如只是改变属性的位置，或者在类中添加了空格）则值不会改变 private static final long serialVersionUID =1L; private String name; private int age; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getAge()&#123; return age; &#125; public void setAge(int age)&#123; this.age = age; &#125;&#125; 如果要在Activity之间传递的话，只需要简单的几行代码即可： 123456Person person = new Person();person.setName(\"Tom\");person.setAge(\"20\");Intent intent = new Intent(this,SecondActivity.class);intent.putExtra(\"person_data\",person);startActivity(intent); 可以看到我们穿件了Person实例，之后直接将它传入putExtra()方法中了，只是因为Person实现了Serializable接口，所以才可以这么写。接下来要在SecondActivity中获取这个对象也很简单： 1Person person = (Person)getIntent().getSerializableExtra(\"person_data\"); 这里调用了getSerializableExtra方法来获取通过参数传递过来的序列化对象，接着再向下转型得到Person对象，就成功实现了Intent传递对象。 Parcelable方式除了Serializable之外，使用Parcelable也可以实现相同的效果，不过不同于将对象进行序列化，Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现了传递对象的功能了。下面修改下Person类的代码： 12345678910111213141516171819202122232425262728293031323334public class Person implements Parcelable&#123; private String name; private int age; 。。。 @Override public int describeContents()&#123; return 0; &#125; @Override public void writeToParcel(Parcel dest,int flags)&#123; dest.writeString(name);//写出name dest.writeInt(age);//写出age &#125; public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;()&#123; @Override public Person createFromParcel(Parcel source)&#123; Person person = new Person(); person.name = source.readString();//读取name person.age = source.readInt(); return person; &#125; @Override public Person[] newArray(int size)&#123; return new Person[size]; &#125; &#125;；&#125; Parcelable 的实现方式要稍微复杂些，首先继承 Parcelable 接口，这样就必须重写 describeContents() 和 writeToParcel() 两个方法。 describeContents 中直接返回0即可，writeToParcel中需要将Person类中的字段一一写出。除此之外，还得再Person类中提供一个 CREATOR 常量。接下来，我们仍然可以通过前面相同的代码来传递Person对象，只不过在SecondActivity中获取对象的时候需要稍加改动： 1Person person = (Person)getIntent().getParcelableExtra(\"person_data\"); 一般来说，Serializable方式比较简单，但是这会把整个对象序列化，因此效率比Parcelable低一些，所以更加推荐Parcelable方式。 定制自己的日志工具实用性不太强，公司项目有更强大的日志工具，因此 略 调试Android程序已经掌握，略 创建定时任务Android中的定时任务一般有两种实现方式：一是Java API中的Timer类，二是Android中的Alarm机制。但Timer类不太适用于哪些需要长期在后台运行的定时任务，因为为了能让电池更加耐用，每种手机都会有自己的休眠策略，Android手机会在长时间不操作的情况下自动让CPU进入睡眠状态，这可能导致Timer中的定时任务无法正常运行。而Alarm则具有唤醒CPU功能，可以保证大多数情况下需要执行定时任务的时候CPU都能正常工作。注意，这里唤醒CPU和唤醒屏幕完全不是一个概念，千万不要混淆。 Alarm机制Alarm机制用法并不复杂，主要借助于AlarmManager实现，跟NotificationManager有点类似，获取实例的方法如下所示： 1AlarmManager manager = (AlarmManager)getSystemService(Context.ALARM_SERVICE); 接下来使用set()方法就可以设置一个定时任务了，比如想设定一个任务在10秒钟后执行： 12long triggerAtTime = SystemClock.elapsedRealtime() + 10 * 1000;manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,triggerAtTime,pendingIntent); 第一个参数是整型参数，用于指定AlarmManager的工作类型，有4种值可选：ELAPSED_REALTIME(让定时任务的触发时间从系统开机开始算，但不会唤醒CPU)、ELAPSED_REALTIME_WAKEUP（表示定时任务从系统开机开始算起，但会唤醒CPU）、RTC（让定时任务触发时间从1970年1月1日0点开始算起，但不会唤醒CPU）、RTC_WAKEUP(让定时任务触发时间从1970年1月1日0点开始算起，但会唤醒CPU)。可以使用SystemClock.elapsedRealtime()获取到系统开机至今所经历的时间的毫秒数。Systemt.currentTimeMillis()可以获取到1970年1月1日0点至今所经历的毫秒数。第二个参数就是定时任务触发的时间，如果第一个参数是ELAPSED_REALTIME或者ELAPSED_REALTIME_WAKEUP，则传入开机至今时间加上延迟执行的时间；如果是RTC或者RTC_WAKEUP，则传入1970年1月1日0点至今的时间再加上延迟执行的时间。第三个参数不多说。 那么如果要实现一个长时间在后台定时运行的服务要如何做呢，其实只要建立一个普通服务，然后将触发定时任务的代码写到onStartCommand()方法中，如下所示： 123456789101112131415161718192021222324252627public class LongRuningService extends Service&#123; ... @Override public int onstartCommand(Intent intent,int flags,int startId)&#123; //TODO 之所以要在子线程里面执行逻辑操作，是因为逻辑操作需要耗时，放在主线程中可能会对定时任务准确性产生轻微影响。 new Thread(new Runnable()&#123; @Override public void run()&#123; //执行具体的逻辑操作 &#125; &#125;).start(); AlarmManager manager = (AlarmManager)getSystemService(ALARM_SERVICE); int anHour = 60 * 60 * 1000;//一小时 long triggerAtTime = SystemClock.elapsedRealtime() + anHour; Intent i = new Intent(this,LongRunningService(this,0,i,0)); //TODO 注意，从4.4开始，Alarm任务的触发将会变得不准确，有可能会延迟一段时间后任务才能得到执行，这不是bug， //而是系统在耗电方面的优化，系统会自动检测目前有多少Alarm任务，然后将触发时间相近的几个任务放在一起执行，可以 //大幅度减少CPU被唤醒的次数，从而延长电池使用。如果要求Alarm任务执行时间必须准确无误，则使用 setExact()方法替代 //下面的set()方法。 manager.set(AlarmManager.ELAPSED_REALTIME_WEKEUP,triggerAtTime,pi); return super.onStartCommand(intent,flags,startId); &#125;&#125; 这样，一旦启动了LongRuningService，就会设定一个定时任务，一个小时后会再次启动LongRuningService，形成一个永久循环。 Doze模式在Android 6.0中，google加入了Doze模式，及大幅度延长电池使用寿命。主要表现为：如果设备未插电源，处于静止（7.0后删除这条件），并且屏幕关闭了一段时间之后，就会进入Doze模式，系统会对CPU、网络、Alarm等活动限制，当然，系统还会间歇性地退出Doze一小段时间，在这段时间，应用可以去完成他们的同步操作、Alarm任务等。如下图所示： 可以看到，随着设备进入Doze模式的时间越长，间歇性退出Doze模式的时间间隔也会越来越长，因为如果设备长时间不使用的话，没必要频繁退出Doze。以下列出Doze模式下有具体哪些功能会收到限制： 网络访问被禁止 系统忽略唤醒CPU或者屏幕操作 系统不再执行WIFI扫描 系统不再执行同步服务 Alarm任务将会在下次退出Doze模式时候执行 不过，如果你真有非常特殊需求，要求Alarm任务在Doze模式也必须正常执行，可以调用AlarmManager的setAndAllowWhileIdle()或setExactAcnAllowWhileIdle()方法就能让定时任务即使在Doze模式下也能正常执行了，这两个方法之间的区别和set()、setExact()方法之间的区别一样。 *** 多窗口模式 在一个屏幕上，同时显示两个app界面。切换到多窗口模式，Activity会经历重新创建的过程。其实这是正常现象，进入多窗口模式后，Activity的大小发生了比较大的变化，此时默认会重新创建活动的。除此之外，像横竖屏也会重新创建活动。如果此时去操作另一个窗口，则当前窗口会执行onPause，而另一个窗口会执行onResume，这很好理解，因为两个窗口都是可见的，所以只会执行到onPause即可。因此，在考虑多窗口模式下，用户仍然可以看到处于暂停状态的应用，那么像视频播放器之类的应用应该在此时能够继续播放视频才对，因此最好不要在Activity的onPause()方法中去处理播放器的暂停逻辑，而应该在onStop()方法中处理，并且在onStart()方法中恢复视频播放。另外，针对进入多窗口时活动会被重新重新创建，如果想改变这一默认行为，可以在AndroidManifest.xml中进行配置： 123&lt;activity android:name=\".MainActivity\" android:configChanges=\"origintation|keyboardHidden|screenSize|screenLayout\" 这样不管进入多窗口模式还是横竖屏切换，Activity都不会被重新创建，而是会将屏幕发生变化的事件通知到Activity的onConfigurationChanged()方法中，因此，如果有这方面的需求，只需要重写onConfigurationChanged()即可。 当然，如果想禁用多窗口模式，只需要在 AndroidManifest.xml 中的 或者 标签中加入如下属性即可： 1android:resizeableActivity=[\"true\" | \"false\"] 需要注意的是，这个属性只有在项目的targetSdkVersion指定成24或者更高的时候才会有用。不过Android规定，如果targetSdkVersion小于24,并且Activity不允许横竖屏切换，那么应用也将不支持多窗口模式，如果不允许应用横竖屏切换，只需要在AndroidManifest.xml中添加如下配置： 1android:screenOrientation=[\"portrait\" | \"landscape\"]","categories":[],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第10章： 后台默默的劳动者-探究服务","slug":"第一行代码（第二版）-第十章","date":"2018-07-09T10:00:00.000Z","updated":"2019-05-01T08:44:48.148Z","comments":true,"path":"2018/07/09/第一行代码（第二版）-第十章/","link":"","permalink":"https://glassx.gitee.io/2018/07/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%8D%81%E7%AB%A0/","excerpt":"","text":"服务非常适合执行那些不需要和用户交互还要求长期运行的任务。要注意的是，服务并不是运行在一个独立的进程当中，而是依赖于创建服务时所在的应用程序进程，当应用程序被杀掉时，所有依赖该进程的服务也会停止。不要被服务的后台概念迷惑，实际上服务并不会自动开启子线程，所有的代码都是默认运行在主线程中。因此在使用服务时要注意主线程被阻塞的情况。 服务的基本用法新建类MyService继承Service，要求重写其唯一一个抽象方法 onBind 。一般又要重写onCreate（服务创建时调用）、onStartCommand（每次服务启动的时候调用）以及onDestroy（服务销毁时调用）方法，它们是服务中最常用的3个方法。如果我们希望服务已启动就立刻执行某个动作，就可以将逻辑写在onStartCommand方法里。另外，还需要在AndroidManifest文件中做如下声明（四大组件都得声明）： 12345&lt;service android:name=\".MyService\" android:enabled=\"true\" android:exported=\"true\"&lt;/service 其中export属性表示是否允许除了当前程序之外的其他程序访问这个服务，enable表示是否启用这个服务。 启动和停止服务通过以下代码可以简单地实现启动和停止服务： 12345678910111213@Overridepublic void onClick(View v)&#123; switch(v.getId())&#123; case R.id.start_service: Intent startIntent = new Intent(this,MyService.class); startService(startIntent); break; case R.id.stop_service: Intent startIntent = new Intent(this,MyService.class); stopService(startIntent); break; &#125;&#125; 构建出Intent对象，使用startService即可启动MyService，会依次执行onCreate-&gt;onStartCommand；同理，使用stopService即可停止，onDestroy就会执行。如果在service里面，那么使用stopSelf即可停止自己。由于刚才点击start的时候，onCreate和onStartCommand都执行了，也许你会疑惑，这两个方法到底有什么区别呢？其实onCreate方法在服务第一次创建时调用，而onStartCommand则在每次启动服务时调用，由于是第一次创建，所以两个方法都执行了，如果多次点击start service按钮，那就只有onStartCommand方法执行了。 活动和服务通信上一节虽然在活动中启动和停止了服务，但是启动服务之后，活动与服务基本上就没关系了，没法控制服务。如果希望控制服务执行，比如MyService提供下载功能，则希望可以决定什么时候开始下载，以及查看下载进度等，主要的思路是创建一个专门的Binder对象来对下载功能进行管理，然后通过ServiceConnection来实现通信。简易代码如下： 12345678910111213141516171819//service代码public class MyService extends Service&#123; private DownloadBinder mBinder = new DownloadBinder(); class DownloadBinder extends Binder&#123; public void startDownload()&#123; &#125; public int getProgress()&#123; return 0; &#125; &#125; @Override public IBinder onBind(Intent intent)&#123; return mBinder; &#125;&#125; 12345678910111213141516171819202122232425//Activity代码private ServiceConnection connection = new ServiceConnection()&#123; @Override public void onServiceDisconnected(ComponentName name)&#123;//解除绑定时调用 &#125; @Override public void onServiceConnected(ComponentName name,Ibinder service)&#123;//绑定时调用 downloadBinder = (MyService.DownloadBinder)service; downloadBinder.startDownload(); downloadBinder.getProgress(); &#125;&#125;@Overridepublic void onClick(View v)&#123; switch(v.getId())&#123; case R.id.bind_service: Intent bindIntent = new Intent(this,MyService.class); bindService(bindIntent,connection,BIND_AUTO_CREATE);//绑定服务 break; case R.id.unbind_service: unbindService(connection);//解绑服务 break; &#125;&#125; 服务生命周期一旦在任何位置调用了Context的startService方法，相应的服务就会启动，如果服务还没创建过，onCrete先执行，在执行onStartCommand，如果已经创建了，则只会执行onStartCommand了，启动后该服务一直运行，直到调用stopService或者stopSelf为止。虽然多次启动服务onStartCommand会被多次执行，但是服务只会存在一个实例。另外，还可以调用Context的bindService来获取一个服务的持久连接，这时会回调服务的onBind方法，类似地，如果之前没创建过该服务，就会先执行onCreate在执行onBind，之后，调用方可以获取到onBind方法里返回的IBinder对象实例，就能自由和服务进行通信。调用unbind方法，也会执行Myservice的onDestroy方法，即销毁服务。 服务的更多技巧使用前台服务由于服务运行在后台，因此其系统优先级比较低，当出现内存不足的情况时，容易被回收，这就考虑使用前台服务。前台服务和普通服务最大的区别在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉可以看到更详细的信息，非常类似于通知效果。其主要实现方法如下： 123456789101112131415161718public class MyService extends Service&#123;... @Override public void onCreate()&#123; super.onCreate(); Intent intent = new Intent(this,MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this,0,intent,0); Notification notification = new NotificationCompat.Builder(this) .setContentTitle(\"title\") .***//其他配置省略了 .build(); //没有像普通Notification一样使用NotificationManager将通知展示出来，而是使用 //startForeground方法 **startForeground(1,notification);//与普通Notification和普通的Service区别的关键在这里** &#125;&#125; 使用IntentService服务中的代码都是默认运行在主线程当中的，如果直接在服务里处理耗时操作，很容易出现ANR。当然，为了避免这种情况，你可以在onStartCommand方法中new 一个Thread来处理耗时逻辑，写法并不复杂，但是程序员容易忘记开启线程或者忘记调用stopSelf。为了简单地创建一个异步的、能够自动停止的服务，Android专门提供了IntentService，在继承Intentservice之后，你可以直接在它的 onHandleIntent方法中执行耗时操作（这是在新的线程里面，可以通过Thread.currentThread().getId()方法查看线程ID，跟主线程不是同一个），在耗时操作执行完毕之后，这个IntentService会自动调用onDestroy停止。 服务的最佳实践——完整版下载示例直接上代码吧，多说无益。用于执行异步任务的AsyncTask： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150//这里AsyncTask传入3个参数类型，第一个泛型指定为String，表示在执行AsyncTask时需要传入一个//字符串给后台任务，第二个指定为Integer，表示使用整型数据作为进度显示单位，第三个泛型Intege则表示使用整数型//数据来反馈执行结果public class DownloadTask extends AsyncTask&lt;String,Integer,Integer&gt;&#123; public static final int TYPE_SUCCESS = 1;//成功 public static final int TYPE_FAILED = 2;//失败 public static final int TYPE_PAUSED = 3;//暂停 public static final int TYPE_CANCELED = 4;//取消 private DownloadListener downloadListener = null; private boolean isPaused = false; private boolean isCancled = false; private int lastProgress; public DownloadTask(DownloadListener listener)&#123; downloadListener = listener; &#125; @Override protected Integer doInBackground(String... params) &#123;//用于后台执行下载逻辑 InputStream is = null; RandomAccessFile savedFile = null; File file = null; try&#123; long downloadedLength = 0;//记录已经下载的文件长度 String downloadUrl = params[0]; String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(\"/\")); //SD卡的Download目录 String directory = Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_DOWNLOADS).getPath(); file = new File(directory + fileName); //如果已经存在要下载的文件了，则读取已经下载的字节数，这样就可以在后面启动端点续传功能 if(file.exists())&#123; downloadedLength = file.length(); &#125; //获取文件总长 long contentLength = getContentLength(downloadUrl); if(contentLength == 0)&#123; return TYPE_FAILED; &#125;else if(contentLength == downloadedLength)&#123; //已下载的字节和总字节相等，说明已经下载完成 return TYPE_SUCCESS; &#125; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() //断点下载，指定从哪个字节开始下载 .addHeader(\"RANGE\",\"bytes=\" + downloadedLength + \"-\") .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if(response != null)&#123; //以下读取服务器响应的数据，并使用Java文件流方式，不断从网络读取数据，不断写到本地，知道 //文件全部下载完成为止 is = response.body().byteStream(); savedFile = new RandomAccessFile(file,\"rw\"); savedFile.seek(downloadedLength);//跳过已下载的字节 byte[] b = new byte[1024]; int total = 0; int len; while ((len = is.read(b)) != -1)&#123; if(isCancled)&#123; return TYPE_CANCELED; &#125;else if (isPaused)&#123; return TYPE_PAUSED; &#125;else &#123; total += len; savedFile.write(b,0,len); //计算已下载的百分比 int progress = (int) ((total + downloadedLength) * 100/contentLength); publishProgress(progress); &#125; &#125; response.body().close(); return TYPE_SUCCESS; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (is != null)&#123; is.close(); &#125; if (savedFile != null)&#123; savedFile.close(); &#125; if (isCancled &amp;&amp; file != null)&#123; file.delete(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; return TYPE_FAILED; &#125; @Override protected void onProgressUpdate(Integer... values) &#123;//用于在界面上更新当前的下载进度 int progress = values[0]; if (progress &gt; lastProgress)&#123; downloadListener.onProgress(progress); lastProgress = progress; Log.e(\"进度\",progress+\"\"); &#125; &#125; @Override protected void onPostExecute(Integer status) &#123;//用于通知最终的下载结果 switch (status)&#123; case TYPE_SUCCESS: downloadListener.onSuccess(); break; case TYPE_FAILED: downloadListener.onFailed(); break; case TYPE_PAUSED: downloadListener.onPaused(); break; case TYPE_CANCELED: downloadListener.onCancled(); break; default: break; &#125; &#125; public void pauseDownload()&#123; isPaused = true; &#125; public void cancelDownload()&#123; isCancled = true; &#125; //获取要下载的内容的大小 private long getContentLength(String downloadUrl) throws IOException&#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if(response != null &amp;&amp; response.isSuccessful())&#123; long contentLength = response.body().contentLength(); response.close(); return contentLength; &#125; return 0; &#125;&#125; 用于执行后台任务的Service 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public class DownloadService extends Service&#123; private DownloadTask downloadTask; private String downloadUrl; private DownloadListener listener = new DownloadListener()&#123; @Override public void onProgress(int progress) &#123; getNotificationManager().notify(1,getNotification(\"Downloading...\",progress)); &#125; @Override public void onSuccess() &#123; downloadTask = null; //下载成功时将前台服务通知关闭，并创建一个下载成功的通知 //这句代码将服务创建成前台服务 stopForeground(true); getNotificationManager().notify(1,getNotification(\"Download Success\",-1)); Toast.makeText(DownloadService.this,\"Download success\",Toast.LENGTH_LONG).show(); &#125; @Override public void onFailed() &#123; downloadTask = null; //下载失败将前台服务通知关闭，并创建一个下载失败的通知 stopForeground(true); getNotificationManager().notify(1,getNotification(\"Download Failed\",-1)); Toast.makeText(DownloadService.this,\"Download failed\",Toast.LENGTH_LONG).show(); &#125; @Override public void onPaused() &#123; downloadTask = null; Toast.makeText(DownloadService.this,\"Paused\",Toast.LENGTH_LONG).show(); &#125; @Override public void onCancled() &#123; downloadTask = null; stopForeground(true); Toast.makeText(DownloadService.this,\"Canceled\",Toast.LENGTH_LONG).show(); &#125; &#125;; //为了让service可以和Activity通信，创了这个binder class DownloadBinder extends Binder&#123; public void startDownload(String url)&#123; if(downloadTask == null)&#123; downloadUrl = url; downloadTask = new DownloadTask(listener); downloadTask.execute(downloadUrl); startForeground(1,getNotification(\"Downloading...\",0)); Toast.makeText(DownloadService.this,\"Downloading...\",Toast.LENGTH_LONG).show(); &#125; &#125; public void pauseDownload()&#123; if (downloadTask != null)&#123; downloadTask.pauseDownload(); &#125; &#125; public void cancelDownload()&#123; if (downloadTask != null)&#123; downloadTask.cancelDownload(); &#125;else&#123; if (downloadUrl != null)&#123; //取消下载时需要将文件删除，并将通知关闭 String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(\"/\")); String directory = Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_DOWNLOADS).getPath(); File file = new File(directory + fileName); if(file.exists())&#123;//如果已经存在要下载的文件了，则读取已经下载的字节数，这样就可以在后面启动端点续传功能 file.delete(); &#125; getNotificationManager().cancel(1); stopForeground(true); Toast.makeText(DownloadService.this,\"Canceled\",Toast.LENGTH_LONG).show(); &#125; &#125; &#125; &#125; private DownloadBinder mBinder = new DownloadBinder(); @Nullable @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; private NotificationManager getNotificationManager()&#123; return (NotificationManager) getSystemService(NOTIFICATION_SERVICE); &#125; private Notification getNotification(String title,int progress)&#123; Intent intent = new Intent(this,MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this,0,intent,0); NotificationCompat.Builder builder; //TODO 注意这段代码，在8.0以后通知要求设置 NotificationChannel，否则会报错 //TODO 在书本中的代码没有这一段 if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O )&#123; NotificationChannel channel = new NotificationChannel(\"im_channel_id\",\"System\", NotificationManager.IMPORTANCE_LOW); NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); if(manager != null)&#123; **manager.createNotificationChannel(channel); &#125; &#125; //书上是 builder = new NotificationCompat.Builder(this); ，但是这个方法现在已经废弃了 builder = new NotificationCompat.Builder(this,\"im_channel_id\"); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)); builder.setContentIntent(pi); builder.setContentTitle(title); if (progress &gt; 0)&#123; //当progress大于或者等于0才需显示下载进度 builder.setContentText(progress + \"%\"); builder.setProgress(100,progress,false); &#125; return builder.build(); &#125;&#125; Activity中的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private DownloadService.DownloadBinder downloadBinder; //为了能够控制service的行为 private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; downloadBinder = (DownloadService.DownloadBinder) service; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.start).setOnClickListener(this); findViewById(R.id.pause).setOnClickListener(this); findViewById(R.id.cancel).setOnClickListener(this); Intent intent = new Intent(this,DownloadService.class); startService(intent); bindService(intent,connection,BIND_AUTO_CREATE); //6.0及以上要求动态申请权限，有权限才能使用这个下载功能 if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this, new String[] &#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1); &#125; &#125; @Override public void onClick(View v) &#123; //首先判断downloadBinder是否有效 if (downloadBinder == null)&#123; return; &#125; switch (v.getId())&#123; case R.id.start: String url = \"https://raw.githubusercontent.com/guolindev/eclipse/master/eclipse-inst-win64.exe\"; downloadBinder.startDownload(url); break; case R.id.pause: downloadBinder.pauseDownload(); break; case R.id.cancel: downloadBinder.cancelDownload(); break; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED)&#123; Toast.makeText(MainActivity.this,\"拒绝权限无法使用程序\",Toast.LENGTH_SHORT).show(); finish(); &#125; break; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(connection); &#125; 当然，还有要注意的是，要在AndroidManifest.xml中注册Service： service android:name=”.DownloadService” 还有，在AndroidManifest.xml中需要标明网络权限和存储权限： uses-permission android:name=”android.permission.INTERNET” uses-permission android:name=”android.permission.WRITE_EXTERNAL_STORAGE” 最后，针对本例子，例子中使用了okhttp，需要在buildgradle中添加依赖： implementation ‘com.squareup.okhttp3:okhttp:3.9.0’","categories":[],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第9章： 看看精彩的世界-使用网络技术","slug":"第一行代码（第二版）-第九章","date":"2018-06-23T00:00:00.000Z","updated":"2019-05-01T08:44:00.080Z","comments":true,"path":"2018/06/23/第一行代码（第二版）-第九章/","link":"","permalink":"https://glassx.gitee.io/2018/06/23/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B9%9D%E7%AB%A0/","excerpt":"","text":"webview的用法这节描述得比较简单，因此记住以下内容就行： webview.setWebClient(new WebViewClient); 为webview设置webViewClient，其主要作用是当需要从一个网页跳转到另一个网页时，我们希望目标网页仍然在当前WebView中显示，而不是打开系统浏览器。 使用HTTP协议访问网络介绍了HttpURLConnection 使用方法，简单上个图： OkHttp的简单使用，并不复杂，略。 解析XML格式数据在网络上传输数据时最常用的格式有两种，XML和JSON，首先学习解析XML。 搭建简易服务器提供数据学习解析xml和json之前，先搭建一个简易服务器提供解析的数据，按照以下步骤即可： 下载一个Apache服务器的安装包，官方下载地址http://httpd.apache.org/download.cgi 一路默认Next，域名随意填写如test.com，安装路径的话，可以选择安装在 C:\\Apache 目录 为了验证安装是否成功，可以打开电脑的浏览器验证，输入 127.0.0.1 出现 It works 界面即可。 接下来进入到安装目录的htdocs目录下，按照上述安装过程应该是C:\\Apache\\htdocs目录，新建get_data.xml文件，编辑，并加入内容： 1234567891011&lt;apps&gt; &lt;app&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;google map&lt;/name&gt; &lt;/app&gt; &lt;app&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;google map&lt;/name&gt; &lt;/app&gt;&lt;/apps&gt; 打开浏览器访问 http://127.0.0.1/get_data.xml就会显示上述内容，同理，如果在其中新建 get_data.json文件，并添加以下数据： 123[&#123;\"id\":\"5\",\"version\":\"5.5\",\"name\":\"map\"&#125;,&#123;\"id\":\"6\",\"version\":\"6.6\",\"name\":\"boom\"&#125;,&#123;\"id\":\"7\",\"version\":\"3.5\",\"name\":\"clash\"&#125;] 打开浏览器访问 http://127.0.0.1/get_data.json 就会返回上述json。 Pull解析方式解析XML格式的数据有多重方式，主要是Pull和SAX两种方式。通过自己搭建的服务器拉取XML数据之后通过Pull解析的示例如下： SAX解析Pull解析方式虽然非常好用，它比XML解析方式要复杂一些，但是语义方面更清楚，通常情况下，我们都会新建一个雷继承自DefaultHandler，并重写父类的5个方法： 每当解析某个节点的时候，startElement方法就会得到调用，其中localName记录当前节点的名字。接下来的工作就非常简单了，修改MainActivity中的代码，如下所示： 解析JSON格式数据JSON相对XML而言优势在于它体积更小，在网络上传输的时候可以更省流量，但缺点是语义性较差。 使用JSONObject比较简单，直接上截图的例子： 使用GSON解析单个的对象比较简单，比如解析： {“name”:”Tom”,”age”:20} 那只需要定义Person类，有String类型的name字段以及int类型的age字段，则可以使用： 12Gson gson = new Gson();Person person = gson.fromJson(jsonData,Person.class); 解析数组稍微麻烦点： 1List&lt;Person&gt; people = gson.fromJson(jsonData,new TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;.getType());","categories":[],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第8章：丰富你的程序-使用手机多媒体","slug":"第一行代码（第二版）-第八章","date":"2018-06-22T00:00:00.000Z","updated":"2019-05-01T08:44:22.621Z","comments":true,"path":"2018/06/22/第一行代码（第二版）-第八章/","link":"","permalink":"https://glassx.gitee.io/2018/06/22/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%85%AB%E7%AB%A0/","excerpt":"","text":"使用通知我们可以在Activity中、BroadcastReceiver以及Service中创建通知，不论在哪里创建，整体步骤是相同的，下面通过示例演示： 123456789101112131415161718192021222324252627282930313233343536373839//1、需要NotificationManager管理通知，通过调用Context的getSystemService方法获得NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);//2、创建一个延迟意图（PendingIntent），标明点击notification时的响应，这里可以启动Activity，Broadcast以及service等//PendingIntent有点类似于Intent，不过前者倾向于在某个合适的时机去执行某个动作，而后者倾向于立即执行某个动作Intent intent = new Intent(MainActivity.this,SecondActivity.class);//根据启动的对象（Activity、Broadcast或service），可以使用getActivity()/getBroadcast()/getService()PendingIntent pi = PendingIntent.getActivity(this,0,intent,0);//3、通过Builder构造器创建Notification对象，几乎Android每个版本都会对通知这部分进行修改，因此我们需要使用//support-v4包提供的NotificationCompat类来兼容性地实现，保证在各个版本上都能正常使用通知Notification notification = new NotificationCompat.Builder(context) .setContentTitle(\"title\") .setContentText(\"content\") .setSound(Uri.from(\"\"))//控制通知的声音 //设置通知来的时候震动，数组中的值为时长，单位为毫秒，下标0表示手机静止时长，下标1为手机震动时长，下标2为手机静止 //时长，以此类推，这就实现了通知来时立刻震动1秒，静止1秒，再震动1秒 //注意震动需要权限 &lt;uses-permission android:name=\"android.permission.VIBRATE\"&gt; .setVibrate(new long[]&#123;0,1000,1000,1000&#125;) .setWhen(System.currentMillis())//指定通知被创建的时间，下拉时这个时间会显示在通知上 .setSmallIcon(R.drawable.small_icon)//显示在顶部状态栏上的图标 .setLargeIcon(BitmapFactory.decodeResource(gerResources(),R.drawable.large_icon))//下拉时显示在通知左边 .setContentIntent(pi)//指明点击之后的意图 //通知自动消失,第二种取消方式是，将notification的id传入SecondActivity中，在进入到SecondActivity后，在SecondActivity //的onCreate方法中重新获取manager，并且关闭这个通知： //NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE); manager.cancel(id); .setLights(Color.GREEN,1000,1000)//设置灯光绿色和一闪一闪的效果 .setAutoCancel(true) //设置style，一般通知只会显示很短的内容文字，但如果真的非常需要长文字，也是支持的，这样设置style，如果要显示一张大图片， //以下换成NotificationCompat.BigTextStyle().bigPicture(bitmap)即可 .setStyle(new NotificationCompat.BigTextStyle().bigText(\"fdasfdsafdsafdafdasfsdafadsfdsfasdffasdfdsfdsfsda\")) //设置通知优先级，如果设置为最高的话，即要求用户立刻看，不会像普通通知只在状态栏显示一个图标，而是弹出一个横幅 //不论你当前在玩游戏还是看电影，这个横幅都会弹 .setPriority(NotificationCompat.PRIORITY_MAX) .build();//4、发出通知manager.notify(1,notification);//第一个参数指定notification的id 调用摄像头和相册平时使用QQ或者微信的时候经常要别人分享图片，这些图片可以使手机摄像头拍摄也可以从相册中选取，这种功能非常普遍。 摄像头拍照直接上代码展示可能更加清晰： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748takePhoto.setOnclickListener(new View.OnclickListener()&#123; @Override public void onClick(View v)&#123; //创建File对象，用于存储拍照后的图片 File outputImage = new File(getExternalCacheDir(),\"output.jpg\"); try&#123; if(outputImage.exists())&#123;//存在了 outputImage.delete(); &#125; outputImage.createNewFile(); &#125;catch(IOException e)&#123; &#125; if(Build.VERSION.SDK_INT &gt;= 24)&#123; imageUri = FileProvider.getUriForFile(MainActivity.this, \"com.example.fileprovider\",outputImage); &#125;else&#123; imageUri = Uri.fromFile(outputImage); &#125; //启动相机 Intent intent = new Intent(\"android.media.action.IMAGE_CAPTURE\"); intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri); startActivityForResult(intent,TAKE_PHOTO); &#125;&#125;);@Overrideprotected void onActivityResult(int requestCode,int resultCode,Intent data)&#123; switch(requestCode)&#123; case TAKE_PHOTO: if(resultCode == RESULT_OK)&#123; try&#123; //将拍摄的照片显示出来 Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver() .openInputStream(imageUri)); ivPic.setImageBitmap(bitmap); &#125;catch (FileNotFoundException e)&#123; &#125; &#125; break; &#125;&#125; 上面的代码中我们用了内容提供器，因此还需要在AndroidManifest.xml中声明这个提供器(有一点要注意的是,在4.4以前（4.4及以后不需要）访问SD卡得应用关联目录也是要声明权限的，为了兼容老版本的手机，需要声明 WRITE_EXTERNAL_STORAGE 权限)： 123456789101112131415161718&lt;users-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt;&lt;application android:icon=\"@mipmap/ic_launcher\" ... android:theme=\"@style/AppTheme\"&gt; &lt;privider &lt;!--这里，android:name属性的值是固定的，android:authorities属性的值必须要和刚才FileProvider.getUriForFile()--&gt; &lt;!--方法中的第二个参数一致，另外，meta-data中用resource指定了Uri的共享路径--&gt; android:name=\"android.support.v4.content.FileProvider\" android:authorities=\"com.example.fileprovider\" android:exported=\"false\" android:grantUriPermissions=\"true\"&gt; &lt;meta-data android:name=\"android.support.FILE_PROVIDER_PATHS\" android:resource=\"@xml/file_paths\"/&gt;&lt;/application&gt; 当然，provider声明中使用了@xml/file_paths资源，这个资源我们还没创建，因此在res目录下可以创建这么个xml，内容如下： 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"&gt;&lt;paths xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;!--这里面external-path指定Uri共享的，name属性随便填，path属性表示共享的具体路径，这里设置空值就表示将整个SD卡进行共享--&gt; &lt;!--当然，你可以仅仅共享我们存放output.jpg这张图片的路径--&gt; &lt;external-path name=\"my_images\" path=\"\"&gt;&lt;/paths&gt; 以上整个代码首先创建了一个File对象，用于存放摄像头拍下的图片，我们将其命名为output.jpg，并将它存放在手机SD卡的应用关联缓存目录（指SD卡中专门用于存放当前应用缓存数据的位置，路径为/sdcard/Android/data//cache，调用getExternalCacheDir()方法就可以得到这个目录）下。为什么使用应用关联缓存目录来存放图片呢？因为从Android 6.0开始，读写SD卡被列为危险权限，如果将图片存放SD卡得任何其他目录，都要进行运行时权限处理才行，而使用应用关联目录则可以跳过这一步。 接着会判断如果设备版本低于7.0，就调用Uri.fromFile()方法将File对象转换为Uri对象，这个Uri标识着图片的本地真实路径。否则就调用FileProvider的getUriForFile()方法获得Uri对象。之所以这样是因为从7.0开始，直接使用本地真实路径的Uri被认为是不安全的，会抛出异常，而FileProvider则是一种特殊的内容提供器，可以选择性地将封装过的Uri共享给外部，提高应用安全性。 最后就是启动摄像头拍照并且回调获取图片了。 从相册中选择照片直接选取一张现有图片比打开相机拍一张照片更加常用，一个优秀的应用应该将这两种方式都提供给用户。废话不多说直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111chooseFromAlbum.setOnclickListener(new View.OnclickListener()&#123; @Override public void onClick(View v)&#123; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1); &#125;else&#123; openAlbum(); &#125; &#125;&#125;);private void openAlbum()&#123; Intent intent = new Intent(\"android.intent.action.GET_CONTENT\"); intent.setType(\"image/*\"); startActivityForResult(intent,CHOOSE_PHOTO);//打开相册&#125;@Overridepublic void onRequestPermissionsResult(int requestCode,String[] permissions,int[] grantResults)&#123; swithc(requestCode)&#123; case 1: if(grantResults.lenght &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else&#123; Toast.makeText(this,\"you denied the permission\",Toast.LENGTH_SHORT).show(); &#125; break; &#125;&#125;@Overrideprotected void onActivityResult(int requestCode,int resultCode,Intent data)&#123; switch(requestCode)&#123; case CHOOSE_PHOTO: if(resultCode == RESULT_OK)&#123; if(Build.VERSION.SDK_INT &gt;= 19)&#123;//4.4及以上 handleImageOnKitKat(data); &#125;else&#123;//4.4以下 handleImageBeforeKitKat(data); &#125; &#125; break; &#125;&#125;//4.4及以上处理方式@TargetApi(19)private void handleImageOnKitKat(Intent data)&#123; String imagePath = null; Uri uri = data.getData(); //如果是document类型Uri，则通过document id处理 if(DocumentsContract.isDocumentUri(this,uri))&#123; String docId = DocumentsContract.getDocumentId(uri); if(\"com.android.providers.media.documents\".equals(uri.getAuthority())&#123; //解析出数字格式的id String selection = MediaStore.Images.Media._ID + \"=\" + id; imagePath = getImagePaht(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,selection); &#125;else if(\"com.android.providers.downloads.documents\".equals(uri.getAuthority()))&#123; Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"),Long.valueOf(docId)); imagePath = getImagePath(contentUri,null); &#125; &#125;else if(\"content\".equalsIgnoreCase(uri.getScheme()))&#123;//如果是content类型的uri，则使用普通方式处理 imagePath = getImagePath(uri,null); &#125;else if(\"file\".eualsIgnoreCase(uri.getScheme()))&#123;//如果是file类型的uri，直接获取推按路径即可 imagePath = uri.getPath(); &#125; //根据路径显示图片 displayImage(imagePath);&#125;//4.4以前处理方式private void handleImageBeforeKitKat(Intent data)&#123; Uri uri = data.getData(); //因为他的Uri没有封装过的，不需要任何解析直接去获取真实路径即可 String imagePath = getImagePath(uri,null); displayImage(imagePath);&#125;//通过Uri和selection来获取真实的图片路径private String getImagePath(Uri uri,String selection)&#123; String path = null; Cursor cursor = getContentResolver().query(uri,null,selection,null,null); if(cursor != null)&#123; if(cursor.moveToFirst())&#123; path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); &#125; cursor.close(); &#125; return path;&#125;//根据路径显示图片private void displayImage(String imagePath)&#123; if(imagePath != null)&#123; Bitmap bitmap = BitmapFactory.decodeFile(imagePath); ivPicture.setImageBitmap(bitmap); &#125;else&#123; Toast.makeText(this,\"failed to get image\",Toast.LENGTH_SHORT).show(); &#125;&#125; 因为照片是存在SD卡上的，所以我们首先进行权限处理，WRITE_EXTERNAL_STORAGE表示授予了对SD卡的读和写的能力。在onActivityResult回调中针对不同版本使用不同方式处理图片，因为从4.4开始，选取相册中的图片不再返回真实的Uri了，而是一个封装过的Uri，因此必须对这个Uri解析才行，在handleImageOnKitKat()方法中，如果返回的Uri是document类型的话，就取出document id进行处理，如果Uri的authority是media格式的话，document id还需要进行一次解析，要通过字符串分割的方式取出后半部分才能得到真正的数字id。 播放多媒体文件播放音频和视频比较简单，没有兼容性等复杂问题，仅仅只需要记住： 申请 WRITE_EXTENAL_STORAGE 权限 使用 MediaPlayer 播放音频结束时，在 onDestroy方法中要进行 MediaPlayer.stop() 和 MediaPlayer.release() ，将资源释放掉; 使用 VideoView 播放视频结束时，在 onDestroy方法中要进行 VideoView.suspend() ，将资源释放掉; 其他内容略过。","categories":[],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第7章： 数据存储全方案——跨程序共享数据：探究内容提供器","slug":"第一行代码（第二版）-第七章","date":"2018-06-21T00:00:00.000Z","updated":"2019-05-01T08:43:42.531Z","comments":true,"path":"2018/06/21/第一行代码（第二版）-第七章/","link":"","permalink":"https://glassx.gitee.io/2018/06/21/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%83%E7%AB%A0/","excerpt":"","text":"可能你会有些疑惑，为什么要将我们程序中的数据共享给其他程序呢？当然，这是视情况而定的，比如账号密码之类的隐私数据显然是不能共享给其他程序的，不过一些可以让其他程序进行二次开发的基础性数据，我们还是可以选择共享。例如联系人程序、短信程序、多媒体库等，它们的数据库中保存了很多基础数据，如果不允许其他应用进行访问，则方便性就会大打折扣。 运行时权限Android的权限机制在一开始就存在，但是在6.0以前保护隐私方面比较有限，因为像微信这种大家都离不开的软件，容易“店大欺客”，不同意它所有的权限只能不安装，这并不合理。 权限机制详解开发者在AndroidManifest.xml中声明权限，一种情况是，用户如果在低于6.0的系统上安装该程序，会在安装时列出该应用所需要的权限，从而决定是否要安装这个程序，并且在用户安装成功之后，还能在设置中查看程序所申请的权限，但是对于那些离不开的程序（比如微信）来说，要么全部同意它申请的权限，要么不安装，这不太合理；如果在6.0及以上的系统中安装，则用户不必在安装时一次性授权所有申请的权限，而是在软件使用的过程中再对危险权限进行授权，就算拒绝了这个权限，仍然可以使用应用的其他功能，而不是以前那样直接无法安装。 Android 6.0 及以上将所有权限分为两类，普通权限和危险权限，普通权限是指不会直接威胁用户的安全和隐私的权限，这部分权限系统自动帮我们授权，避免用户不停地手动授权；危险权限则表示会触及用户隐私或者设备安全性的权限，如获取联系人、定位设备位置等，必须由程序员动态申请，由用户手动点击授权才可以，否则无法使用相应功能。目前为止，Android中的危险权限有9组共24个权限，如下列表所示（图片来自官网）： 这张表格无需记住，在使用的时候作为参照，如果权限在这张表中，则进行运行时处理就好。另外注意一下，表格中每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权了，那么该权限对应的权限组中所有的其他权限也会同时被授权。 在程序运行时申请权限以拨打电话的权限为例来说明权限的申请，点击一个按钮，就拨打指定的号码，在6.0以前可能是这样实现的： 在AndroidManifest.xml中申请权限：1&lt;uses-permission android:name=\"android.permission.CALL_PHONE\"/&gt; 在代码中实现： 12345678btnCall.setOnclickListener(new View.OnclickListener()&#123; @Override public void onClick(View v)&#123; Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse(\"tel:10086\")); startActivity(Intent); &#125;&#125;); 在6.0以下系统上能正常拨打电话，但是在6.0或者以上系统运行，会报错Permission Denial，可以看出是由于权限被禁止导致的，因此我们应该尝试使用以下方式来申请权限： 123456789101112131415161718192021222324252627282930313233343536btnCall.setOnclickListener(new View.OnclickListener()&#123; @Override public void onClick(View v)&#123; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermission(MainActivity.this,new String[]&#123;Manifest.permission.CALL_PHONE&#125;,1); &#125;else&#123; call(); &#125; &#125;&#125;);private void call()&#123; Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse(\"tel:10086\")); startActivity(Intent);&#125;@Overridepublic void onRequestPermissionResult(int requestCode,String[] permissions,int[] grantResults)&#123; switch(requestCode)&#123; case 1: if(grantResults.lenght &gt; 0 &amp;&amp; grantResults(0) == PackageManager.PERMISSION_GRANTED)&#123; call(); &#125;else&#123; Toast.makeText(this,\"You denied the permission\",Toast.LEGHTH_SHORT).show(); &#125; break; &#125; &#125; 上述第一步先判断用户是不是已经给我们授权了，使用的是ContextCompat.checkSelfPermission，如果已经授权，直接拨打电话，否则调用ActivityCompat.requestPermission方法向用户申请授权，这时候用户可以选择同意或者拒绝我们的申请，不论哪种结果，都会通过回调onRequestPermissionResult告知，在回调中根据不同的结果做不同的处理。记住，在动态声明权限后，AndroidManifest中还得添加 声明。 访问其他程序中的数据内容提供器的用法一般有两种，一是使用现有的内容提供器来读取和操作响应程序中的数据，另一种是创建自己的内容提供器给我们的数据提供外部访问接口。 ContentResolver的基本使用如果想要访问内容提供器共享的数据，就一定要借助ContentResolver类，可以通过Context中的getContentResolver方法获取到该类的实例。可以对内容进行CRUD操作，不同于SQLiteDatabase，ContentResolver增删改查不接收表名参数，而是使用Uri参数代替，该Uri主要由两部分组成：authority和path，前者用于对不同的应用程序做区分，一般采用程序包名形式，如某个程序的包名是com.example.app，那么对应的authority就可以命名为com.example.app.provider；path则是对同一应用程序中不同表做区分的，通常会添加到authority后面，所以内容Uri的形式一般如下所示(带协议声明)： content://com.example.app.provicer/table1content://com.example.app.provicer/table2 正式查询的时候，将Uri作为参数传入，代码如下： 12Uri uri = Uri.parse(\"content://com.example.app.provicer/table1\");Cuisor cursor = getContentResolver().query(uri,projection,selection,selectionArgs,sortOrder); 其中，query方法中各个参数对应的含义如下所示： 接下来便可以进行相应的增删改查操作，代码如下： 1234567//查if(cursor != null)&#123; while(cursor.moveToNext())&#123; String colomn1 = cursor.getString(cursor.getColumnIndex(\"column1\")); int colomn2 = cursor.getInt(cursor.getColumnIndex(\"column2\")); &#125;&#125; 12345//增ContentValues values = new ContentValues();values.put(\"column1\",\"text\");values.put(\"column2\",1);getContentResolver().insert(uri,values); 1234//改，把column1的值清空ContentValues values = new ContentValues();values.put(\"column1\",\"\");getContentResolver().update(uri,values,\"column1 = ? and column2 = ?\",new String[]&#123;\"text\",\"1\"&#125;); 12//删除getContentResolver().delete(uri,\"column2 = ?\",new String[]&#123;\"1\"&#125;); 其实整体就相当于sql语句，因此并不太难。 创建自己的内容提供器因为基本上没有这样的需求，暂时略后续补上","categories":[],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第6章：数据存储全方案：详解持久化技术","slug":"第一行代码（第二版）-第六章","date":"2018-06-11T00:00:00.000Z","updated":"2019-05-01T08:44:30.550Z","comments":true,"path":"2018/06/11/第一行代码（第二版）-第六章/","link":"","permalink":"https://glassx.gitee.io/2018/06/11/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%85%AD%E7%AB%A0/","excerpt":"","text":"Android系统主要提供了3种方式用于简单地实现数据持久化功能——文件存储、SharedPreference存储以及数据库存储。 文件存储文件存储是Android中最基本的存储方式，它不对存储内容进行任何的格式化处理，因而比较适合用于存储一些简单的文本数据或者二进制数据。 将数据存储到文件Context类提供了一个openFileOutput()方法，可以用于将数据存储到指定文件，需要两个参数，第一个参数是文件名，纯粹的名称，不可以包含路径，因为所有的文件都是默认存储到/data/data//files/目录下；还有个参数是操作模式，主要有两种（其他2种在4.2被废弃了）： MODE_PRIVATE:默认的操作模式，表示当指定同样文件名的时候，所写入的内容将会覆盖原来文件中的内容。 MODE_APPEND:表示如果该文件已经存在，就往文件里面追加内容，不存在就创建新文件。 保存文件的一般如以下代码操作： 123456789101112131415161718192021public void save()&#123; String dataStr = \"data to save\"; FileOutputStream out = null; BufferedWriter writer = null; try&#123; //文件名是data out = openFileOutput(\"data\",Context.MODE_PRIVATE); writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(dataStr); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finnaly&#123; try&#123; if(writer != null)&#123; writer.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 存储成功后，可以通过Android Device Monitor 进入File Explorer标签，在目录中/data/data//files/中就能找到 data 文件。同理，读取存到文件中的代码应如下所示： 12345678910111213141516171819202122232425public String load()&#123; FileInputStream in = null; BufferedReader reader = null; StringBuilder content = new StringBuilder(); try&#123; in = openFileInput(\"data\"); reader = new BufferedReader(new InputStreamReader(in)); String line = \"\"; while((line = reader.readLine()) != null)&#123; content.append(line); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finnaly&#123; try&#123; if(reader != null)&#123; reader.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; return content.toString();&#125; SharedPreferenceSharedPreference是使用键值对的方式来存储数据的，保存一条数据的时候，需要给这条数据提供一个对应的键，读取数据时通过这个键把对应的值读取出来，SharedPreference文件都是存放在/data/data//shared_prefs目录下。要想存储数据，首先要获取到SharedPreference对象，Android主要提供了3中方式： Context类中的getSharedPreference()方法：此方法接收两个参数，第一个用于指定文件名称，第二个用于指定操作模式，目前只有MODE_PRIVATE可选（其他的几种在4.2或者6.0版本被废弃了），并且是默认的操作模式，表示只有当前应用程序才可以对这个文件进行读写。 Activity中的getPreferences()方法：和Context类中的getSharedPreference()方法类似，只不过它只接受一个操作模式参数，因为使用这个方法时会自动将当前Activity的类名作为SharedPreference的文件名。 PreferenceManager类中的getDefaultSharedPreferences()方法：它接受一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreference文件。 获取到SharedPreference对象之后，就可以开始存储数据了，主要分为3步实现： 调用SharedPreference对象的edit()方法获取SharedPreference.Editor对象 向SharedPreference.Editor对象添加数据。 调用apply()方法提交，从而完成存储操作。 代码形式应该是这样的： 1234567SharedPreferences.Editor editor = getSharedPreferences(\"data\",MODE_PRIVATE).edit();editor.putString(\"name\",\"Tom\");editor.apply();//存储完成后，读取数据SharedPreferences pref = getSharedPreferences(\"data\",MODE_PRIVATE);String name = pref.getString(\"name\",\"\"); SQLite数据库存储文件存储和SharedPrefrences存储只适用于保存一些简单的数据和键值对，要存储大量复杂的关系型数据的时候，有点难以应付了。 创建数据库Android为了让我们更方便地管理数据库，专门提供了一个SQLiteOpenHelper抽象类，要想使用的话，我们就需要创建一个自己的类去继承它，它有两个抽象方法，onCreate和onUpgrade用来创建和升级数据库，其它两个重要的实例方法：getReadableDatabase和getWritableDatabase，他们都可以创建或者打开一个现有的数据库（没有就创建），在数据库不可写入的时候（如磁盘满了），前者以只读的形式打开数据库，后者会出现异常。它有两个构造方法可重写，一般使用哪个参数较少的即可，总共4个参数，第一个context，第二个是数据库名，第三个是自定义的Cursor，一般传null，第四个表示当前的数据库版本号，用于对数据库进行升级操作。一般代码如下图所示： 12345678910111213public class MyDatabaseHelper extends SQLiteOpenHelper&#123; public static final CREATE_BOOK = \"create table Book (\" + \"id integer primary key autoincrement,\" + \"author text,\" + \"price real,\" + \"pages integer,\" +\"name text)\"; @Override public void onCreate(SQLiteDatabase db)&#123; db.exeSQL(CREATE_BOOK); &#125;&#125; 使用的时候应该是这样子的： 123dbHelper = new MyDatabaseHelper(this,\"BookStore.db\",null,1);//就会创建成功了dbHelper.getWritableDatabase(); 上例创建了一个Book表，使用primary key 将id设置为主键，并用autoincrement关键字表示id是自增长的。可以使用 adb shell 命令，之后cd到/data/data//databases/目录下用ls列出该目录的文件，可以看到BookStore.db文件，以及BookStore.db-journal文件，后者是数据库的临时文件。SQLite没有其他数据库一样有很多繁杂的数据类型，它的数据类型很简单：integer表示整型，real表示浮点型，text表示文本，blob表示二进制类型； 升级数据库此时项目中有一张Book表用于存放输的各种详细数据了，但是如果再想添加一张Category表用于记录图书的分类，如果仅仅直接在MyDatabaseHelper的onCreate中写成： 12345@Overridepublic void onCreate(SQLiteDatabase db)&#123; db.exeSQL(CREATE_BOOK); db.exeSQL(CREATE_CATEGORY);&#125; 是行不通的，因为使用的时候先初始化helper：dbHelper = new MyDatabaseHelper(this,”BookStore.db”,null,1)再获取数据库：dbHelper.getWritableDatabase()，而由于此时已经存在数据库BookStore.db了，因此不会再执行helper的onCreate方法了。此时清除app数据可以做到创建Category表，但是这在实际应用中不合理，而我们可以用onUpgrade方法来解决，我们前面构造了MyDatabaseHelper，第4个参数是版本号，我们目前是1，所以只要传入的值大于当前版本号1，onUpgrade方法就可以执行，因此我们可以这样增加Category表： 123456789101112public class MyDatabaseHelper extends SQLiteOpenHelper&#123; ... @Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion)&#123; db.exeSQL(\"drop table if exists Book\"); db.exeSQL(\"drop table if exists Category\"); onCreate(db); &#125;&#125; 上述代码执行了两条drop语句，发现数据库已经存在Book表和Category表了就删除，然后调用onCreate方法重新创建，因此在onCreate中也得写成： 12345@Overridepublic void onCreate(SQLiteDatabase db)&#123; db.exeSQL(CREATE_BOOK); db.exeSQL(CREATE_CATEGORY);&#125; 在使用的时候也得升级版本号： 123dbHelper = new MyDatabaseHelper(this,\"BookStore.db\",null,2);//就会创建成功了dbHelper.getWritableDatabase(); 获取到数据库，接下来可以对其CRUD操作，其中C代表添加（Create），R代表查询（retrieve），U代表更新（Update），D代表删除（Delete）。Android开发者水平参差不齐，并非每一个都会SQL语言，Android提供了一系列的辅助性方法，是的在Android中即使不去编写SQL语句，也能轻松完成所有CRUD操作。getReadableDatabase与getWriteableDatabase方法不仅可以用来创建和升级数据库，他们还会返回一个SQLiteDatabase对象，借助这个对象就可以轻松CRUD： 1234567891011121314151617181920212223242526272829/**添加数据**/SQLiteDatabase db = dbHelper.getWritableDatabase();ContentValues values = new ContentValues();values.put(\"name\",\"thinking in java\");values.put(\"price\",16.96);values.put(\"pages\",512);//插入时指定表名为\"Book\"db.insert(\"Book\",null,values);/**以下是更新**/values.clear();values.put(\"price\",20);//第三个参数对应SQL语句中的where部分，表示更新所有name等于?的行，而?是一个占位符，//可以通过第四个参数提供的一个字符串数组为第三个参数中的每个占位符指定相应内容db.update(\"Book\",values,\"name=?\",new String[]&#123;\"thinking in java\"&#125;);/**以下是删除**///表示删除pages的值大于500的数据db.delete(\"Book\",\"pages &gt; ?\",new String[]&#123;\"500\"&#125;);/**以下是查询**/Cursor cusor = db.query(\"Book\",null,null,null,null,null,null);if(cursor.moveToFirst())&#123; do&#123; String name = cursor.getString(cursor.getColumnIndex(\"name\")); String pages = cursor.Double(cursor.getColumnIndex(\"price\")); &#125;while(cursor.moveToNext());&#125;cusor.close(); 当然，可以直接使用SQL语句直接完成上述操作： 1234567891011//添加db.execSQL(\"insert into Book (name,pages,price) values(?,?,?)\",new String[]&#123;\"thinking in java\",\"512\",\"20\"&#125;);//升级db.execSQL(\"update Book set price = ? where name = \",new String[]&#123;\"20\",\"thinking in java\"&#125;);//删除db.execSQL(\"delete from Book where pages &gt; ?\",new String[]&#123;\"500\"&#125;);//查询db.execSQL(\"select * from Book\",null); 使用LitePal略","categories":[],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第5章： 全局大喇叭：详解广播机制","slug":"第一行代码（第二版）-第五章","date":"2018-06-10T00:00:00.000Z","updated":"2019-05-01T08:44:14.158Z","comments":true,"path":"2018/06/10/第一行代码（第二版）-第五章/","link":"","permalink":"https://glassx.gitee.io/2018/06/10/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%94%E7%AB%A0/","excerpt":"","text":"广播机制介绍Android中广播分为标准广播和有序广播，标准广播是一种完全异步执行的广播，广播发出后，所有广播接收器机会会在同一时刻接收到广播，但同时意味着它也是无法被截断的。有序广播是一种同步执行的广播，同一时刻只有一个广播接收器能收到这条消息，当这个广播接收器的逻辑执行完毕之后才会继续传递，优先级高的广播接收器可以先收到广播，并且还可以阶段正在传递的广播，这样后面的广播接收器就收不到这条广播消息。 动态注册和静态注册广播动态注册一般在Activity的onCreate方法中写上类似于： 1234IntentFilter filter = new IntentFilter();filter.addAction(\"com.example.MyReceiver\");receiver = new MyReceiver();registerReceiver(receiver,filter); 并且在onDestroy方法中注销广播： 1&gt; unregisterReceiver(receiver); 然后，完善一般是内部类的MyReceiver： 123456class MyReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context,Intent intent)&#123; Toast.makeText(context,\"receive the broadcast\",Toast.LENGTH_SHORT).show(); &#125;&#125; 最后得在适当的时候发送广播： 12Intent intent = new Intent(\"com.example.MyReceiver\");sendBroadcast(intent); 当然，如果你是用广播在APP中实现强制退出登录（如QQ账号在另一台设备上登录了），那你只需要在当前Activity上弹一个窗提示已经被强制下线即可，因此有必要将广播在BaseActivity中注册，并且在BaseActivity的onPause方法（注意不是onDestroy方法了，因为我们只需要栈顶的Activity能够响应就行）中注销广播即可。如果是接收系统级广播，可能还得在AndroidManife.xml中声明相关权限。APP中实现强制退出登录时的广播接收器可以这样写： 1234567891011121314151617181920class ForceOfflineReceiver extends BroadcastReceiver&#123; @Override public void onReceive(final Context context,Intent intent)&#123; AltertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(\"warning\"); builder.setMessage(\"force offline\"); builder.setCancelable(false); builder.setPositiveButton(\"ok\",new DialogInterface.OnclickListener()&#123; @Override public void onclick(DialogInterface dialog,int which)&#123; ActivityCollector.finishAll();//销毁所有活动 Intent intent = new Intent(context,LoginActivity.class); context.startActivity(intent); &#125; &#125;); &#125;&#125; 静态注册广播是在AndroidManife.xml中做如下的声明，其中MyReceiver类一般不是内部类，因为即使app未启动也能接收广播： 123456789101112&lt;application android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/appname\"&gt; ... &lt;receiver android:name=\".MyReceiver\" android:enabled=\"true\" android:exported=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.example.MyReceiver\" &lt;/receiver&gt; &lt;/application&gt; 如果要发送有序广播，只需要将以上发送广播的代码sendBroadcast(intent)替换成sendOrderedBroadcast(intent,null);即可。设置广播的优先级只需要设置intentFilter的priority属性即可（AndroidManifest文件中是intent-filter属性）。 使用本地广播前面发送的广播属于系统全局广播，发出的广播可以被任何应用接收到，并且我们也可以接受来自其它任何应用发出的广播，这容易引起安全性问题，比如关键数据广播被其他应用截获，或者其他应用发送各种垃圾广播。本地广播的发送有些不同： 123LocalBroadcastManager manager = LocalBroadcastManager.getInstance(this);Intent intent = new Intent(\"com.example.MyReceiver\");manager.sendBroadcast(intent); 注册： 1234IntentFilter filter = new IntentFilter();filter.addAction(\"com.example.MyReceiver\");localReceiver = new LocalReceiver();manager.registerReceiver(localReceiver,filter); 同样注销广播： 1manager.unregisterReceiver(localReceiver); 本地广播的几点优势： 可以明确地知道正在发送的广播不会离开我们的程序，因此不必担心机密数据泄露。 其他的程序无法将广播发送到我们程序内部，因此不用担心会有安全漏洞隐患。 发送本地广播比发送系统全局广播更加高效。 另有一点需要说明：本地广播是无法通过静态注册方式来接收的，其实这也完全可以理解，因为静态注册主要就是为了让程序在未启动的情况下也能接收广播，而发送本地广播时，我们的程序肯定是已经启动了；此外，不要再onReceive方法中添加过多的逻辑或者进行任何耗时的操作，因为广播接收器中是不允许开启线程的，当onReceive方法运行了较长时间而没有结束时，程序就会报错。因此它更多的知识扮演一种打开程序其他组件的角色，如弹一条通知，或者启动一个服务等。","categories":[],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第4章：手机平板要兼顾：探究fragment","slug":"第一行代码（第二版）-第四章","date":"2018-06-09T08:00:00.000Z","updated":"2019-05-01T08:44:57.104Z","comments":true,"path":"2018/06/09/第一行代码（第二版）-第四章/","link":"","permalink":"https://glassx.gitee.io/2018/06/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%9B%9B%E7%AB%A0/","excerpt":"","text":"这一章前面部分主要讲解Fragment的基本使用，这点我觉得官方文档关于fragment的知识可能会更好一些，以下是官方的阐述： 主要是平时使用Fragment时，对其使用方法有疑惑，以下或许能解释部分： 为什么使用Fragment参考自官方：主要是为了在大屏幕手机（如平板电脑）上更加零落的UI设计，可以更方便地组合和交换UI组件。 Fragment的创建想为Fragment提供布局，则必须实现onCreateView()回调，可以通过xml定义布局资源，为此，onCreateView()提供了一个LayoutInflater对象： public static class ExampleFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // Inflate the layout for this fragment return inflater.inflate(R.layout.example_fragment, container, false); } }向Activity中添加Fragment1、在Activity的布局文件中声明：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:name=&quot;com.example.ListFragment&quot; android:id=&quot;@+id/list&quot; android:layout_weight=&quot;1&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;fragment android:name=&quot;com.example.AticleFragment&quot; android:id=&quot;@+id/viewer&quot; android:layout_weight=&quot;2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/LinearLayout&gt; 官方解释:Activity初始化布局时，会实例化布局中指定的每个fragment，并为每个Fragment调用onCreateView()方法，系统会直接插入Fragment返回的View来替代元素。 2、通过编程方式将Fragment添加到某个现有的ViewGroup：可以在Activity运行期间将Fragment添加进去，你只需要指定Fragment要放入哪个ViewGroup，这需要使用FragmentTransaction： FragmentManager fragmentManager = getFragmentManager(); FragmentTransaction transaction = fragmentManager.beginTransaction();然后，你可以使用add()方法添加一个fragment： ExampleFragment fragment = new ExampleFragment(); transaction.add(R.id.fragment_container,fragment); transaction.commit(); 一旦通过FragmentTransaction做出了更改，就必须commit以使更改生效。 3、添加没有UI的Fragment：你可以使用Fragment为Activity提供后台行为，而不显示额外的UI。使用函数： add(Fragment,String)String类型参数为Fragment提供一个唯一的字符串标记，由于Fragment没有雨Activity中的视图关联，因此不会收到onCreate()调用，因此你可以不实现这个方法。如果你稍后想从Activity中获取到这个Fragment，可以使用findFragmentByTag()。 可以在SDK的sample中查看具体用法：/APIDemos/app/src/main/java/com/example/android/apis/app/FragmentRetainInstance.java 执行Fragment事务需要使用FragmentTransaction，可以使用： add() 、remove() 、replace()等方法设置想要执行的更改，然后commit生效。 不过在commit之前你可能想调用 addToBackStack()将其添加到Fragment事务返回栈，允许用户按返回键返回上一Fragment状态。 来个例子： /**create new fragment and transaction**/ Fragment newFragment = new ExampleFragment(); FragmentTransaction transaction = getFragment().beginTransaction(); /**Replace whatever is in the fragment_container view with this fragment and add the transaction to the back stack**/ transaction.replace(R.id.fragment_container,newFragment); transaction.addToBackStack(null); //commit the transaction transaction.commit();向FragmentTransaction添加更改的顺序无关紧要，但有一些注意事项： commit操作不会立即执行，而是等主线程认为可以执行的时候再运行，不过，如果有必要，你也可以从主线程调用executePendingTransactions() 以立即执行commit。 最后必须调用commit，而且只能在用户离开Activity之前commit，否则会引发异常，如果对于需要commit的更改无关紧要，可以使用commitAllowingStateLoss()。 可以向同一个容器中添加多个fragment，你添加的顺序决定他们在视图层次结构中出现的顺序。 管理Fragment需要使用FragmentManager，你可以使用它执行以下操作： findFragmentById() （对于在Activity布局中提供UI的Fragment）或者findFragmentByTag()（对于提供或者不提供UI的Fragment都可）。 popBackStack() (模拟用户发出的返回命令)，将Fragment从返回栈中弹出。 addOnBackStackChangedListener() 监听返回栈变化 与Activity通信Fragment可以通过getActivity()访问Activity实例，并轻松执行诸如在Activity布局中查找视图等任务： View listView = getActivity().findViewById(R.id.list);同样，Activity也可以使用findFragmentById 或者 findFragmentByTag,通过从FragmentManager获取Fragment的引用来调用Fragment中的方法： ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);一个应用场景例子一个新闻应用中Activity两个Fragment，Fragment A放列表list，Fragment B 放对应内容，那么A在列表项选定后，告诉Activity，以便Activity通知B显示该新闻。其方案可以这样设计： 在A中声明接口OnArticleSelectedListener ： public static class FragmentA extends ListFragment { ... // Container Activity must implement this interface public interface OnArticleSelectedListener { public void onArticleSelected(Uri articleUri); } ... }同事在Activity中实现接口OnArticleSelectedListener，在A的onAttach方法时判断Activity是否这样做了： public static class FragmentA extends ListFragment { OnArticleSelectedListener mListener; ... @Override public void onAttach(Activity activity) { super.onAttach(activity); try { mListener = (OnArticleSelectedListener) activity; } catch (ClassCastException e) { throw new ClassCastException(activity.toString() + &quot; must implement OnArticleSelectedListener&quot;); } } ... }当有点击事件的时候，A看起来是这样子的： public static class FragmentA extends ListFragment { OnArticleSelectedListener mListener; ... @Override public void onListItemClick(ListView l, View v, int position, long id) { // Append the clicked item&apos;s row ID with the content provider Uri Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id); // Send the event and Uri to the host activity mListener.onArticleSelected(noteUri); } ... }Fragment的生命周期如下图： 其中将fragment进行至fragment的resume状态（即可以跟用户交互）的核心序列如下： onAttach(Activity) ：activity与fragment关联的时候调用. onCreate(Bundle) ：fragment初始化的时候调用. onCreateView(LayoutInflater, ViewGroup, Bundle) ：为fragment创建返回view界面. onActivityCreated(Bundle): 通知fragment它绑定的那个Activity已经执行完了onCreate()操作. onViewStateRestored(Bundle)： 通知fragment它保存的view state已经被恢复了. onStart()： fragment对用户可见 (还要取决于包含这个fragment的activity是否已经启动了). onResume()： 使fragment可以和用户交互了 (还要取决于包含这个fragment的activity是否已经resume了).如果一个fragment不再使用了，它会执行一系列相反的过程: onPause()： fragment不能与用户交互（可能是由于activity的pause）。 onStop()： fragment不可见了（可能是由于activitystop了）。 onDestroyView()：通知fragment清理与它相关的view资源。 onDestroy()：在完全清理fragment的状态时调用。 onDetach()：当fragment与activity解除绑定时调用。 动态加载布局的技巧使用限定符如果使用平板就会发现里面的应用基本上是双页模式，但是在手机上限于屏幕大小，都是单页模式。如果判断该使用双页模式还是单页模式，这就要借助限定符（qualifiers）来实现了，我们可以有两个布局文件，一个 layout_single.xml 单页模式布局放在layout目录，一个 layout_double.xml 双页模式布局放在 layout-large 目录，其中的large是个限定符。Android中常用限定符如下： 使用最小限定符前面解决了单页双页模式，但是到底怎么才算large，我们需要更精确地控制的话，需要最小限定符。我们新建layout-600dp文件夹，将双页布局文件放入其中，这样就会意味着，当程序运行在宽度小于600dp的设备上时，显示的是单页布局，否则使用的是双页布局。 以上两种技巧可以将手机版和pad版都使用同一个app，避免维护多个app，一处改动，需要在两个app中同步改动。注意在代码中区别目前是双页模式还是单页模式，可以用以下方式： 12345if(findViewById(R.id.anotherpageid) == null)&#123; //单页&#125;else&#123; //双页&#125; 其中R.id.anotherpageid是在单页中所没有的那个布局的id。","categories":[],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第3章：软件和也要拼脸蛋","slug":"第一行代码（第二版）-第三章","date":"2018-06-09T00:00:00.000Z","updated":"2019-05-01T08:43:52.871Z","comments":true,"path":"2018/06/09/第一行代码（第二版）-第三章/","link":"","permalink":"https://glassx.gitee.io/2018/06/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%89%E7%AB%A0/","excerpt":"","text":"布局文件中如果添加Button，并指定其text为”button”的话，但是显示的是”BUTTON”，全部变为大写了，要去掉这一效果，可以添加属性android:textAllCaps=”false” RelativeLayout 中还有另外一组对于控件进行定位的属性，android:layout_alignLeft表示让一个控件的左边缘和另一个控件的左边缘对齐，同理，还有android:layout_alignRight、Top、Bottom 。 创建自定义控件我们所用的所有控件都是直接或者间接继承自View的，所有的布局都是直接或者间接继承ViewGroup，View是Android中最基本的一种UI组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是在View的基础上添加各自特有功能；而ViewGroup则是一种特殊的View，它可以包含很多子View和子ViewGroup，是一个防止控件和布局的容器。常用控件和布局的继承结构如下图所示： App中的标题栏几乎在每个界面都是一样的，除了标题不一样，其他的诸如左边按钮点击就finish当前页面，右边的是菜单按钮，这些功能基本上一样，如果在每个页面都单独为这些按钮重复添加相同的监听，比较繁琐。所以可以将标题栏单独封装成单独的一个TitleLayout的，每次只需要引入到布局中即可。 使用listview可以继承ArrayAdapter简化操作，类似如下(当然，这里在getView的时候没有进行复用优化，仅仅只是示例)： 12345678910111213141516171819public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt;&#123; private int resourceId; public FruitAdapter(Context context,int resourceId,List&lt;Fruit&gt; objects)&#123; super(context,resourceId,objects); this.resourceId = resourceId; &#125; @Override public View getView(int position,View convertView,ViewGroup parent)&#123; Fruit fruit = getItemt(position); View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false); ImageView ivFruit = view.findViewById(R.id.img); TextView tvFruit = view.findViewById(R.id.txt); ivFruit.setImageResource(fruit.getImageId()); tvFruit.setText(fruit.getName()); return view; &#125;&#125; 使用更强大的RecyclerView在设置LayoutManager的时候，可以指定排布的方向比如以下代码： 12LinearLayoutManager manager = new LinearLayoutManager(this);manager.setOrientation(LinearLayoutManager.HORIZONTAL);//平时一般使用竖直方向，这里特意指定横向 为什么Listview很难或者根本无法实现这种效果呢，其实这主要得益于RecyclerView的出色设计，ListView的布局排列是由自身去管理的，，而RecyclerView则将这个工作交给了LayoutManager，LayoutManager指定了一套可扩展的布局排列接口，自雷只要按照接口的规范来实现，就能定制出不同排列方式的布局了。 实现点击事件，可以在Adapter中的onCreateViewHolder方法中来做到，诸如以下实现： 123456789101112@Overridepublic ViewHolder onCreateViewHolder(ViewGroup parent,int viewType)&#123; View view = LayoutInflater.from(parent.getContext).inflate(R.layout.fruit_item,parent,false); final ViewHolder holder = new ViewHolder(view); holder.ivFruit.setOnclickListener(new View.OnclickListener()&#123; @Override public void onClick(View v)&#123; int postion = holder.getAdapterPosition(); //doSomeThing you want &#125; &#125;);&#125;","categories":[],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"Intent 传递的数据过大","slug":"Intent传递数据过大","date":"2018-06-07T00:00:00.000Z","updated":"2018-06-11T00:43:20.000Z","comments":true,"path":"2018/06/07/Intent传递数据过大/","link":"","permalink":"https://glassx.gitee.io/2018/06/07/Intent%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7/","excerpt":"","text":"这个问题源于最近做的项目中出现的bug，一个Activity A通过startActivity(intent)的方式（intent中携带了String类型的data）启动另一个Activity B时，发生了崩溃，查看错误日志如下： 可以看到，这是 android.os.TransactionTooLargeException ，字面意思是事务太大。这就很好理解了，因为笔者使用了intent携带数据，在事后分析这个data在传入的时候大约50k，因此导致了这个问题。后来使用SharedPreference将数据捎带过去解决了问题，这个bug本身看懂了报错就很简单，因此不再赘述。后面有空有兴趣之后再补上分析Intent传递数据到底是多大的限制。","categories":[],"tags":[{"name":"问题随笔","slug":"问题随笔","permalink":"https://glassx.gitee.io/tags/%E9%97%AE%E9%A2%98%E9%9A%8F%E7%AC%94/"}]},{"title":"Listview 中 CheckBox 状态错误问题原因及解决方案","slug":"listview搭配checkbox问题","date":"2018-06-05T00:00:00.000Z","updated":"2018-06-11T00:48:06.000Z","comments":true,"path":"2018/06/05/listview搭配checkbox问题/","link":"","permalink":"https://glassx.gitee.io/2018/06/05/listview%E6%90%AD%E9%85%8Dcheckbox%E9%97%AE%E9%A2%98/","excerpt":"","text":"在开发过程中碰到很多问题，有些问题在锤子便签中记录了一个概要，有的问题甚至连记录都没有，此次开个头，将碰到的问题记录下来。 今天要写的问题跟Listview有关，顺便复习下ListView的相关复用机制，以及Listview的Adapter中getView方法为什么需要ViewHolder，是怎么提高加载效率的。下面开始进入回忆状态，事情的经过是这样的： 在平时的 Android 开发过程中，我们可能需要去实现以下效果： 在 Listview 中使用CheckBox，但是会碰到 CheckBox 选中/非选中 这种状态错乱的问题，笔者最近在项目中就碰到了，比如我选中了 id0、id1、id2 三个 CheckBox ，再想选择 id15 ，这就要求滑动 Listview 了，滑到 id15 CheckBox 将其选中，再滑动到顶部，握草，发现 id0、id1、id2 已经变成 非选中 状态了，莫非是我记错了？再重新来一次，还是一样！这就不科学了，一定是哪里出了问题，我当时的代码是这样的： @Override public View getView(final int i, View view, ViewGroup viewGroup) { ViewHolder viewHolder = null; if(view == null){ viewHolder = new ViewHolder(); view = LayoutInflater.from(context).inflate(R.layout.layout,null); viewHolder.cb = (CheckBox) view.findViewById(R.id.select_cb); viewHolder.tvName = (TextView) view.findViewById(R.id.name_tv); view.setTag(viewHolder); }else{ viewHolder = (ViewHolder) view.getTag(); } viewHolder.cb.setChecked(data.get(i).isSlected()); viewHolder.tvName.setText(data.get(i).getName()); viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() { @Override public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked) { data.get(i).setSlected(isChecked); } }); return view; }脑子里第一反应是各处的 item 串了，联想到使用 viewholder 来复用 item ，于是就去了解了一番 Listview 对 item 的复用机制。 复用机制我们知道，listview 需要承载大量的数据，并且需要写一个 Adapter 与其适配，这样数据就能展现出来了，但是不知道大家有没有仔细想过，为什么需要 Adapter 这个东西，它到底起了个什么作用。 从 Adapter 说起说到底，Android 中控件就是为了展示数据以及交互用，只不过Listview特殊些，它用于展示大量的信息的，但是 Listview 只承担交互和展示工作的，至于数据来自哪里，它不care。这样，listview工作最基本需要一个 Listview 控件和一个数据源，但是数据源可能是数组，可能是集合，甚至可能是数据库表中查询出来的游标，如果 Listview 要去为每一种数据源进行匹配的话，它一定会变得非常臃肿了，于是 Adapter 出现了。 顾名思义，Adapter 是适配器的意思，它在 Listview 与数据源之间起了一个桥梁作用，与之前的情况不同的是，Adapter 的接口都是统一的，因此 Listview 不需要担心任何适配问题。而 Adapter 是个接口（interface），它可以有各种子类，比如 ArrayAdapter 可用于数组和 List 类型的数据源匹配，SimpleCursorAdapter 可以用于游标类型的数据源匹配，这样把适配问题解决了，并且扩展性不错。 RecycleBin 类在解释复用机制之前，还有必要说一下 RecycleBin 类，因为它是 Listview 能够展现成百上千条数据并且不会 OOM 的关键，RecycleBin 是 AbsListview 的一个内部类，其主要代码如下： /** * The RecycleBin facilitates reuse of views across layouts. The RecycleBin * has two levels of storage: ActiveViews and ScrapViews. ActiveViews are * those views which were onscreen at the start of a layout. By * construction, they are displaying current information. At the end of * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews * are old views that could potentially be used by the adapter to avoid * allocating views unnecessarily. */ class RecycleBin { private RecyclerListener mRecyclerListener; /** * The position of the first view stored in mActiveViews. */ private int mFirstActivePosition; /** * Views that were on screen at the start of layout. This array is * populated at the start of layout, and at the end of layout all view * in mActiveViews are moved to mScrapViews. Views in mActiveViews * represent a contiguous range of Views, with position of the first * view store in mFirstActivePosition. */ private View[] mActiveViews = new View[0]; /** * Unsorted views that can be used by the adapter as a convert view. */ private ArrayList&lt;View&gt;[] mScrapViews; private int mViewTypeCount; private ArrayList&lt;View&gt; mCurrentScrap; /** * Fill ActiveViews with all of the children of the AbsListView. * * @param childCount * The minimum number of views mActiveViews should hold * @param firstActivePosition * The position of the first view that will be stored in * mActiveViews */ void fillActiveViews(int childCount, int firstActivePosition) { if (mActiveViews.length &lt; childCount) { mActiveViews = new View[childCount]; } mFirstActivePosition = firstActivePosition; final View[] activeViews = mActiveViews; for (int i = 0; i &lt; childCount; i++) { View child = getChildAt(i); AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams(); // Don&apos;t put header or footer views into the scrap heap if (lp != null &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) { // Note: We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in // active views. // However, we will NOT place them into scrap views. activeViews[i] = child; } } } /** * Get the view corresponding to the specified position. The view will * be removed from mActiveViews if it is found. * * @param position * The position to look up in mActiveViews * @return The view if it is found, null otherwise */ View getActiveView(int position) { int index = position - mFirstActivePosition; final View[] activeViews = mActiveViews; if (index &gt;= 0 &amp;&amp; index &lt; activeViews.length) { final View match = activeViews[index]; activeViews[index] = null; return match; } return null; } /** * Put a view into the ScapViews list. These views are unordered. * * @param scrap * The view to add */ void addScrapView(View scrap) { AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams(); if (lp == null) { return; } // Don&apos;t put header or footer views or views that should be ignored // into the scrap heap int viewType = lp.viewType; if (!shouldRecycleViewType(viewType)) { if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) { removeDetachedView(scrap, false); } return; } if (mViewTypeCount == 1) { dispatchFinishTemporaryDetach(scrap); mCurrentScrap.add(scrap); } else { dispatchFinishTemporaryDetach(scrap); mScrapViews[viewType].add(scrap); } if (mRecyclerListener != null) { mRecyclerListener.onMovedToScrapHeap(scrap); } } /** * @return A view from the ScrapViews collection. These are unordered. */ View getScrapView(int position) { ArrayList&lt;View&gt; scrapViews; if (mViewTypeCount == 1) { scrapViews = mCurrentScrap; int size = scrapViews.size(); if (size &gt; 0) { return scrapViews.remove(size - 1); } else { return null; } } else { int whichScrap = mAdapter.getItemViewType(position); if (whichScrap &gt;= 0 &amp;&amp; whichScrap &lt; mScrapViews.length) { scrapViews = mScrapViews[whichScrap]; int size = scrapViews.size(); if (size &gt; 0) { return scrapViews.remove(size - 1); } } } return null; } public void setViewTypeCount(int viewTypeCount) { if (viewTypeCount &lt; 1) { throw new IllegalArgumentException(&quot;Can&apos;t have a viewTypeCount &lt; 1&quot;); } // noinspection unchecked ArrayList&lt;View&gt;[] scrapViews = new ArrayList[viewTypeCount]; for (int i = 0; i &lt; viewTypeCount; i++) { scrapViews[i] = new ArrayList&lt;View&gt;(); } mViewTypeCount = viewTypeCount; mCurrentScrap = scrapViews[0]; mScrapViews = scrapViews; } } 注释说 RecycleBin 用于view的reuse，它维持了两个存储空间，ActiveViews 和 ScrapViews，前者存放显示在屏幕上的view，到列表最后的时候，它里面的view都会去到 ScrapViews 中。而后者用于存放 old views ，这些view可能可以直接以convertView的形式直接利用，避免没必要的 allocat 内存，这就是Adapter中convertView的由来。 fillActiveViews() :这个方法会根据传入的参数来将 Listview 中指定的元素存储到 mActiveViews 数组中。 getActiveView() :跟 fillActiveViews 方法对应，用于从 mActiveViews 中获取数据，需要注意的是，一旦第 position 个数据被获取成功之后，该view就会从 mActiveViews 中移除，下次再获取第position个位置将会返回 null，也就是说mActiveViews不能复用。 addScrapView() :用于将一个废弃的view进行缓存，当一个view要废弃的时候（比如滚出屏幕），就调用该方法缓存，以便下次使用。 getScrapView() :从 ScrapViews 中取出一个view，这些废弃缓存中的view是没有顺序可言的，因此取的算法也非常简单，获取尾部的就行。 setViewTypeCount() :我们知道在 adapter 中我们可以重写 getViewTypeCount() 来表示Listview中有几种类型的数据项，而setViewTypeCount()的作用就是为每种类型的数据项都单独启用一个 RecycleBin 缓存机制。 扯点view的绘制Listview 再牛逼，也是继承自view的，而view的执行流程就是3步，onMeasure() 用于测量 view 的大小，onLayout() 用于确定 View 的布局，onDraw() 用于将 view 绘制到界面上。 Listview 最特殊的地方在于 onLayout() ,而这是在它父类 AbsListview 中实现的，它主要就一个重要判断：如果 Listview 的大小或者位置发生了变化，那就要求所有子布局强制重绘。而 layoutchildren() 方法是用来进行子元素布局的，具体由 Listview 自己实现，可以解析下。 刚开始，Listview 中没有任何子view，因此会去调用 fillActiveViews() 方法，这是为了将 Listview 中的子 view 进行缓存的，由于此时子 view 为空，因此会调用 fillFromTop() ，最终调用到 fillDown() 方法，进行 Listview 的填充操作。fillDown() 中有个while循环，当遍历完从 Listview 顶部到底部的距离的item或者 adapter 中的数据遍历结束，while就跳出。在while中，执行 makeAndAddView() ，它会尝试从 RecycleBin 中快速获取 active view ，但此时 RecycleBin 中还未缓存任何view，因此获得null，所以就会尝试调用 obtainView() ，它是可以保证返回一个 view 的，于是将获取到的view立刻传入到了 setupChild() 中。 那到底 obtainView() 怎么保证获取到view的？不夸张地说，Listview 中最重要的内容都在 obtainView() 中了，该方法里首先调用了 RecycleBin 的 getScrapView() 方法尝试获取一个废弃缓存中的 view ，当然这时候是获取不到的，得到null，之后再调用 mAdapter 的 getView() 方法来获取一个 view ，这时候似曾相识了，有 adapter 和 getView() 方法了，对，就是我们平常写的那个 adapter，然后重写的那个 getView(),这时候会传入 position，convertView (此时为null)，parent (当然是 this 了)。 捋一下item的复用一切从 onLayout 开始，当大小或者位置发生了变化，就会调用onLayout，onLayout完毕之后，就剩下 ondraw 去绘制了。onLayout中，（为了叙述方便，不考虑数据不足以填满Listview的情况），首先要拿item的view放到Listview中，先从ActiveViews中拿，如果为空，则打算从 ScrapViews 中拿，还是为空，则利用 adapter 去创造，创造一屏 itemview 填充于 ActiveViews 中，之后 Listview 从 ActiveViews 中取出 itemview ，ActiveViews 删除该 itemview ，如果 itemview 滑动隐藏了，就会丢弃到 ScrapViews 中，这样滑动的时候触发 onLayout ，onLayout 再去找 itemview 填充，如果有现成的就用，没有就创造。 分析源码谈原因再来看源码，为了更方便，加上toast提示： @Override public View getView(final int i, View view, ViewGroup viewGroup) { ViewHolder viewHolder = null; if(view == null){ viewHolder = new ViewHolder(); view = LayoutInflater.from(context).inflate(R.layout.layout,null); viewHolder.cb = (CheckBox) view.findViewById(R.id.select_cb); viewHolder.tvName = (TextView) view.findViewById(R.id.name_tv); view.setTag(viewHolder); }else{ viewHolder = (ViewHolder) view.getTag(); } viewHolder.cb.setChecked(data.get(i).isSlected()); viewHolder.tvName.setText(data.get(i).getName()); viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() { @Override public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked) { Toast.makeText(context,&quot;这是点击了第&quot; + i + &quot;个&quot; ,Toast.LENGTH_SHORT).show(); data.get(i).setSlected(isChecked); } }); return view; }运行之后我们看到整个列表，选中第1个，会弹toast “这是点击了第0个” 接着往上慢慢滑动，直至将第一个item隐藏的时候，发现 toast 弹出来了，显示 这是点击了第0个！而这个时候最下面之前被第一条隐藏的item也展现出来了，综合上面的知识，可以知道，这个隐藏的item是复用了第1个item的view，复用view的时候，由于该隐藏item是未checked，而第一条item是已经checked，因此它执行 viewHolder.cb.setChecked(data.get(i).isSlected()); 的时候，会触发 OnCheckedChangeListener ，由于之前第一个 item 设置了监听： viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() { @Override public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked) { Toast.makeText(context,&quot;这是点击了第&quot; + i + &quot;个&quot; ,Toast.LENGTH_SHORT).show(); data.get(i).setSlected(isChecked); } });这时候就触发了监听事件，因此toast就弹出来了，并且把第一条item的数据也由checked改成unchecked，因此你下次再见到第一个item的时候，状态就变成unchecked了。 结论最后可以说结论了，这个现象是由于listview中item复用导致，如果你不用viewholder是不会有这问题的，其实这个结论并不重要，重要的是理解这里面的发生机制。当然，说了问题起因，当然得给个解决方案，方法不止一种，我个人用的一种方法是在 viewHolder.cb.setChecked(data.get(i).isSlected()); 之前添加一句： viewHolder.cb.setOnCheckedChangeListener(null); 我想你肯定知道为什么。 注：参考（引用）以下博客劳动成果： 郭霖 ： Android ListView工作原理完全解析，带你从源码的角度彻底理解","categories":[],"tags":[{"name":"问题随笔","slug":"问题随笔","permalink":"https://glassx.gitee.io/tags/%E9%97%AE%E9%A2%98%E9%9A%8F%E7%AC%94/"}]},{"title":"第2章：先从看得到的入手","slug":"第一行代码（第二版）-第二章","date":"2018-06-01T00:00:00.000Z","updated":"2019-05-01T08:44:06.925Z","comments":true,"path":"2018/06/01/第一行代码（第二版）-第二章/","link":"","permalink":"https://glassx.gitee.io/2018/06/01/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"Intent使用显式地就不说了，使用隐式的Intent时并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，并帮我们找出合适的活动去启动。 普通的隐式Intent使用比如在AndroidManifest.xml中声明activity的时候，可以添加： 1234&lt;intent-filter&gt; &lt;action android:name=\"com.example.ACTION_START\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt;&lt;intent-filter&gt; 在代码中就能以下面代码来启动这个activity了（由于category是DEFAULT，所以在intent中并未指定category了）： 12Intent intent = new Intent(\"com.example.ACTION_START\");startActivity(intent); 如果在AndroidManifest.xml中声明activity的时候同时指定了action和category，那么必须要在Intent中严格匹配才能打开，否则可能报错，比如写成： 12345&lt;intent-filter&gt; &lt;action android:name=\"com.example.ACTION_START\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;category android:name=\"com.example.MY_CATEGORY\"/&gt;&lt;intent-filter&gt; 则代码中必须添加以下代码才能正确运行。 123Intent intent = new Intent(\"com.example.ACTION_START\");**intent.addCategory(\"com.example.MY_CATEGORY\");**startActivity(intent); 更多隐式Intent用法使用隐式的Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，比如说要在应用程序中点击一个按钮，然后要在浏览器中打开一个网页，则使用以下代码： 123Intent intent = new Intent(Intent.ACTION_VIEW);intent.setData(Uri.parse(\"http://www.baidu.com\"));startActivity(Intent); 这里面，setData()接收一个Uri对象，主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传入到Uri.parse()方法中解析产生的。那如果我们要自己写个浏览器应用，让其它应用也能像这样利用我们的APP打开网页，又该怎么做呢，这就要求在中添加一个&lt;data标签&gt;，用于更精确地指定当前活动能够响应什么类型的数据。标签中可以配置以下内容： android:scheme。用于指定数据的协议部分，例如上例中的http部分。 android:host。用于指定数据的主机名部分，如上例中的www.baidu.com。 android:port。用于指定数据的端口部分。 android:path。用于指定主机名和端口之后的部分。 所以，如果我们要做一个浏览器，至少要在AndroidManifest.xml对主activity声明： 123456&lt;intent-filter&gt; &lt;action android:name=\"com.example.ACTION_START\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:scheme=\"http\"&gt;&lt;intent-filter&gt; 下次其他APP需要用http协议打开网页时，我们的APP也会在候选列表中了。除了http协议意外，我们还可以指定很多其他协议，比如geo表示地理位置、tel表示拨打电话。 活动的生命周期 onCreate()，活动第一次被创建的时候调用，应该在这里面完成活动的初始化操作。 onStart()，在活动由不可见变为课件的时候调用。 onResume()，在活动准备好和用户进行交互的时候调用，此时活动一定位于返回栈的栈顶，并且处于运行状态。 onPause()，在系统准备去启动或者恢复另一个活动的时候调用，通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但是工作不能太多，不然会影响下一个Activity的使用。 onStop(),活动完全不可见的时候调用，它和onPause主要的区别在于，如果启动的新活动是一个对话框式的活动，那么onPause方法会得到执行，而onStop不会执行。 onDestroy()，活动晓辉之前调用。 onRestart()，由停止状态变为运行状态之前调用。一般是由上一个活动返回到当前活动。 活动回收了怎么办想象以下场景，应用中有活动A，在A的基础上启动活动B，活动A此时进入了停止状态，此时由于内存不足，将活动A回收了，然后用户按Back键返回活动A，会出现什么情况呢？其实还是会正常显示A，只不过这是并不会执行onRestart方法，而是会执行活动A的onCreate方法，因为活动A在这种情况下会被重新创建一次。 如果A进程中有输入框，并且已经输入了一些文字了，如果回收被重新创建，那么会丢失输入的信息，影响用户体验。Activity中还提供了一个onSaveInstanceState()回调方法，这个方法可以保证在活动回收之前一定会被调用，这个方法会携带一个Bundle类型的参数，它允许以key-value的形式存取值，我们可以这样将要保存的数据存下来： 12345@Override public void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putString(\"name\",\"glassx\"); &#125; 数据已经保存下来了，但是在哪里恢复呢？其实我们一直使用的onCreate方法其实也有一个Bundle类型的参数，这个参数一般情况下是null，如果在活动呗系统回收之前有通过onSaveInstanceState保存的话，这个参数就会带有之前所保存的全部数据，因此通过以下方法取即可： 12345678@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if(savedInstanceState != null)&#123; String name = savedInstanceState.getString(\"glassx\"); &#125; &#125; 活动的启动模式在实际项目中我们应该根据特定的需求为每个活动指定恰当的启动模式，启动模式一种四种：standard、singleTop、singleTask、singleInstance。 standard是默认的启动模式。每次启动都会创建一个新的实例。 singleTop：有些情况下，可能会觉得standard不太合理，活动明明已经在栈顶了，为毛还要再创建新的实例呢？singleTop模式可以解决这个问题，当活动以该模式启动时，如果发现返回栈的栈顶已经是该活动，那就直接使用它，不创建新的实例，并且调用栈顶实例的onNewIntent方法；如果栈顶不是该活动，就创建该活动的新的实例。 singleTask：如果活动的启动模式指定为singleTask，那么每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果有，把这个活动之上的所有活动统统出栈，并且直接使用该实例，并调用该实例的onNewIntent方法？？（存疑，等会实践下）。反之没有的话就创建该活动的实例。 singleInstance：指定为singleInstance模式的活动会启用一个新的返回栈来管理这个活动（其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈）。 那么这样做有什么意义呢？想象以下场景，我们的程序中有一个活动是允许其他程序调用的，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，应该如何实现呢？前面3中模式做不到，因为每个应用程序都会有自己的返回栈，同一个活动在不同的返回栈中入栈必然是创建了新的实例。而使用singleInstance模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活动，不管哪个应用来访问这个活动，都公用一个返回栈，也就解决了共享活动实例的问题。 注意：如果三个活动，A和C都是standard模式，B是singleInstance模式，那么A启动B，B启动C后，在C界面按返回键是回退到A，再按返回键回退到B，接着按返回键才会退出应用，因为A和C是同一个回退栈中，B单独在一个栈中，可以用如下图来理解这一过程。 活动的最佳实践知晓当前是在哪一个活动建一个BaseActivity，在onCreate的时候打印出来当前实例的类名，之后其他的activity都继承这个activity即可： 123456@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(\"BaseActivity\",getClass().getSimpleName()); &#125; 随时随地退出app如果你在第三个activity界面，这个时候想要退出App是非常不方便的，可以新建一个类来管理所有Activity： 1234567891011121314151617public class ActivityController&#123; public static List&lt;Activity&gt; activities = new ArrayList&lt;Activity&gt;(); public static void addActivity(Activity ac)&#123; activities.add(ac); &#125; public static void removeActivity(Activity ac)&#123; activities.remove(ac); &#125; public static void finishAll()&#123; for(Activity ac : activities)&#123; ac.finish(); &#125; &#125;&#125; 这样只需要在BaseActivity的onCreate里面执行ActivityController的addActivity方法，即可把Activity添加进去，在BaseActivity的onDestroy方法中执行removeActivity，将其移除，在需要退出app的时候，只需要执行finishAll即可。 启动活动最佳写法每个Activity中都写上启动自己的方法： public class TestActivity extends BaseActivity{ public static void actionStart(Context context,String name,String sex){ Intent intent = new Intent(context,TestActivity.class); intent.putExtra(\"name\",name); intent.putExtra(\"sex\",sex); context.startActivity(intent); } } 这样做的一个好处就是，启动这个activity所需要的参数一目了然，而无需阅读这个activity的源码就可以直接调用方法就能避免漏掉参数。","categories":[],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第1章：开启启程","slug":"第一行代码（第二版）-第一章","date":"2018-05-31T10:00:00.000Z","updated":"2019-05-01T08:43:32.932Z","comments":true,"path":"2018/05/31/第一行代码（第二版）-第一章/","link":"","permalink":"https://glassx.gitee.io/2018/05/31/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"","text":"Android系统架构 最底层是Linux内核层。 为Android设备各种硬件提供了底层驱动，如显示驱动，音频驱动等。 系统运行库层。 这层通过一些C/C++库来为Android系统提供主要的特性支持。如Sqlite库提供了数据库支持，OpenGL|ES提供提供3D绘图等。 应用框架层。 主要提供了构建应用程序可能用到的各种API。 应用层。 所有安装在手机上的应用程序都属于这一层。比如系统自带的联系人、短信等程序，自己开发的应用。 Android应用开发特色四大组件四大组件分别是活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）和内容提供器（Content Provider） build.gradle 文件中，compileSdkVersion用于指定项目的编译版本；buildToolsVersion用于指定项目构建工具的版本；applicationId用于指定项目的包名，并且它的优先级高于在 AndroidManifest.xml中指定的包名；minSdkVersion用于指定项目最低兼容的Android版本;targetSdkVersion表明你在该目标版本上做过了充分的测试，系统将为你的应用程序启用一些最新的功能和特性。比如说Android6.0 系统中引入了运行时权限这个功能，如果你将targetSdkVersion指定成23或者更高，那么系统就会为你的程序启用运行时权限功能；否则就不会启用运行时权限功能。 而在build.gradle的dependencies闭包中，声明了当前项目所有的依赖关系，Android studio 项目一共有3中依赖方式，本地依赖、库依赖和远程依赖，本地依赖可以对本地的jar包或者目录添加依赖关系，形式如：compile fileTree(dir: ‘libs’, include: [‘*.jar’])；库依赖可以对项目中的库模块添加依赖关系，如compile(name: ‘testsdk’, ext: ‘aar’)；远程依赖则可以对jcenter库上的开源项目添加依赖关系，如compile ‘com.android.support.constraint:constraint-layout:1.0.2’，其中，com.android.support.constraint是域名，用于和其他公司的库作区分，constraint-layout是组名称，用于和同一个公司其他库作区分。 关于日志：不用System.out.println()，因为Log系统可以对日志分级，可以展示打印时间，可以添加过滤器等等。Log快捷键：如果要打Log.d，则输入logd，按tab键即可，同理Log.i只需要logi之后按Tab键，以此类推，四种级别的日志都能快捷打出来。还有，如果在oncreate方法外面输入logt，然后按下Tab键，就会以当前的类名作为值自动生成一个类似下面的TAG常量： 1234public class HelloWorldActivity extends AppCompatActivity&#123; private static final String TAG = \"HelloWorldActivity\";&#125;","categories":[],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第6章：死锁","slug":"现代操作系统（第三版）-第6章","date":"2018-05-30T10:00:00.000Z","updated":"2019-05-01T08:43:03.762Z","comments":true,"path":"2018/05/30/现代操作系统（第三版）-第6章/","link":"","permalink":"https://glassx.gitee.io/2018/05/30/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-%E7%AC%AC6%E7%AB%A0/","excerpt":"","text":"如果有两个进程A和B需要将扫描的文档记录到CD上，进程A请求扫描仪并被授权使用，请求CD时发现已被B占用了，于是被拒绝，同理，B请求扫描仪也会被拒绝，于是产生死锁。在一个数据库系统中，为了避免竞争，可对若干记录加锁，如果进程A对R1加锁了，进程B对R2加了锁，接着这两个进程又试图把各自对方的记录也加锁，这是也会产生死锁。所以，软硬件资源都可能出现死锁。 资源和死锁条件资源分为两类，一类是可抢占资源（preemptable resource） 可以从拥有它的进程中枪战而不产生任何副作用，比如存储器。一个系统拥有256M的用户内存和一条打印机，如果有两个256M内存的进程都想打印，进程A获得了打印机，而B战友内存，但是幸运的是可以通过把进程B患处内存、把进程A换入内存可以实现抢占B的内存，这样，进程A继续运行并执行打印任务，然后释放打印机和内存。另一类是不可抢占资源（nonpreemptable resource）是指在不引起相关的计算失败的情况下，无法把它从占有它的进程中抢占过来，如CD刻录机。如果一个进程已经在开始刻盘，突然将刻录机分配给另一个进程，那么将划坏CD盘。 因此，总的来说，死锁和不可抢占资源有关，有关可抢占资源的潜在死锁通常可以通过在进程之间重新分配资源而化解，所以我们主要关注不可抢占资源上。当然，Coffman等人总结了发生（资源）死锁需要具备四个必要条件： 不可抢占。 已经分配给一个进程的资源不能强制性地被抢占，他只能被占有它的进程显式地释放。 互斥条件。 每个资源要么已经分配了一个进程，要么就是可用的。 占有和等待。 已经得到了某个资源的进程还可以再请求新的资源。 环路等待。 死锁发生时，系统中一定有由两个或者以上的进程组成一条环路，该环路中每个进程都在等待着下一个进程所占有的资源。 注意：死锁发生时，以上四个条件一定是同时满足的。任何一个不成立就不会发生死锁 死锁建模在讨论死锁解决方案之前，讨论如何对死锁建模是有意义的。有个叫Holt的人指出可以利用有向图建立死锁四个条件的模型——在有向图中有两类节点：用圆形表示进程，用方形表示资源。从资源节点到进程节点的有向边代表该资源已被请求、授权并被进程占用，由进程节点到资源节点的有向边表明当前进程正在请求该资源。以下是一个示意图： 图中，当前资源R整备进程A占用，进程B正等待着资源S，图c)进入了死锁状态，进程C等待着资源T，资源T被进程D占用，进程D又等待着由进程C占用的资源U。 处理方法总而言之，有四种处理死锁的策略： 忽略该问题。也许如果你忽略它，他也会忽略你。 检测死锁并恢复。 让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题。 仔细对资源进行分配，动态地避免死锁。 破坏引起死锁的四个必要条件之一，防止死锁产生。 以下对这四种策略分别阐述。 忽略问题最简单的方法是鸵鸟算法：把头埋进沙子里，假装根本没有问题发生。不同人对于该方法的看法不同，数学家认为这种方法不能接受，不管代价多大，都要彻底防止死锁产生；而对于工程师，它们会考量死锁发生的频率和严重性，如果平均5年一次死锁，那么大多数工程师不会以性能损失和可用性代价去防止死锁。 检测死锁和死锁恢复每种类型一个资源的死锁检测从最简单的例子开始，假定每种类型的资源只有一个，即排除了同时有两台打印机的情况。我们假设一个系统包括A到G共7个进程，R到W共6中资源，资源的占有情况和进程对资源的请求情况如下：（1）A进程持有R资源，且需要S资源。（2）B进程不持有任何资源，但需要T资源。（3）C进程不吃油任何资源，但需要S资源。（4）D进程持有U资源，且需要S资源和T资源。（5）E进程持有T资源，且需要V资源。（6）F进程持有W资源，且需要S资源。（7）G进程持有V资源，且需要U资源。 问：系统是否存在死锁？如果存在，涉及哪些进程？ 回答这一问题，初看很难，但是建模构造一张资源分配图之后，可以直观地看到图中包含了一个环，如下图所示： 在换种，可以看出进程D、E、G已经死锁，A、C、F没有死锁，因为可以把资源S分配给它们中的任意一个。 每种类型有多个资源的死锁检测如果一类资源可能存在多个，就需要采用另一个方法来检测死锁。现在我们提供一种基于矩阵的算法来检测从P1到Pn这n个进程中的死锁。假设资源类型数为m，E1代表资源类型1，E2代表资源类型2，以此类推。E是现有资源向量，代表每种已存在的资源总数，比如资源类型1代表磁带机，那么E1=2就表示系统有两台磁带机。 在任意时刻，某些资源已被分配所以不可用，假设A是可用资源向量，那么Ai表示当前可供使用的资源数（即没有被分配的资源）。如果仅有的两台磁带机都已经分配出去了，那么A1的值为0 。 现在我们需要两个数组：C代表当前当前分配矩阵，R代表请求矩阵。C的第i行代表Pi当前所持有的每一种类型资源的资源数，所以Cij代表进程i所持有的资源j的数量，同理Rij代表Pi所需要的资源j的数量，数据结构如下图： 这四种数据结构之间有一个重要的恒等式，具体地说，某种资源要么已分配，要么可用，这个结论意味着： 换言之，如果我们将所有已分配的资源j的数量加起来在和所有可供使用的资源数相加，结果就是该类资源的资源总数。死锁检测算法就是给予向量的比较，我们定义向量A和向量B之间的关系为A小于或等于B以表明A的每一个分量要么等于要么小于和B向量对应的分量。 每个进程起初是没有被标记的，算法开始会对进程做标记，进程被标记后就表明它们能够被执行，不会进入死锁，死锁检测算法如下： 寻找一个没有标记的进程Pi，对于它而言，R矩阵的第i行向量小于或等于A。 如果找到了这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转到第1步。 如果没有这样的进程，算法终止。 算法的第1步是寻找可以运行完毕的进程，该进程有资源请求并且该请求可被当前的可用资源满足。这一选中的进程随后就被运行完毕，在这段时间内它释放自己持有的所有资源并将它们返回到可用资源库中，然后，这一进程被标记为完成，如果所有的进程最终都能运行完的话，就不存在死锁，如果进程一直不能被运行，那它们就是死锁进程。 从死锁恢复我们讨论各种从死锁中恢复的方法，尽管这些方法看起来都不那么令人满意： 利用抢占恢复。 临时将资源从当前所有者哪里转移到另一个进程，许多情况下这是需要人工敢于的。比如，要将激光打印机从它持有的进程那里拿走，管理员可以收集已打印好的文档，然后该进程被挂起，接着打印机被分配给另一个进程。 利用回滚恢复。 周期性地将进程的状态写入一个文件以备重启。一旦检测到死锁，拥有所需要资源的进程会回滚到一个时间点，在此时间点之前该进程获得了一些其他资源，在该检查点之后所做的工作都丢失。实际上，是将该进程复位到一个更早的状态，那时候它还没取得所需的这个资源。接着就把这个资源分配给一个死锁进程。 杀死进程恢复。 杀死环中的一个进程。或者杀死环外带有该资源的一个进程。 动态避免死锁利用资源轨迹图、安全状态和不安全状态、银行家算法去解决。这里略复杂，暂时先不深入研究。 破坏引起死锁的四个条件之一 破坏互斥条件，如果资源不被一个进程独占，那么死锁肯定不会产生。 当然，允许两个进程同时使用打印机会造成混乱，通过采用假脱机（spooling printer）技术可以允许若干个进程同时产生输出。该模型中唯一真正请求使用物理打印机的进程是打印机守护进程，由于守护进程绝不会请求其他资源，因此不会产生死锁。 破坏占有和等待条件。只要禁止已持有资源的进程再等待其他资源便可以消除死锁。 一种实现方法是规定所有进程在开始执行前请求所需的全部资源。如果所需的全部资源可用，那么就将它们分配给这个进程，于是该进程肯定能够运行结束。如果一个或者多个资源正被使用，那么就不分配，进程等待。另一种方案是，要求当一个进程请求资源时，先暂时释放其当前占用的所有资源，然后再尝试一次获得所需要的全部资源。 破坏不可抢占条件。 假如一个进程已分配到一台打印机且正在进行打印输出，如果由于它需要的绘图仪无法获得而强制性把打印机抢占掉，则会引起混乱。但是，一些资源可以通过虚拟化的形式来避免发生这样的情况，假脱机打印机向磁盘输出，并且只允许打印机守护进程访问真正的物理打印机，就可以消除涉及打印机的死锁。然而，不是所有资源都可以进行类似的虚拟化，比如数据库中的记录在操作的时候必须要锁定，因此存在死锁的可能 破坏环路等待。 消除环路有几种方法。比较靠谱的方案是，对所有的资源统一编号，现在的规则是，进程可以在任何时刻提出资源请求，但是所有请求必须按照资源编号的顺序（升序）提出，如下图所示，进程可以先请求打印机后请求磁带机，但不可以先请求绘图仪后请求打印机。 最后，总结一张图用于预防死锁：","categories":[],"tags":[{"name":"读书笔记-现代操作系统（第三版）","slug":"读书笔记-现代操作系统（第三版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/"}]},{"title":"第2章：进程与线程","slug":"现代操作系统（第三版）-第2章","date":"2018-05-29T10:00:00.000Z","updated":"2019-05-01T08:42:54.803Z","comments":true,"path":"2018/05/29/现代操作系统（第三版）-第2章/","link":"","permalink":"https://glassx.gitee.io/2018/05/29/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-%E7%AC%AC2%E7%AB%A0/","excerpt":"","text":"进程是操作系统提供的最古老也是最重要的抽象概念之一。即使CPU只有一个，但他们也支持（伪）并发操作的能力。他们将一个单独的CPU变换成多个虚拟的CPU，没有进程的抽象，现代计算将不复存在。 进程在任何多道程序设计系统中，CPU由一个进程快速切换到另一个进程，使每个进程各运行几十或者几百个毫秒，严格地来说，在某一个瞬间，CPU只能运行一个进程，但在1秒钟期间，它可能运行多个进程，这样就能产生并行的错觉，这就是伪并行。伪并行概念用来区分多处理器系统（系统有两个或者更多CPU并共享同一个物理内存）的真正硬件并行。 进程模型一个进程就是一个正在执行的程序的实例，包括程序计数器、寄存器和变量当前值。从概念上讲，每个进程拥有它自己的CPU，当然，真正的CPU在各进程间来回切换，这种快速的切换称作多道程序设计。在多道程序计算机内存中有若干道程序，这些程序被抽象为若干个各自拥有自己控制流程（即每个程序自己的逻辑程序计数器）的进程，并且每个程序都独立地运行。当然，实际上只有一个物理程序计数器，所以程序运行时，它的逻辑程序计数器被装入实际的程序计数器，当该程序结束（或暂停）执行时，物理程序计数器被保存在内存中该进程的逻辑程序计数器中。 由于CPU在各进程之间来回快速切换，所以每个进程执行器运算的速度是不确定的，并且当同一进程再次运行时，器运算速度通常也不可再现。例如，考虑一个 I/O 进程，它执行一个10000次的空循环以等待磁带机达到正常速度，然后发出命令读取第一个记录。如果CPU决定在空循环期间切换到其他进程，则磁带机进程可能在第一条记录通过磁头之后还未被再次执行。 进程和程序间的却别是微妙的，但是非常重要。想象以为父亲正在为他的女儿烘制生日蛋糕，则做蛋糕的食谱就是程序（即用适当形式描述的算法），这位父亲是处理器（CPU），而做蛋糕各种原料（面粉、糖、鸡蛋等）就是输入的数据，进程就是他阅读食谱、取各种原料以及烘制蛋糕等一系列动作的总和。现假设他的儿子被蜜蜂蛰了哭着跑进来，父亲于是就记录下当前照着食谱做到哪里了（保存进程当前状态），拿出急救手册，为儿子处理蜇伤，我们看到处理机从一个进程（做蛋糕）切换到另一个优先级高的进程（医疗救治），每个进程有各自的程序（食谱和急救手册）。当急救完成之后，父亲又继续做蛋糕，从离开时的那一步继续做下去。值得注意的是，我们可能经常两次去启动同一个字处理软件，即一个程序运行了两遍，这也要算作两个进程。 创建进程有4中主要事件导致进程创建： 系统初始化 启动操作系统时，通常会创建若干进程，这些进程中有些是前台进程，用于同用户（人类）交互。其他的是后台进程，后台进程一般具有某些专门的功能，例如，设计一个后台进程接收发来的电子邮件，这个进程在一天的大部分时间都在睡眠，但是当电子邮件达到时就被唤醒了。停留在后台处理诸如电子邮件、web页面、新闻、打印之类的活动的进程称为守护进程（daemon）。 正在运行的进程进行系统调用创建 正在运行的进程发出系统调用，以便创建一个或者多个线程协助其工作。 用户请求创建一个新的进程。 用户双击图标或者输入命令行，启动一个新的程序。 一个批处理作业的初始化 仅在大型机的批处理系统中应用，用户在这种系统中提交批处理作业，在操作系统认为有资源科运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。 在Unix系统中，只有一个系统调用可以创建新的进程：fork。它会创建一个与调用进程相同的副本，这两个进程（父进程和子进程）拥有相同的存储镜像、同样的环境字符串和同样的打开文件，这就是全部情形。通常，子进程接着执行execve或者一个类似的系统调用，以修改器存储镜像并运行一个新的程序。例如，当一个用户在shell中输入sort时，shell就创建一个子进程，然后这个子进程执行sort。在Windows中，情形正相反，一个win32函数调用 CreateProcess既处理进程的创建，也负责把正确的程序装入新的进程。不论在Unix还是Windows中，进程创建后，父进程和子进程有各自不同的地址空间。 进程的终止进程终止，通常由下列条件引起： 正常退出（自愿） 进程完成了自己的工作，调用系统调用，通知工作已经完成。 出错退出（自愿） 进程发现了严重错误，如要编译某个文件，但是该文件不存在，于是编译器就会退出。再给出了错误参数时，面向屏幕的交互式进程通常不退出，相反，这些程序会弹出一个对话框，并要求用户再试一次。 严重错误（非自愿） 进程引起的错误，通常是由于程序中的错误导致，例如执行了非法指令，引用不存在的内存等。在这类错误中，进程会收到信号（被中断），而不是在这类错误出现时终止。 被其他进程杀死（非自愿） 进程的状态尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但进城之间经常需要相互作用，一个进程的输出结果可能作为另一个进程的输入，在shell命令： cat chapter1 chapter2 chapter3 | grep tree 中，第一个进程运行cat，将三个文件链接并输出，第二个进程运行grep，它从输入中选择所有包含单词tree的那些行。根据这两个进程的相对速度，可能发生这种情况：grep准备就绪可以运行，但输入还没有完成，于是必须阻塞grep；还有可能是：一个概念上能够运行的进程被迫停止，因为操作系统调度另一个进程占用了CPU。下图可以看到显示进程的三种状态的状态图： 运行态和就绪态在逻辑上是类似的，二者都可以运行，只是后者还没有CPU分配给它，阻塞态就完全不同，处于该状态的进程不能运行，即使CPU空闲也不行。在操作系统发现进程不能继续运行下去时，发生转换1；转换2和3是由于进程调度引起的；当进程等待的一个外部事件发生时（如一些输入到达），则发生转换4。 进程的实现操作系统维护者一张表格，即进程表（process table）。每个进程占用一个进程表项，该表项包含了进程状态的重要信息，诸如程序计数器、堆栈指针，内存分配状况、所打开的文件的状态、账号和调度信息等。下图展示了典型系统中的关键字段： 多道程序设计模型采用多道程序设计可以提高CPU利用率，从概率的角度来看cpu的利用率是比较好。假设一个进程等待I/O操作的时间与其停留在内存中的时间比是p,当内存中有n个进程时，则所有n个进程都在等待I/O（此时CPU空转）的概率是p的n次方，CPU的利用率由一下公式给出： 从完全精确的角度考虑，应该指出此概率模型只是描述了一个大致的状况。它假设所有n个进程都是独立的，即内存中的5个进程中，3个运行，2个等待是完全可以接受的，但在单cpu中，不能同时运行3个进程，所以当CPU忙时，已就绪的进程必须等待CPU，因而，进程不是独立的，更精确的模型应该使用排队论构造，但它仍然是具有参考意义的，下图以n为变量的函数表示CPU的利用率，n称为多道程序设计的道数（degree of multiprogramming）。 从图中可以看到，如果进程花费80%的时间等待I/O，为使CPU的浪费低于10%，至少要有10个进程同时在内存中。当读者认识到一个等待用户从终端输入的交互式进程是处于I/O等待状态时，很明显，80%甚至更多的I/O等待时间是普遍的，即使是在服务器中，做大量磁盘I/O操作的进程也会花费同样或更多的等待时间。虽然图中的模型很粗略，但它依然对预测CPU的性能很有效。例如，假设计算机有512MB内存，操作系统占128MB，每个用户程序占128MB，那么这些内存允许3个用户程序同时驻留内存，若80%时间用于I/O等待，则CPU利用率大约是1-0.80.80.8 ，大约49%，在增加512MB内存后，CPU利用率可以提高到79%，换而言之，第二个512M内存提高了30%的吞吐量。但是增加第三个512MB内存只能讲CPU利用率提高到91%，吞吐量仅提高12%，因此可以确定第一次增加内存是合算的投资，第二个则不是。 线程线程的使用人们认为需要使用线程的理由如下： 并行的线程可以共享同一个地址空间和所有可用数据的。 对于某些应用而言，这是必需的，二者正式多进程模型（它们具有不同的地址空间）所无法表达的。 线程比进程更轻量级，更快捷地创建和撤销。 在许多系统中，创建一个线程较一个进程要快10~100倍。在有大量线程需要动态和快速修改时，这一特性很有用。 若多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行，从而加快应用程序执行速度。 在多CPU系统中，多线程是有益的，在这样的系统中，真正的并行有了实现的可能。 假如字处理软件被编写成含有3个线程的程序，一个与用户交互，另一个在后台重新进行格式处理，一旦有某一句语句被删掉，交互线程就通知格式化线程对整个文档重新进行处理，同时交互线程继续监控键盘和鼠标，并相应诸如滚动到第一页之类的简单命令。剩下那个每隔一段时间进行磁盘备份，防止程序崩溃或者系统崩溃。拥有三个线程的情形如下图所示： 如果程序是单线程的，那么在进行磁盘备份时，来自键盘和鼠标的命令就会被忽略，直到备份工作完成为止。并且，很显然在这里三个不同的进程是不能工作的，这是因为三个线程都需要在同一个文件上进行操作，通过让三个线程代替三个进程，三个线程共享公共内存，于是它们都可以访问同一个正在编辑的文件。 现在考虑另一个多线程发挥作用的例子，一个web服务器，某些页面较其它页面相比，有更多的访问，比如对主页的访问比其它更深层次的页面访问次数更多。利用这一事实，web服务器可以把获得大量访问的页面集合保存在内存中，这样的一种页面集合称为高速缓存（cache），高速缓存也应用在其它很多场合。一种组织web服务器的方式如下图所示： 上图中，一个称为分派程序（dispatcher）的线程从网络中读入工作请求，在检查请求之后，分派现成挑选一个空转的（即被阻塞的）工作线程（worker thread）提交该请求。接着分派现成唤醒该工作线程，将它由阻塞状态转变为就绪状态。工作线程被唤醒后，它检查有关的请求是否在web页面的cache中，这个高速缓存是所有线程都可以访问的，如果没有，该线程开始执行从磁盘中调入页面的I/O操作，并且进入阻塞直到磁盘操作完成。当上述工作线程阻塞在磁盘操作时，为了完成更多操作，分派线程可能挑选另一个工作线程运行，也可以把另一个已经就绪的工作线程投入运行。 这种模型允许把服务器编写为一个集合，在分派线程的程序中包含一个无限循环，该循环用来获得工作请求并把工作请求派给工作线程。每个工作线程的代码包含一个从分派线程接收请求的无限循环，收到请求后，如果页面存在，则返回给客户机，接着该工作线程阻塞，等待一个新的请求到来。 在没有多线程的情况下，编写web服务器。一种可能的方式是：web服务器的主循环获得请求，检查请求，并在取下一个请求之前完成整个工作。在等待磁盘操作时，服务器空转，不处理任何到来的其他请求。课件线程较好地改善了web服务器的性能。如果对于这种性能的降低不可接受，那如果使用read系统调用，则还有一种可能的方式。在请求到来时，这个唯一的线程对请求进行考察，如果请求能在高速缓存中得到满足，那么一切都好，否则，就启动一个非阻塞的磁盘操作。服务器在表格中记录当前请求的状态，然后去处理下一个事件。下一个事件可能是一个新工作的请求，或是磁盘对先前操作的回答。如果是新工作的请求，就开始该工作；如果是磁盘的回答，就从表格中取出对应的信息，并处理该回答。对于非阻塞磁盘I/O而言，这种回答多数会以信号或者中断的形式出现。注意，这种情况下，“顺序进程”模型消失了，每次服务器从为某个请求工作的状态切换到另一个状态时，都必须显式地保存或者重新装入相应的计算状态。这里，每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，我们把这类设计称为有限状态机（finite-state machine）。 现在很清楚多线程必须提供的是什么了，多线程使得“顺序进程”的思想得以保留下来，这种顺序进程阻塞了系统调用（如磁盘I/O），但是仍旧实现了并行性。 经典线程模型进程用于把资源集中到一起，而线程是在CPU上被调度执行的实体。在同一个进程环境中，多个线程共享一个地址空间和其他资源，这意味着线程间共享同样的全局变量，一个线程也可以读、写甚至清除另一个线程的堆栈，线程间是没有保护的，因为这是没有必要的，因为同一个进程中的多个线程是合作而不是竞争关系。线程之间对于资源的持有如下图所示： 和传统进程一样（即只有一个线程的进程），线程可以处于若干种状态的任何一个：运行、阻塞、就绪或者终止。认识到每个线程有其自己的堆栈很重要，下图展示这一状况： 每个线程的堆栈有一帧，供各个被调用但是还没有从中返回的过程使用。例如，如果过程X调用过程Y，而Y又调用Z，那么当Z执行时，供X、Y和Z使用的帧会全部存在堆栈中。通常每个线程会调用不同的过程，从而有一个各自不同的执行历史，这就是为什么每个线程需要有自己的堆栈的原因。这里还可以了解线程的join操作和yield操作。 POSIX 线程POSIX线程是线程的POSIX（Portable Operating System Interface of UNIX，可移植操作系统接口）标准。它定义的线程包叫做Pthread。有两种主要的方法实现线程包：在用户空间中和在内核中。这两种方法互有利弊，不过混合实现方式也是可能的。 在用户空间中实现线程这种方法是把整个线程包放在用户空间，内核对线程包一无所知，从内核角度考虑，就是按单线程进程方式管理。这种方法的优点： 最明显的优点是：用户级线程包可以在不支持线程的操作系统上实现。 线程在一个运行时系统的顶部运行，这个运行时系统是一个管理线程的过程的集合。在用户空间管理线程时，每个进程需要有其专用的线程表（thread table），用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器等。该线程表由运行时系统管理，当一个线程转换到就绪态或者阻塞态时，需要在线程表中存放重新启动该线程所需的信息。如下图可以对比不同方式实现的线程包： 可以方便地在进程内调度切换到另一个线程，并且线程切换非常快捷。 在线程运行完成，例如，线程调用thread_yield ，就可以把线程的信息保存在线程表中，进而，线程调度程序来选择另一个要运行的线程。保存该线程状态的过程和调度程序都只是本地过程，所以启动它们比进行内核调用效率更高。 允许进程有自己定制的调度算法。 例如，那些有垃圾收集线程的应用程序就不用担心线程会在不合适的时刻停止。 尽管用户级线程具有上述的优点，但是它的缺点也明显： 第一个问题是如何实现阻塞系统调用。 假设在还没有任何按键动作之前，一个线程读取键盘，让该线程时机进行该系统调用时不可接受的，因为这会停止所有的线程。使用线程的一个主要目标是：首先要允许每个线程使用阻塞调用，但是还要避免被阻塞的线程影响其他的线程。有了阻塞系统的调用，这个目标不太容易实现。 页面故障问题。 如果某个程序调用或者跳转到了一条不在内存的指令上，而操作系统将到磁盘上取回这个丢失的指令（和该指令的“邻居们”），这就称为页面故障。如果有一个线程引起页面故障，内核甚至不知道有线程存在，通常会把整个进程阻塞，直到磁盘I/O完成为止，尽管其他线程是可以运行的。 如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU。 在一个单独的进程内部，没有时间中断，所以不可能用轮转调度（轮流）的方式调度进程。 可能反对用户级线程的最大负面意见是，程序员通常在经常发生线程阻塞的应用中才希望使用多个线程。 在内核中实现线程由上面在用户空间实现的线程和在内核空间实现的线程对比图可以看出，在内核中实现线程不在需要运行时系统，另外，每个进程中也没有线程表。所有能够阻塞线程的调用都以系统调用的形式实现，这与运行时系统过程相比，代价是相当可观的。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程或者运行另一个进程中的线程。而在用户级线程中，运行时始终运行自己进程的线程，直到内核剥夺它的CPU。如果某个进程中的线程引起页面故障，内核可以很方便地检查该进程是否还有其他可运行的线程，如果有，在等待所需要的页面从磁盘读入时，就选择一个线程运行。 在内核中实现线程有以下缺点： 但是内核中创建、撤销、切换线程操作代价都比较大。 在内核中尽量减少创建和撤销线程，最好能实现复用（在执行完成后，标记为不可运行，当要创建新线程时，再将其启用）。 信号是发给进程而不是线程，当信号达到时要考虑将信号交给哪个线程处理。 即使线程可以注册感兴趣的信号，但是多个线程注册同一个信号如何处理也是个问题。 混合实现有试图将用户级线程的优点与内核级线程的优点结合起来的方法，一种方法是使用内核级线程，然后将用户级线程与某些内核线程多路复用起来，如下图所示： 进程间通信这个部分看了两次都不甚明白，先跳过。 调度进程行为几乎所有进程的（磁盘）I/O请求或计算都是交替突发的。如下图所示，CPU不停顿地运行一段时间，然后发出一个系统调用以便读写文件。如下图所示： 图中有一件事值得注意，某些进程花了大多数时间在计算上，称为计算密集型；有些在等待I/O上花了大多数啊时间，称为I/O密集型。有必要指出，随着CPU越来越快，更多的进程倾向于I/O密集型，这里的基本思想是，如果需要运行I/O密集型进程，那么就应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙碌。 何时调度 创建新进程后，决定运行父进程还是子进程。 在一个进程退出时必须做出调度决策。 一个进程阻塞时，必须选择另一个进程运行。 发生I/O中断时，做出调度决策。 调度算法的目标在讨论目标前，有必要了解我们会处于那些环境中，在不同的应用领域有不同的环境，可以将其分为三类： 批处理 交互式 实时 下图针对所有环境列出不同的目标： 批处理系统的调度算法 先来先服务最短作业优先最短剩余时间优先 交互式系统调度算法 轮转调度优先级调度多级队列调度：最短进程优先保证调度彩票调度公平分享调度","categories":[],"tags":[{"name":"读书笔记-现代操作系统（第三版）","slug":"读书笔记-现代操作系统（第三版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/"}]},{"title":"第14章：安全HTTP","slug":"HTTP 权威指南-第14章","date":"2018-05-25T00:00:00.000Z","updated":"2019-05-01T08:42:12.639Z","comments":true,"path":"2018/05/25/HTTP 权威指南-第14章/","link":"","permalink":"https://glassx.gitee.io/2018/05/25/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC14%E7%AB%A0/","excerpt":"","text":"前面讨论的基本认证方式和摘要认证以及报文完整性检查都是轻量级的方法，但对于重要的如银行业务处理，大规模网上购物来说，这还不够，我们需要一种能够提供下列功能的HTTP安全技术： 服务器验证，客户端验证服务器是真的还是伪造的 客户端认证，服务器验证客户端是真的还是伪造的 完整性，客户端和服务器的数据不被修改 加密，无需担心会话被窃听 效率，算法的运行要求足够快 普适性，基本上所有的客户端和服务器都支持这种协议 其他 httpshttps是最流行的HTTP安全形式，它的URL以** https:// ** 而不是 http:// 开头。所有的HTTP请求和响应数据在发送到网络之前都要进行加密，HTTPS在HTTP下面提供了一个安全层，可以使用SSL，也可以使用其后继者TSL（Transport Layer Security，传输层安全），由于二者十分类似，所以一般不太严格地用SSL来表示SSL和TSL。 数字加密概念 密码：对文本进行编码的算法。 密钥：改变密码行为的数字化参数 对称密钥加密系统：编/解码使用相同密钥的算法 不对称密钥加密系统：编/解码使用不同密钥的算法 公开密钥加密算法：一种能够使数百万计算机便捷地发送机密报文的系统 数字签名：用来验证报文是否被改动的校验和。 数字证书：由可信的组织验证和签发的识别信息 假如使用rot3（循环移位3字符）方式对报文加密，则 明文 meet 加密后为 phhw，示意图如下： 那在概念中，密码就是 “循环移位N字符” ，N的值是由密钥控制的，在这里N的值是3。 改变密钥的值就能产生不同的密文。编码算法和编码机器都可能落入敌人手中，但是只要没有正确的号盘设置（密钥值），也无法实现解码。这种属于使用了密钥的密码。 数字密码：数字密码只是一些数字，这些数字密钥值是编码/解码算法的输入，编码算法就是一些函数，这些函数会读取一块数据，并根据算法和密钥的值对其进行编码/解码。给定一段明文P、一个编码函数E和一个数字编码密钥e，就可以生成一段经过编码的密文C，通过解码函数D和解码密钥d，就可以将密文C解码为原始的明文P，当然，编码/解码函数互为反函数。 对称密钥加密技术对称密钥加密在编码时候使用的密钥值和解码时候的密钥值一样的。保持密钥的机密很重要，在很多情况下，编码解码算法都是众所周知的，因此密钥是唯一保密的东西了。可用密钥的数量取决于密钥中的位数，以及可能的密钥中有多少是有效的。就对称加密而言，通常所有的密钥值都是有效的（知名的非对称密钥加密系统RSA中，有效密钥必须以某种方式与质数相关，因此并非所有的密钥都有效）。8位的密钥只有256个可能，40位的密钥可以有2的40次方个可能的密钥值等等。 流行的对称密钥加密算法有:DES/Triple-DES、RC2、RC4 缺点：发送者和接收者在对话前一定要有一个共享的保密密钥，服务器与每个客户端都需要有一个独立的密钥，以致如果客户端数量过多的情况下，服务器保存的密钥数量可观。如果N个节点，每个节点都要和其他所有N-1个节点通信，总共大概会保存N的平方个密钥，这将是一个管理噩梦。 公开密钥加密技术公开密钥加密技术使用了两个非对称密钥，一个用来对报文编码，一个用来对报文解码。编码密钥是可以公之于众的，每个不同的客户端可以用相同的编码密钥进行加密，但是只有主机自己才知道私有的解密密钥，只有解密密钥才能解码。 在引入公钥加密机制之前，可以先看两个问题： 问题1:314159265358979 × 314159265358979 的结果是多少？问题2： 3912571506419387090594828508241 的平方根是多少？ 如果不用计算器，第一个问题，相信大多数人花上一两个小时用纸笔能够计算出来，而第二个问题，即使花上一两天，估计也基本上没人能解出来。虽然平方和开方互为逆运算，但是它们的复杂度差异却很大，这种不对称性构成了公钥密码体系的基础。一种叫做RSA的公钥机制表明，对计算机来说，大数的乘法比对大数进行因式分解要容易得多。所有公开密钥非对称加密系统的要求是，即便拥有以下线索： 公开密钥（共有的，每个人都可以获得） 一小片拦截下来的密文（可以网络嗅探获得） 一条报文以及与之相关的密文（对一段文本使用公钥加密就可以得到） 也无法计算出保密的私有密钥。 RSA 就是满足这些条件的流行的公开机密要加密系统。RSA的算法是公开的，源代码也可以获得，破解的难度与一个极大的数字进行质因数分解的难度一样。 混合加密系统和会话密钥任何人只要知道了公开密钥，就可以向一台公共服务器发送安全报文，所以非对称的公开密钥加密系统是很好用的，两个节点无须为了进行安全的通信而先交换私有密钥。但公开密钥加密算法的计算可能会很慢，比较常见的做法是在两个节点之间通过便捷的公开密钥加密技术建立起安全通信，然后再利用那条安全通道产生并发送临时的随机对称密钥，通过更快的对称加密技术对其余的数据进行加密。 数字签名除了加密/解密报文之外，还可以用加密系统对报文进行签名（sign），以说明是谁编写的报文，同时证明报文未被篡改过，这种技术被称为数字签名（digital signing）。签名是加了密的校验和，使用数字签名有以下两个好处： 签名可以证明是作者编写了这条报文。 只有作者才有最机密的私有密钥，因此只有作者才能计算出这些校验和。 签名可以防止报文被篡改。 如果恶意攻击者在传输过程中修改了报文，则校验和就不再匹配了，攻击者没有私钥，无法为篡改的报文伪造正确的验证码。 以下例子说明了节点A是如何向节点B发送一条报文，并对其进行签名： 节点A将变长报文提取为定长摘要。 节点A对摘要应用一个“签名”函数，这个函数会将用户的私有秘钥作为参数。因为只有A知道私有密钥，所以正确的签名函数会说明签名者就是所有者。在下图中，由于解码函数D中包含了用户的私有密码，所以我们将其作为签名函数使用。 一旦计算出签名，节点A就将其附加在报文末尾，并将报文和签名都发给B 在接收端，如果B需要确定报文确实是A写的，而且没有被篡改过，节点B就可以对签名进行检查。节点B接收经过私有秘钥扰码的签名，并应用了使用公开密钥的反函数，如果拆包后的摘要与节点B自己的摘要版本不匹配，就说明要么被篡改了，要么发送者不是A。 数字证书数字证书都是由可信任的颁发机构颁发，它通常包括 对象的名称、过期时间，证书颁发者，来自证书发布者的数字签名、通常还包括对象的公开密钥以及对象使用签名算法的描述性信息。典型的数字签名格式如下： 数字证书没有单一的全球标准，但现在大多数证书都以一种标准格式 ——X.509 v3 描述。 用证书对服务器进行认证通过https建立一个安全的web事务之后，现代的浏览器会自动获取所连接服务器的数字证书，如果如武器没有证书，安全连接就会失败，服务器证书中包含很多字段，包括： web站点的名称和主机名； web站点的公开密钥； 颁发机构的名称； 颁发机构的签名。 浏览器收到证书时会对签名颁发机构进行检查，如果这个机构是很权威的公司，那浏览器一般已经知道其公开密钥了（浏览器会预先安装很多签名颁发机构的证书），就能像之前那样验证签名了。如果对签名颁发机构一无所知，浏览器就无法确定是否应该信任这个签名颁发机构，它通常会向用户展示一个对话框，看用户是否相信这个签名发布者，因为发布者可能是本地IT部门。以下展示了验证签名的过程： HTTPS-细节介绍https就是在安全的传输层上发送的http，它在将http报文发送给TCP之前，先将其发送给一个安全层，对其进行加密。对web服务器发起请求时，我们需要一种方式来告知web服务器去执行http的安全协议版本，这是在URL的方案中实现的，对web资源执行某事务时，它会检查URL方案： 如果URL方案是http，客户端会打开一条到服务器端口80的连接（默认情况下），并发送http命令。 如果URL的方案是https，客户端就会打开一条到服务器端口443（默认情况）的连接，然后与服务器握手，以二进制格式与服务器交换一些SSL安全参数，附上加密的http命令。 在https中，客户端首先打开一条到web服务器端口443（默认情况）的连接，一旦建立了TCP连接，客户端和服务器就会初始化SSL层，对加密参数进行沟通，并交换密钥，握手完成后，SSL就初始化完成了，客户端就可以将请求报文发送给安全层了，在将这些报文发送给TCP之前，要先对其进行加密。http和https的对比： SSL握手在发送已加密的HTTP报文之前，客户端和服务端要进行一次SSL握手，主要完成以下工作： 交换协议版本号 选择一个两端都了解的密码 对两端身份进行验证 生成临时会话密钥，以便加密信道 SSL握手简化版示意图如下： 在一个web服务器上执行安全事务，比如提交银行卡信息时，总是希望在于你所认为的那个组织对话，因此https事务总是要求使用服务器证书的。站点证书有效性检查步骤如下： 日期检测。检查证书的起始日期和结束日期。 签名颁发者可信度检测。每个证书是由某个证书颁发机构（CA）签发的，它们负责位服务器担保，证书有不同的等级，每种证书都要求不同级别的背景验证。比如申请某个电子商务服务证书，通常要求提供一个营业的合法证明。 签名检测。一旦判定签名授权是可信的，浏览器就要对签名使用颁发机构的公开密钥，并将其与校验码比较，以查看证书的完整性。 站点身份检测。为防止服务器复制其他人的证书，或拦截他人流量，大部分浏览器都会试着去验证证书中的域名与它们所对话的服务器的域名是否匹配。 虚拟主机与证书对于虚拟主机（一台服务器上有多个主机名），有些流行的web服务器程序只支持一个证书，如果用户请求的是虚拟主机名，与证书名称并不完全匹配，浏览器就会显示警告框。比如cajun-shop.com网站，站点的托管服务提供商提供的官方名称位 cajun-shop.securesites.com。 用户进入http://www.cajun-shop.com时，服务器证书中列出的官方主机名（*.securesites.com）与用户浏览的虚拟主机名（www.cajun-shop.com）不匹配，以至于出现警告。 为了防止出现这个问题，cajun-shop.com的所有者会在开始处理安全事务时，将所有用户都重定向到cajun-shop.securesites.com。 通多代理以隧道形式传输安全流量很多公司都会在公司网络和公共因特网的安全边界上放置一个代理，代理是防火墙路由器唯一允许进行http流量交换的设备，它可能会进行病毒检测或者其他的内容控制工作。 但只要客户端开始用服务器的公开密钥对发往服务器的数据进行加密，代理就再也不能读取http首部了！代理不能读取首部，意味着无法知道应该将请求转向何处。 这种情况一种常用的技术就是https SSL 隧道协议，客户端首先要告知代理，他想要连接的安全主机和端口，这是在开始加密之前以明文形式告知的，所以代理可以理解这条信息。 http通过新的名为connect的扩展方法来发送明文形式的端点信息，connect方法会告诉代理，打开一条到期望主机和端口号的连接，这项工作完成之后，直接在客户端和服务器之间以隧道形式传输数据。 以下示意了一个connet：","categories":[],"tags":[{"name":"读书笔记-HTTP 权威指南","slug":"读书笔记-HTTP-权威指南","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"}]},{"title":"第12、13章：认证机制","slug":"HTTP 权威指南-第12、13章","date":"2018-05-23T00:00:00.000Z","updated":"2019-05-01T08:42:04.584Z","comments":true,"path":"2018/05/23/HTTP 权威指南-第12、13章/","link":"","permalink":"https://glassx.gitee.io/2018/05/23/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC12%E3%80%8113%E7%AB%A0/","excerpt":"","text":"第12章——基本认证机制当访问某些需要授权才能访问的资源时，服务器会返回401要求登录认证，web服务器会将受保护的文档组织成一个 安全域（security realm），每个安全域可以有不同的授权用户集。 一个例子假设web服务器建立了两个安全域，一个用于公司的财务信息，一个用于个人家庭的文档，那么公司的CEO应当能够访问销售额预测资料，但不应该允许CEO访问员工和其家人度假的照片。 下面是一个假想的基本认证质询，它指定了一个域： HTTP/1.0 401 UnauthorizedWWW-Authenticate：Basic realm=”Family” 域应该有一个描述性字符名，比如 Family（员工个人家庭照片），以帮助用户了解应该使用哪个用户名和密码。 缺点基本认证的机制很简单，但是存在以下主要的安全隐患： 基本认证以 username:pwd 的形式将用户名密码拼接起来，并且通过Base-64的加密后通过网络发送用户名和密码，这基本上相当于明文传输（base-64很容易破解）。 即使使用其他更难解密的方式加密，也没有机制防止重放攻击。 没有针对中间节点的防护，头部不被更改，能通过认证，但是报文内容更改了也能造成很大的危害。 第13章——摘要认证摘要认证试图修复基本认证协议的严重缺陷，它遵循的箴言是“绝不通过网络发送密码”，相对基本认证，它做了如下改进： 永远不以明文在网络上发送密码 可以防止恶意用户捕获并且重放的握手过程 可以选择性地防止对报文内容的篡改 防范其他常见形式的攻击 原理摘要认证的主要原理是“对信息主体的浓缩”，它认证的主要流程如下： 客户端请求了某个受保护的文档。 在客户端能够证明身份前，服务器拒绝提供文档，并向客户端发起质询，询问用户名和摘要形式的密码。 客户端传递用户名和密码的摘要。服务器知道所有用户的密码，将收到的摘要与自己用密码计算出来的摘要对比，即可校验用户身份真伪。 如果验证通过，则开始向客户端提供文档。 注意：整个过程都没有在网络上发送密码！而是发送密码的“摘要”或者说是指纹 整个过程图示如下： 摘要摘要是一种单向函数，主要用于将无限的输入值转换为有限的浓缩输出值，有时也将摘要函数称为加密的校验和、单向散列函数或者指纹函数。常见的摘要函数是 MD5 ，会将任意长度的字节序列转换为一个128位的摘要。MD5输出的128位的摘要通常会被写成32个16进制的字符，每个字符表示4位。 重放攻击使用单向摘要就无需以明文发送密码了，但是别有用心的人还是可以截获摘要，并一遍遍地重放给服务器，进行重放攻击，在这点上，摘要和密码一样好用。 为了防止重放攻击，服务器可以向客户端发送一个称为 随机数（nonce）的特殊令牌，这个数会经常发生变化（根据具体规则来定，可以每次认证都变化），客户端在计算摘要之前要先将这个随机数令牌附加到密码上去。在密码中加入随机数就会使摘要随着随机数的每次变化而变化，没有密码就无法计算出正确的摘要。 摘要认证的握手机制摘要认证的握手步骤流程如下： 客户端请求被保护的文档。 服务器计算出一个随机数，放入质询报文（WWW-Authenticate）中，与服务器支持的算法列表一同发给客户端。 客户端选择其中一个算法，计算出密码和其他数据的摘要。并将摘要放在认证报文（Authorization）中发回服务器，如果客户端要对服务器进行质询，可以发送客户端的随机数。 服务器接受摘要、选中的算法以及支撑数据，在本地生成摘要，并与客户端发来的摘要对比验证。如果客户端有对服务器进行质询，就会创建服务端摘要。 摘要认证会话过程优化预授权普通的认证方式中，事务结束前，每条请求都要有一次 请求/质询 的循环，如果客户端事先知道下一个随机数是什么，就可以取消这个 请求/质询 循环，这样客户端就可以在服务端发出请求之前，正确地生成Authorization首部了。这样就能减少报文的数量，对性能也有很大的提升，如图： 此外，还有几种预授权的方式： 服务器预先在Authentication-info成功首部中发送下一个随机数。 这虽然避免了 请求/质询 循环，但是它也破坏了对同一条服务器的多条请求进行管道化的功能，因为在发布下一条请求之前，一定要收到下一个随机值才行。 服务器允许在一段时间内使用同一个随机数。 可能会有一定次数的重放攻击的可能性。 客户端和服务器使用同步的、可以预测的随机数生成方法。 报文完整性保护如果使用了完整性保护（qop=”auth-init”），对应的内容就是对实体主体部分，而不是报文主体部分的散列，对于发送者，要在应用任意传输编码方式之前计算，而对于接收者，则应在去除所有传输编码之后计算。 总结安全隐患和相应解决方案 重放攻击。 用生成随机数解决，可能可以包括IP地址、时间戳、资源Etag等计算摘要。 多重认证机制。 比如同时存在基本认证和摘要认证时。可以考虑使用最强认证方案。 首部篡改。 防范方式：要么端到端加密，要么对首部进行数字签名，最好二者结合。 词典攻击。 没有好的对策，设置合理的密码过期策略，和难以猜测和破译的密码吧。 恶意代理攻击和中间人攻击。 没有更好的方法，唯一方式是使用SSL。 选择明文攻击。 利用摘要词典获取密码明文，或者暴力枚举可能的密码。 存储密码。 如果摘要认证密码文件被入侵，攻击者就获取到域中所有文件，而无需进行解码了。消除这个问题的方法：（1）加强保护 （2）确保域名在所有域中是唯一的。如果密码文件被入侵，所造成的破坏也局限于某一特定域。 摘要加密没有为内容的安全提供保障，可能可以知道内容是否被篡改，真正安全的事务是通过SSL才能实现。","categories":[],"tags":[{"name":"读书笔记-HTTP 权威指南","slug":"读书笔记-HTTP-权威指南","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"}]},{"title":"第11章：客户端识别与cookie机制","slug":"HTTP 权威指南-第11章","date":"2018-05-22T00:00:00.000Z","updated":"2019-05-01T08:41:56.364Z","comments":true,"path":"2018/05/22/HTTP 权威指南-第11章/","link":"","permalink":"https://glassx.gitee.io/2018/05/22/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC11%E7%AB%A0/","excerpt":"","text":"HTTP提供匿名、无状态的请求/响应 服务，为了给用户个性化的服务，有必要识别用户，主要的方式有： HTTP首部承载用户身份信息 HTTP请求首部有From （用户的email地址）、user-agent（用户的浏览器软件）、Referer（用户是从这个页面跳转过去的）、Authorization（用户名和密码）等字段，利用这些字段可以识别用户。 以下是首部承载的信息： 跟踪客户端IP地址，通过IP地址识别用户。 IP识别有弊端，（1）它识别的是及其，不是用户 （2）网络服务提供商可能会提供动态的IP （3）如果使用了代理，那获取到的IP可能只是代理的IP.（4）为了安全，用户可能通过网络地址转换（Network Address Translation， NAT） 防火墙来浏览网络内容，这些NAT设备隐藏了防火墙后面的那些实际客户端的IP。 用户登录，用认证方式识别用户。 如果服务器希望在为用户提供对站点的访问前先登录，则可以返回 401 Login Required ,然后浏览器会弹出登录框。这样就能显式地询问用户是谁。 胖UTL，在URL中嵌入识别信息的技术 有些web站点会为每个用户生成特定版本的URL来追踪身份，用户浏览站点时，web服务器会动态生成一些超链，继续维护URL中的信息。但是，这种方案有几点问题： 无法共享URL，包含了特定用户的信息，如果分享出去，无意中将积累的个人信息共享出去了 需要对每个用户动态生成胖URL，额外的服务器负荷 破坏缓存。为每个URL生成用户特有的版本，意味着不再有供公共访问的URL缓存了。 cookie 是目前识别用户，实现持久会话的最好方式。包括 会话cookie 和 持久cookie ，他们之间的唯一区别就是他们的过期时间。浏览器会记住从服务器返回的set-cookies或者set-cookie2首部中的cookie内容，并将cookie存储在cookie数据库，将来用户访问同一站点时，浏览器会按照某些规则将cookie放在cookie请求首部中将其传回去。 以下是为用户设置cookie的情形： cookie的域属性： 产生cookie的服务器可以向set-cookie响应首部添加一个Domain属性来控制哪些站点可以看到那个cookie，比如，下面的HTTP响应首部告知浏览器将 cookie user=”haha” 发送给域 “.baidu.com”中的所有站点： set-cookie: user=”haha”;domain=”baidu.com” 如果访问的是www.baidu.com 、news.baidu.com 或其他任何以 .baidu.com 结尾的站点，下列的cookie都会被发布出去； Cookie :user=”haha” cookie 规范甚至允许用户将cookie域部分web站点关联起来，可以通过path属性来实现： 例如，某个web服务器可能是由两个组织共享的，每个组织都有独立的cookie，站点 www.baidu.com 可能会将部分web站点用于外卖，如 www.baidu.com/waimai/ ，可以用一个独立的cookie来记录用户喜欢的外卖口味，如： Set-cookie: taste=hot; domain=”baidu.com”; path=/waimai/ 如果用户访问 http://www.baidu.com/waimai/bj/index.html 时就会获得两个cookie： Cookie: user=”haha”Cookie: taste=”hot” 因此，可以理解为：cookie就是由服务器贴到客户端上，由客户端维护的状态片段，只会回送给那些合适的站点。 我们有Set-Cookie 和 Set-Cookie2 两种，后者属于更新的版本。Cookie2首部告知服务器，用户Agent代理理解新形势的cookie，病提供了所支持的cookie标准版本，：Cookie2： $Version=”1”如果服务器理解新形式的cookie，就能识别出Cookie2首部，并在响应首部发送Set-Cookie2（而不是Set-Cookie），如果客户端从同一个响应中既获得了Set-Cookie 首部又获得了 Set-cookie2首部，就会忽略老的 Set-cookie首部。","categories":[],"tags":[{"name":"读书笔记-HTTP 权威指南","slug":"读书笔记-HTTP-权威指南","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"}]},{"title":"第4章：连接管理","slug":"HTTP 权威指南-第4章","date":"2018-05-21T13:10:00.000Z","updated":"2019-05-01T08:41:47.537Z","comments":true,"path":"2018/05/21/HTTP 权威指南-第4章/","link":"","permalink":"https://glassx.gitee.io/2018/05/21/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0/","excerpt":"","text":"TCP连接HTTP的连接实际上就是TCP的连接和一些使用连接的规则。 TCP是可靠的数据管道：TCP为HTTP提供了一条可靠的比特传输管道，从TCP连接一端输入的字节会从另一端以原有顺序、正确地传送出来。 TCP流是分段的，由IP分组传送：HTTP以流的形式将报文数据通过一条打开的TCP连接传输，TCP会将数据流分成若干段，每个TCP段都是由IP分组承载，从一个IP地址发送到另一个IP地址。 任意时刻计算机都可以有多条TCP连接处于打开状态，TCP是通过端口号来保持这些连接的正确运行。 TCP的连接是通过4个值来识别的：&lt;源IP地址、源端口号、目的IP地址、目的端口号&gt; ，这4个值定义了唯一一条连接，IP地址可以将你连接到正确地计算机，而端口号可以将你连接到正确的应用程序。 以下表示四条不同的TCP连接，各连接要么源IP不同，要么目的IP不同，要么源端口不同，要么目的端口不同： 利用套接字操纵TCP客户端和服务器之间的连接： HTTP性能讨论性能概述HTTP事务流程主要包括几个方面： 客户端首先根据URI确定WEB服务器的IP和端口，如果没有DNS缓存的话，这个过程可能花费数十秒。 接下来，客户端向服务器发送TCP连接请求，并等待服务器应答，每条新的TCP连接都会有连接建立时延。 一旦连接建立起来，服务器处理请求、因特网传输请求报文都需要时间。 HTTP位于TCP上层，所以HTTP事务的性能很大程度上取决于TCP通道的性能。这其中，对HTTP性能影响最常见的是TCP相关的时延，包括： TCP连接建立握手 小的HTTP事务可能会在TCP建立上花费50%的时间，这是不合理的。 用于捎带确认的TCP延迟确认算法 每个TCP段都有一个序列号和数据完整性校验和，每个段的接收者收到完好的段时，都会向发送者回送确认分组。如果发送者没有在指定的时间窗口收到确认信息，发送者就认为分组已损坏，并重新发送数据。由于确认报文很小，所以TCP允许TCP将返回的确认信息与输出的数据分组结合在一起，可以更有效地利用网络。为了增加确认报文找到输出数据分组的可能性，很多TCP栈都实现了一种“延迟确认”算法，延迟确认算法会在一个特定的窗口时间（通常100~200毫秒）内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组，如果那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。 TCP慢启动拥塞(se)控制 TCP数据传输的性能还取决于TCP连接的使用期（age）。TCP连接会随着时间进行自我“调谐”——期初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输速度，这种“调谐”称为 TCP慢启动，用于防止因特网的突然过载和拥塞。例如，如果HTTP事务有大量的数据要发送，是不能一次将所有分组发送出去的，必须发送一个分组等待确认，然后可以发送两个分组，每个分组都必须确认，这样就可以发送四个分组了，这种方式被称为“打开拥塞窗口”。由于存在这种拥塞控制，所以新连接的传输速度会比已经传输过一定量数据的“已调谐”的连接慢一些。由于已“调谐”的连接快，因此HTTP中有一些可以重用现存连接的工具，提高效率。 数据聚集的Nagle算法与TCP_NODELAY 如果每次发送的数据量很少，但是传输的次数很多，就会产生大量包含少量数据的分组，网络性能就会下降，Nagle算法鼓励发送全尺寸（LAN上最大尺寸的分组大约1500字节，因特网上是几百字节）的段，试图在发送一个分组前，将大量TCP数据绑在一起，提高网络效率，毕竟每个TCP段中哪怕只放了一个字节，也至少装载了40个字节的标记和首部。但是这也会引发HTTP性能问题，首先，可能某个小的HTTP报文无法填满一个分组，但等待那些永远不会到来的额外数据而产生时延。其次，Nagle算法与前面体积的延迟确认似乎是矛盾的 —— Nagle算法会阻止数据发送，直到有确认分组抵达为止，但是确认分组会被延迟确认算法延迟100~200毫秒。 TIME_WAIT时延和端口耗尽 当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，这类信息指挥维持一小段时间，通常是所估计的最大分段使用期的2倍（称为2MSL，通常为2分钟）。 HTTP的性能改善有几种方法可以提高HTTP的性能： 并行连接，通过发起多条TCP连接发起并发的HTTP请求。这样可以避免单条连接的空载时间和没有充分利用带宽。以下两个图为对比：串行： 并行：2. 持久连接，用于消除连接及关闭的时延。 以前使用 keep-alive 字段，现在使用 persistent。3. 管道化连接。通常，http请求总是顺序发送的，下一个请求只有在当前请求的响应被完全接受的时候才会被发送。由于网络延迟和带宽的限制，这样会导致在服务器发送下一个响应的时候中间有很大的延迟。管道化连接可以将多条连接放入队列，当第一条请求发出之后，第二条第三条请求也可以开始发送了，这样做可以降低网络环回时间，提高性能。 如果一个事务，不管是执行一次还是很多次，得到的结果都是相同的，那我们说这个事务是幂等的。 GET、HEAD PUT DELETE TRACE OPTIONS 是幂等的，但POST不是幂等的，所以不应该以管道化的方式发送POST请求。 书本之外：关于TIME_WAIT以下内容参考自博客： https://blog.csdn.net/u013616945/article/details/77510925 描述首先调用close()发起主动关闭的一方，在发送最后一个ACK之后会进入time_wait的状态，也就说该发送方会保持2MSL时间之后才会回到初始状态。MSL值得是数据包在网络中的最大生存时间。产生这种结果使得这个TCP连接在2MSL连接等待期间，定义这个连接的四元组（客户端IP地址和端口，服务端IP地址和端口号）不能被使用。 产生的原因 为实现TCP全双工连接的可靠释放 假设发起主动关闭的一方（client）最后发送的ACK在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前，client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常。 为使旧的数据包在网络因过期而消失 为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。 time_wait状态如何避免首先服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。","categories":[],"tags":[{"name":"读书笔记-HTTP 权威指南","slug":"读书笔记-HTTP-权威指南","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"}]},{"title":"Ubuntu下利用github和hexo搭建自己的博客","slug":"Ubuntu下利用github和hexo搭建自己的博客","date":"2018-05-03T12:46:00.000Z","updated":"2019-05-01T09:49:48.406Z","comments":true,"path":"2018/05/03/Ubuntu下利用github和hexo搭建自己的博客/","link":"","permalink":"https://glassx.gitee.io/2018/05/03/Ubuntu%E4%B8%8B%E5%88%A9%E7%94%A8github%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"最近打算开始写点东西，发出来，一来可以督促自己持续地将所学所感悟的东西记录下来，二来，以前一直在自己遇到问题解决不了的时候去google，获取他人的答疑解惑，而自己写的总结性的东西都在有道云笔记上（主要怕误导大家），这次重新搭建自己的博客，附上了评论系统，所以希望即使写出来的东西不完善也能让大家留个评论，能够及时改正，因此就膨胀发出来了。同时希望这个教程能够帮到一些人亲手搭建自己的博客。 根据一直以来的经验，使用第三方框架之前一定要仔细阅读官方的文档，先不要去获取网上所谓的教程，因为每个教程里面针对的 操作系统、搭设的环境等 不一定和你的一模一样，而官方文档一般是能涵盖你所碰到的大多数问题的 先放上官方的（语言可以选择中文的哦）： hexo的主页在这里：https://hexo.io/ hexo的文档在这里：https://hexo.io/docs/ 如果你自己能看文档解决，那是再好不过了，如果根据官方文档踩到坑跳不出来，可以参考参考以下的教程。 一、安装nodejs 与 npm首先声明，博主目前主要使用Ubuntu进行Android开发，然后进行一些简单的日常使用，对Ubuntu玩得并非很6，看到hexo官网上说要先安装nodejs和npm，首先想到的是去nodejs官网，但是下载下来解压之后，一脸懵逼，不知道怎么操作了。官网上没有很直观的文档(是不仔细找还不好发现)，google 上也是众说纷纭，遂又硬着头皮去官网上找找解决方法，我最后找到的官方指引，点击这里就是，有针对各种系统安装nodejs的说明（同时会自动安装 npm），为了节约大家去看文档的时间，以下还是列出ubuntu环境下nodejs的安装过程： 在终端输入： curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash - 注：在写本教程的时候，最新的LTS版本的nodejs是 8.11.1，所以我这里是8.x，这个版本号可以依据自己需要的版本而改动 当然，如果提示你还未安装curl，则使用以下命令安装即可： $ sudo apt-get install curl 完成之后，再在终端输入： $ sudo apt-get install -y nodejs 最后，输入以下命令检测是否安装成功 ： $ nodejs -v v8.11.1 $ npm -v 5.6.0 如果显示这些版本号，说明安装成功。 二、安装hexo根据hexo的官方介绍，里面很详细地介绍了安装过程： 1、安装hexo(如果提示权限问题请在命令前加上 sudo) $ npm install -g hexo-cli 2、初始化hexo 在终端cd到你想要存放blog的目录，执行 $ hexo init BLOG 这行命令会帮你创建一个BLOG文件夹，并且做一些初始化操作，这里BLOG是你想要新建的存放hexo必要文件的文件夹。 3、安装依赖 $ cd BLOG $ npm install 三、配置github申请github账号，并且在本地电脑上安装git ，并且将本地生成的公钥更新到github上，以便本机有权限将生成的静态网页push到github服务器。参考附件：github官方提供的ssh设定：https://help.github.com/articles/connecting-to-github-with-ssh/ 在github上新建project在github上新建project ，只需要注意project的名字一定得是 username.github.io 就行了，像我的博客地址是 glassx.github.io，因此我的project的名字是 glassx.github.io 。 四、配置hexo 以及 关联hexo与github在正式写作之前，我们需要配置hexo，并且将hexo与github关联起来。 主题配置首先是选择 主题（theme），当然也可以使用hexo的默认主题，我目前使用的是yilia主题，这个纯属个人爱好，你可以去知乎上搜索好看的hexo主题，也能从我认为的hexo主题大全中选择你中意的主题。只需将下载好的主题放到 *BLOG/themes/ *目录下备用。 用yilia主题的话，别忘了在BLOG目录下终端执行： $ npm i hexo-generator-json-content –save 修改hexo的配置文件打开 ** BLOG/ 目录下的 **_config.yml 文件，找到 theme 字段，将它的值改成你需要的主题名称，比如我的就是 ： theme: yilia 除此之外，还需要找到 deploy 字段，将它下面的字段配置成类似于： deploy: type: git repository: https://github.com/glassx/glassx.github.io.git branch: master将 https://github.com/glassx/glassx.github.io.git 换成你自己的就好了（其实这里整个就是你前面在github上新建的仓库的地址）。 安装必要控件使用以下命令安装deploy的git工具： $ npm install hexo-deployer-git –save 如果不安装，在部署的时候会报错： ERROR Deployer not found: git 注意：一定要在第三步的时候将你的公钥上传到github上去，也就是第三步中的 github提供的ssh设定 那个部分，否则在部署的时候会提示没有权限 五、开始写作准备工作终于做完了，开始发挥吧！首先新建博文： 在终端里定位到上述的BLOG文件夹下，执行 $ hexo new post “firstpage” 之后会在 BLOG/source/_post/ 目录下生成 firstpage.md 文件，编辑firstpage.md 文件，注意该文件的编辑使用的是 markdown 语法，如果不懂这个语法的话，就去google一下吧，语法很简单。 关于Ubuntu下的编辑器，我目前在使用的是 Remarkable，个人觉得挺好用，因此也安利一波。 编辑完成之后，终端中定位到 BLOG/ 目录，使用hexo命令生成静态文件： $ hexo generate 生成静态文件命令也可以直接简化成： $ hexo g 生成静态文件的过程就是将markdown文件 firstpage.md导出成index.html之类的静态文件，静态文件生成之后，便只需要部署了： $ hexo deploy 同样，部署命令也可以简化成： hexo d 部署过程实际上是将静态文件push到github指定仓库的过程，期间需要输入你的github的username，比如我的就是glassx ，之后回车；再提示你输入github登录密码（输入密码是看不见的，输入了看不见不要慌），输完回车就OK了。 当然你可以做到一行命令生成静态文件后自动部署： $ hexo generate –deploy 或者 $ hexo deploy –generate 二者的效果是一样的，都是生成静态文件后自动部署。 部署成功之后，就可以通过 username.github.io 访问你的页面了（username换成你的名字，比如我的就是 glassx.github.io） 总结一下，在整个过程中，hexo的安装按照官方给出的步骤一步步执行就可以了，nodejs的安装也不困难，建立的github仓库其实就是为了存放静态页面，只有在deploy的时候将静态文件推送上去，当然，github提供的page功能会将你的静态页面展示出来。 建议：为了能够在不同的平台上方便地更新博客，并且防止系统损坏等意外导致博客丢失，建议在github上另外建立一个仓库，用于存放BLOG文件夹的内容","categories":[],"tags":[{"name":"手摸手","slug":"手摸手","permalink":"https://glassx.gitee.io/tags/%E6%89%8B%E6%91%B8%E6%89%8B/"}]}]}