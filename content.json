{"meta":{"title":"glassx的小黑屋","subtitle":"小黑屋","description":"生活是天籁，需要凝神静听","author":"glassx","url":"https://glassx.gitee.io","root":"/"},"pages":[{"title":"categories","date":"2019-10-22T15:12:57.000Z","updated":"2019-10-22T15:15:46.000Z","comments":true,"path":"categories/index.html","permalink":"https://glassx.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-17T11:55:49.000Z","updated":"2019-11-17T13:35:16.000Z","comments":true,"path":"tags/index.html","permalink":"https://glassx.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"自己编的-特殊函数","slug":"Kotlin核心编程-自己加的特别篇","date":"2021-08-18T09:25:00.000Z","updated":"2021-08-18T09:35:59.445Z","comments":true,"path":"2021/08/18/Kotlin核心编程-自己加的特别篇/","link":"","permalink":"https://glassx.gitee.io/2021/08/18/Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E8%87%AA%E5%B7%B1%E5%8A%A0%E7%9A%84%E7%89%B9%E5%88%AB%E7%AF%87/","excerpt":"","text":"run()函数它的实现如下，其实就是调用传入的block参数(一般是个Lambda代码块)： 1234567891011public inline fun &lt;R&gt; run(block: () -&gt; R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return block() }//使用run { myFun()} apply() 函数实现如下，主要看后面两行，先是调用了block函数（block里面可以直接使用this？），然后再返回当前调用者this。即执行完block后返回当前的调用者： 1234567891011121314151617public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } block() return this }//使用方法val a = ArrayList&lt;String&gt;().apply { add(\"A\") add(\"B\") add(\"C\") println(this)//打印 [A,B,C]}println(a)//同样打印 [A,B,C] let函数只需要看源代码最后一行即可：意思是把当前调用对象作为参数传入block代码块(意味着一定要用it访问调用对象，能不能this?),最后，返回block执行结果，即作用域中的最后一个对象：： 123456public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return block(this) } also() 函数源码先调用block(this) ，但是最后返回值是this，也就是，将当前调用者传入block，执行完后返回调用者。 1234567891011121314public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } block(this) return this }//使用val a = \"ABC\".also{ println(it)//输出 ABC}pintln(a);//输出 ABC with() 函数源码传入一个接收者对象 reciver，然后使用该对象去调用传入的Lambda代码块： receiver.block() 1234567891011121314151617public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return receiver.block() }//使用whith(ArrayList&lt;String&gt;()) { add(\"A\") add(\"B\") add(\"C\") println(this)//ABC}.let { println(it)//kotlin.Unit} run、let 与 also 对比由下面代码可能更好理解run实现中 return block() 、let实现中的 return block(this) ，以及 also 源码中的 return this ： 12345678910111213141516171819202122232425262728//run提供了一个单独的作用域，并且会返回在这个作用域当中的最后一个对象//例如现在有这么一个场景，用户领取app的奖励，如果用户没有登录弹出登录dialog，如果已经登录则弹出领取奖励的dialog。我们可以使用以下代码来处理这个逻辑run { if (islogin) loginDialog else getAwardDialog}.show() val original = \"abc\"original.let { println(\"The original String is $it\") // \"abc\" it.reversed() }.let { println(\"The reverse String is $it\") // \"cba\" it.length }.let { println(\"The length of the String is $it\") // 3}original.also { println(\"The original String is $it\") // \"abc\" it.reversed() }.also { println(\"The reverse String is ${it}\") // \"abc\" it.length }.also { println(\"The length of the String is ${it}\") // \"abc\"} run是直接提供一个作用域，并返回作用域里面最后一个对象 let 将this传入block中，并且返回 block(this)，也就是作用域最后一个对象 also 将this传入block中，但是返回的是 this，也就是调用者本身 with 呢，是以 with(T) 的形式使用(但是它貌似不能判断null？) apply没有传入this，但是直接返回this 最后，按需使用的情景： 有些内容参考 无嘴小呆子 无需写interface，直接写个高阶函数？这个地方是不是高阶函数？","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-Kotlin核心编程","slug":"读书笔记-Kotlin核心编程","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Kotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"}]}]}