{"meta":{"title":"glassx的小黑屋","subtitle":"小黑屋","description":"生活是天籁，需要凝神静听","author":"glassx","url":"https://glassx.gitee.io","root":"/"},"pages":[{"title":"categories","date":"2019-10-22T15:12:57.000Z","updated":"2019-10-22T15:15:46.966Z","comments":true,"path":"categories/index.html","permalink":"https://glassx.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-17T11:55:49.000Z","updated":"2019-11-17T13:35:16.504Z","comments":true,"path":"tags/index.html","permalink":"https://glassx.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"第13讲-存储优化<中>-如何优化数据存储","slug":"Android开发高手课-13课","date":"2020-07-04T03:36:00.000Z","updated":"2020-07-04T03:45:37.046Z","comments":true,"path":"2020/07/04/Android开发高手课-13课/","link":"","permalink":"https://glassx.gitee.io/2020/07/04/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-13%E8%AF%BE/","excerpt":"Serializable 的原理Serializable 的原理是通过 ObjectInputStream 和 ObjectOutputStream 来实现的，通过 Android 6.0 的源码可以看到 ObjectOutPutStream 的部分源码实现：12345private void writeFieldValues(Object obj, ObjectStreamClass classDesc) &#123; for (ObjectStreamField fieldDesc : classDesc.fields()) &#123; ... Field field = classDesc.checkAndGetReflectionField(fieldDesc); ...","text":"Serializable 的原理Serializable 的原理是通过 ObjectInputStream 和 ObjectOutputStream 来实现的，通过 Android 6.0 的源码可以看到 ObjectOutPutStream 的部分源码实现：12345private void writeFieldValues(Object obj, ObjectStreamClass classDesc) &#123; for (ObjectStreamField fieldDesc : classDesc.fields()) &#123; ... Field field = classDesc.checkAndGetReflectionField(fieldDesc); ... 整个序列化过程使用了大量反射(反射意味着效率低)和临时变量(临时变量意味着GC)，并且，在序列化对象时，不仅会序列化当前对象本身，还需要地柜序列化对象引用的其他对象。 Serializable 的进阶Serializable 序列化支持使用自定义 writeObject和readObject，他会先反射判断是否存在我们自己实现的 序列化writeObject方法和反序列化readObject 方法。通过这两个方法，我们可以对某些字段做修改，也能实现序列化的加密功能。 还有，Serializable 的反序列默认是不会执行构造函数的 Parcelable 的永久存储一般来说，我们使用 parcelable 只是会在内存中序列化操作，并不会存储到磁盘。其实，我们也可以存储到磁盘的：通过 Parcel.java 中的 marshall 接口获取byte 数组，然后存在文件中，从而实现 Parcelable 的永久存储。 12345678// Returns the raw bytes of the parcel.public final byte[] marshall() &#123; return nativeMarshall(mNativePtr);&#125;// Set the bytes in data to be the raw bytes of this Parcel.public final void unmarshall(byte[] data, int offset, int length) &#123; nativeUnmarshall(mNativePtr, data, offset, length);&#125; 不过，一般不推荐这样做，因为可能会有系统版本兼容性问题，因为我们无法保证所有的 Android 版本的 Parcel.cpp 实现完全一致。还有就是数据前后的兼容性，这里并没有类似 Serializable 里面有个 serialVersionUID 来保证版本一致性。 14-数据库优化SQLite 默认支持多进程并发操作，它通过文件锁来控制多进程的并发，但是SQLite 的锁粒度并没有非常细，针对的是整个DB文件，简单来说，多进程可以同事获取 SHARED 锁来读取数据，但是只有一个进程可以获取 EXCLUSIVE 锁来写数据库 数据库使用注意： 防止注入 防止窃取 小表无需维护索引，因为索引是需要一直维护的，有代价 慎用 “select * “ 需要多少列，就取多少列 定期删除无用数据","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android开发高手课","slug":"Android开发高手课","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/"}]},{"title":"存储优化<上>-常见的存储方式","slug":"Android开发高手课-12课","date":"2020-06-28T10:36:00.000Z","updated":"2020-07-04T03:45:58.308Z","comments":true,"path":"2020/06/28/Android开发高手课-12课/","link":"","permalink":"https://glassx.gitee.io/2020/06/28/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-12%E8%AF%BE/","excerpt":"Android存储安全在4.3以前，应用都在自己的沙盒里，沙盒使用标准Linux保护机制，为每个应用创建唯一 Linux UID 来定义。简单来说，就是保证微信不能访问淘宝的数据。4.3以后引入SELinux，进一步定义应用沙盒边界。即使我们进程有root权限也不能为所欲为(想干事情必须先在安全策略配置文件中赋予权限)。","text":"Android存储安全在4.3以前，应用都在自己的沙盒里，沙盒使用标准Linux保护机制，为每个应用创建唯一 Linux UID 来定义。简单来说，就是保证微信不能访问淘宝的数据。4.3以后引入SELinux，进一步定义应用沙盒边界。即使我们进程有root权限也不能为所欲为(想干事情必须先在安全策略配置文件中赋予权限)。 数据加密：Android 两种加密，全盘加密和文件加密。全盘加密在4.4引入，在 5.0 后默认打开 常见数据存储方法综合来看,Android提供了 SharedPreferences /ContentProvider/文件/数据库 SharedPreferences非常简便，但是问题比较多: 跨进程不安全 加载缓慢(使用异步加载，且没设置线程优先级，就有可能出现主线程等待低优先级线程所问题) 全量写入(无论commit还是apply，即使只改动一个条目，也会把全部内容写入，并且多次写入一个同一文件，也不会合并为一次) 卡顿(收到系统广播或onPause等时机，系统会强制把sp文件写到磁盘，此过程或阻塞) 还有，存储json等复杂文件时，会有转义等操作，会额外耗时 如果我们想的话，可以使用 MMKV 替代sp，它利用文件锁保证跨进程安全，并且性能也比较好 ContentProviderContentProvider 的生命周期默认在 Application 的onCreate 之前，而且是在主线程的，ContentProvider 跨进程传递数据是利用 Android 的 Binder 和匿名共享内存机制。简单来说，就是通过 Binder 传递 (CusorWindow 对象内部的）匿名共享内存的文件描述符，这样数据无需跨进程。 ContentProvider 主要存在以下几个问题： 自定义的 ContentProvider 的构造函数、静态代码块、onCreate 函数尽量不要做耗时操作 性能。传输数据比较小的时候，使用 ContentProvider 不一定划算 安全：ContentProvider本身提供了很好的安全，但是如果是exported，当支持执行 sql 语句时，就要注意 sql 注入问题。 简而言之，ContentProvider 适合相对比较笨重，适合传输量大的数据","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android开发高手课","slug":"Android开发高手课","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/"}]},{"title":"面试题-算法-红黑树","slug":"红黑树","date":"2020-06-27T02:46:00.000Z","updated":"2020-06-27T02:46:38.121Z","comments":true,"path":"2020/06/27/红黑树/","link":"","permalink":"https://glassx.gitee.io/2020/06/27/%E7%BA%A2%E9%BB%91%E6%A0%91/","excerpt":"二叉查找树(也称二叉搜索树) 左子树上的节点值都小于等于根节点的值 右子树上的节点值都大于等于根节点的值 左右子树也是二叉搜索树 它是基于二分查找的思想，查找最大的次数为二叉树高度 查找代价 当左右子树高度大致平衡时，时间复杂度在 O(logN) 当先后插入的关键字有序时，退化成链表，查找的时间复杂度就在 O(N)了","text":"二叉查找树(也称二叉搜索树) 左子树上的节点值都小于等于根节点的值 右子树上的节点值都大于等于根节点的值 左右子树也是二叉搜索树 它是基于二分查找的思想，查找最大的次数为二叉树高度 查找代价 当左右子树高度大致平衡时，时间复杂度在 O(logN) 当先后插入的关键字有序时，退化成链表，查找的时间复杂度就在 O(N)了 插入代价新节点插入到树的叶子节点上，因此，插入节点和查找一个不存在的数据的代价相同 删除代价 如果被删除的节点左、右 有一个为null时，代价仅为 O(1) 如果左右子树都存在，时间复杂度最大也不会超过O(logN) 缺陷： 极端情况可能退化成链表，时间复杂度为 n。这主要是由于树不平衡导致的 平衡二叉查找树(平衡二叉搜索树)是严格的平衡二叉树，它是空树或者左右两个子树的高度差 小于等于1，同时，左右两个子树也是平衡二叉搜索树 查找代价时间很稳定，查找效率最好最坏都是 O(logN) 插入代价由于要保证严格的平衡，插入时可能要进行再平衡(最多旋转一次)，因此插入的整体代价还在 O(logN) 删除代价和插入一样，要考虑再平衡，但是最多需要O(logN)次旋转，所以时间复杂度为 O(2logN) 红黑树(Red-Black Tree)它并不严格地平衡，最长路径长度不超过最短路径长度的2倍。它删除和插入引起平衡性改变的概率要远低于平衡二叉搜索树 查找代价查找代价基本上维持在 O(logN) 级别，最差情况下肯定比平衡二叉搜索树要差，因为没有那么平衡 插入代价不容易引起失衡，整体代价和平衡二叉搜索树差不多，也是 O(logN) 级别(虽然涉及变色，但是变色的代价很小) 删除代价相对平衡二叉搜索树，不容易引起失衡，时间复杂度也在 O(logN) 级别 补充平衡二叉搜索树由于插入和删除，会引起需要调整，可以通过 ：变色、左旋转、右旋转 三种方式调整。是否需要调整要根据红黑树的特性： 节点是红色或黑色 根节点是黑色 叶子节点都是黑色的空节点 红色节点的两个子节点都是黑的(红节点不能连续出现) 任一点到每个叶子节点的路径包含相同数目的黑节点 B-树和B+ 树我们所谓的B-树，其实并不是B减树，中间是横线，不是减号；B + 就是 B加树了 如 os 的文件目录存储、数据库中的索引结构的存储，不可能在内存中建立查找结构，必须在磁盘中建立好结构。 在磁盘组织结构下，从任何一个节点指向其他节点都可能读取一次磁盘，再将数据写入内存比较。这回带来大量的IO操作，所以我们需要新的数据结构，即 B树和B+树。 B树是一种多路平衡查找树，每个节点最多包含k个孩子，k称为B树的阶。K大小取决于磁盘页的大小。 以上内容参考自知乎专栏、知乎、csdn博客","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"第18课-耗电优化<上>","slug":"Android开发高手课-18、19课","date":"2020-06-26T09:28:00.000Z","updated":"2020-06-27T02:40:22.534Z","comments":true,"path":"2020/06/26/Android开发高手课-18、19课/","link":"","permalink":"https://glassx.gitee.io/2020/06/26/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-18%E3%80%8119%E8%AF%BE/","excerpt":"第18课-耗电优化&lt;上&gt;准确的测量电量并不是那么容易，在《大众点评App的短视频耗电量优化实战》一文中，为我们总结了下面几种电量测试的方法:当测试反馈耗电问题时，bug report 结合 Battery Historian 是最好的排除方法：123456//7.0和7.0以后$ adb bugreport bugreport.zip//6.0和6.0之前:$ adb bugreport &gt; bugreport.txt//通过historian图形化展示结果python historian.py -a bugreport.txt &gt; battery.html","text":"第18课-耗电优化&lt;上&gt;准确的测量电量并不是那么容易，在《大众点评App的短视频耗电量优化实战》一文中，为我们总结了下面几种电量测试的方法:当测试反馈耗电问题时，bug report 结合 Battery Historian 是最好的排除方法：123456//7.0和7.0以后$ adb bugreport bugreport.zip//6.0和6.0之前:$ adb bugreport &gt; bugreport.txt//通过historian图形化展示结果python historian.py -a bugreport.txt &gt; battery.html 19讲-耗电优化&lt;下&gt;如何优化 耗电优化的第一个优化方向是优化应用后台耗电 第二个优化方向是符合系统的规则，让系统认为你的耗电是正常的。 比如，Android P 通过 Android Vitals 监控后台耗电，所以我们需要符合它的规则，它的规则如下：","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android开发高手课","slug":"Android开发高手课","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/"}]},{"title":"第16课-网络优化<中>","slug":"Android开发高手课-16,17课","date":"2020-06-26T03:36:00.000Z","updated":"2020-06-26T09:39:43.208Z","comments":true,"path":"2020/06/26/Android开发高手课-16,17课/","link":"","permalink":"https://glassx.gitee.io/2020/06/26/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-16,17%E8%AF%BE/","excerpt":"第16课-网络优化&lt;中&gt;对于速度、弱网络以及安全的优化，该从哪些方面入手，首先我们要弄清楚一个网络请求的整个过程,示意图如下：可以看出，整个流程分为 发起请求-&gt;DNS解析-&gt;创建连接-&gt;发送/接收数据-&gt;关闭连接 第17课-网络优化&lt;下&gt;-大数据下网络如何监控","text":"第16课-网络优化&lt;中&gt;对于速度、弱网络以及安全的优化，该从哪些方面入手，首先我们要弄清楚一个网络请求的整个过程,示意图如下：可以看出，整个流程分为 发起请求-&gt;DNS解析-&gt;创建连接-&gt;发送/接收数据-&gt;关闭连接 第17课-网络优化&lt;下&gt;-大数据下网络如何监控 插桩为了兼容性考虑，首先考虑插桩。如360开源的性能监控工具 ArgusAPM ，就是利用 Aspect 切换插桩，实现监控系统和 OkHttp 网络请求库的请求。 系统网络库的插桩实现可以参考TraceNetTrafficMonitor，主要利用Aspect的切面功能，关于OkHttp的拦截可以参考OkHttp3Aspect，它会更加简单一些，因为OkHttp本身就有代理机制。 Native Hookhook 本地的代码，需要考虑兼容性 统一网络库ios 和Android 都统一使用同一套网络库，统一监控 小技巧：1、我们可以通过Android官方的 TrafficStats 类来获取整个手机或者某个 UID 从开机算起的网络流量； 2、Android 和 Iphone 都有一个网络测试模式，可以尝试下： Android手机：打开拨号界面，输入 ##4636## ，然后按拨号键（可进入工程测试模式，部分版本可能不支持）iPhone手机：打开拨号界面，输入 3001#12345# ，然后按拨号键。 自己注：在网上找到的微信弱网优化方法","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android开发高手课","slug":"Android开发高手课","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/"}]},{"title":"第20课-UI优化-UI渲染关键概念","slug":"Android开发高手课-20课","date":"2020-05-30T02:32:00.000Z","updated":"2020-05-31T05:48:50.666Z","comments":true,"path":"2020/05/30/Android开发高手课-20课/","link":"","permalink":"https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-20%E8%AF%BE/","excerpt":"UI优化&lt;上&gt;-20讲UI渲染的背景知识ppi 像素密度，每英寸包含的像素数，这是物理参数，不可改dpi 像素密度，指的是单位尺寸像素数量。这是可以人为调整的 density 密度，每平方英寸中包含的像素点数，density = dpi / 160 dp ： px = dp * density","text":"UI优化&lt;上&gt;-20讲UI渲染的背景知识ppi 像素密度，每英寸包含的像素数，这是物理参数，不可改dpi 像素密度，指的是单位尺寸像素数量。这是可以人为调整的 density 密度，每平方英寸中包含的像素点数，density = dpi / 160 dp ： px = dp * density 屏幕适配方案使用dp 限制符适配 CPU 与 GPU 由上面的图可以知道，软件绘制使用的是Skia 库，硬件绘制是通过 open GL 之后在GPU 上实现的 在Android 7.0以后，添加了对 Vulkan 的支持，它比 OpenGL 功耗和多核优化上更优秀 Android 渲染的演进可以通过下图整体看下Android 图形体系： 各个部分的功能可以比喻成以下内容： 画笔：Skia 或者 OpenGL 。Skia 使用CPU 绘制，OpenGL 使用 GPU 绘制 画纸：Surface。所有元素都在 Surface 这张画纸上绘制和渲染。在Android中，Window 是View的容器，每个Window 都会关联一个Surface。windowManager 负责管理这些 window ，并且把它们的数据传递给 SurfaceFlinger。 画板：Graphic Buffer。Graphic Buffer 缓冲用于应用程序图形的绘制，Android 4.1 之前使用的是双缓冲；4.1之后使用三缓冲 显示：SurfaceFliger 。将WindowManager 提供的所有 Surface ，通过Hardware Composer 合成并输出到显示屏 开启硬件加速软件绘制流程图如下： Surface： 每个View 都由某个Window 管理，每个Window 关联一个Surface Cavas。通过Surface的lock 函数获得一个Cavas，Cavas 可以理解成Skia 底层接口的封装 Grapic Buffer。 SurfaceFlinger 帮我们托管 BufferQueue ，我们从BufferQueue 中拿到 Graphic Buffer，然后通过Canvas 和 Skia 将绘制内容栅格化到上面(个人理解为栅格化后的数据保存在这个buffer中)。 SurfaceFlinger 。通过 Swap Buffer 把 Front Graphic Buffer 的内容交给 SurfaceFlinger ，最后硬件合成器 Hardware Composer 合成并输出到显示屏。 硬件加速绘制流程如下图(3.0以后支持硬件加速)： 硬件绘制与软件绘制最核心的区别是硬件绘制通过GPU完成 Graphic Buffer内容的绘制，此外，硬件绘制引入了 DisplayList 的概念，每个View内部都有一个DisplayList，当某个View需要重绘时，将其标记为Dirty，重绘也仅仅只需要重绘一个View的DisplayList，这样，无需像软件绘制那样向上递归，大大减少绘图的操作数量，提高了渲染效率，更新的过程示意如下： 硬件加速虽然极大地提高了显示和刷新速度，但是它也存在一些问题，一方面是内存消耗，另一方面是部分绘制函数不支持 Project Butter （黄油计划）4.1的时候，提出黄油计划，主要包括两个方面，一是 VSYNC ,一是 Triple Bufferfing (三缓冲)。 在4.0 及以前，cpu可能在忙别的事情，导致没来得及处理UI 绘制，为了解决这个问题，VSYNC 出现了，它类似于时钟中断，这个信号到来时，CPU立即准备Buffer数据，大部分设备刷新频率都是60Hz，所以一帧数据的准备工作要在 16ms内完成。 4.0及以前，Android使用双缓冲，一般不同的View或者Activity 都会公用一个Window，也就是公用一个Surface，每个Surface 会有一个BufferQueue 缓存队列，这个队列由SurfaceFlinger 管理，通过匿名共享内存与App应用层交互。示意图如下： 整个流程如下： 每个Surface对应的 BufferQueue 内有有两个Graphic Buffer，一个用于绘制，一个用于显示。 同一时刻可能有多个Surface (可能是不同应用的Surface，也可能是同一个应用里面类似SurfaceView 和TexureView ，它们都会有自己单独的Surface)，SurfaceFlinger 把所有的Surface 要显示的内容统一交给 Hardware Composer，它会最终合成屏幕显示的内容。 如果只有两个Buffer，当CPU/GPU 绘制时间过长，则两个缓冲区分别被显示设备和GPU 占用，cpu 无法准备下一帧数据，造成浪费。三个缓冲区的话，cpu、gpu 显示设备都能使用各自的缓冲区工作，个不影响，最大限度利用空闲时间。 在黄油计划之后，Android 5.0 推出了 RenderThread ，将所有GL 命令执行放到 RenderThread 中执行，减轻UI 线程的负担。 数据测量可以通过开发者选项中查看过度绘制的情况 还可以使用 Systrace 性能数据采样和分析工具 4.1及以后，可以采用 Tracer for OpenGL ES 逐帧分析","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android开发高手课","slug":"Android开发高手课","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/"}]},{"title":"第21课-UI优化-优化UI渲染","slug":"Android开发高手课-21课","date":"2020-05-30T02:32:00.000Z","updated":"2020-06-25T07:22:34.966Z","comments":true,"path":"2020/05/30/Android开发高手课-21课/","link":"","permalink":"https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-21%E8%AF%BE/","excerpt":"UI优化&lt;下&gt;ui渲染测量测试工具： Profile GPU Rendeing 和 Show GPU Overdraw ，定位方法可以参考官方文档，检查GPU渲染速度和过度绘制问题定位工具可以使用 Systrace 和 Tracer for OpenGL ES，具体可以参考官方文档：渲染速度慢","text":"UI优化&lt;下&gt;ui渲染测量测试工具： Profile GPU Rendeing 和 Show GPU Overdraw ，定位方法可以参考官方文档，检查GPU渲染速度和过度绘制问题定位工具可以使用 Systrace 和 Tracer for OpenGL ES，具体可以参考官方文档：渲染速度慢 适用于自动化测试场景的测试方式(自己加的标题)虽然图形化界面工具非常好用，但是难以用在自动化测试场景，以下测量方式可以用于自动化测试： gfxinfogfxinfo 可以输出包含各个阶段发生的动画以及帧相关的性能信息，以及渲染相关的内存和View hierachy 信息，命令如下： adb shell dumpsys gfxinfo 在Android 6.0 之后，gxfinfo 命令新增了 framestats 参数，可以拿到最近120帧每个绘制阶段的耗时信息： adb shell dumpsys gfxinfo framestats SurfaceFlinger除了耗时，还需要关心渲染使用的内存，4.1以后每个 Surface 都会有 3个 Graphic Buffer，那如何查看 Graphic Buffer 占用的内存，可以通过如下命令查看相应信息： adb shell dumpsys SurfaceFlinger 这部分内存大小和 屏幕分辨率，以及Surface的个数有关。 UI优化的常用手段我们的目标是实现app的帧率达到 60fps，意味着所有操作要在 16.7 ms 内完成，这期间要做的事情如下所示： 我们优化，就是拆解渲染的各个阶段耗时，找到瓶颈，加以优化。ui优化的方法如下： 1、尽量使用硬件加速。硬件加速绘制的性能是远远高于软件绘制的，所以ui优化第一个手段应该尽量使用硬件加速。但是有些api不支持硬件加速，这个需要注意，比如 渐变、磨砂、圆角等，它们的渲染性能比较低。 2、View 的创建优化View 的创建在UI线程，对于复杂的界面，这部分耗时不容忽视。View 的创建过程中，会包括xml的读取io，解析xml 以及生成对象的时间(Framework会大量使用反射) 因此建议： 1、使用代码创建view 对象缺点是不能直接预览2、提前创建、异步创建3、View 重用(模仿ListView、RecyclerView，不过重用要注意先清空状态)。 如果异步创建，那么会导致系统抛出异常。这时候，我们可以通过非常取巧的方式来异步创建ui：先把线程的Looper的MessageQueue替换成Looper的Queue： 要注意的是，在创建完成view之后，需要把线程的Looper恢复成原来的。 3、measure/layout 优化这两部分也是在ui线程执行的，一般的优化方法有： 减少UI布局层次 优化layout开销。尽量不要使用 RelativeLayout 和 weighted LinearLayout ，它们开销很大，建议使用 ConstranLayout 背景优化。尽量不要重复设置背景，尤其注意的是主题背景，theme默认会是一个纯色背景，如果我们自定义了界面背景，那么主题背景对我们来说是无用的，由于主题背景是设置在DecorView 中的，所以会带来重复绘制，也会带来绘制性能损耗。 4、UI优化进阶可以采用flutter","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android开发高手课","slug":"Android开发高手课","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/"}]},{"title":"第7、8课-启动优化","slug":"Android开发高手课-7,8课","date":"2020-05-30T02:00:00.000Z","updated":"2020-05-30T02:00:40.709Z","comments":true,"path":"2020/05/30/Android开发高手课-7,8课/","link":"","permalink":"https://glassx.gitee.io/2020/05/30/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-7,8%E8%AF%BE/","excerpt":"启动优化&lt;上&gt;-第7讲启动分析着手优化之前，首先分析启动过程。 首先预览窗口，系统拉起App进程之前，会根据app的Theme属性创建预览窗口。当然，我们禁用预览窗口或者预览窗口为透明时，用户依然可以看到桌面。 进程和闪屏页创建完毕，可以看到广告图片界面 主窗口创建完成可以看到首页了 首页加载完，才能操作起来","text":"启动优化&lt;上&gt;-第7讲启动分析着手优化之前，首先分析启动过程。 首先预览窗口，系统拉起App进程之前，会根据app的Theme属性创建预览窗口。当然，我们禁用预览窗口或者预览窗口为透明时，用户依然可以看到桌面。 进程和闪屏页创建完毕，可以看到广告图片界面 主窗口创建完成可以看到首页了 首页加载完，才能操作起来 启动遇到的问题 点击图标很久都不响应。可能是禁用了预览窗口或者透明皮肤 首页显示太慢。闪屏广告、其它准备工作都要在启动阶段完成，如果耗时太多就慢 首页显示后无法操作。工作异步延后之后，首页就会出现白屏，或者首页出来无法操作 启动优化优化工具：综合看来，在卡顿优化中提到的 “systrace + 函数插桩” 是比较理想的方案，而且还能看到一些关键事件：GC、SystemServer 、CPU 调度等 准确的评估之后，才能指引优化的方向 优化方式 闪屏优化。今日头条把预览窗口与是县城闪屏效果，用户在很短时间内看到“预览闪屏”，不过这种实现对于低端机型会把总的闪屏时间拉长。所以比较推荐在 6.0及以上的版本才采用“预览闪屏” 业务梳理。清楚启动过程中每一个运行的模块，哪些是一定需要的，哪些是可以砍掉，可以懒加载的。还有，懒加载要防止集中化，容易出现首页用户无法操作的情况。 线程优化。主要在于减少cpu调度带来的波动，让应用启动更加稳定。具体做法是，一方面控制县城的数量，要有线程池(我们是采用Rxjava，统一管理线程池)；还有一个就是管理线程的锁，比如业务有先后顺序，或者优先级不同，这一点可以采用第三方启动框架来解决，比如阿里开源的Alpha、微信内部使用的mmkernel 启动优化&lt;下&gt;-第8讲启动进阶方法启动过程不建议出现网络io 还有，就是数据结构选择问题，在启动时，只需要读写很少量的 sp文件，如果与很大的sp文件一起解析，这个解析时间可能就要超过 100ms了(可以说我们的application中的sp解析是花了很长时间的)。 黑科技应用加固对启动速度来说是灾难 启动监控 实验室监控，如果客观地反映启动耗时，视频录制是非常好的选择，尤其是我们拿不到竞品的数据(通过分析竞品，我们制定了秒开的标准，可以取平均值、最大值、最小值) 线上监控。我们使用talkingdata来监测。(但是我们要注意监测的耗时)，最终衡量指标呢，使用平均法容易忽略掉性能差的手机，可以使用快开慢开比：比如2秒快开比，5秒快开比；另一种就是 90% 用户启动时间，如果90%用户启动时间都小于5秒，那我们90%区间启动耗时就是5秒。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android开发高手课","slug":"Android开发高手课","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/"}]},{"title":"第5、6课-卡顿优化","slug":"Android开发高手课-5,6课","date":"2020-05-27T13:43:00.000Z","updated":"2020-05-27T14:40:23.666Z","comments":true,"path":"2020/05/27/Android开发高手课-5,6课/","link":"","permalink":"https://glassx.gitee.io/2020/05/27/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-5,6%E8%AF%BE/","excerpt":"卡顿优化&lt;上&gt;基础知识获取cpu信息：12345// 获取 CPU 核心数cat /sys/devices/system/cpu/possible // 获取某个 CPU 的频率cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq","text":"卡顿优化&lt;上&gt;基础知识获取cpu信息：12345// 获取 CPU 核心数cat /sys/devices/system/cpu/possible // 获取某个 CPU 的频率cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq 卡顿指标出现卡顿，首先应该看cpu使用率，可以通过 /proc/stat 查看系统的cpu使用情况： 12345proc/self/stat: utime: 用户时间，反应用户代码执行的耗时 stime: 系统时间，反应系统调用执行的耗时 majorFaults：需要硬盘拷贝的缺页次数 minorFaults：无需硬盘拷贝的缺页次数 如果cpu使用率长期大于60%，表示系统处于繁忙状态，就需要进一步分析用户时间和系统时间的比例。普通应用程序系统时间不会长期高于 30% ，如果高于这个值，就应该检查是否是I/O过多，还是其他的系统调用问题。 另外，top 命令可以查看哪个进程是cpu消耗大户。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android开发高手课","slug":"Android开发高手课","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/"}]},{"title":"第3、4课-内存优化","slug":"Android开发高手课-3,4课","date":"2020-05-27T13:43:00.000Z","updated":"2020-05-27T13:43:33.960Z","comments":true,"path":"2020/05/27/Android开发高手课-3,4课/","link":"","permalink":"https://glassx.gitee.io/2020/05/27/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE-3,4%E8%AF%BE/","excerpt":"内存优化&lt;上&gt;Android中Bitmap 内存分配的变化过程 3.0以前，Bitmap 对象放在Java堆，像素数据存放在 Native内存中，如果不手动调用 recycle ，那么Native内存中的像素数据完全依赖于 finalize 函数，而这个函数是不可靠的 3.0~7.0,Bitmap 对象和像素数据统一放到 Java 堆，这样就算不 recycle 操作，像素数据也会随着一起回收，不过，这导致大量内存占用，引起大量GC。一起放在内存也有可能即使系统有大量内存没利用，但是却会导致oom了(比如给分配的最大堆只到 300M，但是用得差不多了，此时系统却还空闲有3G内存，却要引起oom了) Android 8.0 中，NativeAllocationRegistry 可以满足Bitmap 对象存放在Java 堆，像素数据在 Native 中，还能实现一并回收对象和像素数据。(8.0还提供硬件位图(Hardware Bitmap)，减少内存占用并提升绘制效率)","text":"内存优化&lt;上&gt;Android中Bitmap 内存分配的变化过程 3.0以前，Bitmap 对象放在Java堆，像素数据存放在 Native内存中，如果不手动调用 recycle ，那么Native内存中的像素数据完全依赖于 finalize 函数，而这个函数是不可靠的 3.0~7.0,Bitmap 对象和像素数据统一放到 Java 堆，这样就算不 recycle 操作，像素数据也会随着一起回收，不过，这导致大量内存占用，引起大量GC。一起放在内存也有可能即使系统有大量内存没利用，但是却会导致oom了(比如给分配的最大堆只到 300M，但是用得差不多了，此时系统却还空闲有3G内存，却要引起oom了) Android 8.0 中，NativeAllocationRegistry 可以满足Bitmap 对象存放在Java 堆，像素数据在 Native 中，还能实现一并回收对象和像素数据。(8.0还提供硬件位图(Hardware Bitmap)，减少内存占用并提升绘制效率) 关于内存优化的两个误区 内存占用越小越好。不是这样的，更多的内存意味着更好的动画效果和更快的缓存命中，只需要做到系统内存充足时多用，系统内存紧张时少用(释放不是必须的内存)即可 Native 的内存不用管。其实，当系统内存不足的时候，就会开始依次清理 后台、桌面、服务、前台，一步步来，直到内存足够，最后直到重启手机 内存观测方法 观察Log，查看GC 回收的原因 使用如下命令查看： adb shell dumpsys meminfo &lt;package_name|pid&gt; [-d] 内存优化&lt;下&gt;内存优化探讨Bigmap 优化、内存泄露优化、设备分级几个层次入手 设备等级就是，在某些低性能的机器上，动画不要了，进程也不预先启动了。安装包大小也是有要求的，比如有很多app就有极速版这个概念，它们的apk很小，动画也不酷炫。apk大小跟内存的关系可以参考如下图： Bitmap 可以用第三方框架来做，比如Fresco，实在要自己管理，可以向后台要求指定宽度，bitmap的inbitMap内存复用，inSample降低采样 内存泄露：使用LeakCanary自动化检测方案，只可以做到Activity和Fragment的泄漏检测，如何检测其他的内存泄露呢？如何监测疑似的内存泄漏呢？","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android开发高手课","slug":"Android开发高手课","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/"}]},{"title":"他山之石","slug":"他山之石","date":"2020-05-02T13:33:00.000Z","updated":"2021-02-22T02:15:12.060Z","comments":true,"path":"2020/05/02/他山之石/","link":"","permalink":"https://glassx.gitee.io/2020/05/02/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/","excerpt":"碰到的内存泄漏怎么检测？LeakCanary 原理？ 点击看答案 参考以前的源码解析第10点 HashMap 源码？为什么要将链表转成红黑树？红黑树特点？ 点击看答案 参考以前的源码解析第10点 消息循环源码、如何做到任务切换线程？想要提交一个任务有几种方式？ 点击看答案 关于源码，可以从postDelay、IdleHandler、插队的msg 几个角度来讲。其中源码可以查看Android基础中的3、4题，后面两个可以参考Android基础的32、33题","text":"碰到的内存泄漏怎么检测？LeakCanary 原理？ 点击看答案 参考以前的源码解析第10点 HashMap 源码？为什么要将链表转成红黑树？红黑树特点？ 点击看答案 参考以前的源码解析第10点 消息循环源码、如何做到任务切换线程？想要提交一个任务有几种方式？ 点击看答案 关于源码，可以从postDelay、IdleHandler、插队的msg 几个角度来讲。其中源码可以查看Android基础中的3、4题，后面两个可以参考Android基础的32、33题 kotlin 协程原理？怎么切换线程的？Kotlin 优点和缺点？ 一个无序，实际上是逆序的数组排序用什么算法好？ 调优、怎么瘦身，打包流程，模块化 开发者模式中，GPUInfo 中柱状图颜色代表的含义；命令dumpsys meminfo中VSS、PSS、GSS、USS代表什么意思 Android绘制三部曲、Canvas是怎么最终显示在屏幕中的、是以什么样子的数据结构传输的 物理内存与虚拟内存的关系、Android Heap的结构是怎么样的、如果要进行垃圾回收，会收集那些区域 binder源码、其原理是什么，发起一次请求的过程，如何根据文件描述符找到对应的binder实体 多个Fragment在销毁后重建之后重叠怎么办 点击看答案 产生重叠的原因一般是由于我们采用show 和 hide 的方式( 而不是replace )来控制Fragment 的显示和隐藏，当Activity 由于内存不足被回收之后再恢复的时候，如果不做处理，那就会把这些fragment new 出来添加到Activity 中，由于是刚new出来的，并没有以前的show/hide 状态，因此就造成重叠。 解决办法在第一次进入Activity 初始化Fragment的时候，为添加的fragment 设置tag ，并且 tag 为fragment的全限定名，将这些tag以列表形式tags保存。在 onSaveInstanceState 回调的时候，保存tags。 在恢复的时候，首先恢复出来tags，再依次遍历tags中的tag，使用FragmentManager.findFragmentByTag 查找fragment。如果查找出来的 fragment 不空，则直接使用，否则的话，就使用 savedInstanceState?.classLoader.loadClass(tag) 来反射新建这个fragment (因为我们的tag就是fragment 的全限定名嘛)。 replace 方式切换fragment 与 show/hide 方式切换fragmentreplace 固然可以避免很多不必要的问题，但是它不能保存页面状态，对用户体验不友好，频繁切换还会导致卡顿。show/hide 方式只会控制隐藏/展示，所以效率上会好一些。 以上内容参考自简书上的博客、披萨大叔 设计一个图片缓存框架，缓存算法用什么 点击看答案 缓存算法使用 LRUCache，其原理可以参考Android基础-LruCache原理 有个ListView快速滑动 如何优化Bitmap的显示 点击看答案 监听列表的 onScrollChangeListener ，在快速滑动的时候， Fresco.getImagePipeline().pause() ,停下之后又 resume() 操作。 以上内容可以参考：cnblogs上的博客 Bitmap的复用听过没有 点击看答案 参考Android基础中38题的内容 如何进行内存优化 减少内存消耗 shopeetry catch finally关于return的执行结果 点击看答案 参考java基础-Java finally与return执行顺序 treemap如何对两个元素进行比较 非compareble对象比较 点击看答案 TreeMap 使用红黑树实现，时间复杂度 log(n)，TreeMap要求存放的键值对映射的键必须实现Comparable接口，从而根据键对元素进行排序。 以上内容可以参考cnblogs的博客 hashcode equals区别 object有什么方法 点击看答案 clone、equals、finalize、getClass、hashCode、identityHashCode、identityHashCodeNative、internalClone、notify、notifyAll、toString、wait 以上内容参考自系统源码 讲讲Android存在的设计模式 点击看答案 Context 的装饰器模式 AlertDialog 使用了建造者模式 BitmapFactory 的工厂模式 View 的layout、measure、draw 就是 责任链模式 aidl 代理模式 ListView、Gridview 等 使用的适配器模式 以上内容参考自简书上的文章 android的消息机制 android的事件分发 讲个android的源码 自选 LeakCanary 设计模式讲讲有什么认识的，代理模式优缺点 点击看答案 代理模式优点： 协调调用者和被调用者，降低耦合度 增强被调用者的功能。增加和更换代理无需修改被调用者源码，如何开闭原则，具有良好的可扩展性。 保护目标对象 缺点： 增加了类 速度可能慢。在调用者和被调用者之间增加了代理对象，因此请求处理的速度可能会变慢 增加系统复杂度。实现代理模式需要额外的工作，有些可能还比较复杂，比如远程代理。 以上内容参考自简书上的博客 图片 缓存机制 首屏调优 内存调优 lazada自我介绍一下app网络防劫持 介绍下，出现劫持，解决方案呢？拦截了webview 网络请求后，用什么请求性能优化，做了哪些工作强引用、弱引用和软引用。弱引用和软引用的区别。MVC 和 MVP 的区别。他们各个层次之间交互有什么区别 SharedPreference 是线程/进程 安全的吗？apply 和 commit 有什么区别？(提交到哪？是本地的xml 还是 内存的xml？)，有什么坑？Handler 机制说一下？ 消息延迟是怎么做到的？我有个新消息，在已有的消息队列中我想让他先执行，可以吗。 最有挑战的项目？你负责做了什么？给你带来什么价值？，这个sdk给你们的产品带来什么价值？如何判断你这个sdk是否好用？你们的业务成功率是多少，有统计吗？如果要设计这个监控这个sdk？你们有相关的埋点吗？感觉面试官隐约对app的监控感兴趣。 http 和 http2 有什么区别。 http 和 https 有什么区别。告诉我它是怎么做到安全的呢？ kotlin 语言与java 语言相比有什么优点吗？ kotlin 的协程了解吗？它的原理？协程相比线程创建的开销小一些？主线程使用协程是不是不会阻塞？假设我在主线程里面使用协程执行非常耗时的操作，我的主线程会ANR吗？为什么在io操作比较多的时候对协程有利呢？协程有自己的栈空间吗？ cici数组实现队列gc的流程java软引用与弱引用区别java中的this编译时的原理final变量用反射修改HashMap的内部结构，给定一个key，如何找到对应的value，使用equalvolatileJava线程池有什么作用Java动态代理handler机制android跨进程通信的方式自定义控件方式Canvas绘制过什么 手写功能断点续传的实现如何设计图片加载库有看过哪些安卓的源码 View树绘制 事件分发 Activity启动 handler看过哪些开源项目 eventbus volley 图片 线程池管理 插件化 资源加载app 启动速度的优化做过哪些fresco加载图片原理 优势是什么写程序时，堆和栈有什么优化点 内存回收时机 如何判断对象可被回收引用计数法和gc root法事件分发 cancel事件一般在什么时候被触发touchdelagate 一个父view只能设置一个delegate，如何解决设置多个App整个架构了解么mvvm data bindingwebviewfragment startactivity动画的原理黄油计划 vsync设计一个离线视频下载功能 1、Activity 启动流程2、android app签名原理 Android查询资源文件layout原理设计一个decode bitmap方法启动Activity A后，按home键，再从桌面启动activity A ， Activity A的生命周期handler原理 onSaveInstanceState调用时机Fragment View区别Java内存管理和内存回收Android scheme Activity怎么管理自己的生命周期，ActivityThread怎么运作消息事件分发进程之间通讯 线程锁touch事件分发原理scrollview和viewpager之间的滑动如何防止冲突，里面listitem也需要支持滑动怎么办插件化的了解情况动态代理实现（自由发挥的）如何实现一个拥有取出最小值方法的堆栈，要求算法的事件复杂度是O(E)如何算二叉树节点之间的最小距离两个链表，可能很长，实现求和（大数求和），结果也是单向链表ActivityTask的使用onNewIntent的调用时机checkbox，up事件和down事件的区别怎么用Standard方式来实现一个SingleTop启动的ActivityHttp文件上传的具体过程 BD线程同步方法（关键字，并发包）wait/notify,notify方法和notifyAll方法区别，notifyAll方法唤醒的线程，怎么决定哪一个线程得到运行HashMap(要很熟悉)，put过程，get过程现在key为double类型，需要将key的整数部分当成同一个key应该怎么做（提示：重写方法）内存泄露分析进程间通信方式(别忘了BroadcastReceiver)A跳转到B的生命周期调用，如果A的onStop方法方法发生在B的onResume方法之前会发生什么现象，如果B是singleTask又是什么情况？会调用B的哪些方法service运行在什么线程Handler内存泄露原理(message.target = handler，所以真正原因是由于message造成的)，解决方法，一个线程可以有多个Handler吗。handler的sendMessage方法和postRunable方法区别HandlerThread设计一个图片加载框架，LRUCache原理看过第三方库的源码吗排序算法，时间复杂度，快排为什么是NlogN完全二叉树高度弱引用和软引用 今天面到的题目新的部分有几个 1include merge viewstub区别 2二叉树第n层节点个数 3touchdelegate TOU面试http状态码 onTouch、onTouchEvent、onClick 执行顺序 onclick 不响应，如何排查 设计一个下载框架(考虑多线程)。 单进程中，一个线程下载和用两个线程下载哪个更快？ 在主线程要优先执行一个任务咋办？除了消息栅栏外还有其他方法吗？Thread.join，还有吗？如何发送消息栅栏，这是hide方法，自己如何发送异步消息。 空闲的时候执行某个任务有什么方法？IdleHandler，还有其他方式吗 IntentService 与 Service 区别，啥时候用IntentService synchronized 锁优化策略 线程安全的集合有哪些？CopyOnWriteList 在什么时候使用？HashTable 与 ConcurrentHashMap 的区别？ 线程池的拒绝策略有哪些？ 什么情况下singleTask 在一个进程中会有两个实例？ NEW_TASKA启动B，B启动C，C启动D，现在从D启动A，并且启动完成后只保留A，如何做？ Okhttp 的 addInteceptor 与 addNetWorkInterceptor 的区别 如何保证dns的安全？自己建立dns服务器，httpdns 做sdk的话，如何在接入的时候管理第三方依赖 设计模式，整体和部分 Okhttp 多个host，如何配置 TENG面试了解插件化吗？有哪些第三方开源的方案？Tinker的原理 行业内性能优化的方案有了解吗？页面如何秒开？ 串行GC的时候，会锁住堆挂起线程，那么无论线程处于什么状态都能挂起吗？ 多线程中的同步队列与等待队列(可能问的是 同步队列和条件队列) CAS是啥？AQS是啥可以参考这里？RetraintLock的原理 锁的种类，什么是可重入锁 如何让多个线程同时启动 Java内存空间怎么划分 有哪些GC算法，哪些对象可以作为GC Root JNI 中，Env是啥，它能干什么 什么情况下本地方法栈会引用Java对象 HashMap原理 Android系统的启动流程，应用为什么用zygote来fork，有什么好处 Apk的签名原理，v1和v2 https相比http的优势是什么？除了安全之外呢？证书如何校验 Java的堆与栈的区别，除了存储的对象不一样之外，还有其他不一样么？ 进程间通信为什么用Binder，Binder的原理？空间大小限制（貌似是4M）? 可重入锁是什么？悲观锁和乐观锁的区别？ 什么时候用到TCP，什么时候用到UDP？举例 https的攻击手段，https的证书是如何发送给客户端的？ RecyclerView和ListView的区别 TENG面试http状态码 ontouch ontouchEvent onClick 执行顺序 onClick不响应，应该怎么排查 设计一个下载框架（还要考虑多线程），单进程中，一个线程下载和用两个线程下载谁快？（要充分利用cpu） 在主线程我要优先执行一个任务咋办？消息栅栏，除了这种方法之外呢？如何发送消息栅栏？这是hide方法 空闲的时候执行某个任务有什么方法？IdleHandler，thread. join，还有啥方法吗 IntentService 与service区别？啥时候用IntentService synchronize锁优化策略 线程安全集合有哪些？HashTable与ConcurrentHashMap 的区别？Copy onWrite List在啥时候用？ 线程池的拒绝策略有哪些 什么情况下singleTask在一个进程中会有两个实例 a启动b，b启动c，c再启动d，这时候直接回到a页面，并且只保留a页面，有啥方法？ okhttp的addIntercept 与 add Network Interceptor 方法区别？ dns安全，httpdns 方案 做sdk管理第三方依赖 设计模式，整体和部分 自己发送异步消息 okhttp多个host，多重配置 异步创建view的原理 如何插桩 哪些地方匿名共享内存：堆，contentprovider，显示的时候 sp原理 事件分发 hashtable concurrentHashMap TOU面试handler，IdleHandler原理，使用 组件化，插件化，热修复 断点续传 用过哪些开源库？retrofit的原理 反转二叉树 做了哪些优化？gpu优化？ hashmap原理，如何hash？为什么8个的时候要红黑树？ a启动b生命周期怎么走 gc算法，哪些可以作为gc root，分代算法是怎样的？ volatile关键字作用？能保证原子性吗？ webview内存泄露的原理，handler内存泄露原理 如何发现内存泄露？LeakCanary的原理是什么？ Activity的启动模式 taskaffinity的作用？ 进程间通信方式有哪些？AIDL能传递的数据类型有哪些？AIDL怎么使用？AIDL的方法参数能传接口吗？都跨进程干什么 app崩溃率多少？怎么统计的？能捕捉所有异常吗？如何捕捉native的崩溃？ 动态代理 TENG面试relativelayout与constrantlayout（可以参考链接：https://mp.weixin.qq.com/s/gGR2itbY7hh9fo61SxaMQQ） 如何查看cursor之类的导致内存泄露问题 onclick，onTouch执行顺序 算法：链表的中间元素，判断链表是否有环，快排最好最差时间复杂度，快排是怎么操作的 T3 面试近期有做什么优化或者重大技术？DNS污染是怎么回事https的证书是怎么起作用的？用什么检测内存泄漏-LeakCanary扫码登录是怎么做到的多线程用过吗，乐观锁与悲观锁说下 T1String可以继承吗？为什么？为什么设计成不可变？快排原理二分查找原理Activity的几种启动方式，Service中怎么启动Activity（参考链接：https://blog.csdn.net/fang323619/article/details/74388804），从源码角度来说，ActivityManager 为什么会对4种tag做处理 事件传递的机制(触摸事件)？Activity 的顶级响应视图是啥？onTouchListener 与onClickListener 哪个先执行(onTouchListener)？onTouchListener 返回true 之后，onClickListener 还会执行吗(不会)？onTouchListener 和 onLongClick 哪个先执行？ View的绘制流程？从掉帧的角度来说下 View 的绘制流程？ScrollView 嵌套滑动冲突怎么去解决？在父view的up里面return 了true，子view会收到down事件吗？tcp与udp区别，tcp三次握手做了什么单例模式怎么写，为什么大图一般是怎么优化的？fresco的源码有看过吗，它有什么缺点？有没有用过其他的图片框架？Activitymanagerservice 源码知道哪些app性能优化 国斌1: （1）自我介绍 （2）你主要负责什么模块、奖金优化是什么东西（奖金优化的前提是如果能中奖，中奖金额要怎么样）、如何将所有组合列出来、如何将注数分配出去、奖金范围怎么算的 （3）APP的架构是怎么样的，为什么要这样子架构？MVP每块你们是怎么分工的 （3）首屏怎么调优的、加快启动速度的，内存泄漏怎么检测，LeakCanary原理是什么 （4）HashMap源码相关、为什么要将链转红黑树？红黑树特点、插入删除 （5）消息循环源码、如何做到任务切换线程、想要提交一个任务有几种方式 （6）Kotlin协程原理，怎么切换线程的，为什么要换Kotlin及其优缺点 （6）一个无序、实际上是逆序的数组排序用什么算法好 我说的是快排、实际上应该用归并排序能获得最好的时间复杂度 2： （1）还是奖金优化 （2）还是性能调优、怎么瘦身、打包流程、模块化 （3）开发者GPUInfo中的每条柱状图颜色代表含义、命令dumpsys meminfo中VSS、PSS、GSS、USS代表什么意思 （4）Android绘制三部曲、Canvas是怎么最终显示在屏幕中的、是以什么样子的数据结构传输的 （5）物理内存与虚拟内存的关系、Android Heap的结构是怎么样的、如果要进行垃圾回收，会收集那些区域 （6）binder源码、其原理是什么，发起一次请求的过程，如何根据文件描述符找到对应的binder实体 （7）广度、深度搜索，拓朴排序、最短路径算法 （8）ELF文件格式、反编译器原理 （9）Kotlin优缺点 3： （1）项目架构是怎么样的 （2）画一下结构图 （3）为什么要迁移项目到Kotlin （4）线程 协程 为什么需要线程池 他的状态变化是怎么样的 在Android中的应用 （5）如何设计一个App的架构 该考虑什么 （6）Flutter怎么从平台到Dart的 如何渲染的 （7）你觉得面得怎么样 4： 讲个项目你负责的模块多个Fragment在销毁后重建之后重叠怎么办设计一个图片缓存框架缓存算法用什么有个ListView快速滑动 如何优化Bitmap的显示Bitmap的复用听过没有如何进行内存优化 减少内存消耗 5： 讲下项目的架构负责的模块算法 最大子序和try catch finally关于return的执行结果hashmap源码 treemap如何对两个元素进行比较 非compareble对象比较hashcode equals区别object有什么方法讲讲Android存在的设计模式android的消息机制android的事件分发讲个android的源码 自选LeakCanary 6：android消息机制android事件分发设计模式讲讲有什么认识的 代理模式优缺点图片 缓存机制首屏调优 内存调优 lazada自我介绍性能优化做了哪些工作四种引用的含义mvp 与 mvc 区别Handler 机制，如何实现消息延迟最有挑战的项目，负责做了什么业务监控怎么设计http与http2的区别http与https的区别kotlin语言与java的区别，优点kotlin的协程原理，有自己的栈空间吗，与线程区别 英语自我介绍下？–妥妥挂了。。 猫总为什么不用URLConnection而用OKHttp不了解 qq的music自我介绍下性能优化的经验如何设计措施，防止以后新人在主线程添加太多的任务了解过启动框架吗如何分阶段启动相关任务，这些任务有相互依赖，或者有向无关图能达到什么效果，量化下内存优化的内容webp 占用内存小一些还是尺寸小一些？图片框架本来就会做这些裁剪之类的功能，这样自己做是否就重复了其它内存优化的点(我觉得可以说说大图加载，只加载一部分)了解ashmem 吗，除了这个作用还能有其他作用吗优化app的整体内存占用第一步得分析吧。profile 工具第二步、分析问题在哪，native 和 Java 层 的内存占用，如果native 和 Java 中图片占用都比较大，如何分析第三步、是内存泄漏导致的、还是大数组、大对象 用LRU 的话，一般不会引起内存很大占用，所以如果内存大，一般是内存泄漏导致的 Talkingdata 统计些什么 监控dns的成功率，即用户使用你的ip直接请求的成功率了，以前系统直接解析，现在是用户直接打不开 尝试使用https 去解决吗 网络成功率怎么优化 dark 和 art 的 gc 过程有了解吗 非并行 GC 的过程 分配内存，不够，然后做什么操作，最后就会分配成功。分配不够的话，系统会扩容，扩容发生在什么时机 常用设计模式，单例模式怎么写 volatile ： 性能优化了解不太多，尤其内存优化总结不多，数据量化 字节参考Fresco 架构上说下，MVC模式，说说 Fresco加载gift的流程和原理4. 一个大的ViewGroup，上面显示两个不一样大小的图片，内容一样，怎么做（利用Fresco的缓存）5. 一个图片是50 * 50，一个图片是100 * 100，内存大小是怎样的，比如 5050的内存大小是1，100100的内存大小是多少？ 两张图片，内存变大了还是不变，内存副本有几份？6. RecyclerView 滑动的时候，缓存机制7. RecyclerView 下面一个子item，我手指按在RecylerView上，然后滑动，说出滑动过程8. 海量数据中找出TOP N（堆）9. 自定义帧动画机制，一边解压一边加载，用完之后回收，inBitmap进行内存复用。用了哪些数据结构，如何保证按顺序执行。10. bitmap drawable 区别(互相转化，drawable包含bitmap)Bitmap是Drawable . Drawable不一定是Bitmap Drawable在内存占用和绘制速度这两个非常关键的点上胜过Bitmap 1、 jni 方法调用是怎么实现之类的2、 java string 和 c++ string 有什么区之类的3、 自己做的项目上遇到的技术难题和解决方案4、 消息队列 如何设计一个组件化的appView的绘制流程activity的启动模式如何监控启动就crash的问题如何独立编译单独的组件对比一下图片加载模块，Glide 和Fresco , AsyncImageView 主要还是通过项目发散开的问题：1，android开发中常见的两种序列化，serializeble 和 parcelable 的区别2，recyleview中的常见卡顿问题是如何解决的，如何监控到用户的卡顿（监控UI线程的message 处理逻辑，超过60ms）3，项目比较大，编译比较慢的解决办法（插件化，组件化）4，项目中遇到的一个小问题，是如何解决的5，OOM类型的问题如何解决6，内存泄漏如何监 Android so如何减包Android Camera采集渲染流程如何排序一个比内存大的文件 C++ 父类析构函数的virtual作用，怎么实现防止内存泄漏的C++ 虚函数表是什么JNI的attachCurrentThread作用是什么JNI的LocalRef和GlobalRef new了是否要delete，可以不delete么？简单介绍下libuv","categories":[{"name":"笔记","slug":"笔记","permalink":"https://glassx.gitee.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"他山之石","slug":"他山之石","permalink":"https://glassx.gitee.io/tags/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/"}]},{"title":"Android开发技巧","slug":"Android开发技巧","date":"2020-05-01T01:38:00.000Z","updated":"2020-05-01T01:40:07.134Z","comments":true,"path":"2020/05/01/Android开发技巧/","link":"","permalink":"https://glassx.gitee.io/2020/05/01/Android%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/","excerpt":"查看运行的service如果要查看当前手机上运行有哪些service（不可以先 adb shell 再执行后面的，否则显示的进程就不对了，至少我的是这样的）： adb shell dumpsys activity services 当然，肯定是可以加 grep 关键字过滤的： adb shell dumpsys activity services | grep MiniAppPreService","text":"查看运行的service如果要查看当前手机上运行有哪些service（不可以先 adb shell 再执行后面的，否则显示的进程就不对了，至少我的是这样的）： adb shell dumpsys activity services 当然，肯定是可以加 grep 关键字过滤的： adb shell dumpsys activity services | grep MiniAppPreService 同理，我们也可以通过 grep 过滤查看当前一组进程(下面示例是过滤出名字中包含 com.example.io 的)： adb shell ps | grep com.example.io","categories":[{"name":"Android技巧","slug":"Android技巧","permalink":"https://glassx.gitee.io/categories/Android%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"手摸手","slug":"手摸手","permalink":"https://glassx.gitee.io/tags/%E6%89%8B%E6%91%B8%E6%89%8B/"}]},{"title":"第8章：计算机网络中的安全","slug":"计算机网络-自自顶向下方法-中文第6版-第8章","date":"2020-05-01T00:56:00.000Z","updated":"2020-05-01T01:09:01.466Z","comments":true,"path":"2020/05/01/计算机网络-自自顶向下方法-中文第6版-第8章/","link":"","permalink":"https://glassx.gitee.io/2020/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87%E7%AC%AC6%E7%89%88-%E7%AC%AC8%E7%AB%A0/","excerpt":"8.6 使TCP 连接安全，SSL SSL （Secure Socket Layer ）安全套接字层， SSL 版本 3的一个稍加修改的版本被称为 TLS(Transport Layer Security)在 http 之下，tcp 之上，有 ssl 层。ssl 握手流程：总体来说，ssl 握手，首先要建立一个tcp 连接 ，其次在验证server 的真实性 ，最后 client 再将对称加密所需要的key通过公钥加密交给server。此后，两端通过对称加密来完成通信。整个过程如下图所示：","text":"8.6 使TCP 连接安全，SSL SSL （Secure Socket Layer ）安全套接字层， SSL 版本 3的一个稍加修改的版本被称为 TLS(Transport Layer Security)在 http 之下，tcp 之上，有 ssl 层。ssl 握手流程：总体来说，ssl 握手，首先要建立一个tcp 连接 ，其次在验证server 的真实性 ，最后 client 再将对称加密所需要的key通过公钥加密交给server。此后，两端通过对称加密来完成通信。整个过程如下图所示： 抛开tcp连接的建立，详细步骤如下： client发送支持的算法列表以及一个随机数 x server 从接收的列表中选择一种对称算法、一种非对称算法 和 一种摘要算法，连同自己的证书 以及 随机数 y 一起返回 client 验证该证书，提取公钥，并生成一个前主密钥，并用服务器的公钥加密这个 前主密钥，之后发送给server server 解密获得 主密钥 client 发送自己这边所有握手的报文的一个 摘要 server 端发送自己这边握手报文的一个 摘要 最后两个步骤保证了握手免受篡改危害。比如，在观察第一步的时候，客户端提供的算法列表，有些算法强，有些弱，因为还未协商，所以这张列表是以明文发送的。如果中间攻击者从中删除了较强的算法，迫使server 最后只能选择较弱的算法。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机网络-自自顶向下方法-中文第6版","slug":"计算机网络-自自顶向下方法-中文第6版","permalink":"https://glassx.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87%E7%AC%AC6%E7%89%88/"}]},{"title":"第3章：运输层","slug":"计算机网络-自自顶向下方法-中文第6版-第3章","date":"2020-05-01T00:50:00.000Z","updated":"2020-05-01T01:11:12.465Z","comments":true,"path":"2020/05/01/计算机网络-自自顶向下方法-中文第6版-第3章/","link":"","permalink":"https://glassx.gitee.io/2020/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87%E7%AC%AC6%E7%89%88-%E7%AC%AC3%E7%AB%A0/","excerpt":"3.2 因特网提供的运输服务TCP 协议提供的拥塞控制不一定能给通信进程带来直接好处，但能为因特网带来整体好处。3.3 无连接运输：UDPDns 是一个通常使用 UDP 的应用层协议的例子。一台主机中的DNS应用程序想要进行一次查询时，它构造一个报文并将其交给UDP。如果没有查询到，要么告知应用程序不能响应，要么试图向另一个dns服务器发送查询。","text":"3.2 因特网提供的运输服务TCP 协议提供的拥塞控制不一定能给通信进程带来直接好处，但能为因特网带来整体好处。3.3 无连接运输：UDPDns 是一个通常使用 UDP 的应用层协议的例子。一台主机中的DNS应用程序想要进行一次查询时，它构造一个报文并将其交给UDP。如果没有查询到，要么告知应用程序不能响应，要么试图向另一个dns服务器发送查询。 为什么不是总选择TCP这种可靠连接呢？有以下几个原因： 速度快。无需建立连接，不用像TCP 哪样三次握手然后建立连接(想想如果dns运行在tcp上，则会慢很多) 更精细控制。使用UDP ，应用层可以更精细控制 何时、发送什么数据 UDP 无需维护连接状态。没有维护连接状态，也就不需要发送和跟踪 缓存、拥塞控制、序号确认 等工作，响应更快 分组的首部开销小，TCP 有20个字节，而UDP 仅仅 8个字节 首先要提一下，UDP 是可以实现可靠数据传输的，可以通过在应用程序中建立可靠性机制来保证。这样无需受制于TCP 拥塞控制机制限制传输速率。 UDP 首部只有 源端口号，目的端口号，长度(首部+数据) 以及 校验和。校验和用于防止传输过程中引入的差错(路由器内存可能引入比特差错) 3.4 可靠传输的原理 TCP 是在不可靠的 IP 层之上实现可靠数据传输协议。 需要三种协议来处理比特差错的情况： 差错检测。要有检测手段 接收方反馈。 重传 回退N步：允许发送放发送多个分组，而不需要等待确认，但是也受到滑动窗口的限制，不能超过最大分组数。如果出现超时，发送方重传所有已发送但还未被确认过的分组。当接收到一个连续的ack时，窗口就向前滑动(因为接收方是要求按序接收的，比如n还没收到，但是来了n+1，将会把n+1丢掉的)。选择重传：按照滑动窗口发送时，接收方将确认一个正确接收的分组而不管其是否按序，时序的分组将被缓存直到所有丢失分组都受到位置，这样才一并交给上一层。避免丢弃导致无谓的重传 3.5 面向连接的传输：TCP快速重传： 一旦收到3个冗余的ACK，TCP就会执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。 TCP让发送方维护一个接收窗口的变量来提供流量控制。 流量控制服务：限制发送速率，避免发送方使接收方缓存溢出的可能性。 如果客户端故意不发送ACK来完成第三次握手，那就是所谓的SYN洪范攻击。 拥塞控制：如果TCP发送方感知到网络没什么拥塞，则TCP发送方增加其发送速率；如果发送方感知有拥塞，则降低发送速率。 确定拥塞： 超时或者 收到3个冗余的 ACk，就认为发生了拥塞如何控制：可以使用拥塞窗口(congestion window，用cwnd 来表示) 去控制发送方向网络中发送流量的速率。 TCP拥塞控制算法： 慢启动：TCP 连接开始时，cwnd 通常设置一个较小的值，之后，每发送成功一次，cwnd就翻番。因此，tpc开始时较慢，但在慢启动过程中以指数增长。 拥塞避免： 一旦进入拥塞避免状态，cwnd的值是上次遇到拥塞时的值的一半，即距离拥塞并不远。因此，tcp 每发送成功一次不再是翻番，而是增加一定的量，先行规律缓慢增长，比慢启动速率慢很多。 快速恢复： 拥塞窗口减半cwnd=cwnd/2，之后执行拥塞避免算法，使拥塞窗口慢慢增大。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机网络-自自顶向下方法-中文第6版","slug":"计算机网络-自自顶向下方法-中文第6版","permalink":"https://glassx.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87%E7%AC%AC6%E7%89%88/"}]},{"title":"高级进阶课","slug":"高级面试课程","date":"2020-04-19T14:16:00.000Z","updated":"2020-07-25T01:03:10.454Z","comments":true,"path":"2020/04/19/高级面试课程/","link":"","permalink":"https://glassx.gitee.io/2020/04/19/%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E8%AF%BE%E7%A8%8B/","excerpt":"4-1 停止线程 点击看答案 有两种方法： 调用 interruput 方法，通过抛异常的方式触发 使用boolean 标志位，注意，要使用volatile 标志位保证可见性； 一般而言，如果你使用了 Thread.sleep() 这样的系统方法，那么使用 interrupt 方法来停止线程，否则一律使用 boolean 标志位。 建议转移到线程安全问题上去 为什么停止线程会有问题suspend 方法，但是现在已经被废弃。线程 t1 和 t2 ，如果t1被暂停了，然后一直持有锁 L1，那么t2一直在等待L1，而且不知道什么时候会恢复，这就很糟心了；并且如果t2持有t1需要的锁 L2 ，那就更麻烦了，可能导致死锁。所以线程的暂停(suspend方法)方法被废弃了。停止线程t1，马上释放锁，这时候线程t2 获取锁，接着读取这块加锁的内容，此时，如果t1在这个过程中只写入部分数据，t2 拿到的就是 非法数据，所以停止线程(stop方法)是不安全的。 为什么Thread 的run方法中执行 sleep 方法要try-catch 捕捉 InterruptedException ，这是因为在sleep 过程中，有可能这个thread 会被调用 thread.interrupt() ，此时就会触发 这个异常，我们应该在 catch 语句中 关闭打开的文件之类的。","text":"4-1 停止线程 点击看答案 有两种方法： 调用 interruput 方法，通过抛异常的方式触发 使用boolean 标志位，注意，要使用volatile 标志位保证可见性； 一般而言，如果你使用了 Thread.sleep() 这样的系统方法，那么使用 interrupt 方法来停止线程，否则一律使用 boolean 标志位。 建议转移到线程安全问题上去 为什么停止线程会有问题suspend 方法，但是现在已经被废弃。线程 t1 和 t2 ，如果t1被暂停了，然后一直持有锁 L1，那么t2一直在等待L1，而且不知道什么时候会恢复，这就很糟心了；并且如果t2持有t1需要的锁 L2 ，那就更麻烦了，可能导致死锁。所以线程的暂停(suspend方法)方法被废弃了。停止线程t1，马上释放锁，这时候线程t2 获取锁，接着读取这块加锁的内容，此时，如果t1在这个过程中只写入部分数据，t2 拿到的就是 非法数据，所以停止线程(stop方法)是不安全的。 为什么Thread 的run方法中执行 sleep 方法要try-catch 捕捉 InterruptedException ，这是因为在sleep 过程中，有可能这个thread 会被调用 thread.interrupt() ，此时就会触发 这个异常，我们应该在 catch 语句中 关闭打开的文件之类的。 4-2、如何写出线程安全的代码 点击看答案 每个线程都有一个自己的内存副本，这是java的内存模型。 要么不共享，要么不可变。其次就是采取一定手段了 final 其实还有一个功能就是禁止重排序。某些情况下，构造函数调用完了，非final的成员变量还没初始化完(final 是已经初始化完了)，这就会有问题了。 为什么 a++ 不是原子性的，因为这个操作首先要将 a 赋值进来，int temp = a; 之后再对temp 操作：temp += 1; 最后再将 temp 的值赋回给a。 ThreadLocal 的使用建议ThreadLocal 对对象也是弱引用 声明为全局静态final 成员，避免初始化多个ThreadLocal 对象(因为设置value的时候是以ThreadLocal 为key的) 避免存储大量对象，因为hash冲突使用的是开放定址 法，这并不适合大量数据 用完后及时移除，因为它只能靠主动移除和线程退出时移除，否则线程声明周期长的时候，迟迟得不到释放。 禁止重排序的方法： final 关键字 volatile关键字 加锁(synchronized/Lock) 保证可见性： final 关键字 volatile 加锁(释放锁之前强制刷新到主内存 ) 保证原子性的方法： 加锁 使用CAS 指令 使用原子类型 ，如 AtomicInteger 使用原子属性更新器 还可以参考简书上的博客 4-3、ConcurrentHashMap 点击看答案 从1.5 到 1.8 一直在优化 jdk5：诞生，分段锁(segment)，对段加锁，必要时加锁。它的hashCode 计算方法就是，对key 求hashCode ，之后对这个hashCode 再散列得到散列码 code，之后，根据这个code 的高位 来计算segment 的值，根据低位计算在segment 中的值。1.6：二次hash算法。Integer 的hashCode() 函数返回的就是它的value值。3万多以下的整数高位都是15，于是都集中在一个segment中，退化成 HashTable 了(因为对这个segment 加锁也就相当于对整个ConcurrentHashMap加锁了)1.7：段(segment)懒加载，volatile &amp; CAS 操作避免加锁。一开始并不会把segment 通通new出来，需要哪个。使用volatile 来修饰 segment[] 数组，防止可见性导致的问题，比如，在某个segment 创建后，另一个线程不能马上知道。8、摒弃段(segment)，基于Hashmap 原理并发。 使用 求和分段计数 CHM 是弱一致性 添加元素不一定马上读到。你读过这个段，然后再往这个段添加数据，那么就遗漏了 同以上的理，清空之后可能还有元素； HashTable 的问题 大锁，对整个HashTable 加锁 长锁，直接对方法加锁 读写公用一把锁，读写不能同时进行 CHM 解法小锁： 分段锁(1.51.7 版本使用segment)，后来(1.8版本)桶节点锁短锁：先尝试获取，失败再加锁分离读写锁：读写失败再加锁(1.51.7版本)，volatile读CAS写(1.7~1.8版本) 总结：如何进行锁优化长锁不如短缩：尽可能只锁必要的部分大锁不如小锁：对加锁的对象拆分分离读写锁，读写的频次是不一样的消除无用锁，尽量不加锁，使用volatile 或者 CAS 4-5 Android 中写出优雅的代码 点击看答案 异步，不一定涉及到多线程，比如你setOnclickListener，它不是马上执行，而是等点击再相响应。异步不一定快，如果你线程一直在做运算，其实就无需太多线程，如果有很多io，被阻塞在那，那多开线程是有用的。 避免回调地狱。 Rxjava 要注意的问题： 很多时候Rxjava 请求完数据后，要更新UI，其实本质上这还是匿名内部类，会持有 Activity 引用。更新ui的时候，ui可能已经没有了，可能出现空指针； 声明将所有任务的句柄放在 List 列表中，在需要停止的时候，遍历执行 Disposable.dispose(); kotlin 协程协程将异步逻辑同步化，取消协程，其实是跟 view 绑定，监听它的attach 状态，在dettach 的时候，取消协程。 5-1 cpu 架构适配 点击看答案 注意问题： native 开发才关注cpu架构 不同架构兼容性如何 so 库太多如何优化 apk 体积 sdk 开发者应该提供哪些so 库 armeabi 可以兼容x86 和 arm 架构，但是不兼容 mips(mips 目前已经被Android废弃了)。但是兼容方式无法获得最优性能，性能不敏感的话，可以这么干。有哪个架构的目录，那么所有so库就要有一份这个架构。 目前用得最多的可能就是 armabi-v7a 了，考虑实际情况可能使用 armabi-v7a 就可以了。 但是如果你有某个compute.so 针对计算比较多，那么你可以在 armeabi 目录下存在一个 compute.so 以及 compute_v8a.so ，其他的abi 只要提供一份就可以了(其实，微信就是这么干的)。非启动加载的so可以云端加载，从后台拉取。 在gradle 中指定需要的so类型，减小apk体积 sdk 开发要提供完整abi 5-2 Java native 方法怎么与Native 函数绑定第5章的，都是jni，后面再看 6-1，Activity 启动流程 点击看答案 考察什么： 与ams 如何交互参数结果如何展示 Activity 如何实例化 Activity 生命周期如何流转 Activity 窗口如 何展示 Activity转场动画实现机制 Activity 跨进程启动所有进程Zygote fork 出来，预加载到启动资源，加快速度。 插件化，要有占位Activity才能实现。只能Activity 在进程内启动另一个Activity 的时候可以，在请求ActivityManagerProxy 之前和在ActivityThread 中开始回调Activity生命周期之前进行相应处理。 Activity 跨进程启动Activity ，会涉及到Binder 通信，这个Binder 缓冲区是有大小限制的(貌似是4M)，没办法传递的。如果要实现数据传递，如果在同一个进程，可以使用单例，否则呢，不在同一个进程中，可以使用Provider(而AIDL 使用的也是Binder ，同样有大小限制吧)。 由于Activity 是通过反射构建出来的对象： (Activity)cl.loadClass(className).newInstance() ，它是通过无参的构造器构造的，所以呢，我们不要去写Activity 的构造函数，这是不应该的；尤其不要只写有参数的构造函数，这样的话，就没法启动这个Activity 了，会崩溃的。 Fragment 也不要自己写有参数的构造器，虽然我们自己可以把它new出来。但是当Activity 被回收，之后恢复Activity 的时候，会恢复Fragment ，当然，这个恢复也是通过反射的方式，通过无参的构造函数来构建Fragment实例的。如果你是通过有参数的构造函数自己启动Fragment的，那么在恢复的时候可能会丢失信息，这也是我们要求使用 arguments 方式而不是构造函数的参数给fragment传递数据的原因。个人猜测，这可能也是不让我们自己new Activity 的方式去构造它的原因吧。 Activity的窗口展示流程 在Activity 启动过程中，ActivityThread 执行 handleLaunchActivity，在这个方法中，attach 的时候就会 createPhoneWindow，之后调用 create、start、restoreState、postCreate、resume 过程中，其实都在installDecor (个人觉得是初始化 DecorView)，在resume回调之后，马上调用 makeVisible 才将DecorView 展示出来(layout啊，绘制啊)，我们才能看到显示的内容。这也就是为什么在resume 之前我们无法准确地获取View 的高度的原因。 转场动画前一个页面调用 ExitTransiton，在新页面没打开之前，执行这个退出动画，进入新页面时，执行进入动画，这样就衔接上了。 6-2 如何跨App 启动Activity？有哪些注意事项？ 点击看答案 如何启动外部应用的 Activity 共享uid的app(即在App的AndroidManifest文件中都注明了 android:sharedUserId=”xxx”，这个xxx 在两个应用中都是相同的) ，给 Intent 设置包名和Activity的全路径名，即可启动。 目标Activity 在AndroidManifest.xml中 设置为 exported=true，之后给Intent 设置 包名 和Activity全路径名即可。 给目标Activity 设置 action 和 category ，使用 IntentFilter 隐式启动 为允许外部启动的 Activity 添加权限为目标Activity 添加权限，如： 12345678&lt;activity android:name=\".MainActivity\" android:permission=\"com.examle.permit\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"zzz\" /&gt; &lt;category android:name=\"zzzzz\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 那么，如果外部app要启动这个Activity，它要在 AndroidManifest 文件中声明这个权限。之后，再通过 action 和 category 方式启动。不过，这个要求含有目标Activity 的app先行安装。 拒绝服务漏洞如果你的Activity 暴露出去了，那么攻击者可以来攻击，让你的Activity 拒绝服务。具体的原理如下： 我们知道，如果Activity A 启动另一个App 的 Activity B 的时候，往Intent 里面传入一个 实现了序列化接口的对象 serializableObject ，是可以传递过去的。 在 B 中，只要你去访问了 intent.getExtra() ，那bundle 就会把序列化的数据反序列化过来。 好了，如果serializableObject 对象对应的类只在 A 中有，但是在 B 应用中并没有，这时候反序列化就会产生异常(ClassNotFoundException，类找不到异常)。 拒绝服务异常一般发生在 Activity 启动过程中 或者在 onNewIntent 回调过程中。解决方法包括： 1、使用try-catch 2、不要暴露Activity 6-4、在代码任意位置为当前 activity 添加 view 点击看答案 如何在任意位置获取当前Activity 6-5、微信右滑返回效果 点击看答案 Fragment中实现相对简单，Activity 实现起来复杂 fragment实现： view 跟随手势移动的效果，不涉及window控制 用Activity实现，前一个activity 要搞成透明的效果，windowIsTranslucent = true，window的background 设置为透明多个Task情况，比如顺序启动 a、b、c 三个，a 和 c 在同一个栈，因此可以先获取b的照片放做背景透明对Activity生命周期影响，设置透明的话，下面的Activity 只能是 onPause 状态，不可能stop所以我们只有在滑动的时候，才要求透明，其他的时候不透明，因为透明会影响绘制效率啊。。。。 7-1、为什么不能在UI线程绘制 点击看答案 ui线程是什么？ActivityThread 的main函数所运行的线程为什么ui要设计成非线程安全的？因为加锁开销大，ui对时间敏感，ui具有高频可变性 非ui线程一定不能更新吗？不是，还有surfaceView，它会对canvas 加锁 ： lockCanvas ，其次再draw ，最后 unLockCanvas，绘制放在子线程，效率提高。所以，可能app已经anr了，但是地图绘制界面还在绘制，很奇怪，这是因为地图绘制使用了 surfaceview。不过现在官方推荐使用TexutureView了，不推荐使用 SurfaceView。 Handler 的delay 可靠吗？不可靠 7-3、ANR 类型 点击看答案 原理，就是处理事物之前 postDelay 一个事件，这个事件会导致anr窗口弹出，如果在delay的时间内完成事物，则会removeMessage ，把这个postDelay的message移除，就不会产生anr了。 Looper为什么不会导致cpu占用过高？因为 epoll多路复用机制 7-4、自己实现Handler略 8-1、如何避免oom 点击看答案 native heap 在内存不够的时候，也会抛oom 使用合适的数据结构避免枚举-影响内存和编译出来的文件(都会增大) Bitmap： 选选择合适的分辨率，如果作为背景不要太清晰不要使用帧动画对Bitmap的重采样 谨慎使用多进程，新进程会带有一些公共资源，是会消耗内存的。谨慎使用largeHeap = true，不同的手机上不一定能实现，还有，内存太大了，gc会困难使用NDK，Native Heap 优雅避免java 堆内存限制 8-2、如何对图片缓存？ 点击看答案 网络/磁盘/内存 进行缓存缓存算法-LRU算法，或者最少使用频率的算法如何验证算法的效果(命中率) 如何计算图片占用内存的大小 点击看答案 根据实图手动计算它在内存中占用的内存。 首先了解dip，mdpi、hdpi、xhdpi、xxhdpi、xxxhdpi canvas 就相当于一个层，这个层根据不同手机进行缩放 assets(sd卡上的文件也是一样的)：如果png，采用ARGB_8888 的话呢，那就是 宽 × 高 × 4 ，因为每个像素要有4个字节，这里 4个8，每个8代表8个比特如果是jpg，你没有指定加载格式，它默认还是使用 ARGB_8888，计算方式还是：宽 × 高 × 4。 其实jpg它没有透明度，那个A是没有用的，使用 RGB_565 即可，5 + 6 + 5 = 16 ，2个字节，所以就是 宽 × 高 × 2 从hdpi： 假设图片的大小为 112px * 131px ,格式png，如果你图片在 hdpi 中，那么系统会认为你这个图片的密度本身就是1.5，如果你这时候有个2.75密度屏幕的手机，那么它就会换算，比如说宽度 ： 112 / 1.5 * 2.75 = 205.333…. ，系统会四舍五入取 205 ，同理高度会换算成： 131/1.52.75 = 240，所以如果使用 ARGB_8888 ，那占用内存就是 205240 * 4。同理啊，如果手机屏幕大点，比如说是3，那就是 131/1.5*3 和 112 / 1.5 * 3 了。 在把它放到xxhdpi，这时候密度是 3 了，这时候如果手机是 3，那就得是 131/3*3 和 112 / 3 * 3 了 所以如果在 mdpi中，那默认图片密度是 1了，那么在 dpi 是 3的手机上，图片宽高应该是 131*3 和 112 * 3 以此类推，其实在drawable，后面没有带dpi 的，那效果和 mdpi 一样，默认图片是 1 如果是nodpi ，告诉系统不会缩放，就按照原始的像素，131 和 112 了 所以宽高的计算方式 ： 图片/dpi * 屏幕dpi 图片体积优化跟图片存储格式无关。跟采用 ARGB_8888 或者 RGB_565根据需要的尺寸采样使用矩阵变换来放大图片不透明采用 RGB_565.9 图片使用VectorDrawable 9-1、Android p 规避访问私有api的限制 点击看答案 访问私有api，我们使用的是 反射 方式 反射时 setAccessible(true) ,只是绕过语言层面，并不会更改它的 final 或者 private 属性，不会说把private 改成public。 Android p中设置了 API 名单，有白名单、黑名单之类的，私有api在黑名单中，通过限制反射来限制访问 私有api 9-2、换肤的原理略 9-3、virtualApk 插件化原理略 Tinker 怎么实现热修复略 10-1、如何开展优化工作 点击看答案 对整个目标是否有清晰认识 重点问题拆解 优化前期花 20% 的时间就能解决80%问题，剩下的 20%优化很难 对比业内(tester 测试其他app的打开页面方式) 指标监控，前后对比 10-x都略 11-1、如何设计一个系统 点击看答案 保持和面试官沟通，多确认 需求-&gt; 关键流程 -&gt; 细节，明确边界 细节和边界的通常问题： 如何处理并发，是否有频繁io网络怎么接入-短连接、长连接、连接池化，是否频繁与服务端交互(项目中的大接口)、是否有推送啊保障安全性-数据是否需要加密、加密算法、 11-2、插件化略 11-3、设计一个短视频app 点击看答案 视频如何处理？视频来源？自有还是第三方？视频由用户上传还是专业供应平台是否需要建立用户关系链支持分享？支付系统打赏啊？社交。聊天播放器比较耗电视频防止对手获取防止广告被劫持 11-4、设计一个网络框架 点击看答案 不局限于http，还可以 websococket 单向请求还是双向请求啊？ 支持异步请求？使用Rxjava 还是kotlin 协程？ 要考虑可移植性啊？ 缓存策略，多大啊？如何淘汰？ 全局数据拦截器，对所有请求ip替换啊，对公共结果处理啊 日志输出，json，pb 转换为可视化 重试机制，3s、6s 之后再重试，最多重复多少次，防止死循环 参数组装，bean？hashMap，或者类似Retrofit 使用注解配置 协议体可以使用 Builder 模式 数据传输与拦截使用责任链模式 数据序列化 DNS 增强-httpDnsServer ，比如google的，还有aliyun 和腾讯云有，可以默认支持几个","categories":[{"name":"上课笔记","slug":"上课笔记","permalink":"https://glassx.gitee.io/categories/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"高级进阶课","slug":"高级进阶课","permalink":"https://glassx.gitee.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6%E8%AF%BE/"}]},{"title":"面试题-算法-LeetCode-多线程","slug":"面试题-算法-LeetCode-多线程","date":"2020-04-11T12:43:00.000Z","updated":"2020-04-11T13:39:40.260Z","comments":true,"path":"2020/04/11/面试题-算法-LeetCode-多线程/","link":"","permalink":"https://glassx.gitee.io/2020/04/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-LeetCode-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"1114、按序打印：类中的3个方法分别运行在3个线程中，如何保证它们按顺序执行？ 点击看答案 没找到方便记忆的版本，自己写个。当然，链接中通过 AtomInteger 来实现自旋也是不错的。 123456789101112131415161718192021public class JavaMainClass &#123; volatile int a = 0; void test1()&#123; System.out.println(\"test1\"); a = 1; &#125; void test2()&#123; while (a != 1)&#123; Thread.yield(); &#125; System.out.println(\"test2\"); a= 2; &#125; void test3()&#123; while (a != 2)&#123; Thread.yield(); &#125; System.out.println(\"test3 \\n\"); &#125;&#125; 自己写的时候的问题：看懂题目，volatile 关键字使用即可","text":"1114、按序打印：类中的3个方法分别运行在3个线程中，如何保证它们按顺序执行？ 点击看答案 没找到方便记忆的版本，自己写个。当然，链接中通过 AtomInteger 来实现自旋也是不错的。 123456789101112131415161718192021public class JavaMainClass &#123; volatile int a = 0; void test1()&#123; System.out.println(\"test1\"); a = 1; &#125; void test2()&#123; while (a != 1)&#123; Thread.yield(); &#125; System.out.println(\"test2\"); a= 2; &#125; void test3()&#123; while (a != 2)&#123; Thread.yield(); &#125; System.out.println(\"test3 \\n\"); &#125;&#125; 自己写的时候的问题：看懂题目，volatile 关键字使用即可 LeetCode 1195、 交替打印字符串编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是： 如果这个数字可以被 3 整除，输出 “fizz”。 如果这个数字可以被 5 整除，输出 “buzz”。 如果这个数字可以同时被 3 和 5 整除，输出 “fizzbuzz”。 假设有这么一个类： 1234567class FizzBuzz &#123; public FizzBuzz(int n) &#123; ... &#125; // constructor public void fizz(printFizz) &#123; ... &#125; // only output \"fizz\" public void buzz(printBuzz) &#123; ... &#125; // only output \"buzz\" public void fizzbuzz(printFizzBuzz) &#123; ... &#125; // only output \"fizzbuzz\" public void number(printNumber) &#123; ... &#125; // only output the numbers&#125; 点击看答案 看参考答案吧 自己写的时候的问题：使用Semaphore 关键字会简单很多，使用volatile 关键字稍稍麻烦些。 这个问题也可以关联到后续的 打印零与奇偶数 LeetCode 1115、 交替打印FooBar我们提供一个类： 12345678910111213class FooBar &#123; public void foo() &#123; for (int i = 0; i &lt; n; i++) &#123; print(\"foo\"); &#125; &#125; public void bar() &#123; for (int i = 0; i &lt; n; i++) &#123; print(\"bar\"); &#125; &#125;&#125; 两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。请设计修改程序，以确保 “foobar” 被输出 n 次。 点击看答案 注意在空闲的时候Thread.yield() 自己写的时候的问题：可以使用 volatile 关键字，不过在 while 自旋过程中，需要 Thread.yield(); 让出cpu，否则容易出现超时。 LeetCode 1226、 哲学家进餐 点击看答案 这个问题还没想通，后续再看 LeetCode H2O 生成 点击看答案 使用 Semaphore简单粗暴。这个问题还没想通，后续再看 自己写的时候的问题：看别人的再自己写的，h的Semaphore(2),而 o 的 Semaphore(0) ，但是生成h 一个 就release一个 o (虽然o的permit 数量为 0 ，但是在另一个线程release 一个就相当于create 一个，所以并不矛盾，同理，在生成 o 的时候， o.acquire(2)) LeetCode","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题-算法-LeetCode-题库简单题","slug":"面试题-算法-LeetCode-题库简单题","date":"2020-04-04T03:06:00.000Z","updated":"2020-04-24T15:12:33.398Z","comments":true,"path":"2020/04/04/面试题-算法-LeetCode-题库简单题/","link":"","permalink":"https://glassx.gitee.io/2020/04/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-LeetCode-%E9%A2%98%E5%BA%93%E7%AE%80%E5%8D%95%E9%A2%98/","excerpt":"注： 以下题目都是根据 LeetCode App上的顺序，按照由易到难排列(与其他列表有重复的题目就略过了)704、二分查找，给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1 点击看答案 这题目自己写得还不错 自己写的时候的问题：无","text":"注： 以下题目都是根据 LeetCode App上的顺序，按照由易到难排列(与其他列表有重复的题目就略过了)704、二分查找，给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1 点击看答案 这题目自己写得还不错 自己写的时候的问题：无 参考链接：LeetCode 最小k个数 点击看答案 使用 PriorityQueue 代替自己建堆 自己写的时候的问题：Comparator 单词没写对，还有 Comparator 应该是个泛型，后面要接上 参考链接LeetCode 二叉树的最大深度 参考别人的思想 https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ 平衡二叉树 参考别人的思想 https://leetcode-cn.com/problems/balanced-binary-tree/solution/balanced-binary-tree-di-gui-fang-fa-by-jin40789108/ N叉树的最大深度 依葫芦画瓢 https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/ 二叉树的最小深度 我去，审题啊，叶节点啊，[1,2]的时候，叶节点是2啊，1还不是叶节点。 https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/li-jie-zhe-dao-ti-de-jie-shu-tiao-jian-by-user7208/ 翻转二叉树 我去，面试google的那个牛人都没能写出来，我写出来了，额。。其实不就是每个结点都在翻转么。估摸着是那个哥们紧张了吧。 https://leetcode-cn.com/problems/invert-binary-tree/ 对称二叉树 右边比左边，左边比右边 https://leetcode-cn.com/problems/symmetric-tree/ 面试题 03.04. 化栈为队 别人的想法太巧妙了，pop 或者 peek 的时候，只要辅助栈的元素不空，就可以出去。为空就将原本栈的元素倒入到辅助栈再pop或者peek。 https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/solution/java-liang-ge-zhan-by-npe_tle/ 宝石与石头 真心傻逼了，用 if(!set.add(charAt(i))) 去判断，应该只要 if(set.contains(charAt(i))) 即可。 https://leetcode-cn.com/problems/jewels-and-stones/ 整数的各位积和之差 乘积的初始值应该为1啊，蛋疼，居然初始化为 0 https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/ 将数字变成 0 的操作次数 while循环到num == 0 为止 https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/ 统计位数为偶数的数字 转成字符串看length不就好了，还要想着去除，唉 https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/ 有多少小于当前数字的数字 1、快排的条件有点忘了，最开始的判断条件 front &gt; tail，while循环中要有 nums[j] &gt;= pvoit 、num[i] &lt;= pvoit ,一轮while 之后，要执行 nums[start] = nums[front]; nums[front] = pvoit;2、对于数组，int[] nums = {1,4,8,50,2,44,2};可以执行 nums.clone() 能将数组复制一份 https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/ 面试题 02.03. 删除中间节点 脑筋急转弯 https://leetcode-cn.com/problems/delete-middle-node-lcci/","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题-算法-LeetCode-精选TOP面试题","slug":"面试题-算法-LeetCode-精选TOP面试题","date":"2020-03-15T02:15:00.000Z","updated":"2020-04-11T13:04:45.155Z","comments":true,"path":"2020/03/15/面试题-算法-LeetCode-精选TOP面试题/","link":"","permalink":"https://glassx.gitee.io/2020/03/15/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-LeetCode-%E7%B2%BE%E9%80%89TOP%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"注： 以下题目都是根据 LeetCode App上的顺序，按照由易到难排列(与其他列表有重复的题目就略过了)350、两个数组的交集II 点击看答案 hashmap 记录第一个数组每个元素出现次数，再遍历第二个数组 2. 先给两个数组排序，再遍历** 自己写的时候的问题：Integer 写错、HashMap&lt;Integer,Integer&gt; 在 int times = get(key) 的时候，要注意判空","text":"注： 以下题目都是根据 LeetCode App上的顺序，按照由易到难排列(与其他列表有重复的题目就略过了)350、两个数组的交集II 点击看答案 hashmap 记录第一个数组每个元素出现次数，再遍历第二个数组 2. 先给两个数组排序，再遍历** 自己写的时候的问题：Integer 写错、HashMap&lt;Integer,Integer&gt; 在 int times = get(key) 的时候，要注意判空 LeetCode 412、Fizz Buzz，写一个程序，输出从 1 到 n 数字的字符串表示。1. 如果 n 是3的倍数，输出“Fizz”；2. 如果 n 是5的倍数，输出“Buzz”；3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。 点击看答案 计算 n%3==0 及 n%5==0 的 boolean 值。之后分别输出 自己写的时候的问题：canDivid3 的时候，应该使用遍历的下标i ，而不是传入的参数n %3 == 0 LeetCode 13、 罗马数字转整数 点击看答案 前一个数比后一个数小 自己写的时候的问题：map写成了 HashMap&lt;String,Integer&gt; ，应该是 HashMap&lt;Character,Integer&gt;，还有，throw 抛出异常的时候，应该要有new关键字，即 throw new IllegalArgumentException(“error input!”); LeetCode 387、字符串中的第一个唯一字符，给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1 点击看答案 第一次遍历，次数存放在HashMap中，第二次遍历，找到第一个不重复的。 自己写的时候的问题：无 LeetCode 28、实现 strStr()，给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。示例： 12输入: haystack = \"hello\", needle = \"ll\"输出: 2 点击看答案 只有第一个字符匹配上才需要比较 自己写的时候的问题：haystack = “” 且 needle = “” 时，我返回了 -1，应该是 0，还有计算String的长度应该是 str.length() ,而不是 str.leng ,不过数组倒是可以这样做 arr.length LeetCode 38、外观数列 点击看答案 读懂题目很重要，递归 自己写的时候的问题：throw 要 new ！ LeetCode 69、x的平方根，计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去，如8的平方根是 2.28…，则结果取2即可 点击看答案 我自己的写法，没有考虑数字越界： 123456789101112131415161718public static int mySqrt(int x) &#123; if(x &lt; 0)&#123; throw new IllegalArgumentException(\"error input!\"); &#125; if(x == 0 || x == 1)&#123; return x; &#125; int result = 0; for(int i = 1;i * i &lt;= x; i++)&#123; System.out.println(\"i = \" + i); result = i; &#125; return result;&#125; 其他数字都对，但是如果输入 2147395600 ，则在 i= 46340 时，i就已经是结果了，但是这里的循环条件还是会继续执行，这时候 i= 46341 时，就超出 int 的取值范围越界了，因此不对。如果非要用这种方法去实现，可以在 for 语句里面加个条件： i * i &gt; 0 。因为Java 中的int型数据是有符号数，最高位表示符号，越界的时候，最高位变成1了，也就是变成负数，所以这个条件在刚发生越界的时候就不满足了，就能得到正确的结果。 使用二分查找法要注意几点：首先 (a/2)² &gt; a ，则可以解出来正整数解是 a &gt; 4，即在 a &gt; 4的情况下 a/2 &gt; 根号a 是必然的，再综合 1,2,3,4 这几个特殊数字，我们可以得出，a开根号的值在 [1,a/2] 这种闭合区间。还有，开根号这里可能会有小数，但是我们只要返回正数，所以可以要求 front == tail ，最后是返回tail的值，要注意。 LeetCode 371、两整数之和，不使用运算符 + 和 -，计算两个整数 a、b之和 点击看答案 异或求出普通位相加，与操作求出进位 自己写的时候的问题：a 要暂存 无进位结果，我写的时候忘了暂存了。因为无进位结果 + 进位 还有可能产生进位，所以要有 while 循环。 LeetCode 283、移动零，给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序 点击看答案 2个指针，1次遍历 自己写的时候的问题：无 LeetCode 1、两数之和，给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 点击看答案 使用 HashMap 辅助 自己写的时候的问题：无 LeetCode 101、对称二叉树,给定一个二叉树，检查它是否是镜像对称的 点击看答案 递归判断 自己写的时候的问题：要懂递归啊，这是乱写成功的。不会递归时，把条件列出来，估计就有思路了。 LeetCode 108(还未写)、将有序数组转换为二叉搜索树，将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树 点击看答案 二叉树遍历 LeetCode 118、杨辉三角，给定一个非负整数numRows，生成杨辉三角的前numRows行 点击看答案 按照描述的方法，暴力解就好 自己写的时候的问题：自己想的 for语句，依次生成前面的行 LeetCode 125、验证回文串，给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 点击看答案 自己写的时候的问题：自己写的感受还是使用双指针，效率高，转小写，然后去掉无关的符号这种操作效率太低。注意Character的方法 toLowerCase()、 isDigit() 和 isLetter() 就可以了。 [LeetCode](https://leetcode-cn.com/problems/valid-palindrome/solution/java-da-dao-zhi-jian-6xing-by-rabbitzhao/） 268、缺失数字，给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 点击看答案 数组中所有数字异或，结果再与 0n 异或，得到的结果就是缺失的那个数字(因为相同的数字异或结果为0) 2. 0n 这些数字的和-数组所有数字的和 = 缺失的数字 自己写的时候的问题：自己写的时候，感觉使用 异或 操作简单方便。 LeetCode 171、Excel 表序列号，给定一个Excel表格中的列名称，返回其相应的列序号。如：A -&gt; 1，B -&gt; 2，Z -&gt; 26，AA -&gt; 27，AB -&gt; 28 点击看答案 我们常用的 10 进制数字，0~9 共 10 个数字。题目A-Z，26个字母，所以是26进制，故，AB= 26 + 2 = 28** 自己写的时候的问题：看做26进制的数字，从字符串尾部开始遍历，计算每个char所在位的 base ，要注意输入小写字母，所以要统一转为小写去比较。 LeetCode 172、 阶乘后的零，给定一个整数 n，返回 n! 结果尾数中零的数量，你算法的时间复杂度应为 O(log n) 点击看答案 可以转换为n的质因数中5的个数 自己写的时候的问题：*自己写的时候，使用for循环(从 5 到 n，每次进5) 的方式来计算5的个数，结果超时，虽然放在 IntelliJ 中运行结果是对的。因此，应该使用更高效的方式， n /= 5; result += n; *。 [LeetCode](https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-3/） 189、旋转数组，给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 点击看答案 首先能想到的是：新建一个数组，然后将原数组中的数字按照旋转后的顺序放到新数组 ，其次就是：首先将整个数组旋转，再分别旋转前面部分和后面部分 自己写的时候的问题：写了3次，旋转3次是没问题，关键是处理好 k &gt; nums.length 的情况。 LeetCode 190、(还未写)颠倒二进制位,颠倒给定的 32 位无符号整数的二进制位。 点击看答案 每次取1位反转 LeetCode 191、位1的个数，编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数 点击看答案 n&amp;(n-1) 或者 一直往右移 自己写的时候的问题：无符号数有点难，还么有完全理解。while 条件写成 n &gt; 0 ，应该要写成 n != 0。 LeetCode 198、打家劫舍,小偷计划偷窃沿街的房屋。每间房内都藏有一定的现金，但如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额 点击看答案 奇偶，然后选较大 自己写的时候的问题：求偶数和的时候，先计算当前偶数和，再与奇数和比较，计算当前偶数和的最终值 LeetCode 202、快乐数，判断一个数是不是快乐数。一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 点击看答案 快慢指针用来终止无限循环 自己写的时候的问题：主要是要细心，自己写的时候写成 result = temp * temp ,应该是 result += temp * temp LeetCode 204、计数质数，统计所有小于非负整数 n 的质数的数量。（质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。） 点击看答案 质数的判断：for (int i = 2; i * i &lt;= n; i++) 自己写的时候的问题：最优解暂时有点难理解，还是先只要注意 i * i &lt;= n 这样的优化方式吧 LeetCode 234、回文链表，判断链表是否是回文链表 点击看答案 1、反转链表，对比反转后和原链表是否相同 2、链表值复制到数组中，再采用前后双指针 自己写的时候的问题：写得很完美，第一步，快慢指针找到中间节点 第二步、反转中间节点之后的部分 第三步、对比前半部分和反转后的后半部分 LeetCode 326、3的幂，给定一个整数，写一个函数来判断它是否是 3 的幂次方。 点击看答案 1、不断求余，不断除以3，看结果 2、转换成3进制，看是不是前面1个1，后面全是0 自己写的时候的问题：老老实实一直除以 3 ，但是，要注意数字 0 ，否则 n % 3 == 0 会进入死循环 LeetCode 242、有效的字母异位词，给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 点击看答案 大小26的数组，两个字符串遍历每个字符，s遍历就在相应下标+1，而遍历t时在相应下标-1 自己写的时候的问题：只有小写字母，所以用数组实现了，不难 LeetCode","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题-算法-LeetCode-腾讯精选练习50题","slug":"面试题-算法-LeetCode-腾讯精选练习50题","date":"2020-03-08T07:18:00.000Z","updated":"2020-04-06T14:45:07.071Z","comments":true,"path":"2020/03/08/面试题-算法-LeetCode-腾讯精选练习50题/","link":"","permalink":"https://glassx.gitee.io/2020/03/08/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-LeetCode-%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%89%E7%BB%83%E4%B9%A050%E9%A2%98/","excerpt":"注： 以下题目都是根据 LeetCode App上的顺序，按照由易到难排列237、删除链表中的节点编写一个函数，使其可以删除某个链表中给定的(非末尾)节点，函数将只会传给你要被删除的节点(坑在这里，注意：传给你的不是head节点和要删除的值，而是直接传给你要删除的那个节点)。 点击看答案 仅仅只是删除而已，简直是脑筋急转弯，被坑进去了 自己写的时候的问题：没啥，主要是审题","text":"注： 以下题目都是根据 LeetCode App上的顺序，按照由易到难排列237、删除链表中的节点编写一个函数，使其可以删除某个链表中给定的(非末尾)节点，函数将只会传给你要被删除的节点(坑在这里，注意：传给你的不是head节点和要删除的值，而是直接传给你要删除的那个节点)。 点击看答案 仅仅只是删除而已，简直是脑筋急转弯，被坑进去了 自己写的时候的问题：没啥，主要是审题 LeetCode 344、反转字符串 点击看答案 首尾双指针 自己写的时候的问题：尴尬，忘了 i++,j– 了 LeetCode 7、整数反转 点击看答案 每次反转一个数字，注意防止溢出(可以考虑result使用long类型) 自己写的时候的问题：要注意负数的最小值，和整数最大值一样处理 LeetCode 9、回文数，判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。你能不将整数转为字符串来解决这个问题吗？ 点击看答案反转后一半数字 自己写的时候的问题：*通过不断除以10，搞清楚这个值到底是什么数量级，比如99，那 div 就是10级，比如 999，那 div 就是 100级，然后通过 n/div 就能得到第一位， n%10，得到最后一位，比较他们的值。依次往复 * LeetCode 14、(还未做)最长公共前缀 点击看答案 直接看链接，这个不大会 LeetCode 88、合并两个有序数组nums1和nums2，将nums2合并到nums1中，使nums1成为一个有序数组(假设nums有足够空间)。 点击看答案 从后往前，注意 nums1 中剩余的元素 自己写的时候的问题：没问题，从尾到头合并即可 LeetCode 20、有效的括号：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效(即括号的开闭符合规则)。 点击看答案 使用HashMap 建立映射关系，Stack 用于遍历 自己写的时候的问题：记住 Stack 的 isEmpty() 、pop 、push 方法即可 LeetCode 21、合并两个有序链表，将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的(假设链表元素顺序由小到大) 点击看答案 双指针，注意其中一个链表到表尾时，另一个链表整个接上去 LeetCode 292、Nim 游戏，桌上一堆石头，两人轮流拿1~3块石头，拿到最后一块石头的人获胜。现在给n块石头，你先拿，判定你是否能赢得游戏。你们是聪明人，每一步都是最优解。 点击看答案 当 n%4 != 0 时，就可以赢 LeetCode 26、删除排序数组中的重复项，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。你不需要考虑数组中超出新长度后面的元素。 点击看答案 后一个元素与当前重复，则直到不重复的元素，移过来，覆盖重复元素。 LeetCode 53、最大子序和 点击看答案 前面的和是否是正数，是正数就有增益 LeetCode 70、爬楼梯，需要爬n阶才能到楼顶，每次可以爬1阶或者2阶，有多少种方法爬到楼顶？ 点击看答案 斐波那契数列 LeetCode 104、二叉树的最大深度 点击看答案 记住递归方法，好用的递归的方法 LeetCode 121、买卖股票的最佳时机，给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 点击看答案 遍历，记录当前最小的值，以及之后相对应的最大利润 LeetCode 122、买卖股票的最佳时机 II，给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票，注意你不能在买入股票前卖出股票） 点击看答案 简单的一次遍历,相邻依次减下去 LeetCode 136、只出现一次的数字，一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素 点击看答案 所有元素异或 LeetCode 141、环形链表，给定一个链表，判断链表中是否有环 点击看答案 快慢指针，并且快指针每次走两步，慢指针每次走一步 LeetCode 557、反转字符串中的单词 III 输入: “Let’s take LeetCode contest”输出: “s’teL ekat edoCteeL tsetnoc” 点击看答案 使用辅助栈 LeetCode 155、最小栈，设计一个支持push、pop、top操作，并且能在常数时间内检索到最小元素的栈 点击看答案 两个栈，一个正常存放元素，一个不同步存放小元素 LeetCode 160、相交链表，编写一个程序，找到两个单链表相交的起始节点 点击看答案 两个指针分别遍历两个链表，到尾结点后切换到另一个链表的头结点，两个指针相交的地方就是第一个相交的节点 LeetCode 169、多数元素，给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素 点击看答案 排序，中间那个元素就是 LeetCode 206、反转链表 点击看答案 pre节点和current 节点 LeetCode 217、存在重复元素，给定一个整数数组，判断是否存在重复元素。 点击看答案 HashSet LeetCode 231、2的幂，给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 点击看答案 二进制数据中只有1个1 LeetCode 二叉搜索树的最近公共祖先,给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 点击看答案 直接看链接 LeetCode","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题-算法-概念","slug":"面试题-算法-概念","date":"2020-03-08T04:55:00.000Z","updated":"2020-05-08T15:52:03.498Z","comments":true,"path":"2020/03/08/面试题-算法-概念/","link":"","permalink":"https://glassx.gitee.io/2020/03/08/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E6%A6%82%E5%BF%B5/","excerpt":"二叉查找树(也称二叉搜索树) 左子树上的节点值都小于等于根节点的值 右子树上的节点值都大于等于根节点的值 左右子树也是二叉搜索树 它是基于二分查找的思想，查找最大的次数为二叉树高度 查找代价 当左右子树高度大致平衡时，时间复杂度在 O(logN) 当先后插入的关键字有序时，退化成链表，查找的时间复杂度就在 O(N)了","text":"二叉查找树(也称二叉搜索树) 左子树上的节点值都小于等于根节点的值 右子树上的节点值都大于等于根节点的值 左右子树也是二叉搜索树 它是基于二分查找的思想，查找最大的次数为二叉树高度 查找代价 当左右子树高度大致平衡时，时间复杂度在 O(logN) 当先后插入的关键字有序时，退化成链表，查找的时间复杂度就在 O(N)了 插入代价新节点插入到树的叶子节点上，因此，插入节点和查找一个不存在的数据的代价相同 删除代价 如果被删除的节点左、右 有一个为null时，代价仅为 O(1) 如果左右子树都存在，时间复杂度最大也不会超过O(logN) 缺陷： 极端情况可能退化成链表，时间复杂度为 n。这主要是由于树不平衡导致的 平衡二叉查找树(平衡二叉搜索树)是严格的平衡二叉树，它是空树或者左右两个子树的高度差 小于等于1，同时，左右两个子树也是平衡二叉搜索树 查找代价时间很稳定，查找效率最好最坏都是 O(logN) 插入代价由于要保证严格的平衡，插入时可能要进行再平衡(最多旋转一次)，因此插入的整体代价还在 O(logN) 删除代价和插入一样，要考虑再平衡，但是最多需要O(logN)次旋转，所以时间复杂度为 O(2logN) 红黑树(Red-Black Tree)它并不严格地平衡，最长路径长度不超过最短路径长度的2倍。它删除和插入引起平衡性改变的概率要远低于平衡二叉搜索树 查找代价查找代价基本上维持在 O(logN) 级别，最差情况下肯定比平衡二叉搜索树要差，因为没有那么平衡 插入代价不容易引起失衡，整体代价和平衡二叉搜索树差不多，也是 O(logN) 级别(虽然涉及变色，但是变色的代价很小) 删除代价相对平衡二叉搜索树，不容易引起失衡，时间复杂度也在 O(logN) 级别 补充平衡二叉搜索树由于插入和删除，会引起需要调整，可以通过 ：变色、左旋转、右旋转 三种方式调整。是否需要调整要根据红黑树的特性： 节点是红色或黑色 根节点是黑色 叶子节点都是黑色的空节点 红色节点的两个子节点都是黑的(红节点不能连续出现) 任一点到每个叶子节点的路径包含相同数目的黑节点 以上内容参考自zhihu、csdn、知乎 B-树和B+ 树我们所谓的B-树，其实并不是B减树，中间是横线，不是减号；B + 就是 B加树了 如 os 的文件目录存储、数据库中的索引结构的存储，不可能在内存中建立查找结构，必须在磁盘中建立好结构。 在磁盘组织结构下，从任何一个节点指向其他节点都可能读取一次磁盘，再将数据写入内存比较。这回带来大量的IO操作，所以我们需要新的数据结构，即 B树和B+树。 B树是一种多路平衡查找树，每个节点最多包含k个孩子，k称为B树的阶。K大小取决于磁盘页的大小。 一些算法上的概念B树理解平衡二叉树后，就会更好理解后续的B树。 平衡二叉树平衡二叉树是一棵二叉树，每个节点的左边节点小于当前节点的值，右边节点的值大于当前节点的值。 因为二叉树的遍历性能和树的层级成反比，层级h越小查询越快，为了保证树的结构左右两端数据大致平衡以降低二叉树高度，一般会采用算法机制实现节点的平衡，如下图所示： B 树当上述的平衡二叉树深度很深无法存储所有的节点数据时，需要读取磁盘。从而树的深度越大，需要的I/O操作次数越多，因此效率也越低，因此我们需要想办法降低树的高度。 B 树的思路和平衡二叉树一样，但是采用了多叉的方式降低了高度。 B树的具体实现比较难描述，看下面的参考链接更清晰，就不赘述。 以上内容参考自： 勤劳的小手、B树概念 字符串匹配主要是利用KMP算法，这个很令人头大，这里贴出算法代码，如果需要详细了解，可以去查看July大神的这篇文章。 12345678910111213141516171819202122232425262728public static int kmp(String str, String dest,int[] next)&#123;//str文本串 dest 模式串 for(int i = 0, j = 0; i &lt; str.length(); i++)&#123; while(j &gt; 0 &amp;&amp; str.charAt(i) != dest.charAt(j))&#123; j = next[j - 1]; &#125; if(str.charAt(i) == dest.charAt(j))&#123; j++; &#125; if(j == dest.length())&#123; return i-j+1; &#125; &#125; return 0; &#125; public static int[] kmpnext(String dest)&#123; int[] next = new int[dest.length()]; next[0] = 0; for(int i = 1,j = 0; i &lt; dest.length(); i++)&#123; while(j &gt; 0 &amp;&amp; dest.charAt(j) != dest.charAt(i))&#123; j = next[j - 1]; &#125; if(dest.charAt(i) == dest.charAt(j))&#123; j++; &#125; next[i] = j; &#125; return next; &#125; next数组的计算主要跟模式串有关，与文本串并没有关系，因为，模式串前后公共最长子序列。这样才会让我们跳过大量的重复计算 数字排列题目：用1，2，2，3，4，5 这6个数字，写一个方法，打印出所有不同的排列，如 512234、412235等，要求4不能再第三位，3与5不能相连。 思路：问题可以归结为图的遍历，实际上6个数字就是6个结点，把6个结点连成无向连通图，对于每个结点求这个图形的遍历路径，所有结点的遍历路径就是最后对这6个数字的排列组合结果集。当然，这样获取的结果集未达到题目要求：（1）3与5不能相连，这个可以在构造图的时候就满足条件；（2）不能重复，有两个2，明显会存在重复结果，得最后去重（可以放在treeSet中）；（3）4不能排在第三位，这个仍旧在结果集中排除即可。 具体代码略。 手写算法题。猫扑素数；1到n，求1的个数；单词反转。算法：排序、二叉树遍历、红黑树了解。常见的数据结构主要有数组、链表、栈、队列、二叉堆、树、图等，红黑树和BL树的区别快速排序底层原理简单描述。","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Android获取debug包的cookies的db文件","slug":"Android获取debug包的cookies的db文件","date":"2020-02-27T00:00:00.000Z","updated":"2020-03-03T13:29:59.914Z","comments":true,"path":"2020/02/27/Android获取debug包的cookies的db文件/","link":"","permalink":"https://glassx.gitee.io/2020/02/27/Android%E8%8E%B7%E5%8F%96debug%E5%8C%85%E7%9A%84cookies%E7%9A%84db%E6%96%87%E4%BB%B6/","excerpt":"背景在项目中，用户登录后，需要为白名单中的 host 注入特定的cookies，在用户退出登录的时候，需要将注入的 cookies 清除(只清除app自己注入的cookies，h5 注入的cookies不要清除)。实现Android 的webview 并没有提供针对单个host 清除cookies的方法，只有全部清除，因此主要思路是将需要删除的cookies 设置为过期，再删除过期的即可，具体可以参考Android清除单个域名的cookie","text":"背景在项目中，用户登录后，需要为白名单中的 host 注入特定的cookies，在用户退出登录的时候，需要将注入的 cookies 清除(只清除app自己注入的cookies，h5 注入的cookies不要清除)。实现Android 的webview 并没有提供针对单个host 清除cookies的方法，只有全部清除，因此主要思路是将需要删除的cookies 设置为过期，再删除过期的即可，具体可以参考Android清除单个域名的cookie 当然，设置cookies过期有两种方法: Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; 使用Cookie的: Expires 属性. 它可以设置cookie的过期时间. 下面的代码表示id这条cookie的过期时间是2015年10月21日早上7点28分; Set-Cookie: id=a3fWa; Max-Age=86400 使用Cookie的: Max-Age 属性. 它可以指定从现在开始Cookie存在的秒数. 秒数过完则cookie过期 参考 aisowe 问题但是在清理的时候，发现总是不能清除掉指定cookie，打印出来发现：同一个host，比如 baidu.com ，它的cookie里面有2个key是一样的，但是值不一样，清理的时候，指定host 为baidu.com ，但是只能清除一个，另一个怎么也清理不掉。 这就很奇怪了，能想到的就是可能在多个不同的host下都注入了这个key，于是想办法要把它存储cookies的文件取出来看下。 我们知道，cookies 文件存储在 /data/data//app_webview，文件名是Cookies ，但是这个路径是一个app内部空间，普通情况下是没办法将这个文件获取出来的，除非是在虚拟机或者root过后，安装特定的文件管理器。 解决方案不过我们安装Debug 的包的情况下，可能会有解决办法。因为 PackageManager 会检查 AndroidManifest.xml 中 isDebuggable 是不是false，这个值在我们打包的时候会根据你是打release包还是debug包而是不同的值，debug情况下是 isDebuggable = true，release 情况下是 true。 这样，我们将手机通过Android Studio 安装上debug包，进入shell： adb shell 进入app 空间： run-as 这样就能进入到app的内部空间，当然，也可以参考不root情况下读取data数据 ,此时我们再通过命令： cd app_webview/ 就能进到存放cookies的目录了，通过 ls 命令就能看到 Cookies 这个文件，这个文件是个数据库文件，可以使用sqlite3 打开。此时我们不能直接将其copy到我们电脑上，只能将其复制到我们的 sdcard 中： cp Cookies /sdcard 此时，Cookies 文件已经被赋值到 sdcard，通过两次 exit 命令，就能退出 shell 模式，再通过 adb pull 命令，就能将其复制到电脑上了。 数据分析在命令行打开Cookies 文件： sqlite3 /desktop/Cookies.dump cookies 就能看到cookies的数据了，这时候才发现，原来两个host都注入了这个key的cookie，一个是 baidu.com 一个是 .baidu.com，而后者是h5页面自己注入的，接下来问题就很明了了，将需要清除的cookies 按照前面的方法添加过期时间就ok，再手动执行删除过期cookies的操作，任务就完成了。 该篇文章旨在记录问题解决过程，详细过程这里略过。","categories":[{"name":"问题","slug":"问题","permalink":"https://glassx.gitee.io/categories/%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"问题记录","slug":"问题记录","permalink":"https://glassx.gitee.io/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"第13章：热修复原理","slug":"Android进阶解密-第13章","date":"2020-01-15T14:17:00.000Z","updated":"2020-01-15T14:18:03.828Z","comments":true,"path":"2020/01/15/Android进阶解密-第13章/","link":"","permalink":"https://glassx.gitee.io/2020/01/15/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC13%E7%AB%A0/","excerpt":"热修复框架的核心技术主要有3类：代码修复、资源修复和动态链接库修复。资源修复很多热修复的框架的资源修复参考了Instant Run的资源修复原理，因此我们首先了解下Instant Run 的原理。Instant Run 的资源修复核心逻辑在MonkeyPatcher 的monkeyPatchExistingResources 方法中，如下所示：","text":"热修复框架的核心技术主要有3类：代码修复、资源修复和动态链接库修复。资源修复很多热修复的框架的资源修复参考了Instant Run的资源修复原理，因此我们首先了解下Instant Run 的原理。Instant Run 的资源修复核心逻辑在MonkeyPatcher 的monkeyPatchExistingResources 方法中，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041//com/android/tools/fd/runtime/MonkeyPatcher.javapublic static void monkeyPatchExistingResources(Context context,String externalResourceFile,Collection&lt;Activity&gt; activityes)&#123; ... try&#123; //创建一个新的 AssetManager AssetManager newAssetManager = (newAssetManager)newAssetManager.class.getConstructor(new Class[0]).newInstance(new Object[0]);//1 Method mAddAssetPath = AssetManager.class.getDeclareMethod(\"addAssetPath\",new Class[] &#123;String.class&#125;);//2 mAddAssetPath.setAccessible(true); //通过反射调用 addAssetPath 方法加载外部的资源( SD 卡) if (((Integer) mAddAssetPath.invoke(newAssetManager,new Object[]&#123; externalResourceFile&#125;)).intValue () == 0) &#123;//3 throw new IllegalStateException(\"Could not create new AssetManager\"); if&#123;activities != null)&#123; for (Activity activity : activities) &#123; Resources resources= activity.getResources() ;//4 try &#123; //反射得到 Resources 的 AssetManager 类型的 mAssets 字段 Field mAssets = Resources.class.getDeclareField(\"mAssets\");//5 mAssets.setAccessible(true ); //将 mAssets 字段的引用替换为新创建的 AssetManager mAssets.set(resources,newAssetManager) ;//6 //得到 Activity 的 Resources.Theme Resources.Theme theme = activity.getTheme(); ... //反射得到 Resources.Theme 的 mAssets 字段 Field ma = Resources . Theme.class.getDeclaredField (” mAssets \" ) ; ma.setAccessible(true); //将 Resources.Theme 的 mAssets 字段替换为 newAssetManager ma.set(theme,newAssetManager);//7 &#125; catch (Throwable ignore) &#123; &#125; &#125;&#125; 可以看出，在注释1处创建了一个新的AssetManager，之后通过反射调用 addAssetPath 方法加载外部(SD卡)的资源。在注释4处遍历Activity 列表，得到每个Activity 的Resource ，在5处通过反射得到Resources 的AssetManager 类型的mAsset字段，并在注释6处改写mAssets字段的引用为新的 AssetManager。之后，将AssetManager 类型的mAssets 字段的引用全部替换为新创建的 AssetManager。所以，总共就是两个步骤： 创建新的 AssetManager ,通过反射调用 addAssetPath 方法加载外部的资源,这样新创建的 AssetManager 就含有了外部资源。 将 AssetManager 类型的 rnAssets 字段的引用全部替换为新创建的 AssetManager。 代码修复先写到这，后续有空再来。。。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android进阶解密","slug":"Android进阶解密","permalink":"https://glassx.gitee.io/tags/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/"}]},{"title":"第5章：理解上下文Context","slug":"Android进阶解密-第5章","date":"2019-12-06T11:09:00.000Z","updated":"2020-02-20T13:53:40.204Z","comments":true,"path":"2019/12/06/Android进阶解密-第5章/","link":"","permalink":"https://glassx.gitee.io/2019/12/06/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC5%E7%AB%A0/","excerpt":"Context 的关联类开发中经常使用的Context 的使用场景大体分为两类： 使用Context 调用方法，比如启动 Activity、访问资源、调用系统服务等。 调用方法时传入，比如弹出 Toast、创建dialog。 Activity、Service 与 Application 都间接继承 Context，因此可以说一个应用进程的Context 数量 = Activity 数量 + Service 数量 + 1，这个1就是Application数量。Context 的关联类的关系如下图所示：","text":"Context 的关联类开发中经常使用的Context 的使用场景大体分为两类： 使用Context 调用方法，比如启动 Activity、访问资源、调用系统服务等。 调用方法时传入，比如弹出 Toast、创建dialog。 Activity、Service 与 Application 都间接继承 Context，因此可以说一个应用进程的Context 数量 = Activity 数量 + Service 数量 + 1，这个1就是Application数量。Context 的关联类的关系如下图所示： 可以看出，ContextWrapper 中包含有 Context 类型的 mBase 对象，mBase 具体指向 ContextImpl，此外，ContextThemeWrapper、Service 和 Application 都继承自 ContextWrapper，这样它们都能通过 mBase 来使用Context 的方法。同时它们也是装饰类，在 ContextWrapper 上又添加了不少功能。比如，ContextThemeWrapper 包含了主题相关的方法(getTheme之类)，因此Activity 继承了ContextThemeWrapper，而Service 不需要主题，因此继承 ContextWrapper。Context 关联类的继承结构有以下优点： 使用者能够方便使用Context 的功能。 如果 ContextImpl 发生了变化，它的装饰类 ContextWrapper 无需做任何修改。 ContextImpl 的具体实现不会暴露给使用者。 通过组合而不是继承，拓展 ContextImpl 的功能。运行时选择不同的装饰类，实现不同功能。 Application Context 的创建过程我们通过 getApplicationContext 来获取应用程序的全局 Application Context，那么 Application Context 是如何创建的呢？在应用程序启动完成后，应用程序就有一个全局的 Application Context，那就从应用程序启动过程着手，Application Context 的创建过程时序图如下： 应用程序进程的主线程管理类 ActivityThread 会调用内部类 ApplicationThread 的 scheduleLaunchActivity 方法来启动Activity，而在scheduleLaunchActivity 中会向 H 发送 LAUNCH_ACTIVITY 类型消息，目的是将启动Activity 的逻辑放在主线程中。在 H 的 handleMessage 方法中最终会调用到 LoadApk 类的 makeApplication 方法： 123456789101112131415161718192021222324252627282930//frameworks/base/core/java/android/app/LoadedApk.javapublic Application makeApplication(boolean forceDefaultAppClass,Instrumentation nstrumentation) &#123; if (mApplication != null) &#123;//l return mApplication; &#125; ... Application app = null; String appClass = mApplicationinfo.className; if (forceDefaultAppClass || (appClass == null) ) &#123; appClass = \"android.app.Application”; &#125; try &#123; java.lang.ClassLoader cl= getClassLoader(); if (!mPackageName.equals (\"android\"))&#123; initializeJavaContextClassLoader (); &#125; Contextimpl appContext = Contextimpl.createAppContext(mActivityThread,this); //2 app = mActivityThread.rninstrumentation.newApplication(cl, appClass, appContext);//3 appContext. setOUterContext(app) ;//4 &#125;catch (Exception e)&#123; ... &#125; ... mApplication = app;//5 ... return app;&#125; 注释1处，假设是第一次启动应用程序，因此 mApplication 为null，在注释2处通过 Contextimpl 的 createAppContext 方法创建 Contextimpl 的实例，注释3中创建了 Application 对象，注释4处将 Application 对象赋值给 Contextimpl 的成员变量 mOuterContext ，这样，ContextImpl 中也包含了 Application 的引用。注释5处的 mApplication 即 LoadedApk 的成员变量 mApplication。来看看注释 3 处Application 是如何创建的（最终调用到如下代码的方法）： 1234567//frameworks/base/core/java/android/app/lnstrumentation.javastatic public Application newApplication(xxxx)&#123; Application app = (Application) clazz.newinstance (); app.attach(context) ; //l return app ;&#125; 注释1处通过反射来创建Application，并调用其 attach 方法，并且将 ContextImpl 类型的对象传进去： 1234567891011121314//frameworks/base/core/java/android/app/Application.javafinal void attach(Context context) &#123; attachBaseContext(context); mLoadedApk = Contextimpl.getimpl(context).mPackageinfo;&#125;protected void attachBaseContext(Context base) &#123; if(mBase != null ) &#123; throw new IllegalStateException (\"Base context already set\"); &#125; mBase = base;&#125; 最终，把一路传过来的 ContextImpl 类型的 base 赋值给 Application 的 mBase 。前面讲过，这个歌mBase 是ContextWrapper 的成员变量，因为Application 继承 ContextWrapper ，所以才有这个变量。因此，Application 的attach 方法的作用就是使 Application 可以使用 Context 的方法，这样，Application 才可以用来代表 Application Context。 Application Context 的获取过程我们通过 getApplicationContext 来获取Application Context，这个方法在 ContextWrapper 中实现： 12345//frameworks/base/core/java/android/content/ContextWrapper.javapublic Context getApplicationContext()( return mBase.getApplicationContext( );&#125; 从前面我们可知，mBase 指的是 ComtextImpl，具体代码： 12345//frameworks/base/core/java/android/app/ContextImpl.javapublic Context getApplicationContext () &#123; return (mPackageinfo != null ) ? mPackageinfo.getApplication() : mMainThread.getApplication();&#125; 如果 loadedApk 类型的mPackageinfo 不为 null，则调用其 getApplication 方法，否则调用 ActivityThread 的 getApplication 方法： 12345//frameworks/base/core/java/android/app/LoadedApk.javaApplication getApplication() &#123; return mApplication ;&#125; 这个 mApplication 应该熟悉，是在前面提到的 LoadedApk 的 makeApplication 方法中注释 5 处被赋值的，是个Application 对象。就这样，我们获取到 Application Context。 Activity 的Context 创建过程 应用程序进程的主线程管理类 ActivityThread 会调用内部类 ApplicationThread 的 scheduleLaunchActivity 方法来启动Activity，最终通过 H 类在主线程中处理启动事项，最终调用到 ActivityThread 的 performLaunchActivity 方法： 123456789101112131415161718192021222324//frameworks/base/core/java/android/app/ActivityThread.javaprivate Activity perfomLaunchActivity(ActivityClientRecord r , Intent customintent) &#123; ... ContextImpl appContext = createBaseContextForActivity(r);//l Activity activity = null ; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity(cl , component getClassName() , r.intent) ; //2 ... &#125;catch(Exception e)&#123; ... &#125; try &#123; ... if(activity != null) &#123; appContext.setOuterC nte t(activity) ; //3 //4 activity.attach(xxxx,xxxx); ... &#125;catch(Exception e)&#123; ... &#125; 在注释2处创建了Activity 的实例，注释1处通过 createBaseContextForActivity 方法创建 Activity 的 ContextImpl，并在注释4 处将 ContextImpl 对象传给activity 的attach方法，在注释3处调用了 ContextImpl 的 setOuterContext 方法，将 Activity 的实例赋值给 ContextImpl 的成员变量 mOuterContext ，这样，ContextImpl 也可以访问 Activity 的变量和方法。createBaseContextForActivity 方法中，最终也会调用 ContextWrapper 的 attachBaseContext ，将Activity 中的 ContextImpl 对象赋值给 ContextWrapper 的成员变量 mBase，这样，ContextWrapper 的功能就可以交由 ContextImpl 来处理。 Service 的 Context 创建过程Service 的Context 创建过程与 Activity 的Context 创建过程类似，这里先略过，后续有时间再记录。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android进阶解密","slug":"Android进阶解密","permalink":"https://glassx.gitee.io/tags/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/"}]},{"title":"第12章：理解ClassLoader","slug":"Android进阶解密-第12章","date":"2019-11-28T02:34:00.000Z","updated":"2019-12-03T13:47:10.300Z","comments":true,"path":"2019/11/28/Android进阶解密-第12章/","link":"","permalink":"https://glassx.gitee.io/2019/11/28/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC12%E7%AB%A0/","excerpt":"热修复和插件化是目前比较热门的技术，想要更好地掌握它们需要先了解ClassLoader。从第11章可知，DVM 和 ART 加载的是dex文件，JVM 加载的是class文件，因此它们的类加载器 ClassLoader 是肯定有区别的。Java中的ClassLoader虚拟机章节提到 类加载子系统，它的主要作用就是通过多种类加载器来查找和加载Class文件到Java虚拟机中。Java系统中的类加载器主要包括以下：","text":"热修复和插件化是目前比较热门的技术，想要更好地掌握它们需要先了解ClassLoader。从第11章可知，DVM 和 ART 加载的是dex文件，JVM 加载的是class文件，因此它们的类加载器 ClassLoader 是肯定有区别的。Java中的ClassLoader虚拟机章节提到 类加载子系统，它的主要作用就是通过多种类加载器来查找和加载Class文件到Java虚拟机中。Java系统中的类加载器主要包括以下： Bootstrap ClassLoader(引导类加载器)：C/C++实现的，用于加载指定的JDK核心类库，比如 java.lang、java.uti等系统类。 Extensions ClassLoader(拓展类加载器)： Java中的实现类为 ExtClassLoader ，用于加载Java的拓展类，主要包括 $JAVA_HOME/jre/lib/ext 、java.ext.dir 等目录。 Application ClassLoader(应用程序类加载器)：Java中的实现类为 AppClassLoader，用来加载 1、当前程序的 Classpath 目录 ；2、系统属性 java.class.path指定的目录。 ClassLoader 继承关系以下代码可以验证 运行一个Java程序需要用到哪些类加载器： 123456789public class ClassLoaderTest &#123; public static void main(String[] args)&#123; ClassLoader loader = ClassLoaderTest.class.getClassLoader(); while (loader != null)&#123; System.out.println(loader);//1 loader = loader.getParent(); &#125; &#125;&#125; 上述代码可以获得当前类 ClassLoaderTest 的类加载器，接着打印出当前类加载器的父加载器，直到没有父加载器，打印的结果如： sun misc Launcher AppClassLoader@75b84c92sun .misc .Launcher$ExtClassLoader@lb6d3586 可以看出，加载 ClassLoaderTest 的加载器是 AppClassLoader，并且AppClassLoader 的父加载器是 ExtClassLoader。但是这里没有打印出 ExtClassLoader 的父加载器 Bootstrap ClassLoader ，是因为Bootstrap ClassLoader 由 C/C++ 编写，并不是一个Java类，因此我们无法在Java代码中获取。 双亲委派模型所谓的双亲委派模型就是首先判断该Class是否已经加载，如果未加载，则当前加载器委托父加载器进行查找，这样依次地柜，直到委托到最顶层的 Bootstrap ClassLoader，如果Bootstrap ClassLoader 找到了该Class，就直接返回，否则，依次向下查找，如果当前加载器之上的所有加载器都未能加载，则当前加载器自身去查找。 如果要加载一个位于D盘的Class文件，系统所提供的类加载器就不能满足，这时候需要自定义类加载器 CustomClassLoader 继承java.lang.ClassLoader 并覆写findClass方法，加载D盘的Class文件步骤如下： CustomClassLoader 首先从缓存中查找Class文件是否已经加载，已经加载就返回，没有加载就委托给父加载器(AppClassLoader)。 按照双亲委派模型递归。 一直委托到 Bootstrap ClassLoader ，如果 Bootstrap ClassLoader 也没能加载，则交给子加载器(ExtClassLoader)，以此类推。 综合以上，ClassLoader的父子关系不是使用继承来实现的，二是使用组合来实现代码复用。 双亲委派模型的好处： 避免重复加载。如果Class已经加载过，就不需要加载，二是直接读取。 更加安全。如果不使用双亲委派模型，就可以自定义一个String类来替代系统的String类，显然会造成安全隐患。或者自定义一个Object类，有可能会动摇java基础，因为java里面所有类都要继承java的Object(这段是我自己理解添加的)。采用双亲委派模型似的系统的类在Java虚拟机启动时就被加载，也就无法自定义系统类来替代系统。 自定义类加载器的代码如下： Android 中的ClassLoaderClassLoader 的类型Android中系统类加载器也主要包括3种： BootClassLoader： 由Java代码实现，类的访问修饰符是默认的，只有在同一个包中才能访问，用户无法直接调用。Android系统启动时，会使用BootClassLoader 预加载常用类。 DexClassLoader：可以加在dex文件以及包含dex的压缩文件(apk和jar)，不管加载哪种文件，最终都加载dex文件。 PathClassLoader：Android使用它来加载系统类和应用程序的类，通常用来加载已经安装的apk的dex文件。 ClassLoader的继承关系通过前面用于验证java类继承关系的代码，在这里同样可以验证Android中类加载器的继承关系。 ClassLoader 的加载过程Android 的 ClassLoader 同样遵循了双亲委派模型，ClassLoader 的加载方法为 loadClass方法，这个方法定义在抽象类 ClassLoader中。ClassLoader的查找流程如下图所示： BootClassLoader的创建在ZygoteInit的main方法中，调用了Zygote的 preload 方法，preload方法中又调用了 ZygoteInit 的 preloadClasses 方法，preloadClasses用于预加载常用的类，这个预加载属于拿空间换时间的策略。在preloadClasses方法中会创建 BootClassLoader 。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android进阶解密","slug":"Android进阶解密","permalink":"https://glassx.gitee.io/tags/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/"}]},{"title":"第4章：四大组件的工作过程","slug":"Android进阶解密-第4章","date":"2019-11-25T06:09:00.000Z","updated":"2020-02-09T11:49:06.254Z","comments":true,"path":"2019/11/25/Android进阶解密-第4章/","link":"","permalink":"https://glassx.gitee.io/2019/11/25/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC4%E7%AB%A0/","excerpt":"根Activity的启动过程根Activity 是应用程序第一个Activity，相比普通的Activity的启动过程，一般用根Activity 的启动过程来指代应用程序的启动过程，更具有参考意义。根Activity 的启动过程比较复杂，这里分为3个部分来讲：Launcher 请求AMS 过程、AMS 到ApplicaitonThread 的调用过程 以及 ActivityThread 启动Activity。","text":"根Activity的启动过程根Activity 是应用程序第一个Activity，相比普通的Activity的启动过程，一般用根Activity 的启动过程来指代应用程序的启动过程，更具有参考意义。根Activity 的启动过程比较复杂，这里分为3个部分来讲：Launcher 请求AMS 过程、AMS 到ApplicaitonThread 的调用过程 以及 ActivityThread 启动Activity。 Launcher 请求AMS 过程当我们点击桌面上某个应用的快捷图标时，就会通过Launcher 请求AMS 来启动该应用程序，过程的时序图如下： 点击桌面图标，会调用 Launcher 的startActivitySafely方法： 12345678910111213141516171819// packages/apps/Launcher3/src/com/android/launcher3/Launcher.java public boolean startActivitySafely(View v ,Intent intent, Itemlnfo item)&#123; ... intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); //l try&#123; if (xxxx)&#123; ... &#125;else if(user == null || user.equals(Process.myUserHandle()))&#123; startActivity(intent, optsBundle); //2 &#125;else &#123; ... &#125; return true; &#125; catch (ActivityNotFoundExceptionlSecurityException e) &#123; ... &#125; return false;&#125; 因为是启动新的应用，所以注释1处将根Activity 在新的任务栈启动，应用启动会执行到注释2处的startActivity 方法，最终会在Activity 中调用 startActivityForResult 方法： 123456789// frameworks/base/core/java/and oid/app/Activity.javapublic void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123;//1 options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = minstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToke,this,intent, requestCode , option); &#125; else &#123; ... &#125; 注释1的mParent 是Activity 类型，表示当前Activity 的父类(个人理解，这里应该说是当前Activity的前一个Activity)，因此mParent == null 成立，最后由 Instrumentation 的execStartActivity方法来执行启动操作。 Instrumentation 主要用于监控应用程序和系统的交互。主要代码如下： 12345678910111213// frameworks/base/core/java/android/app/Instrumentation.javapublic ActivityResult execStartActivity(Context who , IBinder contextThread, IBinder token , Activity target, Intent intent ,int requestCode ,Bundle options)&#123;...try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who ); int result = ActivityManager.getService().startActivity(xxx,xxx,xxxx)); checkStartActivityResult(result, intent);&#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e);&#125;return null; 由代码可知，首先通过 ActivityManager 获取 AMS 的代理对象，接着调用代理对象的 startActivity 方法。AMS 的代理对象是一个 IActivityManager(该类由AIDL在工具编译时自动生成的)对象，这个对象封装了 IBinder 类型的 AMS 的引用。通过一系列进程间通信，最终调用 AMS 的 startActivity 方法。 AMS 到 ApplicationThread 的调用过程Launcher 请求进入AMS 后，接着是AMS 到 ApplicationThread 调用流程，时序图如下所示： 在AMS 的startActivity 会使用 startActivityAsUser 实现功能，并获取UserHandle.getCallingUserld() 即 调用者的UserId 作为参数传入。之后，startActivityAsUser 中会判断调用者进程是否被隔离，如果隔离则抛出SecurityException异常；接着，根据UserId 等参数检查调用者权限，如果没权限也抛出 SecurityException 异常。 AMS 中最终调用ActivityStater 的 startActivityLocked 方法，并且如果有 TaskRecord(代表启动的Activity所在的栈)，则将其也作为参数传入；startActivityLocked 中会收集所有逻辑来决定如何将Intent 和Flags 转换为Activity(生成用于描述Activity 的 ActivityRecord 对象)，并且将Activity 与Task 及 Stack 关联。 TaskRecord 用于描述一个 Activity 任务栈，Activity 任务栈其实是一个假想模型，并不真实存在。 最终调用到 ActivityStackSupervisor 的 startSpecificActivityLocked 方法时，会判断要启动的Activity 所在的应用程序进程是否已经运行，已经运行则调用 realStartActivityLocked 方法，并传入代表应用程序进程的 ProcessRecord。之后会调用 ApplicationThread 的 scheduleLaunchActivity 方法。当前代码逻辑运行在AMS所在进程(即SystemServer进程)中，通过 ApplicationThread 进程间通信，将程序执行到应用程序进程，ApplicationThread是AMS 进程与应用程序进程的通信桥梁，如下图所示： ActivityThread 启动Activity 的过程由前面的知识可知，目前的代码逻辑已经运行到应用程序进程中，先查看下ActivityThread 启动Activity 的时序图： ApplicationThread 是 ActivityThread 的内部类，前面讲过应用程序进程创建完成后，会运行代表主线程的实例 ActivityThread 。接着上一节的内容查看 ApplicationThread.scheduleLaunchActivity 方法： 12345678910111213// frameworks/base/core/java/android/app/ActivityThread.javapublic final void scheduleLaunchActivity(xxx,xx,xxx) &#123;//参数太多，这里省略了参数 updateProcessState(procState ,false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident ＝ident; r.intent = intent; r.referrer = referrer; ... updatePendingCoηfiguration (curConfig); sendMessage(H.LAUNCH_ACTIVITY ,r);&#125; 在把启动Activity 必要的数据封装成 ActivityClientRecord 后，通过 sendMessage 方法将封装的数据以 H.LAUNCH_ACTIVITY 类型发送了出去，这里可以大胆地猜测sendMessage方法是通过handler的 sendMessage 执行的，果不其然,sendMessage 有多个重载方法，最终调用到如下代码： 123456789101112// frameworks/base/core/java/android/app/ActivityThread.javaprivate void sendMessage(int what ,Object obj ,int argl ,int arg2 ,boolean async)&#123; Message msg = Message obta (); msg.what = what; msg.ob]= obj; msg.argl = argl; msg.arg2 = arg2; if (async) &#123; msg .setAsynchronous(true); &#125; mH.sendMessage(msg); 这里的mH指的是 ActivityThread 的内部类 H，前面讲过，这个H是集成Handler，是应用进程中主线程的消息管理类，因为ApplicationThread 是一个Binder，它的调用逻辑都运行在Binder 线程池中，所以这里需要使用H将代码的逻辑切换到主线程中。这样一来，我们只需要看 H 的handleMessage 方法即可知道具体的执行操作： 12345678910111213private class H extends Handler &#123; ... public void handleMessage (Message msg ) &#123; switch (msg.what) &#123; case LAUNCH_ACTIVITY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER，\"activityStart\"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj;//1 r.packageinfo = getPackageinfoNoCheck(r.activityinfo.applicationinfo, r.compatlnfo); //2 handleLaunchActivity(r,null ,\"LAUNCH ACTIVITY\"); //3 Trace.traceEnd (Trace . TRACE TAG ACTIVITY MANAGER); break; ... &#125; 在注释1处将传过来的 msg 的成员变量 obj 还原成 ActivityClientRecord，注释2获得LoadApk 类型的对象。应用程序进程要启动Activity时需要将该Activity 所属的APK 加载进来，而LoadApk 就是用来描述已经加载的APK 文件的。注释3处调用 handleLaunchActivity 方法，代码如下： 1234567891011121314151617// frameworks/base/core/java/android/app/ActivityThread.javaprivate void handleLaunchActivity(ActivityClientRecord r ,Intent customintent, String reason) &#123; ... WindowManagerGlobal.initialize (); //启动 Activity Activity a = performLaunchActivity(r, customintent);//1 if(a != null)&#123; ... //将 Activity 的状态置为 Resume handleResumeActivity(r.token, false, r.isForward,!r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);//2 &#125;else&#123; ... //停止 Activity 启动 ActivityManager getServ ce () .finishActivity(r . token , Activity . RESULT CANCELED , null , Activity . DONT_FINISH_TASK_WITH_ACTIVITY) ; &#125;&#125; 注释1处performLaunchActivity 方法启动了 Activity，注释2处将Activity的状态设置为 Resume ，如果该Activity 为null，则会通知AMS 停止启动Activity。我们来看看 performLaunchActivity 方法做了什么： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// frameworks/base/core/java/android/app/ActivityThread.javaprivate Activity performLaunchActivity(ActivityClientRecord r , Intent customintent) &#123; //获取 Activityinfo Activityinfo ainfo = r.activityinfo;//l if (r.packageinfo == null) &#123; //获取 APK 文件的描述类 LoadedApk r.packageinfo = getPackageinfo(ainfo.applicationinfo ,r.compatinfo,Context.CONTEXT_INCLUDE_CODE);//2 &#125; ComponentName component= r.intent.getComponent();//3 ... //创建要启动 Activity 的上下文环境 Contextlmpl appContext = createBaseContextForActivity(r) ; //4 Activity activity = null; try &#123; java.lang .ClassLoader cl= appContext.getClassLoader(); //用类加载器来创建该 Activity 的实例 activity = mInstrumentation newActivity(cl ,component.getClassName() ,r.intent) ;//5 ... &#125; catch (Exception e) &#123; ... &#125; try &#123; //创建 Application Application app = r.packageinfo.makeApplication(false ,minstrumentation); //6 ... if (activity != null) &#123; //初始化Activity，参数太多，省略 activity.attach(....) ; ... if (r.isPersistable()) &#123; minstrumentation.callActivityOnCreate(activity,r.state ,r.persistentState); //8 &#125; else &#123; minstrumentat on callActivityOnCreate(activ ty r .state) ; &#125; ... &#125; r.paused = true ; mActivities.put(r.token,r); &#125; catch (SuperNotCalledException e) &#123; throw e ; &#125;catch (Exception e) &#123; ... &#125; return activity; 注释1处获取 Activityinfo，用于存储AndroidManifest 以及 代码中设置的Activity 和 Receiver 节点的信息，比如Activity 的theme 和launchMode 。注释3中获取要启动的Activity 的 ComponentName 对象，该对象中保存了该Activity 的包名和类名。注释4中启动了Activity的上下文，注释5根据 Activity 的类名，用类加载器创建该 Activity 的实例。之后，注释6中创建了Application ，并且会调用 Application 的 onCreate方法。注释7中调用 Activity 的attach 方法初始化Activity，并且创建Window 对象(PhoneWindow)与Activity 自身关联。注释8中正式启动Activity，并调用Activity 的onCreate 方法。 至此，根Activity 就启动了，即应用程序启动了。 根Activity 启动过程中涉及的进程根Activity 启动过程中涉及的4个进程之间关系如下： 首先Launcher 进程向 AMS 请求创建根 Activity ，AMS 会判断根Activity 所需要的应用程序进程是否存在，不存在就请求 Zygote 进程创建应用程序进程；之后，AMS 请求创建根Activity。上图中步骤 2 采用Socket 通信，步骤 1 和4采用Binder 通信。 读完书本，虽然各个点清晰，但是未能完整总结，以下 桌面点击图标 启动流程总结参考自他人博客 点击桌面图标，Launcher 采用Binder IPC 方式向system_server 发起startActivity 请求。 system_server 进程接收到请求后，向 zygote 进程发送创建进程请求。 zygote 进程fork 出新进程，即App进程。 App 进程通过 Binder IPC 向 system_server 发起 attachApplication 请求。 system_server收到请求做一系列准备后，通过 Binder IPC 向App 进程发送 scheduleLauncherActivity请求。 App 进程的Binder 线程(ApplicationThread)收到请求后，通过Handler 向主线程发送 LAUNCH_ACTIVITY 消息。 主线程收到Message 后，通过反射机制创建目标Activity ，并回调Activity.onCreate 等方法。 至此，App启动，开始Activity 生命周期。 这个过程示意图如下所示： Service 启动过程Service 的启动过程和根Activity 的启动过程有部分相似知识点。Service 的启动过程可以分为两个部分讲解：分别是ContextImpl 到ActivityManageService 的调用过程，以及 ActivityThread 启动 Service。 ContextImpl 到 AMS 的调用过程首先上时序图： 调用startService方法启动service，这个方法在 ContextWrapper 中实现","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android进阶解密","slug":"Android进阶解密","permalink":"https://glassx.gitee.io/tags/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/"}]},{"title":"第3章：应用程序进程启动过程","slug":"Android进阶解密-第3章","date":"2019-11-24T02:22:00.000Z","updated":"2019-12-03T13:29:50.034Z","comments":true,"path":"2019/11/24/Android进阶解密-第3章/","link":"","permalink":"https://glassx.gitee.io/2019/11/24/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC3%E7%AB%A0/","excerpt":"AMS启动一个应用程序首先要保证该应用程序的进程已经启动，如果应用程序进程还不存在，则请求 Zygote 进程启动进程。从前一章内容可知，在Zygote 的Java 框架层会创建Server 端的Socket，用于等待AMS 请求Zygote 创建新的应用程序进程。Zygote 通过fork自身即可创建应用程序进程，这个进程会包含虚拟机实例，并且会创建Binder线程池和消息循环。","text":"AMS启动一个应用程序首先要保证该应用程序的进程已经启动，如果应用程序进程还不存在，则请求 Zygote 进程启动进程。从前一章内容可知，在Zygote 的Java 框架层会创建Server 端的Socket，用于等待AMS 请求Zygote 创建新的应用程序进程。Zygote 通过fork自身即可创建应用程序进程，这个进程会包含虚拟机实例，并且会创建Binder线程池和消息循环。 本章学习应用程序进程的启动，注意，是应用程序进程而不是应用程序的启动过程。 应用程序进程启动过程介绍 AMS 通过调用 startProcessLocked 向 Zygote 进程发送请求， 主要代码如下： 12345678910111213141516171819202122232425private final void startProcessLocked(ProcessRecord app, String hostingType,String hostingNameStr, String abiOverride ,String entryPoint ,String [] entryPointArgs) &#123; ... //获取要创建的应用程序进程的用户 ID int uid = app.uid; //1 int [] gids = null; if (!app.isolated) &#123; //2 gids创建和赋值 if (ArrayUtils isEmpty(permGids))&#123; gids =new int[3]; &#125;else &#123; gids = new int[permGids.leng + 3] ; System.arraycopy(permGids, 0, gids, 3, permGids.length) ; gids[O] = UserHandle.getSharedAppGid(UserHandle.getAppid(uid)); gids[1] = UserHandle.getCacheAppGid(UserHandle .getAppid(uid)) ; gids[2] = UserHandle.getUserGid&#123;UserHandle.getUserid(uid)); &#125; ... if (entryPoint = null) entryPoint = \"android.app.ActivityThread\";//3 ... //启动应用程序进程,这里省略不重要的参数 startResult = Process.start(entryPoint,xxx,uid, xxx,gids,xxx,xxx); 上述代码首先得到应用程序进程的用户ID，之后创建用户组ID 并且赋值，在注释3处判断 entryPoint 为null就赋值 “android.app.ActivityThread”，这个值就是应用程序进程主线程的类名。在最终调用 Process.start 创建进程时，会将进程的用户ID和用户组ID传入。 Process.start会将实现交给 ZygoteProcess(ZygoteProcess用于保持与Zygote进程的通信状态)的start 方法处理，其中首先会执行 openZygoteSocketifNeeded 方法，代码如下： 1234567891011121314151617181920212223242526...if (primaryZygoteState == null || primaryZygoteState.isClosed ()) &#123; try &#123; //与 Zygote 进程建立 Socket 连接 primaryZygoteState = ZygoteState.connect(mSocket);//1&#125; catch (IOException ioe&#125; &#123; throw new ZygoteStartFailedEx (\"Error connecting to primary zygote\"， ioe)&#125;//连接 Zygote 主模式返回的 ZygoteState 是否与启动应用程序进程所需要的ABI匹配if (primaryZygotestate.matches (abi)) &#123;//2 return primaryZygoteState;&#125; ／／如果不匹配，则尝试连接 Zygote 辅模式if (secondaryZygoteState ==null || secondaryZygoteState.isClosed()) &#123; try &#123; secondaryZygoteState = ZygoteState.connect(mSecondarySocket);//3&#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx (\"Error connecting to secondary zygote\", ioe) ; &#125;／／连接 Zygote 辅模式返回的 ZygoteState 是否与启动应用程序进程所需要的 ABI 匹配if (secondaryZygoteState.matches(abi)) &#123;//4 return secondaryZygoteState; &#125;throw new ZygoteStartFailedEx (\"Unsupported zygote ABI :\" + abi); 前面章节提到Zygote的main方法中会创建name为 “zygote” 的server端Socket，注释1就是与Zygote进程建立Socket 连接(name为”zygote”)，并得到 ZygoteState 对象primaryZygoteState；注释2处如果primaryZygoteState 与启动应用程序所需要的 ABI 不匹配，则在注释3处连接name为 “zygote_secondary” 的Socket。如果辅模式返回的 ZygoteState 与进程所需的ABI也不匹配，就抛出异常。 通过 openZygoteSocketifNeeded 获取ZygoteState后，将其作为参数调用 ZygoteProcess的 ZygoteSendArgsAndGetResult 方法 获取Process.ProcessStartResult。 Zygote 接收请求并创建应用程序进程执行完以上步骤后，继续执行 argsForZygote 方法即可让Zygote 收到创建新的应用程序进程的请求。Zygote 接收请求并创建应用程序进程的时序图如下： 由前面章节我们知道，Zygote 中的Server Socket 的runSelectLoop 方法一直在等待 AMS请求创建新的应用程序进程，runSelectLoop 中是通过 runOnce 来创建进程的，runOnce最终调用到 Zygote 的 forkAndSpecialize 方法创建应用程序进程，并返回pid。forkAndSpecialize 通过fork 当前进程来创建一个子进程。此后，便会在应用程序进程中创建 Binder 线程池，*进一步通过反射 ActivityThread 类的main方法调用，令应用程序进程进入了ActivityThread 的main方法中。此时，应用程序进程创建完毕，并且运行了主线程管理类 ActivityThread *。 如果pid为0，说明当前代码运行在新创建的子进程中。 Binder 线程池启动过程程序中会检查代码，确保Binder线程池只会被启动一次。 消息循环创建过程通过反射方式 invok 执行 ActivityThread 的main方法时，会执行一系列主线程的工作，代码如下： 123456789101112131415161718//frameworks/base/core/java/android/app/ActivityThread.java public static void main(String[] args) &#123; ... //创建主线程 Looper Looper.prepareMainLooper(); //1 ActivityThread thread= new ActivityThread(); //2 thread.attach(false) ; if (sMainThreadHandler == null ) &#123;//3 //创建主线程 H 类 sMainThreadHandler = thread . getHandler ();//4 if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\"）； Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER) ; //Looper 开始工作 Looper.loop (); //5 throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; ActivityThread类用于管理当前应用程序进程的主线程，上述代码中创建了主线程的消息循环Looper，其中的内部类 H 继承 Handler，在注释 5 处调用Looper.loop ，即使得Looper 开始处理消息，可见，系统在应用程序进程启动完成后，就会创建消息循环。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android进阶解密","slug":"Android进阶解密","permalink":"https://glassx.gitee.io/tags/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/"}]},{"title":"面试题-设计模式","slug":"面试题-设计模式","date":"2019-11-23T13:40:00.000Z","updated":"2020-04-23T13:31:27.405Z","comments":true,"path":"2019/11/23/面试题-设计模式/","link":"","permalink":"https://glassx.gitee.io/2019/11/23/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"mvc、mvp、mvvm 点击看答案 mvc 特征： view 接收用户的输入，并且可以通知Controller 更改Model 层数据，如果没有涉及逻辑，还可以直接通知Model 更改数据。 需要ui变化，但是没有涉及业务数据，直接调用controller 即可(比如用户选择使用用户名/手机号登录) model 数据变化时，若需要修改ui，需要通过Controller 来通知更新。 在Android中存在问题： Activity 的职责不明，并且臃肿。Activity 除了要展示view (加载view，接收用户操作)，还要承担部分逻辑处理(比如生命周期回调) mvp 特点: View 层接收输入 Presenter 处理业务逻辑，View 与 Model 之间必须经过 Presenter 优点(相对MVC)： 避免了View、Model 直接联系，更加解耦，通过Presenter 实现两者之间的沟通 Activity 更加简明，仅仅负责UI上的工作 mvvm 可能主要关注view 通过databinding 与 viewmodel 相互绑定。 mvc 与 mvp 的区别 在mvc 中 Activity 具有 view 的功能，并且兼任部分 controller 功能，而mvp 中Activity 是纯粹的view mvc 中view 和model 可以直接沟通(没有逻辑情况下，view直接更改model，当然，有逻辑改动的情况下经过controller)，而mvp中二者沟通必须经过presenter。","text":"mvc、mvp、mvvm 点击看答案 mvc 特征： view 接收用户的输入，并且可以通知Controller 更改Model 层数据，如果没有涉及逻辑，还可以直接通知Model 更改数据。 需要ui变化，但是没有涉及业务数据，直接调用controller 即可(比如用户选择使用用户名/手机号登录) model 数据变化时，若需要修改ui，需要通过Controller 来通知更新。 在Android中存在问题： Activity 的职责不明，并且臃肿。Activity 除了要展示view (加载view，接收用户操作)，还要承担部分逻辑处理(比如生命周期回调) mvp 特点: View 层接收输入 Presenter 处理业务逻辑，View 与 Model 之间必须经过 Presenter 优点(相对MVC)： 避免了View、Model 直接联系，更加解耦，通过Presenter 实现两者之间的沟通 Activity 更加简明，仅仅负责UI上的工作 mvvm 可能主要关注view 通过databinding 与 viewmodel 相互绑定。 mvc 与 mvp 的区别 在mvc 中 Activity 具有 view 的功能，并且兼任部分 controller 功能，而mvp 中Activity 是纯粹的view mvc 中view 和model 可以直接沟通(没有逻辑情况下，view直接更改model，当然，有逻辑改动的情况下经过controller)，而mvp中二者沟通必须经过presenter。 以上内容参考自carson_ho的博客 实现一个线程安全的单例模式观察者模式和回调有什么区别？","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题-虚拟机知识","slug":"面试题-虚拟机","date":"2019-11-23T13:40:00.000Z","updated":"2020-07-12T01:50:33.246Z","comments":true,"path":"2019/11/23/面试题-虚拟机/","link":"","permalink":"https://glassx.gitee.io/2019/11/23/%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%99%9A%E6%8B%9F%E6%9C%BA/","excerpt":"1、对象的内存布局 点击看答案 分为3个区域：对象头、实例数据 以及 对齐填充 对象头：包括两部分信息，第一部分：对象自身运行时数据，如hashcode、GC年龄分代、锁状态标志位，官方称为”Mark Word”。第二部分：类型指针，虚拟机通过这个指针确定对象是哪个类的实例。 实例数据：对象真正存储的有效信息。 对齐填充：比如HotSpot vm 要求对象起始地址必须是8的整数倍。对齐填充不是必需的。 以下是句柄访问 时，内存布局关系图： 以上内容参考自： 对象创建与定位","text":"1、对象的内存布局 点击看答案 分为3个区域：对象头、实例数据 以及 对齐填充 对象头：包括两部分信息，第一部分：对象自身运行时数据，如hashcode、GC年龄分代、锁状态标志位，官方称为”Mark Word”。第二部分：类型指针，虚拟机通过这个指针确定对象是哪个类的实例。 实例数据：对象真正存储的有效信息。 对齐填充：比如HotSpot vm 要求对象起始地址必须是8的整数倍。对齐填充不是必需的。 以下是句柄访问 时，内存布局关系图： 以上内容参考自： 对象创建与定位 2、垃圾收集算法 点击看答案 标记-清除 算法。不足：1、标记清除效率不高。2、产生内存碎片。 复制算法。为了解决标记清除的效率问题，将内存划分为大小相等的两块，每次使用一块。不足：可用内存缩小为原来一半。 标记-整理。不足：复制存货对象耗时过多。 分代收集算法。 新生代使用复制算法；老年代采用“标记-清除” 或者 “标记-整理”算法。 以上内容参考自： 垃圾回收算法 3、说说四大引用？强，软，弱，虚，并说明下合适GC 点击看答案 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。 软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，只有在内存不足的时候 JVM 才会回收该对象。这一点可以很好地用来解决 OOM 的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。 “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。要注意的是，虚引用必须和引用队列关联使用. 4、Android中内存分配的执行流程 点击看答案 铺垫Dalvik 虚拟机的Java堆的底层实现是一块共享匿名内存(Ashmem)，并且将其抽象为C库的一个 mspace ，于是，Dalvik 虚拟机就可以利用 C 库里面的 dlmalloc 内存分配器来解决内存碎片问题(这是个成熟的内存分配器，可以很好地解决内存碎片的问题) Android中内存分配的执行流程：流程图如下： 尝试在Java堆上分配指定大小的内存，如果内存充足，就直接分配成功。(不改变java堆当前大小的前提下进行内存分配，属于轻量级的内存分配) 如果分配失败，就执行一次GC(如果此时有GC在运行，则等待这次GC执行完成)，GC 时设置参数false标记不要回收软引用的对象。 GC 完成后，再次尝试轻量级内存分配操作，如果内存充足，就分配成功了 如果上一步内存分配失败，就考虑将Java堆的当前大小设置为Dalvik 虚拟机启动时指定的Java堆最大值，再进行内存分配 如果内存充足，就完成内存的分配 如果上一步还是分配失败，就再次调用GC，并将参数标记为true，表示要回收软引用的对象 GC完毕后，再次尝试分配，成功就返回；不成功也就抛出OOM了 以上内容参考自：老罗的博客 5、Android GC 流程Art 虚拟机GC过程 点击看答案 由图可知，非并行GC的过程如下所示： 挂起所有的ART运行时线程。 调用子类实现的成员函数MarkingPhase执行GC标记阶段。 调用子类实现的成员函数ReclaimPhase执行GC回收阶段。 恢复第2步挂起的ART运行时线程。 并行GC的过程如下所示： 获取用于访问Java堆的锁。 调用子类实现的成员函数MarkingPhase执行GC并行标记阶段。 释放用于访问Java堆的锁。 挂起所有的ART运行时线程。 调用子类实现的成员函数HandleDirtyObjectsPhase处理在GC并行标记阶段被修改的对象。。 恢复第4步挂起的ART运行时线程。 重复第5到第7步，直到所有在GC并行阶段被修改的对象都处理完成。 获取用于访问Java堆的锁。 调用子类实现的成员函数ReclaimPhase执行GC回收阶段。 释放用于访问Java堆的锁。 从上面的分析就可以看出，并行GC和非并行GC的区别在于： 非并行GC的标记阶段和回收阶段是在挂住所有的ART运行时线程的前提下进行的，因此，只需要执行一次标记。 并行GC的标记阶段只锁住了Java堆，因此它不能阻止那些不是正在分配对象的ART运行时线程同时运行，而这些同进运行的ART运行时线程可能会引用了一些在之前的标记阶段没有被标记的对象。如果不对这些对象进行重新标记的话，那么就会导致它们被GC回收，造成错误。因此，与非并行GC相比，并行GC多了一个处理脏对象的阶段。所谓的脏对象就是我们前面说的在GC标记阶段同时运行的ART运行时线程访问或者修改过的对象。 并行GC并不是自始至终都是并行的，例如，处理脏对象的阶段就是需要挂起除GC线程以外的其它ART运行时线程，这样才可以保证标记阶段可以结束。 Dalvik 虚拟机垃圾收集过程 点击看答案 Dalvik 虚拟机使用 Mark-Sweep 算法来进行垃圾收集Dalvik 执行GC 时会有一些选项： isPartial，为true 时，表示仅仅回收Active 堆的垃圾；为false时，表示同时回收Active 堆和Zygote 堆的垃圾 isConcurrent：为true时，表示执行并行GC，false时，表示非并行GC doPreserve：为true的时候，表示不回收软引用的对象；false的时候，表示回收软引用对象Dalvik在如下几种情况会触发GC： 分配对象时，内存不足触发GC 已经分配的内存达到一定阈值时触发GC 调用 System.gc 、VMRuntime.gc 或者收到信号触发 GC 准备抛出 OOM 前而最后进行的 GCGC线程在空闲达到一定时间后，会调用函数对Java堆进行裁剪，将一些没有用到的内存交还给内核。dalvik 的GC 流程(并行和非并行情况)如下图所示： 哪些对象可以做 GC Root 虚拟机栈引用的对象 本地方法栈引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 Dalvik 虚拟机内部创建的部分异常对象 Dalvik 虚拟机内部创建的原子类 注册在调试器的对象 以上内容参考自以上内容参考自 罗升阳的博客 、 老罗的博客 6、如何理解Java类加载机制","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"第11章：Dalvik 和 ART","slug":"Android进阶解密-第11章","date":"2019-11-23T02:30:00.000Z","updated":"2019-11-23T03:00:25.777Z","comments":true,"path":"2019/11/23/Android进阶解密-第11章/","link":"","permalink":"https://glassx.gitee.io/2019/11/23/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC11%E7%AB%A0/","excerpt":"Dalvik虚拟机Dalvik虚拟机 简称 DVM，第10章提到，它不是一个 jvm，主要原因是它没有遵循jvm规范实现，二者的主要区别有： 基于的架构不同 JVM 基于栈，DVM 基于寄存器。基于栈意味着需要去栈中读写数据，所需要的指令更多，并且速度更慢，对于性能优先的移动设备，显然是不合适的。","text":"Dalvik虚拟机Dalvik虚拟机 简称 DVM，第10章提到，它不是一个 jvm，主要原因是它没有遵循jvm规范实现，二者的主要区别有： 基于的架构不同 JVM 基于栈，DVM 基于寄存器。基于栈意味着需要去栈中读写数据，所需要的指令更多，并且速度更慢，对于性能优先的移动设备，显然是不合适的。 执行的字节码不同 在Java SE 程序中，Java 类被编译成一个或者多个.class 文件，并被打包成 jar 文件，之后JVM 会通过相应的 .class 和 jar 文件获取相应的字节码；而DVM 会用dx工具将所有的 .class 文件转换为一个 .dex 文件，然后DVM 从该 .dex 文件中读取指令和数据。.jar文件里面包含多个.class 文件，每个.class文件包含了该类的常量池、类信息、属性等，当JVM 加载.jar文件的时候，会加载里面所有的.class文件，JVM 这种加载方式很慢(首先就是很多io操作)，对于内存有限的移动设备并不合适；而.dex文件将所有的.class里面所包含的信息全部整合到一块了，这样再加载就减少了I/O操作，加快查找速度；并且，相对Android而言，.class中有许多冗余信息，dex工具会去掉冗余信息。 DVM 允许在有限的内存中同时运行多个进程 在Android中，每个应用都运行在一个DVM中，每个DVM 实例都运行在一个独立的进程中，这样，某一个虚拟机崩溃的时候不会导致其他app也关闭。 DVM 由Zygote创建和初始化 在第2章有介绍Zygote，它是一个DVM进程，当系统需要创建一个应用程序时，Zygote就会fork自身，快速地创建和初始化一个DVM实例。对于一些只读的库，所有的DVM实例都会和Zygote共享一块内存区域，节省内存开销。 DVM 有共享机制 DVM 的共享机制可以使不同应用之间在运行时可以共享相同的类，这带来更高的效率；而JVM不具有这种机制，不同的程序，打包以后的程序都是彼此独立的，即便它们在包里使用了同样的类，运行时也是单独加载和运行的。 DVM 运行时堆DVM运行时堆使用标记-清除算法进行GC，它由两个Space以及多个辅助数据结构组成，两个Space分别是：Zygote Space(Zygote Heap) 和 Allocation Space(Active Heap)，前者用于管理Zygote进程在启动过程中预加载和创建的对象，并且Zygote Space不会触发GC，Zygote 进程和应用进程之间会共享Zygote Space。在Zygote 进程fork第一个子进程前，会把Zygote Space 分为两部分，原来已经被使用的部分对仍旧叫做Zygote Space，而未使用的那部分堆叫做 Allocation Space ，以后的对象都会在 Allocation Space上进行分配和释放。 ART虚拟机Android 4.4 的时候发布了ART虚拟机，但是4.4版本默认还是使用DVM，Android 5.0 及以后版本默认采用ART，从此，DVM退出历史舞台。 ART 与 Dalvik 区别ART 与 Dalvik 的区别主要有4点： DVM 是为32位CPU涉及的，而ART支持64位并且兼容32位 CPU。 ART 对垃圾回收机制进行了改进，将 GC 暂停由2次减少为1次，并且频繁执行并行垃圾收集。 ART 的运行时堆空间划分和DVM不同。 DVM中应用每次运行时，字节码通过 JIT 编译器编译为机器码，使得应用程序运行效率低下；而在ART中，系统在安装应用程序时会进行一次AOT(ahead of time compilation,预编译)，将字节码预先编译成机器码并存储在本地，这样应用程序每次运行时就不需要执行编译了。 ART也有两个主要缺点：一是AOT使应用安装时间变长，二是预编译的机器码占用的存储空间比较大。为了解决上面的缺点，Android 7.0 版本在ART中加入了JIT编译器，作为AOT的补充：在安装应用时不会将字节码全部编译成机器码，而是在运行中将热点代码编译器机器码，以达到缩短应用安装时间并节省存储空间。 更详细的内容，可以参考官网上的描述 ART 运行时堆与DVM 的GC不同的是，ART采用多种垃圾收集方案，每个方案会运行不同的垃圾收集器，默认是采用 CMS(Concurrent Mark-Sweep)方案，主要有sticky-CMS 和 partial-CMS，不同的CMS方案，ART运行时堆得空间划分也不同，默认由4个Space和多个辅助结构组成，采用标记-清除算法时，两种虚拟机运行时堆对比图如下： 由图可以看到ART的4个Space，其中，Zygote Space 、Allocation Space 和 DVM 中的作用一样，ImageSpace 用来存放一些预加载类，Large Object Space 用来分配一些大对象。其中Zygote Space 与 Image Space 是进程共享的。 ART 的GC 日志 GC ReasonART 虚拟机GC日志中会包含产生这次GC原因，主要会有： Concurrent: 并发GC，在后台线程运行GC，不会使App的线程暂停，不会阻止内存分配。 Alloc： 当堆内存已满，App尝试分配内存而引起的GC，这个GC发生在正在分配内存的线程中。 Explicit： App显式请求垃圾收集，比如 System.gc()。 NativeAlloc： Native 内存分配时触发的GC。 垃圾收集器名称ART 虚拟机GC日志中会包含所使用的收集器名称，主要会有： Concurrent Mark Sweep(CMS)： 它是以最短收集暂停时间为目标的收集器，采用标记-清除算法，能释放除了Image Space外的所有空间 Concurrent Partial Mark Sweep： 能释放除了Image Space 和 Zygote space 意外的所有空间 Concurrent Sticky Mark Sweep： 粘性收集器，基于分代的垃圾收集思想，只能释放自上次GC以来分配的对象，这个收集器扫描比较频繁，因为它很快并有很短的暂停时间。 Marksweep + Semispace：非并发GC，复制GC用于堆转换以及堆碎片整理。 DVM 和 ART 的诞生它们是从Zygote进程诞生的，这样，Zygote进程就持有了DVM或者ART的实例，此后，Zygote进程每次fork自身创建新的应用进程时，应用程序进程也就得到了 DVM 或者ART 的实例，即每个应用进程都有一个单独的虚拟机实例。这样做的好处是，无需在每次启动应用程序进程时都要创建DVM或者ART，从而加快了应用程序进程的启动速度。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android进阶解密","slug":"Android进阶解密","permalink":"https://glassx.gitee.io/tags/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/"}]},{"title":"第2章：Android系统启动","slug":"Android进阶解密-第2章","date":"2019-11-22T07:10:00.000Z","updated":"2019-12-03T13:22:20.830Z","comments":true,"path":"2019/11/22/Android进阶解密-第2章/","link":"","permalink":"https://glassx.gitee.io/2019/11/22/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC2%E7%AB%A0/","excerpt":"init 进程启动过程init进程是Android系统中用户空间的第一个进程，进程号为1，它被赋予了很多重要职责，比如创建 Zygote 和属性服务等。引入init进程了解Android系统启动流程的前几步，可以有助于引入init进程： 启动电源以及系统启动。当电源按下时，引导芯片代码从预定义的地方(固化在ROM中)开始执行，加载引导程序到RAM中，然后执行。 引导程序BootLoader。它是Android操作系统开始运行前的一个小程序，主要作用是把系统OS拉起来。 Linux 内核启动。linux内核启动完成系统设置后，它首先在系统文件中寻找init.rc，并启动init进程。 init进程启动。init进程的工作比较多，主要用于初始化、启动属性服务 以及 启动Zygote进程。","text":"init 进程启动过程init进程是Android系统中用户空间的第一个进程，进程号为1，它被赋予了很多重要职责，比如创建 Zygote 和属性服务等。引入init进程了解Android系统启动流程的前几步，可以有助于引入init进程： 启动电源以及系统启动。当电源按下时，引导芯片代码从预定义的地方(固化在ROM中)开始执行，加载引导程序到RAM中，然后执行。 引导程序BootLoader。它是Android操作系统开始运行前的一个小程序，主要作用是把系统OS拉起来。 Linux 内核启动。linux内核启动完成系统设置后，它首先在系统文件中寻找init.rc，并启动init进程。 init进程启动。init进程的工作比较多，主要用于初始化、启动属性服务 以及 启动Zygote进程。 init进程入口在Linux内核加载完成后，首先在系统文件中查找init.rc，并启动init进程。init的main函数中做了很多事情，我们主要了解以下几点： 调用property_init 函数对属性初始化，调用 start_property_service函数启动属性服务。 调用 signal_handler_init 设置子进程信号处理函数，主要用于防止init进程的子进程成为僵尸进程。为了防止僵尸进程的出现，系统会在子进程暂停和终止的时候发出 SIGCHLD信号，signal_handler_init就是用来接收这个信号的。 僵尸进程：在linux中，父进程使用fork创建子线程，在子线程终止后，如果父进程并不知道子线程终止了，那么还会在系统进程表为它保留一定的信息。僵尸进程主要危害就是占用系统进程表，可能导致系统进程表被耗尽而无法创建新的进程。假设init的子进程Zygote终止了，signal_handler_init 函数会找到Zygote进程并移除所有Zygote进程信息，再重启Zygote。 解析 init.rcinit.rc 是一个配置文，是由Android 初始化语言编写的脚本，为了分析如何创建Zygote，我们主要查看其中的Service类型语句，在Android 8.0 及以后，每个Service 都对应一个rc 文件。init.rc 中定义Service 的格式如下： service [ ] * //&lt;service 的名字〉〈执行程序路径〉〈传递参数〉 举个栗子，zygote的Service配置文件就是： 12345service zygote /system/bin/app_process64 -Xzygote /system/bin -- zygote --start\u0002system- server class main priority -20 user root group root readproc 来大概分析代码意思，Service用于通知 init 进程创建名为 zygote 的进程，这个进程执行程序的路径为 /system/bin/app_process64，其中 class main指的是Zygote 的classname 为 main。后面的代码是要传给 app_process64的参数。 解析Service类型语句init.rc中Service类型语句使用ServiceParser类来解析，它将init.rc中的service解析生成的Service对象加入到 Service 链表中。 init 启动Zygote我们来了解init是如何启动Service的，这里主要讲解 Zygote这个Service。前面提到，在Zygote的启动脚本中描述Zygote的classname为main，在init.rc中会遍历 解析Service类型语句 过程生成的Service链表，找到 classname 为main的Zygote，如果Zygote Service 已经运行，则不再启动，否则就调用fork函数创建子进程，并在子进程中调用Service的main函数，Zygote的main函数代码如下： 123456789101112int main （int argc, char* const argv []) &#123; if (zygote) &#123; runtime.start （\"com.android.internal.os.Zygoteinit”， args, zygote) ; //1 &#125; else if (className) &#123; runtime .start （” com android nternal.os.Runtimeinit ”， args zygote) ; &#125; else&#123; ... &#125;&#125;... 从注释1处可以看到调用runtime的start函数启动了 Zygote 。 属性服务Windows上有注册表管理器以键值对的形式记录用户软件的一些使用信息，即使系统或者软件重启，其还是能够根据之前注册表中的记录进行相应初始化工作。Android中也提供了类似机制，叫做属性服务。init 进程启动时会启动属性服务，并为其分配内存存储这些属性，如果需要这些属性直接读取即可。启动属性服务的主要代码如下： 12345...property_set_fd =create_socket(PROP_SERVICE_NAME ,SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,0666, 0, 0, NULL); //1...listen(property_set_fd, 8); //2 register_epoll_handler(property_set_fd , handle_property_set_fd) ; //3 由代码可知，首先创建非阻塞的Socket，并对property_set_fd 监听，这样创建的Socket 就成为server，也就是属性服务；listener的参数意味着可以同时为8个试图设置属性的用户服务。最后使用epoll 来监听property_set_fd ：当property_set_fd中有数据到来时，init进程将调用handle_property_set_fd函数处理。 epoll是linux下多路复用I/O接口，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU的利用率。 对属性进行修改时，首先判断属性的合法性，之后查找属性，如果属性存在就更新属性值，否则添加属性。 init进程启动总结主要做了3件事：1、创建和挂载启动所需文件目录 2、启动服务属性 3、解析init.rc ，并启动 Zygote 进程。 Zygote进程启动过程在Android系统中，DVM(或者ART)、应用程序进程、SystemServer进程等都是由Zygote进程创建的。由于Zygote在启动时会创建 DVM(或者ART)，因此其fork的应用程序进程和SystemServer进程可以在内部获取一个 DVM 或者 ART。 在Zygote 中通过 JNI 调用 ZygoteInit(ZygoteInit是由Java编写的)的 main 方法后，Zygote 便进入了Java 框架层，此前没有任何代码进入Java框架层的。即Zygote开创了Java框架层。 ZygoteInit的main方法中主要代码如下： 1234567891011121314151617//frameworks/base/core/java/com/android/internal/os/Zygotelnit.java ...//创建一个 Server 端的 Socket socketName 的值为\"zygote\"zygoteServer.registerServerSocket(socketName);...//预加载类和资源preload(b otT U.ngsTraceLog);...if (startSystemServer) &#123; //启动 SystemServer 进程 startSystermServer(abiList, socketName, zygoteServer);&#125;／／等待 AMS 请求zygoteServer.runSelectLoop(abiList); 由代码可知，通过 registerServerSocket 方法创建一个Server端的Socket ，这个名为 “zygote” 的Socket 用于等待 ActivityManagerService 请求 Zygote 来创建新的应用程序进程。总结一下，ZygoteInit 的main方法总共做了4件事： 创建一个Server端的Socket 预加载类和资源 启动 SystemServer 进程 等待 AMS 请求创建新的应用程序进程 Zygote 进程启动总结Zygote进程启动共做了以下几件事： 创建AppRuntime ，并调用其start方法，启动Zygote 进程 创建java虚拟机并未Java虚拟机注册 JNI 方法 通过 JNI 调用ZygoteInit 的main函数进入Zygote 的Java 框架层 通过 registerServerSocket 创建服务端 Socket ，循环等待AMS 请求来创建新的应用程序进程。 启动 SystemServer SystemServer 处理过程SystemServer 进程主要用于创建系统服务，如 AMS、WMS、PMS 。在 ZygoteInit.java 中启动了 SystemServer，代码如下： 1234567891011private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException｛ //当前运行在 SystemServer 进程中 if (p == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote (socketName ); &#125; //关闭 Zygote 进程创建的 Socket zygoteServer . closeServerSocket() ; //1 handleSystemServerProcess(parsedArgs) ; //2 &#125; return true; 由以上代码可知，SystemServer 进程复制了 Zygote 进程的地址空间，因此也会得到Zygote 创建的 server Socket，这个socket对SystemServer 没有用处，因此在代码 1处将其关闭，之后通过 handleSystemServerProcess 方法启动 SystemServer 进程。接下来，在ZygoteInit中创建了 PathClassLoader，并且通过native 方法 ZygoteInit.nativeZygotelnit 启动了Binder线程池，之后进入 SystemServer 的main 方法。 SystemServer 的run 方法中用 SystemServiceManager 启动了 ActivityManagerService、 PackageManagerService 等服务。在PackageManagerService 创建完成后，将其注册到 ServiceManager 中，ServiceManager 用于管理系统中各种Service，用于系统C/S 架构中的Binder 通信机制：Client端要使用某个Service，需要先到 ServiceManager 中查询Service 的相关信息，然后与Service 所在的Server 进程建立通信通路，这样Client就可以使用Service 了。 SystemServer 进程总结SystemServer 进程被创建后，主要工作： 启动Binder 线程池，这样可以与其他进程通信。 创建 SystemServiceManager，创建和管理系统服务 启动各种服务 Launcher 启动过程系统启动的最后一步是启动一个应用程序来显示系统中已经安装的应用程序，即 Launcher。Launcher 在启动过程中请求 PackageManagerService 获取系统中已经安装的应用程序信息，并且将信息封装成一个个快捷图标列表显示在系统屏幕上，用户就可以通过点击图标来启动相应的应用程序了。Launcher 的启动过程时序图如下： 启动Launcher的入口方法为AMS 的systemReady 方法，该方法在SystemServer 的startOtherService中被调用，之后调用 ActivityStack 的resumeTopActivityUncheckedLocked 方法，ActivityStack 用于描述Activity 栈的。最终调用到 AMS 的 startHomeActivityLocked 方法，在该方法中，创建了 Launcher 启动所需的 Intent，并且在一系列判断后，将该Intent 的 Action 设置为 Intent.ACTION_MAIN 、Category 为 Intent.CATEGORY_HOME，并且在 Launcher 的AndroidManifest 中也是这么配置的。 经过以上操作，com.android.launcher3.Launcher 的Activity 就成为了主 Activity，此时，如果Launcher 还未启动，AMS 就会调用 ActivityStarter 的 startHomeActivityLocked 来启动 Launcher 。 Android系统启动流程结合前面几节内容，可以总结出Android系统启动流程： 启动电源以及系统启动 按下电源键，从预定义地方开始执行，加载BootLoader 到RAM。 引导程序BootLoader 主要作用是拉起系统OS。 Linux 内核启动 内核启动，设置缓存、计划表、加载驱动等，之后寻找 init.rc 文件，并启动init 进程。 init 进程启动 初始化和启动属性服务，并启动 Zygote 进程。 Zygote进程启动 创建Java虚拟机，并未Java虚拟机注册 JNI 方法，创建服务端 Socket 循环等待AMS 请求来创建新的应用程序进程 SystemServer 进程启动 启动Binder 线程池 和 SystemServiceManager ，并启动各种服务。 Launcher启动 SystemServer 进程启动的 AMS 会启动 Launcher，Launcher 会将已安装的应用显示到界面上。 用图表示就是：","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android进阶解密","slug":"Android进阶解密","permalink":"https://glassx.gitee.io/tags/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/"}]},{"title":"面试题-网络知识","slug":"面试题-网络知识","date":"2019-11-22T07:00:00.000Z","updated":"2020-09-12T19:25:09.280Z","comments":true,"path":"2019/11/22/面试题-网络知识/","link":"","permalink":"https://glassx.gitee.io/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/","excerpt":"TCP/IP 三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）首先要会画 三次握手和四次挥手 的图。很重要，画了两次错了3次握手的示意图如下：三次握手过程：TCP发起的一方A，由操作系统生成一个序列号 n，以这个n为原点，对自己每个将要发送的数据进行编号，连接的另一方 B 会对A每次发送的数据进行确认，如果A收到B的确认编号2001，则可以认为 n~2000编号已经全部到达B。","text":"TCP/IP 三次握手（为什么3次，能否2次或者4次？），四次挥手（为什么4次，3次可以吗）首先要会画 三次握手和四次挥手 的图。很重要，画了两次错了3次握手的示意图如下：三次握手过程：TCP发起的一方A，由操作系统生成一个序列号 n，以这个n为原点，对自己每个将要发送的数据进行编号，连接的另一方 B 会对A每次发送的数据进行确认，如果A收到B的确认编号2001，则可以认为 n~2000编号已经全部到达B。 为什么三次握手 首先，三次握手证明双方收发能力正常 其次，如果只需要两次握手，那第二次(从server发到client端)之后server就分配资源了，但是如果第二次丢失了，那就造成资源浪费 还有，如果client没有收到确认，就会再次发送握手连接，如果服务端先接到了第二个消息，然后发送返回确认，双方通信完毕，关闭。这时候第一个请求到了服务端，服务端确认，然而客户端已经关闭了，不理睬，这时候服务端只能一直等。 还有，握手就确认了双方的序列号规则 可以不握手吗？tcp实现可靠通信与 报文序号和确认号(ack) 是分不开的，我们知道握手是干的啥，其中就有告知初始序号的功能，所以不能不握手。 4次挥手示意图： 由上图看出，由client端发起挥手，server给client的2次回复中，一次是确认信息ack，一次是数据的传送，那可不可以只要3次挥手呢？答案是可能的，TCP是全双工的，Client在没有数据需要发送给Server后，就发送FIN告知server，然后终止对server发送消息，但这个时候server还以发送数据给client，这时候需要4次；但是如果server收到client的FIN后再也没有数据要发给client了，那么 对client的ack包和server自己的FIN包就能合并成一个包发送过去，四次挥手变成3次。 了解完挥手完成后，可能还想更深入了解 TIME_WAIT，可以查看之前写的这篇。 延伸-握手可能有什么安全问题首先，发起请求时候的序列是随机的，为什么是随机的呢？想想如果是固定的从0开始，那么客户端发送多次握手(重传)，那么，当新连接建立之后，如果上一次的请求再过来了，序列还是 0 ，那就乱了。相反，如果序列不固定，那么上一次的过来，我只要和新连接这里对比下 序列号 就知道是否合法了。 client第一个 SYN 包丢失，这个无所谓，后续触发重传机制，隔5s，24s等 server 收到 SYN ，但是回复的 SYN，ACK 丢失，也会触发重传，可能依次隔 3s,6s,12s 等 client 最后依次发送的 ACK 丢了，server 因为没收到 ACK 而实现重传，但是client 已经进入 ESTABLISHED 状态了。因为多数情况下，client 发送完最后的 ACK之后，就认为连接建立，开始发送数据。现实中的情况是，在这种情况下 server 收到 client 的数据会进入 ESTABLISH 状态，并会认为数据有效。 如果client 故意不发最后一次 ACK，那么服务端处于半连接状态，如果这种半连接很多的话，server 端很有压力，因为需要一直重传 以上内容参考自知乎上的文章、知乎上的文章1、知乎-泪花的回答 延伸-三次握手可以携带数据吗？第一次、第二次不可以，第三次可以。想想为什么？ 假如第一次允许带数据，那么攻击者只需要在第一次SYN中放入大量数据，根本不考虑服务器接收能力，这会让server 花费很长时间和很多空间来处理这些报文 并且，第一次不知道server 是否有接收能力；如果放第二次，server 也不知道clien 是否有接收能力。 以上内容参考自知乎上的文章、知乎上的文章1、知乎-泪花的回答 引申——为什么要等待2MSL？原因有二：保证TCP协议的全双工连接能够可靠关闭 以及 保证这次连接的重复数据段从网络中消失 第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。 第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。 IP地址分类（A/B/C/D类）IP地址由四段组成，每个字段是一个字节，即4个字节、 每个字节有8位，最大值是255，IP地址 = 网络号+主机号。分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用。 由图可知： A类：前1个字节(8位)为网络号，后3个字节(24位)为主机号。A类第1位必须是0B类：前2个字节(16位)为网络号，后2个字节(16位)为主机号。B类前两位固定为10C类：前3个字节(24位)为网络号，后1个字节(8位)为主机号。C类前3位固定为110D类： 是多播地址，一般用于多路广播用户。该类IP地址的最前面为1110E类： 是保留地址。该类IP地址的最前面为1111 TCP与UDP区别 UDP发送数据前无需建立连接，TCP需要握手建立连接。 UDP尽最大努力交付,不保证可靠交付；TCP提供可靠交付。 UDP面向报文，对应用程序交下来的报文，在添加首部之后就交付给Ip层，不会对报文拆分；TCP面向字节流，会对应用程序的报文进行拆分。 UDP支持一对一、一对多、多对一和多对一的通信；TCP全双工通信，并且只能点对点通信，允许通信双方在任何时候均能通信。 UDP首部开销小，TCP开销大（UDP 8个字节，TCP20个字节）。 UDP没有拥塞控制，在网络条件差的情况下发送端也不会降低发送速率；TCP有拥塞控制，慢开始避免拥塞，快重传、快恢复。 TCP 通过滑动窗口实现流量控制，UDP 无。 需要参考知乎上的讲解)重写一下 引申-TCP流量控制如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。 设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。 从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。 TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。 快重传和快恢复 快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。 快恢复：当发送方连续收到三个重复确认，就开始执行拥塞避免算法，缩小拥塞窗口，随后再使拥塞窗口缓慢地线性增大。 Http和Https的区别？ Https是ssl加密传输，Http是明文传输Https是使用端口443，而Http使用80HttpsSSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比Http协议安全Https协议需要到CA申请证书 中间人攻击带着下列问题去了解Https 安全性： 为什么用了https 就是安全的？用了https就一定安全吗？ https 的底层原理如何？ https的原理https的整体过程分为证书验证和数据传输阶段，具体交互如下图： 所以证书验证阶段流程就是： 客户端发起https 请求 服务端返回https 证书 客户端验证证书是否合法 数据传输阶段流程就是： 证书合法后，在本地生成随机数 通过公钥加密随机数，并把加密后的随机数传输给服务端 服务端通过私钥对随机数解密 服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输 那我们再引申一下，为什么后来要使用对称加密传输数据。这是因为： 非对称加密的效率低 https 上述场景中，只有服务端保存了私钥，一对公私钥只能单向加解密，而对称加密可以实现双向的加解密 中间人攻击了解以上原理之后，中间人攻击的具体流程如下： 主要包括以下步骤： 本地请求被劫持(如dns劫持等)，所有请求均发送到中间人的服务器 中间人返回自己自己的证书 客户端创建随机数并通过中间人的证书公钥加密，之后凭随机数构造对称加密对传输内容加密 中间人用私钥解密随机数，此时中间人拥有客户端的随机数，所以可以通过对称加密算法解密内容 中间人再以客户端的请求内容向正规服务器发送请求，此时中间人发起的请求就是正规请求了，数据也是正规数据，所以合法，正规服务器会通过建立的安全通道返回加密数据 此后流程都是合法化的了，中间人只是做了个转发而已 以上，就是中间人攻击的流程，我们日常使用的fiddler 代理，其实就很好地模拟了中间人攻击。因为我们使用fiddler 代理https 的时候，需要本地信任fiddler 的证书，其实就是中间人返回自己的证书过程，中间人攻击关键也是这一步。 一般客户端会验证证书的合法性，所以中间人的证书没有这么容易被信任，中间人攻击的难点也在这。 以上内容参考自知乎-Java面试那些事儿 TCP/IP 流量控制，拥塞避免，可以结合这篇文章Session 和 Cookie 的区别？ HTTP是一种无状态的协议，为了分辨链接是谁发起的，Session和Cookie就是为解决这个问题而提出来的两个机制。Cookies是服务器下发，存储到本地机器上的一段文本，并随每一个请求发回服务器，是在客户端保持状态的方案。浏览器第一次发送请求时，服务器自动生成了一HashTable和一个Session ID来唯一标识这个HashTable，并将其通过响应发送回浏览器。Session的实现方式和Cookie有一定关系，一般会把session id存在Cookie中（也可以依赖于url重写），每次访问的时候将Session id带过去，服务器就根据id查找hashtable就可以识别当前用户状态了。所以可以总结，cookie存在本地，session存在服务器；父路径不能享用子路径的cookies，而同一个session的窗口可以共享session；cookie没有session可靠。 在浏览器中输入www.baidu.com后执行的全部过程 客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 HTTP中，POST与GET的区别 Get是从服务器上获取数据，Post是向服务器传送数据。 Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中科院看到。 Get传送的数据量小，不能大于2KB；post传送的数据量较大，一般被默认为不受限制。 根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。 http2 与http1 的区别 点击看答案 总结一下：1)、新的二进制格式 2)、多路复用 3)、header 压缩 4)、采用新的压缩算法 5)、server push 6)、更安全的SSL 新的二进制格式 解释： http1 设计的时候是基于文本，http2 基于二进制格式。http2 的格式定义更接近tcp层的方式，length 定义了整个frame 的开始到结束，type 定义了frame 的类型，stream id 用作流控制。如下图所示： 虽然看上去写一个是和http1完全不同了，实际上并没有改变http1的语义，只是把http1的header 和 body 用frame 重新封装了一层而已。他们的对应关系如下： 上述http1的首部信息会封装到 Header 的 frame，而相应的 body 封装到 Data frame。 多路复用 解释：多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。一个request对应一个 stream 并分配一个id，这样一个连接上可以有多个stream，每个stream 的frame 可以随机地混杂在一起，接收方可以根据stream id 将各个frame 再归属到不同的request 里面。 http 性能优化的关键并不在于高带宽，而是低延迟，tcp 连接会随着时间进行自我“调谐”，起初会限制最大速度，如果传输成功，会随着时间提高传输的速度，这种调谐称为“慢启动”。http2 通过让所有数据流共用同一个连接，可以更高效地使用TCP。 客户端依据域名来向服务器建立连接，一般pc端浏览器会针对单个域名的server 同时建立 6~8 个连接，连接无法复用会导致请求要经历三次握手和慢启动。在http1中，假如有5个连接同时发出，在第一个请求没有收到回复之前，后续从应用层发出的请求只能排队，请求2，3，4，5只能等请求1的response 回来之后才能逐个发出。网络通畅的时候性能影响不大，一旦请求1的request 因为什么原因没有抵达服务器，影响到后续所有的请求，问题就比较严重了。 header 压缩 解释：http2针对header 采用新的压缩方式，高效地压缩算法可以很大地压缩header。并且，通讯双方各自缓存一份 header fields 表，避免重复header 的传输。 采用新的压缩算法 解释：http2在采用gzip之外的新的压缩算法，更加安全。 server push 解释：http2 能通过push的方式将客户端需要的内容预先推送过去。 更安全的SSL 解释：http2.0 对 tls 的安全性做了进一步加强。 > 以上内容参考自[知乎上的回答](https://www.zhihu.com/question/34074946) 网络状态码？以 2、3、4、5 开头的代表什么意思。 点击看答案 1xx-临时响应100： 继续。请求者应当继续提出请求101： 切换协议。请求者要求服务器切换协议，服务器确认并准备切换 2xx-成功200： 成功。服务器成功处理请求201： 已创建。请求成功并且服务器创建了新的资源202： 已接受。 服务器接受请求，但是尚未处理203： 非授权信息。服务器成功处理请求，但返回的信息可能来自另一来源204： 无内容。服务器成功处理请求，但是没有返回任何内容205： 重置内容。服务器成功处理请求，但是没有返回任何内容206： 部分内容。服务器成功处理了部分GET请求 3xx-重定向300： 多种选择。服务器根据请求者选择一项操作，火提供操作列表供请求者选择301： 永久移动。请求的资源永久移动到新位置了，返回此响应时会自动转到新位置302： 临时移动。从不同位置响应请求，但是后续还是以原来位置继续请求303： 查看其它位置。304： 未修改。自上次请求后，请求的网页未修改过，此时不会返回网页内容305： 使用代理。请求者只能使用代理访问请求的网页。 4xx-请求错误400： 错误请求。服务器不理解请求语法401： 未授权。请求要求身份验证403： 进制。服务器拒绝请求404： 未找到。服务器找不到请求的网页405： 方法禁用。禁用请求中指定的方法408： 请求超时。服务器等候请求时发生超时410： 已删除。请求的资源已永久删除413： 请求实体过大。请求实体过大，服务器无法响应414： 请求的URI过长。请求的URI（通常为网址）过长，无法处理415： 不支持的媒体类型。 5xx-服务器错误500： 服务器内部错误。服务器遇到错误，无法完成请求501： 尚未实施。服务器不具备完成请求的功能502： 错误网关。503： 服务不可用。暂时地维护或者超载了504： 网关超时。服务器作为网关或者代理，但是没有及时从上游服务器收到请求505： HTTP版本不支持。服务器不支持请求中所用的HTTP协议版本 以上内容参考自站长工具 HttpDNS 点击看答案 当前 DNS 系统存在的问题 域名缓存。运营商的 LocalDNS 会缓存域名解析的结果，而不是向权威域名发起递归。运营商缓存dns就可以实现把dns解析结果指向广告 解析转发。运营商自身不进行域名递归解析，而是把它发给其它运营商。一些小运营商就是这样做的。这样，比如说访问的是qq.com，则腾讯的权威dns收到的域名解析请求的来源就变成了其它运营商，最终导致用户流量被导向了错误的IDC，比如明明是广东的用户，被导向去了北京的服务器。 NAT ，网络地址转换。运营商LocalDNS出口根据权威DNS目标ip进行NAT，导致腾讯权威dns无法正确识别运营商的 LocalDNS 的ip，引发域名解析错误，流量跨网等 解决方案 使用 114 等中立DNS 服务器 使用HttpDNS，HttpDNS 的基本原理如下： 注意：HttpDNS主要用于客户端 HttpDNS 的使用过程主要有两步： 客户端直接访问HttpDNS 接口，获取Host对应的IP。 客户端通过IP，向后台发送请求。以Http为例，通过在Header中指定host 字段，向HttpDNS 返回的IP 发送标准的Http请求即可。 以上内容参考自鹅厂网事上的博客 https的证书验证证书是一级一级的验证的，验证当前的证书时，首先拿上一级的证书的公钥，用上一级的公钥来验证当前证书的签名，验证成功就通过，不成功就报错了。然后一级一级上去，顶级。因为本地(浏览器和操作系统)一般存有信任的根证书，顶级证书一般都能通过本地证书验证。 以上内容可以参考知乎上的内容 https的攻击方式1、中间人攻击。类似Fiddler 这种方式，前提是黑客通过某种特殊手段在被攻击者的手机上安装了根证书2、Https协议降级攻击。比如说client端仅仅支持某个有漏洞的ssl版本(比如SSLv3.0)，那么服务端只能接收或者直接拒绝。如果接受的话，攻击者就能攻击(应该是 Padding Oracle 攻击)3、使用对称加密的时候破解的对称加密 以上内容参考自知乎的博客、中间人攻击","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题-网上搜集的题目(一)","slug":"面试题-网上搜集的题目(一)","date":"2019-11-22T07:00:00.000Z","updated":"2020-03-24T14:43:59.603Z","comments":true,"path":"2019/11/22/面试题-网上搜集的题目(一)/","link":"","permalink":"https://glassx.gitee.io/2019/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BD%91%E4%B8%8A%E6%90%9C%E9%9B%86%E7%9A%84%E9%A2%98%E7%9B%AE(%E4%B8%80)/","excerpt":"谈谈对this和super的认识闭包和内部类的区别Java 多态实现的机制是什么 点击看答案 重写和重载 final 关键字的作用多维数组在内存上是怎么存储的 点击看答案 Java 中的多维数组就是通过一维数组来实现的，只不过这个一维数组中的元素还是多维数组，比如如下声明： 1int[][][] array = new int[2][3][4]; 它实际上大致等同于如下代码： 1234567int[][][] a = new int[2][][]; for (int i = 0; i &lt; a.length; i++) &#123; a[i] = new int[3][]; for (int j = 0; j &lt; a[i].length; j++) &#123; a[i][j] = new int[4]; &#125; &#125; 以上代码参考自iteye中的博客 如果要自己用一维数组去实现二维(或者更多维)的数组，可以使用类似规律： k = j*(j-1)/2 + i -1 来计算出在一维数组中的下标 k 值。","text":"谈谈对this和super的认识闭包和内部类的区别Java 多态实现的机制是什么 点击看答案 重写和重载 final 关键字的作用多维数组在内存上是怎么存储的 点击看答案 Java 中的多维数组就是通过一维数组来实现的，只不过这个一维数组中的元素还是多维数组，比如如下声明： 1int[][][] array = new int[2][3][4]; 它实际上大致等同于如下代码： 1234567int[][][] a = new int[2][][]; for (int i = 0; i &lt; a.length; i++) &#123; a[i] = new int[3][]; for (int j = 0; j &lt; a[i].length; j++) &#123; a[i][j] = new int[4]; &#125; &#125; 以上代码参考自iteye中的博客 如果要自己用一维数组去实现二维(或者更多维)的数组，可以使用类似规律： k = j*(j-1)/2 + i -1 来计算出在一维数组中的下标 k 值。 Java 的异常体系的理解运行时异常 与 非运行时异常NIO/BIO/AIOCollection 与 Map 的区别如何深拷贝List 集合Set 如何保证唯一性的谈谈Java集合中那些线程安全的集合 &amp; 实现原理Collection 和 Collections 的区别 点击看答案 Collection是接口，Collections 是帮助类，能实现排序(Collections.sort() )等功能 以上题目参考自gitee上博客","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题-系统源码理解","slug":"面试题-系统源码理解","date":"2019-11-20T03:13:00.000Z","updated":"2021-02-09T08:13:11.538Z","comments":true,"path":"2019/11/20/面试题-系统源码理解/","link":"","permalink":"https://glassx.gitee.io/2019/11/20/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/","excerpt":"1、okhttp的理解 点击看答案 首先看下okhttp 的整个工作流程： 首先通过 Builder 创建 OkhttpClient 对象 根据设定的条件，使用Request.Builder 构建request 对象 根据 OkhttpClient 与 request 创建 RealCall 不论是通过execute 还是enqueue 方式异步执行，最终都通过 getResponseWithInterceptorChain 方式获取Http 的返回结果 步骤4中，通过Okio 封装的Socket 请求网络，并获取返回结果 Interceptor 是Okhttp 中最重要的一个东西，它不止拦截请求执行一些额外处理，实际上实际的网络请求、缓存、透明压缩等都是通过Interceptor 实现，它们一起连成 Interceptor.chain，每一个Interceptor 决定它自己能处理哪些事件，如果不能处理，则交给下一个Interceptor 处理，也就是责任链模式。这很类似View 中对点击事件的处理。 以上内容参考自：okhttp 解析","text":"1、okhttp的理解 点击看答案 首先看下okhttp 的整个工作流程： 首先通过 Builder 创建 OkhttpClient 对象 根据设定的条件，使用Request.Builder 构建request 对象 根据 OkhttpClient 与 request 创建 RealCall 不论是通过execute 还是enqueue 方式异步执行，最终都通过 getResponseWithInterceptorChain 方式获取Http 的返回结果 步骤4中，通过Okio 封装的Socket 请求网络，并获取返回结果 Interceptor 是Okhttp 中最重要的一个东西，它不止拦截请求执行一些额外处理，实际上实际的网络请求、缓存、透明压缩等都是通过Interceptor 实现，它们一起连成 Interceptor.chain，每一个Interceptor 决定它自己能处理哪些事件，如果不能处理，则交给下一个Interceptor 处理，也就是责任链模式。这很类似View 中对点击事件的处理。 以上内容参考自：okhttp 解析 2、谈谈对RxJava的理解 点击看答案 常用操作符 map：将被观察者发送的数据类型转换为其他类型 flatMap ： 将事件序列中的元素整合，返回一个新的被观察者 zip ： 将多个观察者事件整合发送给观察者 如何实现线程切换 Observer 最终会封装成 SubscribeTask ，这个类实现了 Runnable 接口。 最终在 Runnable 的run 方法中完成 观察者-被观察者的订阅关系 也即，这个run 在哪个线程执行，observer 方法就在哪个方法执行。 如果是 AndroidSchedulers.mainThread 的话，则会以Android主线程的Looper(Looper.getMainLooper())新建一个 Handler ，之后将上述Runnable 封装成Message ，通过Handler 发送到主线程。 如果是其他线程，则会丢给特定线程或者线程池处理。 以上内容参考自： rxjava2线程切换原理、rxjava使用与原理 3、fresco的理解 点击看答案 为什么使用fresco 部门决定采用webp 格式的图片，而fresco 对其支持 5.0 以下Android系统，使用 ashmem(匿名共享内存) 区域存储bitmap ，它的创建、释放都不会触发 GC，带来良好的性能。 fresco 使用ashmem 区域存储bitmap ，gc不会处理这块区域，并且也不会被”ashmem内置清除机制”回收，所以减少gc，提升性能。在ashmem 中，fresco 采用引用计数方式，自己管理内存。 使用了三级缓存，方便图片快速复用、加载：Bitmap 缓存 + 未解码缓存 + 硬盘缓存，前面两个是内存缓存，Bitmap 根据不同系统版本存放不同区域(5.0以下存放ashmem)，未解码存放在堆内存。 fresco 的设计，UIThread 只做从内存缓存中加载图片和显示图片两件事，其他诸如 图片Decode、缓存读写 都放在非 UI线程。 fresco 原理解析典型的MVC模式应用： DraweeView ： view 层，负责显示图片。它继承ImageView 的目的是使用它来显示 drawable ，其他的ImageView 方法都没有使用，也不推荐使用。 Hierarchy： model 层，负责生成要显示的图片 DraweeController： controller 层 DraweeView 把获得event 转给 controller，controller 决定是否隐藏或者显示什么图像，而这些图像存储在 Hierarchy，最后 DraweeView 直接通过 getTopLevelDrawable 获取要显示的图像。 DraweeView 不直接与 Hierarchy 及 DraweeController 打交道，而是通过 DraweeHolder 间接与他们打交道，因为 DraweeHolder 管理着 Hierarchy 与 Controller。 4、ThreadLocal 详解 点击看答案 ThreadLocal 很典型的一个用处就是存储线程的 Looper，我们知道，子线程中初始化Handler 的时候，需要先执行 Looper.prepare ，这个操作就是新建一个Looper 并且将其保存到 ThreadLocal 中。 Thread 类中有个专门存储线程的 ThreadLocal 数据的结构，即 ThreadLocal.Values 。保存值时，首先通过 Thread.currentThread 获取到当前线程，再获取该线程的 ThreadLocal.Values ，这个 Values 中有个 Object[] table 的数组，ThreadLocal 对象就存在这个数组中。每个 ThreadLocal 对象根据自己的 hashcode 按照一定规则获取到在数组中的 index ，之后进行读取或者存储。 这样，每个线程通过同一个 ThreadLocal 获取到的是不同的值。各个线程可以相互独立地执行操作。 以上内容总结自源码，部分语言参考自任玉刚的博客内容 5、LocalBroadcastManager 点击看答案 LocalBroadcastManager 注册本地广播只能通过代码，不能通过xml静态注册。本地广播不会跨进程，不用跟system_server 交互。 原理分析首先，LocalBroadcastManager.getInstance 是个单例，在初始化过程中，会根据 mainLooper 创建一个Handler： 12345678910111213141516private LocalBroadcastManager(Context context) &#123; mAppContext = context; mHandler = new Handler(context.getMainLooper()) &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_EXEC_PENDING_BROADCASTS: executePendingBroadcasts(); break; default: super.handleMessage(msg); &#125; &#125; &#125;;&#125; 其次，注册过程，其实可以理解成订阅某种消息，以便在符合条件的消息发送的时候，这里能接收： 123456789101112131415161718192021222324public void registerReceiver(@NonNull BroadcastReceiver receiver, @NonNull IntentFilter filter) &#123; synchronized (mReceivers) &#123; //创建ReceiverRecord对象 ReceiverRecord entry = new ReceiverRecord(filter, receiver); //mReceivers：数据类型为HashMap&lt;BroadcastReceiver, ArrayList&gt;， 记录广播接收者与IntentFilter列表的对应关系 ArrayList&lt;ReceiverRecord&gt; filters = mReceivers.get(receiver); if (filters == null) &#123; filters = new ArrayList&lt;&gt;(1); mReceivers.put(receiver, filters); &#125; filters.add(entry); for (int i=0; i&lt;filter.countActions(); i++) &#123; String action = filter.getAction(i); //mActions：数据类型为HashMap&lt;String, ArrayList&gt;， 记录action与广播接收者的对应关系 ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action); if (entries == null) &#123; entries = new ArrayList&lt;ReceiverRecord&gt;(1); mActions.put(action, entries); &#125; entries.add(entry); &#125; &#125;&#125; 接着，发送广播，可以理解为，根据 sendBroadcast(Intent intent) 中 intent 的值获取 actions，再根据action 来查询相应的广播接收者，当然，如果当前receiver 正在处理其他广播，则跳过： 123456789101112131415161718192021222324252627282930313233343536373839404142 public boolean sendBroadcast(Intent intent) &#123; synchronized (mReceivers) &#123; ... //根据Intent的action来查询相应的广播接收者列表 ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction()); if (entries != null) &#123; //用于存放与当前action匹配的receiver ArrayList&lt;ReceiverRecord&gt; receivers = null; for (int i=0; i&lt;entries.size(); i++) &#123; ReceiverRecord receiver = entries.get(i); if (receiver.broadcasting) &#123; //当前receiver正在处理其他广播，则跳过 continue; &#125; int match = receiver.filter.match(action, type, scheme, data,categories, \"LocalBroadcastManager\"); if (match &gt;= 0) &#123; if (receivers == null) &#123; receivers = new ArrayList&lt;ReceiverRecord&gt;(); &#125; receivers.add(receiver); receiver.broadcasting = true; &#125; &#125; if (receivers != null) &#123; for (int i=0; i&lt;receivers.size(); i++) &#123; receivers.get(i).broadcasting = false; &#125; //创建相应广播，添加到mPendingBroadcasts队列 mPendingBroadcasts.add(new BroadcastRecord(intent, receivers)); if (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123; //发送消息【见小节2.3.1】 mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS); &#125; return true; &#125; &#125; &#125; return false;&#125; 在 LocalBroadcastManager 的构造函数中我们初始化了这个以 mainLooper 建立的Handler，此时利用它 sendEmptyMessage，在handleMessage 中最终会调用 executePendingBroadcasts 方法（说明此函数也运行在主线程）： 1234567891011121314151617181920212223242526private void executePendingBroadcasts() &#123; while (true) &#123; final BroadcastRecord[] brs; //将mPendingBroadcasts保存到brs数组 synchronized (mReceivers) &#123; final int N = mPendingBroadcasts.size(); if (N &lt;= 0) &#123; return; &#125; brs = new BroadcastRecord[N]; mPendingBroadcasts.toArray(brs); mPendingBroadcasts.clear(); &#125; //挨个回调相应广播接收者的onReceive for (int i=0; i&lt;brs.length; i++) &#123; final BroadcastRecord br = brs[i]; final int nbr = br.receivers.size(); for (int j=0; j&lt;nbr; j++) &#123; final ReceiverRecord rec = br.receivers.get(j); if (!rec.dead) &#123; rec.receiver.onReceive(mAppContext, br.intent); &#125; &#125; &#125; &#125;&#125; 通过以上的原理分析，我们知道本地广播只是在发送广播的时候，在主线程中挨个通知 action 符合的receiver，因此并不会超出进程范围，也不会超出 app 范围，只会在当前app 的当前进程发生。 以上内容参考自gityuan的分析 6、Java线程池ThreadPoolExecutor实现原理 点击看答案 ThreadPoolExecutor 构造函数参数非常多，有以下： corePoolSize： 通过 submit 或者 execute 提交任务时，如果当前线程池的线程数 n &lt; corePoolSize ，则创建一个新的线程处理任务，即使其他 core 线程是空闲的。 maximumPoolSize: 如果当前线程数 n &gt; corePoolSize &amp;&amp; n &lt; maximumPoolSize ，那么不会创建新的线程；但是如果 n &gt;= maximumPoolSize 时，就会创建新的线程。如果是个无界队列(LinkedBlockingQueue)，那么不存在满的情况(n &gt;= maximumPoolSize),也就不会创建新线程。 keepAliveTime: 如果当前线程池中的线程数 n &gt; corePoolSize,那么如果在 keepAliveTime 时间内没有新的任务需要处理，那么就会销毁 corePoolSize - n 个线程。 handler ：异常处理策略。即当任务提交失败的时候，调用这个处理器。 运行状态ThreadPoolExecutor 使用一个 AtomicInteger 的前三位表示线程池状态，后 29 位表示线程数，因此是可以支持上亿的线程计数。线程池主要有几种状态： Running： 线程池正在运行，可以接收新任务。 ShutDown： 不再接收新任务，但会继续处理队列中任务。 Stop： 不接受新任务，也不处理队列中任务，并且中断正在处理的任务 Tidying： 所有任务处理玩，线程数为 0(线程池为空) Terminated： 已经执行完毕(执行了 terminated) submit 执行过程 就是将 Runnable 和 Callable 封装成 RunnableFuture 之后，最终提交给execute 执行。使用 HashSet 类型的 worker 来存储正在运行的任务，只要 worker.size() &lt; corePoolSize，提交新的任务就马上开启新线程执行(上面提到过)。在提交过程中要检查线程池的状态，检查是否关闭了。 worker的数目也是通过 CAS的方式 增减的。 以上内容参考自github上的博客 7、延伸-Java 线程池的异常处理机制 点击看答案 如果是使用submit 提交的话，可以通过继承 ThreadPoolExecutor 再重写 afterExecute 方法，得到实际的异常 (包含 Runnable 和 Throwable) 如果是调用的execute 方法提交的话，那就会抛到 dispatchUncaughtException 里面去了，这时候我们只有对线程 Thread.setUncaughtExceptionHandler(UncaughtExceptionHandler) 来捕捉。即自己写 ThreadFactory (thread 工厂类),并为创建的线程 setUncaughtExceptionHandler 还有一种，就是对 Runnable 的 run 方法里面整个 try-catch 以上内容参考自并发编程网 或者它在github上的相同文章 8、AsyncTask 解析 点击看答案 AsyncTask 是个抽象类，必须子类实现才能使用。在构建的时候，需要指定三个泛型参数类型，分别是 Params、Progress、Result ，即类似 AsyncTask&lt;Integers, Integers, ResponseBean&gt; ，当然，如果某个参数不需要，类型可以写成 Void 。 其整体原理还是 将task丢给ThreadPool 在子线程执行，得到结果后，通过 Handler 的 sendEmptyMessage 的方式将结果切换到主线程 在 AsyncTask 使用的过程中需要遵守如下原则： 必须在UI线程中实例化 execute 必须在UI线程中调用 不要人为调用 onPreExecute、onPostExecute、doInBackground 和 onProgressUpdate 一个 AsyncTask 实例只能执行一次，如果多次调用会报异常 AsyncTask 中有 static 的 ThreadPool ，意味着不管有多少个实例，都只有这个线程池，而在初始化这个线程池的时候，corePoolSize 在不同版本的值默认被设置为 1 或者 5 (Android 3.0以前是5，还不能改；3.0之后设置为1，但是可以自己设置Excutor )，并且 BlockingQueue 基本上是个无界队列(BlockingQueue 或 SynchronousQueue，队列不存在满的情况)，根据 ThreadPool 的原理，我们每次最多只有一个线程或者 5 个线程在执行，意味着多的任务就要排队，并不能实时执行，并且在早期，我们不能设置自定义的 ThreadPoolExcutor，到后来才可以(貌似是Android 4.0以后)。 AsyncTask 存在的问题： AsyncTask 对象只能execute 一次，多次请求会导致多个对象创建 生命周期与Activity 的生命周期不一致，有可能导致内存泄露 cancle 并不马上生效，因为它就是线程，在cancle之后，还得等它完成 以上内容参考自 系统源码、github上的博客、cnblogs的博客、csdn的博客 9、阿里Alpha原理 点击看答案 想象下有以下场景： 有6个任务需要在Application里面执行，其中Task1，Task4，Tas6需要在主线程执行，Task2，Task3需要在Task1执行完才能执行，Task4，Task5需要Task2和Task3执行完才能执行，Task6需要Task4和Task5执行完才能执行，Task4的耗时要大于Task5，是不是顿时就乱了？其实可以通过 PERT 图来捋一捋这个关系，涉及到具体实现的话，可以参考阿里巴巴的 alpha 框架。 Alpha是一个基于PERT图构建的Android异步启动框架 首先解决多进程疑惑，在start方法中就首先判断了 主进程任务、非主进程任务 以及 适用于所有进程的任务，这些任务是通过 public void addProject(Task project, int mode) 方法添加进去的。 在实际情况中，可能会有多个任务同时开始，并且也有可能多个任务作为结束节点，所以为了方便控制整个流程，alpha 设计了startTask 和 finishTask，标记流程的开始和结束，方便任务的监听 如果Task 是在主线程执行的，那么就通过Handler 将时间传递给主线程；如果是非主线程，则通过线程池去执行。 在一个Task执行完成后，就会遍历自己持有的 mSuccessorList(紧后任务列表，也就是当前任务执行完成之后可以执行的Task列表，这里面的Task会根据Priority进行排序)，并依次执行里面元素的 onPredecessorFinished 方法。 mSuccessorList 列表中的Task 是通过 after 方法加入的： 123456789101112131415//紧后任务添加public Builder after(Task task) &#123; task.addSuccessor(mCacheTask); mFinishTask.removePredecessor(task); mIsSetPosition = true; return Builder.this;&#125;//主要操作在这个方法里void addSuccessor(Task task) &#123; //task 添加紧前任务 task.addPredecessor(this); //真正添加为紧后任务 mSuccessorList.add(task);&#125; 意思是Task2要在Task1后面执行，这样，Task2就是Task1的紧后任务，同理，Task1也成了Task2的紧前任务，那这个紧前任务有什么用呢？试想一下，如果Task1、Task2、Task3的紧后任务都是 Task4，那么，在Task1执行完成之后，还要判断 Task2和Task3是否执行完成，然后才能决定是否执行Task4，这就是紧前任务的作用了。 以上文章主要参考自：积木zz的csdn博客, 有博客说，使用 Anchors 比使用 Alpha 更精细，后续再看 10、LeakCanary 原理 点击看答案 原理： 通过registerActivityLifecycleCallbacks 来监听 Activity 的生命周期 onActivityDestroyed。 即 lifecycleCallbacks 监听Activity 的 onDestroy 方法，正常情况下执行了onDestroy 后资源立即回收。 监察机制利用了 WeakReference 和 ReferenceQueue ，使用 WeakReference 对Activity 进行引用，在Activity回收的时候，就会将该WeakReference 引用放到 ReferenceQueue 中。 在onDestroy 之后，等待一段时间，再通过监测 ReferenceQueue 是否包含 WeakReference 就能检查 Activity 是否被正确回收。 如果Activity 没有被回收，就手动 GC 一次，等待若干时间，之后再次判断Activity 是否被回收，若未被回收，说明 Activity 已经泄露。 如果Activity 泄露了，则抓取 dump 信息显示出来。 以上要注意的是： 1、是使用WeakReference对Activity进行引用2、LeakCanary可以配置忽略某些路径的内存泄漏3、手动GC是使用的 Runtime.getRuntime().gc() 实现，代码中解释是这样触发gc的概率会比System.gc() 高一些: System.gc() does not garbage collect every time. Runtime.gc() is more likely to perform a gc.4、 当Activity对象被回收时，会将 WeakReference(而不是Activity)对象放入 ReferenceQueue 中，自己写的测试代码如下： public class MainActivity extends AppCompatActivity { private RecyclebleObject testObject; private WeakReference&lt;RecyclebleObject&gt; objectWeakReference; private ReferenceQueue&lt;RecyclebleObject&gt; referenceQueue; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); testObject = new RecyclebleObject(); referenceQueue = new ReferenceQueue&lt;&gt;(); objectWeakReference = new WeakReference&lt;&gt;(testObject, referenceQueue); final TextView btnClick = findViewById(R.id.click_view); btnClick.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (testObject == null) { testObject = new RecyclebleObject(); } Log.e(\"NullTest\", \"testObject = \" + testObject); Log.e(\"NullTest\", \"referenceQueue 中的内容： \" + referenceQueue.poll()); testObject = null; Runtime.getRuntime().gc(); btnClick.postDelayed(new Runnable() { @Override public void run() { Log.e(\"NullTest\", \"GC 后，testObject = \" + testObject); Reference result = referenceQueue.poll(); Log.e(\"NullTest\", \"GC 后，referenceQueue 的内容： \" + result + \",这个对象与objectWeakReference 相等吗？ \" + (result == objectWeakReference)); } }, 1000); } }); } } 以上代码将会打印出以下结果： testObject = com.example.myapplication.RecyclebleObject@86f4db5referenceQueue 中的内容： nullGC 后，testObject = nullGC 后，referenceQueue 的内容： java.lang.ref.WeakReference@f6c4a,这个对象与objectWeakReference 相等吗？ true 说明在回收后， WeakReference 对象会出现在 referenceQueue 中，而不是 testObject 本身出现在 referenceQueue 。 有意思的是，在 LeakCanary2 时，并不需要接入者手动初始化(LeakCanary.install(this);)了，而是只需要引入即可。其根本原理是：LeakCanary 写了个 ContentProvider 并在 AndroidManifest中注册了，并在 ContentProvider 的onCreate方法中执行了 install 操作！我们知道，ContentProvider 的 onCreate 方法会在启动App的时候自动执行，并且比 Application 的 onCreate 方法还要早，因此它自动执行完全没问题。 以上内容参考自JasmineBen的博客、CSDN上的博客、以及自己写的代码验证 11、Toast显示流程 点击看答案 首先，为了避免Toast显示冲突，会将要显示的Toast放在队列中，然后依次取出来展示 makeText的时候，创建Toast对象和TN对象，Toast创建好后，加载布局，创建mNextView，然后 TN 是控制Toast的显示和隐藏以及取消的，它里面有个 Handler ，以当前线程的Looper来初始化，Toast的显示隐藏取消就是通过这个Handler来处理的。 Toast对象创建完成就 enqueueToast 到NotificationManagerService 进程中去排队的(所以这中间是有跨进程通信这个概念的)，在中间会判断是否要显示这个Toast(如果此Toast正在取消或者隐藏就不展示了)，接着就开始排队，显示的话，就是不断从队列里面取出 ToastRecord ，然后调用 Toast对应的TN 的show 方法展示Toast。 TN收到显示的消息，创建WindowManager对象，然后将第一步创建的 View 添加到 WindowManager ，之后Toast 就显示出来了。 以上内容参考自简书上的博客 12、onTouchListener、onTouchListener 的onTouch方法、onTouchEvent、onClickListener、onLongClickListener 的执行顺序？ 点击看答案 dispatchTouchEvent 在 onTouchListener 之前发生，如果在 dispatchTouchEvent 的 down 事件就return 了 false，则后续的事件压根就不会传过来了，所以不会有什么故事。 但如果 down 事件返回了 true ，则事件虽然onTouchListener 和 onTouchEvent 会发生，但不会有点击事件了，即onLongClick 和 onClick 都不会响应了。 onTouchListener 在onTouchEvent 之前发生， onLongClick 与 onClick 依赖于是在onTouchEvent 里面发生的，也就是说 click 事件是在 onTouchEvent 之后执行，并且 onClick 在 onLongClick 之后执行。 如果在 onTouchListener 的 onTouch 方法中返回true，则没有后面的 onTouchEvent 什么事了，更别提 click 事件 在onTouch 发生后，如果直接在 onTouchEvent 中返回true 或者false ，那就没有 click 什么事情了（因为click 是在super.onTouchEvent中） 如果TouchEvent 不做处理，那么在down事件发生后长按，则会响应 onLongClick 事件，之后up，如果之前的 onLongClick 返回false ，则还会接着 onClick，反之，如果之前的 onLongClick 返回true，则 onClick 不会执行。 以上内容来自自己的实验，以及csdn上的博客1、csdn上的博客2 13、Android 事件中 CANCLE 事件是怎么来的？它的作用是啥？ 点击看答案 第一个问题：我们知道view如果处理了 Down 事件，则随之而来的 Move 和 Up 事件也会交给它处理，但是交给它处理之前，父View 可以拦截，如果被拦截了，就会返回 Cancel 事件，并且不会收到后续的 Move 和 Up 事件 第二个问题： 以上内容参考自 csdn上的博客","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"第1章：Android系统架构","slug":"Android进阶解密-第1章","date":"2019-11-19T14:26:00.000Z","updated":"2020-01-04T03:33:01.857Z","comments":true,"path":"2019/11/19/Android进阶解密-第1章/","link":"","permalink":"https://glassx.gitee.io/2019/11/19/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC1%E7%AB%A0/","excerpt":"系统架构分为五层，从上往下依次是应用层、应用框架层、系统运行库层、硬件抽象层和Linux内核层。 应用层(System Apps)：系统内置的应用程序以及非系统级的应用程序都属于应用层，负责与用户进行直接交互。 应用框架层(Java API FrameWork)：应用框架层为开发人员提供了开发应用程序所需要的API，我们平时开发应用程序都是调用这一层提供的API。 系统运行库层(Native)：系统运行库层分为两部分：分别是C/C++程序库和Android运行时库。运行时库又分为核心库和ART(Dalvik)，核心库提供了Java语言核心库的大多数功能，这样开发者可以使用Java语言来编写Android应用。 硬件抽象层(HAL)：硬件抽象层是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商的知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台。 Linux内核层(Linux Kernel)：Android 的核心系统服务基于Linux内核，在此基础上添加了部分Android专用驱动。","text":"系统架构分为五层，从上往下依次是应用层、应用框架层、系统运行库层、硬件抽象层和Linux内核层。 应用层(System Apps)：系统内置的应用程序以及非系统级的应用程序都属于应用层，负责与用户进行直接交互。 应用框架层(Java API FrameWork)：应用框架层为开发人员提供了开发应用程序所需要的API，我们平时开发应用程序都是调用这一层提供的API。 系统运行库层(Native)：系统运行库层分为两部分：分别是C/C++程序库和Android运行时库。运行时库又分为核心库和ART(Dalvik)，核心库提供了Java语言核心库的大多数功能，这样开发者可以使用Java语言来编写Android应用。 硬件抽象层(HAL)：硬件抽象层是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商的知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台。 Linux内核层(Linux Kernel)：Android 的核心系统服务基于Linux内核，在此基础上添加了部分Android专用驱动。 Android系统源码目录Android 8.0.0系统根目录结构说明如下图所示： 应用层应用层位于整个Android系统的最上层，开发者开发的应用程序以及系统内置应用程序都在应用层，它的目录结构如下： 应用框架层部分应用框架层是系统的核心部分，一方面向上提供接口给应用层调用，另一方面向下与下层进行衔接，应用框架层的主要实现代码在 frameworks/base 和 frameworks/av 目录下，其中frameworks/base 目录结构如下： 源码阅读系统源码阅读的方式有在线阅读和下载源码到本地用软件工具阅读。 在线阅读Android 在线阅读源码的网站有很多，比如：http://androidxref.com/,http://www.androidos.net.cn/,在书中，作者推荐使用前一个url在线阅读；我个人比较推荐第二个，因为它在类搜索这块做得非常舒服，像使用google、baidu 一样容易使用，此外，它还是中文界面。 使用Source Insight下载源码到本地，再用软件工具阅读源码是最好的方式，不受网速影响，效率更高，本地阅读源码可以采用 Android Studio、Eclipse、Sublime 和Source Insight 等软件，这里推荐使用Source Insight 。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android进阶解密","slug":"Android进阶解密","permalink":"https://glassx.gitee.io/tags/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/"}]},{"title":"第10章：Java虚拟机","slug":"Android进阶解密-第10章","date":"2019-11-18T12:48:00.000Z","updated":"2019-11-19T13:05:34.096Z","comments":true,"path":"2019/11/18/Android进阶解密-第10章/","link":"","permalink":"https://glassx.gitee.io/2019/11/18/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC10%E7%AB%A0/","excerpt":"需要注意的是，Android中的Dalvik 和 ART 并不属于Java 虚拟机。当一个Java 文件经过Java编译器后会生成Class 文件，这个Class 文件会由 Java 虚拟机进行处理，Java 虚拟机与 Java 语言没有必然的联系，它只与特定的二进制文件：Class 文件有关。任何语言只要能编译成 Class 文件，都能被Java 虚拟机识别并执行。","text":"需要注意的是，Android中的Dalvik 和 ART 并不属于Java 虚拟机。当一个Java 文件经过Java编译器后会生成Class 文件，这个Class 文件会由 Java 虚拟机进行处理，Java 虚拟机与 Java 语言没有必然的联系，它只与特定的二进制文件：Class 文件有关。任何语言只要能编译成 Class 文件，都能被Java 虚拟机识别并执行。 Java虚拟机结构按照Java虚拟机规范，抽象的Java 虚拟机如下图所示： 从图可以看出，Java虚拟机结构包括 运行时数据区域、执行引擎、本地库接口和本地方法库，其中类加载子系统并不属于Java 虚拟机的内部结构。下面针对这个图来介绍Android 开发需要掌握的Class 文件格式和运行时数据区域。 类的生命周期类的生命周期如下图所示： 类加载的各个阶段的工作： 加载： 查找并加载Class文件 连接： 包括验证、准备和解析 验证：确保被导入类型的正确性 准备：为类的**静态字段分配字段，并用默认值初始化这些字段 解析：虚拟机将常量池内的符号引用替换为直接引用 初始化： 将类变量初始化为正确的初始值。 运行时数据区域可取的几点： 为了在线程切换后能恢复到正确的执行位置，每个线程都会有个独立的程序计数器。如果线程执行的方法是Native方法，则程序计数器的值为空(Undefined)，否则，保存正在执行的字节码指令地址。 可以选择在方法区不显示垃圾收集 其他的可以参考深入理解Java虚拟机的这篇文章即可。 对象的创建当虚拟机接收到一个 new 指令时，它会做如下操作： 判断对象对应的类是否加载、链接、以及初始化。 为对象分配内存：如果内存规整，则只需要将指针指示器向空闲的内存移动若干距离即可；若不规整，则需要由虚拟机维护一个列表记录哪些内存是可用的。 处理并发安全问题，有两种方式解决： 对分配内存空间的动作做同步处理，比如采用 CAS 方式配合失败重试 为每个线程在Java堆中预先分配一小块内存，只有这块内存被使用完后，才需要同步的方式分配新的内存。 初始化分配到的内存空间：将分配到的内存，出对象头以外都初始化为零值。 设置对象的对象头：将对象所属的类、对象的hashcode、以及GC分代年龄等存放在对象头。 执行init方法进行初始化。 垃圾标记算法GC 主要做两个工作：一是内存的划分和分配，二是对垃圾进行回收。关于内存的划分和分配，目前Java虚拟机内存的划分是依赖于GC 的，比如现在的GC 都采用分代收集算法来回收垃圾的。Java 堆作为GC 的主要管理区域，被细分为新生代和老年代。 查看gc日志的时候，[GC(Systemt.gc()) 和 [Full GC(Systemt.gc() 用于说明此次垃圾收集的停顿类型(而非区分新生代和老年代)，后者表示此次GC发生了 STW(Stop the World，只有GC线程在运行，其他线程都暂停)。 其余主要内容，参考以前写的这篇文章 垃圾收集算法标记-清除算法首先标记可以被回收的对象，之后回收被标记的对象所占的空间。它主要有两大缺点：一个是标记和清除两个过程的效率都不高，另一个就是，容易产生大量的内存碎片，碎片太多可能会导致没有足够的连续内存分配给较大的对象，从而提前触发新的GC。 复制算法把空间分为两个相等部分，每次只使用其中一部分，垃圾收集时，把存货的对象复制到另一部分，再把当前部分全部清理掉，这样不需要考虑碎片化问题，缺点就是可用内存变为了原来的一半。 标记-压缩算法新生代一半存活的对象比较少，可以使用复制算法，但是老年代不能选择复制算法了，因为老年代的对象存活率会较高，这样会有很多复制操作，导致效率降低。它的主要方式是，在标记可回收的对象后，将所有还存活的对象压缩到内存的一端，使它们紧凑地排列在一起，然后对边界外的内存进行回收。标记-压缩算法解决了标记-清除算法容易产生大量内存碎片的问题，但是它的效率仍然是很低的。 分代收集垃圾收集的类型分为两种，分别是： Minor Collection: 新生代垃圾收集 Full Collection: 老年代垃圾收集，也称 Major Collection， Full Collection 通常会伴随至少一次的 Minor Collection。 Full Collection 收集频率低，耗时长。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android进阶解密","slug":"Android进阶解密","permalink":"https://glassx.gitee.io/tags/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86/"}]},{"title":"面试题-算法-LeetCode-书籍-剑指offer","slug":"面试题-算法-LeetCode-书籍-剑指offer","date":"2019-11-15T12:58:00.000Z","updated":"2020-04-11T12:43:35.305Z","comments":true,"path":"2019/11/15/面试题-算法-LeetCode-书籍-剑指offer/","link":"","permalink":"https://glassx.gitee.io/2019/11/15/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-LeetCode-%E4%B9%A6%E7%B1%8D-%E5%89%91%E6%8C%87offer/","excerpt":"LeetCode-剑指offer系列面试题03、数组中重复的数字 点击看答案 HashSet 是否添加进去了 自己写的时候的问题：没啥，用hashset 搞定，但是忘了 new 关键字。。。 力扣 面试题04、二维数组中的查找 点击看答案 左下角标志法 自己写的时候的问题：自己写得完美，没问题。为了加深印象，我们说行数 rowNum = matrix.length; columnNum = matrix[0].length, 之后从左下角开始即可。","text":"LeetCode-剑指offer系列面试题03、数组中重复的数字 点击看答案 HashSet 是否添加进去了 自己写的时候的问题：没啥，用hashset 搞定，但是忘了 new 关键字。。。 力扣 面试题04、二维数组中的查找 点击看答案 左下角标志法 自己写的时候的问题：自己写得完美，没问题。为了加深印象，我们说行数 rowNum = matrix.length; columnNum = matrix[0].length, 之后从左下角开始即可。 力扣 面试题05、替换String空格 点击看答案 使用 StringBuilder 自己写的时候的问题：没啥问题，StringBuilder 疯狂拼接即可 力扣 面试题10-I、斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出，求第n个数，但是结果要对 1000000007，如计算初始结果为：1000000008，请返回 1。 点击看答案 使用 StringBuilder 自己写的时候的问题：大体上使用数组是对的，但是在做计算的时候写成了： arrs[i] = arrs[i - 1]%mod + arrs[i-2] % mod;，而实际上应该写成： arrs[i] = (arrs[i - 1] + arrs[i-2]) % mod; 以后要注意 力扣 还可以延伸青蛙跳台阶问题 面试题11、旋转数组的最小数字 点击看答案 二分法 自己写的时候的问题：没啥难，就是要注意细节，1、没有旋转的情况 2、所有数字都相同的情况 3、只有一个数字的情况 4、剩下的就是从后面往前面找，当到某一个数字它的前面一个数字比当前数字大的时候，那最小数字就是当前数字了。 力扣 面试题15、二进制中1的个数 点击看答案 n &amp; (n -1) 自己写的时候的问题：没啥，还是 n &amp; (n-1) 力扣 面试题18、删除链表的节点 点击看答案 两个指针 自己写的时候的问题：没啥，处理好head，之后就是常用的pre 指针、current 指针了 力扣 面试题21、 调整数组顺序使奇数位于偶数前面 点击看答案 首尾双指针 自己写的时候的问题：没啥，很顺利。双指针，快排思想 力扣 面试题22、 链表中倒数第k个节点 点击看答案 前后指针 自己写的时候的问题：没啥，快慢指针，快指针先走k步 力扣 面试题24、 反转链表。反转一个单链表，如输入： 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;Null ，则输出：5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;Null 点击看答案 存储当前节点和上一个节点 自己写的时候的问题：没啥，搞个pre LeetCode 面试题25、 合并两个排序的链表 点击看答案 一个链表到表尾之后，需要接上另一个表的剩余部分 自己写的时候的问题：没啥，造一个空节点 力扣 包含min函数的栈 点击看答案 两个栈，一个维持压入数据，一个维持最小数栈，注意相同最小值要都压入最小数栈 力扣 面试题39、 数组中出现次数超过一半的数字 点击看答案 既然出现次数超过一半 那么排序后在中间的就是所需数字 自己写的时候的问题：先排序后取值不难，但是时间复杂度太高，提交的时候耗时1.3s；使用hashMap 计数，也不难，只是略微繁琐，还有 HashMap 额外占用空间。要熟练 摩尔计数法，这才是最优解。 力扣 面试题40、最小的k个数 点击看答案 大顶堆 自己写的时候的问题：暂时还没做 还可以引申数据流中中位数 力扣 连续子数组的最大和 点击看答案 要么取大值，要么另起炉灶 自己写的时候的问题：与之前写的 力扣53题的答案，这次更加简洁粗暴，直接判断result &lt; 0 是否成立，成立就放弃result，否则就还让它继续 result += element;重点记住这个答案就好 力扣 面试题50、第一个只出现一次的字符 点击看答案 hashmap 存储次数 自己写的时候的问题：HashMap 辅助，没啥难度。在 字符出现次数 &gt; 1 的时候，不要尝试去增加它的次数，节省put 操作。 因为 2次 和 100次 对我们意义是一样的 力扣 面试题52、两个链表的第一个公共节点 点击看答案 两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。这样，当它们相遇时，所指向的结点就是第一个公共结点 自己写的时候的问题：刚开始脑抽只允许一个转换，其实 应该 A 和B两个链表应该各有一次转换机会。 力扣 面试题53 - I、在排序数组中查找数字 I，统计一个数字在排序数组中出现的次数 点击看答案 二分法 自己写的时候的问题：自己写没问题，二分查找没毛病。 力扣 面试题53 - II. 0～n-1中缺失的数字。一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字 点击看答案 解法1：与下标是否相等 解法2：求和？(要考虑溢出) 解法3：二分法 自己写的时候的问题：在数组下标都对应得上的时候，缺失的就是最后一个数字，写的时候没想到这点。 力扣 面试题56 - I、数组中数字出现的次数。一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1) 点击看答案 异或-&gt; 数字分组 自己写的时候的问题：不太熟练，自己只能想到全员异或，然后分组，之后想不到了。其实在分组过后，每组元素都是由 若干个出现两次的数字和一个只出现一次的数字 组成，组内异或就能得到那个只出现一次的数字。 力扣 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素 点击看答案 全员异或 力扣 面试题57、和为s的两个数字。输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可 点击看答案 双指针即可 自己写的时候的问题：没啥说的，提交完美。双指针即可 力扣 面试题58 - I、翻转单词顺序。输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I” 点击看答案 两次翻转 自己写的时候的问题：这题目本身就有点坑爹，注意审题，因为它首尾的空格要求在结果中去掉，并且单词间有多个空格也只保留一个。还有，清空StringBuilder 可以使用 sb.setLength(0) 的方式。其他的倒是没啥。 力扣 面试题58 - II、 左旋转字符串。字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab” 点击看答案 subString即可 自己写的时候的问题：没啥，StringBuilder 拼接，简单粗暴 leetcode 面试题59 - I、 滑动窗口的最大值。给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值 点击看答案 上一次的最大值是不是被滑过的位置 自己写的时候的问题：自己写，不难。充分利用好上一次的最大值即可 leetcode 面试题61、 扑克牌中的顺子。从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14 点击看答案 根据差值计算大小王是否够用就行 自己写的时候的问题：看懂原理，就不难(抄别人的)： 如果我们能够知道 5 张扑克牌中的最大值 maxValue 和最小值 minValue ，那我们就知道，要使它为顺子需要 maxValue - minValue + 1 张牌，所以我们只需要计算最大最小值(0除外)，然后通过上述规律来判断。当然，如果其中有重复的数字(0除外),那么肯定凑不齐了。所以我们关键是找最大最小值，以及判断是否重复。这里面的细节很多，比如boolean[] 用来表示元素是否重复的数组，它的index 不是 遍历牌的 i ，而是牌面值，即 nums[i] leetcode 面试题62、圆圈中最后剩下的数字。0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字 点击看答案 约瑟夫环，记得公式就行（返回的是数组下标） 12345678int cir(int n,int m)&#123; int p=0; for(int i=2;i&lt;=n;i++) &#123; p=(p+m)%i; &#125; return p;&#125; 题目leetcode、解答参考csdn 面试题65、不用加减乘除做加法。写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号 点击看答案 异或操作 自己写的时候的问题：凭记忆做出来了，后续还是要加强。 注意一点再java中不要做 &lt;&lt;&lt; 操作，非法的。 leetcode 面试题66、给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。 点击看答案 对称数组 自己写的时候的问题：似懂非懂 leetcode 66、加一，给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一，最高位存放在数组收尾，数组中每个元素只存储单个数字，可以假设除了0之外，这个整数不会以0开头。假如输入：[1,2,3] ，代表123，则输出 [1,2,4]；输入 [4,3,2,1] ，代表 4321，则输出 [4,3,2,2] 点击看答案 它只是加一的话，可能的情况只有两种： 除9之外的数字加一 数字9加一加一得十，进一位，个位数为0；如加法运算不出现进位，则运算就结束了。还有一种情况就是 当出现 9，99，999 之类的数字时，循环到最后也需要进位，需要手动将它进一位 自己写的时候的问题：没啥问题，遍历每个元素让每个元素 +1 ，当某个元素 +1 之后 &lt; 10,就将当前数组返回；否则，加到最后也还没返回，就要新建一个数组，最开始位为1 LeetCode","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"第4章：异步编程","slug":"Flutter从0到1构建大前端应用-第4章","date":"2019-11-13T13:48:00.000Z","updated":"2019-11-17T13:42:53.166Z","comments":true,"path":"2019/11/13/Flutter从0到1构建大前端应用-第4章/","link":"","permalink":"https://glassx.gitee.io/2019/11/13/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8-%E7%AC%AC4%E7%AB%A0/","excerpt":"异步编程在Flutter中，异步是使用 Future 来修饰的，并运行在 event loop 中，Flutter的异步特性和Android的Looper以及前端的 event loop 类似，都是不断地从事件队列里获取事件然后运行。isolate所有的 Dart 代码都是在 isolate 上运行的，通常情况下，我们的应用都是运作在 main isolate 中，必要时，我们可以创建新的 isolate ，以便更好地利用 CPU 。isolate 在Flutter 中是个很重要的概念，它是通过 Flutter Engine 层面的一个线程来实现的。除了 isolate 所在的线程以外，还有其他的线程，他们跟 Flutter 的线程模型(Threading Mode) 有关。","text":"异步编程在Flutter中，异步是使用 Future 来修饰的，并运行在 event loop 中，Flutter的异步特性和Android的Looper以及前端的 event loop 类似，都是不断地从事件队列里获取事件然后运行。isolate所有的 Dart 代码都是在 isolate 上运行的，通常情况下，我们的应用都是运作在 main isolate 中，必要时，我们可以创建新的 isolate ，以便更好地利用 CPU 。isolate 在Flutter 中是个很重要的概念，它是通过 Flutter Engine 层面的一个线程来实现的。除了 isolate 所在的线程以外，还有其他的线程，他们跟 Flutter 的线程模型(Threading Mode) 有关。 需要注意的是，多个 isolate 无法共享内存，必须通过相关 API 通信才可以。 event loop理解 event loop ，首先可以看下图： 图中运行的步骤如下： 运行 App并执行 main 方法。 开始并优先处理 microtask queue ，直到队列为空。 开始处理 event queue，如果里面有 event，则执行（每次只取一条），每执行一条再判断 microtask queue 是否有新的消息。 microtask queue 和 event queue 都为空，则 App 可以正常退出。 当处理 microtask queue 时，event queue 是会被阻塞的，所以 microtask queue 应当避免耗时操作，否则将导致 App 的绘制和交互被卡住。所以，绘制和交互等应该作为event存放在event queue中更合适。 线程模型与isolateisolate是通过Flutter Engine 层面的一个线程来实现的，Flutter Engine 线程的创建和管理是由 embedder(嵌入层) 负责的，embedder 是平台引擎移植的中间层代码，其运行架构如下： 它提供了4种Task Runner。 Platform Task Runner Platform Task Runner 是Flutter Engine 的主 Task Runner，不仅可以处理与 Engine 的交互，还可以处理来自 Native(Android/ios) 平台的交互。Flutter应用启动时会创建一个Engine实例，Engine会创建一个Platform Thread 供Platform Task Runner 使用。即使Platform Thread 被阻塞，也不会直接导致Flutter应用的卡顿，尽管如此，还是不建议在Platform Task Runner 里面执行繁重的耗时操作，因为长时间卡住Platform Thread ，应用可能会被系统的 Watchdog 强行终止。 UI Task Runner UI Task Runner 不能想当然地认为像Android那样运行在主线程，它其实运行在线程对应到平台的线程上的，属于子线程。在Root isolate 通知 Flutter Engine 有帧需要被渲染时，UI Task Runner 就会生成 Layer Tree 并交给 Flutter Engine。该Tree 最终决定什么内容会在屏幕上被绘制。因此，如果UI Task Runner 过载会导致卡顿。UI Task Runner 还可以处理来自 Native plugin 的消息、timers、microtasks、异步I/O操作。 GPU Task Runner GPU Task Runner 被用于执行与设备GPU相关的调用，它运行的线程对应着平台的子线程，它可以将 UI Task Runner 生成的 Layer Tree 所提供的信息转化为实际的GPU指令。GPU Task Runner 会根据目前帧被执行的进度向 UI Task Runner 要求下一帧数据，这样可以避免 UI Task Runner 不必要的消耗。GPU Task Runner 任务过重会造成Flutter应用卡顿。 IO Task Runner IO Task Runner 也对应着平台的子线程。当UI Task Runner 和 GPU Task Runner 都出现过载时，Flutter应用卡顿，IO Task Runner 会负责做一些预处理的读取工作，然后再上报给 GPU Task Runner，相当于 GPU Task Runner 的助手，助其减少额外工作。 Stream事件流略","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Flutter从0到1构建大前端应用","slug":"Flutter从0到1构建大前端应用","permalink":"https://glassx.gitee.io/tags/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/"}]},{"title":"面试题-多线程知识","slug":"面试题-多线程知识","date":"2019-11-11T13:02:00.000Z","updated":"2020-06-27T07:10:25.631Z","comments":true,"path":"2019/11/11/面试题-多线程知识/","link":"","permalink":"https://glassx.gitee.io/2019/11/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86/","excerpt":"1、线程同步，你了解哪几种方式？ 点击看答案 数据同步：可以使用Android 提供的同步容器。如： CopyOnWriteArrayList（当某个线程要修改list的元素时，首先copy一份出来，然后在修改前加锁，防止多个线程同时修改而copy多个副本，读的时候无需加锁，读的是副本）、concurrentHashMap（分段锁）、BlockingQueue（队列满了，在调用put，会阻塞，直到不再是满的；同理，取也是一样）。 用锁。同步锁：synchronize（无论synchronized关键字加在方法上还是对象上，他锁的都是对象，而不是把一段代码或函数当作锁）、ReentrantLock","text":"1、线程同步，你了解哪几种方式？ 点击看答案 数据同步：可以使用Android 提供的同步容器。如： CopyOnWriteArrayList（当某个线程要修改list的元素时，首先copy一份出来，然后在修改前加锁，防止多个线程同时修改而copy多个副本，读的时候无需加锁，读的是副本）、concurrentHashMap（分段锁）、BlockingQueue（队列满了，在调用put，会阻塞，直到不再是满的；同理，取也是一样）。 用锁。同步锁：synchronize（无论synchronized关键字加在方法上还是对象上，他锁的都是对象，而不是把一段代码或函数当作锁）、ReentrantLock 2、synchronized 与 Lock。讲下 RecentLock 可重入锁？ 什么是可重入锁？为什么要设计可重入锁？ 点击看答案 介绍：synchronized：无论synchronized关键字加在方法上还是对象上，他锁的都是对象，而不是把一段代码或函数当作锁。Lock：一般使用ReentrantLock类做为锁，需要显式指出加锁与释放锁的位置，在加锁和解锁处通过lock()和unlock()显示指出，所以一般会在finally块中写unlock()以防死锁。 区别： synchronized 是个关键字，而 Lock 是个接口 synchronized 使用简单，会自动释放；Lock需要显式加锁与释放，要防止死锁 synchronized是悲观锁，其他线程只能阻塞来等待线程释放锁；Lock是乐观锁。 lock可以使我们多线程交互变得方便，而使用synchronized则无法做到这点。如：某个线程在等待锁的过程中需要中断、或者获知某个线程有没有获取到锁、或者需要指定notify哪个线程 3、为什么wait、notify、notifyAll 方法在object 类中，而sleep 在Thread 类中？ 点击看答案 一个例子，假如要做的事情是“生火-烧水-煮面”。sleep 就是，当我生火之后，觉得有点累，要休息一段时间，所以并不立即烧水，等过会再烧，休息的这段时间是由我自己来控制的，这个灶台我也要一直占用；而对于wait，首先，wait 是由某个object 来调用的，这个object 类似于监督人的角色，当我点火在烧水的过程中，监督人要求我停下来，不允许我继续烧水了，同时剥夺我灶台使用权，让其他人先用灶台，我在旁边等着，直到这个监督人通知(notify/notifyAll)我可以继续使用灶台了，我才能继续。 通过这个例子，我们可以知道： 首先，sleep 和 其他的是有本质区别的：sleep 是一个线程的运行状态控制，所以交给Thread 自己更合适；而wait 是线程之间的通讯工具，交给object更合适，这样各个竞争线程不需要知道彼此的存在。 其次，wait、notify与notifyAll 是锁级别的操作，而锁属于对象，每个对象都可能作为锁，所以它们定义在Object 类中。 从另一个角度来说是，假如不这样做的话，即如果wait、notify和notifyAll 都在Thread 中，会有什么问题： 首先，wait 方法仍然可以使当前线程挂起，但是挂起后怎么被其他线程唤起呢？因为唤起时需要知道要唤起哪个线程。其次，notify 与 notifyAll 都需要知道目前需要唤醒哪些线程。 当然你可以说我们使用共享变量或者其他方式，这无疑会增加线程间通信的复杂性，并带来安全隐患，所以并没有必要。 值得注意的是：必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()、notify()或notifyAll()方法。原因很简单，如果这个代码块或者方法不是同步的，那么进入其中必然是不需要获取锁的，所以释放锁和等待锁就无从谈起，这时候调用的话会报 IllegalMonitorStateException。Java 给报这个错，其实就是不想让我们的程序在不经意间出现 Lost Wake-Up 问题。 以上内容参考csdn的这篇文章 4、延伸-深究 notify/wait 方法为什么一定要放在同步块中？ 点击看答案 前面谈到的是没有同步就没必要释放或者等待锁，这里深究如果不放在同步块中会出现什么问题。这主要是涉及到 “Lost Wake-Up Problem”问题。 我们notify/wait 很典型的一个用途就是生产者-消费者 场景，伪代码如下： 生产者： count ++;notify(); 消费者： while(count &lt;= 0) wait();count –; 生产者和消费着都有两个步骤，如果不在同步块中的话，多线程情况下执行顺序很难保证，有可能会出现如下图所示的执行顺序： 初始的时候，count == 0，消费者发现条件成立，此时，发生上下文切换，生产者线程一顿操作执行了 count ++，之后发出了通知准备唤醒一个线程，这时候消费者刚决定wait，但是还没进入wait，此时，由于消费者线程还未进入wait状态，因此在等待队列中还找不到消费者线程，这个notify就被丢掉了。 以上内容参考自360linker的博客 5、两个线程交替打印，一个输出偶数，一个输出奇数 点击看答案 第一种，使用synchronize 关键字，锁住对象，每次只能一个线程进入。每打印一个数，就释放锁，然后挂起自己，如此往复： 12345678910111213141516171819202122232425262728293031323334353637public class MainClass &#123; public static void main(String[] args) &#123; MainClass obj = new MainClass(); Thread t1 = new Thread(obj::printOdds); Thread t2 = new Thread(obj::printEven); t2.start(); t1.start(); &#125; public synchronized void printOdds() &#123; for (int i = 1; i &lt;= 100; i += 2) &#123; System.out.println(\"t1---\" + i); notify(); try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public synchronized void printEven() &#123; for (int i = 0; i &lt;= 100; i += 2) &#123; System.out.println(\"t2---\" + i); this.notify(); try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 第二种，使用volatile 来保证: 12345678910111213141516171819202122232425262728293031323334353637public class MainClass &#123; static volatile int num = 0; static volatile boolean flag = false; public static void main(String[] args) &#123; Thread t1 = new Thread()&#123; @Override public void run() &#123; super.run(); for (;num&lt;=100;)&#123; if (!flag &amp;&amp; (num == 0 || ++num %2 == 0))&#123;//打印偶数 System.out.println(num); flag = true; &#125; &#125; &#125; &#125;; Thread t2 = new Thread()&#123; @Override public void run() &#123; super.run(); for (;num&lt;100;)&#123; if (flag &amp;&amp; ++num %2 != 0)&#123;//打印奇数 System.out.println(num); flag = false; &#125; &#125; &#125; &#125;; t1.start(); t2.start(); &#125;&#125; 上述代码中 num 和flag 都必须为volatile ，根据短路机制，if 语句中基本上只需要管 flag的值，所以即使 ++num 这个操作是非原子性的，也无妨。 以上内容参考莫那.鲁道的博客 如何控制某个方法允许并发访问线程的个数？ 6、Java创建线程的三种方式 点击看答案 继承Thread类。优点：使用简单 缺点：已经继承Thread 类，不能继承其它类。 实现runnable 接口，创建线程类。 通过Callable 和 Future 创建线程。 以上内容参考自：Java创建线程的三种方式 7、synchronized原理 点击看答案 JVM基于进入和退出Monitor对象来实现 代码块同步 和 方法同步 ，两者实现细节不同。 代码块同步： 在编译后通过将monitorenter指令插入到同步代码块的开始处，将monitorexit指令插入到方法结束处和异常处，通过反编译字节码可以观察到。任何一个对象都有一个monitor与之关联，线程执行monitorenter指令时，会尝试获取对象对应的monitor的所有权，即尝试获得对象的锁。 方法同步： synchronized方法在method_info结构有ACC_synchronized标记，线程执行时会识别该标记，获取对应的锁，实现方法同步。 两者虽然实现细节不同，但本质上都是对一个对象的监视器（monitor）的获取。任意一个对象都拥有自己的监视器，当同步代码块或同步方法时，执行方法的线程必须先获得该对象的监视器才能进入同步块或同步方法，没有获取到监视器的线程将会被阻塞，并进入同步队列，状态变为BLOCKED。当成功获取监视器的线程释放了锁后，会唤醒阻塞在同步队列的线程，使其重新尝试对监视器的获取。 以上内容参考自：synchronized原理 8、线程间通信？ 点击看答案 1、通过内存共享，共享内存中的信息是公共可见的，但是需要显式地进行同步，可以使用Synchronize 和 Lock 来进行同步。 2、notify/wait 方法 3、Condition 实现等待/通知 以上内容部分参考自： 线程通信 9、单例中，为什么要使用volatile 修饰instance？ 点击看答案 主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情: 1.给 instance 分配内存2.调用 Singleton 的构造函数来初始化成员变量3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。 10、有三个线程T1，T2，T3，怎么确保它们按顺序执行？ 点击看答案 参考2个线程的即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MainClass1 &#123; static volatile int num = 0; static volatile int flag = 1; public static void main(String[] args) &#123; Thread t1 = new Thread()&#123; @Override public void run() &#123; super.run(); for (;num&lt;=100;)&#123; if (flag == 1)&#123; ++num; System.out.println(\"t1-\"+ num); flag = 2; &#125; &#125; &#125; &#125;; Thread t2 = new Thread()&#123; @Override public void run() &#123; super.run(); for (;num&lt;100;)&#123; if (flag == 2)&#123; ++num; System.out.println(\"t2-\"+ num); flag = 3; &#125; &#125; &#125; &#125;; Thread t3 = new Thread()&#123; @Override public void run() &#123; super.run(); for (;num&lt;100;)&#123; if (flag == 3)&#123; ++num; System.out.println(\"t3-\"+ num); flag = 1; &#125; &#125; &#125; &#125;; t1.start(); t2.start(); t3.start(); &#125;&#125; 11、Java停止一个正在运行的线程 点击看答案 采用经过volatile 标记的变量来控制 Thread.stop() ，但是不推荐 使用FutureTash 时，可以使用其 cancel() 方法来取消任务 使用return 关键字 123456789101112131415new Thread()&#123; @Override public void run() &#123; super.run(); System.out.println(\"开始执行\"); if (true)&#123; return; &#125; System.out.println(\"return 之后\"); &#125; &#125;.start();&#125; 代码只会打印 “开始执行” ，代码中if是需要的，不然会提示编译不通过。 以上部分内容参考自：Java如何停止线程 12、Java线程池工作原理 点击看答案 线程池好处 复用已经创建的线程，降低线程创建和销毁带来的损耗 提高响应速度。当任务到达时，可以复用已有线程，无需等到线程创建就能立即执行 提高线程的可管理性。线程是稀缺资源，如果无限制创建，不仅消耗系统资源，延长线程等待时间，还可能降低系统稳定性。 线程的几种状态 新建状态(New)：新建一个线程对象 就绪状态(Runnable)：调用线程的 start() 方法，线程变成可运行状态，其他资源都已经获取，只等cpu了 运行状态(Running)：就绪状态的线程获取CPU，执行 阻塞状态(Blocked)：由于某种原因放弃cpu使用权。可能是调用了线程的 wait() 方法、或者等待获取同步锁、或者是执行了sleep()或者其他线程执行了 join() 死亡状态(Dead)：线程执行完了或者因为一场退出run() 以上代码参考自：java线程池 13、死锁条件 点击看答案 产生死锁的四个条件（满足才会死锁）： 互斥使用 不可剥夺 请求保持 循环等待 破坏任意一个条件即可解锁 14、引申-写个简单的死锁程序 点击看答案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void main(String[] args) &#123; Object lock1 = new Object(); Object lock2 = new Object(); Thread thread1 = new Thread(\"thread1\")&#123; @Override public void run() &#123; super.run(); synchronized (lock1)&#123; System.out.println(Thread.currentThread().getName() + \"进入第1层锁\"); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock1)&#123; System.out.println(Thread.currentThread().getName() + \"进入第2层锁\"); &#125; &#125; &#125; &#125;; Thread thread2 = new Thread(\"thread1\")&#123; @Override public void run() &#123; super.run(); synchronized (lock2)&#123; System.out.println(Thread.currentThread().getName() + \"进入第1层锁\"); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock2)&#123; System.out.println(Thread.currentThread().getName() + \"进入第2层锁\"); &#125; &#125; &#125; &#125;; thread1.start(); thread2.start(); &#125; 15、synchronized 关键字 点击看答案 当执行如下代码： 12345public void method() &#123; synchronized (this) &#123; System.out.println(\"Method 1 start\"); &#125;&#125; 反编译之后能看到 monitorenter 和 monitorexit 字样，关于这两条指令，jvm中的解释如下： 每个对象都有一个监视器锁(monitor)，当monitor 被占用时就处于锁定状态，线程执行 monitorenter 指令时，就尝试获取 monitor的所有权，过程如下： 1、如果 monitor 的进入数为 0 ，则该线程进入 monitor，然后将进入数设置为 1，即该现成为 monitor 的所有者。 2、如果有线程已经占有 monitor ，之后又重新进入，则 monitor 的进入数加 1。 3、如果其他线程已经占用了 monitor ，则当前线程进入阻塞状态，直到 monitor 的进入数为 0(之后被唤醒)，再重新获取 monitor 的所有权。 反之，monitorexit 则是线程退出的一个过程。 所以我们知道，修饰代码块时，synchronized 底层是通过 monitor 对象来完成的，其实，wait/notify方法也是依赖于 monitor 对象的，这也是为什么只有再同步块中才能调用 wait/notify 等方法(因为wait 等待的是啥？其实等待的就是对象的 monitor，由于所有类都是object ，里面内置有一个 monitor，因此自然所有类都应该有 wait/notify 方法)。 在修饰成员方法时，如下代码所示： 123public synchronized void method() &#123; System.out.println(\"Hello World!\");&#125; 反编译过后就会有 ACC_SYNCHRONIZED 标识符(没有用 monitorenter 和 monitorexit，其实理论上也是可以的)，jvm 根据这个标识符来实现方法同步：当调用方法时，首先检查方法的 ACC_SYNCHRONIZED 标志是否被设置，如果设置了，则线程首先获取 monitor，获取成功后才能执行方法，方法执行完成后再释放 monitor，方法执行期间，其他对象无法再获得同一个 monitor。所以与修饰 代码块 的时候本质上是没有区别的。 最后，如果修饰的是静态方法，则锁定的是 class 对象。 以上内容参考自：Synchronized及其实现原理 16、synchronized 锁持有的object 是Thread 对象 点击看答案 看过上面synchronized原理，我们来看一段代码： 123456789101112131415161718192021222324public static void main(String[] args) &#123; Thread threadTest = new Thread() &#123; public void run() &#123; System.out.println(\"执行线程中方法\"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; threadTest.start(); synchronized (threadTest) &#123;//这里不明白可以想象单例的 synchronized 用法 try &#123; threadTest.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"执行到了这里\");&#125; 我们知道，wait 必须在同步块中执行，上述代码也是这样的；同时我们也知道，wait() 方法后，必须收到 notify/notifyAll 之后才能结束等待状态。但是上述代码首先输出 “执行线程中方法” ，之后输出 “执行到了这里” ，明明没有notify ，怎么就能结束 wait 状态呢？其实这是因为synchronized 获得对象锁是 Thread 对象的锁时，当该线程执行完成后，会调用线程自身的 notifyAll() 方法，通知所有等待在该线程对象上的线程。所以，用这种方式能够实现 join 的功能，使得线程依次执行。 以上内容参考自csdn上的博客 17、引申-理解Java 中的 join 点击看答案 如果要用join 方法实现上述功能，可以这样： 123456789101112131415161718192021public static void main(String[] args) &#123; Thread threadTest = new Thread() &#123; public void run() &#123; System.out.println(\"执行线程中方法\"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; threadTest.start(); try &#123; threadTest.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"执行到了这里\");&#125; join 方法从字面上理解就是新线程加入进来，等新线程执行完后，老的线程才继续执行。我们日常使用 join 方法是通过 join(0) 来实现的，我们看它的源码： 1234567891011121314151617181920212223 public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (millis == 0) &#123; //如果时执行的join(0) while (isAlive()) &#123; //如果线程是运行状态，就会执行下面的等待 wait(0); &#125; &#125; else &#123; //如果是执行的join(time) while (isAlive()) &#123; //如果线程时运行状态 long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); //等待delay时间后自动返回继续执行 now = System.currentTimeMillis() - base; &#125; &#125;&#125; 其中 while (isAlive()) { wait(0) } ，我们日常调用的 wait() 方法就是调用的 wait(0) 实现，因此这里本质还是 执行了 wait 方法，就是让其一直等待。所以我们上述代码： threadTest.join() 本质是利用 threadTest 对象作为对象锁，当线程终止时，会调用线程自身的 notifyAll ，因此这个 wait 就解除了。 再说下 while (isAlive())，这是在判断线程是否线程是否已经执行了start() 方法，因此如果还没有start() 则不会执行wait() 方法。可以用如下代码验证： 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; final Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"t1\"); &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"t2\"); &#125; &#125;); t2.start();//先启动t2 try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t1.start();//延迟2秒后启动t1&#125; 这段代码看起来执行了 t1.join() ，应该要等t1执行完了才会执行t2，但是呢，这里最终输出： t2 t1 ，即 t2 还是会先执行。这是因为在执行 t1.join() 的时候，t1并没有执行 start() ，isAlive() 为false，因此不生效。 以上内容参考自csdn上的博客 18、wait/sleep/yield/join 方法 点击看答案 wait() 方法的作用是将当前线程挂起，让其进入阻塞状态，直到 notify/notifyAll 方法来唤醒线程，很容易理解，wait 是释放了锁资源的。 wait(long timeout)方法与 wait 相似，区别在于如果再指定时间内没有被notify/notifyAll ，则自动唤醒。 sleep方法只是暂时让出cpu执行权，并不释放锁，而 wait 是释放锁的。 yield 方法只是暂停当前线程，以便其他线程有机会运行，不过不能指定暂停时间，也不能保证当前线程立即停止。yield 方法只是将thread 的状态由 Running 转变为 Runable 状态。不过调度器可能会忽略这个方法，并且Java官方建议只用这个方法用于调试和测试。 join 方法是父线程等待子线程执行完之后再执行。 以上内容参考自cnblogs的博客 19、实现线程安全的方法（三种） 点击看答案 互斥同步 指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个(再使用信号量的时候可以是一些)线程使用，Java中典型的互斥同步手段是 synchronized 关键字，以及 ReentrantLock 类。 非阻塞同步 互斥同步主要的问题就是线程阻塞和唤醒带来的性能问题，因此也称为阻塞同步。非阻塞同步就是先进行操作，如果没有其它线程争用共享数据，操作就成功了，否则产生冲突再补偿(比如自旋不断重试，直到成功为止)，这种乐观方式无需把线程挂起和唤醒，CAS 的出现也为非阻塞同步提供了条件。 无同步方案 如果方法本来就没有涉及共享数据，每次输入相同的数据就能得到相同的输出，这种情况当然无需进行同步。 20、死锁 点击看答案 产生死锁的四个条件（满足才会死锁）： 互斥使用 不可剥夺 请求保持 循环等待 破坏任意一个条件即可解锁 21、引申-写个简单的死锁程序 点击看答案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void main(String[] args) &#123; Object lock1 = new Object(); Object lock2 = new Object(); Thread thread1 = new Thread(\"thread1\")&#123; @Override public void run() &#123; super.run(); synchronized (lock1)&#123; System.out.println(Thread.currentThread().getName() + \"进入第1层锁\"); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock1)&#123; System.out.println(Thread.currentThread().getName() + \"进入第2层锁\"); &#125; &#125; &#125; &#125;; Thread thread2 = new Thread(\"thread1\")&#123; @Override public void run() &#123; super.run(); synchronized (lock2)&#123; System.out.println(Thread.currentThread().getName() + \"进入第1层锁\"); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock2)&#123; System.out.println(Thread.currentThread().getName() + \"进入第2层锁\"); &#125; &#125; &#125; &#125;; thread1.start(); thread2.start(); &#125; 22、synchronized 关键字 点击看答案 当执行如下代码： 12345public void method() &#123; synchronized (this) &#123; System.out.println(\"Method 1 start\"); &#125;&#125; 反编译之后能看到 monitorenter 和 monitorexit 字样，关于这两条指令，jvm中的解释如下： 每个对象都有一个监视器锁(monitor)，当monitor 被占用时就处于锁定状态，线程执行 monitorenter 指令时，就尝试获取 monitor的所有权，过程如下： 1、如果 monitor 的进入数为 0 ，则该线程进入 monitor，然后将进入数设置为 1，即该现成为 monitor 的所有者。 2、如果有线程已经占有 monitor ，之后又重新进入，则 monitor 的进入数加 1。 3、如果其他线程已经占用了 monitor ，则当前线程进入阻塞状态，直到 monitor 的进入数为 0(之后被唤醒)，再重新获取 monitor 的所有权。 反之，monitorexit 则是线程退出的一个过程。 所以我们知道，修饰代码块时，synchronized 底层是通过 monitor 对象来完成的，其实，wait/notify方法也是依赖于 monitor 对象的，这也是为什么只有再同步块中才能调用 wait/notify 等方法(因为wait 等待的是啥？其实等待的就是对象的 monitor，由于所有类都是object ，里面内置有一个 monitor，因此自然所有类都应该有 wait/notify 方法)。 在修饰成员方法时，如下代码所示： 123public synchronized void method() &#123; System.out.println(\"Hello World!\");&#125; 反编译过后就会有 ACC_SYNCHRONIZED 标识符(没有用 monitorenter 和 monitorexit，其实理论上也是可以的)，jvm 根据这个标识符来实现方法同步：当调用方法时，首先检查方法的 ACC_SYNCHRONIZED 标志是否被设置，如果设置了，则线程首先获取 monitor，获取成功后才能执行方法，方法执行完成后再释放 monitor，方法执行期间，其他对象无法再获得同一个 monitor。所以与修饰 代码块 的时候本质上是没有区别的。 最后，如果修饰的是静态方法，则锁定的是 class 对象。 以上内容参考自：Synchronized及其实现原理 23、synchronized 锁持有的object 是Thread 对象 点击看答案 看过上面synchronized原理，我们来看一段代码： 123456789101112131415161718192021222324public static void main(String[] args) &#123; Thread threadTest = new Thread() &#123; public void run() &#123; System.out.println(\"执行线程中方法\"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; threadTest.start(); synchronized (threadTest) &#123;//这里不明白可以想象单例的 synchronized 用法 try &#123; threadTest.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"执行到了这里\");&#125; 我们知道，wait 必须在同步块中执行，上述代码也是这样的；同时我们也知道，wait() 方法后，必须收到 notify/notifyAll 之后才能结束等待状态。但是上述代码首先输出 “执行线程中方法” ，之后输出 “执行到了这里” ，明明没有notify ，怎么就能结束 wait 状态呢？其实这是因为synchronized 获得对象锁是 Thread 对象的锁时，当该线程执行完成后，会调用线程自身的 notifyAll() 方法，通知所有等待在该线程对象上的线程。所以，用这种方式能够实现 join 的功能，使得线程依次执行。 以上内容参考自csdn上的博客 24、引申-理解Java 中的 join 点击看答案 如果要用join 方法实现上述功能，可以这样： 123456789101112131415161718192021public static void main(String[] args) &#123; Thread threadTest = new Thread() &#123; public void run() &#123; System.out.println(\"执行线程中方法\"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; threadTest.start(); try &#123; threadTest.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"执行到了这里\");&#125; join 方法从字面上理解就是新线程加入进来，等新线程执行完后，老的线程才继续执行。我们日常使用 join 方法是通过 join(0) 来实现的，我们看它的源码： 1234567891011121314151617181920212223 public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (millis == 0) &#123; //如果时执行的join(0) while (isAlive()) &#123; //如果线程是运行状态，就会执行下面的等待 wait(0); &#125; &#125; else &#123; //如果是执行的join(time) while (isAlive()) &#123; //如果线程时运行状态 long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); //等待delay时间后自动返回继续执行 now = System.currentTimeMillis() - base; &#125; &#125;&#125; 其中 while (isAlive()) { wait(0) } ，我们日常调用的 wait() 方法就是调用的 wait(0) 实现，因此这里本质还是 执行了 wait 方法，就是让其一直等待。所以我们上述代码： threadTest.join() 本质是利用 threadTest 对象作为对象锁，当线程终止时，会调用线程自身的 notifyAll ，因此这个 wait 就解除了。 再说下 while (isAlive())，这是在判断线程是否线程是否已经执行了start() 方法，因此如果还没有start() 则不会执行wait() 方法。可以用如下代码验证： 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; final Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"t1\"); &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"t2\"); &#125; &#125;); t2.start();//先启动t2 try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t1.start();//延迟2秒后启动t1&#125; 这段代码看起来执行了 t1.join() ，应该要等t1执行完了才会执行t2，但是呢，这里最终输出： t2 t1 ，即 t2 还是会先执行。这是因为在执行 t1.join() 的时候，t1并没有执行 start() ，isAlive() 为false，因此不生效。 以上内容参考自csdn上的博客 25、wait/sleep/yield/join 方法 点击看答案 wait() 方法的作用是将当前线程挂起，让其进入阻塞状态，直到 notify/notifyAll 方法来唤醒线程，很容易理解，wait 是释放了锁资源的。 wait(long timeout)方法与 wait 相似，区别在于如果再指定时间内没有被notify/notifyAll ，则自动唤醒。 sleep方法只是暂时让出cpu执行权，并不释放锁，而 wait 是释放锁的。 yield 方法只是暂停当前线程，以便其他线程有机会运行，不过不能指定暂停时间，也不能保证当前线程立即停止。yield 方法只是将thread 的状态由 Running 转变为 Runable 状态。不过调度器可能会忽略这个方法，并且Java官方建议只用这个方法用于调试和测试。 join 方法是父线程等待子线程执行完之后再执行。 以上内容参考自cnblogs的博客 26、Java 中锁的种类 点击看答案 大概可以分类为： 乐观锁、悲观锁 独享锁、共享锁 公平锁、非公平锁 互斥锁、读写锁 可重入锁 分段锁 其中乐观锁认为线程基本上是没有竞争的，一般采用CAS机制实现，悲观锁认为一个线程获取数据时，一定会有其他数据对数据进行更改，它的实现就是加锁，比如 synchronize 关键字 至于独享锁：一次只能被一个线程拥有，ReentrantLock 这个可重入锁也是独享锁。而共享锁可以被多个线程持有，比如：ReentrantReadWrite 中的读锁ReadLock 是共享锁，写锁WriteLock 是独享锁。 互斥锁的具体实现就是 synchronized、ReentrantLock 等实现；读写锁具体实现就是 ReadWriteLock。 可重入锁：对于同一个线程，在外层方法获取锁的时候，在进入内层方法也会自动获取锁。 公平锁：多线程竞争时排队，按照申请顺序获取锁；非公平锁：竞争时，先尝试插队，失败再排队。 分段锁：并不是一种锁，只是细化锁的粒度。 以上内容参考自知乎上的内容 27、Java 中锁优化的方式 点击看答案 自旋锁与自适应自旋(主要解决互斥同步挂起和恢复需要转入内核态的问题。引入的自适应自旋，意味着自旋时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定的，因为如果在同一个锁对象上，自旋等待刚获得过锁，并且持有锁的线程正在运行，那么虚拟机认为当前自旋也很有可能再次成功，进而允许自旋等待更长时间) 锁消除（虚拟机对于检测到不可能存在共享的数据进行锁消除） 锁消除(一般来说，加锁同步块区域尽量小，只锁真正共享的区域，以便在锁竞争的时候，能尽快释放。但是如果一系列的连续操作对同一个对象频繁反复加锁解锁，甚至是出现在循环体中，那就会导致不必要的性能损耗，典型的就是在 循环中执行StringBuilder 的append操作) 轻量级锁（如果同步对象没有被锁定，虚拟机首先将将在当前线程的栈帧中建立一个名为锁记录-Lock Record 的空间，用于存储锁对象目前的 Mark Word的拷贝，然后虚拟机使用CAS操作尝试把对象的Mark Word 更新为指向 Lock Record 的指针，如果更新成功了，则代表线程拥有了这个对象的锁，对象Mark Word的锁标志也会标记为 “00”，即轻量级锁状态。如果这个cas操作失败，则意味着至少存在一条线程竞争，此时检查Mark Word 是否指向当前线程的栈帧，如果是，则说明已经拥，有了，直接进入同步块即可。否则，如果有两条以上线程争用一个锁，则必须膨胀微重量级锁。轻量级锁的依据是，“对于绝大部分锁，在整个同步周期内是不存在竞争的”，如果没有竞争，则轻量级锁通过CAS操作避免了使用互斥量的开销；当然，如果存在竞争，除了互斥量本身之外，还发生了CAS开销，反而更慢了） 偏向锁（它的目的是在无竞争的情况下消除CAS操作，进一步提升性能。当锁对象第一次被线程获取的时候，就将对象头中的偏向模式置为 “1”,即偏向模式，同时使用CAS操作把获取这个锁的线程的ID记录在Mark word 中，如果操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块都不需要进行同步操作，不过，一旦出现另外一个线程尝试去获取这个锁的情况，偏向模式马上结束。根据锁对象目前是否处于锁定状态来决定是否撤销偏向、恢复到未锁定或者轻量级锁定状态） 以上内容参考自《深入理解Java虚拟机-第三版》","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题-Android基础","slug":"面试题-Android基础","date":"2019-11-09T13:25:00.000Z","updated":"2021-02-09T07:45:14.210Z","comments":true,"path":"2019/11/09/面试题-Android基础/","link":"","permalink":"https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Android%E5%9F%BA%E7%A1%80/","excerpt":"1、是否可以在子线程更新UI 点击看答案 今天看到网上有人较真，说Android中，你可以在子线程更新UI，于是我写了如下测试代码： 12345678910override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val textView = findViewById&lt;TextView&gt;(R.id.text_view) val runnable = Runnable &#123; textView.setText(\"new text\") &#125; Thread(runnable).start() 在子线程中更新EditText的文字居然成功！其实，在主线程修改UI，这属于一个“建议”而不是“标准”，因为如果在子线程定义UI的修改，无法预料到UI会被如何修改。 一言以蔽之：View之所以不能在子线程做UI操作，是因为在 ViewRootImpl 里面会做线程检测，而在onCreate 的时候，ViewRootImpl 还没初始化。 settext的调用流程大概会经历如下步骤： TextView 的 checkForRelayout() 方法 TextView 的 invalidate() 方法 View 的 invalidate() 方法 View 的 invalidateInternal() 方法 ViewGroup(ViewParent) 的 invalidateChild() 方法(不断loop取上一个节点的mParent，然后DecorView 的mParent 是 ViewRootImpl ) 即一直调用到 ViewRootImpl 的 invalidateChild() 最终在 ViewRootImpl 中会 checkThread()检查线程 在ViewGroup 的 invalidateChild() 中，会判断 AttachInfo 是否为空，而在Activity 的 onCreate的时候，Activity 还在初始化，ImageView的mAttachInfo 是空的，所以在ViewGroup 中就直接没执行下去了，而settext 早就发生了，因此，就略过了检查线程这一阶段。","text":"1、是否可以在子线程更新UI 点击看答案 今天看到网上有人较真，说Android中，你可以在子线程更新UI，于是我写了如下测试代码： 12345678910override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val textView = findViewById&lt;TextView&gt;(R.id.text_view) val runnable = Runnable &#123; textView.setText(\"new text\") &#125; Thread(runnable).start() 在子线程中更新EditText的文字居然成功！其实，在主线程修改UI，这属于一个“建议”而不是“标准”，因为如果在子线程定义UI的修改，无法预料到UI会被如何修改。 一言以蔽之：View之所以不能在子线程做UI操作，是因为在 ViewRootImpl 里面会做线程检测，而在onCreate 的时候，ViewRootImpl 还没初始化。 settext的调用流程大概会经历如下步骤： TextView 的 checkForRelayout() 方法 TextView 的 invalidate() 方法 View 的 invalidate() 方法 View 的 invalidateInternal() 方法 ViewGroup(ViewParent) 的 invalidateChild() 方法(不断loop取上一个节点的mParent，然后DecorView 的mParent 是 ViewRootImpl ) 即一直调用到 ViewRootImpl 的 invalidateChild() 最终在 ViewRootImpl 中会 checkThread()检查线程 在ViewGroup 的 invalidateChild() 中，会判断 AttachInfo 是否为空，而在Activity 的 onCreate的时候，Activity 还在初始化，ImageView的mAttachInfo 是空的，所以在ViewGroup 中就直接没执行下去了，而settext 早就发生了，因此，就略过了检查线程这一阶段。 2、延伸-子线程更新UI骚操作-在子线程启动 Dialog 点击看答案 我们可以看下 ViewRootImpl 中的 构造函数 和 checkThread() 方法： 123456789101112131415161718//构造函数public ViewRootImpl(Context context, Display display) &#123; mContext = context; mWindowSession = WindowManagerGlobal.getWindowSession(); mDisplay = display; mBasePackageName = context.getBasePackageName(); mThread = Thread.currentThread(); ...&#125; //checkThread 方法void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views.\"); &#125; &#125; 可以发现，这里并不是要求什么主线程(UI线程)，而是只要当前线程和ViewRootImpl/Window/View 的创建线程是同一个线程就ok,所以，只要在子线程中创建的View，就能在那个子线程更新UI，试试如下代码(我自己亲测可以运行)： 12345678val runnable = Runnable &#123; Looper.prepare() val dialog = MyDialog(this@MainActivity) dialog.show() Looper.loop() &#125; Thread(runnable).start() LruCache 原理 点击看答案 LRU(Least Recently Used，最近最少使用) 缓存算法就是为缓存设计的，它的思想就是当缓存满时，会优先淘汰那些最近最少使用的缓存对象。LruCache 就是Android 基于 LRU 算法给的一个缓存类。 LruCache 的核心就是维护一个缓存对象列表，其中对象按照访问顺序实现的，即一致没访问的对象，将放在队尾，首先被淘汰，最近访问的对象放在队头，最后淘汰。如下图所示： 这里面的队列是由LinkedHashMap 来维护的，前面已经介绍过它的实现原理了，他有个构造函数是这样的： public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder) 最后一个参数 accessOrder 用来表示LinkedHashMap 中双向链表的顺序是插入顺序还是访问顺序，举个例子： 12345678910111213141516171819@JvmStaticfun main(args: Array&lt;String&gt;) &#123; val linkedHashMap = LinkedHashMap&lt;Int,Int&gt;(0,0.75f,true) linkedHashMap[0] = 0 linkedHashMap[1] = 1 linkedHashMap[2] = 2 linkedHashMap[3] = 3 linkedHashMap[4] = 4 linkedHashMap[5] = 5 val ar1 = linkedHashMap[1] val ar2 = linkedHashMap[2] linkedHashMap.forEach &#123; (t, u) -&gt; println(\"key = $t,value = $u \\n\") &#125;&#125; 如果在构造LinkedHashMap 的时候，accessOrder 为false ，则会依次打印： key = 0,value = 0key = 1,value = 1key = 2,value = 2key = 3,value = 3key = 4,value = 4key = 5,value = 5 如果为true，则会打印： key = 0,value = 0key = 3,value = 3key = 4,value = 4key = 5,value = 5key = 1,value = 1key = 2,value = 2 这是因为为true时，会导致最近访问的最后输出，那么这就刚好满足LRU 缓存算法的思想，所以LruCache 的巧妙实现，就是利用了 LinkedHashMap 的这个功能。 所以LruCache 的构造函数为： 1234567public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(\"maxSize &lt;= 0\"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);&#125; 所以LruCache 后续的操作就比较好理解了： 在put 新元素的时候，首先判断 key 和value 都不能为空，之后更新缓存大小；如果之前这个key 有值，则替换这个值，由于已经先前更新过缓存大小，此时要把老的value所占缓存大小减去。最后调整缓存大小，如果缓存大小超过阈值，则依次取出LinkedHashMap 中取出key-value 删除，直到小于阈值为止。 get 的时候，判断 key 是否为 null ，不能为 null 。get操作之后，接着把这个节点删除，再把这个节点添加(头插法，会插入到头部，这样保证顺序)。 3、聊聊handler机制？ 一个线程是否只有一个Looper？如何保证一个线程只有一个Looper？ 点击看答案 Handler 初始化的时候会通过 Looper.myLooper（实际上只是返回了 sThreadLocal.get()） 获取当前线程的Looper。之后通过 looper 获取当前线程的 mQueue 。当然，如果在子线程中new Handler ，基本上会提示 您还未执行Looper.prepare();Looper.prepare() 会判断当前 sThreadLocal.get()是否已经存在了，如果已经存在了，就会提示 “一个线程只能有一个Looper”（注意，就是在这里保证了一个线程只有一个Looper）。Looper.prepare() 只是执行了sThreadLocal.set(new Looper())，在这里给线程设置了Looper。而在主线程中，ActivityThread 的main 方法中会执行 Looper.prepareMainLooper（）来设置Looper，故我们可以直接new Handler，而在子线程中要手动Looper.prepare()才行，并且还要Looper.loop()，让消息循环。接下来就是 handler 的 sendMessage 和post 方法，其实两个方法都是调用 sendMessageDelay 方法，只不过post方法首先将 Runnable封装成Message，变成Message的CallBack。在最终send的时候，Message会持有handler的引用，叫做target，之后，message被丢到handler所持有的MessageQueue中。之后，在主线程中，Looper一直在循环，取出queue中的Message，然后执行message.target.dispatchMessage，在这个方法中，最终会调用到我们写handler时候覆写的 handleMessage 方法。至此，整个流程走完。 4、Handler 的postDelay 是怎么实现的？ 点击看答案 可能用举例子的方式容易懂一些： postDelay 一个10秒的 RunableA 到 MessageQueue，MessageQueue 会调用 nativePollOnce 阻塞线程。 接着post 一个 RunnableB 到 MessageQueue，由于 RunnableB 没有延时，因此when 时间比 RunableA 小，因此被插入在队头，然后调用nativeWake 方法唤醒 线程 。 唤醒后，MessageQueue.next() 方法继续执行，读取到第一个消息 RunnableB，由于没有延时，直接交给Looper。 Looper 处理完B 后，再次调用 MessageQueue.next() 方法，这时候 RunableA 还没到时间，这时候调用 nativePollOnce 阻塞。 这个状态直到阻塞时间到或者下一次有Message 进队。 至于为什么 handler.postDelay并不是先等待一定的时间再放入到MessageQueue中，因为那样的话会需要多个定时器，增加开销。 以上内容源自阅读源码以及 网上博客 附：如何移除Handler的Message？有啥坑吗？ 点击看答案 如果移除Message,有两种方式： 根据 Message 的 what 来移除：handler.removeMessages(what),handler.removeMessages(what.obj)，当然，后者的obj如果为空，就会移除所有的 Message 根据token移除：handler.removeCallbacksAndMessages(token)，当然，如果token为空，就会移除所有 Message (比如在Activity的onDestroy 中有时候为了避免内存泄露会移除)，则只需要传入 null 即可。 handler 的延时操作有两种： handler.postDelayed(runnable, 10000); handler.sendMessageDelay(0, 10000); 但是，如果我们混合使用二者，在移除的时候可能会出现意想不到的问题，比如如下代码： 123456789//创建handlerclass MyHandler extends Handler&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.d(TAG, \"handleMessage: \"+msg.what); &#125;&#125; 创建runnable： 12345678910111213Runnable runnable1 = new Runnable() &#123; @Override public void run() &#123; Log.d(TAG, \"run: 1\"); &#125;&#125;;Runnable runnable2 = new Runnable() &#123; @Override public void run() &#123; Log.d(TAG, \"run: 2\"); &#125;&#125;; 执行： 1234567MyHandler handler = new MyHandler();handler.postDelayed(runnable1,1000);handler.postDelayed(runnable2,1000);handler.sendEmptyMessageDelayed(0,1000);handler.sendEmptyMessageDelayed(1,1000);handler.sendEmptyMessageDelayed(2,1000);//handler.removeMessages(0); 如果屏蔽最后一行，就会输出： 12345run: 1run: 2handleMessage: 0handleMessage: 1handleMessage: 2 但是如果不屏蔽，就只会输出： 12handleMessage: 1handleMessage: 2 意味着两个Runnable 也被移除了！这是咋回事？原来，handler 的 postDelay 功能也是用 sendMessageDelayed 方法去实现的！这当然需要构造 Message 对象咯，然而也仅仅只是 Message m = Message.obtain();m.callback = r; 意味着会新建一个 Message ，而新建的 Message 的what值默认为0 ！问题找到了，那么以后使用remove的时候需要注意什么呢？主要两点： 自定义Handler 处理 msg.what 的时候，what的值不要使用默认值0 同一个Handler 不要同时使用 postDelayed() 和 sendMessageDelayed() 以上内容参考自csdn的博客 5、RecyclerView 的性能优化 点击看答案 有以下几种方式能做到RecyclerView的优化： 数据处理与视图绑定分离。 bindViewHolder 方法是在ui线程执行的，而远端拉取数据肯定是要放在子线程的，所以我们在拉取数据之后做一些预处理后再丢给adapter，防止在 bindViewHolder 方法中再去处理时间比较、保留小数位数之类的操作。 布局优化 1、减少item布局层次 2、减少没必要的xml文件的inflate，可以使用new View()等方式(shape类型的xml 也一样)。 可能的话，为 RecyclerView 设置 setHasFixedSize(true) 这个方法的主要作用就是设置高度，来避免 rv 的 measure 和 layout 操作。比如一个垂直滚动的rv，height属性设置为 wrap_content，最初的数据集只有3条，全部展示出来也不能使rv撑满，如果我们通过notifyItemRangeInserted 添加数据，那么如果你设置了 setHasFixedSize 为true的情况下，rv高度是不会改变的。体现在diamante中就是requestLayout方法的调用。 减少itemView的监听器创建 我们无需对每一个item 都采用匿名内部类的方式添加监听，，而应该公用一个 xxListener 对象，通过id来区分不同操作，避免频繁创建对象带来资源消耗。 加大RecyclerView的缓存 通过设置 setItemViewCacheSize、setDrawingCacheEnabled 以及setDrawingCacheQuality 等方法增加缓存空间，以空间换时间，提升流畅性。 滑动过程中停止加载 使用 DiffUtil 工具 DiffUtil 工具类用来判断新数据和旧数据的差别，从而进行局部刷新，我们只需要在原来调用 mAdapter.notifiyDataSetChanged() 的地方改成下面这样：DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new DiffCallBack(oldDatas, newDatas), true);diffResult.dispatchUpdatesTo(mAdapter);最终，mAdapter 会通过调用 notifyItemRangeInserted、notifyItemRangeRemoved 等方法进行局部刷新。 公用RecycledViewPool 在嵌套的 rv 中，如果子 rv 具有相同的adapter ，那么可以设置 ：RecyclerView.setRecycledViewPool(pool) 来公用RecycledViewPool。 RecyclerView数据预取 默认是开启的，跟我们没关系。具体原理是，当上一帧交给gpu之后，cpu就一直处于空闲状态，需要等待下一帧才会数据处理，所以rv做了个预判，rv会取接下来可能要显示的item，在下一帧到来之前把数据提前处理好，不过呢，这个预判是不一定准确的。 以上内容参考 mandypig、编码前线 以及 Blankj 6、引申-如何保存嵌套rv中的滑动装填比如嵌套的rv这时候左滑到第三个，这时候外层的rv滑动很长距离，当前这个嵌套的rv已经看不见了，划出好远了，如何在嵌套rv再次可见的时候，恢复当时滑到的第三个。 其实 Linearlayoutmanager 中有对应的 onSaveInstanceState 和 onRestoreInstanceState 方法来处理保存和恢复机制。 7、图片加载优化 假设通过ImageView 显示图片，很多时候ImageView 没有原始图片尺寸那么大，把整个图片加载进内存再设置给ImageView则没必要，这时候可以在加载图片时采用低采样率加载进来。 与后端配合，在url 后面接上需要的图片尺寸。(目前就是这么做) 8、延伸-Bitmap大小计算方法//Bitmap所占用的内存空间数等于Bitmap的每一行所占用的空间数乘以Bitmap的行数使用 bitmap.getRowBytes() * bitmap.getHeight(); 参考自计算Bitmap 大小 9、Activity生命周期 点击看答案 onCreate()：当 Activity 第一次创建时会被调用 onRestart()：表示Activity正在重新启动。一般情况下，当当前Activity从不可见重新变为可见状态时，onRestart就会被调用。 onStart(): Activity已经出现了，但是还没有出现在前台，无法与用户交互。这个时候可以理解为Activity已经显示出来，但是我们还看不到 onResume():表示Activity已经可见了，并且出现在前台并开始活动。需要和onStart()对比，onStart的时候Activity还在后台，onResume的时候Activity才显示到前台 onPause():表示 Activity仍可见，只是不可交互 onStop():表示Activity不可见，位于后台 onDestory():表示Activity即将销毁，这是Activity生命周期的最后一个回调，可以做一些回收工作和最终的资源回收 10、延伸-生命周期几种普通情况 点击看答案 从 A 页面Activity 跳转到 B 页面Activity： 一、 启动过程会经历： A:onPause-&gt; B:onCreat-&gt; B:onStart-&gt; B:onResume-&gt; A:onStop 所以我们可以得出结论： 在A 的onPause 中不要执行耗时操作，否则会影响新打开的B，因为当前A 的 onPause 必须执行完，B 的onResume 才会执行。 等 B 的onResume 执行后，A 才完全被覆盖看不见，故，B的onResume 调用完后，A的Stop 才调用。 二、按返回键返回到A： B:onPause-&gt; A:onRestart-&gt; A:onStart-&gt; A:onResume-&gt; B:onStop-&gt; B:onDestroy 我们得出结论： B 首先让出交互权力 A 到前台(onResume)后 ，B才退到后台，B才调用 onStop 三、按Home 键： onPause -&gt; onStop，即让出交互，退到后台 反之，此时再点击图标唤起： onRestart-&gt; onStart-&gt; onResume，即Activity 还在，只需要重新可见即可 11、Activity的启动模式 点击看答案 standard：标准启动。 singleTop(栈顶复用模式)：在当前栈顶就复用，否则新建。 singleTask(栈内复用模式)：在当前栈存在有实例，如果在栈顶，直接使用；如果不在栈顶，将该实例之上的Activity全部出栈。 singleInstance(单例模式)：只要有这个实例，不管在哪个栈，都复用之；否则，在新的栈创建实例。 12、Fragment 为何不推荐使用构造方法传递参数？因为activity 给fragment 传递数据时是通过 setArguments 来传递。如果采用构造方法传递，在诸如横竖屏切换的时候会调用fragment 的空的构造函数，造成数据丢失。 13、Context 理解参考以前写的博客：https://glassx.gitee.io/2019/12/06/Android%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86-%E7%AC%AC5%E7%AB%A0/ 14、Android 全局异常处理在Application 中为 Thread 设置ExceptionHandler 即可。 参考：全局异常处理 15、谈谈你对Application类的理解 点击看答案 说说对什么的理解，就是考察这个东西会不会用，重点有没有什么坑。有以下几点需要注意： Application 在一个虚拟机里面只有一个实例。这里不是说一个App只有一个实例，因为一个App 可能有多个进程，也就是多个虚拟机，这种情况下，每个虚拟机中都会存在一个Application 对象。 Application 本质是一个Context ，继承自 ContextWrapper。 Application 有 MultiDexApplication 子类，这个子类可以用来解决 65535 问题，完成多Dex 打包配置相关工作。 在Application 的onCreate 方法中我们会进行各种初始化，如图片加载库、log 等，但是最好别在里面进行太多耗时操作，这会影响App启动速度，可以使用异步、懒加载、延时加载等策略来减少影响。 通过Context.getApplicationContext ，不论是从Activity 中、Service中获取，都是同一个Application 对象。 在低内存情况下，Application 可能会被销毁，从而导致保存在Application 中的数据错乱，所以要注意判空或者选择其他方式保存数据。 Application 中几个有用的回调如 onLowMemory 、onTrimMemory ，在内存紧张的时候，在这些回调里面关闭数据库连接、移除图片缓存等方式来降低内存，降低被回收的风险。 Application 的生命周期和虚拟机一样长，所以单例或者静态变量的初始化一定要使用Application 的Context 进行初始化，防止内存泄漏。 以上内容可以参考这个链接 16、Android 中进程通信方式可以翻看以前的读书笔记 17、Binder 原理 点击看答案 为什么要使用Binder 性能方面；Binder 数据拷贝只需要一次，而管道、Socket 等都需要2次，共享内存不需要拷贝，但是实现方式比较复杂。 安全方面；传统的进程通信方式对于通信双方没有严格限制，而Binder 机制从协议本身就支持对通信双方做身份校验，所以大大提升安全性。 IPC 原理每个Android 进程，只能运行在自己进程所拥有的虚拟地址空间。例如，对应4G的虚拟地址空间，其中3G是用户空间，1G是内核空间，当然，内核空间大小是可以通过参数配置的。对于用户空间，进程间是不能共享的，而内核空间是可以共享的。Client 进程向Server 进程通信，恰恰是利用进程间内核空间来完成底层通信工作的。 跨进程使用服务的流程 Client 通过Server 的代理接口，对Server 进行调用。 代理接口中定义的方法与Server 中定义的方法是一一对应的。 Client 调用某个代理中的方法时，代理会将Client 传递的参数打包成 Parcel 对象。 代理将Parcel 发送给内核中的 Binder Driver。 Server 读取Binder Driver 中的请求数据，解包 Parcel 对象，处理并返回。 整个调用过程是一个同步过程，在Server 处理的时候，Client 将会Block 住。故Client 调用过程不应该在主线程。 整个流程示意图如下所示： 关于IPC，还可以参考以前的文章 以上内容参考自：进程间通信 以下内容摘自《深入理解Android：卷II》： Binder 有两种调用方式： 阻塞调用方式 和 非阻塞方式。前者 调用方(客户端)会阻塞，直到服务端返回结果，这种方式和普通的函数调用是一样的；后者调用方只要把请求发送到Binder驱动即可返回，但一般还会向服务端发送一个回调(同样是跨进程的Binder调用)，不用等待服务端的结果，一旦服务端处理了该请求，就会调用此回调函数来通知客户端处理结果。 Handler中looper会阻塞，唤醒的时候是通过 pipe 发送 w 来唤醒的 在2.3以前，我们只可以从Java层向 MessageQueue 添加消息，但在2.3以后，MessageQueue 的核心部分下移到Native层，所以有时候cpu并不是很忙，但是你的sendMessage 又是等了很久才被处理，这有可能就是在处理 Native 层的 Message。 18、延伸-Android为什么要设计出Bundle而不是直接使用HashMap来进行数据传递 点击看答案 Bundle 内部是由ArrayMap 实现的，我们知道，ArrayMap 内部实现原理是两个数组，在添加、删除、查找 数据时，都会使用二分查找法，在数据量较小的情况下，相对 HashMap 而言，在效率相差不太大的情况下，更节省内存(HashMap的Entry Array 占用更多内存，并且没用到的会导致浪费)。而我们在Android中使用Bundle 传递数据都是比较少的，因此Bundle 更有效率。 Android 中如果使用Intent 携带数据的话，需要数据基本类型或者是可序列化类型，HashMap 使用Serializeble 进行序列化，而Bundle 是实现了 Parcelable 进行序列化。在Android 平台中，更推荐使用 Parcelable 进行序列化，因为更少的 io 操作(但同时使用更加复杂)。 以上内容参考zhaokaiqiang的博客 19、Android中IPC通信的方式有哪些？使用场景是什么参考以前写的读书笔记即可 20、SharedPreference 解析 点击看答案 获取SharedPreference 对象大概有3种方式获取： 通过Context 的 getSharedPreference() 方法，指定name 和 mode； 通过 Activity 的 getPreferences() 方法，它其实最终还是调用的 Context 的 getSharedPreferences() 方法，只不过我们只需要传mode参数，因为已经在方法中将 Activity 的类名作为name了； 通过 PreferenceManager 的getDefaultSharedPreferences() 方法，目前基本上已经废弃 获取 SharedPreference 对象时，如果有没有存在这个xml文件，则创建，否则读取。在低于4.4 的版本上，如果name 为 null ，则会自动设置为 “null”。一直等这个 xml 文件加载解析完成，才会返回 SharedPreference 对象。 获取xml 过程中，首先会读取 ContextImpl 中的 sSharedPrefsCache 缓存： private static ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache; 由于sSharedPrefsCache 是static 的，并且 Android 中所有系统都使用这一个 ContextImpl 类，所以对于所有的app而言，都公用这一个 sSharedPrefsCache，因此可以理解为，系统启动后，如果有哪个应用使用过 sSharedPrefsCache ，那么它一直会留在内存中，直到系统关闭或者重启。 根据packageName ，可以从 sSharedPrefsCache 中获取当前应用的 ArrayMap&lt;File, SharedPreferencesImpl&gt; 列表，我们知道，根据不同的name，在文件中都会生成不同的xml 形式的 file。我们知道，SharedPreference 的xml 文件存储在 data/{packageName}/shared_prefs 目录下，所以我们name 就能获得 file 文件的路径，进而获取到这个xml 的 File 对象。根据这个对象，我们可以获取到 SharedPreferencesImpl 对象。在SharedPreferencesImpl中存在 Map&lt;String, Object&gt; 类型的 mMap 保存了xml 中key-value值 (解析完xml 后将值存入其中)。所以我们在正式使用的时候，实际上是从内存中读取的。 在解析这个 xml 过程中，SharedPreferenceImpl（SharedPreference 接口的实现类） 一直都是加锁的，在这个锁定状态下，我们无法调用它的 commit 和 apply 方法(处于wait状态)，直到这个解析完成，就会执行 notifyAll 方法。 SharedPreference 的值获取我们以 getBoolean 方法为例： 1234567public boolean getBoolean(String key, boolean defValue) &#123; synchronized (mLock) &#123; awaitLoadedLocked(); Boolean v = (Boolean)mMap.get(key); return v != null ? v : defValue; &#125;&#125; 可以看到在获取之前，首先加锁，因此这过程是线程安全的，之后 awaitLoadedLocked() 一直在等待(前面说的，在getSharedPreference() 过程中，在xml 解析完成return 之前，一直都会加锁的，完成后就会notifyAll)，直到xml 文件解析完成。可以看看 awaitLoadedLocked 的源码，可以看到它的wait过程： 12345678private void awaitLoadedLocked() &#123; ... while (!mLoaded) &#123; try &#123; mLock.wait(); &#125; catch (InterruptedException unused) &#123; &#125; &#125; SharePreferences内部类Editor我们来看 SharedPreference 的 edit() 方法： 12345678public Editor edit() &#123; synchronized (mLock) &#123; awaitLoadedLocked(); &#125; return new EditorImpl(); &#125; 可以看到，它也得 awaitLoadedLocked() 等待SharedPreference 准备完成。从这里还可以知道，每次 edit() 都会 new 一个 EditorImpl 对象，因此，不要频繁edit() 操作。 Editor 的具体实现是 EditorImpl 。我们可以粗略地看下它的源码： 1234567891011121314151617181920212223242526public final class EditorImpl implements Editor &#123; private final Object mEditorLock = new Object(); @GuardedBy(\"mEditorLock\") private final Map&lt;String, Object&gt; mModified = new HashMap&lt;&gt;(); @GuardedBy(\"mEditorLock\") private boolean mClear = false; //这里只写这一个put 操作，其他的 putXXX操作基本上是一样的 @Override public Editor putBoolean(String key, boolean value) &#123; synchronized (mEditorLock) &#123; mModified.put(key, value); return this; &#125; &#125; @Override public Editor remove(String key) &#123; synchronized (mEditorLock) &#123; mModified.put(key, this); return this; &#125; &#125;&#125; 可以看到，我们的put 、remove 之类的操作，只是修改了 hashmap中的值，并没有存入到 SharedPreference 中，通过我们平时使用知道，要在 commit 或者 apply 方法中来生效。 改动提交到 SharedPreference1234567891011121314151617public boolean commit() &#123; //1.先通过commitToMemory方法提交到内存 MemoryCommitResult mcr = commitToMemory(); //2.写文件操作 SharedPreferencesImpl.this.enqueueDiskWrite( mcr, null); try &#123; //阻塞等待写操作完成，UI操作需要注意！！！所以如果不关心返回值可以考虑用apply替代，具体原因等会分析apply就明白了。 mcr.writtenToDiskLatch.await(); &#125; catch (InterruptedException e) &#123; return false; &#125; //3.通知数据发生变化了 notifyListeners(mcr); //4.返回写文件是否成功状态 return mcr.writeToDiskResult;&#125; 首先通过 commitToMemory 提交到内存，之后，直接在调用commit() 方法的线程中将数据写入文件。在真正写文件的时候，采用了数据库的事务思想，因为它有个 backfile 的备份文件。 接下来分析apply 方法： 12345678910111213141516171819202122232425262728293031public void apply() &#123; //有了上面commit分析，这个雷同，写数据到内存，返回数据结构 final MemoryCommitResult mcr = commitToMemory(); final Runnable awaitCommit = new Runnable() &#123; public void run() &#123; try &#123; //等待写文件结束 mcr.writtenToDiskLatch.await(); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125;; QueuedWork.add(awaitCommit); //一个收尾的Runnable Runnable postWriteRunnable = new Runnable() &#123; public void run() &#123; awaitCommit.run(); QueuedWork.remove(awaitCommit); &#125; &#125;; //这个上面commit已经分析过的，这里postWriteRunnable不为null，所以会在一个新的线程池调运postWriteRunnable的run方法 SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable); // Okay to notify the listeners before it's hit disk // because the listeners should always get the same // SharedPreferences instance back, which has the // changes reflected in memory. //通知变化 notifyListeners(mcr);&#125; 在子线程中提交了这个写任务，这个任务是通过handler去post的，而这个handler 初始化的Looper 是从 HandlerThread 中获取到的，所以最终还是相当于在一个个的apply 提交交给了HandlerThread 去操作，即在单线程的子线程执行。 使用是注意 不要存储超大的key或者value 获取一个sp的时候，会把它的整个xml 文件都加载进来，如果太大，比如说 100k，那就会耗费很长的时间。如果为了读取一个boolean 配置，要把整个100k文件加载进来，是很不合理的，会引起频繁gc，和大的内存占用，所以我们应该只要存储很轻量的数据。 还有，我们知道，在getBoolean 或者其他getXXX 方法的时候，会要等待SharedPreference 加载完成，况且，在xml 加载过程中，有多个地方加锁。在加载完成后，getXXX 操作才能执行，否则一直在等待，这过程的阻塞可能引起界面卡顿和掉帧。 所以我们可以在super.onCreate() 之前，可以先执行 getPreference。 不要在sp中存储 JSON 这种特殊符号很多的 value 这么做不是不可以，而是如果这个json很大，就会涉及很多转义(其实html 也会有这情况)，带来很多&amp;这种特殊符号，引发额外地字符串拼接以及函数调用开销。 多次edit() 和 apply() 通过以上的分析我们也知道了，每次 edit() 操作都会 new 一个 EditorImpl，这是一点。还有，经过上次我们知道，每次 apply 会往 HandlerThread 中post 一个 Runnable，然后他们会在单线程中依次执行。可能说到这里还没觉得有什么，但是我告诉你这会导致卡顿，不可思议吧？在子线程操作的，怎么可能导致卡顿呢？但是我们看 ActivityThread 源码，执行 handleStopActivity 的时候： 12345678910private void handleStopActivity(IBinder token, boolean show, int configChanges, int seq) &#123; // 省略无关。。 // Make sure any pending writes are now committed. if (!r.isPreHoneycomb()) &#123; QueuedWork.waitToFinish(); &#125; // 省略无关。。&#125; 就是在api 11 之前，会等待 apply 提交的那些 runnable 执行完了才能退出，如果这个时间过长，会导致anr。 不要用于跨进程 Android官方也不建议使用SharedPreference 跨进程(已经@deprecated)，而建议使用provider。因为它并不是在所有进程上都是可靠的。并且，它通过 MODE_MULTI_PROCESS 这个标志位来实现多进程标记，其实也只是如果sp已经读到内存了，再次获取这个sp 时，如果有这个标志位，就会重新获取一遍文件。 总结一下 不要存放大的key和value，可能引起页面卡顿，频繁gc 毫不相干的配置项不要丢在一起，文件越大越慢。这样，用户没有到达的页面的sp可以不加载进来。 读取频繁的key和不易变动的key尽量不要放在一起。 不要频繁 edit 和 apply ，尽量批量修改一起提交 尽量不要存放 json 和 html ，防止不必要的转义 不要指望用sp 来跨进程通信 以上内容经过自己看代码，以及参考自上善若水、以及维数不多 21、常见内存泄漏场景： 点击看答案 资源性对象未关闭 如 File、Cursor、stream等资源，他们的缓存不只存在java虚拟机内，还存在虚拟机外，仅仅把对象置为null而不关闭，就会引起内存泄漏 单例造成的内存泄漏 单例的静态性使得其生命周期跟app的生命周期一样长，如果使用不恰当(比如引用了非Application 的 Context)的话，很容易造成内存泄漏。 注册对象未注销 观察者模式的注册，在不使用的时候未注销，就会导致，如在Activity中监听电话服务，定义PhoneStateListener注册到TelphoneManager服务中，如果忘记注销，会导致Activity无法被Gc回收。 非静态内部类创建静态实例 首先，非静态内部类会持有外部类的引用。其次，创建的静态实例生命周期和应用的一样长。这样就导致了该静态实例一直会持有该外部类的引用，导致外部类内存资源不能正常回收。 匿名内部类和异步线程 1234567891011public class MainActivity extends Activity &#123; ... Runnable ref1 = new MyRunable(); Runnable ref2 = new Runnable() &#123; @Override public void run() &#123; &#125; &#125;; ...&#125; 上述代码中，ref2的内部类会持有MainActivity 的实例，此时引入一个异步线程，如果此线程与MainActivity 生命周期不一致，就造成MainActivity 泄漏。 Handler造成的内存泄漏。 非静态Handler默认持有外部Activity的引用，退出Activity时，如果Looper中还有Message，就会导致Activity无法回收，可以（1）将Handler设置为静态，并且弱引用持有的对象 （2）Activity 的onDestroy的时候，一处消息队列的消息 来解决内存泄漏。 容器中的对象没有清理 容器里的对象在不需要的时候，要及时移除，使其正确及时地被回收。 以上内容参考自：内存泄漏场景 22、延伸-内存泄露检测工具项目中使用 LeakCanary，参考以前的 LeakCanary 源码分析 即可 23、Android应用程序启动过程 点击看答案 参考以前的读书笔记即可 24、Apk 安装的步骤 点击看答案 分析PMS(PackageManagerService) 就能知道这个过程，总体而言有这几个步骤： 首先判断安装源，诸如adb/shell/all_user 等 将apk 文件复制到 /data/app 目录 解析apk 信息，包括签名校验、四大组件的注册等 dexopt 操作，优化apk中的.dex文件，对于dalvik 虚拟机，dexopt 就是优化操作；对于art 虚拟机，dexopt 就是将.dex翻译成oat文件。 更新权限信息：将app所有权限几率下来更新到PMS 中，并判定是否授予该app 请求的权限。 安装完成，发送 Intent.ACTION_PACKAGE_ADDED 广播 以上内容参考自：apk安装步骤 25、ANR异常发生条件？如何分析ANR？ 点击看答案 ANR 发生条件： 5s内没有响应用户输入事件 10s内广播接收器没有处理完毕 20s内服务没有处理完毕 ANR 时，系统做了什么 弹窗 将ANR 信息输出到 /data/anr/traces.txt 文件中(无需root 就能通过 adb pull 命令拷贝出来) 将ANR 信息输出到 Logcat 中(包含PID、Reason、CPU负载 等) 以上内容参考自： very_on 26、Android 热修复原理 点击看答案 DexClassLoder 可以用来从 .jar 和 .apk 类型的文件内部加载classes.dex 文件。用来执行非安装的程序代码。 两个dex 中存在相同的 class 文件，则会从第一个dex 中找，找到了直接返回，第二个dex 中的class 永远不会被加载进来。 阻止引用类被打上 CLASS_ISPREVERIFIED 标志。 在虚拟机启动的时候，如果verify 选项打开，static、private方法、构造函数等 中的直接引用到的类都在同一个dex文件中，那么该类就会被打上 CLASS_ISPREVERIFIED 标志。 注意，是阻止引用这的类，也就是说，假设有类叫做 LoadBugClass ，在其内部引用了 BugClass，在发布过程中发现 BugClass 有编写错误，那么想要发布一个新的 BugClass ，那么就要阻止 LoadBugClass 这个类被打上 CLASS_ISPREVERIFIED 的标志。而这个标志是在 apk 安装的时候，优化成odex 的阶段被添加的。所以在生成apk之前就要阻止 CLASS_ISPREVERIFIED。 以上内容参考自：热修复原理 27、插件化技术原理 点击看答案 插件化就是让我们应用不必把所有的内容都放在一个apk中，可以把一些功能和逻辑单独抽出来放在插件apk中，然后主apk 按需调用。一来可以让主apk体积更小，二来可以做到热插拔，动态化。 插件化技术基础： DexClassLoader，想要实现加载外部的dex 来实现热部署，必然要把其中的class 文件加载到内存。DexClassLoader 能做到加载.jar 和 .apk 文件中的 class 文件。 Java 反射：因为插件apk 与宿主apk 不再一个apk 内，那么一些类的访问必然要通过反射进行获取。 插件资源访问：res 里每个资源都会在R.java里生成一个Integer 类型的id，app 启动时会把R文件注册到当前的上下文环境，我们在代码中以R文件方式访问资源正是通过这些id访问。然而，插件的R.java并没有注册到当前的上下文，所以也就无法通过id使用。 我们可以通过 addAssetPath 方法重新生成一个新的 Resource 对象来保存插件中的资源，避免冲突。 代理模式：无论是通过activity代理还是通过DroidPlugin 去hook activity 启动过程来启动activity的方式，都是对代理模式的应用。在前一种方式中，虽然加载进来了Activity 等组件，但也仅仅是作为一个普通对象而存在，并没有在AndroidManifest中注册，没有生命周期回调。这时候通过代理即可。 以上内容参考自： http://www.androidos.net.cn/book/android-road/android/advance/plugin.html、virtualAPK 实现方式可以参考这里 28、轮播图实现原理？ 点击看答案 原理： 如果只有一张图，则不作处理 如果有n张图，则在 ViewPager 的adapter中做如下处理： getAccount 返回 n * 10000 instantiateItem 的时候，position 需要对 n 求余 源自项目代码 29、ListView 原理 点击看答案 ListView 原理主要要提及RecycleBin 机制，这是ListView 能够实现大量数据都不会 OOM 的一个重要原因。它包含两个数组：mActiveViews 用于存储当前显示在屏幕上的item，mScrapViews 用于存储已经不可见的item。 ListView 自己是没有覆写 onLayout 方法的，这个方法在父类 AbsListView 中实现。第一次 layout 操作：此时ListView 中还没有任何子 View，接着自顶至底填充ListView，这个填充过程首先尝试获取一个 active view，不过此时还没有缓存任何 active view，于是只能通过Adapter 的 getView 获取view(此时convertView 是空的，只能创建)；之后，调用 addViewInLayout 将这个view 添加到 ListView ，将第一屏加载完成后，这个getView 动作就会停止。 第二次Layout：如果layout执行两次的话，那么ListView 就会存在一份重复的数据了。其实第二次layout的过程中，也会去获取 active view ，不过这时候有数据了，有view了，这时候首先执行 detachAllViewsFromParent ，将ListView 中所有的item 都清除掉，detach掉，从而保证第二次 layout 过程中不会产生一份重复数据。由于这些清除掉的item 在 active view 中会有缓存，所以不会重新执行 inflate 过程。之后又重新获取active view ，获取到再 attachViewToParent 就再次添加到 ListView 中。这样经历了 detach 又 attach 过程，ListView 所有子View 就显示出来了。 在滑动的时候，不可见的view会 detach 之后回收到 mScrapViews 中。滑动展示新的item的时候，会从 mScrapViews 废弃的view中获取一个view，再调用 Adapter.getView ，并且将获取到的废弃 View 当做 convertView 传过去，接下来就是我们在 adapter 中常用的写法了。 因此，整个Listview 中总共只有那么几个固定的 item ，滑动的时候就这几个 view 在倒腾(detach 和 attach)，因此不论数据量多大，都不会导致oom。 以上内容参考自郭霖的博客 30、android 5.0, 6.0, 7.0, 8.0新特性 点击看答案 5.0 Meterial Design ART 虚拟机 6.0 动态权限申请 移除了 Http Client 库 Dozen 模式 如果用户未插接设备的电源，在屏幕关闭的情况下，让设备在一段时间内保持不活动状态，那么设备就会进入低电耗模式。在低电耗模式下，系统会尝试通过限制应用访问占用大量网络和 CPU 资源的服务来节省电量。它还会阻止应用访问网络，并延迟其作业、同步和标准闹钟。 参考官方文档 7.0 多窗口支持(分屏模式) JIT/AOT 交叉编译(取一个平衡，节约磁盘占用)。 8.0 画中画 Notification 引入 channel 概念，必须设置 TextView 自动调整文字大小 9.0 刘海屏支持 多摄像头支持 Q 折叠设备 深色主题 31、如何导入外部数据库 点击看答案 把原来数据库的文件放在 res/raw 目录下。 我们知道Android系统下数据库应该存放在 /data/data/(packageName)/ 目录下，我们所要做的就是把已有数据库传入那个目录下。操作方法是用FileInputStream 读原数据库，再用FileOutputStream 写入到那个目录。 以上内容参考自: 如何导入外部数据库 32、Android 消息屏障 点击看答案 Handler 中的Message 可以分为三类：同步消息、异步消息 以及消息屏障(消息屏障也是一种消息，只不过target为null)。同步屏障可以通过 MessageQueue.postSyncBarrier 函数来设置(该方法是私有方法，需要反射调用，新的api 貌似提供了public 的 postSyncBarrier方法)： 1234567891011121314151617181920212223242526private int postSyncBarrier(long when) &#123; synchronized (this) &#123; final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next msg.next = p; prev.next = msg; &#125; else &#123; msg.next = p; mMessages = msg; &#125; return token; &#125;&#125; 乍一看，这里就是往MessageQueue 中放入了一个Message ，和Handler 的post 及postDelay 一样，但是我们知道，Handler 的post 或者postDelay 时，Message 的target 字段会引用这个Handler，而设置同步屏障的时候，没有设置target字段。 异步消息和普通消息一样，Message 中 setAsynchronous(true) 操作了。而通过 MessageQueue 的next() 获取需要处理的 Message 时，有没有target 会是截然不同的处理方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123;//碰到同步屏障 //一直循环，直到拿到距离表头最近的异步消息 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; //将msg 从消息链表中移除 prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. //如果能执行到这里，说明当前没有需要处理的 msg (queue 为空，或者 msg 的时间还没到) if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; //获取当前IdleHandler的数量 pendingIdleHandlerCount = mIdleHandlers.size(); &#125; //没有需要处理的idleHandler，退出 if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; //用将所有的idleHandler存入mPendingIdleHandlers mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. //迭代处理 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; //根据返回值，选择是否remove这个idleHandler if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; 如果碰到没有 target 的 msg ，则会一直遍历是否有异步的消息，如果有，则马上处理，可以说设置了同步屏障后，Handler 只会处理异步消息(在达到目标后，要求手动调用 MessageQueue.removeSyncBarrier 来移除屏障)。 当messageQueue 中没有msg 或者最早的一个 msg 都要在一段时间之后执行，那么如果直接让线程空转有点浪费，在这个时候，系统会去调用这个IdleHandler 接口回调(如果有的话)，如果上述代码返回false，说明只需要执行一次，在执行完了之后，将会被remove掉；如果返回true，则认为会执行多次。 使用场景：Android系统中存在Vsync 消息，主要负责 16ms 更新一次屏幕展示，如果同步消息在16ms内没执行完成，就会出现掉帧，用户感觉卡顿。假如在 Vsync 消息加入 MessageQueue 时前面还有 10个同步消息，每个消息执行10ms，那么总共也需要100ms ，这段时间会丢掉很多帧，为了解决这种排队等候，可以使用同步屏障+异步消息。如 ViewRootImpl 的 scheduleTraversals 方法就是这样： 12345678910111213void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125; 以上内容参考自Handler之同步屏障机制、Android 源码分析 - Handler的同步屏障机制、同步屏障的使用示例可以参考Android中异步消息和同步屏障 33、引申-IdelHandler 点击看答案 通过以下代码可以添加IdleHandler (注意是Looper.myQueue，而不是Looper.myLooper： 12345678//getMainLooper().myQueue()或者Looper.myQueue()Looper.myQueue().addIdleHandler(new IdleHandler() &#123; @Override public boolean queueIdle() &#123; //你要处理的事情 return false; &#125; &#125;); 结合消息屏障中列出的代码可知，如果在 queueIdle 方法中返回false，则在方法执行完成之后，这个 IdleHandler 将会被移除，即只执行一次；如果return true，则会多次执行。 IdelHandler 的常用场景有：1、延迟执行：当Activity 启动时，需要延时执行一些操作，以免启动过慢，我们通常使用postDelay的方式执行，但是这个delay的时间不太好把握，这时候用 IdelHandler 会更优雅。 2、批量任务，只关心最终结果，例如开发im应用，通常情况下每收到一个消息都会刷新一下ui，短时间内收到多个消息，就会刷新多次界面，容易造成卡顿，影响性能，这时候可以通过子线程监听im消息，通过IdelHandler 刷新ui是比较理想的。 以上内容参考自张小凡凡 34、卡顿之-BlockCanary 原理 点击看答案 卡顿可以使用 BlockCanary 去监测，它需要你自己指定超时的阈值，超过这个阈值就展示出来。我们只知道这个功能，但是它的原理是啥呢？我们可以首先看下 Looper 的源码： 123456789101112131415161718192021222324/** * Initialize the current thread as a looper, marking it as an * application's main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: &#123;@link #prepare()&#125; */public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125;&#125;/** * Returns the application's main looper, which lives in the main thread of the application. */public static Looper getMainLooper() &#123; synchronized (Looper.class) &#123; return sMainLooper; &#125;&#125; 我们整个进程就只有一个主线程，主线程只有一个 mainLooper ，所以不管多少Handler 与主线程相关，最终都会让这个 mainLooper 来处理，我们再来看下 mainLooper 处理事务的逻辑： 123456789101112131415161718192021222324252627public static void loop() &#123; ... for (;;) &#123; Message msg = queue.next(); // might block // 获取printer final Printer logging = me.mLogging; if (logging != null) &#123; // 在执行特定message 之前打印日志 logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; // Make sure the observer won't change while processing a transaction. //处理事务 ... if (logging != null) &#123; //事务处理完成后，再次打印 logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; msg.recycleUnchecked(); &#125;&#125; 这个 Printer 类型的 mLogging，在每个 Message 处理前后都调用了一遍，printer 流程卡住了，不就是主线程卡住了吗？而我们只需要执行以下代码： Looper.getMainLooper().setMessageLogging(); 就可以设置自己自定义的 Printer ，这样当卡顿发生时，就能感知了。 以上内容参考自 BlockCanary作者的博客 35、Android 跨进程通信之 Binder 点击看答案 Linux 内核提供了丰富的进程间通信机制，如 管道(pipe)、信号(signal)、消息队列(Message)、共享内存(Share Memory) 以及 Socket 等。——摘自《Android系统源代码分析》 Android 中使用 Binder 进行多进程间通信只需要一次数据拷贝，效率上仅次于共享内存。Binder IPC 机制通过 mmap() 内存映射实现，内存映射简单讲就是将用户空间的一块内存区域映射到内核空间。Android 中Binder 进程间通信示意图如下： Binder 通信中的代理模式我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现了，但是还有问题让我们困惑：A进程想要B进程中某个对象(object) 是如何实现的呢？毕竟分数不同的进程，内存地址映射规则也不一样，A进程没法直接使用B进程中的object。 其实，数据流经过Binder驱动都会左一层转换。当A进程想要获取B进程中的object 时，驱动并不会真的把 object 返回给 A，而是返回一个与 object 看起来一样的代理对象 objctProxy，这个 objctProxy 有object 的所有方法，但是这些方法没有 objct 方法中的那些能力，这些方法的主要工作就是将请求参数交给 Binder 驱动，而对于A进程来讲，就和直接调用 object 对象一样一样的。 当Binder 驱动收到 A 进程的消息后，发现是 objctProxy ，接着查询自己维护的表单，发现它是B进程 object 的代理对象，于是就通知B进程调用 object 的指定方法，并要求将结果返回自己。之后Binder 驱动将结果转发给A进程，一次通信就完成了。具体通信过程如下图所示： 多进程通信方式选择如果想进程间通信，但是无需多线程，可以使用 Messenger；如果需要进程间通信，并且还需要再服务中处理多线程，那就使用AIDL(其实Socket也是能实现的)。 顺带一提：App实现多进程有很多弊端，比如：静态和单例会失效(不是同一规则的内存映射)、sharedPreference 会不可靠 等 以上内容参考自Android进程间通信 36、事件分发 点击看答案 当我们点击屏幕时，事件最先传递给Activity ，在 Activity 的dispatchTouchEvent() 回调中，默认首先调用 getWindow().superDispatchTouchEvent(ev) 将事件交给window 处理，如果window 返回true之后，则直接return true。在 getWindow().superDispatchTouchEvent(ev) 调用的时候，我们能发现事件一步步传递： 1、PhoneWindow.superDispatchTouchEvent2、DecorView.dispatchTouchEvent()3、ViewGroupTouchEvent() 以上内容参考自Android触摸反馈 37、所谓的Android 开发高手课 点击看答案 Bitmapbitmap 是烧内存大户，3.0~7.0中会将bitmap对象和像素数据统一放到Java堆中，不过还是会引起大量gc甚至导致oom。将Bitmap 内存放到Native 中可以做到和对象一起快速释放，Android 8.0 中提供 NativeAllocationRegistry 帮助将bitmap 放到 native 内存，同时还能满足与对象一起回收。 ANR首先看主线程的堆栈，查看是否因为锁等待导致。接着看 ANR 日志中的 iowait、CPU、GC、systemt server 等信息，进一步确定是否是 io 问题，或者是 CPU 竞争问题，还是由于大量 GC 导致卡死。从 Logcat 中能够看到当时系统的一些行为，比如出现 ANR 时，会有 “am_anr”，App被kill 时，会有 “am_kill”。 Serializable 整个序列化过程使用了大量的反射和临时变量，而且在序列化对象的时候，不仅会序列化当前对象本身，还需要递归序列化对象引用的其他对象 因为存在大量反射和 GC 的影响，序列化的性能会比较差。另外一方面因为序列化文件需要包含的信息非常多，导致它的大小比 Class 文件本身还要大很多，这样又会导致 I/O 读写上的性能问题 Parcel 序列化和 Java 的 Serializable 序列化差别还是比较大的，Parcelable 只会在内存中进行序列化操作，并不会将数据存储到磁盘里。 参考自别人的博客 38、Android 中大图加载 点击看答案 一般为了尽可能避免OOM，图片加载都会按照如下做法： 如果仅仅只需要读取大图的尺寸和类型，那我们没必要将其加载到内存，在解码的时候，指定 BitmapFactory.Options 中的inJustDecodeBounds 属性设置为true即可，这样避免为bitmap 分配内存，但是能读到图片的尺寸和类型。根据图片的大小以及ImageView 的大小，我们可以配置 BitmapFactory.Options.inSampleSize 来确定加载到内存中图片的大小。 对于图片显示,根据需要显示图片空间的大小对图片进行压缩显示(我们是提交给后台的链接中拼接了所需要的尺寸) 如果图片非常多，则会使用 LruCache 等缓存机制，将所有图片占据的内容维持在一个范围。详情可以参考郭霖的博客 但是，还有一种情况，如果单个图片非常巨大，并且还不允许压缩(如清明上河图、世界地图等)，那么我们可以使用 BitmapRegionDecoder 来实现。 BitmapRegionDecoder 的原理是：给定一个矩形区域(Rect)，然后通过 Bitmap bitmap = mDecoder.decodeRegion(mRect,opthions) 方法来获取这个区域的 bitmap 展示。因此我们大图展示过程中，都是一次次分割实现的。 以上内容参考自鸿洋、官方文档 39、关于Android绘制 点击看答案 原理60帧的画面让人感觉不到画面的更新，因此Android系统中基本上是 60帧/s的刷新频率，也就是每16ms 发出一次 VSYNC信号触发对UI的绘制。当然，我们要明白，这个 16ms 不只是全用来绘制界面，而是会包括layout、measure。 整体的过程就是，cpu执行计算任务，即 layout、measure后将ui计算成多维图形(多边形、纹理)，再经过OpenGL处理，之后交给GPU 进行栅格化后显示在屏幕上。 因此，16ms的时间主要被两件事情占用，第一件:将UI对象转换为一系列多边形和纹理；第二件：CPU传递处理数据到GPU进行栅格化 Frame Buffer中的数据是怎么来的GPU 从Frame Buffer 中获取数据绘制，但其除了 Frame Buffer 外，还有缓冲的Back Buffer ，GPU 也会定时地切换这两个 Buffer 的角色(可能其中一个为Frame Buffer，另一个就为 Back Buffer)，由于16ms 发出一次 VSYNC 信号，因此这个切换也是 16ms。 在系统将Back Buffer 交给应用填充数据时，实际过程是将 Back Buffer 锁定，讲一个指向它的引用交给你的应用，这个引用就是Canvas对象，View的onDraw 方法中接收到的Canvas就是它。我们知道，父view在onDraw的时候，会一直调用子View的onDraw方法，这个Canvas 就会一直传递下去给每一个View。当所有的View 都通过Canvas 绘制完成后，才算完成了一帧的绘制。 丢帧是怎么发生的上面说GPU 会定期交换 Back Buffer 和 Frame Buffer ，但是有一个例外情况，当你的应用正在往 Back Buffer 中填充数据时，系统会将 Back Buffer 锁定，如果到了 GPU 交换两个Buffer 的时间点，你的应用还在往Back Buffer 中填充数据，GPU 会发现 Back Buffer 被锁定了，它会放弃这次交换(即发生Jank了)，导致的结果就是手机屏幕仍然显示原来的图像，即用户在32ms内看到的是同一帧。 开发者如何避免可以从两个方面考虑： CPU产生的问题：不必要的布局和失效 GPU产生的问题：过度绘制(overdraw) 1、避免cpu 计算任务过重。1、减少在onDraw 方法中创建对象，尤其是复杂对象。 2、减少视图层次，尽量使用ConstrainLayout 等代替多层嵌套2、避免cpu、GPU 任务过重，减少不必要的View的invalidate 调用(不invalidate可以让gpu最大限度使用缓存)3、减少过度绘制。1、clipRect帮助识别可见的区域。2、去除View 中不必要的background，因为许多background 并不会显示在最终的屏幕上。比如ImageView，假如它现实的图片填满了空间，你就没有必要给它设置一个背景色。 以上内容参考自wei_lei、milter、jianshu 40、屏幕尺寸变化适配有什么手段 点击看答案 使用 match_parent、wrap_content 等方式藐视控件大小 使用宽度限定符，如 layout-w600dp 屏幕方向限定符，如 layout-land、layout_port 来适配横竖屏 使用Fragment，将界面组件化 使用.9图片 41、像素密度 点击看答案 为了保证在密度不同的屏幕上看起来尺寸相同，必须使用密度无关的像素(density-independent pixels，简称 dp 或者 dip) 作为单位。1dp 是以中密度屏幕(像素密度(dpi，每平方英尺上的像素个数)：160dpi)作为基准密度，在基准上1dp = 1px。不过在定义文本时，应该使用可缩放像素(scalable pixels，简称： sp)作为单位。默认情况下，dp 与sp大小相同，但是当用户在设置中调整文本大小时，sp就会变化了。还有，要注意的是，我们平时说的屏幕的尺寸是指的屏幕对角线长度。 以上内容参考自官方文档 42、彻底理解android 应用无响应机制 点击看答案 首先总结下ANR发生的情况以及阈值： ANR的原理基本上都是执行某项操作task之前，通过Handler 发送一个延时 Message，如果在延时时间到达之前 task 执行完成，则通过handler removeMessage 将Message 移除，否则，在延时时间到达之后还未能完成，Handler 便会处理这个message，从而抛出ANR。尤其需要注意的有以下几点： 通过静态注册的广播(动态广播不用考虑)在完成前会检查 SharedPreference 是否已经完成同步到磁盘，如果没有，要等其完成才能告知系统已经完成。 Provider 只有在进程首次启动的时候才会检测ANR，当provider 进程已经启动，再次请求provider 不会触发超时。 Activity 退出也会检查 sp 是否已经同步到磁盘，未完成的话，也会等待。 回答有哪些路径会导致ANR从handler 发送了 message 到 removeMessage 之前的任何一个环节都可能出现ANR，比如：service 的回调方法慢，比如主线程的消息队列存在耗时消息让service 的回调迟迟得不到执行，可能是sp操作缓慢，可以是system_server 进程的binder 线程繁忙，而导致 removeMessage 没来得及执行，也有可能是广播在等待sp操作，等等。 ANR 避免 主线程尽量只做UI相关操作，避免耗时操作，如过度绘制、IO操作 避免主线程与工作线程发生锁竞争 谨慎使用SharedPreference 以上内容参考自gityuan的博客、gityuan博客 43、为什么要使用Binder 机制进程间通信 点击看答案 Linux现有的IPC 方式 管道：信息复制2次。在创建时分配一个page大小的内存，缓存区大小比较有限； 消息队列：信息复制2次。额外的CPU消耗；不合适频繁或信息量大的通信； 共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决； 套接字(Socket)：信息复制2次。作为更通用的接口，传输效率低，主要用于同机器或跨网络的通信； 信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等； 为什么采用Binder(从5个维度)总结下：从性能的角度、从稳定性的角度、从安全的角度、从语言层面的角度、从公司战略的角度 从性能的角度:从拷贝次数看，仅次于共享内存。但是共享内存会遇到进程同步，太复杂。 从稳定性的角度：Binder 基于 C/S 架构，清晰明了，Client 端与Server 端相对独立。 从安全的角度：传统的Linux IPC 只能由用户在数据包里填入UID/PID，接收方无法获得对方进程可靠的 UID/PID ,从而无法鉴别对方身份。而Android 为每个安装好的应用都分配了自己的UID。此外，C/S架构有利于Server端根据UID鉴别访问权限。 语言层面：Binder 这种面向对象的思想与Android 开始的开发语言 Java 高度契合。 公司战略： 公司战略层面就不多说了 另外，Linux没有采用Binder 不是他们没想到，而是Binder 更适合Android这种手持设备而已。 以上内容参考自gityuan的csdn 44、Binder 机制 点击看答案 而一般的进程间通信方式(共享内存除外)，需要Client端进程空间拷贝到内核空间，再由内核空间拷贝到Server进程空间，会发生两次拷贝。 Binder 进程间的高效率通信的秘诀在于 binder_mmap() ，如下图示意： 虚拟进程地址空间(vm_area_struct)和虚拟内核地址空间(vm_struct)都映射到同一块物理内存空间。当Client端与Server端发送数据时，Client（作为数据发送端）先从自己的进程空间把IPC通信数据copy_from_user拷贝到内核空间，而Server端（作为数据接收端）与内核共享数据，不再需要拷贝数据，而是通过内存地址空间的偏移量，即可获悉内存地址，整个过程只发生一次内存拷贝。 进程和内核虚拟地址映射到同一个物理内存的操作是发生在数据接收端，而数据发送端还是需要将用户态的数据复制到内核态。 下图展示了通过Binder 进行进程间通信： 我个人理解，client 与server 双方都有进行 mmap 映射操作，但是在用户空间获取到的映射空间只能读，不能写。这样，双方发送数据时都只需要执行 copy_from_user 即可，在接收端通过地址偏移就能获取到数据 从universus的博客(据说这篇博客是介绍binder的神级存在)能看出来确实两端都有映射。 以上内容参考自gityuan的博客 45、动画 点击看答案 帧动画、View 动画(补间动画)、属性动画 帧动画就一帧帧播放 View动画：指定开始状态和结束状态，中间的view会自动被补齐，主要支持 平移、缩放、透明度、旋转 四种基本效果。主要应用场景： view的动画 以及 Activity、Fragment 的切换动画。注意：View 动画执行到某个位置时，它的动作响应(比如点击)还停留在原来位置的，只有点击原来位置才有效，因为它不是真正改变View的属性。 属性动画：真正的视图移动，点击移动后的视图会有效果。 以上内容参考自会飞的鱼 46、关于Android绘制 点击看答案 原理60帧的画面让人感觉不到画面的更新，因此Android系统中基本上是 60帧/s的刷新频率，也就是每16ms 发出一次 VSYNC信号触发对UI的绘制。当然，我们要明白，这个 16ms 不只是全用来绘制界面，而是会包括layout、measure。 整体的过程就是，cpu执行计算任务，即 layout、measure后将ui计算成多维图形(多边形、纹理)，再经过OpenGL处理，之后交给GPU 进行栅格化后显示在屏幕上。 因此，16ms的时间主要被两件事情占用，第一件:将UI对象转换为一系列多边形和纹理；第二件：CPU传递处理数据到GPU进行栅格化 Frame Buffer中的数据是怎么来的GPU 从Frame Buffer 中获取数据绘制，但其除了 Frame Buffer 外，还有缓冲的Back Buffer ，GPU 也会定时地切换这两个 Buffer 的角色(可能其中一个为Frame Buffer，另一个就为 Back Buffer)，由于16ms 发出一次 VSYNC 信号，因此这个切换也是 16ms。 在系统将Back Buffer 交给应用填充数据时，实际过程是将 Back Buffer 锁定，讲一个指向它的引用交给你的应用，这个引用就是Canvas对象，View的onDraw 方法中接收到的Canvas就是它。我们知道，父view在onDraw的时候，会一直调用子View的onDraw方法，这个Canvas 就会一直传递下去给每一个View。当所有的View 都通过Canvas 绘制完成后，才算完成了一帧的绘制。 丢帧是怎么发生的上面说GPU 会定期交换 Back Buffer 和 Frame Buffer ，但是有一个例外情况，当你的应用正在往 Back Buffer 中填充数据时，系统会将 Back Buffer 锁定，如果到了 GPU 交换两个Buffer 的时间点，你的应用还在往Back Buffer 中填充数据，GPU 会发现 Back Buffer 被锁定了，它会放弃这次交换(即发生Jank了)，导致的结果就是手机屏幕仍然显示原来的图像，即用户在32ms内看到的是同一帧。 开发者如何避免可以从两个方面考虑： CPU产生的问题：不必要的布局和失效 GPU产生的问题：过度绘制(overdraw) 1、避免cpu 计算任务过重。1、减少在onDraw 方法中创建对象，尤其是复杂对象。 2、减少视图层次，尽量使用ConstrainLayout 等代替多层嵌套2、避免cpu、GPU 任务过重，减少不必要的View的invalidate 调用(不invalidate可以让gpu最大限度使用缓存)3、减少过度绘制。1、clipRect帮助识别可见的区域。2、去除View 中不必要的background，因为许多background 并不会显示在最终的屏幕上。比如ImageView，假如它现实的图片填满了空间，你就没有必要给它设置一个背景色。 以上内容参考自wei_lei、milter、jianshu 47、Kotlin 优势 点击看答案 按照官网上的说法： 简洁。 判空、getter、setter 方法、命名传参(动态改变参数)无需重载，可能结合anko 之类的更加简单 安全 减少空指针等错误、类型判断过后，自动类型转换 兼容java 可以混编 48、多进程 webview 点击看答案 想着app只有一个 Cookies 的 db 文件，估摸着跨进程的 webview 能共享这个cookie数据。今天试了试，结果发现俩问题： 加上跨进程后，在一加6上(Android 10 系统)运行崩了，但是在魅族15上(Android 7.1.1系统)运行良好 主进程webview 的cookies 正常，但是新进程的webview 加载 cookies 缺失。 很奇怪的是，通过 adb shell ,run-as com.esun.ui ，获取app_webview 中的 Cookies 文件用sqlite3 打开，里面的 cookies 一条条又是正常的！初步断定是同步的问题，因为只有一个db文件，不可能不一样。 至于，一加手机不能正常使用，是因为Android P及以上的版本不支持从多个进程使用具有相同数据目录的Webview，官方的解决方法就是给不同进程的Webview 设置不同的数据目录(在Application中)： 123456789@RequiresApi(api = Build.VERSION_CODES.P)public static void initWebViewDataDirectory(Context context) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123; String processName = getProcessName(context); if (!context.getPackageName().equals(processName)) &#123;//判断是否是默认进程名称 WebView.setDataDirectorySuffix(processName); &#125; &#125;&#125; 以上内容参考自liudave、简书上的博客 49、无需root，获取应用在/data/data{packageName}/里面的数据 点击看答案 在debug 包情况下，我们可以在未经授权的情况下获取 /data/data{packageName}/ 目录下的数据，比如：Cookies 的db 文件(虽然没有db后缀，但是就是个db文件)、SharedPreference 的xml 文件等。具体步骤： 执行 adb shell run-as {包名} ，例如： run-as com.example.haha 这时候 ls 命令能看到我们 app 在/data/data/ 目录下的所有文件了 如果需要将 Cookies 文件拷贝到电脑桌面的话，我们需要先将其拷贝到sd卡上： 首先，拷贝到sd卡上： cp app_webview/Cookies /sdcard/ 其次，退出 shell 模式，执行： exit (多次执行，直到回到初始状态) 最后，使用adb pull 命令将文件拉出来 如果需要查看这个Cookies 的db 文件，可以使用以下指令即可查看： sqlite3 /home/sample/Desktop/Cookies.dump cookies 50、签名 点击看答案 APK Signature Scheme v1解压一个签名后的 APK ，在 META-INF 目录下会有三个文件： MANIFEST.MF、CERT.SF、CERT.RSA。它们就是v1签名的关键。 其中，MANIFEST.MF存储了APK中的每个文件的文件名和摘要，类似如下形式(上面是文件名，下面是文件的 SHA256 消息摘要之后进行 Base64编码)： Name: AndroidManifest.xmlSHA-256-Digest: bWeqbdj+sLYqFQPe/j3kjv7hGZZYFm+YheK2AwGnW90= CERT.SF 称为二次摘要文件。它的格式和 MANIFEST.MF 的一样，也是上面name，下面摘要，只不过摘要是对 MANIFEST.MF 中的摘要条目做摘要(对MANIFEST.MF摘要条目进行SHA-256摘要再base64处理,值得注意的是，CERT.SF中存储了 MANIFEST.MF 整个文件的 摘要值)： Name: AndroidManifest.xmlSHA-256-Digest: bQWn4Jvp6bjlQUQQ8cr1NO9nl9hrMXMTbVeXGULZwSI= 最后，CERT.RSA 文件与 CERT.SF 文件是相互对应的，二者的名字一样，它里面主要存储了证书的公钥、过期日期、发行人、加密算法、CERT.CF文件的签名(使用私钥对CERT.CF文件的签名)等。 从以上信息我们知道，使用不同的keystore进行签名时，除了 CERT.RSA 文件外，其余两个文件都是一样的。也就是说前两者主要保证各个文件的完整性，而 CERT.RSA 用来保证apk的来源即完整性。 v1 签名校验过程 检查apk中的文件对应的摘要值是否与 MANIFEST.MF 记录的一致 使用 CERT.RSA 文件检验签名文件 CERT.SF 文件是否被修改过 使用 CERT.SF 校验 MANIFEST.MF 文件是否被修改过 为什么这个顺序呢？假设一下，如果你改了apk的文件，那么在安装apk文件时，第一步通过 MANIFEST.MF 校验不通过；假如你改了文件重新计算摘要值，更新了 MANIFEST.MF 文件，那么必定与 CERT.SF 文件中计算的值不一样。最后的保障是 v1的缺点 META_INF文件不在校验范围内，很容易绕过 单个文件的完整性校验在安装的时候比较耗时 APK Signature Scheme v2v2签名不是针对单个文件，而是将apk分成 1M 大小的块，对每个块计算摘要(由于块摘要可以并行处理，因此可以提高校验速度)，之后对所有摘要进行摘要得到顶级摘要，之后利用私钥对顶级摘要签名得到数字证书(即得到数字证书)。如下图所示： 为了保护 APK 内容，整个 APK（ZIP文件格式）被分为以下 4 个区块： ZIP 条目的内容（从偏移量 0 处开始一直到“APK 签名分块”的起始位置) APK 签名分块 ZIP 中央目录 ZIP 中央目录结尾 可以看到，Android签名存放区域是zip文件的中央目录(central Directory)之前。v2对整个apk签名，因此如果需要对齐(zipalign)的话，必须先对齐后签名。 以上内容参考自csdn上的博客、简书上的博客、jb51 51、浅谈TouchDelegate的坑与用法 点击看答案 用于扩大点击区域 以上内容参考自简书 52、BitMap 内存管理 点击看答案 Android 2.3.3即更低版本无需使用bitmap 的时候，调用其 recycle() 方法 Android 3.0 及更高版本引入了 BitmapFactory.Options.inBitmap 字段，如果设置了此字段，那么采用 Options 对象的解码方法会在加载内容时尝试重复使用现有位图。不过，使用会有一些限制，尤其是4.4以前，仅支持大小相同的位图的复用。 原理：当Bitmap 从 LruCache 删除时，对其的软引用会防止在HashSet 中，以供之后通过 inBitmap 重复使用。 以上内容参考自官方文档 53、epoll 点击看答案 epoll机制提供了Linux平台上最高效的I/O复用机制，它的主要作用是I/O复用，即在一个地方等待多个文件句柄的I/O事件。 epoll的效率为什么比 select/poll高呢？有以下几个原因： 1、每次调用select 时，需要把感兴趣的事件都复制到内核中，二epoll 只在epll_ctl 进行加入操作的时候才复制一次2、epoll内部用于保存事件的数据结构使用的是红黑树，查找速度很快，二select采用数组保存信息，不但一次能等待的句柄有限，并且在事件较多时查找起来速度很慢 以上内容参考自《深入理解Android：卷II》 54、杂 点击看答案 系统有个 framework-res.apk ，这个APK 除了包含资源之外，还包含一些Activity(如关机对话框) ，这些Activity 实际上运行在 system_server 进程中，从这个角度看，system_server 是一个特殊的应用进程 LoadedApk 用于保存一些和 APK 相关的信息(如资源文件位置、JNI 库位置等) ActivityThread 中包含一个mLooper 成员，代表一个消息循环。mServices 用于保存 Service ，Activityes 用于保存 ActivityClientRecord，mAllApplications 用于保存 Appkication (注意，我们获取 ApplicationContext 的时候，首先从 LoadApk 中获取，没成功再从 ActivityThread 中获取)。 55、BroadCastReceiver 点击看答案 我们知道，在 BroadCastReceiver 的onReceive 中不能执行耗时操作，但是如果我们有这个需求的时候，怎么办呢？其实，如果这个处理比较耗时，可以采用异步的方式处理： 即先调用 BroadCastReceiver 的 goAsync 方法得到一个 PendingResult 对象，然后将该对象放到工作线程中处理，可以参考的代码如下： 12345678910111213141516171819202122232425262728public void onReceive(final Context context, final Intent intent) &#123; final PendingResult result = goAsync(); wl.acquire(); AsyncHandler.post(new Runnable() &#123; @Override public void run() &#123; handleIntent(context, intent);//耗时操作 result.finish(); &#125; &#125;);&#125;public final class AsyncHandler &#123; private static final HandlerThread sHandlerThread = new HandlerThread(\"AsyncHandler\"); private static final Handler sHandler; static &#123; sHandlerThread.start(); sHandler = new Handler(sHandlerThread.getLooper()); &#125; public static void post(Runnable r) &#123; sHandler.post(r); &#125; private AsyncHandler() &#123;&#125;&#125; 以上内容参考自 《深入理解Android：卷II》第268页、csdn的博客、简书的博客 Sticky 的广播，一旦有接收者注册，系统马上将该广播传递给它们。 动态注册的非order广播，在 sendBroadcast 的时候，可以直接发送，不需要等待上一个Receiver 接收处理完成后才发送下一个。而静态注册的广播，则必须处理完一个接收者才能处理下一个接收者。这是因为需要避免惊群效应，动态广播的接收者的进程是肯定存在的(如果不存在肯定没法注册),而静态注册的广播接收者不能保证它已经和进程绑定了(进程可能还没启动)，假如发送广播时，这些接收者进程都不存在，那么一下子就创建了多个进程，系统压力陡增。每次处理一个的recevier的坏处在于延时较长。 以上内容参考自《深入理解Android：卷II》 56、证书校验 点击看答案 主要是为了更进一步的安全，防止通过 fiddler 抓包 crt格式的证书保存在assets文件夹中，同时，也可以从后台获取证书，保存在sp文件中，从后台获取证书时，需要将tag(标记客户端当前已有证书的版本，由于本地默认在assets文件夹中有证书，所以默认也有个tag)传过去，如果tag为空，则后台肯定返回证书，否则，判断客户端不是最新证书的情况会返回最新证书。马上判断证书中是否包含请求证书这个接口的host，包括才算成功。如果asset中的证书未失效，那么下载的证书就下次使用；反之，得后台的证书下载下来马上就使用。通过 CertificateFactory 将crt文件格式的证书转换成 x.509 格式的对象，之后，对比本地证书的公钥和服务端返回的公钥的值是否一致来决定证书是否校验通过。 有个细节，获取证书的这个接口请求是通过ip请求的(首先通过 114 或者 119 获取host 的ip)，然后将真正的host设置在 header 中，在从后台下载到证书后，验证证书里面是否包含有这个接口的host，包含了才算通过。 57、RecyclerView与ListView的区别1、局部刷新。RecyclerView 可以局部刷新，而ListView不可以2、ListView的ViewHolder 需要自己定义，并且不是强制要求的；而RecyclerView 是已经封装好了，是强制的3、ListView 的Adapter 继承的是 BaseAdapter；RecyclerView 的Adapter 继承的是 RecyclerView.Adapter4、ListView可以设置分割线；RecyclerView 只能自己些DecodeItem5、ListView 可以针对Item直接添加点击事件，RecyclerView只能自己写回调6、ListView的显示方式没有RecyclerView灵活，后者可以使设置成瀑布流、竖直的、横向的，网格的7、缓存机制不同，缓存层级 参考自简书、简书","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题-Java基础","slug":"面试题-Java基础","date":"2019-11-09T13:25:00.000Z","updated":"2021-02-22T02:19:25.591Z","comments":true,"path":"2019/11/09/面试题-Java基础/","link":"","permalink":"https://glassx.gitee.io/2019/11/09/%E9%9D%A2%E8%AF%95%E9%A2%98-Java%E5%9F%BA%E7%A1%80/","excerpt":"1、Java 多态 点击看答案 多态存在的三个必要条件：一、要有继承关系 二、要重写方法 三、父类指向子类对象。 多态就是指允许不同类的对象(如：父类的多个子类)，对同一消息做出不同响应(同一个函数调用在不同子类中的行为不同)。 多态的实现：动态绑定(dynamic binding),即在执行期间判断所引用的对象的实际类型，根据实际类型再调用相应方法。 Java 中多态的表现：接口的实现、继承父类进行方法重写 以及 同一个类中进行方法重载。 以上内容参考自： Java多态","text":"1、Java 多态 点击看答案 多态存在的三个必要条件：一、要有继承关系 二、要重写方法 三、父类指向子类对象。 多态就是指允许不同类的对象(如：父类的多个子类)，对同一消息做出不同响应(同一个函数调用在不同子类中的行为不同)。 多态的实现：动态绑定(dynamic binding),即在执行期间判断所引用的对象的实际类型，根据实际类型再调用相应方法。 Java 中多态的表现：接口的实现、继承父类进行方法重写 以及 同一个类中进行方法重载。 以上内容参考自： Java多态 Java集合 2、ArrayList 与 LinkedList的区别 点击看答案 ArrayList的特点： 以数组实现，初始空间是10，节约空间 有容量限制，当超出限制时，新增50%容量，即容量变为原来的1.5倍，如果还不够，则直接扩充为需求值，之后将原来数据拷贝到新的空间中，比较耗时 按照数组下标访问元素——get(i)/set(i,e) 性能很高 按照下标插入、删除元素，需要移动受影响的元素，性能就会变差(remove操作可以理解为删除index为0的节点，并将后面的元素移到0处) LinkedList的特点： 以双向链表实现，链表无容量限制，但是双向链表本身使用了更多空间 按下标访问元素——get(i)/set(i,e)，要遍历链表将指针移动到位(如果i&gt;链表的一半，会从末尾开始移动) 插入、删除元素时，只需要修改前后节点的指针即可。但如果是指定位置插入和删除，则还是需要遍历部分链表的指针才能移动到下标所指的位置。如果只是在链表两头的操作就能省掉指针的移动。 参考链接：ArrayList、LinkedList) 3、HashMap 点击看答案 根据官方描述，HashMap 基于 Map 接口实现，允许null 键/值，非同步、不保证有序(比如插入顺序)、顺序可能会随时间变化。 两个重要的参数容量(Capacity)就是bucket大小，负载因子(Load factor)就是bucket填满程度的最大比例。若对迭代性能要求高，则capacity不宜设置过大，同时load factor也不宜设置过小；当buckets的数目大于 capacity * load factor 时，就需要调整buckets 的大小为当前的2倍。 hashMap的put函数实现 对key的hashCode 做hash，然后计算index； 如果没有碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets 后； 如果碰撞导致链表过长，达到某个阈值后，则把链表转换成红黑树； 如果节点已经存在，就替换 old value (保证key的唯一性)； 如果bucket满了，就要resize； 注意，插入元素采用头插法，因为HashMap的发明者认为，后插入的Entry被查找的可能性更大。 get函数的实现 bucket里第一个节点，则直接命中； 如果有冲突，则通过 key.equals(k) 方式去查找对应的 entry。 若为树，则树中通过key.equals查找，时间复杂度为 O(logn);若为链表，则链表中通过key.equals查找，时间复杂度为 O(n)。 hashmap细节 hashmap的初始长度是16，并且手动初始化或者每次自动扩展时，长度必须是2的幂。 这里主要强调是2的幂，至于为什么是16，主要是为了让key到index的映射更加均匀。前面提到，index = Hash(key) ，如何实现一个尽量分布均匀地hash函数。有人说可以通过求余的方式： index = hashCode(key) % length ，不过求余的方式虽然简单，但是效率不高，Hashmap中采用了位运算方式，其公式为： index = hashCode(key) &amp; (length - 1) 以具体例子来说，假如某个key 的 hashCode(二进制) = 101110001110101110 1001，hashmap的默认长度length = 16 ，则 length - 1 为15，二进制数据为 1111，把两个二进制数据做位与操作得到 1001,即十进制的 9 ，所以index = 9。所以这里，index的结果完全取决于hashCode的最后4位(当然，java8中，会将这个hashCode的高16位不变，低16位和高16位做异或操作作为低16位的值，之后才与 length -1 做位与，这样避免只有低4位是有效位，从而进一步降低碰撞，因为参与的位数多了)。 所谓为什么要是2的幂，也即如果不是2的幂会怎样？比如hashMap的长度是 10，还是以上面的例子：hashCode(二进制) = 101110001110101110 1001，length - 1 = 9 ，即 1001，则index 也还会是1001(因为hashCode的后4位也是1001)，单独看这里没什么问题，但是从此我们可以推断：如果hashCode的后 4 位是 1001、1101、1111，1101等等，它们的结果都会是 1001，因为相当于只有第1位和第4位在起作用，这不符合index均匀分布的要求。那如果是2的幂呢？则length - 1后，所有的位数都是1，则每位都会起作用。 Hashmap的容量是有限的，当容量达到一定的饱和度的时候，Key映射位置发生碰撞的概率会上升，这好理解，因为如果每个坑都差不多有entry在了，无论你index是多少，都会碰撞，所以元素越多，越容易发生碰撞。java中的条件是 : hashmap.size &gt;= capacity * load factor 的时候，就需要resize，需要经历两个步骤，1、扩容，创建一个新的Entry数组，长度是以前的2倍，2、ReHash，遍历原来的 Entry数组，把所有的Entry 重新hash到新的数组，因为数组长度变化了，hash的规则也会改变，所以需要rehash。这里不需要重新计算hash，只需要判断原来的hash值新增的那位是0 还是1，如果是0的话，索引还是没变化，如果是1，则索引变成 “原索引 + oldCapacity”。 举个例子拉说，如果以前的capacity 是 8，则resize后变成16，以前的length - 1 为 111 现在则变成了 1111，多了一个有效位，所以只要判断 hashCode 的对应新增的那位的值是0还是1了，0的话，整个index还是不变，1的话，就在index的基础上加上老的容量 8 即可。 前面提到，key和value都可能为null，如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中。 Hashmap的线程不安全如何体现？ 如果多个线程同时使用put添加元素，如果发生碰撞，最终只有一个线程值被保存，因为另一个的会被覆盖。 由于resize操作存在，hashmap在多线程的情况下，可能会出现死循环，具体参考：小灰的解释 参考链接： 知乎链接、hashmap介绍链接 4、HaShMap 链表元素到达8的时候转红黑树的若干问题 点击看答案 首先，得满足两个条件才会转红黑树：一个是链表长度到8,一个是数组长度到64 为什么到8才转成红黑树？首先根据统计节点数&gt;=8概率是很小的(千分之一)，并且到8的时候，会引起性能下降，且因为转红黑树消耗性能，所以到 8 才转。 会根据红黑树状态以及红黑树节点总数到6这个阈值来将红黑树退回链表，这主要是是因为 8 和 6 这两个数字相差2，不至于插入删除一个元素导致来回转换 为什么不一开始就采用红黑树？因为红黑树是有额外的空间开销的，并且红黑树涉及左旋右旋等操作(我自己臆测的，也没看到有好的说法) 以上问题参考自hashmap转红黑树的两个条件 、HashMap的问题、cnblogs的博客、 5、HashTable 点击看答案 HashTable 类似于HashMap ，它同样基于hash表实现，每个元素也是key-value 对，也是通过单链表解决冲突，容量不足时，也会resize，二者区别是： HashTable 的key和Value 都不能为null，而HashMap允许。 HashTable 默认大小是 11，扩容方式是 old*2 + 1,而HashMap 默认大小是16，要求数组大小是2的幂，扩容时，直接扩为2倍。 获取index的方式不一样，Hashtable 采用除余的方式，而HashMap采用 位与的方式，效率更高。 HashTable 保证方法调用的线程安全，因为在每个方法前都有synchronize 关键字。而HashMap 没有，因此在线程安全条件下效率更高。 上文的参考链接 6、ConcurrentHashMap 点击看答案 想要避免HashMap 的线程安全问题有很多办法，比如采用 HashTable 或者 Collections.synchronizedMap ，但是这两者有共同的问题：性能，因为无论是读还是写操作，它们都会给整个集合加锁，导致同一时间的其他操作阻塞。如下图所示： 此时，ConcurrentHashMap应运而生，理解 ConcurrentHashMap 关键要理解一个概念： Segment 。Segment 本身就相当于一个 HashMap 对象，Segment 包含一个HashEntry 数组，数组中每个 HashEntry 既是一个键值对，也是一个链表的头结点，如下图所示： 这样的Segment 在ConcurrentHashMap 中有2 的N 次方个，共同保存在一个名为 segments 的数组中。因此，整个 ConcurrentHashMap 的结构如下： 这个二级结构，和数据库的水平拆分有些相似。采取这样的结构就是锁分段技术，每个segment 就好比一个自治区，读写操作互不影响。所以，ConcurrentHashMap 操作会有以下几种可能性： 不同Segment 可以并发写入。 同一 Segment 可以同时读和写。 同一个 Segment 并发写入时，只有一个线程可以执行，其他的线程阻塞。因为 Segment 的写入会加锁。 通过以上分析我们知道，ConcurrentHashMap 中每个 Segment 各自持有一把锁。在保证线程安全的情况下，降低了锁的粒度，让并发操作效率更高。 get 方法 为输入的key做 Hash 运算，得到hash值。 通过hash值，定位到对应的 Segment 对象。 再次通过 hash 值，定位到 Segment 中数组的具体位置。 put 方法 为输入的key 做Hash 运算，得到hash 值。 通过hash值，定位到 Segment 对象。 获取可重入锁。 再次通过 hash 值，定位到 Segment 当中的具体位置。 插入或者覆盖 HashEntry 对象。 释放锁。 size 方法获取 ConcurrentHashMap 总元素数量，自然要把各个 Segment 的元素汇总起来，但是如果在统计过程中，已经统计过的 Segment 瞬间插入新的元素，这时候怎么办呢？其实，这个size调用过程的大体逻辑如下： 遍历所有 Segment。 把 Segment 的元素数量累加。 把 Segment 的修改次数累加起来。 判断所有Segment 的总修改次数是否大于上一次的修改次数，如果大于，说明统计过程中有修改，重新统计，同时尝试次数 +1；否则，说明没有修改，统计结束。 如果尝试次数超过阈值，则对每一个Segment 加锁，再重新统计。 此时，统计的结果肯定正确，统计结束，释放锁。 为了尽量不锁住所有的Segment ，首先乐观假设Size过程中不会有修改，当尝试一定次数后，才无奈转换为悲观锁。 以上文章参考小灰的分析 7、HashMap 、 HashTable 和 ConcurrentHashMap 的区别？ 点击看答案 HashTable 是 HashMap 的线程安全实现，但是 HashTable在竞争激烈时效率低下，因为访问所有 HashTable 的线程都竞争同一把锁。ConcurrentHashMap 采用锁分段技术，将数据一段段存储，每段一把锁，当两个线程访问不同段数据时不受干扰，当然，contentValue和size等方法需要了解整体数据的情况下，还需要锁住整个表。 8、LinkedHashMap 点击看答案 LinkedHashMap 是Hash表和链表的实现，并且保存了记录的插入顺序。因为LinkedHashMap里面的Entry比HashMap多了两个字段：after和before，而以前的HashMap中的next 字段没有变化，从而额外构成一个双向链表，当然就可以在keySet()时按插入顺序输出，LinkedHashMap结构如下图所示： 与HashMap的区别：1、保存了记录的插入顺序，遍历的时候，首先打印最先插入的记录。2、遍历的时候比HashMap慢，因为LinkedHashMap 遍历链表，而HashMap可以说是根据capacity 遍历链表。不过如果HashMap容量很大并且实际数据比较少的情况下，遍历起来可能比LinkedHashMap慢。3、HashMap的遍历速度和容量有关，而LinkedHashMap 遍历速度只和实际数据有关。 以上内容参考这个链接，从知乎这个问题得到了灵感，忽然想明白了这个结构。 9、WeakHashMap 点击看答案 WeakHashMap，从名字可以看出它是某种 Map。它的特殊之处在于 WeakHashMap 里的entry可能会被GC自动删除，即使程序员没有调用remove()或者clear()方法。 更直观的说，当使用 WeakHashMap 时，即使没有显示的添加或删除任何元素，也可能发生如下情况： 调用两次size()方法返回不同的值； 两次调用isEmpty()方法，第一次返回false，第二次返回true； 两次调用containsKey()方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key； 两次调用get()方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。 遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉？其实不然，WeekHashMap 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。 以上内容参考 知乎的大神 10、TreeMap 点击看答案 HashMap不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了。TreeMap 实现了 SortedMap 接口，它是有序的集合。而且是一个红黑树结构。每个key-value都作为一个红黑树的节点。 使用红黑树的好处是能够使得树具有不错的平衡性，这样操作的速度就可以达到log(n)的水平了。 以上文章参考java集合-TreeMap、oschina链接 还有这个大牛 11、Java泛型 点击看答案 Java 泛型主要关注几点： 类型通配符顾名思义就是匹配任意类型。如如下写法：List&lt;?&gt; list ; 带限通配符上限通配符：使用extends 关键字指定这个类型必须继承某个类或者实现某个接口，也可以是该类(接口)本身。如： List&lt;? extends Shape&gt; ，表示集合中所有元素都是Shape 类型或者它的子类。 下限通配符：使用super 关键字指定这个类型必须是某个类的父类，或者某个接口的父接口，也可以是这个类本身。如：List&lt;? super Circle&gt; ，表示集合中所有元素都是Circle 类型或者是其父类。 类型擦除 Class c1=new ArrayList().getClass();Class c2=new ArrayList().getClass();System.out.println(c1==c2); 输出 true ，也就是说编译后的class文件中不会包含任何泛型信息，泛型信息不会进入到运行时阶段。 由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类 以上内容参考自Java泛型 12、Java抽象类和接口的区别 点击看答案 abstract class和interface是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。 abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于 abstract class和interface的选择显得比较随意。 但是，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。 总结： 设计理念上，接口反映的是”like-a”关系，抽象类反映的是”is-a”关系，即接口表示这个对象能做什么，抽象类表示的是这个对象是什么(想象一下，人可以吃东西，狗也能吃东西，接口反映的是吃东西这个动作，而抽象类能反映的，可能就是人这个物种)。 抽象类与接口都不能直接实例化。 抽象类被子类继承，接口被子类实现。 接口中定义的变量只能是公共的静态常量(即 public static final)，抽象类中是普通变量。 抽象类中可以没有抽象方法，接口中可以没有方法，但是有方法一定要有抽象方法。 接口可以被类多实现(类可以实现多个接口)，抽象类只能被单继承。 接口中没有this 指针，没有构造函数，不能拥有实例变量或实例方法。 关于接口，再多啰嗦几句： 接口用于描述系统对外提供的服务，因此接口中的成员变量和方法都必须公开(public)，确保所有使用者能访问。 接口仅描述系统能做什么，但不指名如何做，因此所有方法都是抽象(abstract)方法。 接口不涉及任何具体实例(this关键字)的相关细节，因此接口没有构造方法，没有实例变量，只有静态(static)变量。 接口中的变量是所有实现类公有的，既然公有，肯定是不变的东西，所以变量是不可变(final)的。 通俗讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中。接口对修改关闭，对扩展开放，是开闭原则的体现。 以上内容参考自：Java抽象类和接口的区别、程序媛想事 13、Java transient关键字 点击看答案 Java序列化时，transient关键字用于属性前时，该属性就不会被序列化。它的使用可以总结为下面几点： 变量被 transient 修饰时，变量将不会是对象持久化的一部分。 transient 只能修饰变量而不能修饰方法和类，并且也不能修饰本地变量。 静态变量不管是否被 transient 修饰，均不能被序列化。 附：父类实现了Serializable，子类没有，父类有int a = 1、int b = 2、int c = 3子类有int d = 4、int e = 5序列化子类的时候，d和e会不会被序列化？（答案：会） 反过来父类未实现Serializable，子类实现了，序列化子类实例的时候，父类的属性是直接被跳过不保存，还是能保存但不能还原？（答案：值不保存） 以上内容参考自：Java transient关键字 14、Java finally与return执行顺序 点击看答案 首先探讨下，try-catch-finally 块中的语句是否一定被执行？答案是否定的，原因有2个： 如果try 语句没有被执行(比如在try 之前就return 了)，finally就不会执行。 如果try 块中有 System.exit(0)这样的终止Java 虚拟机的语句的话，finally就不会执行。这可以理解，连JVM 都停止了，啥都没有了。 关于finally 与return 的执行顺序，过程比较复杂，可以分为如下情况： 正常情况下，finally 语句在return 语句执行之后，return 返回之前执行的。 123456789101112131415161718192021public class FinallyTest1 &#123; public static void main(String[] args) &#123; System.out.println(test11()); &#125; public static String test11() &#123; try &#123; System.out.println(\"try block\"); return test12(); &#125; finally &#123; System.out.println(\"finally block\"); &#125; &#125; public static String test12() &#123; System.out.println(\"return statement\"); return \"after return\"; &#125;&#125; 会输出： try blockreturn statementfinally blockafter return 可以看出，try 中的return语句先执行了，但是值没有立即返回，等finally执行结束后再返回值。 如果finnaly 块中有return 语句会覆盖 try 中的 return 返回。 如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变(int 类型和 Map 类型)。 try 块里的return 语句在异常情况下不会执行，怎么返回看情况。 以上内容参考自：Java finally与return执行顺序 15、两个对象的 hashcode 相同，是否对象相同？equal() 相同呢？ 点击看答案 hashCode是所有java对象的固有方法，默认返回的是该对象在jvm的堆上的内存地址，不同对象的内存地址肯定不同，所以这个hashCode也就肯定不同了。如果重载了的话，由于采用的算法的问题，有可能导致两个不同对象的hashCode相同。 hashCode和equals两个方法是有语义关联的，它们需要满足：A.equals(B)==true –&gt; A.hashCode()==B.hashCode()，但是反之不能说hashcode相等就equals因此重载其中一个方法时也需要将另一个也重载。 此外，请注意：hashCode的重载实现最好依赖于对象中的final属性，从而在对象初始化构造后就不再变化。一方面是jvm便于代码优化，可以缓存这个hashCode；另一方面，在使用hashMap或hashSet的场景中，如果使用的key的hashCode会变化，将会导致bug，比如放进去时key.hashCode()=1，等到要取出来时key.hashCode()=2，就取不出来数据了。综上所述，hashCode相同或者equals相同并不能说明对象相同。 16、延伸-Java 中 hashcode 的作用 点击看答案 官方文档的定义就是： hashcode 方法返回对象的哈希码值，支持该方法主要是为了支持基于哈希机制的Java 集合类，如HashMap、HashSet、HashTable 等。 hashcode的常规约定是： Java程序运行期间，同一个对象上多次调用 hashcode ，必须一致地返回相同的整数，而从某一应用程序的一次执行到同一程序的另一次执行，该整数无须保持一致。如果两个对象相等，那么两个对象中的每个对象上调用 hashcode 方法都必须生成相同的整数结果。 以上内容参考自：OUYM 17、延伸-为什么重写了equals 方法，要求必须重写hashcode 方法？ 点击看答案 根据前面的内容，总结就是：为了满足常规约定-如果两个equals 满足，就一定要求返回相同的 hashcode。举个例子，如果重写了 equals 方法，对象中 num 和data 参与了equals 比较，那么 num 和data 也要参与生成hashcode，这是为了遵守上述约定。 18、生成hashcode 注意的事项 点击看答案 返回的hash值是int型，防止溢出 不同对象返回的hash值尽量不同(为了hashmap 等集合减少碰撞) 无论何时，对同一个对象调用hashcode()都应该产生同样的值 最后一点是很重要的，也是容易出隐形bug的地方，如果将一个对象put() 到HashMap 时产生了一个 hashcode 值，而 get() 取出时却产生了另外一个hashcode，那么就无法获取该对象了。所以，如果hashcode() 方法依赖于对象中易变的数据，那就要当心了。 以上内容参考自：OUYM 19、下面代码输出的结果？ 点击看答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//题目1String str1 = \"hello\";String str2 = \"he\" + new String(\"llo\");System.err.println(str1 == str2);//答案是false，因为str2中的llo是新申请的内存块，而==判断的是对象的地址而非值，所以不一样。//题目2public static void main(String args[]) &#123; Thread t = new Thread() &#123; public void run() &#123; pong(); &#125; &#125;; t.run(); System.out.print(\"ping\"); &#125; static void pong() &#123; System.out.print(\"pong\"); &#125; &#125; //输出 pongping ，这里调用的是Thread 的run 方法，与普通方法是一样的，失去线程的特性了。因此我们要启动新县城执行的时候，需要使用Thread 的 start() 方法。 //题目3，如下代码是否能正常运行？public class NULL &#123; public static void test()&#123; System.out.println(\"haha\"); &#125; public static void main(String[] args) &#123; ((NULL)null). test(); &#125;&#125;//能正常运行，输出 haha 。首先，null 值可以强转成任何 Java 类型，所以 (NULL)null 、(String)null 等都是合法的。其次，test 方法是static 方法，只和类名绑定，不借助对象进行访问。综上，能正常输出。反之，如果 test 非static ，就只能使用对象访问，这时候使用null对象肯定会报空指针。 //题目4，如何输出class People &#123; String name; public People() &#123; System.out.print(1); &#125; public People(String name) &#123; System.out.print(2); this.name = name; &#125;&#125;class Child extends People &#123; People father; public Child(String name) &#123; System.out.print(3); this.name = name; father = new People(name + \":F\"); &#125; public Child() &#123; System.out.print(4); &#125; &#125;//会输出132，在Java 中，子类的构造过程中必须调用其父类的构造函数，因为有继承关系存在，子类要把父类的内容继承下来。//题目5，如何输出public class HelloA &#123; public HelloA() &#123; System.out.println(\"HelloA\"); &#125; &#123; System.out.println(\"I'm A class\"); &#125; static &#123; System.out.println(\"static A\"); &#125;&#125;class HelloB extends HelloA &#123; public HelloB() &#123; System.out.println(\"HelloB\"); &#125; &#123; System.out.println(\"I'm B class\"); &#125; static &#123; System.out.println(\"static B\"); &#125; public static void main(String[] args) &#123; System.out.println(\"-------main start-------\"); new HelloB(); new HelloB(); System.out.println(\"-------main end-------\"); &#125;&#125;//会输出如下结果：static Astatic B-------main start-------I'm A classHelloAI'm B classHelloBI'm A classHelloAI'm B classHelloB-------main end-------这个题目很好，考察静态语句块、构造语句块(就只有大括号的那块) 以及 构造函数执行顺序。对象初始化顺序：1. 类加载之后，从父类到子类执行被static 修饰的语句； 2.static 执行完毕后，再执行main 方法； 3.如果有语句new自身对象，将从父类到子类执行构造语句块、构造器。 20、延伸-类的初始化步骤 点击看答案 没有父类的情况： 类的静态属性 类的静态代码块 类的非静态属性 类的非静态代码块 构造方法 有父类的情况: 父类的静态属性 父类的静态代码块 子类的静态属性 子类的静态代码块 父类的非静态属性 父类的非静态代码块 父类构造方法 子类非静态属性 子类非静态代码块 子类构造方法 以题目深化理解： 12345678910111213141516171819202122public class Singleton &#123; private static Singleton singleton = new Singleton(); public static int counter1; public static int counter2 = 0; private Singleton()&#123; counter1 ++; counter2 ++; &#125; public static Singleton getSingleton()&#123; return singleton; &#125;&#125;public class TestSingleton &#123; public static void main(String args[])&#123; Singleton singleton = Singleton.getSingleton(); System.out.println(\"counter1 = \" + singleton.counter1); System.out.println(\"counter2 = \" + singleton.counter2); &#125;&#125; 上述代码将输出： counter1 = 1counter2 = 0 根据类初始化步骤，由于 Singleton 并没有被加载过，所以首先执行类加载步骤，在“准备”阶段，首先给静态变量赋初默认值：singleton = nullcounter1 = 0counter2 = 0 加载和连接完毕，再进行初始化工作，依照代码写的顺序依次执行，首先执行 singleton = new Singleton();这样就会执行构造方法的内部逻辑，即此时 counter1 = 1; counter2 = 1; 接下来，由于counter1 只进行了定义，并没有初始化，所以counter1的值仍然为1 ；接下来，counter2 进行了定义并且赋值 0 ，则初始化阶段后，counter2 的值为0； 初始化完毕，要调用Singleton.getSingleton() ，由于singleton 的值已经初始化过，此时直接返回即可。因此输出 counter1 = 1，counter2 = 0。 反之，如果将静态变量初始化的顺序改变下： 123public static int counter1;public static int counter2 = 0;private static Singleton singleton = new Singleton(); 则会输出 counter1 = 1，counter2 = 1 了，按照上述推理应该能够理解。 以上内容参考自：码个蛋，同时可以参考以前写的虚拟机的相关文章 21、constructor 是否一定要与类名同名，方法名是否一定不能与类名同名？ 点击看答案 constructor 是一定要与类名同名的，但普通的类方法是可以和类名同名的，它与构造方法唯一的区别就是构造方法没有返回值。 22、数据溢出与非法数据问题 点击看答案 存在使i + 1 &lt; i的数吗？答案是肯定的，比如i是int 类型，那么当i 是最大的整数时，i+1就溢出了，就可能&lt; i。 是否存在 i&gt;j || i&lt;= j 不成立？答案是肯定的，比如：Double.NaN 或者 Float.NaN 以上内容参考自程序媛想事 23、Java 的参数传递 点击看答案 在讨论之前，首先看下如下代码的输出情况： 123456789101112131415161718public class Example &#123; String str = new String(\"good\"); char[] ch = &#123; 'a', 'b', 'c' &#125;; public static void main(String args[]) &#123; Example ex = new Example(); ex.change(ex.str, ex.ch); System.out.print(ex.str + \" and \"); System.out.print(ex.ch); &#125; public void change(String paramA, char paramB[]) &#123; paramA = \"test ok\"; paramB[0] = 'g'; &#125;&#125; 上述代码输出good and gbc 。在Java 中没有引用传递，只有值传递，这个值指的是实参的地址的拷贝，得到这个值(地址拷贝)后，你可以通过它修改这个地址的内容，因为此时这个内容的地址和原地址是同一个地址，但是你不能改变这个地址本身使其重新引用到其他对象。以上的意思说明仅仅只是值传递。具体过程如果使用图示的话，如下所示： str的传递： 在change方法中重新为paramsA 赋值： ch的传递： 在change方法中更改paramsB 的元素值： 以上内容参考自：程序媛想事、RavenXRZ 24、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？查看以前写的这篇读书笔记即可 25、String、StringBuilder、StringBuffer、CharSequence 区别 点击看答案 CharSequence 是一个接口，String、StringBuilder、StringBuffer 都实现了这个接口，它们三个的本质都是通过字符数组实现的。 StringBuilder、StringBuffer 的char 数组开始的存储空间是16，如果append() 过程中超过这个容量，将会申请新的空间，并把老的数组一起复制过去。 StringBuffer 的每个处理方法都加上了 synchronized 关键字，因此可以说它是线程安全的。 26、Java 中String 为毛要设计成不可变？ 点击看答案 为什么说String 是不可变的首先我们看源码： 123public final class String implements Serializable, Comparable&lt;String&gt;, CharSequence &#123; private final char[] value;&#125; 类使用final 修饰，说明不可继承；存放内容的 value 是个char[]数组，也是final修饰，创建以后就不可改变。说明一下，这个 value 是stack 上的一个引用，数据本身还是在heap堆上。final 修饰value ，只能是说stack 指向的引用地址是不可变的，但是堆里面的数据本身还是可变的！举例理解下： 123456final int[] value=&#123;1,2,3&#125;int[] another=&#123;4,5,6&#125;;value = another;//编译器报错，final不可变final int[] value=&#123;1,2,3&#125;;value[2]=100;//这时候数组里已经是&#123;1,2,100&#125; 通过以上代码相信就能理解上面描述的意思了。也许有人还认为String是可以变的，并且举例如下： 12String a = \"abcd\";a = \"abcdef\"; 这其实不是String本身变化，只是变量a指向heap堆的指针发生了变化，而String本身并没有发生变化，示意图如下： 为什么要设计成不可变首先，先得清楚 final 这个关键字。 final的出现就是为了为了不想改变，而不想改变的理由有两点：设计(安全)或者效率。 字符串常量池的需要。String 带有字符串常量池的属性，如果两个字符串one和two都指向 “something” 赋值，它们其实都指向同一个内存地址。这样在大量使用字符串的情况下，可以节省内存空间，提高效率。之所以能实现这个特性，String 的不可变是必要的(如果可变，那么一个改了，所有引用常量池这个string值都会改变)。 允许String对象缓存HashCode。String 对象的哈希码被频繁使用，比如在HashMap 中。 其次，为了安全。多线程安全：多个线程同时读一个资源，不会引发竞态条件，但是对资源做写操作就会有危险，这样保证String使用线程安全。url、反射所需要的参数等都是String类型，如果允许改变，会引起安全隐患(比如非法访问：如果String可变，那么可以在安全检测后，修改String值，导致非法访问)。 一定是不可变的吗？由以上内容可知，String 是通过字符数组实现的，这个字符数组被final 修饰，因此不能重新指向其他内存区域，但是，我们可以针对这块内存区域改变值，即改变这个数组里面的内容，比如将 value[0] 的值由 ‘a’ 改成 ‘b’(当然这个过程要通过反射去实现)。 可能令你疑惑的操作方式我们平日开发通常情况下少量的字符串拼接其实没太必要担心，例如: String str = “aa”+”bb”+”cc”; 像这种没有变量的字符串，编译阶段就直接合成”aabbcc”了，然后看字符串常量池（下面会说到常量池）里有没有，有也直接引用，没有就在常量池中生成，返回引用。 如果String a = “123”;这种写法是会将 “123” 放入常量池的，但是如果使用 String b = new String(“123”); 则会在堆上分配空间存放。 但是如果： 123String str1 = \"aaa\";String str2 = \"bbb\";String str = str1+str2; 则在编译的时候会优化成： StringBuilder sb = StringBuilder(String.valueOf(str1))).append(str2) 如果： 1234StringBuffer sb = new StringBuffer();String s = null;sb.append(s);System.out.println(sb.length()); 则会输出4，因为如果是null的话，则会拼接 “null”。 以上内容参考自：qingmengwuheng1 以及 岚之山 27、成员内部类、静态内部类、局部内部类和匿名内部类的理解 点击看答案 成员内部类成员内部类定义在另一个类的内部，它是依赖外部类而存在的，也就是说如果要创建内部类的对象，前提是必须存在一个外部类的对象，以下是两种内部类使用情况： 123456789101112131415161718class TestClass&#123; public void haha()&#123; //典型用法：在当前外部内中直接使用内部类 InnerClass innerClass = new InnerClass(); //非典型用法：使用某个类的内部类 OutBean outBean = new OutBean(); OutBean.InnerBean = outBean.new InnerBean(); &#125; class InnerClass&#123; &#125; class OutBean&#123; class InnerBean&#123; &#125; &#125;&#125; 注意代码中典型用法和非典型用法成员内部类对象的创建，说明了内部类对象的创建是依赖于外部类对象的，尤其是： outBean.new InnerBean() 这种写法。 成员内部类可以用private、protected、public 及包访问权限修饰，如果成员内部类被private修饰，则只能在外部内的内部访问；如果使用public修饰，则任何地方都能访问；如果使用protected修饰，则只能在同一个包下，或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。 成员内部类可以无条件访问外部类所有的成员属性和方法(包括private的和static的)，不过如果内部类和外部类有相同名称的变量或者方法时，优先访问内部类自己的，如果要访问外部类的可以如下写法： 外部类.this.成员变量(方法) 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于它的访问尽心阿玉方法内或者作用域内。由于类似于局部变量，所以并不能有 public、protected、private 或者 static 修饰符的。示例如如下代码： 1234567public People getWoman()&#123; class Woman extends People&#123;//局部内部类 int age = 0; &#125; return new Woman();&#125; 匿名内部类匿名内部类我们使用很多，比如在实现点击监听的时候： 123456btnOk.setOnclickListener(new OnclickListener()&#123; @Override public void onClick()&#123; &#125;&#125;); 匿名内部类是为一种没有构造器的类，大部分匿名内部类用于接口回调，一般来说，匿名内部类用于继承其他类或者接口，并不需要增加额外地方法，只是对继承方法的实现或者重写。 静态内部类静态内部类定义在一个类里面，并且被static 修饰，并不需要依赖于外部类。这点和类的静态成员属性有点类似，并且它不能使用外部类的非static 成员变量或者方法。 深入理解内部类1、为什么成员内部类可以无条件访问外部类成员？因为编译器会默认为内部类构造器中添加一个参数，这个参数是外部类对象的一个引用，所以它能直接访问外部内的成员。这也从侧面说明成员内部类为什么要依赖于外部类的对象。 2、为什么局部内部类和匿名内部类只能访问局部final 变量？我们首先看如下代码： 12345678910public void test(final int b)&#123; final int a = 10; new Thread()&#123; public void run()&#123; System.out.println(a); System.out.println(b); &#125; &#125;.start();&#125; 如果把变量a或者b任意一个final 去掉，代码就编译不过。至于为什么，我们首先考虑一个问题：当test 方法执行完成后，变量a的生命周期结束了，而Thread对象的生命周期可能还没结束，那么在Thread的run方法中继续访问a就实现不了了，但是又要实现这样的效果，怎么办？Java中采用了 复制 手段来解决，也就是将a复制到Thread对象中。 也就是说，如果局部变量的值在编译期间就能确定，则直接在匿名内部类中创建一个拷贝；如果局部变量的值无法再编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值 内部类的场景和好处 每个内部类都能独立继承一个接口实现，所以无论外部类是否已经继承了某个实现，对内部类都没有影响。内部类使得多继承的解决方案变得完整。 方便将存在一定逻辑关系的类组织在一起，又可以对外隐藏 方便编写事件驱动程序(如实现点击监听) 以上内容参考自：Matrix海 子","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"第3章：一切皆组件","slug":"Flutter从0到1构建大前端应用-第3章","date":"2019-10-23T14:21:00.000Z","updated":"2019-11-17T13:42:34.387Z","comments":true,"path":"2019/10/23/Flutter从0到1构建大前端应用-第3章/","link":"","permalink":"https://glassx.gitee.io/2019/10/23/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8-%E7%AC%AC3%E7%AB%A0/","excerpt":"从布局来看，官方把 Flutter 布局分为 Basic widget、Single-child 和 Multi-child。在学习和实战中，记住一句关于 Flutter 的话：一切皆组件。基础组件(Basic widgets)在组件划分上，Container、Row、Column 在官方文档里属于基础组件，但是 Container 又属于单一子元素组件(Single-child)，而 Row、Column 又属于多子元素组件(Multi-child)。为了便于区分和记忆，本书约定基础组件是不能再拆分的院子组件。以下了解下常用的组件：","text":"从布局来看，官方把 Flutter 布局分为 Basic widget、Single-child 和 Multi-child。在学习和实战中，记住一句关于 Flutter 的话：一切皆组件。基础组件(Basic widgets)在组件划分上，Container、Row、Column 在官方文档里属于基础组件，但是 Container 又属于单一子元素组件(Single-child)，而 Row、Column 又属于多子元素组件(Multi-child)。为了便于区分和记忆，本书约定基础组件是不能再拆分的院子组件。以下了解下常用的组件： TextText 比较简单，基本用法如下： Text(“hello”); 当然，实际应用时还会有各种效果，比如文字大小、颜色、阴影等，常用属性如下表： 属性 取值 textAlign 对齐方式 maxLines 最大行数 textScaleFactor 缩放因子，默认 1.0 overflow 配合maxlines使用，超出最大行数可以用省略号或渐变效果隐藏多余行数 style TextStyle对象，其属性有color、fontFamily、background、fontSize、下划线等 textSpan 配合Text.rich使用，可实现类似富文本效果 IconIcon 即图标，在Android中支持系统自带的图标，mipmap文件夹中存放的就是Icon 类型图片。使用方式如下： Icon(Icons.search: Colors.blue) 可以根据AS的提示查看系统自带的Icon，这些其实是矢量图标字体(iconfont)，即这些图片的尺寸不管怎么改变，图标本身都是清晰的，且没有锯齿，我们可以像改变文字颜色一样改变图标颜色。如果系统自带的满足不了，推荐使用阿里妈妈的矢量图标字体库。Icon 除了使用图标字体以外，还支持传入图片： icon: “images/ic_company.png” ImageImage 的基本使用方式是从本地加载图片，代码如下： //AssetImage 也能写成 Image.assetImage(image: AssetImage(“images/image_icon.png”),width: 50.0) 如果从网络加载一张图片： 1234Image( image: NetworkImage(\"https://www.phei.com.cn/templates/images/img_logo.jpg\"), width: 120.0,) 除上述方式，还可以通过 Image.file、Image.memory 的方式进行加载。 ButtonFlutter 常用的button有以下几种： RaisedButton、FlatButton、IconButton、FloatingActionButton、OutlineButton等。一般的使用方式如下： 123456789RaisedButton( color: Colors.blue, child: Text(\"RaisedButton\"), textColor: Colors.white, //onPressed: () =&gt; &#123;&#125;, onPressed: () &#123; print(\"xxxxxx\"); &#125;) 如果要自定义Button，只需要把源码相关属性覆写掉，就能得到想要的效果。 FlutterLogo顾名思义，就是Flutter的Logo，使用size来改变Logo大小，代码如下： 1234FlutterLogo( size: 100.0, colors: Colors.red,) 小技巧：在做具体项目时，需要展示图片时，可以先使用FlutterLogo 作为展位图，确定下具体尺寸并预览，等整体布局完毕之后，在把FlutterLogo替换成具体图片。 单一子元素组件(Single-child)单一子元素组件包括： Container、Padding、Center、Align、FittedBox、AspectRatio 等。 ContainerContainer 的简单使用如下： 12345Container( color: Colors.green, alignment: Alignment(0.0,0.0), child: new Text(\"container\"),) 首先了解下它的对齐方式，即上面代码中的 alignment 属性，它接受 Alignment 对象，会传入两个参数，取值范围都在 [-1,1] 之间，如下图所示： 从图可以看出，中间位置 x 和y都为 0，它表示内容在Container的正中间位置，上面的示例代码就是；如果要让文字在左下角，只需要把 Alignment 的值改为 (-1,1) 即可。这样子写一般比较麻烦，Fluuter提供了一些简单的映射方式，如下： 1234Alignment.center == Alignment(0.0,0.0)Alignment.centerLeft == Alignment(-1.0,0.0)...//以此类推 Container 的约束有时候，我们需要约束容器所占据的大小和空间，在大部分情况下，可以通过 BoxConstraint 来完成： 1234567child: Container( child: Text(\"dfa\"), constraints: BoxConstraints( maxHeight: 400.0, minHeight: 200.0 ),) 有时候，我们需要把存储在child中的Container扩展到最大： constraints: BoxConstraints.expend() 如果要设置容器的宽度和高度： constraints: BoxConstraints.expend(width: 250.0,height: 100.0) 在Container中，可以通过以下方式来设置margin 和 padding ： padding: EdgeInsets.only()margin: EdgeInsets.only() 在 Container 中，要注意的一个新概念是border，padding 、margin 与 border 的关系如下图所示： Container 中还有装饰器的概念(Decoration)，这个属性很强大，可以支持背景图现行或者径向渐变，也支持边框、圆角、阴影等实现： 12345678910111213141516171819202122232425262728293031Container( margin: EdgeInsets.only(top: 60.0,left: 80.0), constraints: BoxConstaints.tightFor(width:300.0,height: 300.0), //装饰器 decoration: BoxDecoration( //边线 border: Border.all(width:3,color:Colors.red), //阴影 boxShadow: [ BoxShadow( color: Colors.black, offset: Offset(2.0,2.0), blurRadius: 4.0 ) ], //实现渐背景色 gradient: LinearGradient( colors: [Colors.red,Colors.blue] ), ), //偏移 transform: Matrix4.rotationZ(.3), alignment: Aligment.center, child: Text( \"佩奇\", style: TextStyle(color: Colors.white,fontsize: 30.0), ),); SingleChildScrollView与Android的ScrollView差不多，用于view滚动，里面也只能嵌套一个child，用法： 123SingleChildScrollView( child: Column(...)) FittedBox它主要负责对组件进行缩放和位置调整，它里面的属性 fit 相当于Android里面的 scaleType，示意图如下： FractionallySizedBoxFractionallySizedBox 与 FittedBox 还有点类似，但是前者是基于宽度/高度 缩放因子来调整布局大小，大小有可能超出父组件的设置，如果其子组件设置了大小，也不会起作用，用法一般如下： 1234567891011Container( child: new FractionallySizedBox( widthFactor: 1.5, heightFactor: 0.5, child: new Container( width: 50.0//无效 color: Colors.yellow, ), )) ConstrainedBox它是一种有约束的限制的布局，在其约定范围内，其子组件是不能逾越的。 BaseLineBaseLine 是一种基线的对齐方式，可以把几个不相关的组件设置在同一条水平线上进行，使文字和图片底部对其的使用方法： 123456789101112131415161718192021body: new Row( mainAxisAlignment: mainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ new Baseline( baseline: 100.0, baselineType: TextBaseline.alphabetic, child: new Text( \"天气好\", style:xxxx, ), ), new Baseline( baseline: 100.0, baselineType: TextBaseline.alphabetic, child: FlutterLogo( size: 100, ), ), ]) 多元素组件(Multi-child)Scaffold它是基于Material 的与路由相关的、良好的结构体，它为我们很好地集成了 AppBar、floatingActionButton 等元素。 AppBar就是我们理解的App顶部导航栏，这个控件一般可以实现大部分需求，但是，在有需要的情况下，我们也可以自定义，比如，我们的左侧不一定是返回按钮，这时候，我们可以重写其leading属性，例如： 12345leading: IconButton( icon: new Icon(Icons.face), onPressed: ()&#123; &#125;), Row 和 Column二者都属于线性布局，一个横向一个纵向，要注意的是，Column 是不支持滚动的。Row的基本属性如下： children 子组件数组 crossAxisAlignment 子组件在纵轴方向的对其方式 mainAxisAlignment 子组件在横轴方向的对其方式 textDirection 布局顺序，一般是从左至右 mainAxisSize max，表示尽可能多占用水平方向的位置 ListView它和Android中的Listview有些类似，有以下几种创建方式： ListView ListView.builder ListView.custom ListView.separated 第一种示例： 123456789101112ListView( padding:const EdgeInsets.all(10.0), //可以设置水平滚动或者竖直滚动 scrollDirection: Axis.vertical //Item 高度 itemExtent: 30.0, children: &lt;Widget&gt;[ Text('A'), Text('B'), Text('C'), ],) ListView.builder 用于创建重复的子项布局： 12345678ListView.builder( padding:const EdgeInsets.all(10.0), itemExtent: 30.0, itemCount: 5,//可不传 itemBuilder: (context,position)&#123; return ListItem(); &#125;) ListView.separated 即带有“分割”作用，即可以在子项中夹杂其他项（比如可以用作实现分割线）： 1234567891011ListView.separated( itemCount: itemCount, itemBuilder: (context,position)&#123; return ListItem(); &#125; //分割项 separatorBuilder: (context,position)&#123; return SeparatorItem(); &#125;) ListView.custom 可以通过 SliverChildListDelegate 来接收 IndexedWidgetBuilder，并且为 ListView 生成列表项，从而实现自定义功能。 我们可以留意一下ListView 的physics 属性，这个属性可以帮助实现诸如 ios 地址选择器的滚轮效果等。 还有，以下ListView属性值得注意： RepaintBoundary 为true时，避免列表项滚动时重绘 AutomaticKeepAlive 为true时，被滑出的区域不会被回收 GridView和Android中的类似，不再赘述 CustomScrollView如果是多个组件结合起来一起滚动，比如同时存在ListView和GridView，则可以使用CustomScrollView。这个得实践才能知道效果，不多文字描述。 Flex即弹性布局，该布局借鉴了前端的 Flex 布局，值得注意的属性如下： direction 表示垂直或者水平方向(Axis.vertical 或 Axis.horizon) flex 弹性系数，大于0会按照比例来分割，等于0不会扩展占用的空间 flex 的效果图： 对应的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647body: Column( children: &lt;Widget&gt;[ Container( height: 400.0, child: Flex( direction: Axis.vertical, children: &lt;Widget&gt;[ Expanded( flex: 1, child: Container( color: Colors.red, ) ), Expanded( flex: 2, child: Container( color: Colors.yellow, ) ), ] ) ), Container( height: 120.0, child: new Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ Expanded( flex: 1, child: Container( color: Colors.blue, ) ), Expanded( flex: 2, child: Container( color: Colors.red, ) ), ] ) ), ] ) 上面例子中，我们实现了Flex布局，这种布局还可以通过在Row组件里设置两边对齐 MainAxisAlignment.spaceBetween 来实现。 WrapWrap 即动词“包裹”的意思，前面介绍过，可以使用Row 和Column去包裹一些组件，因为它们都是多元素组件，Column 可能还好，但Row有时候就会出问题：会把屏幕撑破： 我们使用Wrap 就不会出现这种情况。它会自适应屏幕，Wrap 可以使用spacing 和 runSpacing 分别指定水平和垂直方向的间距。 状态管理ContextContext 表示组件上下文的意思，每一个Context只对应一个Widget，如果一个Context对应的是父Widget A ，则Widget A 对应的 Context 也包含了子 Widget 的Context，**通过Context可以遍历和查找当前 Widget 树。 StatelessWidget即无状态的 Widget ，无法通过setState设置组件的状态，它的内部属性应该设置为 final，防止被意外改变。 StatefullWidget即有状态的 Widget，当我们创建一个 StatefullWidget 组件时，它同时也创建了一个State对象，并且 StatefullWidget 通过 State 关联可以达到刷新ui 的目的。StatefullWidget 只需要调用 setState(xx) 而不是像 Android 中类似 textView.setText(xx),就能改变UI。 StatefullWidget 由两部分组成，第一部分为主体，代码如下： 1234567891011class MyStatefullWidget extends StatefullWidget&#123; MyStatefullWidget(&#123; Key key, this.color, &#125;): super(key: Key) final Color color; @Override _MyStatefullWidgetState createState() =&gt; new _MyStatefullWidgetState();&#125; 主体部分继承了 StatefullWidget，在主体部分中创建的变量是无法变更的。第二部分代码如下： 12345class _MyStatefullWidgetState extends State&lt;MyStatefullWidget&gt;&#123; @Override Widget build(BuildContext context)&#123; &#125;&#125; 第二部分类名以 “_” 开头，表示该类是私有的，可以通过 widget.{variable} 访问第一部分里定义的变量，比如上述定义的： widget.color 。 State 的生命周期生命周期的回调方法如下图所示： 首次启动界面会执行： initState -&gt; didChangeDependencies -&gt; build 点击重载按钮(闪电图标)： reassemble -&gt; didUpdateWidget -&gt; build ** reassemble 只在debug模式下生效** 页面发生跳转时： deactivate -&gt; didChangeDependencies -&gt; build 解释下State生命周期中几个重要的方法： initState: 第一个被执行的方法，一般可以在这里面初始化动画、控制器 dispose： 在组件被销毁时调用，一般在initState中初始化的动作，在dispose中销毁。 Widget 唯一身份标识： keyflutter中每个Widget 都有唯一标识，这个标识在Flutter Framework 层创建和渲染时生成的，它就是key。在某些场景下，你需要保存key，并且通过key访问该Widget，可以通过 GloabalKey,LocalKey,UniqueKey 或者 ObjectKey 进行保存，如通过 GloabalKey 保存 key，并在整个应用程序中共享： 123456789GloabalKey myKey = GloabalKey();...@overrideWidget build(BuildContext context)&#123; return new MyWidget( key: myKey );&#125; InheritedWidget被 InheritedWidget 暴露出来的数据，可以高效地在Widget树中从上往下传递和共享，并且支持跨级传递。这个去看具体的例子。 包管理Android 使用 gradle 管理包，ios 使用 Cocoapods ，flutter 中使用 pubspec.yaml 配置文件对包进行管理。在 pubspec.yaml 里面添加了包之后，输入命令 flutter packages get 即可把包下载下来使用。 常见代码段效果在IDE 把代码敲一遍。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Flutter从0到1构建大前端应用","slug":"Flutter从0到1构建大前端应用","permalink":"https://glassx.gitee.io/tags/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/"}]},{"title":"第2章：dart语言入门","slug":"Flutter从0到1构建大前端应用-第2章","date":"2019-10-20T02:13:00.000Z","updated":"2019-11-17T13:42:25.831Z","comments":true,"path":"2019/10/20/Flutter从0到1构建大前端应用-第2章/","link":"","permalink":"https://glassx.gitee.io/2019/10/20/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8-%E7%AC%AC2%E7%AB%A0/","excerpt":"编写hello world使用dart 在控制台输出 hellow world 是比较简单的：123void main()&#123; print(\"hello world !\")&#125;变量与常量使用var声明一个变量，在未初始化之前，默认值为null；如果想设置一个常量，即让一个变量不可变，那么可以使用final 或者 const 修饰：","text":"编写hello world使用dart 在控制台输出 hellow world 是比较简单的：123void main()&#123; print(\"hello world !\")&#125;变量与常量使用var声明一个变量，在未初始化之前，默认值为null；如果想设置一个常量，即让一个变量不可变，那么可以使用final 或者 const 修饰： 123456789101112var num;num = 15;print(\"小明的年龄是 $num 岁\");num = '20'; //注意，变量的类型是可以变化的！！！print(num);final c= 30； //final 修饰的变量只能被声明一次print(c);const d = 50;print(d); 那么const 和final 的区别是什么呢？const 变量是一个编译时常量，final 变量在第一次使用时被初始化(const 是隐式的 final)，实例变量可以是 final ，但是不能 const，常量如果是类级别的，可以使用 static const，例如： const static PI = 3.1415 字符串Dart 里面的字符串有以下几种创建方式： 使用单引号、双引号创建字符串。 使用三个引号或者双引号创建多行字符串。 使用r创建原始raw字符串。 1234567var str1 = 'hello'var str2 = \"hello\"//使用三个引号创建多行var str3 = '''hello Bob'''//使用r创建 var str4 = r'你好啊' 注意，如果单引号里面嵌套单引号或者双引号里面嵌套双引号，则需要使用反斜杠进行转义。 在Dart里，可以对字符串进行单行拼接，也可以多行拼接： 123456789101112131415String s1 = 'ha' 'ha'; //单引号空格拼接String s1 = \"ha\" \"ha\"; //双引号空格拼接//使用加号(+)拼接和java一样，不赘述//使用三引号多行拼接String s1 = ''' Android开发工程师 前端开发工程师 '''; String s1 = \"\"\" Android开发工程师 前端开发工程师 \"\"\"; list 与数组Dart 中，List 表示集合，其实和数组是同一个概念，创建方式如下： 12345678var list = [1,2,3];var list = new List();//创建不可变list，如果试图改变不可变list，就会报错var list = const[1,2,3];//随机打乱里面的元素顺序list.shuffle() map123456Map name = &#123;\"name\": \"haha\"&#125;//创建不可变mapMap name = const&#123;\"name\": \"haha\"&#125;Map name = new Map();name['name'] = 'haha' dynamic 和 Object在Dart中，一切皆对象，而且这些对象的父类都是 Object，当没有选择明确的类型时，编译的时候回根据值去明确类型： 123var name1 = 'abc'Object name = 'abc'dynamic name = 'abc' 以上写法都没有问题，但是dart并不建议这样做，在实际开发中，我们尽量为变量明确类型，这样可以加快运行速度(如果不指定类型，则在debug模式下类型会是动态的)，并且提高安全性。 使用dynamic 时则是告诉编译器，我们不用做类型检测，并且知道自己在做什么，如果我们调用一个不存在的方法时，会执行 noSuchMethod()方法，在默认情况下，会抛出NoSuchMethodError 异常。 运算符 三目运算： 如： var a = b &gt; 10 ? a : 0 ~/ 除法： 返回一个整数结果(取商)： var z = 12~/7print(z) //结果是3，这个结果还未验证，将信将疑？？？ 级联操作符：类似一些语言中的链式调用，例如： String s = new StringBuffer() ..write(‘a’) ..write(‘b’) .toString(); print(s);// 打印出 ab 判断某种类型： as、is、is! (注意感叹号在is的后面) 异常捕获Dart 的异常捕获比Java还要强大，可以抛出任意类型的对象，抛出异常的方式通常如下： throw Exception(‘我是异常’) 使用try-catch保证程序健壮性： 12345678try&#123;//do something&#125; on AuthorizationException catch(e)&#123; //捕获特定类型异常&#125;catch(e)&#123; //...&#125;finally&#123;&#125; 函数可以用以下方式定义一个普通函数： 123bool getName(name)&#123; return name;&#125; 可选参数可选的命名参数，即不传这些参数也可以，在定义参数是，使用{params1,params2,…}指定命名参数： 12void userSetting(int age,String name)&#123;&#125; 这个函数中，我们可以传递age、name，或者其中一个，或者都不传递也可以。 必传参数我们可以使用 @required 来修饰参数，表示参数必传： 12void userSetting(&#123;@Required int age,@Required String name)&#123;&#125; 可选位置参数书上没有说什么叫做可选位置参数，我个人理解是，同时包含了必选参数以及可选参数，可以用[]把目标标记为可选的位置参数： 12345void userSetting(&#123;int age,String name,[String interestes]&#125;)&#123; if(interestes != null)&#123; print('兴趣爱好:$interestes'); &#125;&#125; 默认参数类似于kotlin，默认参数在参数后接 “=” : 1void userSetting(&#123;int age = 12,String name = '小明'&#125;) 函数可作为参数传递这个可能稍微有点费解，就是把一个函数当做一个参数传递给另外一个函数，看例子： 123456void printItem(String item)&#123; print(item);&#125;var users = ['小明','小王']users.forEach(printItem); 函数作为变量函数也可以直接作为一个变量使用，并且后续可以使用这个变量作为函数来调用： 123var say = (name)&#123; say('过年了');&#125; 异步编程Dart 和 JavaScript 的一个共同点是——单线程，同步代码会阻塞程序，因此在程序中能看到大量的异步操作。在Flutter 中，是使用 Future 对象来执行相关操作的，Futrue 支持链式操作，可以按顺序执行异步函数。 Future 是什么一个 Future 是一个 Future 自身的泛型 Future 对象，他表示一个异步操作产生的 T 类型的结果，当然，T可以是void类型，如果返回一个Future的函数被调用了，将发生以下两件事： 这个函数加入待完成队列并且返回一个未完成的 Future 对象。 当这个操作结束了，Future 对象返回一个值或者错误。 1234Future&lt;int&gt; future = getFuture();future.then((value) =&gt; handleValue(value)) .catchError((error) =&gt; handleError(error)).whenComplete() =&gt; handlerComplete(); 我们在future.then中接受异步处理的结果，并根据业务做相应处理。而future.catchError则用于捕获并处理错误。无论失败或者成功，都需要处理的业务可以放在 whenComplete 中。 async 和 await当遇到有需要延迟的运算(async)时，将其放到延迟运算的队列(await)中，把不需要的延迟运算的部分先执行完，最后来处理延迟运算部分，要使用await，就必须在async标记的函数中运行，否则这个await会报错。async 和 await 是Future 的语法糖，解决了回调地狱(Callback Hell) 问题。它们的用法例子如下： 123456789steps() async&#123; try&#123; String step1Result = await step1('step1'); String step2Result = await step2(step1Result); String step3Result = await step3(step2Result); &#125;catch(e)&#123; print(e); &#125;&#125; 从代码可以看出，await 必须被包裹在async 里面，假如没有使用这两个语法糖，那么代码将会是这样的： 123456789step1('step1').then((step1Result)&#123; step2(step1Result).then(step2Result)&#123; step3(step2Result).then(step3Result)&#123; //step4 //step5 ... &#125; &#125;&#125;) 可以看出，这确实使代码变得整洁易读。 泛型Dart 的泛型和Java的很类似，如下例子，就不多说： 12345List animals = new List&lt;String&gt;();class NewAnimal&lt;T extends Animal&gt;&#123; String toString() =&gt; \"创建一个新的小动物\"&#125; 继承、接口实现 和 混合dart 的继承使用 extends ，接口实现使用 implements ，同时，dart也是单继承，并且通过 @Override 来重写父类的方法，也可以通过super 来调用父类的方法，这与Java相似。另外，由于flutter没有Java中的公有和私有访问修饰符，因此可以直接访问父类中的所有变量和方法。 接口的实现：Fluuter 是没有接口(interface)关键字的，但是每个类都是一个隐式的接口，这个接口包含类中的所有成员变量和定义的方法，当类被当做接口时，类中的所有方法就是接口中的方法，它需要在子类中被重新实现： 1234567891011121314151617181920abstract class CanFixComputer&#123; void fixComputer();&#125;class CanProgramming&#123; void programming()&#123; &#125;&#125;class SoftwareEngineer extends Engineer implements CanFixComputer, CanProgramming&#123; @Override void fixComputer()&#123; print('软件工程师修电脑'); &#125; @Override void programming()&#123; print('码农写代码'); &#125;&#125; 上面的代码将 CanProgramming 作为接口实现，因此如果不重写 programming 就会报错。 接下来来借料Dart提供的混合(mixins,也可理解为混入)语法特性，它的作用是在类中混入其它功能，通俗地将，mixins 是一个可以把自己方法提供给其它类使用，但却不需要称为其它类的父类的类，它以非继承的方式来复用类中的代码，mixins 使用with关键字来实现： 12345678910111213141516171819202122232425262728293031323334abstract class CanFixComputer&#123; factory CanFixComputer._()&#123; return null; &#125; void fixComputer()&#123; print('软件工程师修电脑'); &#125;&#125;abstract class CanProgramming&#123; factory CanProgramming._()&#123; return null; &#125; void programming()&#123; print('码农写代码'); &#125;&#125;abstract class Work&#123; void doWork();&#125;class Engineer extends Worker&#123; void doWork()&#123; print('工程师在工作'); &#125;&#125;class SoftEngineer extends Engineer with CanFixComputer, CanProgramming&#123; &#125; 这样，在 SoftEngineer 类中就可以使用 CanFixComputer 和 CanProgramming 中的方法了，有些同学可能有疑问了，如果写成下面这样子： 1234567891011121314151617181920212223class Teacher extends Worker&#123; void doWork()&#123; print('老师在上课'); &#125;&#125;class Engineer extends Worker&#123; void doWork()&#123; print('工程师在工作'); &#125;&#125;class Driver extends Worker&#123; void doWork()&#123; print('开车'); &#125;&#125;class SoftEngineer extends Engineer implements Driver with Teacher&#123; void doWork()&#123; print('我自己的方法'); &#125;&#125; 上述代码中，SoftEngineer 自己有个doWork 方法，并且继承的类，实现的接口以及mixins的类都有doWork方法，那么在调用 doWork 方法时，到底怎么调用呢？它们的原则是这样的： 如果类本身有这个方法，则调用本身的方法 否则调用 mixins 的这个方法 如果mixins 也没有这个方法，则调用 extends 的这个方法 如果extends 也没有这个方法，则调用 implements 类中的这个方法 优先级方法： 自身方法-&gt; mixins -&gt; extends -&gt; implements","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Flutter从0到1构建大前端应用","slug":"Flutter从0到1构建大前端应用","permalink":"https://glassx.gitee.io/tags/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/"}]},{"title":"第1章：Flutter 简介","slug":"Flutter从0到1构建大前端应用-第1章","date":"2019-10-19T14:21:00.000Z","updated":"2019-11-17T13:42:15.415Z","comments":true,"path":"2019/10/19/Flutter从0到1构建大前端应用-第1章/","link":"","permalink":"https://glassx.gitee.io/2019/10/19/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8-%E7%AC%AC1%E7%AB%A0/","excerpt":"Flutter 的优势 跨平台：开发的代码可同时部署在 Android、ios、web、桌面 环境上。 流畅的跨平台UI。使用“自绘UI + 原生系统”，配合 Skia 2D 引擎，实现高帧率的流畅UI，比webview这种方式效率更高。 开发过程中支持热重载，只需要保存代码即可在设备上看到更改后的效果，提高了开发效率。 对开发环境要求低，目前支持 Android Studio 和 VScode 两种 IDE 。","text":"Flutter 的优势 跨平台：开发的代码可同时部署在 Android、ios、web、桌面 环境上。 流畅的跨平台UI。使用“自绘UI + 原生系统”，配合 Skia 2D 引擎，实现高帧率的流畅UI，比webview这种方式效率更高。 开发过程中支持热重载，只需要保存代码即可在设备上看到更改后的效果，提高了开发效率。 对开发环境要求低，目前支持 Android Studio 和 VScode 两种 IDE 。 Flutter架构学习一门新技术，首先要对其整个技术体系有个大概的了解。Flutter 整体可以分为Framework 和 Engine 两个部分，官方给出的架构图如下： Flutter FrameworkFramework 是由纯 Dart 语言实现的 SDK ，Dart 也是Flutter 的官方语言。以下分别介绍各层作用： 最底下的两个层：底层UI库，提供动画、手势及绘制功能供开发者调用。 Rendering层：负责构建UI树，每当 UI 树上的 Element 发生变化时，都会计算出有变化的部分并且会更新UI树，最终将UI树绘制到屏幕上。 Widgets 层： 基础组件库，Flutter 默认帮我们提供了 Material (即 Android 风格) 和 Cupertino(即 ios 风格) 两种视觉风格的组件库。 Flutter EngineEngine 是由纯 C++ 实现的 SDK，Framework 层所有的UI库都会调用到 Engine 这一层。 Skia： 2D 渲染引擎(Android 系统自带，但ios 系统不自带，因此，ios 报所占的存储空间更大)。 Dart： Dart 运行时。 Text： 文字排版引擎。 开发环境搭建个人觉得，开发环境搭建按照官方文档会更好，并且官方有中文文档，唯一要注意的是，在中国使用 Flutter 需要注意资源获取的问题。附： flutter官方中文文档——环境搭建：https://flutter.cn/docs/get-started/install 中国网络环境的注意事项：https://flutter.cn/community/china 还要注意的一点是，设置flutter环境变量的时候最好设置永久的环境变量，不然重启电脑环境变量就会无效了。 Flutter 升级和分支切换可以通过在项目的根目录中(包含pubspec.yaml的目录)输入命令： flutter upgrade 对flutter 进行升级，这里还介绍下 Flutter channels 相关的概念，Flutter 有4种release channel ，即：stable、beta、dev、master，官方推荐使用 stable channel ，我们可以在命令行输入以下命令来查看当前的 channel，并会列出所有channel： flutter channel 用 * 标识的位置表示当前channel ，如果想要切换channel 到stable 分支，可以用以下命令： flutter channel stable 这里还有需要注意的是 pubspec.yaml，这个文件掌管着 Flutter 所需要的依赖包，有点类似于 Node.js 中的 package.json ，这些 Flutter 依赖包有内置的，还有别的开发者发布的，我们可以通过命令 flutter packages get 获取依赖包列表，还能通过 flutter pachages upgrade 命令升级这些依赖包。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Flutter从0到1构建大前端应用","slug":"Flutter从0到1构建大前端应用","permalink":"https://glassx.gitee.io/tags/Flutter%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/"}]},{"title":"第7章：Android启动过程简析","slug":"深入理解Android内核设计思想-第7章","date":"2019-10-09T14:00:00.000Z","updated":"2019-11-17T13:48:59.530Z","comments":true,"path":"2019/10/09/深入理解Android内核设计思想-第7章/","link":"","permalink":"https://glassx.gitee.io/2019/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC7%E7%AB%A0/","excerpt":"第一个系统进程(init)Android设备的启动必须经历3个阶段： Boot Loader、Linux Kernel 以及 Android 系统服务，默认情况下它们都有各自的启动画面。作为Android 中第一个被启动的进程，init的 PID 的值为 0，它通过解析 init.rc 脚本来构建出系统的初始运行形态——其中最重要的就是启动 ServiceManager、Zygote 和 SystemServer。","text":"第一个系统进程(init)Android设备的启动必须经历3个阶段： Boot Loader、Linux Kernel 以及 Android 系统服务，默认情况下它们都有各自的启动画面。作为Android 中第一个被启动的进程，init的 PID 的值为 0，它通过解析 init.rc 脚本来构建出系统的初始运行形态——其中最重要的就是启动 ServiceManager、Zygote 和 SystemServer。 Android 的“DNS服务器”——ServiceManagerServiceManager 是Binder 机制中的“DNS服务器”，负责域名(某Binder服务在 ServiceManager 注册时提供的名称) 到IP地址(由底层Binder驱动分配的值)的解析。 ServiceManager 所属class 是core ，并且带有 critical 选项，说明它是系统的关键进程——意味着如果进程不幸在4分钟内异常退出4次，则设备将重启并进入还原模式。当 ServiceManager 重启时，zygote、media、surfaceflinger 等都会被重启。 “孕育” 新的线程和进程——Zygote这个单词是”受精卵”的意思，正如其名所示，Android 中大多数的应用进程和系统进程都是通过 Zygote 来生成的。它所在的程序名叫做”app_process” ，而不像 ServiceManager 一样在一个独立的进程中。在init 进程的帮助下，通过zygote 逐步建立起 SystemServer 的运行环境。 Android的“系统服务”——SystemServerSystemServer 是 Android 进入 Launcher 前的最后准备。ZygoteInit 通过 Zygote.forkSystemServer 来生成一个新的进程，用于承载各系统服务。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深入理解Android内核设计思想-林学森","slug":"深入理解Android内核设计思想-林学森","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E6%9E%97%E5%AD%A6%E6%A3%AE/"}]},{"title":"第6章：进程间通信——Binder","slug":"深入理解Android内核设计思想-第6章","date":"2019-09-26T13:36:00.000Z","updated":"2019-11-17T13:48:53.881Z","comments":true,"path":"2019/09/26/深入理解Android内核设计思想-第6章/","link":"","permalink":"https://glassx.gitee.io/2019/09/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC6%E7%AB%A0/","excerpt":"我们知道，同一个程序中两个函数之间能够直接调用的根本原因是他们处于相同的内存区域中，因为在同一个内存区域中，虚拟地址的映射规则完全一致，所以A函数和B函数的调用关系很简单，但两个不同进程，他们是没有办法直接通过内存地址来访问到对方内部的函数或者变量的。既然无法直接访问，那间接的方法就是Binder。如果通观Binder的各个元素，就会惊奇地发现它和 TCP/IP 网络有很多相似之处：","text":"我们知道，同一个程序中两个函数之间能够直接调用的根本原因是他们处于相同的内存区域中，因为在同一个内存区域中，虚拟地址的映射规则完全一致，所以A函数和B函数的调用关系很简单，但两个不同进程，他们是没有办法直接通过内存地址来访问到对方内部的函数或者变量的。既然无法直接访问，那间接的方法就是Binder。如果通观Binder的各个元素，就会惊奇地发现它和 TCP/IP 网络有很多相似之处： Binder 驱动 -&gt; 路由器 Service Manager（本质也是个服务器） -&gt; DNS（本质也是个服务器） Binder Client -&gt; 客户端 Binder Server -&gt; 服务器 TCP/IP中一个典型的服务连接过程如下图所示： 这个简化的流程图有以下几个步骤： Client 向dns 查询 google.com 的ip地址。显然，Client 一定得先知道DNS 的 IP地址，才能向它发起查询，DNS 服务器的ip设置是在接入网络前就已经设置完成的。当然，client向DNS 查询 ip地址不一定需要，因为如果已经知晓server的ip，就无需这一步，从而加快访问速度； DNS 将查询结果返回 Client。Client的Ip地址对于 DNS 是必须的，不过这些信息会封装在 TCP/IP 包中。 Client 发起连接。这里我们没有提及Router的作用，因为它所负担的责任是将数据包投递到用户设定的目标IP中，它是整个通信结构中的基础。 而对于Binder来说，Binder的 DNS (Service Manager)也不是必须的——前提是客户端能记住它要访问的进程的 Binder 标志（IP地址），尤其要注意的是，这个标志是个“动态IP”，意味着即使客户端记住了本次通信过程中目标进程的唯一标志，下一次访问仍然需要重新获取。因此，Service Manager 这个 DNS 的还是挺有必要的。 既然Service Manager是 DNS 服务器，那么它的 IP 地址是多少呢？Binder 机制对此作了特别规定，Service Manager在Binder通信中唯一标志用于都是0。 智能指针略 进程间的数据传递载体——Parcel关于进程间如何传递，我们可以使用2个生活例子来类比： 用快递寄衣服：虽然快递种类比较多，但是无论用哪个快递，用哪种运输方式，“衣服”本身始终是没有变过的，接收人拿到的还是原来那件衣服。 通过电子邮件发送图片：在接收人看到邮件中的图片时，我们无法确认这张图片在传输过程中被复制了多少次，但是可以肯定的是，对方看到的图片和原始图片是一样的。 进程间通信的数据传递类似于第2种情况，如果只是一个int型数值，不断复制直到目标进程即可；如果是一个对象呢？我们直到，同一个进程中对象的传递实质上是传递了一个内存地址，但是在跨进程的情况下就无能为力了，因为采用了虚拟内存机制，两个进程都有自己独立的内存地址空间，所以跨进程传递的地址空间是无效的。 进程间的数据传递是Binder 机制中的重要环节，而担负这一重任的就是Parcel。 Parcel 的直译是 “打包” ，上面提到，进程间数据传递直接传送对象的地址是行不通的，那把对象在进程 A 中占据的内存相关数据打包起来，然后寄送到内存 B 中，由 B 在自己的进程空间中“复现”这个对象，是否可行？ Parcel 就具有这种打包能力。 Parcel 提供了很多接口方便程序使用，他可以存储多种类型的数据： 原始数据类型 以及 原始数据类型数组 Parcelable Bundle Active Objects 通常我们存入Parcel 的是对象的内容，而 Active Objects 写入的则是他们的特殊标志引用。所以从 Parcel 中读取这些对象时，大家看到的并不是重新创建的对象实例，而是原来那个被写入的实例，能够以这种方式传递的对象目前主要有两类： Binder 以及 FileDescriptor (Linux 中的文件描述符)。 Untyped Containers 它是用于读写标准的任意类型的 Java 容器，包括 ： writeArray(Object[])/readArray(ClassLoader)、writeList(list)/readList(list) Parcel 可以用集装箱来类比，理由如下： 货物无关性： 不排斥运输的货物种类，电子产品、汽车等都可以 不同的货物需要不同的打包和卸货方案： 比如运载易碎物品和坚硬物品的装箱和卸货方式就有很大的不同。 值得注意的是，Parcel 存/取 数据的方式都是一一对应的，如 writeByte(byte)/readByte() 远程运输和组装： 集装箱的货物一般需要跨洋，这类似于 Parcel 的跨进程。不过集装箱运输公司本身并不负责所运输货物的组装，而 Parcel 会依据协议为接收方提供还原冤死数据对象的业务。 Parcel 的工作方式（书上没有，自己添加） Parcel 的 Parcel.obtain() 方法可以获取一个Parcel 对象，系统预先产生了一个大小为6的 Parcel 池 sOwnedPool，在obtain 操作时，如果 sOwnedPool 中还有现成的 Parcel 对象，则直接利用，否则通过 new Parcel(0) 创建 Parcel 对象。 Parcel.java 实际上只是一个简单的中介，它的主要内容都是 JNI 层的 Parcel 实现的。Parcel 对象的初始化过程只是简单地给各个变量赋初始值，并没有设想中的内存分配动作，因为 Parcel 遵循的是“动态扩展”的内存申请原则，只有在需要时才申请内存，避免资源浪费。 Parcel 提供数据当前位置的值 dataPosition，类似于游标。每当存储新数据时，都是从 dataPosition 位置接着往后存储，存储新数据时，会判断当前空间是否足够，如果不足，则申请新的空间（个人根据文中内容理解的，不太确定是否正确）。 Binder驱动与协议Android 是 linux 内核的，因而 Binder 驱动也是标准的 linux 驱动，具体而言，Binder驱动会把自己注册成一个 misc device，并向上层提供 /dev/binder节点——但是它并不对应真实的硬件设备。Binder 驱动运行于内核态，可提供 open()、ioctl()、mmap() 等常用文件操作。 Android 系统为什么把 Binder 注册成 misc device 类型的驱动呢？因为 linux 字符设备通常要通过 alloc_chrdev_region()、cdev_init() 等操作才能在内核中注册自己；而 misc 类型驱动相对简单，只需要 misc_register() 就可轻松解决。 Binder 驱动为上层提供了6个接口，但一般文件操作用到的 read() 和 write() 则没有出现，这是因为它们的功能完全可以用 ioctl() 和 mmap() 来代替，并且会更灵活。这6个接口中使用得最多的是 binder_ioctl,binder_mmap 和 binder_open，，以下分别介绍这三种接口。 打开Binder驱动——binder_open上层进程在访问 Binder 驱动时，首先需要打开 /dev/binder 节点，这个操作最终的实现是在 binder_open() 中，在这个方法中，会创建一个 binder_proc 实体，这个实体用于记录各种管理数据(Binder 驱动会在 /proc 系统目录下生成各种管理信息)，并且，每个进程都有独立的记录。 在完成proc 的初始化之后，就会把这个 proc 加入到 Binder 的全局管理中，这个过程涉及资源互斥，因而需要使用保护机制。到目前为止，Binder 驱动已经为用户创建了一个它自己的 binder_proc 实体，之后用户对Binder 设备的操作都以这个对象为基础。 binder_mmap对于 Binder 驱动来说，上层用户调用的 mmap() 最终对应了 binder_mmap()操作(应用程序最多只能申请 4M 的空间，如果超出这个大小，不会退出或者报异常，而只会满足用户 4M 的请求)，那么Binder 采用 mmap 的目的是什么呢？我们知道，mmap() 可以把设备指定的内存块直接映射到应用程序的内存空间中，但Binder 本身并不是硬件设备，而是基于内存的“伪硬件”，那么它映射了什么内存块到应用程序中呢？ 假设有连个进程A和B，其中进程B通过 open() 和 mmap() 与Binder驱动建立了联系，如下图： 可以看到 ： 对于进程B而言，通过mmap()返回值得到一个内存地址（当然是虚拟地址），这个地址最终会指向物理内存的某个位置（通过虚拟内存转换）。 对于Binder驱动而言，它也有个指针（binder_proc-&gt;buffer）指向某个虚拟内存地址，这个地址转换后，与进程B指向的物理内存地址位于同一个位置。 个人理解：进程B执行 mmap() ，最终是通过 Binder 的 binder_mmap() 来实现，在 B 拿到这块内存后(当然是经过虚拟内存转换后的虚拟内存地址)，Binder 驱动同时将这块内存赋值给了 binder_proc-&gt;buffer。这样，Binder和应用程序就拥有了若干公用的物理内存块，它们对着各自内存地址的操作，实际是在同一块内存中执行，这时候我们再把A进程加入进来，如下图： 这时候，左半部分没有变化，右半部分Binder驱动通过copy_from_user()，把A进程中某段数据复制到其binder_proc-&gt;buffer所指向的内存空间，这时候我们惊喜发现，binder_proc-&gt;buffer在物理内存中的位置和进程B是共享的，进而，B进程可以直接访问到这段数据，也就是说，Binder驱动只用了一次复制，就实现了进程A和B之间的数据共享。 以上通过 mmap 映射的映射区是 只读的。 binder_ioctl这是 Binder 接口函数中工作量最大的一个。前面提到过，Binder 并不提供 read() 和 write() 等常规文件操作，因为 ioctl 完全可以替代它们。它主要提供了以下命令： BINDER_WRITER_READ: 读写操作，可以用此命令向 Binder 读取或写入数据 BINDER_SET_MAX_THREAD: 设置支持的最大线程数，因为客户端可以并发向服务器端发送请求，如果Binder 驱动发现当前的线程数量已经超过设定值，就会告知 Binder server 停止启动新的线程。 BINDER_SET_CONTEXT_MGR: Service Manager 专用，让它把自己设置为“Binder”大管家。系统中只有一个 Service Manager。 Service ManagerService Manager(后面简称 SM) 也就是Binder 中的 “DNS服务器”，既然是DNS，那么在用户可以浏览网页之前就必须就位，因此SM在有人使用Binder之前就处于正常工作状态。SM 的主要工作： 从Binder驱动读取消息 调用binder_parse 处理解析消息 不断循环，而且永远不会主动退出，除非出现致命错误 它提供的服务应该至少包括以下几种： 注册——当一个Binder Server 创建后，它们要将自己的相关信息告知 SM 备案 查询——应用程序可以向 SM 发起查询请求，已获知某个 Binder Server 对应的句柄。 SM 的查询过程很简单，主要是调用 do_find_server 遍历内部列表，并返回目标 Server；注册 Binder server 也很简单，首先在 SM 维护的数据列表中查找是否已经有对应的节点存在，，如果没有，就创建一个新的节点记录这个 Server。 实际上，我们获取 SM 也很简单，只需要以下几步： 打开Binder设备 执行mmap 通过Binder驱动向 SM 发送请求（SM 的 handle是 0） 获得结果 Binder 客户端Binder 的最大消费者是Java层的应用程序，但是在各种上层的应用场景中切换“过于丝滑”，因此我们很少能感觉到Binder的存在，但是我们能够通过Android的四大组件的行为看出蛛丝马迹： Activity：通过 startActivity 可以启动目标进程，不论它是不是属于这个应用。 Service：任何应用程序都可以通过startService 或者 bindService 来启动特定的服务，而不论后者是不是跨进程的。 BroadCast：任何应用都可以通过 sendBroadcast 来发送一个广播，且无论广播接收者是不是在同一个进程中。 组件的上述操作中，多数并不会特别指明要由哪个目标应用程序来响应请求，它们只需要通过Intent表达意愿，然后由系统找出最匹配的应用进程完成工作。为了更明确地说明个中的进程间通信，这里以binderService举例说明： 首先Application1 填写Intent，调用 bindService 发出请求 在Application1的运行空间中收到 bindService 请求，这时候会与 ActivityManagerService(AMS)，这就需要得到AMS的Binder句柄，就涉及到进程间通信了（需要ServiceManage.getService）,拿到句柄后，程序才能真正向它发起请求。 AMS基于“最优匹配策略”，从其存储的所有服务组件中找到最符合Intent的一个，然后向它发送Service绑定请求（这也是进程间通信），如果目标进程还不存在的话，AMS还要负责将其启动 “被绑定”的服务进程需要响应绑定，并在完成任务后通知AMS，然后由后者回调发起请求的Application1（回调接口是ServiceConnection）。 Server 服务端在建立服务之后，可以有两种方式向外面提供服务： Server在ServiceManager中注册，这样，调用者只需要通过 ServiceManager.getService(NAME)就可以获得句柄，随后与之通信。 所谓的“匿名Server”，并不需要在ServiceManager中注册，那么Client是如何访问的呢？其实它通过其他Server作为中介，没错，就是通过一个“第三方”实名的Server，调用者首先通过ServiceManager获取这个实名的server，在由它提供匿名者的 Binder 句柄。 Binder 优点基于自己的理解而言，Binder具有以下优点： 性能较好 Binder只需要拷贝一次数据，仅次于共享内存（一次都不要），消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。 稳定性好 基于C/S架构在逻辑上更清晰，client有需求，Server完成。共享内存实现起来复杂，各方没有客户端与服务端之别，要考虑并发问题以及可能出现的死锁。 安全性好 传统 Linux IPC 的接收方要么无法获得对方进程可靠的 UID/PID ，从而无法鉴别对方身份；要么只能由用户在数据包里填入UID/PID。Android 为每个应用分配了自己的UID，前面提到 C/S 架构，Server 会根据权限控制策略判断 Client 的请求是否满足权限。并且Binder机制还有匿名 Binder ，压根无法直接获取句柄，安全性更好。 使用简单。 获得句柄之后，就像调用本地方法一样方便。并且Linux的IPC方式使用C语言，而Android应用层主要使用Java，这可能也是个因素。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深入理解Android内核设计思想-林学森","slug":"深入理解Android内核设计思想-林学森","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E6%9E%97%E5%AD%A6%E6%A3%AE/"}]},{"title":"第12章: Java内存模型与线程","slug":"深入理解Java虚拟机-第12章","date":"2019-09-22T23:46:00.000Z","updated":"2020-03-03T14:53:46.996Z","comments":true,"path":"2019/09/23/深入理解Java虚拟机-第12章/","link":"","permalink":"https://glassx.gitee.io/2019/09/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC12%E7%AB%A0/","excerpt":"概述在许多情况下，让计算机同事去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是计算机的运算速度与它的存储和通信子系统的差距太大，大量的时间都花费在磁盘I/O 、网络通信或者数据库访问上。硬件的效率与一致性高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但也为系统引入了一个新问题：缓存一致性(Cache coherence)。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主存(Main memory)，当多个处理器的运算任务都涉及同一块主内存区域时，可能导致各自的缓存数据不一致，此时，同步回到主存时以谁的缓存数据为准呢？","text":"概述在许多情况下，让计算机同事去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是计算机的运算速度与它的存储和通信子系统的差距太大，大量的时间都花费在磁盘I/O 、网络通信或者数据库访问上。硬件的效率与一致性高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但也为系统引入了一个新问题：缓存一致性(Cache coherence)。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主存(Main memory)，当多个处理器的运算任务都涉及同一块主内存区域时，可能导致各自的缓存数据不一致，此时，同步回到主存时以谁的缓存数据为准呢？ 除高速缓存外，为了使处理器内部运算单元尽量被充分利用，处理器可能会对输入代码进行乱序执行(Out-Of-Execution)优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但是并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果某个计算任务依赖另一个计算任务的中间结果，那么其顺序性不能依靠代码的先后顺序来保证。 Java 内存模型Java 内存模型(Java Memory Model, JMM) 是用来屏蔽各种硬件和操作系统的内存访问差异。 主内存与工作内存Java 内存模型的主要目标是定义程序中各个变量的访问规则，此处的变量(Variables) 包括 实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不存在竞争。 注意区别：如果局部变量是个refrence类型，它引用的对象在Java堆中可能被各个线程共享，但refrence本身在Java栈的局部变量表中，是线程私有的。 Java内存模型规定所有的变量都存储在主内存(Main Memory)，每条线程还有自己的工作内存(Working Memory)，这两个分别可以类比物理模型中的主内存以及处理器的高速缓存。线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。 关于副本拷贝，假设线程访问一个10MB 的对象，那会不会也拷贝出来呢？虚拟机基本上不会这么实现，只有对象的引用、对象中某个在线程中访问到的字段是可能存在拷贝的。还有，这里所讲的主内存、工作内存 与 前面讲的Java堆、栈、方法区等并不是同一个层次的内存划分，二者并没有关系。 内存间交互操作Java 内存模型中定义了以下8种操作来完成从主内存拷贝到工作内存，以及从工作内存同步回主内存： lock（锁定）：对主内存变量标识为某一条线程独占。 unlock（锁定）：对主内存变量标识为解锁。 read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存，以便后面的load操作。 load（载入）：作用于工作内存变量，把read操作从主内存得到的变量值放入工作内存的变量拷贝中。 use（使用）：作用于工作内存变量。把工作内存中一个变量的值传递给执行引擎。当虚拟机遇到一个需要使用到变量的值的字节码指令时执行这个操作。 assign（赋值）：作用于工作内存变量。把一个从执行引擎接收到的值赋值给工作内存的变量。当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存变量。把工作内存中一个变量的值传送到主内存中，以便随后的write操作。 write（写入）：作用于主内存变量。把store操作从工作内存中得到的变量的值放入主内存的变量中。 如果要把一个变量从主内存复制到工作内存，那就要顺序地执行 read 和 load 操作（只是顺序地执行，不保证连续执行，中间是可以插入其他指令的），如果要把变量从工作内存同步回主内存，就要顺序地执行 store 和 write 操作。并且，Java 内存模型要求执行上述操作必须满足下列条件： read 和 load、store 和 write 必须成对出现，不许单独出现。 变量在工作内存中改变了之后，必须要同步回主内存，即不允许丢弃它最近的 assign 操作；并且如果没有发生assign，则不允许同步回主内存。 对一个变量 use、store 之前，必须先执行过了 assign 和 load 。 一个变量在同一时刻只允许一条线程执行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次 lock 后，只有执行相同次数的 unlock 操作后变量才能被解锁。 如果对一个变量执行 lock 操作，那会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量值。 如果变量没有被 lock 锁定，那就不允许对它执行 unlock ，也不允许 unlock 一个被其他线程 lock 住的变量。 对变量执行 unlock 之前，必须把此变量同步回主内存中（执行 store、write 操作）。 对于 volatile 型变量的特殊规则volatile 可以说是Java虚拟机提供的最轻量级的同步机制。这里首先以不正式但通俗易懂的语言来介绍这个关键字的作用，当一个变量定义为 volatile 后，它将具备两种特性： 第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对其他线程来说是可以立即得知的。而普通变量是做不到这一点的。 第二个语义是禁止指令重排序优化。 关于volatile 变量的可见性，经常会有开发人员误解，认为 “volatile 变量在各个线程中是一致的，所以基于 volatile 变量的运算在并发下是安全的”，因为事实上我们不能得出“基于 volatile 变量的运算在并发下是安全的” 这样的结论，因为虽然volatile变量在各个线程的工作内存中不存在一致性问题(由于每次使用之前都要先刷新，所以执行引擎看不到一致的情况，所以可以认为不存在一致性问题)，但Java里面的运算并非原子操作，所以导致 volatile 变量的运算在并发下一样是不安全的。通过以下简单代码可以演示： 123456789101112131415161718192021222324252627282930313233public static volatile int race = 0; private static final int THREADS_COUNT = 20; private static void increase() &#123; race++; &#125; public static void main(String[] args) &#123; Thread[] threads = new Thread[THREADS_COUNT]; for (int i = 0; i &lt; THREADS_COUNT; i++) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; increase(); //System.out.println(race); &#125; &#125; &#125;); threads[i].start(); &#125; //等待所有累加线程都结束 while (Thread.activeCount() &gt; 1) &#123; Thread.yield(); &#125; System.out.println(race); &#125; 注意：我个人运行这段代码的时候，并不能正常打印，因为while循环中的 Thread.activeCount() 一直是2，只有把 for 循环中的 System.out.println(race) 放开才能打印，我的环境是： Android Studio 3.5 + jre1.8 。,如果并发正确的话，最终输出结果应该是 200000，但实际运行的结果大概率会是一个小于 200000 的数字。为什么呢？问题出在 increase() 方法中的 race++ 操作上，我们可以使用javap命令反编译这个函数的代码得到如下的字节码： 发现只有一行代码的increase方法在class文件中是由4条字节码指令构成的(return 不是由 race++ 产生的)，所以很容易分析出并发失败的原因了：当getstatic 指令把 race 的值取到操作栈顶时，volatile 可以保证 race 的值是正确的、最新的，但在执行 iconst_1、iadd 这些指令的时候，其他线程可能已经把 race 的值增大了，所以最后执行 putstatic 指令后可能把较小的 race 值同步回了主内存中。 客观地说，此处用字节码来分析问题仍然是不严谨的，因为即使编译出来只有一条字节码指令，也并不意味着这条指令就是一个原子操作，一条字节码在执行时，解释器往往要运行多行代码才能实现它的语义。如果是编译执行，一条字节码可能会转化成若干条本地机器码指令。但考虑阅读方便，并且字节码已经够说明问题，所以此处选用字节码分析。 以上代码说明volatile 在并发运行中可能出现的问题，但是如下代码场景就很适合使用 volatile 变量来控制并发，当shutdown 方法调用时，能保证所有线程中执行的 doWork() 方法都能停下来： 1234567891011volatile boolean stopThread;public void shutdown()&#123; stopThread = true;&#125;public void doWork()&#123; while(!stopThread)&#123; //do stuff &#125;&#125; volatile 禁止指令重排序优化仍然不太容易理解，通过以下伪代码来看看为何指令重排序会干扰程序的并发执行： 123456789101112131415161718Map configOptions;char[] configText;//此变量必须定义为 volatile//假设以下代码在线程 A 中执行，模拟读取配置信息，读取//完成后，将 initialized 设置为 true 以通知其他线程configOptions = new HashMap();configText = readConfigFile(fileName);processConfigOptions(configText,configOptions);initialized = true;//假设以下代码在线程 B 中执行，等待 initialized 为 true ，//代表线程 A 已经把配置信息初始化完成while(!initialized)&#123; sleep();&#125;//使用线程 A 中初始化好的配置信息doSomethingWithConfig(); 这个场景十分常见，只是我们在处理配置文件时一般不会出现并发而已。如果 initialized 没有使用 volatile 修饰，就可能由于指令重排序优化，导致 initialized = true 被提前执行(指令重排序优化是机器级的优化操作，这里说的提前执行是指对应的汇编代码提前执行)，这样线程 B 中使用配置信息的代码就可能出现错误，而volatile 可以避免此类情况发生。以下再举个例子来说明 volatile 关键字是如何禁止指令重排序优化的： 123456789101112131415161718public class Singleton&#123; private volatile static SingleTon instance; public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; public static void main()&#123; Singleton.getInstance(); &#125;&#125; 编译后，这段代码对instance变量赋值部分如下代码所示： 可以对比 instance 有被volatile修饰和没有被修饰的编译后的代码，会发现，关键变化在于有 volatile 修饰的变量，在赋值(mov %eax,0x150(%esi) 这句就是赋值操作)，之后会多执行一个 lock 操作，这个操作是一个内存屏障，令重排序时不能把后面的指令重排序到内存屏障之前的位置。只有一个cpu访问内存时，并不需要内存屏障；但如果有两个或更多cpu访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性。这操作也相当于做了一次 store 和 write 操作，引起其他cpu（或内核）对于这个变量的无效化，因此保证了 volatile 变量的修改对其他cpu立即可见。 在某些情况下，volatile 的同步机制的性能确实要优于锁，但是虚拟机对锁实行许多消除和优化，所以我们很难量化地认为 volatile 的同步机制比锁快多少。但是可以肯定的是：volatile 变量的读操作与普通变量几乎没差别，但写操作可能会慢一些，因为它需要需要在本地代码中插入内存屏障保证处理器不乱序执行。 long 和 double 型变量的特殊规则long 和double 都是64位数据类型，内存模型允许虚拟机将没有被 volatile 修饰的64位数据类型的读写操作分为两次32位操作来进行，可能会导致某些线程读到”半个变量”的数据，不过这种情况十分罕见(目前商用Java虚拟机不会出现)，所以了解这回事即可。 原子性、可见性 与 有序性整体回顾一下Java内存模型，Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性3个特征来建立的。 原子性(Atomicity)：read、load、assign、use、store 和 write 操作是保证原子性的，基本数据类型的访问读写也是具有原子性的。如果要保证更大范围的原子性，Java 内存模型还提供了 lock 和 unlock 来满足这种需求。 可见性。可见性指一个线程修改了共享变量的值，其他线程能立即得知这个修改。除了volatile 之外，Java还有两个关键字能实现可见性，即 synchronize 和 final 。同步块的可见性是由 “对一个变量执行unlock操作前，必须把此变量同步回主内存中” 获得的。而final修饰的字段在构造器中一旦初始化完成，并且构造器没有把 “this”的引用传递出去(this引用逃逸是很危险的，其他线程可能通过这个引用访问到”初始化了一半”的对象)，那在其他线程中就能看到 final 字段的值。 有序性。Java 程序中有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果从一个线程观察另一个线程，所有操作都是无序的。前者指“线程内表现为串行语义” ，后者指“指令重排序”和“工作内存与主内存同步延迟” 现象。Java 语言提供了 volatile 和 synchronized 来保证线程之间操作的有序性，前者本身包含了指令重排序的语义；后者通过 “一个变量在同一个时刻只允许一条线成对其进行lock操作”决定了持有同一个锁的两个同步块只能串行进入。 先行发生原则这块理论性的总结性的内容，个人觉得就先不写了。 Java 线程线程的实现这块的内容在操作系统的内容中有描述： 使用内核线程实现（每个内核线程对应一个轻量级进程）； 使用用户线程实现（创建销毁开销小，没有内核支援，处理诸如阻塞等问题异常困难）； 使用用户线程+轻量级进程混合实现（即内核线程和用户线程一起使用，n: m 的关系）。 Java 线程调度线程调度的方式主要有两种： 协同式线程调度(Cooperative Threads-Scheduling) 和 抢占式线程调度(Preemptive Threads-Scheduling)。前者靠线程自觉，线程执行时间由线程自己控制，后者每个线程由系统分配时间，Java 使用后者。 虽然Java线程调度是系统自动完成的，但是我们可以给线程设置优先级来“建议”系统给某些线程多一些时间。但给线程设置优先级还是不靠谱的，原因如下： Java 线程是通过映射到系统的原生线程上来实现的，不同的系统上的优先级与Java的线程优先级等级基本上对应不上。可能你在Java中指定的2个优先级，在某操作系统上映射成同一个优先级。 优先级可能会被系统自行改变。 状态转换Java 语言定义了5种线程状态，在任一时间点，一个线程只能有且只有其中的一种状态： 新建(New)：创建后尚未启动。 运行(Runnable)：可能在执行，也有可能在等待 CPU 分配时间。 无限期等待(Waiting)：这种状态下不会被 CPU 分配时间，要等其他线程显式地唤醒。 以下方法会让线程陷入无限期等待：没有设置 Timeout 参数的 Object.wait() 方法。没有设置 Timeout 参数的 Thread.join() 方法。LockSupport.park() 方法。 限期等待(Timed Waiting)：这种状态下不会被 CPU 分配时间，不过无需等待其他线程显式唤醒，在一定时间后由系统自动唤醒。 以下方法会让线程进入限期等待：Thread.sleep() 方法。设置了 Timeout 参数的 Object.wait() 方法。设置了 Timeout 参数的 Thread.join() 方法。LockSupport.parkNanos() 方法。LockSupport.parkUtil() 方法。 阻塞(Blocked)：阻塞状态是在等待获取一个排他锁。 结束(Terminated)：线程已经执行结束。 线程状态转换图如下：","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"第5章：Binder进程间通信系统","slug":"Android系统源代码情景分析-第5章","date":"2019-09-15T07:48:00.000Z","updated":"2019-11-17T13:44:12.183Z","comments":true,"path":"2019/09/15/Android系统源代码情景分析-第5章/","link":"","permalink":"https://glassx.gitee.io/2019/09/15/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90-%E7%AC%AC5%E7%AB%A0/","excerpt":"Android 应用程序由 Activity、Service、Broadcast Receiver 和 Content Provider 四中组件构成，它们可能运行在不同的进程中。此外，各种系统组件也运行在独立的进程中，如 Activity 管理服务 ActivityManagerService 和 package 管理服务 PackageManagerService 都运行在系统进程 System 中。","text":"Android 应用程序由 Activity、Service、Broadcast Receiver 和 Content Provider 四中组件构成，它们可能运行在不同的进程中。此外，各种系统组件也运行在独立的进程中，如 Activity 管理服务 ActivityManagerService 和 package 管理服务 PackageManagerService 都运行在系统进程 System 中。 Android 是基于 Linux 内核开发的，Linux 内核提供了丰富的进程间通信机制：管道(Pipe)、信号(Signal)、消息队列(Message)、共享内存(Share Memory) 和 套接字(Socket) 等。但Android 系统并没有采用这些传统的进程间通信机制，而是使用了新的机制——Binder。与传统的进程间通信机制相比，Binder 进程间通信机制在进程间传输数据时，只需要执行一次复制操作，不仅提高了效率，并且节省了内存空间。 使用共享内存在进程间传输数据的时候，虽然也只需要进行一次复制操作，但是它一般要结合其他的进程间通信机制来同步信息。 Binder 进程间通信机制采用 C/S 通信方式，提供服务的进程称为 Server 进程，而访问服务的进程称为 Client 进程，同一个 Server 进程可以同时运行多个组件来向 Client 提供服务；而同一个 Client 进程也可以同时向多个 Service 组件请求服务。Service 组件启动时，会将自己注册到一个 Service Manager 组件中，以便 Client 组件可以通过 Service Manager 组件找到它。Binder 进程间通信机制中涉及了 Client、Service、Service Manager 和 Binder 驱动程序四个角色的关系如下图所示： Client、Service 和 Service Manager 都运行在用户控件，而Binder 驱动程序运行在内核控件。Client、Service 和 Service Manager 均是通过系统调用 open(打开)、mmap(内存映射)、ioctl(在用户空间，使用ioctl系统调用来控制设备) 来访问设备文件 /dev/binder ，从而实现与Binder驱动的程序的交互，而交互的目的就是为了能够间接执行进程间通信。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深Android系统源代码情景分析(第三版)","slug":"深Android系统源代码情景分析-第三版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%89%E7%89%88/"}]},{"title":"第13章: 线程安全与锁优化","slug":"深入理解Java虚拟机-第13章","date":"2019-09-14T02:12:00.000Z","updated":"2020-03-03T15:02:38.238Z","comments":true,"path":"2019/09/14/深入理解Java虚拟机-第13章/","link":"","permalink":"https://glassx.gitee.io/2019/09/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC13%E7%AB%A0/","excerpt":"概述并发处理的广泛应用使得 Amdahl 定律替代摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。线程安全线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程问题，更无须自己采取任何措施来保证多线程的正确调用。","text":"概述并发处理的广泛应用使得 Amdahl 定律替代摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。线程安全线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程问题，更无须自己采取任何措施来保证多线程的正确调用。 Java 线程安全为了更深入地理解线程安全，在这里我们可以不把线程安全当做一个非真即假的二元排他选项来看待。按照线程安全的“安全程度”由强至弱来排序，我们可以将Java语言各种操作共享的数据分为：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。 不可变不可变(Immutable) 的对象一定是线程安全的，只要一个不可变对象被正确地创建构建出来(没有发生this引用逃逸的情况)，那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态。 Java 语言中，如果共享数据是一个基本数据类型，只要在定义时使用final关键字就可以保证它是不可变的；如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响，有很多途径去实现这个目的，最简单的就是把对象中带有状态的变量都声明为final，这样，在构造函数结束之后，它就是不可变的。 Java API 中复合不可变要求的类型，有String、枚举类型、Long、Double以及BigInteger、BigDecimal等大数据类型，但同为Number的子类型的原子类 AtomicInteger 和 AtomicLong 则并非不可变的。 绝对线程安全绝对线程安全通常需要付出很大的，甚至有时候是不切实际的代价。在Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全。我们可以通过一个不是“绝对线程安全”的线程安全类来看看这里的“绝对”是什么意思。 Java程序员基本上都认为 java.util.Vector 是一个线程安全的容器，因为它的add、get、size等方法都被 synchronized 修饰的，尽管这样效率很低，但确实是安全的。但是，即使所有方法都被修饰成同步，也并不意味着调用它的时候永远不需要同步手段了，看如下测试代码： 123456789101112131415161718192021222324252627282930313233private static Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;(); public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; vector.add(i); &#125; Thread removeThread = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125;); Thread prindThread = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; System.out.println(vector.get(i)); &#125; &#125; &#125;); removeThread.start(); prindThread.start(); //不要同时产生过多线程，否则导致操作系统假死 while (Thread.activeCount() &gt; 20) ; &#125; &#125; 这段代码运行过程中会出现 ArrayIndexOutOfBoundsException，但是在我自己写代码验证的时候，感觉这个错误还是很容易被忽略的，运行了好长时间都还在一直输出，但其实早就报错了，但不知道怎么程序还是正常运行。这点在自己验证的时候要注意一下，我的运行环境是：Android studio 3.5 + jre 1.8 。 可能你一开始也会和我一样懵逼了，这 Vector 里面每个方法都被 synchronized 关键字修饰，这种情况下调用方法锁定的是对象，虽说synchronized 可以重入，但是上述代码添加、删除、遍历 可是在3个线程当中啊，压根就是互斥的啊，怎么会报错呢？ 原来，我们忽略了一个重要因素：原子操作。在 prindThread 线程中，for 循环会读取 vector.size ，它会先获取锁，然后读取值，假设值是 10，之后释放锁(注意，问题就在这了)，接下来print的时候，假设当前i是7，通过 vector.get(i) 读取元素的时候，会再次加锁，但是由于此时 vector 的size 不知道已经变成多少了，如果此时变成了 6，那么这个 get 操作就会发生越界了。 如果remove线程恰好在一个错误的时间里删除了一个元素，导致序号i已经不再可用的话，再用vector.get(i) 访问就会抛出 ArrayIndexOutOfBoundsException。如果要保证这段代码的正确运行，书上给出的方案是把两个thread改成如下代码： 1234567891011121314151617181920212223Thread removeThread = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (vector)&#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125; &#125;); Thread prindThread = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (vector)&#123; for (int i = 0; i &lt; vector.size(); i++) &#123; System.out.println(vector.get(i)); &#125; &#125; &#125; &#125;); 相对线程安全相对线程安全就是我们通常意义上所讲的线程安全，它需要保证这个对象单独的操作是线程安全的，我们在调用的时候无需做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。Java语言中，Vector、HashTable、Collections的synchronizeCollection() 方法包装的集合等。 线程兼容线程兼容指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。Java API 中大部分类都是属于线程兼容的，如 ArrayList 和 HashMap 等。 线程对立线程对立是指无论调用端是否采取同步措施，都无法再多线程环境并发使用，如 Thread 类的suspend() 和 resume() 方法，如果两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发的话，无论是否进行了同步，都会存在死锁风险(这两个方法在jdk中已经被声明放弃了)。这类代码很少出现，我们也应该避免。 线程安全的实现方法这听起来是代码编写的问题，但虚拟机提供的同步和锁机制也起到了非常重要的作用。只要读者了解了虚拟机线程安全手段的运作过程，自己去思考代码如何编写并不是一件困难的事情。 互斥同步同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只能被一个(或者是一些，使用信号量的时候)线程使用，而互斥是实现同步的一种手段。互斥是因，同步是果；互斥是方法，同步是目的。 Java中最基本的互斥同步手段是 synchronize 关键字，经过编译后，会在同步快的前后分别形成 monitorenter 和 monitorexit 两个字节指令，这两个字节码都需要 reference 类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronize 指明了对象参数，那就是这个对象的 reference ；如果没有明确指定，那就根据 synchronize 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。 根据虚拟机规范，执行 monitorenter 时首先尝试获取对象的锁，如果没有被锁定，或者当前线程已经拥有这个锁，就把锁的计数器 +1 ，相应地，monitorexit 时减 1 。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被释放。 这里有2点是要注意的：synchronize 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题；其次，同步块在已进入的线程执行完之前，会阻塞后面的线程，前面提到过，Java的线程是映射到操作系统的原生线程上的，如果要阻塞或者唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转到核心态中，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块(如被synchronize修饰的getter() 或 setter() 方法)，状态转换消费的时间可能比代码执行时间还要长，所以 synchronize 是 Java 语言中一个重量级(Heavyweight)操作。 还可以使用 ReetrantLock 来实现同步，它的基本用法与 synchronize 相似，都具备线程重入性，只是 ReetrantLock 表现为API语法层面的互斥锁(lock 和 unlock 方法配合 try/finally 语句块来完成)，synchronize 表现为原生语法层面的互斥锁。不过，ReetrantLock 增加了一些高级功能，主要有以下3项： 等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待。 公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁：而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronize 是非公平的，ReetrantLock 默认也是非公平的。 锁绑定多个条件是指一个 ReetrantLock 对象同时可以绑定多个 Condition 对象。而synchronize 中，锁对象的 wait 、notify或者 notifyAll 方法可以实现一个隐含的条件是：如果要和多于一个的条件关联的时候，就要额外地添加一个锁。而 ReetrantLock 无需这样做，只需要多次调用 newCondition 方法即可。 在JDK 1.6以前，synchronize 的吞吐量会随着竞争的激烈程度增加而急剧下降，但 ReetrantLock 却基本保持在平稳水平。但随着后面的优化，二者的性能基本上持平了，并且虚拟机在未来的性能改进中更倾向于原生的 synchronize ，所以还是提倡在 synchronize 能实现需求的情况下，优先考虑使用 synchronize 来同步。 非阻塞同步互斥同步最主要的问题就是线程阻塞和唤醒带来的性能问题，因此也称为阻塞同步，这是一种悲观的并发策略，总认为不去做正确的同步措施，就肯定会出问题。随着硬件指令集的发展（因为我们需要操作和冲突检测这两个步骤具备原子性，只能靠硬件来保证，如果使用互斥同步就失去意义了），我们有了另一个选择：基于冲突检测的乐观并发策略，通俗讲就是先操作，如果没有其他线程竞争，操作就成功了；如果有竞争产生了冲突，再采取其他补偿措施（常见的措施就是不断重试，直到成功）。这种策略无需把线程挂起，因此称为非阻塞同步。 指令集发展后，可以确保一个从语义上看起来需要多次操作的行为只需要一条处理器指令就能完成，其中最重要的指令为 ：比较并交换(Compare-and-Swap) ，下文简称 CAS，它的语义是：内存地址V，旧的预期值 A,新值 B，当且仅当 V 符合旧预期值 A 是，处理器就用新值 B 更新 V，否则就不更新。 不妨拿一段在第 12 章中没有解决的问题代码来看看如何使用CAS操作来避免阻塞同步，我们曾通过这段20个线程自增 10000 此的代码来证明 volatile 变量不具备原子性，那如何才能让它具备原子性？把 “race ++ “ 操作或 increase() 方法用同步块包裹起来当然是一个办法，但如果改成如下代码，效率会提高很多： 12345678910111213141516171819202122232425262728private static AtomicInteger race = new AtomicInteger(0);private static final int THREADS_COUNT = 20; private static void increase()&#123; race.incrementAndGet(); &#125; public static void main(String[] args) &#123; Thread[] threads = new Thread[THREADS_COUNT]; for (int i = 0;i&lt; THREADS_COUNT;i++)&#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0;i&lt; 10000;i++)&#123; increase(); &#125; &#125; &#125;); threads[i].start(); &#125; while (Thread.activeCount() &gt; 1)&#123; Thread.yield(); &#125; System.out.println(race); &#125; 运算结果： 200000 使用AtomicInteger代替int后，程序输出了正确地结果，一切要归功于incrementAndGet 方法的原子性，它的实现非常简单： 123456789public final int incrementAndGet()&#123; for(;;)&#123; int current = get(); int next = current + 1; if(compareAndSet(current,next))&#123; return next; &#125; &#125;&#125; incrementAndGet 方法在一个无限循环中，不断尝试将一个比自己当前值大1的新值赋给自己，如果失败了，那说明在执行“获取-设置”操作的时候值已经有了修改，于是再次循环进行下一次操作，直到设置成功为止（设置成功才return 跳出循环）。 如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A，这就有可能是这段期间它的值曾经被改成了B，后来又被改成了A，那 CAS 操作就会误认为它从来没被改变过，这称为 “ABA” 问题。如果需要解决 “ABA” 问题，改用传统的互斥同步会比原子类更高效。 无同步方案如果一个方法本来就不涉及共享数据，那它自然无需任何同步措施。这种代码是天生线程安全的，这里简单介绍其中两类： 可重入代码：这种代码可以在任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。可重入代码有一些共同特征，如 不依赖存储在堆上的数据和公用的系统资源，用到的状态量都是由参数中传入、不调用 非可重入的方法等。 线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看这些共享数据代码是否能保证在同一个线程中执行，如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内。 符合这种特点的应用并不少见。一个应用实例就是web交互模型中“一个请求对应一个服务器线程”的处理方式 锁优化JDK 1.6 实现了各种锁优化技术，如适应性自旋、锁消除、锁粗化、轻量级锁 和 偏向锁 等，这些技术都是为了在线程之间更高效地共享数据。 自旋锁与自适应自旋在讨论互斥同步的时候，提到了阻塞对性能影响最大。虚拟机开发团队注意到在许多应用上，共享数据锁定状态只会持续很短时间，为这段时间去挂起和恢复线程不值得。我们可以让后面的请求锁的线程“稍等一下”，但不放弃处理器的执行时间，看锁是否被很快释放。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓自旋锁。 自旋本身避免了挂起和恢复过程，但是它占用cpu时间，如果锁被占用的时间很短，这是值得的；反之，如果锁被占用的时间过长，则白白消耗处理器资源，因此需要有一定限度，限定自旋次数。 锁消除如果代码上要求同步，但是被检测到不可能存在共享数据竞争，就可以对锁进行消除，锁消除的主要判定依据来源于逃逸分析的数据支持。也许读者会有疑问，变量逃逸，对于虚拟机来说需要使用数据流分析来确定，但是程序员自己应该很清楚，怎么会在明知道不存在数据竞争的情况下要求同步呢？答案是：有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中普遍存在，来看看下面例子： 123public String concatString(String s1,String s2,String s3)&#123; return s1 + s2 + s3;&#125; 我们知道，String 是个不可变的类，对字符串的连接操作总是通过生成新的String来进行。JDK 1.5 前，String 连接会转化为 StringBuffer对象的连续 append 操作，1.5 及以后的版本会转化为 StringBuilder 对象的连续 append，即上述代码可能会变成以下的样子： 1234567public String concatString(String s1,String s2,String s3)&#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); sb.append(s3); return sb.toString();&#125; 现在大家还认为这段代码没有涉及同步吗？每个 StringBuffer.append 方法中都有一个同步块，锁就是sb对象。虚拟机很快会发现它的动态作用域被限制在 concatString 方法内部，永远不会被逃逸到方法外，因此，虽然这里有锁，也可以被安全地消除。 锁粗化原则上，编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，这是为了使需要同步的操作数量尽可能变小，让等待的线程尽快拿到锁。大部分情况下这原则是正确的。 但是，如果一系列连续操作都是对同一个对象反复加锁和解锁，甚至加锁操作是在循环体中，频繁地进行互斥同步操作会导致不必要的性能消耗。上述代码中连续的 append 方法就属于此类范围，虚拟机会把加锁同步的范围扩展(粗化)到整个操作序列的外部，就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。 轻量级锁轻量级锁是相对于传统的锁机制而言的，首先强调的一点是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 要理解轻量级锁，必须从HotSpot虚拟机的对象（对象头部分）的内存布局开始介绍。HotSpot虚拟机的对象头分为两部分：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄等，官方称为 “Mark Word”，它是实现轻量级锁和偏向锁的关键。第二部分用于存储指向方法区对象类型数据的指针。 在代码进入同步块的时候，如果此同步对象没有被锁定——Mark Word 中锁标记位为 “01”，则虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的 Mark Word 的拷贝，然后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，如果这个更新动作成功了，那么这个县城就拥有了该对象的锁，并且将对象的 Mark Word 的锁标志位转变为 “00” ，表示对象处于轻量级锁定状态。 如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志位变为 “10” ，后面等待锁的线程也要进入阻塞状态。 上面描述的是加锁过程，解锁过程也是通过CAS 操作来进行的，如果对象的 Mark Word 仍然指向线程的锁记录，那就用 CAS 操作把当前对象的的 Mark Word 和 线程中复制的 Mark Word 替换，如果替换成功，整个同步过程完成。如果替换失败，说明其他线程尝试过获取该锁，那么在释放锁的同时，唤醒被挂起的线程。 轻量锁的依据是“绝大部分锁，在整个同步周期内都是不存在竞争的”，这是经验数据，如果没有竞争，轻量级锁使用CAS 操作避免了使用互斥量的开销；如果存在锁竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此会比传统重量级锁更慢。 偏向锁如果说轻量级锁是在无竞争情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。 假设当前虚拟机启用了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机会把对象头中的标志位设置为 “01”，即偏向模式。同时，使用CAS操作把获取到这个锁的线程ID记录在对象的 Mark Word 之中，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。 当另外一个线程去尝试获取这个锁时，偏向模式就结束。根据锁对象目前是否处于被锁定状态，撤销偏向后恢复到 未锁定(标志位 01) 或 轻量级锁定(标志位 00)的状态，后续的同步操作就如上面介绍的轻量级锁执行。 偏向锁可以提高带有同步但无竞争的程序的性能，它不一定总是对程序运行有利。如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。因此，有时候禁止使用偏向锁反而可以提升性能。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"第10章：早期（编译期）优化","slug":"深入理解Java虚拟机-第10章","date":"2019-09-13T13:10:00.000Z","updated":"2020-03-03T13:41:44.918Z","comments":true,"path":"2019/09/13/深入理解Java虚拟机-第10章/","link":"","permalink":"https://glassx.gitee.io/2019/09/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC10%E7%AB%A0/","excerpt":"Java语言的“编译期”是一段“不确定”的操作过程，它可能是指一个前端编译器把.java文件转变成 .class 的过程，也可能是指JIT编译器把字节码变成机器码的过程，还能是指 ATO编译器直接把 .java 文件编译成本地代码的过程。最符合大家认知的应该是第一类，在本章中，我们提到的 “编译期” 以及 “编译器” 都指限于第一类过程。","text":"Java语言的“编译期”是一段“不确定”的操作过程，它可能是指一个前端编译器把.java文件转变成 .class 的过程，也可能是指JIT编译器把字节码变成机器码的过程，还能是指 ATO编译器直接把 .java 文件编译成本地代码的过程。最符合大家认知的应该是第一类，在本章中，我们提到的 “编译期” 以及 “编译器” 都指限于第一类过程。 Javac 编译器前面很多个人觉得只有写编译器才能用得着的内容，先略过。 标注检查：javac的编译过程包含标注检查，标注检查的内容包括诸如变量使用前是否已经被声明，变量与赋值类型是否匹配等。此外，标注检查还有一个重要动作称为常量折叠，如果我们在代码中谢了如下定义： int a = 1 + 2; 那么在语法树上仍然能看到字面量“1”、“2” 以及操作符 “+”，但是经过常量折叠后，他们将会被折叠为字面量 “3”，由于编译期进行了常量折叠，因此在代码中定义 “a = 1 + 2” 与直接定义 “a = 3” 的cpu指令运算量是一样的，并不会增加额外的哪怕一个cpu指令开销。数据及控制流分析是对程序上下文逻辑的进一步验证，以下举一个关于 final 修饰符的数据及控制流分析的例子： 123456789101112//方法一有final修饰public void foo(final int arg)&#123; final int var = 0; //do something&#125;//方法二没有final修饰public void foo(int arg)&#123; int var = 0; //do something&#125; 这两个 foo() 方法中，在代码编写时程序肯定会受到 final 修饰符的影响，不能再改变第一个方法的 arg 和 var 变量的值，但是这两段代码编译出来的Class 文件是没有任何区别的。通过 第六章 的内容可知，局部变量与字段(实例变量、类变量) 是有区别的，前者在常量池中没 CONSTANT_Fieldref_info 符号引用，自然也没有访问标志（Access_Flags）的信息，甚至可能连名称也不会保留下来(取决于编译时的选项)，自然在Class文件中不可能知道一个布局变量是不是声明为 final 了，因此，将局部变量声明为 final 对运行是没有影响的，变量的不可变性仅仅由编译器在编译期间保障。 Java 语法糖的味道语法糖可以看做编译器实现的一些 “小把戏” ，这些小把戏不会提供实质性的功能改进，但它可能会使得效率“大提升”，但我们也应该去了解这些“小把戏”背后的真实世界，那样才能利用好它们，而不是被它们迷惑。 泛型与类型擦除Java中的类型，本质是参数化类型(Parametersized Type)的应用，也就是说所操作的数据类型被指定为一个参数。泛型技术在Java 和 C# 之中的使用方式看似相同，但实现上却有根本性的分期，C# 中的泛型无论在程序源码中、编译后的IL（中间语言）中或是运行期的 CLR 中，都是切实存在的， List 与 List 就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现方式称为类型膨胀，基于这种方法实现的泛型称为真实泛型。 Java 语言中的泛型规则不一样，它们只在源码中存在，在编译后的字节码文件中就已经替换为原来的原声类型了，因此，对于运行期的Java语言来说， ArraList 与 ArrayList 就是同一个类，所以泛型技术实际上是Java的一颗语法糖，这种实现方法称为“类型擦除”，基于这种方法实现的泛型称为 伪泛型。可以通过代码反编译来查看Java泛型实现过程： 1234567public static void main(String[] args)&#123; Map&lt;String,String&gt; map = new HashMap(); map.put(\"hello\",\"你好\"); map.put(\"how are you\",\"吃了吗\"); Systemt.out.println(map.get(\"hello\")); Systemt.out.println(map.get(\"how are you\"));&#125; 把这段代码编译成 Class 文件，再用子界面反编译工具反编译成Java代码，会发现代码变成如下形式： 1234567public static void main(String[] args)&#123; Map map = new HashMap(); map.put(\"hello\",\"你好\"); map.put(\"how are you\",\"吃了吗\"); Systemt.out.println((String)map.get(\"hello\")); Systemt.out.println((String)map.get(\"how are you\"));&#125; 会发现，反编译回来的 Map 定义都变成了 Map map = new HashMap()，输出的时候，是靠强转实现的，也就是把object转为程序员写的实际类型。Java 的伪泛型招致很多批评的声音，不过这种实现方式在某些情况下丧失了泛型思想应有的一些优雅，比如在类中存在如下两个方法： 123456789public class GenericTypes&#123; public static void method(List&lt;String&gt; list)&#123; System.out.println(\"invoke method(List&lt;String&gt; list)\"); &#125; public static void method(List&lt;Integer&gt; list)&#123; System.out.println(\"invoke method(List&lt;Integer&gt; list)\"); &#125;&#125; 思考一下，这段代码是否正确。也许你已经知道了，这段代码是不能被编译的，因为List 与 List 编译后都被擦除了，变成了一样的原生类型 List ,擦除动作导致这两种方法的特征签名变得一样。初看起来，无法重载的原因找到了，但真的如此吗？其实，泛型擦除成相同的原生类型只是无法重载的原因之一，接着看下面的代码： 12345678910111213141516public class GenericTypes&#123; public static String method(List&lt;String&gt; list)&#123; System.out.println(\"invoke method(List&lt;String&gt; list)\"); return \"\"; &#125; public static int method(List&lt;Integer&gt; list)&#123; System.out.println(\"invoke method(List&lt;Integer&gt; list)\"); return 1; &#125; public static void main(String[] args)&#123; method(new ArrayList&lt;String&gt;()); method(new ArrayList&lt;Integer&gt;()); &#125;&#125; 编译执行发现，不但可以编译还能正常输出结果： System.out.println(“invoke method(List list)”)System.out.println(“invoke method(List list)”) 为两个方法添加了不同的返回值之后，方法重载居然成功（注意，仅仅只是在jdk 1.6及以下才能编译通过，高版本是编译不通过的，但在书上是没有这个版本说明的，而我们读者只需要知道有这么个事情就行）了，这是对Java语言中返回值不参与重载选择的基本认知的挑战吗？当然不是的，之所以能够编译成功，是因为两个 method 方法加入了不同的返回值之后，能够共存在同一个 Class 文件了。由于这只是针对低版本的功能，故此处不多解释了。 自动装箱、拆箱与遍历循环这几个专门拿出来讲只是因为它们是Java语言中使用得最多的语法糖。可以通过以下代码看看这些语法糖在编译后会发生什么变化： 123456789public static void main(String[] args)&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4); int sum = 0; for(int i: list)&#123; sum += i; &#125; Systemt.out.println(sum);&#125; 上述代码在自动装箱、拆箱与遍历循环编译后，变成以下样式： 123456789101112131415public static void main(String[] args)&#123; List&lt;Integer&gt; list = Arrays.asList(new Integer[]&#123; Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3), Integer.valueOf(4), &#125;); int sum = 0; for(Iterator localIterator = list.iterator();localIterator.hasNext();)&#123; int i = ((Integer)localIterator.next()).intValue(); sum += i; &#125; Systemt.out.println(sum);&#125; 代码一共包含自动装箱、自动拆箱、遍历循环与变长参数5种语法糖。遍历循环还原成了迭代器的实现，而变长参数则是通过数组的方式转变。语法糖看起来简单，但是也有很多需要注意的地方，如以下代码： 123456789101112131415Integer a = 1;Integer b = 2;Integer c = 3;Integer d = 3;Integer e = 321;Integer f = 321;Long g = 3L;System.out.println(c==d); //true System.out.println(e==f); //false Interger 128限制（缓存了 -128~127的对象，超出这个值就重新new，否则就直接取）System.out.println(c==(a+b)); // trueSystem.out.println(c.equals(a+b)); //true System.out.println(g==(a+b)); //true ，这个还真没找到解释的方法System.out.println(g.equals(a+ b)); //false ,因为 g 是 Long 类型，而 a + b 后是Integer类型，类型都不一样,equals 不会自动处理数据转型 结果和注释都已经写上了，关于Integer的128限制，再来例子说明： 12345678910Integer i=127;Integer j =127;System.out.println(i==j); //truei=128;j=128;System.out.println(i==j); //false i=new Integer(127);j=new Integer(127);System.out.println(i==j); //false 详细解释：jvm在运行时创建了一个缓存区域，并创建了一个integer的数组。这个数组存储了-128至127的值。因此如果integer的值在-128至127之间，则是去缓存里面获取。因此上面的i和j指向的是同一个内存地址。因为128超过了这个缓存区域，因此第二次赋值的时候是重新开辟了两个内存地址。第三次因为使用了new关键字，在java中。new关键字是开辟内存空间。因此第三次赋值是开辟了新的内存空间，此时发现即便i与j都是127，但内存地址不再相同。 包装类的 “==” 运算在不遇到算术运算的情况下不会自动拆箱，并且它们的 equals() 方法不处理数据转型的关系。 条件编译略 实战： 插入式注解处理器略","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"第11章: 晚期（运行期）优化","slug":"深入理解Java虚拟机-第11章","date":"2019-09-08T08:24:00.000Z","updated":"2019-11-17T13:49:50.944Z","comments":true,"path":"2019/09/08/深入理解Java虚拟机-第11章/","link":"","permalink":"https://glassx.gitee.io/2019/09/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC11%E7%AB%A0/","excerpt":"概述Java 程序最初是通过解释器(Interpreter)进行解释执行的，虚拟机发现某个方法或代码块运行特别频繁时，会将它们认定为“热点代码”(Hot Spot Code)。为了提高运行效率，虚拟机会把这些代码编译成本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(Just In Time Compiler, JIT编译器)。","text":"概述Java 程序最初是通过解释器(Interpreter)进行解释执行的，虚拟机发现某个方法或代码块运行特别频繁时，会将它们认定为“热点代码”(Hot Spot Code)。为了提高运行效率，虚拟机会把这些代码编译成本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(Just In Time Compiler, JIT编译器)。 JIT 不是虚拟机必需部分，Java虚拟机规范也没有规定实现，但它却是衡量一款商用虚拟机优秀与否的关键指标，也是最能体现虚拟机技术水平的部分。本章所讲的内容都是基于HotSpot虚拟机。 HotSpot 虚拟机的JIT首先看几个问题： 为何要使用解释器与编译器并存架构 为何要实现两个不同的JIT 程序何时使用解释器执行？何时使用编译器执行？ 哪些程序代码会被编译为本地代码？如何编译为本地代码？ 如何从外部观察JIT的编译过程和编译结果？ 解释器与编译器第一个问题，解释器与编译器两者各有优势：当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；程序运行后，随着时间推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大时，也可以使用解释执行节约内存。同时，解释器可以作为编译器激进优化时的一个“逃生门”。因此，在整个虚拟机架构中，解释器与编译器经常配合工作。 第二个问题，两个不同的JIT一般称为 Client Compiler（也称为 C1 编译） 和 Server Compiler（也称为 C2 编译） 。虚拟机一般会启用分层编译策略，分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次： 第0层：解释执行，解释器不开启性能监控(Profiling)，可触发第1层编译。 第1层，也称C1编译，将字节码编译成本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。 第2层，也称C2编译，将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。 实施分层编译后，C1和C2将会同时工作，许多代码会被多次编译，用C1获取更高的编译速度，用C2获取更好地编译质量，并且解释执行时也无需承担收集性能监控信息的任务。 编译对象与触发条件第三个问题，上文提到，运行过程中会被即时编译器编译的“热点代码”有两类，即： 被多次调用的方法。 被多次执行的循环体。 解释一下第二点，这是为了解决一个方法只被调用过一次或少量几次，但是方法体内部存在循环次数较多的循环体问题。这样，循环体的代码也被重复执行多次，因此这些代码也应该认为是“热点代码”。 编译过程默认设置下，无论是方法调用产生的即时编译请求还是OSR编译请求，虚拟机在代码编译器还未完成之前，都仍将按照解释方式执行。 编译优化技术以如下代码清单来说明编译优化： 12345678910111213141516static class B &#123; int value; final int get() &#123; return value; &#125;&#125;public void foo() &#123; y = b.get(); //do something z = b.get(); sum = y + z;&#125; 首先说明的是，这些代码优化变换是建立在代码的某种中间表示或机器码之上，绝不是建立在Java源码之上，这里是为了展示方便，使用了Java语言的语法来表示这些优化技术所发挥的作用。 以上的代码已经非常简单了，但仍有许多优化余地，第一步就是方法内联(Method Inlining)，内联后的foo函数代码如下： 12345678public void foo() &#123; y = b.value; //do something z = b.value; sum = y + z;&#125; 方法内联的重要性高于其他优化措施，它主要有两个目的：去除方法调用的成本(如建立栈帧等) 以及为其他优化方法建立良好的基础(方法内联膨胀后可以便于在更大范围上采取后续优化手段)。 第二步进行 冗余访问消除(Redundant Loads Elimination)，假设上述代码中 do something 刽改变 b.value的值，那就可以将 z = b.value 替换为 z = y ，因为上一句 y = b.value 已经保证 y 与b.value 是一致的，这样就可以不用再去访问对象b的局部变量了。优化后的代码: 12345678public void foo() &#123; y = b.value; //do something z = y; sum = y + z;&#125; 第三步我们进行复写传播(Copy Propagation)，因为在这段程序的逻辑中没有必要使用 z 这个变量，它与 y 是完全相等的，因此可以用 y 来替代 z ，复写传播后的代码如下： 12345678public void foo() &#123; y = b.value; //do something y = y; sum = y + y;&#125; 第四步我们进行无用代码消除(Dead Code Elimination)。在上述代码清单中， y = y 是没有意义的，把它擦除后的代码如下： 1234567public void foo() &#123; y = b.value; //do something sum = y + y;&#125; 经过4次优化后，达到的效果一致，但是比原始代码省略了许多语句，执行效率也更高。接下来继续看几项有代表性的优化技术。 公共子表达式消除这是语言无关的经典优化技术之一，普遍用于各种编译器的经典优化技术，它的含义是：如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成了公共子表达式。假设存在如下代码： int d = (c * b) * 12 + a + (a + b * c); 这段代码交给JIT编译后，它将进行如下优化：因为 c * b 与 b * c 是一样的表达式，并且在计算期间 b 与 c 的值是不可变的，因此表达式可能会被视为： int d = E * 12 + a + (a + E); 这时候，编译器还可能进行 代数化简(Algebraic Simplification)，把表达式变为： int d = E * 13 + a * 2; 数组边界检查消除如果有一个数组 foo[] ，在Java语言中访问数组元素 foo[i] 的时候系统将会自动进行上下界的范围检查，即i必须满足 i&gt;= 0 &amp;&amp; i &lt; foo.length ，否则抛出异常。 为了安全，数组边界检查是必须的，但是运行期间一次不漏地检查则优点浪费，是可以“商量”的。假如程序中访问一个对象 foo 的某个属性 value，那以Java伪代码表示虚拟机访问的过程如下： 12345if(foo != null) &#123; return foo.value;&#125;else &#123; throw new NullPointException();&#125; 在使用隐式异常优化后，虚拟机会把上述代码变为如下伪代码过程： 12345try &#123; return foo.value;&#125;catch(segment_fault) &#123; uncommon_trap();&#125; 虚拟机会注册一个 segment_fault 信号的异常处理(uncommon_trap),这样当foo不空的时候，对value的访问是不会额外消耗一次对foo判空的开销的。代价就是当 foo 真的为空时，必须转入到异常处理器中恢复并抛出 NullPointException异常，这个过程必须从用户态转到内核态中处理，结束后再回到用户态，速度远比一次判空检查慢，但当 foo 极少为空的时候，隐式异常优化是值得的。 方法内联方法内联是编译器最重要的优化手段之一，除了消除方法调用的成本之外，它更重要的意义在于为其他优化手段建立良好的基础，如下代码就解释了内联对其他优化手段的意义： 12345678910public static void foo(Object obj)&#123; if(obj != null)&#123; System.out.println(\"do something\"); &#125;&#125;public static void testInline(String[] args)&#123; Object obj = null; foo(obj);&#125; 事实上 testInline 方法的内部全部是无用代码，如果不做内联，后续即使进行了无用代码消除优化，也无法发现任何“Dead Code”，因为如果分开来看， foo() 和 testInline() 两个方法的操作都可能是有意义的。因此方法内联的意义不只是把目标方法“复制”到发起调用的方法中避免真实的方法调用。但实际上Java 虚拟机中的内联过程远没有那么简单，如果不是即时编译器做了一些努力，按照经典编译原理的优化理论，大多数的方法都无法进行内联。 逃逸分析逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸；甚至还可能被外部线程访问到，譬如赋值给类变量或者可以在其他线程中访问的实例变量，称为线程逃逸。 如果能证明一个方法不会逃逸到方法或线程外，则可能为这个变量进行一些高效优化： 栈上分配(Stack Allocation)：Java 虚拟机中，在Java 堆上分配创建对象的内存空间几乎是Java程序员都清楚的常识了，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但回收动作（无论是筛选可回收对象还是回收和整理内存）都需要耗费时间。如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁，减小垃圾收集系统的压力。 同步消除(Synchronization Elimination)：线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么变量的读写肯定不会有竞争，对这个变量实施的同步措施就可以被消除。 标量替换(Scalar Replacement)：标量(Scalar)是指一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型(int、long等数值类型及 refrence 类型等)都不能再进一步分解，它们就可以称为标量。相对地，如果一个数据可以继续分解，那它就称作聚合量，Java中的对象就是最典型的聚合量。如果把一个Java 对象拆散，根据程序访问情况将其使用到的成员变量恢复原始类型来访问就叫做标量替换。 如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上分配和读写外，还可以为后续进一步优化手段创建条件。 Java 与 C/C++的编译器对比有兴趣的时候再来补上，略。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"deepin使用心得","slug":"deepin使用心得","date":"2019-08-18T03:40:00.000Z","updated":"2020-03-10T13:54:42.563Z","comments":true,"path":"2019/08/18/deepin使用心得/","link":"","permalink":"https://glassx.gitee.io/2019/08/18/deepin%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/","excerpt":"背景在windows 10 上使用Android studio 开发，分分钟让你怀疑人生，编译运行一次看效果，5、6分钟很正常，7、8分钟是常有的事，忍无可忍，决心切换到 linux 环境。以个人的理解，Linux 的发行版都是基于相同的内核，所以比较各个发行版的时候，我个人主要比较 美观程度、使用方便程度以及可使用的软件数目。","text":"背景在windows 10 上使用Android studio 开发，分分钟让你怀疑人生，编译运行一次看效果，5、6分钟很正常，7、8分钟是常有的事，忍无可忍，决心切换到 linux 环境。以个人的理解，Linux 的发行版都是基于相同的内核，所以比较各个发行版的时候，我个人主要比较 美观程度、使用方便程度以及可使用的软件数目。 在尝试包括ubuntu、中兴的新支点、优麒麟、deepin 之后，最终选择使用 deepin（深度技术）。deepin 有自己的应用商店，里面有包括 wps、qq、微信、TIM、foxmail、百度云盘、MindMaster、搜狗输入法等常用软件（有些是deepin-win版本的，但是优化得很好），并且如果需要安装其他的常用软件，也能通过deepin-wine方式安装；除此之外，deepin的界面极为美观，操作起来也特别方便，很多操作与windows类似。最重要的是，deepin天生对中文环境友好，并且无需费神选择镜像源，几乎安装上就能够正常使用，因此在这里，我强烈安利一波这个国产的，难得的linux发行版。 软件安装一、安装Android studio按照官方给的教程下载，并且解压到相应的目录即可，你可以把快捷方式的图标固定在decor上，如果之后偶尔通过这个图标不能正常启动，就进入 AS 的解压目录，进入bin 目录中，双击 studio.sh 运行就可以正常使用了。 二、安装rtx打开终端，输入以下命令： sudo apt install deepin.com.qq.rtx2015 卸载就输入： sudo apt remove deepin.com.qq.rtx2015 三、安装openJdkAndroid 开发使用 openJdk 就足够了，并且安装过程也是超级方便，以下命令就能搞定： sudo apt-get install openjdk-8-jdk 四、安装git作为developer，版本管理是必不可少的，git 最初是为 linux 版本管理而生，因此在linux上安装 git 也是极为方便： sudo apt-get install git 其他软件可以从deepin自带的应用商店安装。 卸载软件linux彻底卸载软件步骤:以卸载wine为例 1、 删除软件及配置文件 sudo apt-get –purge remove wine 2、 删除没用的依赖包 sudo apt-get autoremove wine 3、 此时dpkg的列表中有”rc”状态的软件包,可以执行以下命令进行最后清理 sudo dpkg -l |grep ^rc|awk ‘{print $2}’ |sudo xargs dpkg -P 4、 然后删除安装包,位于/root/.wine和/home/usrname/.wine sudo rm -rf /root/.winesudo rm -rf /home/usrname/.wine Android Studio 使用有时候，需要在 Android studio 的 terminal 中输入相应的gradle 命令，尤其是build出错又找不到错误的时候，就想使用命令： gradlew compileDebugSources –stacktrace -info 但是我们直接在as的terminal中输入这行命令是不行的，并且我一般也懒得去配置环境。这时候，其实我们可以在项目的根目录下能发现 gradlew 的一个文件，我们能不能使用这个gradlew呢？事实上是可以的，只需要执行： ./gradlew compileDebugSources –stacktrace -info 如果提示权限不足，只需要chmod 777 项目的根目录修复下权限即可： sudo chmod -R 777 chmod -R 777 /media/test/_dde_data/work/test Android 源码下载安装repoAndroid 源码是使用 repo 管理的，所以我们首先安装repo，在安装repo前，你可能需要先安装 curl ： sudo apt-get install curl 安装完成后，可以通过命令查看 curl 的版本号，同时验证 curl是否安装完成 curl –version 步入正题，在deepn下，我们只需要在终端输入以下3条简单的命令即可完成repo的安装： mkdir ~/bincurl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo 接着，我们还需要为 repo 配置环境变量，在终端中输入： sudo vim /etc/bash.bashrc 当然，如果你安装了 sublime 的话，可以使用如下命令会更方便一些： sudo subl /etc/bash.bashrc 在这个打开的文件尾部添加你的环境变量，比如我的就是这样的(你需要把路径换成你的，一般来说你将我的例子中的 glassx 换成你的用户名即可)： export PATH=$PATH:/home/glassx/bin:$REPOPATH 使环境变量生效： source /etc/bash.bashrc 接下来，你可以正式下载Android 源码了。 下载 Android 源码由于众所周知的原因，我们下载Android 源码链接不可能成功，因此推荐使用清华大学的源，官方主页为： https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ 你也可以直接直接复制链接： https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar 放在迅雷中下载，这个文件略大，估计下载时间按照天来计算。 下载完成后，解压到指定文件夹(-C 用来指定解压后的文件存放位置)： tar -xvf /media/glassx/AndroidSourceCode/aosp-lastest.tar -C /media/glassx/AndroidSourceCode 在解压后的目录下， ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录，cd 到这个文件夹下，执行 : repo sync 就可以同步所有分支了，这个过程消耗的时间也略长，可能需要若干个小时，请耐心等待。至此，我们已经将 Android 源码成功下载下来并且解压同步分支了。 由于我同事有这个tar文件了，所以我就直接从他那里copy了过来，如果你同学或者同事也已经有这个tar文件了，可以直接复制这个文件。这里顺带说一下操作方式：如果你是windows ，并且他也是windows，则只需要他将这个文件所属的目录设置为共享文件夹，之后你在你的文件管理器中输入类似以下地址： \\192.168.12.13\\d\\共享文件夹 其中192.168.12.13 是你同事的ip，后面接的是共享文件夹的路径。 如果你的是deepin，你同事的也是linux，那么也好办，使用 ssh 登录你同事的电脑： ssh 192.168.12.13 登录成功后，进入你同事的电脑，通过 scp 命令可以把文件给copy到你的电脑上。 很多时候我们想要做的就是自己编译一个 Android 系统安装在模拟器上，这个我目前还未完成，等完成后，再来续上。 deepin遇到的问题今天遇到问题了，安装软件和升级都不行，报错： 12345sudo apt-get upgrade正在读取软件包列表... 完成正在分析软件包的依赖关系树正在读取状态信息... 完成E: 软件包 mindmaster 需要重新安装，但是我无法找到相应的安装文件。 或者是： 12345sudo apt-get install mindmaster正在读取软件包列表... 完成正在分析软件包的依赖关系树正在读取状态信息... 完成E: 软件包 mindmaster 需要重新安装，但是我无法找到相应的安装文件。 怎么着解决也不行，最后在网上找到这个方法，首先： rm -rf /var/lib/dpkg/info/mindmaster* 然后： sudo dpkg –remove –force-remove-reinstreq mindmaster","categories":[{"name":"linux","slug":"linux","permalink":"https://glassx.gitee.io/categories/linux/"}],"tags":[{"name":"手摸手","slug":"手摸手","permalink":"https://glassx.gitee.io/tags/%E6%89%8B%E6%91%B8%E6%89%8B/"}]},{"title":"第5章：Android 进程/线程管理","slug":"深入理解Android内核设计思想-第5章","date":"2019-08-06T13:40:00.000Z","updated":"2019-11-17T13:48:46.555Z","comments":true,"path":"2019/08/06/深入理解Android内核设计思想-第5章/","link":"","permalink":"https://glassx.gitee.io/2019/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC5%E7%AB%A0/","excerpt":"Android 进程和线程进程(process) 是程序的一个运行实例，而线程(Thread)则是 CPU 调度的基本单位。对于Android应用开发者而言，通常面对的都是 Activity、Service等组件，并不需要特别关心进程是什么，因而产生了一些误区，如部分研发者认为系统四大组件就是进程的载体。","text":"Android 进程和线程进程(process) 是程序的一个运行实例，而线程(Thread)则是 CPU 调度的基本单位。对于Android应用开发者而言，通常面对的都是 Activity、Service等组件，并不需要特别关心进程是什么，因而产生了一些误区，如部分研发者认为系统四大组件就是进程的载体。 很遗憾，虽然四大组件很符合我们对进程的印象，但是他们不能算是完整的进程实例，最多只能算进程的组成部分，从 AndroidManifest.xml 中也可以得到一点提示（这个xml是对应用程序的声明和描述）： 1234&lt;application android:label=\"launch performance\"&gt; &lt;activity android:name=\"SimpleActivity\"&gt; ... 可以看到，Activity的外围有一个名为 的标签，换句话说，四大组件都只是 “application”的零件。通过例子来分析让读者有个更全面的认识，通过Activity A启动Activity B，在 B 的onCreate(Bundle savedInstanceState) 打断点，查看断点详情可以看到如下图所示的内容： 从这个实验中还解决了一个重要问题，即主线程到底怎么产生的，从上图的函数堆栈可以知道：主线程由ZygoteInit启动，经由一系列调用后最终才执行Activity的onCreate函数，并且，Zygote为Activity创建的主线程是 ActivityThread。以下是源码展示： 1234567891011121314151617181920212223public static void main(String[] args) &#123; CloseGuard.setEnabled(false); //只有主线程才能调用这个函数，普通线程应该使用prepare()，具体见对 Looper 的讲解 Looper.prepareMainLooper(); //主线程对应的handler if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; //这个main()是static的，因此这里需要创建一个实例 ActivityThread thread = new ActivityThread(); //Activity是由界面显示的，这个函数将与WindowManagerService 建立联系 thread.attach(false, startSeq); //主循环开始 Looper.loop(); //如果程序运行到了这里，说明退出了上面的Looper循环 throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 其实，启动Activity后，除了main thread 外还有多个binder线程，如下图所示（用于Binder的那些线程是在什么时候创建的，这个问题留到后面Binder章节详细解答）： 图中可以看到，B 被启动之后，主线程也始终只有一个，此时A退出了运行，但没有被杀掉，只是被压入了栈中。同样，如果我们启动一个Service，并把断点打在Service的onCreate方法的中，我们会发现，Service也是寄存于ActivityThread之中的，并且启动流程和Activity基本上一致，并且启动Service时，同样有Binder线程支持。限于篇幅，这里不做截图和代码。 按照Android系统设计：”By default，all componets of the same application run in the same process and thread(called the “main” thread)”，这可以理解为，对于同一个AndroidManifest中定义的四大组件，除非有特别的声明，否则它们都运行在同一个进程中(并且均由主线程处理事件)。如何证明呢？根据前面操作系统的基础知识，如果两个对象处于同一个进程空间，那么内存区域应该是可共享访问的，利用这个原理我们可以论证下： 12345678910111213141516171819202122232425262728//第1个activitypublic class MainActivity extends BaseActivity &#123; static int ConstTemp = -1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //在启动SecondActivity 前，将ConstTemp值改为2，如果他们不是处于同一个进程，那么在 // SecondActivity中是无法获得更新后的值 2 的，只可能是 -1 ConstTemp = 2; startActivity(new Intent(this,SecondActivity.class)); &#125;&#125;//第2个acitivitypublic class SecondActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); Log.e(\"SecondActivity\",\"ConstTemp = \" + MainActivity. ConstTemp); &#125;&#125; 最终输出的结果是2，说明都是在同一个进程中，当然，我们还可以通过查看二者的 PID 和 TID 的方法证明这两个Activity默认确实在同一个进程中。当然，Android还提供了特殊方式让不是同一个包的组件也可以运行于相同的进程中，这样做的优势是，它们可以方便地资源共享，而不用大费周章地进程间通信。这可以分为两种情况： 在AndroidManifest中的四大组件标签中加入 android:process 来表明这一组件想要运行在哪个进程空间。 针对整个程序包，可以直接在 标签中，加入 android:process 属性来指明想要依存的进程环境。 Handler、MessageQueue、Runable与Looper参考专题里面的内容（现在还没放上去）略 UI主线程-ActivityThread前面提到Activity的部分源码，这里精简下再贴出来： 1234567891011121314public static void main(String[] args) &#123; Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 普通线程使用Looper的代码如下： 1234567891011class LooperThread extends Thread&#123; public Handler mHandler; public void run()&#123; Looper.prepare(); mHandler = new Handler()&#123; public void handleMessage(Message msg)&#123;&#125; &#125; Looper.loop(); &#125;&#125; 比较二者的代码可知其中的区别主要体现在： prepareMainLooper 和 prepare，普通线程prepare就可以了，而主线程使用 prepareMainLooper ，主要是多了一步给sMainLooper 赋值的操作，这样，我们就能从主线程中通过 getMainLooper() 方式获得主线程的 Looper。 Handler不同，普通线程申城一个与Looper绑定的Handler，而主线程是从当前线程中获取的Handler，也就是说，ActivityThread 提供了一个“事件管家”，以处理主线程中各种消息。 Thread 类Thread 类的内部原理Thread 实现了 Runnable ，也就是说线程是“可执行的代码”。我们一般通过2种方式使用Thread ： 123456//第1种MyThread thr = new MyThread(...);thr.start();//第2种new Thread(Runnable target).start(); 这两种方法最终都通过 start 启动，它会间接调用Runable 的 run 实现. 线程的休眠和唤醒控制线程的相关方法我们至少可以想到以下几个： wait()、notify()、notifyAll()、interrupt()、join() 和 sleep()。 wait 和 notify/notifyAll 和其他方法不同，这3个函数是由 Object 类定义的——意味着它们是任何类的共有“属性”，那为什么这么设计呢？官方对wait的解释是： Causes the calling thread to wait until another thread calls the notify() or notifyAll() method of this object 当某个线程调用一个 Object 的wait 方法时，系统就要在这个 Object 中记录这个请求。因为调用者很可能不止一个，所以可使用列表的形式来逐一添加它们。当后期唤醒条件满足时， Object 既可以使用 notify 来唤醒列表中的一个等待线程，也可以通过 notifyAll 来唤醒列表中的所有线程。值得注意的是，调用者只有称为 Object 的 monitor 后，才能调用它的 wait 方法，而称为一个对象的 monitor 有以下3种途径： 执行这个 object 的 synchronize 方法 执行一段 synchronize 代码，并且是基于这个 object 做的同步 如果 object 是 Class 类，可以执行它的 synchronize static 方法 interrupt ：如果说wait是自愿行为， 那 interrupt 就是 “被迫” 的了，它的意思就是“中断”。 join，用以下例子说明： 12345Thread t1 = new Thread(new ThreadA());Thread t2 = new Thread(new ThreadB());t1.start();t1.join();t2.start(); 它希望达到的目的就是只有当 t1 线程执行完成时，我们才接着执行后面的 t2.start() 。这样就保证了两个线程顺序执行。 sleep：它和 wait 一样都是属于“自愿”的行为，只不过 wait 是等待某个 object ，而sleep 是等待时间，一旦设置的时间到了就会被唤醒。 Thread 实例讲一个典型范例来理解Thread：假如我们使用 SeekBar 开控制系统音效，要求：(1)UI界面响应流畅，(2)并且要能反映出音效的变化，(3)并且系统稳定。同时，有以下几个前提： 向系统发送音效调整的命令是个耗时操作 频繁向系统发送调整命令会导致死机 用户的操作是随意的，没有规律的（用户可能飞快地拉动，也有可能慢慢拉动） 对于要求1，可以将发送命令这个耗时操作放到一个独立线程执行，这样就不会影响UI，保证流畅。而根据3个前提条件，条件2和条件3是有矛盾的，如果要实时听到音效变化，在seekbar进度变化错城中需要不停地发送请求，而用户快速滑动导致产生大量请求，可能会引起死机，从而违背第3个要求。 再来想想其它简单方法，当启动一个新的线程处理调整请求时，显然需要把这些请求先放入消息队列中再排队处理，假设用户1s内产生了24个请求，那么队列中的数量将会陆续增加（假设500ms才处理完一个），直到用户操作结束。那么，实际上这些请求值是有优先级的，即后产生的调整值更贴近用户想要的效果。根据这个思想，我们可以适当控制消息队列中元素的数量，比如： 当产生新的调整值时，先清空消息队列，然后再把请求入队。 当产生新的调整值时，先判断消息队列的数量，根据实际情况删除部分消息，然后才请求入队。采用这种方式可以保证最后一个入队的请求总是可以被处理的，这也就意味着用户最终选择的音效值是可以体现出来的。示例代码如下： 12345678910111213141516171819private Thread mBusinessThread = null;private boolean mBusinessThreadStarted = false;private BusinessThreadHandler mBusinessThreadHandler = null;private void startBusinessThread()&#123; if(true == mBusinessThreadStarted) return; else mBusinessThreadStarted = true; mBusinessThread = new Thread(new Runnable()&#123; @Override public void run()&#123; Looper.prepare(); mBusinessThreadHandler = new BusinessThreadHandler(); Looper.loop(); &#125; &#125;); mBusinessThread.start();&#125; 上述代码使用Looper.loop 来不断处理调整请求，这些请求是通过 mBusinessThreadHandler 发送到 mBusinessThread 的消息队列中的，如下所示： 1234567891011121314151617181920public class BusinessThreadHandler extends Handler&#123; //重写 sendMessage @Override public boolean sendMessage(int what,int arg1,int arg2)&#123; //清理消息队列中未处理的请求 removeMessages(what); //发送消息到队列 return super.sendMessage(obtainMessage(what,arg1,arg2)); &#125; public void handleMessage(Message msg)&#123; switch(msg.what)&#123; case MSG_CODE: //执行耗时操作 break; default: break; &#125; &#125;&#125; sendMessage 方法中首先清除了消息队列中还未被处理的请求，这样一方面降低了程序向系统发送请求的频率，加快了相应速度和UI流畅性；另一方面保证 BusinessThreadHandler 下次取到的是优先级较高的调整请求值，保证用户听到实时的音效变化。 Android 应用程序的典型启动流程我们了解到 Android 系统中一个应用程序的主体是由 ActivityThread 构成的，并且 Android 系统是基于 Linux 的，原则上说它的应用程序并不只是 APK 一种类型，换句话说，所有 Linux 支持的应用程序都可以通过一定方式运行在 Android 上(一些系统级应用程序就是以这种方式存在的)，为了叙述统一，我们这里所指的应用程序都是 APK 类型的应用程序。它们通常由两种方式在系统中被启动： 在 Launcher 中点击相应的应用程序图标启动 通过 startActivity 启动 这两种启动方式的流程基本上是一致的，最终都会调用 ActivityManagerService(以下简称 AMS) 的 startActivity 来完成。在新的 Activity 启动钱，原先处于 resume 状态的 Activity 会被 pause ，这种管理方式比 Windows 的多窗口系统简单得多，将一个 Activity 置为 pause 主要通过此 Activity 所属进程的 ApplicationThread.schedulePauseActivity 方法完成，ApplicationThread 是应用程序进程提供给 AMS 的一个 Binder 通道。假设即将启动的 Activity 所属的进程并不存在，那么 AMS 还需要先把它启动起来。 ActivityThread 启动并做好相应的初始化工作后，需要调用 attachApplication 来通知 AMS ，后者才能继续执行未完成的 startActivity 流程。具体而言， AMS 通过 ApplicationThread.scheduleLaunchActivity 请求应用程序来启动一个指定的 Activity ，之后一系列工作就要靠应用进程自己来完成，如 Activity 创建 Window，遍历 View Tree 等。 在进入后面的章节前，这里先大略熟悉 startActivity 的流程。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深入理解Android内核设计思想-林学森","slug":"深入理解Android内核设计思想-林学森","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E6%9E%97%E5%AD%A6%E6%A3%AE/"}]},{"title":"第8章: 虚拟机字节码执行引擎","slug":"深入理解Java虚拟机-第8章","date":"2019-08-01T13:00:00.000Z","updated":"2020-02-15T13:18:09.281Z","comments":true,"path":"2019/08/01/深入理解Java虚拟机-第8章/","link":"","permalink":"https://glassx.gitee.io/2019/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0/","excerpt":"概述在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，所有的虚拟机执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。运行时栈帧结构栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的局部变量表、操作数栈、方法返回地址等信息。每一个方法从调用开始到执行完成的过程，对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。","text":"概述在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，所有的虚拟机执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。运行时栈帧结构栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的局部变量表、操作数栈、方法返回地址等信息。每一个方法从调用开始到执行完成的过程，对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。 在编译代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响。典型的栈帧结构如下图： 一个线程中的方法调用链可能会很长，在活动线程中，只有位于栈顶的栈帧才是有效的。 局部变量表局部变量表示一组变量值存储空间，用于存放 方法参数 和 方法内部蒂尼的局部变量。在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法(非static方法)，那局部变量表中第0位索引默认用于传递方法所属实例的引用，在方法中可以通过”this”关键字来访问这个隐含参数。剩下的参数则按照参数表顺序排列，参数表分配完毕后，再分配方法体内部定义的变量。 为了节省栈帧内存，局部变量表的空间是可以重用的，方法体中定义的变量，其作用域不一定会覆盖整个方法体，当超出作用范围时，它的空间就可能交给其他变量使用，不过这样的设计出了节省栈帧空间外，还会伴随额外的副作用，比如导致垃圾不能及时回收，以下举例说明()： 1234public static void main(String args)&#123; byte[] placeholder = new byte[64 * 1024 * 1024]; System.gc();&#125; 代码中向内存中填充了64MB数据，然后通知虚拟机进行垃圾收集，但是我们可以发现结果并没有回收。不过，这里没有回收placeholder所占的内存还说得过去，因为在执行gc时，placeholder还处于作用域之呢，虚拟机自然不会回收，下面把代码改下（代码8-2）： 12345678public static void main(String args)&#123; &#123; byte[] placeholder = new byte[64 * 1024 * 1024]; &#125; System.gc();&#125; 加入花括号之后，placeholder的作用域被限制在花括号之内，从代码逻辑上讲，gc的时候，placeholder就已经不可能再被访问了，但是执行以下，发现还是没有被回收。在解释之前，再次修改下代码试试（代码8-3）： 123456789public static void main(String args)&#123; &#123; byte[] placeholder = new byte[64 * 1024 * 1024]; &#125; int a = 0;//添加这句 System.gc();&#125; 再次运行，发现内存被正确地回收了，看起来很莫名其妙。placeholder 能否被回收的根本原因是：局部变量表中是否还存有关于placeholder数组的引用。第一次修改中，代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder原本所占的空间还没有被其他变量复用，所以作为GC Roots一部分的局部变量表仍然保持着对它的引用。这种关联没有被及时打断，在绝大部分情况下影响都很轻微。 但是如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（代替上面例子中的 int a = 0，把变量对应的局部变量表中的空间清理掉）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用。 上述例子说明了在某些情况下赋null值操作确实是有用的，但是不应对这种操作有过多依赖，更没必要当做普遍的编码规则来推广，原因有两点：一是从编码角度讲，以恰当的变量作用域来控制变量的回收时间才是最优雅的解决方案。二是从执行角度讲，使用赋null值操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，赋null值的方式在经过JIT编译优化之后就会被消除掉，这时候将变量设置为null是没有意义的。以前面的例子来说，代码8-2 的形式经过JIT编译后，System.gc() 执行时，就可以正确地回收内存了，无需再写成代码 8-3 的样子。 还有一点需要注意，类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；一次在初始化阶段，赋予程序员定义的初始值，因此，即使在初始化阶段没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量不一样，它并不存在“准备阶段”，因此如果定义了局部变量但是没有赋初始值是不能使用的。 这段做的笔记有点多，这是因为个人以前在一些书籍上看到有观点说，推荐及时将不使用的对象手动置为null，但是解释语焉不详，在这里从虚拟机角度看到了解释，故详细记下来 操作数栈操作数栈(operand stack)是一个后入先出的栈，痛局部变量表一样，操作数栈的最大深度也在编译时写入到Code属性中了。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容。 举个例子，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令是，会将这两个int值出栈并相加，然后将相加的结果入栈。 方法调用方法调用并不等同于方法执行，方法调用唯一的任务就是确定被调用方法的版本（即调用哪一个方法），还不设计方法内部的具体运行。前面已经讲过，Class文件的编译过程不包含传统编译中的连接步骤，一切方法调用在Class文件里面都只是符号引用，而不是方法在时机运行时内存布局中的入口地址（相当于之前说的直接引用）。 解析前面提到，所有方法调用中的目标方法在Class文件中都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用。这种解析能成立的前提是：“编译期可知，运行期不可变”，这类方法的调用就称为“解析(Resolution)”。符合这种特性的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。 只能被invokestatic 和 invokespecial 指令调用的方法都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实力构造器、父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法称为非虚方法，与之对应的称为虚方法（final方法除外）。 被final 修饰的方法虽然是通过invokevertual 指令调用的，但是由于它无法被覆盖，没有其他版本，所以Java语言规范中明确说明final是一种非虚方法。 分派Java具备面向对象的3个基本特征：继承、封装以及多态。分派调用过程将会揭示多态性特征的一些基本体现，如“重载”和“重写”在Java虚拟机中是如何实现的。 1、 静态分派 在讲解静态分派之前，看一段经常出现在面试题中的代码，方法静态分派代码如下面代码8-6所示： 123456789101112131415161718192021222324252627282930public class StaticDispatch&#123; static abstract class Human&#123; &#125; static class Man extends Human&#123; &#125; static class Woman extends Human&#123; &#125; public void sysHello(Human guy)&#123; System.out.println(\"hello ,guy !\"); &#125; public void sysHello(Man guy)&#123; System.out.println(\"hello ,gentleman !\"); &#125; public void sysHello(Woman guy)&#123; System.out.println(\"hello ,lady !\"); &#125; public static void main(String[] args)&#123; Human man = new Man(); Human woman = new Woman(); StaticDispatch sr = new StaticDispatch(); sr.sayHello(man); sr.sayHello(woman); &#125;&#125; 打印结果： hello ,guy!hello ,guy! 这段代码实际上是考验读者对重载的理解程度，但这里为什么会选择执行参数类型为 Human 的重载呢？解决问题前，先按如下代码定义两个重要概念： Human man = new Man(); 上面代码中的”Human”称为变量的静态类型（Static Type）或叫做外观类型(Apparent Type)，后面的 “Main” 则称为变量的实际类型(Actual Type)。静态类型和实际类型在程序中都可以发生一些变化，**区别是，静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才确定，例如下面代码： 1234567//实际类型变化Human man = new Man();man = new Woman();//静态类型变化sr.sayHello((Man)man);sr.sayHello((Woman)man) 回到上面代码 8-6 中，由于虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的，并且静态类型是编译期可知的，因此在编译阶段，根据静态类型选择了 sayHello(Human) 作为调用目标，并把这个方法的符号引用写到main方法里的两条invokevirtual指令参数中。静态分派的典型应用是方法重载，另外，编译器虽然能确定出方法的重载版本，但很多情况下这个重载版本并不是”唯一“的，往往只能确定一个”更加合适的“版本，以下代码 8-7演示了何为”更加合适“的版本： 123456789101112131415161718192021222324252627282930313233public class Overload&#123; public static void sysHello(Object arg)&#123; System.out.println(\"hello Object\"); &#125; public static void sysHello(int arg)&#123; System.out.println(\"hello int\"); &#125; public static void sysHello(long arg)&#123; System.out.println(\"hello long\"); &#125; public static void sysHello(Character arg)&#123; System.out.println(\"hello Character\"); &#125; public static void sysHello(char arg)&#123; System.out.println(\"hello char\"); &#125; public static void sysHello(char... arg)&#123; System.out.println(\"hello char...\"); &#125; public static void sysHello(Serializable arg)&#123; System.out.println(\"hello Serializable\"); &#125; public static void main(String[] args)&#123; sayHello('a') &#125;&#125; 打印结果： hello char 如果注释掉 sysHello(char arg) 方法，则会打印 “hello int”；再注释掉 sysHello(int arg) 方法，则会打印 “hello long”；再注释掉 sysHello(long arg) 方法，则会打印 “hello Character”；如此下去，输出的结果会不断变化。这其实也还好理解： ‘a’首先是个char，自然首先输出 hello char；如果没有该方法，则自动类型转换为int，如果再没有此方法，则会进一步转换为long类型（按照 char -&gt; int -&gt; long -&gt; float -&gt; double的顺序进行匹配，但不会匹配到byte和short类型，因为转型到这两种是不安全的）。所以上述代码在注释掉 sysHello(long arg) 后，输出变为 “hello Character” ，此时发生了自动装箱。如此注释下去，”hello char…” 将会是最后一个打印的，可见变长参数的重载优先级是最低的，甚至比Object还低。值得注意的是，有一些在单个参数中成立的自动转型，如char转型为 int，在变长参数中是不成立的。 2、 动态分派 动态分派和多态性的另一个重要体现——重写(Override)有很密切的关联，结合前面Man和Woman一起sayHello的例子来看如下代码： 123456789101112131415161718192021222324252627282930public class DynamicDispatch&#123; static abstract class Human&#123; protected abstract void sayHello(); &#125; static class Man extends Human&#123; @Override protected void sayHello()&#123; System.out.println(\"man say hello\"); &#125; &#125; static class Woman extends Human&#123; @Override protected void sayHello()&#123; System.out.println(\"woman say hello\"); &#125; &#125; public static void main(String[] args)&#123; Human man = new Man(); Human woman = new Woman(); man.sayHello(); woman.sayHello(); man = new Woman(); man.sayHello(); &#125;&#125; 打印结果： man say hellowoman say hellowoman say hello 结果不出人意料，但是虚拟机是如何知道要调用哪个方法？这里显然不能再根据静态类型来决定，因为静态类型都是Human的两个变量 man 和woman 在调用 sayHello 方法时执行了不同的行为，并且man在两次调用中执行了不同的方法。因此可以看出，这只是因为变量的实际类型不同。因为invokevirtual指令的运行时解析过程大致如下： 第一步：找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C第二步：如果在C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过，则返回方法的直接引用；否则，返回 java.lang.IllegalAccessError异常。第三步：否则，按照继承关系从下往上一次对C的各个父类进行第二步的搜索和验证。第四步： 如果始终没有找到合适的方法，则抛 java.lang.AbstractMethodError异常。 3、 单分派与多分派 方法的接收者与方法的参数统称方法的宗量。根据分派基于多少种宗量，可以将分派划分为但分派和多分派，单分派是根据一个宗量对目标方法进行选择；多分派就是根据多个宗量对目标方法进行选择。定义比较拗口，对照下面这个例子，分析 Father 和 Son 做“艰难决定”之后，就不难理解了： 1234567891011121314151617181920212223242526272829303132333435//单分派、多分派的例子public class Dispatch&#123; static class QQ &#123;&#125; static class _360 &#123;&#125; public static class Father&#123; public void hardChoice(QQ arg)&#123; System.out.println(\"father choose qq\"); &#125; public void hardChoice(_360 arg)&#123; System.out.println(\"father choose 360\"); &#125; &#125; public static class Son extends Father&#123; public void hardChoice(QQ arg)&#123; System.out.println(\"son choose qq\"); &#125; public void hardChoice(_360 arg)&#123; System.out.println(\"son choose 360\"); &#125; &#125; public static void main(String[] args)&#123; Father father = new Father(); Father son = new Son(); father.hardChoice(new _360()); son.hardChoice(new QQ()); &#125;&#125; 运行结果： father choose 360son choose qq 根据以上代码，我们看看编译阶段编译器的选择过程，也即静态分配过程。这时候选择目标方法的依据有两点：静态类型以及参数，最终产物是产生了两条invokevirtual 指令，两条指令的参数分别为常量池中指向 Father.hardChoice(_360) 以及 Father.hardChoice(QQ) 方法的符号引用，因为是根据两个宗量选择，所以Java语言的静态分派属于多分派类型。 再看看运行阶段虚拟机的选择，也即动态分派的过程。在执行 “son.hardChoice(new QQ())” 时，由于编译期已经决定目标方法的签名必须为 hardChoice(QQ) ,此时，参数的静态类型和参数的实际类型都对方法的选择不会构成任何影响(只要是QQ类型，管你是“腾讯QQ”还是“奇瑞QQ”)，唯一可以影响虚拟机选择的因素只有方法接受者的实际类型是 Father 还是 Son ，因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。 因此，到目前为止（Java 1.8），我们可以说Java语言是一门静态多分派、动态单分派的语言。 4、虚拟机动态分派的实现 上述的分派结局虚拟机在分派过程中“会做什么”，具体如何做到的，不同虚拟机之间会有差异。由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜寻合适的目标方法。但是在实际实现中并不会进行如此频繁的搜索，面对这种情况，最常用的手段就是为类在方法区中建立一个**虚方法表(Vitual Method Table,即vtab)，使用虚方法表索引来替代元数据查找以提高性能.基于上方的代码，做如下虚方法表示意： 虚方法表中存放着各个方法的实际入口地址，如果方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类方法相同，否则，替换为子类具体实现版本的地址入口。因此图中Son的hardChoice方法并没有和父类指向同一处。 5、静态变量、方法的继承、重写、重载(非书本内容，自己测试过后添加) 首先看一段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class StaticClassFarther &#123; public static int a = 3; public static void tt()&#123; System.out.println(\"father 的 tt 方法\"); &#125;&#125;public class StaticClassSon extends StaticClassFarther &#123; public static int a = 4; //注释1 /*public void tt(int b)&#123; System.out.println(\"son 的 非静态 tt 重载方法\"); &#125;*/ public static void tt(int b)&#123; System.out.println(\"son 的 静态 tt 重载方法\"); &#125; //注释2 /*public void tt()&#123; System.out.println(\"son 的非静态 tt 方法\"); &#125;*/ public static void tt()&#123; System.out.println(\"son 的 tt 方法\"); &#125;&#125;public class StaticMainClass &#123; public static void main(String[] args) &#123; StaticClassFarther farther = new StaticClassFarther(); StaticClassFarther mix = new StaticClassSon(); StaticClassSon son = new StaticClassSon(); farther.tt(); System.out.println(\"farther 中a = \" + farther.a + \"\\n\"); mix.tt(); System.out.println(\"mix 中a = \" + mix.a + \"\\n\"); son.tt(); son.tt(4); System.out.println(\"son 中a = \" + son.a + \"\\n\"); System.out.println(\"StaticClassFarther.a = \" + StaticClassFarther.a); System.out.println(\"开始调用：StaticClassFarther.tt \"); StaticClassFarther.tt(); &#125;&#125; 其中注释1 是非静态重载，是可以编译通过的，但是注释2非静态重写是不行的，一定要静态重写。再看看输出结果： father 的 tt 方法farther 中a = 3 father 的 tt 方法mix 中a = 3 son 的 tt 方法son 的 静态 tt 重载方法son 中a = 4 StaticClassFarther.a = 3开始调用：StaticClassFarther.ttfather 的 tt 方法 从结果可以看出，子类重写并没有改变父类的值，通过 StaticClassFarther.tt 调用结果还是没变化。并且，具体实现已经是子类的情况下：StaticClassFarther mix = new StaticClassSon();输出的结果还是父类的(即输出以下内容)： father 的 tt 方法 和 mix 中a = 3 动态语言支持略，后续看到这里补上 基于栈的字节码解释执行引擎Java 语言经常被人们定位为“解释执行”的语言，在Java 1.0 时代，这定义还算准确，但当主流的虚拟机中都包含了即时编译器后，Class 文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机才知道的事情。再后来，Java也发展处了可以直接生成本地代码的编译，而C/C++也出现了通过解释器执行的版本，这时候再笼统地说“解释执行”，对于整个Java语言来说几乎没有意义。 基于栈的指令集与基于寄存器的指令集Java 编译器输出的指令，基本上是一种基于栈的指令集架构，它们依赖操作数栈进行工作；与之相对的另一套常用的指令集架构是基于寄存器的指令集。那么二者有何不同呢？举个简单的例子，分别使用两种指令集计算“1+1”，基于栈的指令集会是这个样子： iconst_1iconst_1iaddistore 0 两条icons_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后 istore_0把栈顶的值放到局部变量表的第0个Slot中。而如果基于寄存器，那程序可能就会是这样： mov eax, 1add eax, 1 mov 指令把EAX寄存器的值设为 1，然后add指令再把这个值加1，结果就保存在 EAX寄存器里面。了解了区别之后，那么这两套指令集哪一种更好？其实是各有所长，基于栈的指令集的主要优点是可移植，而基于寄存器的话，程序要直接依赖于这些硬件寄存器而不可便面地受到硬件的约束。栈架构指令集的主要缺点是执行速度相对来说会稍慢一些，完成相同功能所需要的指令一般会比寄存器的要多，因为出栈和入栈操作本身就产生了相当多的指令数量，更重要的是，栈实现在内存之中，频繁的栈访问也意味着频繁的内存访问，对处理器来说，内存始终是执行速度的瓶颈。 基于栈的解释器执行过程以示例讲述解释器执行过程， 略 本章小结6、7、8章，我们分析了 Java程序是如何存储的、如何载入（创建）的以及如何执行的问题，第9章将一起看看这些理论知识在具体开发中的经典应用。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"第7章: 虚拟机类加载机制","slug":"深入理解Java虚拟机-第7章","date":"2019-07-28T03:00:00.000Z","updated":"2019-11-17T13:49:31.664Z","comments":true,"path":"2019/07/28/深入理解Java虚拟机-第7章/","link":"","permalink":"https://glassx.gitee.io/2019/07/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC7%E7%AB%A0/","excerpt":"概述上一章了解了Class文件存储格式，在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能运行和使用，那么，虚拟机如何加载这些文件？虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。在Java语言中，类型的加载、连接和初始化都是在程序运行期间完成的，这令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性。","text":"概述上一章了解了Class文件存储格式，在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能运行和使用，那么，虚拟机如何加载这些文件？虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。在Java语言中，类型的加载、连接和初始化都是在程序运行期间完成的，这令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性。 例如，可以等到运行时再指定其实际的实现类：用户可以通过Java预定义和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或者其他地方加载一个二进制流作为程序代码的一部分。 类加载的时机类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期如下图所示： 总共有7个阶段，其中验证、准备、解析 这3个部分统称为连接(Linking)，并且加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载按照上述顺序按部就班地开始（不是“进行”，也不是“完成”，只是按部就班地“开始”，因为这些阶段通常都是相互交叉地混合式进行）。 虚拟机规范中严格规定了有且只有5种情况必须立即对类进行初始化（而加载、验证、准备自然需要在此之前开始）： 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。 这4条指令的最常见的Java代码中的场景是：使用new关键字实例化对象、读取或者设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）、以及调用一个类的静态方法。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则先触发其初始化。 当初始化一个类，如果发现其父类还没有进行过初始化，则需要先触发其父类初始化。 虚拟机启动时，虚拟机会先初始化用户指定的主类（包含main()方法的那个类） 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 以上5种场景中的行为称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用。以下举3个例子来说明何为被动引用。 1234567891011121314151617181920212223//被动使用类字段演示一：//通过子类引用父类的静态字段，不会导致子类初始化public class SuperClass&#123; static&#123; Systemt.out.printlin(\"SuperClass init!\"); &#125; public static int value = 123;&#125;public class SubClass extends SuperClass&#123; static&#123; Systemt.out.printlin(\"SubClass init!\"); &#125;&#125;//非主动使用类字段演示public class NotInitialization&#123; public static void main(String[] args)&#123; System.out.printlin(Subclass.value); &#125;&#125; 上述代码运行后，只会输出 “SuperClass init!” ，对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。 12345678//被动使用类字段演示二：//通过数组定义来引用类，不会触发此类的初始化public class NotInitialization&#123; public static void main(String[] args)&#123; SuperClass[] sca = new SuperClass[10]; &#125;&#125; 这里复用了上面的 SuperClass ，运行之后，发现没有输出 “SuperClass init!” ，说明没有触发 SuperClass 的初始化阶段。 12345678910111213141516//被动使用类字段演示二：//常量在便一阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化public class ConstClass&#123; static&#123; Systemt.out.printlin(\"ConstClass init!\"); &#125; public static final String HELLOWORLD = \"hello world\";&#125;public class NotInitialization&#123; public static void main(String[] args)&#123; Systemt.out.printlin(ConstClass. HELLOWORLD); &#125;&#125; 上述代码运行之后，也没有输出 “ConstClass init!” ，虽然在 Java 源码中引用了 ConstClass 中的常量 HELLOWORLD ，但其实在编译阶段通过常量传播优化，已经将此常量值 “hello world” 存储到了 NotInitialization 类的常量池中，以后 NotInitialization 对常量 ConstClass. HELLOWORLD 的引用时机都被转化为 NotInitialization 对自身常量池的引用了。也就是说，实际上 NotInitialization 的 Class 文件之中并没有 ConstClass 类的符号引用入口，这两个类在编译成 Class 之后就不存在任何联系了。 接口的加载过程与类加载过程稍有一些不同，接口与类真正有所区别的是前面讲述的5种“有且仅有”需要开始初始化场景中的第3种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。 顺带说明一下，上面的代码都是用静态语句块 “static{}”来输出初始化信息的，但接口中不能使用 “static{}”语句块。 类加载过程加载“加载”是“类加载(Class Loading)”过程的一部分，不要混淆。在加载阶段，虚拟机需要完成以下3件事情： 通过类的全限定名获取类的二进制字节流 将字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。 这3点规范并不算具体，例如第一条，并没有指明要从哪里获取，怎么获取，因此充满创造力的开发人员玩出了各种花样： 从 zip 包中读取，最终成为日后 jar、ear、war 格式的基础 从网络中获取，比如Applet 运行时计算生成，这种场景用得最多的就是动态代理技术。 验证验证是连接阶段的第一步，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击。从整体来看，验证阶段大致上会完成下面4个阶段的检验动作： 文件格式验证 魔数0xCAFEBABE开头、主次版本是否在虚拟机处理范围内等。 元数据验证 是否有父类-除Object外，所有类都有父类、父类是否继承了不允许被继承的类-final修饰，是否实现了父类或者接口要求实现的所有方法。 字节码验证 通过数据流和控制流分析，确定程序语义是否合法、符合逻辑的。如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。 符号引用验证 这个校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段发生。通常校验：通过全限定名是否能找到对应的类、符号引用中的类、字段、方法的访问性(private、protected、public、default)是否可以被当前类访问 等等。 准备准备阶段正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。 这里两个容易产生的混淆的概念强调一下：首先，这时候进行内存分配的仅仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时一起分配在java堆中。其次，这里说的初始值“通常情况”下是数据类型的零值，假设一个类变量定义为： public static int value = 123; 那变量value在准备阶段过后的初始值为 0 而不是 123。把value赋值为123的动作将在初始化阶段才会执行。 解析解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。 符号引用(Symbolic References)：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。 直接引用(Symbolic References)：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。 初始化到了初始化阶段，才真正开始执行类中定义的Java程序代码(或者说是字节码)。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序自定的主观计划去初始化类变量和其他资源。换一个角度来表达就是：初始化阶段是执行类构造器()方法的过程。以下介绍下()方法执行过程中一些可能会影响程序运行行为的特点和细节： ()方法由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。一个例子说明： 12345678910111213public class Test&#123; static int i =1; static&#123; Systemt.out.print(i);//正常使用 j = 0;//给变量赋值可以正常编译 Systemt.out.print(j);//这句提示“非法向前引用” &#125; static int j =1;&#125; ()方法与类的构造函数（实例构造器()）不同,它不需要显式地调用父类构造器，虚拟机会保证在子类的 () 执行之前，父类的()已经执行完毕。因此，在虚拟机中第一个被执行()方法的类肯定是 java.lang.Object。这其实也意味着，父类定义的静态语句块要优先于子类变量赋值操作。一个例子说明： 123456789101112131415static class Parent&#123; public static A = 1; static&#123; A = 2; &#125;&#125;static class Sub extentds Parent&#123; public static int B = A;&#125;public static void main(String args[])&#123; Systemt.out.println(Sub.B)&#125; 以上代码将打印出 2 而不是 1。 ()方法对于类或者接口不是必需的，如果类中没有静态语句块，也没有对变量的赋值，那么编译器可以不为这个类生成()方法。 接口中不能使用静态语句块，但是可以有变量初始化的赋值操作，因此接口与类一样都会生成 ()方法 。但接口的 ()方法 无须先执行父接口的()方法，只有父接口中定义的变量使用时，父接口才会初始化（接口的实现类在初始化时也不会执行接口的()方法）。 虚拟机会保证一个类的 ()方法 在多线程环境中会被正确地加锁、同步，所以，多线程同时去初始化一个类，那么只会有一个县城执行这个类的&lt;clinit&gt;()方法，其他的线程都会阻塞等待。举个例子： 12345678910111213141516171819202122232425262728static class DeadLoopClass&#123; static&#123; //如果不加上这个if语句，编译器将报错，并拒绝编译 if(true)&#123; System.out.println(Thread.currentThread() + \"init DeadLoopClass\"); while(true)&#123; &#125; &#125; &#125; public static void main(String[] args)&#123; Runnable script = new Runnable()&#123; public void run()&#123; Systemt.out.println(Thread.currentThread() + \"start\"); DeadLoopClass dlc = new DeadLoopClass(); Systemt.out.println(Thread.currentThread() + \"run over\"); &#125; &#125;; Thread thread1 = new Thread(script); Thread thread2 = new Thread(script); thread1.start(); thread2.start(); &#125;&#125; 上述代码在死循环以模拟长时间操作，另外一条线程在阻塞等待，将打印以下结果： Thread[Thread-0,5,main]startThread[Thread-1,5,main]startThread[Thread-0,5,main]init DeadLoopClass 类加载器虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。 类与类加载器对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗地说，比较两个类是否“相等”，只有在这两个类都是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，都被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 这里的“相等”，包括代表类的Class对象的 equals() 、isAssignableFrom()、isInstance() 方法返回的结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。以下代码演示了不同类加载器对instanceof关键字运算的结果的影响： 1234567891011121314151617181920212223242526public class ClassLoaderTest&#123; public static void main(String[] args) throws Exception&#123; ClassLoader myLoader = new ClassLoader()&#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException&#123; try&#123; String fileName = name.substring(name.lastIndexOf(\".\") + 1); InputStream is = getClass().getResourceAsStream(fileName); if(is == null)&#123; return super.loadClass(name); &#125; byte[] b = new byte[is.available()]; is.read(b); return defineClass(name,b,0,b.length); &#125;catch()&#123; throw new ClassNotFoundException(); &#125; &#125; &#125; Object obj = myLoader.loadClass(\"org.example.classloading. ClassLoaderTest\"); Systemt.out.println(obj.getClass()); System.out.println(obj instanceof org.example.classloading. ClassLoaderTest); &#125;&#125; 返回结果： class org.example.classloading. ClassLoaderTestfalse 从结果可以看出，对象确实是类 “org.example.classloading. ClassLoaderTest” 的类，并实例化了这个类的对象。但这个对象与类 org.example.classloading. ClassLoaderTest 做所属类型检查的时候却返回了false，这是因为虚拟机中存在了两个 ClassLoaderTest 类，一个由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来自同一个Class文件，但依然是两个独立的类。 双亲委派模型从java虚拟机角度来讲，只存在两种类加载器：一种是启动类加载器(Bootstrap ClassLoader)，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类 java.lang.ClassLoader。 如下图所示的类加载器之间的这种层次关系，称为双亲委派模型(Parent Delegation Model)。 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合(Composition)关系来复用父加载器的代码。 双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 双亲委派模型一个显而易见的好处就是：Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。 例如类 java.lang.Object ，无论哪一个类加载器都要加载这个类（因为所有的类都直接或间接地继承了它），最终都是委派给处于模型最顶端的启动类加载器进行加载，因此，Object 类在程序中的各种类加载器环境中都是同一个类。相反，如果不使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在 ClassPath 中，那系统中将将会出现多个不同的Object 类，Java类型体系中最基础的行为也就无法保证。 破坏双亲委派模型略","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"第6章: 类文件结构","slug":"深入理解Java虚拟机-第6章","date":"2019-07-27T06:56:00.000Z","updated":"2019-11-17T13:49:25.150Z","comments":true,"path":"2019/07/27/深入理解Java虚拟机-第6章/","link":"","permalink":"https://glassx.gitee.io/2019/07/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC6%E7%AB%A0/","excerpt":"概述计算机只认识0和1，但是最近10年虚拟机以及大量建立在虚拟上的语言的发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。无关性的基石Sun公司及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现程序的“一次编写，到处运行”。而各种不同平台的虚拟机以及平台无关的字节码（ByteCode）是构成平台无关性的基石。","text":"概述计算机只认识0和1，但是最近10年虚拟机以及大量建立在虚拟上的语言的发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。无关性的基石Sun公司及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现程序的“一次编写，到处运行”。而各种不同平台的虚拟机以及平台无关的字节码（ByteCode）是构成平台无关性的基石。 到目前为止，或许大部分程序员都还认为Java虚拟机执行Java程序是一件理所当然的事情，但在Java发展之初，Java的规范就分为Java语言规范以及Java虚拟机规范，时至今日，Java语言之外已经有一大批语言运行在Java虚拟机之上，如 Groovy、JRuby、Jython等。 Java 虚拟机不和包括Java在内的任何语言绑定，它只与“Class 文件”这种特定的二进制文件格式所关联，任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。 Class 类文件的结构Class 文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有任何分隔符。遇到需要占用8位字节以上空间的数据项时，会按照高位在前的方式分割成若干个8位字节进行存储。 Class 文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种结构只有两种数据类型： 无符号数和表。 无符号数属于基本的数据类型，以u1、u2、u4、u8分别代表1、2、4、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8 编码构成的字符串值。 表示由多个无符号数或者其他表作为数据项的复合数据类型，表用于描述有层次关系的复合结构的数据，整个Class文件本质就是一张表。 魔数与Class文件的版本Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。Class 文件的魔数值为 0xCAFEBABE (咖啡宝贝？)，很有浪漫气息。紧接着魔数的4个字节存储着Class文件的版本号，高版本的JDK能乡下兼容以前版本的Class文件，但不能运行以后版本的Class文件。 很多文件存储标准中都使用魔数来进行身份识别，如gif和jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来识别主要是基于安全考虑： 文件扩展可以随意改动。 常量池版本号之后是常量池入口，该区域可以理解为Class文件中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值。 常量池中主要存放两大类常量：字面量（Literal） 和 符号引用（Symbolic References）。字面量比较接近于Java语言层面的常量概念，如 文本字符串、声明为final的常量值等，而符号引用则属于编译原理方面的概念，包括了下面三类常量： 类和接口的全限定名(Fully Qualified Name) 字段的名称和描述符(Descriptor) 方法的名称和描述符 Java代码在javac编译的时候，并不像c和c++那样有“连接”这一步骤，而是在虚拟机加载 Class 文件的时候进行动态连接，也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息。虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时解析、翻译到具体的内存地址中。 访问标志常量池结束后，紧接着2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括： 这个Class 是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等等。 类索引、父类索引与接口索引集合类索引（this_class） 和父类索引(super_class)都是一个u2类型的数据，而接口索引集合(interfaces)是一组u2类型的数据的集合，class 文件中由这三项数据来确定这个类的继承关系。 其中，类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于Java不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此，父类索引都不为0。接口索引集合用来描述这个类实现了哪些接口，按照implement语句后的接口顺序从左到右排列在接口索引集合中。 字段表集合字段表(field_info)用于描述接口或者类中声明的变量，包括类级变量和实例级变量，不包括方法内的局部变量。这个描述可以包括的信息有： 字段的作用域(public、private、protected修饰符)、实例变量还是类变量(static修饰符)、可变性(final)、并发可见性(volatile 修饰符，是否强制从主内存读写)、可否被序列化(transient修饰符) 等等。 方法表集合Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，只是些微的区别，比如volatile关键字和transient关键字不能修饰方法 。 属性表集合在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息(这一块内容也没耐心看下去，下次看明白再补)。 字节码指令简介这章离App开发比较远，因此第一遍的时候先略过。 公有设计和私有实现理解公有设计与私有实现之间的分界线是非常有必要的，Java虚拟机实现必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。按照Java虚拟机规范一成不变地逐字实现其中要求的内容是一种可行的途径，但是一个优秀的虚拟机实现，在满足虚拟机规范的约束下对具体实现做出修改和优化也是完全可行的。虚拟机实现的方式主要有以下两种： 将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。 将输入的Java虚拟机代码在加载或执行翻译成宿主机CPU的本地指令集（即 JIT 代码生成技术） Class 文件结构的发展略。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"总结-新","slug":"总结-新","date":"2019-07-10T14:50:00.000Z","updated":"2020-07-25T09:35:42.569Z","comments":true,"path":"2019/07/10/总结-新/","link":"","permalink":"https://glassx.gitee.io/2019/07/10/%E6%80%BB%E7%BB%93-%E6%96%B0/","excerpt":"书籍笔记 开启多进程的方式，看这里 多进程缺陷(Application多次启动，静态成员失效，单例失效，sp的可靠性下降，断点调试会麻烦)，解决办法(判断主进程，aidl，断点调试先去掉多进程) Android中的IPC方式，总共7种(别漏了广播)，看这里 Activity 的启动模式，看这里 standard模式的Activity 默认会进入启动它的Activity所属的任务栈中，由于非Activity类型的Context 没有所谓的任务栈，所以会报错。解决这个问题的方法是为待启动的Activity指定 FLAG_ACTIVITY_NEW_TASK 标记 卡顿优化的步骤，各项指标过高代表啥(cpu、内存) ，看这里 Bitmap 内存分配的变化过程 看这里 如何做启动优化(预览窗口、闪屏、懒加载防止集中、业务优先级-第三方框架、线程管理-数量-线程池,启动过程勿出现io-负载高的时候，io性能下降很快、启动时只读很小的sp文件)，看这里 启动耗时的监控方式(录屏、线上监控-talkingdata) ppi、dpi 概念，看这里 软件绘制和硬件绘制的区别，硬件加速快的原理是啥，看这里 SurfaceFlinger 管理Graphic Buffer (比如三缓冲就有三个 buffer)，通过匿名共享内存与App应用层交互 ui优化手段(尽量硬件加速、view创建优化-不用xml-提前-异步-重用、measure与layout优化-ui层次-constranLayout-无用背景)，看这里 网络优化之网络请求过程是啥，网络怎么监控？ 看这里 SELinux 进一步定义沙盒边界，即使应用进程有root权限也不能为所欲为(还得在安全策略配置文件中赋予权限) sp的缺点(跨进程不安全、加载慢-让主线程等待、全量写入-mommit和apply都这样、卡顿-onPause强制把sp写入磁盘、json复杂格式会有转义开销)，可以使用mmkv 代替，看这里 ContentProvider 的onCreate 在 Application 的 attachBaseContext 之后，在Application 的onCreate 之前，并且还是在主线程，因此在provider的构造函数、静态代码块、onCreate中不要耗时操作 ContentProvider 跨进程传递的原理：利用 Android 的 Binder 和 匿名共享内存机制。即通过Binder 传递 CursorWindow 对象内部的匿名共享内存的文件描述符，看这里 Serializable 的原理，效率低的原因，反序列的时候会执行构造函数吗？，看这里 Parcelable 可以永久存储吗？原理是啥？，看这里 Android 事件分发，看这里 让一个View 滑动起来，有几种方法？ 看这里 init 进程做了哪些事情？ 看这里 Zygote 进程做了哪些事情？(创建了虚拟机，创建systemServer进程、fork应用程序、创建server类型的socket) SystemServer 的主要作用？ (创建系统服务AMS、WMS、PMS) Android 系统启动流程， 看这里 Zogote 进程 fork 自身创建应用进程的时候，会为应用进程创建Binder线程池和消息循环，会通过检查，确保Binder 进程只启动一次， 看这里 应用进程创建完毕，通过反射调用 ActivityThread 的main方法，在main方法里面prepareMainLooper、创建了 ActivityThread 对象，再从这个ActivityThread 对象中获取 handler 作为成员变量保存，之后再loop，不允许退出 Instrumentation 主要用于监控应用程序和系统的交互 AMS 与 应用进程通信时，是与 ApplicationThread 打交道的，而不是直接与 ActivityThread ，ApplicationThread 是 ActivityThread 的内部类 点击桌面图标，App的启动过程，看这里 获取 Application Context时，首先从 LoadApk 类型的 mPackageinfo 中获取，如果为null ，则从 ActivityThread 类型的 mMainThread 中获取 Dalvik 与 ART 的区别，art 有dalvik 堆空间划分区别？看这里 热修复原理之Instant Run，自己创建一个AssetManager ，反射调用其addAssetPath 加载外部的resource。反射每个Activity 的AssetManager字段 mAsset，并将 mAsset 的值改成新建的 AssetManager即可。看这里 linux中常见的进程间通信有哪些？ （管道、信号、socket、消息队列-Message、共享内存等） 看这里 描述下 Binder 的工作流程，为什么是一次复制 mmap(memory map，内存映射)将某个设备或者文件映射到应用进程的内存空间，这样，访问这块内存就相当于对设备/文件进行读写。这种基于内存共享的方式如果用于进程间通信，则需要注意实现同步，因为这个过程并没有同步机制，而Binder中是 c/s 模式，因此不存在同步问题 Ashmem(Anony Shared Memory，匿名共享内存)的原理也是将指定的物理内存分别映射到各个进程的地址空间，从而实现内存共享。Ashmem 也是一个 misc 设备，看这里 主线程的 prepareMainLooper 和 普通线程的 prepare 方法的区别是啥？ 看这里 飞快拉动进度条或者音量SeekBar，如何保证界面流畅又要听到实时声音？ 看这里 ActivityThread 启动并做好相应的初始化工作后，需要调用 attachApplication 来通知 AMS ，后者才能继续执行未完成的 startActivity 流程,看这里 系统对 Parcel 是有缓存的，系统预先产生一个大小为6的parcel 池，所以我们可以通过 Parcel.obtain() 方法获取一个 Parcel 对象，如果还有现成Parcel 对象，则直接使用，否则new一个。并且，Parcel存储数据时，会提供数据当前位置dataPosition，类似游标，每当存储新数据时，从这个位置接着往后存，空间不够再申请 看这里 binder 主要提供open、mmap、ioctl 三个接口，接口的作用是啥？ 看这里 用户申请binder 服务的流程（A、B进程间数据传递），： open-&gt;mmap-&gt;ioctl，应用程序申请binder 的空间大小？ 看这里 Binder 的优点：性能、稳定、安全、使用简单， 看这里 Java 内存区域划分及可能存在的异常，啥是直接内存？ 啥叫运行时常量池，这个常量池在哪？ 看这里 如何产生各种异常，oom，stackoverflow ？ 看这里 哪些对象可以做 GCRoot ？ 谈谈引用？ 不可达非死不可吗，流程咋样？ 看这里 垃圾收集算法，并发收集的缺点？ 内存分配策略？ 看这里 类加载过程如何？ 各个过程做啥？ 类啥时候会初始化？特殊情形-获取父类静态值、作为数组类型-static final 字符串入常量池了、看这里 虚拟机执行非静态方法时，通过局部变量表完成参数值到参数变量列表的传递，第0位索引默认用于传递方法所属实例，这样，在方法中可以使用this 关键字来访问这个实例了，看这里 在有继承关系存在的情况下，虚拟机如何做到 方法调用分派？ 根据各个类的虚方法表中方法的指向， 看这里 静态变量和静态方法的重写，只跟声明的类型有关， 看这里 volatile 禁止指令重排的原理？ (赋值后lock,相当于store 和 write操作) ，volatile、synchronize、final 都能保证可见性 ，volatile、synchronize、锁 可以保证有序性 看这里 线程状态转换？ 看这里 实现线程安全的方法？(互斥同步、非阻塞同步-CAS操作、无同步-无共享) synchronized 关键字原理？ 看这里 锁优化方式？(自旋、消除、粗化、轻量级、偏向) ，看这里 为什么不是总选择tcp，而要在有时候udp呢？ udp 首部应该包括什么呢？ 看这里 快重传、流量控制、拥塞控制 分别是啥？拥塞控制 的确定？ 拥塞控制的算法？-慢启动、拥塞避免、快速恢复 ，看这里 ssl握手流程？ 看这里 TCP的时延有哪些？(握手、慢启动的拥塞控制、捎带确认)，http性能提升手段？(并行连接-发起多条tcp连接、持久连接、管道化发送-同一条tcp连接连续发送多条，无需等回复)， 看这里 签名是加了密的校验和。看这里 死锁条件？(互斥条件、不可剥夺、保持等待、环路等待)，看这里 第一次启动Service 会执行 onCreate，多次启动则 onStartCommand 多次启动 ，看这里 debug 包获取cookies： adb shell ，run-as ，再cd 到目录即可， 看这里 Toast显示流程 看这里","text":"书籍笔记 开启多进程的方式，看这里 多进程缺陷(Application多次启动，静态成员失效，单例失效，sp的可靠性下降，断点调试会麻烦)，解决办法(判断主进程，aidl，断点调试先去掉多进程) Android中的IPC方式，总共7种(别漏了广播)，看这里 Activity 的启动模式，看这里 standard模式的Activity 默认会进入启动它的Activity所属的任务栈中，由于非Activity类型的Context 没有所谓的任务栈，所以会报错。解决这个问题的方法是为待启动的Activity指定 FLAG_ACTIVITY_NEW_TASK 标记 卡顿优化的步骤，各项指标过高代表啥(cpu、内存) ，看这里 Bitmap 内存分配的变化过程 看这里 如何做启动优化(预览窗口、闪屏、懒加载防止集中、业务优先级-第三方框架、线程管理-数量-线程池,启动过程勿出现io-负载高的时候，io性能下降很快、启动时只读很小的sp文件)，看这里 启动耗时的监控方式(录屏、线上监控-talkingdata) ppi、dpi 概念，看这里 软件绘制和硬件绘制的区别，硬件加速快的原理是啥，看这里 SurfaceFlinger 管理Graphic Buffer (比如三缓冲就有三个 buffer)，通过匿名共享内存与App应用层交互 ui优化手段(尽量硬件加速、view创建优化-不用xml-提前-异步-重用、measure与layout优化-ui层次-constranLayout-无用背景)，看这里 网络优化之网络请求过程是啥，网络怎么监控？ 看这里 SELinux 进一步定义沙盒边界，即使应用进程有root权限也不能为所欲为(还得在安全策略配置文件中赋予权限) sp的缺点(跨进程不安全、加载慢-让主线程等待、全量写入-mommit和apply都这样、卡顿-onPause强制把sp写入磁盘、json复杂格式会有转义开销)，可以使用mmkv 代替，看这里 ContentProvider 的onCreate 在 Application 的 attachBaseContext 之后，在Application 的onCreate 之前，并且还是在主线程，因此在provider的构造函数、静态代码块、onCreate中不要耗时操作 ContentProvider 跨进程传递的原理：利用 Android 的 Binder 和 匿名共享内存机制。即通过Binder 传递 CursorWindow 对象内部的匿名共享内存的文件描述符，看这里 Serializable 的原理，效率低的原因，反序列的时候会执行构造函数吗？，看这里 Parcelable 可以永久存储吗？原理是啥？，看这里 Android 事件分发，看这里 让一个View 滑动起来，有几种方法？ 看这里 init 进程做了哪些事情？ 看这里 Zygote 进程做了哪些事情？(创建了虚拟机，创建systemServer进程、fork应用程序、创建server类型的socket) SystemServer 的主要作用？ (创建系统服务AMS、WMS、PMS) Android 系统启动流程， 看这里 Zogote 进程 fork 自身创建应用进程的时候，会为应用进程创建Binder线程池和消息循环，会通过检查，确保Binder 进程只启动一次， 看这里 应用进程创建完毕，通过反射调用 ActivityThread 的main方法，在main方法里面prepareMainLooper、创建了 ActivityThread 对象，再从这个ActivityThread 对象中获取 handler 作为成员变量保存，之后再loop，不允许退出 Instrumentation 主要用于监控应用程序和系统的交互 AMS 与 应用进程通信时，是与 ApplicationThread 打交道的，而不是直接与 ActivityThread ，ApplicationThread 是 ActivityThread 的内部类 点击桌面图标，App的启动过程，看这里 获取 Application Context时，首先从 LoadApk 类型的 mPackageinfo 中获取，如果为null ，则从 ActivityThread 类型的 mMainThread 中获取 Dalvik 与 ART 的区别，art 有dalvik 堆空间划分区别？看这里 热修复原理之Instant Run，自己创建一个AssetManager ，反射调用其addAssetPath 加载外部的resource。反射每个Activity 的AssetManager字段 mAsset，并将 mAsset 的值改成新建的 AssetManager即可。看这里 linux中常见的进程间通信有哪些？ （管道、信号、socket、消息队列-Message、共享内存等） 看这里 描述下 Binder 的工作流程，为什么是一次复制 mmap(memory map，内存映射)将某个设备或者文件映射到应用进程的内存空间，这样，访问这块内存就相当于对设备/文件进行读写。这种基于内存共享的方式如果用于进程间通信，则需要注意实现同步，因为这个过程并没有同步机制，而Binder中是 c/s 模式，因此不存在同步问题 Ashmem(Anony Shared Memory，匿名共享内存)的原理也是将指定的物理内存分别映射到各个进程的地址空间，从而实现内存共享。Ashmem 也是一个 misc 设备，看这里 主线程的 prepareMainLooper 和 普通线程的 prepare 方法的区别是啥？ 看这里 飞快拉动进度条或者音量SeekBar，如何保证界面流畅又要听到实时声音？ 看这里 ActivityThread 启动并做好相应的初始化工作后，需要调用 attachApplication 来通知 AMS ，后者才能继续执行未完成的 startActivity 流程,看这里 系统对 Parcel 是有缓存的，系统预先产生一个大小为6的parcel 池，所以我们可以通过 Parcel.obtain() 方法获取一个 Parcel 对象，如果还有现成Parcel 对象，则直接使用，否则new一个。并且，Parcel存储数据时，会提供数据当前位置dataPosition，类似游标，每当存储新数据时，从这个位置接着往后存，空间不够再申请 看这里 binder 主要提供open、mmap、ioctl 三个接口，接口的作用是啥？ 看这里 用户申请binder 服务的流程（A、B进程间数据传递），： open-&gt;mmap-&gt;ioctl，应用程序申请binder 的空间大小？ 看这里 Binder 的优点：性能、稳定、安全、使用简单， 看这里 Java 内存区域划分及可能存在的异常，啥是直接内存？ 啥叫运行时常量池，这个常量池在哪？ 看这里 如何产生各种异常，oom，stackoverflow ？ 看这里 哪些对象可以做 GCRoot ？ 谈谈引用？ 不可达非死不可吗，流程咋样？ 看这里 垃圾收集算法，并发收集的缺点？ 内存分配策略？ 看这里 类加载过程如何？ 各个过程做啥？ 类啥时候会初始化？特殊情形-获取父类静态值、作为数组类型-static final 字符串入常量池了、看这里 虚拟机执行非静态方法时，通过局部变量表完成参数值到参数变量列表的传递，第0位索引默认用于传递方法所属实例，这样，在方法中可以使用this 关键字来访问这个实例了，看这里 在有继承关系存在的情况下，虚拟机如何做到 方法调用分派？ 根据各个类的虚方法表中方法的指向， 看这里 静态变量和静态方法的重写，只跟声明的类型有关， 看这里 volatile 禁止指令重排的原理？ (赋值后lock,相当于store 和 write操作) ，volatile、synchronize、final 都能保证可见性 ，volatile、synchronize、锁 可以保证有序性 看这里 线程状态转换？ 看这里 实现线程安全的方法？(互斥同步、非阻塞同步-CAS操作、无同步-无共享) synchronized 关键字原理？ 看这里 锁优化方式？(自旋、消除、粗化、轻量级、偏向) ，看这里 为什么不是总选择tcp，而要在有时候udp呢？ udp 首部应该包括什么呢？ 看这里 快重传、流量控制、拥塞控制 分别是啥？拥塞控制 的确定？ 拥塞控制的算法？-慢启动、拥塞避免、快速恢复 ，看这里 ssl握手流程？ 看这里 TCP的时延有哪些？(握手、慢启动的拥塞控制、捎带确认)，http性能提升手段？(并行连接-发起多条tcp连接、持久连接、管道化发送-同一条tcp连接连续发送多条，无需等回复)， 看这里 签名是加了密的校验和。看这里 死锁条件？(互斥条件、不可剥夺、保持等待、环路等待)，看这里 第一次启动Service 会执行 onCreate，多次启动则 onStartCommand 多次启动 ，看这里 debug 包获取cookies： adb shell ，run-as ，再cd 到目录即可， 看这里 Toast显示流程 看这里 Android开发高手课 Android 的bitmap 内存分配随着 Android 版本的变化过程？NativeAllocationRegistry? 看这里 卡顿考虑cpu，怎么看？ 用户时间过多或者 系统调用时间过多？ 看这里 启动优化方式？(闪屏-当做view浮、业务优先级梳理、线程优化-线程池控制总量)，监控指标？ ，看这里 ppi、dpi、density？ dp * density = px ，软件绘制/硬件绘制流程 ，硬件绘制为啥快， surface 与window 关系，看这里 ui优化方式？(硬件加速、view创建-不用xml-提前创建/异步创建-重用、measure/layout优化-减少层次-constranlayout-背景优化) ，看这里 完整的网络请求？ 看这里 sp 缺点？替代方式？ContentProvider注意事项？ 看这里 Serializable 的原理？Parcelable 的永久存储？ 看这里 高级进阶课全部链接 如何停止线程？为什么stop和suspend会有问题？ ThreadLocal 使用建议 禁止指令重排的方法？可见性方法？保证原子性方法？ HashTable问题？ConcurrentHashMap？ ConcurrentHashMap的解决方案？所以，如何进行锁优化？ Rxjava 存在的问题？ cpu 架构适配优化方案？？ Activity 是通过反射创建出来的，所以不要去写它的构造函数。同理，Fragment 也不要去写，因为恢复Fragment的时候，也是反射的，这也是为什么我们推荐使用argument 传递参数的原因 在 resume 回调之后，才调用 makeVisible 将 DecorView 展示出来(layout,draw)，所以在resume之前我们是无法准确获得view的高度的 如何启动外部应用的Activity？ (uid、exported-且全路径，action和category)，为了避免别的应用乱启动 exported 的Acivity，可以给Activity 添加权限，没有在Manifest中声明就启动不了 别人如何攻击暴露的Activity产生异常？ 如何在任意位置为当前Activity 添加View ？ 为什么不能在非主线程更新ui？一定不能吗？ ANR 怎么产生的，Looper 为什么不会cpu占用过高？ 内存越大越好吗？不，导致gc时间长，避免oom？bitmap选择合适分辨率，不要使用帧动画，bitmap重采样，Native Heap 优雅避免堆限制 谨慎多进程？新进程会有一些公共资源，也是会消耗内存的 如何对图片进行缓存？ 如何计算图片大小？ 图片体积优化？ 图片格式无关跟argb_8888或者565有关、裁剪合适尺寸、采样、矩阵变换来放大图片、.9 如何开展优化工作？ 目标-找原因-优化 如何设计短视频？视频处理、来源、分享、打赏、社交、聊天、耗电问题、防止视频泄露、防止广告劫持 如何设计网络框架？ http和websocket、异步、可移植性、缓存策略、拦截器、日志、重试机制-重试多少次-间隔、结果组装 题目 mvc、mvp、mvvm 设计模式区别？ mvc中view可以直接改数据 看这里 Android中内存分配的执行流程？ Android GC 过程？ 看这里 三次握手？为毛3次能2次吗？ 序列号为什么随机？握手会有什么安全问题？三次握手可以携带数据吗？ 看这里 TCP与udp 区别 ？ 不用维护连接， 看这里 啥是中间人攻击？ http1与http2的区别？ 看这里 RxJava 线程切换原理？看这里 为什么使用fresco？ThreadLocal 原理？LocalBroadcastManager 原理？看这里 ThreadPoolExecutor 原理？线程池异常处理？AsyncTask 源码解析？ 看这里 Synchronized 与 Lock 的区别？ 看这里 wait、notify、notifyAll 方法在object 类中，而sleep 在Thread 类中? notify/wait 方法为什么一定要放在同步块中？ 看这里 synchronized原理？单例中，volatile 的作用？如何停止一个线程 ？ 看这里 写个死锁程序？ 看这里 synchronized 锁持有的object 是Thread 对象的情况?同理，Java 中的 join原理？ 看这里 集合-ArrayList、LinkedList、HashMap、HashTable、ConcurrentHashMap、LinkedHashMap、WeakHashMap、TreeMap 看这里 泛型信息不会进入到运行时阶段，由于系统中并不会真正生成泛型类，因此，instanceof运算符后不能使用泛型类 抽象类和接口的区别，看这里 transient 关键字， 看这里 Java 的finally 与 return 的执行顺序 ？system.exit(0)、正常情况return语句先返回，但没有真正返回值，等finally执行完后真正返回、finally中有return则会覆盖try中的return、finally没有return，则看情况，如果是简单类型，则在finally中改没关系，如果是复杂类型，改了就会影响最终值 看这里 Java 中HashCode 与 equals 方法理解，HashCode 生成注意事项？同一个对象多次调用hashcode都是一致的、两个对象相等，则hashcode要相等、两个对象不相等，尽量hashcode不相等，避免Hashmap等冲突、int型防止溢出 看这里 类的初始化步骤是啥？ 看这里 String、StringBuilder、StringBuffer、CharSequence 区别？本质都是通过字符数组实现的，StringBuilder 和StringBuffer 初始空间都是16，如果超过，就申请新的空间，并把老数组赋值过去。 看这里 String 为毛设计成不可变？字符串常量需要、String的HashCode被频繁使用，会缓存HashCode、为了安全：用在url之类的场合。 一定不可变吗？ 看这里 成员内部类、静态内部类、局部内部类和匿名内部类的理解。内部类的优势：方便组织类关系、完善的Java的多继承机制、方便实现事件驱动程序(如点击事件)看这里 是否可以在子线程更新UI？首先settext了，然后执行ViewGroup的invalidateChild，最后在ViewRootImpl中检测线程，而在onCreate中，由于attachInfo 还是空的，所以走不到ViewRootImpl，走不了检查线程，所以可以设置。 可以参考这里、以及这里 LruCache原理。看这里 Handler 机制？如何保证一个线程一个Looper？postDelay 怎么实现？ nativePollOnce 和 nativeWake 分别来阻塞和唤起线程。 Android 的消息屏障？Handler三种消息：同步消息、异步消息、消息屏障。 通过MessageQueue.postSyncBarrier 来发送屏障，消息屏障就是没有target字段的Message，需要手动移除，屏障在就会执行查询异步消息，知道移除屏障。 IdelHandler？ 看这里 RecyclerView 的优化方式？ 如何保存嵌套 RecyclerView 的滑动装填？ 看这里 Activity 生命周期几种普通情况。 看这里 谈谈对Application 的理解？即有啥特性、有什么坑？ 看这里 Binder 理解？ 为什么要使用Binder 机制进程间通信？-五个维度 看这里 Android 为什么用Bundle 而不是使用HashMap 来传递数据？ 看这里 SharedPreference 的理解 ？ 看这里 常见内存泄漏场景 ？如何监测？LeakCanary 的原理是啥？ 看这里 APK 安装步骤。 看这里 ListView 原理？ 看这里 Android 5.0, 6.0, 7.0, 8.0新特性 ？ 看这里 UI卡顿之BlockCanary？ 看这里 Android 中大图加载 ？如果不需要展示，则BitmapFactory.option设置inJustDecodeBounds即可、图片非常多，可以使用LruCache、 看这里 彻底理解android 应用无响应机制？看这里 理解Android签名？看这里 为什么 epoll 快？ 看这里 BroadCastReceiver 怎么执行耗时操作(异步)？ 看这里 他山之石 HashMap 为毛链表转成红黑树？红黑树特点？ 看这里 一个无序，实际上是逆序的数组排序用什么算法好？ 看这里-参考别人的博客 Android heap 的结构？主要用来分配对象的堆空间 Zygote Space 和 Allocation Space 的底层都是匿名共享内存，使用C库的 malloc 和 free 来进行管理，通过 dlmalloc 技术来尽量解决碎片问题。 看这里 多个Fragment 销毁后重建之后重叠？ 看这里 Bitmap 能否复用？怎么复用？ 看这里 TreeMap 如何对两个元素比较？HashMap 转红黑树的时候，怎么比较？ 非compareble对象如何比较？ 看这里 object 有哪些方法？ 看这里 Android系统中存在的代理模式？理解动态代理和静态代理？ 看这里 SharedPreference 是线程/进程 安全的吗？apply和commit 有什么区别(提交到哪？内存还是本地xml)？有什么坑？看这里 Handler 中我想指定某个消息先执行，可以吗？ 看这里 http与http2的区别？http与https区别？https怎么做到安全的？ 看这里 java中this编译时的原理？构造方法(对，构造方法也是)、实例方法第一个参数就是this，它的类型为Base，这是编译器自动添加的。 可以看别人的博客了解 Android 自定义控件方式？——————— fresco加载图片原理？ 优势是什么？ ashmem 减少gc，webp 事件分发 cancel事件一般在什么时候被触发？ 某个子View处理了Down事件之后，那么接下来的 Move 和 Up 事件也会交给他处理，但在交给他处理前，父view还是可以拦截事件的，如果拦截了事件，子View就会收到一个Cancel事件，并且不会收到后续的Move 和Up事件。 看这里 onSaveInstanceState 调用时机。onSaveInstanceState是Activity的生命周期方法，主要用于在Activity 销毁时保存信息，Activity 只执行opause时(打开的另一个Activity透明)，在 Android 3.0 及以上不会执行 onSaveInstanceState，以下就会执行。当Activity 执行 onStop 时，就都会执行 onSaveInstanceState。 看这里 Fragment View区别？ Fragment复用粒度更大、从代码设计上Fragment可以提高代码内聚、Fragment完整的生命周期、Fragment更复杂，消耗资源大。看这里 notifyAll方法唤醒的线程，怎么决定哪一个线程得到运行? handler的sendMessage方法和postRunable方法区别? 针对xx的问题统一的链接看这里 聊聊kotlin的协程？优缺点？适用场景？kotlin 如何实现空安全？ MeasureSpec 的理解？ 如何处理手势冲突？内部法和外部法 如何优化App的性能？具体指标变化如何？ ArrayMap 与 SparseArray 的原理？ 三次握手和四次挥手？ 锁的种类？ HandlerThread?run的时候prepare() 了，退出的时候需要执行 handlerThread.quit() 以便退出loop IntentService 原理？多次调用Service 会咋样？为毛 onHandleIntent 之后，执行的是 stopSelf(int) ？ 什么是大接口？为毛要用大接口？如何实现？ 怎样防止劫持？ 聊聊内部sdk的设计？有什么收获？ 最有成就感的？最棘手的？ 为了安全，做了哪些努力？ apk签名校验、https证书校验、本地广播、sp加密 平时逛论坛？关注的技术？ 如何做的证书校验？ 看这里Android基础 如何移除Handler的Message？有啥坑吗？ 看这里Android基础 如何性能优化？lint无用资源、Application减轻负担(主进程，小sp，框架减少人为)、ui绘制优化(硬件加速、view创建优化-代码创建-提前-异步-View重用、measure/layout-布局层次-ConstranLayout减少layout开销-去除无用背景-shapelayout代替xml的shape)、启动优化（flash页面、减少cpu集中）、内存(泄漏、容器避免自动装箱、正确使用引用)、cpu(解析放在子线程、sp存储json、避开高峰-IdelHandler、线程管理-数量-线程池,启动过程勿出现io-负载高的时候，io性能下降很快)、网络优化(dns加速)、结构(mvp)、尽量不要有io操作 看这里、以及Android开发高手课 ANR 定位？tcp与udp 基本排序插入排序：O(n^2)复杂度，稳定的排序选择排序： 复杂度总是 O(n^2)，每次挑最大最小的，因此不稳定 shell 排序： 最差的时候：O(n^2) 平均复杂度 ： nlogn，不稳定冒泡：有序的情况，一趟完成，OO(n)，平均复杂度O(n^2)，稳定的排序快排序： 分治思想，平均 nlogn ，最坏 O(n^2)，交换数据啊，不稳定堆排序：最坏最好和平均都是 nlogn ，不稳定归并排序： 分治思想，时间复杂度 nlogn ，稳定，主要用于外部排序 归并和快排的平均时间复杂度差不多，但是比快排最差情况要好。但是归并使用的空间比较多，因此一般情况下选择快排 不稳定的排序：希尔、堆、快排 初始化顺序？","categories":[{"name":"阶段","slug":"阶段","permalink":"https://glassx.gitee.io/categories/%E9%98%B6%E6%AE%B5/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://glassx.gitee.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"第3章：View体系与自定义View《一》","slug":"Android进阶之光-第3章","date":"2019-07-06T13:00:00.000Z","updated":"2019-11-18T12:55:29.953Z","comments":true,"path":"2019/07/06/Android进阶之光-第3章/","link":"","permalink":"https://glassx.gitee.io/2019/07/06/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89-%E7%AC%AC3%E7%AB%A0/","excerpt":"坐标系Android 系统中有两种坐标系：Android 坐标系和 View 坐标系，了解这两种坐标系能够帮助我们实现View的各种操作。Android坐标系Android坐标系中， 将屏幕左上角的顶点作为原点， 这个原点向右是X轴正方向， 向下是Y轴正方向， 如下图所示。View坐标系View坐标系与Android坐标系并不冲突，两者是共同存在的，一起来帮助开发者更好地控制View。对于View坐标系，搞明白下图的信息即可：","text":"坐标系Android 系统中有两种坐标系：Android 坐标系和 View 坐标系，了解这两种坐标系能够帮助我们实现View的各种操作。Android坐标系Android坐标系中， 将屏幕左上角的顶点作为原点， 这个原点向右是X轴正方向， 向下是Y轴正方向， 如下图所示。View坐标系View坐标系与Android坐标系并不冲突，两者是共同存在的，一起来帮助开发者更好地控制View。对于View坐标系，搞明白下图的信息即可： MotionEvent提供的方法：假设上图中间的那个圆点就是我们触摸点，无论是View还是ViewGroup，最终的点击事件都会由onTouchEvent(MotionEvent event)方法来处理。MotionEvent提供了获取焦点坐标的各种方法： getX()：获取点击事件距离控件左边的距离，即视图坐标。 getY()：获取点击事件距离控件顶边的距离，即视图坐标。 getRawX()：获取点击事件距离整个屏幕左边的距离，即绝对坐标。 getRawY()：获取点击事件距离整个屏幕顶边的距离，即绝对坐标。 View的滑动View的滑动基本思想：当点击事件传到View时，系统记下触摸点的坐标，手指移动时系统记下移动后触摸的坐标并算出偏移量，并通过偏移量来修改View的坐标。 实现View滑动有很多种方法， 在这里主要讲解6种滑动方法， 分别是layout()、offsetLeftAndRight() 与 offsetTopAndBottom()、LayoutParams、动画、scollTo 与 scollBy ，以及Scroller。 layout方法View进行绘制的时候会调用onLayout()方法来设置显示的位置， 因此我们同样也可以通过修改View的left、 top、 right、 bottom属性来控制View的坐标。以下是实现一个随手指滑动的自定义view的步骤： 首先获取触摸点的坐标 123456789101112public boolean onTouchEvent(MotionEvent event)&#123; //获取手指触摸点的横坐标和纵坐标 int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: lastX = x; lastY = y; break; &#125;&#125; 在ACTION_MOVE事件中计算偏移量,再调用layout（ ） 方法重新放置这个自定义View的位置即可: 123456789case MotionEvent.ACTION_MOVE: //计算移动距离 int offsetX = x - lastX; int offsetY = y - lastY; //调用layout方法来重新确定它的位置 layout(getLeft() + offsetX,getTop()+offsetY, getRight()+offsetX,getBottom()+offsetY) break 在每次移动时都会触发layout()方法对屏幕重新布局，从而达到移动View的效果。 offsetLeftAndRight() 与offsetTopAndBottom()这两种方法和layout()方法的效果以及使用方式都差不多，只需要将上面ACTION_MOVE中的代码替换为以下代码即可： 123456789case MotionEvent.ACTION_MOVE: //计算移动距离 int offsetX = x - lastX; int offsetY = y - lastY; //对left 及 right 进行偏移 offsetLeftAndRight(offsetX); //对top及bottom进行偏移 offsetTopAndBottom(offsetY); break; LayoutParams（ 改变布局参数）LayoutParams主要保存了View的布局参数， 因此可以通过改变它来达到改变View位置的效果。 我们只需将 ACTION_MOVE 中的代码替换成如下代码即可(注意是：MarginLayoutParams)： 12345678910case MotionEvent.ACTION_MOVE: //计算移动距离 int offsetX = x - lastX; int offsetY = y - lastY; ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams)getLayoutParams(); params.leftMargin = getLeft() + offsetX; params.topMargin = getTop() + offsetY; setLayoutParams(params) break; 动画采用动画来移动，在res目录新建anim文件夹并创建如下translate.xml文件: 1234567&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:fillAfter=\"true\"&gt; &lt;translate android:duration=\"1000\" android:fromXDelta=\"0\" android:toXDelta=\"300\"/&gt;&lt;/set&gt; 在Java中调用： view.setAnimation(AnimationUtils.loadAnimation(this,R.anim.translate)) 需要注意的是，如果动画文件中没有添加 android:fillAfter=”true” ，则方块向右平移300像素后，又返回原来的位置。并且，View动画不能改变View的位置参数，如果对一个Button加上如上的平移动画，当Button平移300像素停留在当前位置时，我们点击这个Button并不会触发点击事件，但是点击原始位置却触发了点击事件，这是因为对于系统来说，Button并没有改变原来位置。 在Android 3.0出现的属性动画解决了上述问题，它不仅可以执行动画，还能改变View的位置参数，其操作如下： ObjectAnimator.ofFloat(view,”translationX”，0，300).setDuration(1000).start() scrollTo 与 scrollByscollTo、scollBy移动的是View的内容，如果在ViewGroup中使用， 则是移动其所有的子View。scrollTo(x，y)表示移动到一个具体的坐标点，而scrollBy(dx，dy)则表示移动的增量为dx、dy。 其中， scollBy最终也是要调用scollTo的。二者的源码如下： 123456789101112131415161718public void scrollTo(int x,int y)&#123; if(mScrollX != x || mScrollY != y)&#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if(!awakenScrollBars())&#123; postInvalidateOnAnimation(); &#125; &#125;&#125;public void scrollBy(int x,int y)&#123; scrollTo(mScrollX + x, mScrollY + y)&#125; 如果要实现上面view随手指滑动的效果，就需要将ACTION_MOVE中的代码替换成如下代码： ((View)getParent()).scrollBy(-offsetX,-offsetY); 请注意，这里是对view的parent进行scroll，这是因为如果对view本身scroll的话，就是对自己的内容进行移动，而不是整个view。并且注意，这里设置的偏移量值都为负值，以下具体讲解一下。 假设我们正用放大镜来看报纸，放大镜用来显示字的内容。同样我们可以把放大镜看作我们的手机屏幕，它们都是负责显示内容的；而报纸则可以被看作屏幕下的画布，它们都是用来提供内容的。放大镜外的内容，也就是报纸的内容不会随着放大镜的移动而消失，它一直存在。同样，我们的手机屏幕看不到的视图并不代表其不存在。过程的示意图如下： scrollBy之前： 调用scrollBy(50,50)之后： Scroller我们在用scollTo/scollBy方法进行滑动时，这个过程是瞬间完成的，所以用户体验不大好。这里我们可以使用 Scroller 来实现有过渡效果的滑动，这个过程不是瞬间完成的，而是在一定的时间间隔内完成的。Scroller本身是不能实现View的滑动的，它需要与View的computeScroll() 方法配合才能实现弹性滑动的效果。具体代码如下示意： 12345678910111213141516171819202122232425262728public CustomView(Context context,AttributeSet attrs)&#123; private Scroller mScroller; super(context,attrs); //初始化mScroller mScroller = new Scroller(conetxt); @Override public void computeScroll()&#123; super.computeScroll(); if(mScroller.computeScrollOffset())&#123; ((View)getParent()).scrollTo(mScroller.getCurrentX(),mScroller.getCurrentY()); invalidate(); &#125; &#125; //提供调用的方法 public void smoothScrollTo(int destX,int destY)&#123; int scrollX = getScrollX(); int scrollY = getScrollY(); int deltaX = destX - scrollX; int deltaY = destY - scrollY; mScroller.startScroll(scrollX, scrollY, deltaX, deltaY); &#125;&#125; 我们首先初始化Scroller，之后重写computeScroll方法，系统会在绘制View的时候在 draw 方法中调用该方法。在computeScroll方法中， 我们调用父类的scrollTo() 方法并通过Scroller来不断获取当前的滚动值， 每滑动一小段距离我们就调用invalidate() 方法不断地进行重绘，重绘就会调用computeScroll()方法， 这样我们通过不断地移动一个小的距离并连贯起来就实现了平滑移动的效果。这里我们设定CustomView沿着X轴向右平移400像素(至于为什么是负数，上面已经解释过了): mCustomView.smoothScrollTo(-400,0); 属性动画在属性动画出现之前，Android系统提供的动画只有帧动画和 View 动画。View 动画我们都了解，它提供了AlphaAnimation、 RotateAnimation、 TranslateAnimation、 ScaleAnimation这4种动画方式，并提供了AnimationSet动画集合来混合使用多种动画。 随着Android 3.0属性动画的推出， View动画不再风光。 相比属性动画， View动画一个非常大的缺陷突显， 其不具有交互性。 当某个元素发生View动画后，其响应事件的位置依然在动画进行前的地方， 所以View动画只能做普通的动画效果， 要避免涉及交互操作。 但是它的优点也非常明显： 效率比较高， 使用也方便。 在属性动画中使用最多的就是AnimatorSet和ObjectAnimator配合： 使用 ObjectAnimator 进行更精细化的控制， 控制一个对象和一个属性值， 而使用多个ObjectAnimator组合到AnimatorSet形成一个动画。 属性动画通过调用属性get、 set方法来真实地控制一个View的属性值， 因此， 强大的属性动画框架基本可以实现所有的动画效果。 ObjectAnimatorObjectAnimator 是属性动画最重要的类， 创建一个 ObjectAnimator 只需通过其静态工厂类直接返还一个ObjectAnimator对象。 参数包括一个对象和对象的属性名字， 但这个属性必须有get和set方法， 其内部会通过Java反射机制来调用set方法修改对象的属性值。 一般使用方式如下： ObjectAnimator.ofFloat(view,”translationX”,200,0).start() ObjectAnimator的使用方法就不介绍了，需要注意的是， 在使用ObjectAnimator的时候， 要操作的属性必须要有get和set方法， 不然ObjectAnimator 就无法生效。 如果一个属性没有get、 set方法， 也可以通过自定义一个属性类或包装类来间接地给这个属性增加get和set方法。 如以下示例这种情况： 123456789101112131415private static class MyView&#123; private View mTarget; private MyView(View target)&#123; this.mTarget = target; &#125; public int getWidth()&#123; return mTarget.getLayoutParams().widht &#125; public void setWidth(int width)&#123; mTarget.getLayoutParams().width = width; mTarget.requestLayout(); &#125;&#125; 使用时只需要操作包类就可以调用get、 set方法了： 12MyView mMyView = new MyView(mButton);ObjectAnimator.ofInt(mMyView,\"width,500).setDuration(500).start() ValueAnimatorValueAnimator不提供任何动画效果， 它更像一个数值发生器， 用来产生有一定规律的数字， 从而让调用者控制动画的实现过程。 通常情况下， 在ValueAnimator的AnimatorUpdateListener中监听数值的变化， 从而完成动画的变换。 AnimatorSet略 在XML中使用属性动画12345678&lt;objectAnimator android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:duration=\"3000\" android:propertyName=\"scaleX\" android:valueFrom=\"1.0\" android:valueTo=\"2.0\" android:valueType=\"floatType\"/&gt; 在代码中引用xml属性动画也很简单： 123Animator animator = AnimatorInflater.loadAnimator(this,R.anim.scale);animator.setTarget(view);animator.start(); 解析Scroller略，去看源码，看不懂再来添加这块内容 View 事件分发机制这里了解Activity的构成就好了，如下图： 事件分发机制则看之前写的文章还容易理解一些，这里就略过了。 View的工作流程这一章太长，作为第二部分内容。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android进阶之光","slug":"Android进阶之光","permalink":"https://glassx.gitee.io/tags/Android%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%89/"}]},{"title":"常用的git命令","slug":"git常用用法","date":"2019-07-06T08:57:00.000Z","updated":"2019-11-17T14:00:04.316Z","comments":true,"path":"2019/07/06/git常用用法/","link":"","permalink":"https://glassx.gitee.io/2019/07/06/git%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95/","excerpt":"常用的git命令（摘抄自官网）列显已有的标签列出现有标签的命令非常简单，直接运行 git tag 即可： $ git tagv0.1v1.3 我们可以用特定的搜索模式列出符合条件的标签。在 Git 自身项目仓库中，有着超过 240 个标签，如果你只对 1.4.2 系列的版本感兴趣，可以运行下面的命令：","text":"常用的git命令（摘抄自官网）列显已有的标签列出现有标签的命令非常简单，直接运行 git tag 即可： $ git tagv0.1v1.3 我们可以用特定的搜索模式列出符合条件的标签。在 Git 自身项目仓库中，有着超过 240 个标签，如果你只对 1.4.2 系列的版本感兴趣，可以运行下面的命令： $ git tag -l ‘v1.4.2.*’v1.4.2.1v1.4.2.2v1.4.2.3v1.4.2.4 新建标签含附注的标签创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可： $ git tag -a v1.4 -m ‘my version 1.4’ 轻量级标签轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可： $ git tag v1.4-lw 分享标签默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可： $ git push origin v1.5 如果要一次推送所有本地新增的标签上去，可以使用 –tags 选项： $ git push origin –tags 删除分支删除本地分支删除本地分支可以使用一下命令： $ git branch -d testing 如果删除失败，需要强制删除可以使用 -D 选项强制删除它： $ git branch -D testing 删除远程分支 可以运行带有 –delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令： $ git push origin –delete serverfixTo https://github.com/schacon/simplegit [deleted] serverfix","categories":[{"name":"查阅工具","slug":"查阅工具","permalink":"https://glassx.gitee.io/categories/%E6%9F%A5%E9%98%85%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"git","slug":"git","permalink":"https://glassx.gitee.io/tags/git/"}]},{"title":"第3章——View的事件体系","slug":"Android 开发艺术探索-第3章","date":"2019-05-12T14:42:00.000Z","updated":"2019-11-17T13:43:42.533Z","comments":true,"path":"2019/05/12/Android 开发艺术探索-第3章/","link":"","permalink":"https://glassx.gitee.io/2019/05/12/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC3%E7%AB%A0/","excerpt":"View 基础知识1、 MotionEvent 和 TouchSlopMotionEvent这里只需要注意一点，通过MotionEvent 可以获得点击事件发生的x和y坐标，系统提供了两组方法，getX/getY 和 getRawX/getRawY ，他们的区别很简单，前者返回的是相对于当前View的左上角的 x 和 y 坐标，后者返回的是相对于手机屏幕左上角的 x和y 坐标。","text":"View 基础知识1、 MotionEvent 和 TouchSlopMotionEvent这里只需要注意一点，通过MotionEvent 可以获得点击事件发生的x和y坐标，系统提供了两组方法，getX/getY 和 getRawX/getRawY ，他们的区别很简单，前者返回的是相对于当前View的左上角的 x 和 y 坐标，后者返回的是相对于手机屏幕左上角的 x和y 坐标。 TouchSlopTouchSlop 是系统所能识别出的被认为是滑动的最小距离，小于这个值就不认为是滑动操作。TouchSlop 是一个常量，和设备有关，在不同的设备上这个值可能是不同的。通过如下方式可以获取这个常量： ViewConfiguration.get(context).getScaledTouchSlop() 2、VelocityTracker、GestureDetector 和 ScrollerVelocityTracker用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。它的使用过程很简单，首先在 View 的 onTouchEvent 方法中追踪当前单击事件的速度： VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event); 接着，当我们想知道当前的滑动速度时，可以采用如下方法获得： velocityTracker.computeCurrentVelocity(1000);int xVelocity = (int)velocityTracker.getXVelocity();int yVelocity = (int)velocityTracker.getYVelocity(); 这里需要注意的是： 一、获取速度之前必须先计算速度；二、这里的速度是指一段时间内手指所划过的像素数，比如将时间间隔设置为 1000ms，在 1s 内水平从左至右滑过100像素，那么水平速度就是100 。如果将时间间隔设置为100ms，在这100ms 内滑过10像素，则水平速度会变成 10 。此外，这个速度是可以为负值的，当水平方向从右往左滑动时，水平方向的速度即为负值。 GestureDetector手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。比如要监听双击行为，代码如下： GestureDetector mGestureDetector = new GestureDetector(listener);//再加上这行可以解决长按屏幕后无法拖动的现象mGestureDetector.setIsLongpressEnabled(false); 接着，接管目标View的onTouchEvent方法，在待监听View的 onTouchEvent 方法中如下实现： boolean consume = mGestureDetector.onTouchEvent(event);return consume; OnGestureListener 与 OnDoubleTapListener 里面的方法有很多，常用的有：onSingleTapUp（单击）、onScroll（拖动）、onLongPress（长按）、onFling（快速滑动）、onScroll（拖动）、onDoubleTap（双击）。 Scroller弹性滑动对象，用于实现View的弹性滑动，我们知道，当使用View的scrollTo/scrollBy方法来进行滑动时，其过程是瞬间完成的，这时候就可以使用 Scroller 来实现有过渡效果的滑动，它需要和View的conputeScroll方法配合使用才能共同完成这个功能，典型的使用如下： 123456789101112131415161718Scroller mScroller = newScroller(context);//缓慢滑动到指定位置privte void smoothScrollTo(int destX,int destY)&#123; int scrollX = getScrollX(); int delta = destX - scrollX; //1000ms内滑向destX就是，效果就是慢慢滑动 mScroller.startScroll(scrollX,0,delta,0,1000); invalidate();&#125;@Overridepublic void computeScroll()&#123; if(mScroller.computeScrollOffset())&#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate() &#125;&#125; View 的滑动未完待续。。。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}]},{"title":"第2章——IPC机制","slug":"Android 开发艺术探索-第2章","date":"2019-05-11T14:40:00.000Z","updated":"2019-11-17T13:43:34.684Z","comments":true,"path":"2019/05/11/Android 开发艺术探索-第2章/","link":"","permalink":"https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC2%E7%AB%A0/","excerpt":"提到IPC的使用场景就必须提到多进程，如果只有一个进程，又何必使用进程间通信。多进程的情况分为两种：第一种是应用本身需要采用多进程模式实现（比如通过多个进程来获取多份内存空间）；第二种是当前应用需要向其他应用获取数据，由于是两个应用，因此必须采用跨进程通信方式。Android中的多进程模式我们不讨论两个应用之间的多进程情况。","text":"提到IPC的使用场景就必须提到多进程，如果只有一个进程，又何必使用进程间通信。多进程的情况分为两种：第一种是应用本身需要采用多进程模式实现（比如通过多个进程来获取多份内存空间）；第二种是当前应用需要向其他应用获取数据，由于是两个应用，因此必须采用跨进程通信方式。Android中的多进程模式我们不讨论两个应用之间的多进程情况。 1、开启多进程，Android中使用多进程有两种方法：第一种是给四大组件在AndroidManifest中指定 android:process 属性；第二种是非常规方式，通过JNI在native层去fork一个新的进程。第二种情况属于特殊情况，暂时不考虑。 2、多线程模式的运行机制如果用一句话形容多进程，那就是：“当应用开启了多进程以后，各种奇怪的现象都出现了”，开启多线程只需要给四大组件指定 android:process 属性，但是是否正常运行就是另外一回事了。看个例子： 有 MainActivity 和 SecondActivity，其中 SecondActivity 指定运行在一个新的进程中，并且项目还新建一个 UserManager 类，类中有个public 的静态变量： 123public class UserManager&#123; public static int sUserId = 1;&#125; 在 MainActivity 的 onCreate 中把 sUserId 的值改为2，打印sUserId，之后再启动 SecondActivity ，在 SecondActivity 中打印 sUserId 。 可以发现在 MainActivity 中打印的值是2，在 SecondActivity 中打印的值是 1 ，看到这里，大家应该明白了多进程带来的问题，绝非只是指定一个 android:process 这么简单。 分析：我们知道，Android 系统为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类的对象会产生多份副本。拿上面的例子来说，两个进程中都存在一个 UserManager 类，并且这两个类是互相不干扰的，在一个进程中修改 sUserId 的值只会影响当前进程，对其他进程不会造成任何影响。 通过以上可以知道，运行在不同进程中的四大组件，只要他们之间需要通过内存来共享数据，都会共享失败，这也是多进程所带来的主要影响。一般来说，使用多进程会造成如下几个方面的问题： 静态成员和单例模式完全失效 上面做了分析 线程同步机制完全失效 既然都不是一块内存了，那么不管是锁对象还是锁全局类都无法保证线程同步，因为不同进程锁的不是同一个对象 SharedPreference 的可靠性下降 是因为 SharedPreference 不支持两个进程同时去执行写操作，否则会导致可能的数据丢失（因其本质是通过读写xml文件来实现的） Application 会多次创建 这个问题是显而易见的，由于系统要在创建新的进程同时分配独立的虚拟机，所以这个过程其实就是启动一个应用的过程，因此相当于系统又把应用重新启动了一遍，自然就创建了新的Application。还可以这么理解，运行在同一个进程中的组件是属于同一个虚拟机和同一个Application的；同理，运行在不同进程中的组件是属于两个不同的虚拟机和Application。 IPC 基础概念介绍IPC 中的基础概念包括3方面内容： Serializable 接口、Parcelable接口、Binder。 1、Serializable 接口Serializable 是Java提供的一个空的序列化接口，为对象提标准的序列化和反序列化操作。使用 Serializable 实现序列化非常简单，只需要类实现 Serializable 接口，并且在类的声明中指定一个类似下面的标识： private static final long serialVersionUID = 12345L 实际上，这个 serialVersionUID 也不是必需的，因为serialVersionUID 的机制是这样的： 序列化时，系统会把当前类的 serialVersionUID 写入序列化的文件中；当反序列化的时候，会去检测文件中的 serialVersionUID 是否和当前类的 serialVersionUID 一致，如果一致说明序列化的类版本和当前类的版本是相同的，就可以成功反序列化；否则的话，说明当前类和序列化的类相比发生了某些变换，就无法正常反序列化。以下例子说明 Serializable 的使用： 1234567891011121314151617181920//序列化的类public class User implements Serializable&#123; private static final long serialVersionUID = 12345L; public int id; public String userName;&#125;/**********使用*****************///序列化User user = new User(12,\"tom\");ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"cache.txt\"));out.writeObject(user);out.close();//反序列化过程ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"cache.txt\"));User newUser = (User)in.readObject();in.close(); 另外，系统默认的序列化过程也是可以改变的，通过重写 writeObject 和 readObject 方法即可，只不过大部分情况下我们无需去重写这两个方法。 2、Parcelable 接口Parcelable 也是一个接口，只要实现这个接口，类的对象就可以实现序列化并通过 Intent 和 Binder 传递。 具体使用方法可以查看官方文档 既然 Parcelable 和 Serializable 都能实现序列化并且都可用于 Intent 间的数据传递，那如何取舍呢？Serializable 是Java中的序列化接口，序列化和反序列化需要大量I/O操作；而Parcelable 是 Android 中的序列化方式，主要用在内存序列化上，使用起来稍显麻烦，但是效率高，所以这是 Android 官方推荐的序列化方式。综上所述，将对象序列化存储到设备或者通过网络传输时使用 Serializable ，否则使用 Parcelable 。 3、BinderBinder 是 Android 中的一种 IPC 方式，还可以理解为一种虚拟的物理设备，它的设备驱动是 dev/binder。 Android 中的 IPC 方式使用Bundle由于Bundle 实现了 Parcelable 接口，所以它可以方便地再不同的进程间传输，基于这一点，当我们在一个进程中启动了另一个进程的 Activity、Service 和 Receiver，我们就可以在Bundle 中附加我们需要传给其他进程的信息，并通过Intent 发送出去，这是一种最简单的进程间通信方式。 使用文件共享共享文件是一种不错的进程间通讯方式，适合在对数据同步要求不高的进程间通信。当然，SharedPreferences 是个特例，由于系统对它的读写会有一定的缓存策略，即在内存中会有一份 SharedPreferences 文件的缓存，因此在多进程模式下，面对高并发的的读写会有很大几率丢失数据，因此不建议在进程间通信中使用 SharedPreferences。 使用 Messenger顾名思义可以翻译成信使，通过它可以在不同的进程中传递 Message 对象,它是轻量级的 IPC 方案，底层实现是 AIDL 。Messenger 只是一串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务端，服务端仍然只能一个个处理。具体可以参考官方文档 使用 AIDL由于 Messenger 服务端只能串行处理，所以可以使用 AIDL 来实现跨进程调用。具体内容可以参考官方文档 使用 ContentProvider这是Android 中提供的专门用于不同应用建进行数据共享的方式。 使用 SocketSocket 是网络通信中的概念，也称为“套接字”，它分为流式套接字和用户数据报套接字两种，分别对应于网络的传输控制层中的TCP和UDP协议。 选择合适的 IPC 方式 名称 优点 缺点 适用场景 Bundle 简单易用 只能传输Bundle支持的数据类型 四大组件之间的通信 文件共享 简单易用 不适合高并发 无并发，数据实时性要求不高 AIDL 功能强大，支持一对多，支持实时 使用复杂 一对多通信且有RPC需求 Messenger 一对多串行通信，支持实时 高并发困难，不支持RPC，只能传输Bundle支持的数据 低并发的一对多通信 ContentProvider 数据源访问功能强大 理解为受约束的AIDL，主要提供数据源的 CRUD 操作 一对多的进程间数据共享 Socket 支持一对多并发实时通信，支持字节流 实现繁琐 网络数据交换","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}]},{"title":"第1章——Activity 生命周期和启动模式","slug":"Android 开发艺术探索-第1章","date":"2019-05-11T07:42:00.000Z","updated":"2020-07-22T13:37:59.091Z","comments":true,"path":"2019/05/11/Android 开发艺术探索-第1章/","link":"","permalink":"https://glassx.gitee.io/2019/05/11/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC1%E7%AB%A0/","excerpt":"Activity 的生命周期全面分析本节将分为两部分内容，一部分是典型情况下的生命周期，一部分是异常情况下的生命周期（比如被系统回收或者由于当前设备Configuration 发生改变而导致 Activity 被销毁重建）。一、典型情况下的生命周期分析正常情况下，Activity 会经历如下生命周期：","text":"Activity 的生命周期全面分析本节将分为两部分内容，一部分是典型情况下的生命周期，一部分是异常情况下的生命周期（比如被系统回收或者由于当前设备Configuration 发生改变而导致 Activity 被销毁重建）。一、典型情况下的生命周期分析正常情况下，Activity 会经历如下生命周期： onCreate ： 表示Activity 正在创建，这是生命周期第一个方法。 onRestart ： 表示Activity 正在重新启动。一般情况下，当前Activity 从不可见重新变为可见时，onRestart 就会被调用。 onStart ： 表示Activity 正在被启动，这时候 Activity 已经可见了，但是还没出现在前台，无法和用户交互。可以理解为 Activity 已经显示出来了，但是我们还看不到。 onResume ： 表示 Activity 已经可见了，并且出现在前台可以交互。 onPause： 表示 Activity 正在停止，正常情况下，紧接着 onStop 会被调用；在特殊情况下，如果这个时候快速地再回到当前 Activity ，那么 onResume 将会被调用。此时可以做一些存储数据、停止动画等工作，但是注意不能太耗时，因为onPause必须先执行完，新Acitivty 的 onResume 才会执行。 onStop ： 表示 Activity 即将停止，可以做一些稍微重量级的回收工作，同样不能太耗时。 onDestroy： 表示 Activity 即将被销毁，这是Activity 生命周期中的最后一个回调，我们可以做一些回收工作和最终的资源释放。 以下再针对 Activity 的生命周期具体说明： 针对特定的Activity，第一次启动回调如下： onCreate-&gt;onStart-&gt;onResume 打开新的Activity 或者(按Home键)回到桌面的时候，回调 onPause-&gt;onStop ；这里有种特殊情况，打开的新Activity 如果是透明主题（意味着当前Activity还是可见的），那么当前Activity 不会回调 onStop 。 当用于再次回到原来的 Activity 时，回调 onRestart-&gt;onStart-&gt;onResume 当用户按返回键返回上一个页面时，回调 onPause-&gt;onStop-&gt;onDestroy 从整个生命周期来看，onCreate与onDestroy是配对的，分别标识着Activity的创建与销毁；onStart与onStop是配对的，标识着Activity是否可见；onResume 与 onPause 是配对的，标识着Activity是否在前台。 一个问题：当前 Activity 标识为 A，启动一个新的Activity 标识为 B，那么B的onResume 和 A 的onPause 哪个先执行？ 由上面的描述可知是限制性A的 onPause，再执行 B 的onResume ，具体看源码，官方文档也是这么解释(Always followed by onPause())。 二、异常情况下的生命周期分析1、资源相关的系统配置发生改变导致Activity被杀死并重建如果没有做特殊处理，当横竖屏切换的时候，由于系统配置发生了改变，Activity 会加载不同的资源（比如横竖屏加载两张不同图片），此时 Activity 会被销毁并且重新创建。由于 Acitivity 是在异常情况下终止的，因此在销毁Activity的时候，确切来说是在onStop之前（但是跟onPause没有顺序关系，有可能在其之前，也可能在其之后）会调用 onSaveInstanceState 来保存当前 Activity 状态； Activity 被重新创建后，会把销毁时 onSaveInstanceState 方法保存的Bundle对象作为参数传给 onCreate 方法和 onRestoreInstanceState 方法，因此可以从这两个方法恢复之前保存的数据。从时序上来说，onRestoreInstanceState 调用时机在 onStart 之后。 这两个方法恢复数据的区别是：onRestoreInstanceState 一旦被调用，其参数 savedInstanceState 是一定有值的，我们不需要额外地判空；而 onCreate 中的数据是可能为空的，官方文档建议采用 onRestoreInstanceState 去恢复数据。 如果没有覆写的话，onSaveInstanceState 和 onRestoreInstanceState 方法中，系统会自动为我们做一定的恢复工作。 2、资源内存不足导致低优先级Activity被杀死Activity 按照优先级从高到低可以分为如下三种： （1）前台Activity——正在和用户交互的Activity，优先级最高（2）可见但非前台Activity——比如Activity中弹出了dialog，导致Activity可见但是位于后台无法和用户直接交互。（3）后台Activity——已经被暂停的的Activity，优先级最低。 我们知道，当系统配置发生改变时，Activity 会被销毁并重新创建，当然我们也可以通过给 Activity 指定configChanges 属性来阻止销毁重建： android:configChanges=”orientation” 当然这个属性可以配置的项目还有很多，比如切换系统语言、使用了新字号、界面模式改变（比如 是否开启/关闭夜间模式）。 Activity 的启动模式 standard： 标准模式。不复用，每次请求都创建新实例，并且就运行在启动它的那个Activity所在的栈。 singleTop： 栈顶复用模式 。如果实例位于任务栈的栈顶就复用，复用时调用 onNewIntent方法，否则就创建新的实例。 singleTask： 栈内复用模式。当前栈内没有实例，则创建实例放入栈中；如果实例在当前栈内，则复用，复用时调用 onNewIntent方法，并把它之上的Activity出栈。 singleInstance： 单例模式。只能单独位于一个任务栈中，只要这个实例存在，后续的请求均不会创建新的Activity。复用时调用 onNewIntent方法。 在使用 ApplicationContext 启动standard 模式的Activity时会报错： Callking startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag 这是因为standard模式的Activity 默认会进入启动它的Activity所属的任务栈中，由于非Activity类型的Context 没有所谓的任务栈，所以会报错。解决这个问题的方法是为待启动的Activity指定 FLAG_ACTIVITY_NEW_TASK 标记，这样启动的时候会为它创建一个新的任务栈（体会下，这时候实际上是以singleTask模式启动的） 参考其他博客的启动模式的原理点击launcher 的startactivity 会调用到Instrumentation的execStartActivity，之后交给AMS 来处理启动操作，之后调用 ActivityStackSupervisor 的 startActivityMayWait 方来启动，而ActivityStackSupervisor 是管理Activity堆栈的类 另外提一下，Activity 在AMS中的形式是 ActivityRecord，task在AMS 中的形式是 TaskRecord，进程在 AMS 中的管理形式为 ProcessRecord 判断启动模式，根据当前的Activity 和 要启动的Activity 的启动模式，根据相应的启动模式设置launchFlags 在Android 5.0上 在 ActivityStackSupervisor 类的startActivityUncheckedLocked 里面判断launchmode 以上内容参考自简书的博客上的内容 Activity 的FlagsActivity 的Flags很多，这里分析比较常用的几个: FLAG_ ACTIVITY_ NEW_ TASK 为Activity 指定singleTask启动模式，其效果和在XML中指定 singleTask 启动模式相同 FLAG_ ACTIVITY_ SINGLE_ TOP 为Activity 指定 singleTop 启动模式，其效果和在XML中指定 singleTop 启动模式相同 FLAG_ ACTIVITY_ CLEAR_ TOP 具有此标记的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈，这个标记为一般会和FLAG_ACTIVITY_SINGLE_TOP标记位一起出现。由前面的分析可知，singleTask启动模式默认具有此标记位效果。 FLAG_ ACTIVITY_ EXCLUDE_ FROM_ RECENTS 具有这个标记位的Activity不会出现在历史Activity列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候，这个标记比较有用。这个标记等同于xml中指定Activity 的属性 android:excludeFromRecents = “true” IntentFilter 的匹配规则略","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}]},{"title":"总结","slug":"总结","date":"2019-05-04T03:16:00.000Z","updated":"2020-05-10T02:15:31.019Z","comments":true,"path":"2019/05/04/总结/","link":"","permalink":"https://glassx.gitee.io/2019/05/04/%E6%80%BB%E7%BB%93/","excerpt":"","text":"进程间通信方式 点击看答案 别漏了BroadCastReceiver 参考链接：ipc机制 零散的知识点 点击看答案 Service 多次启动， onStartCommand 会多次 本地广播无法通过静态方式注册 RemoteViews 通过id来给特定的view更新UI 为毛Thread 废弃 suspend 方法，因为如果被suspend 了一直持有锁，那就可能导致死锁了 stop 方法废弃，主要是防止数据写了一半，导致后期数据不一致问题 在sleep过程中，有可能会执行 thread.interrupt 方法，所以要try-catch 如何禁止指令重排和可见性：final、volatile、加锁 保证原子性：加锁、CAS、原子类型(AtomicInteger等) onSaveInstanceState 的调用时机： 销毁Activity 的时候，在 onStop 之前(与onPause没啥关系)。 onRestoreInstanceState 的调用时机是在 onStart 之后 开启多进程，可以指定process，还可以在native 上fork出来 多进程问题：Application多次、单例失效、sp不可靠、锁失效(即使锁类也不行了) view的滑动有几种方法：layout、offsetALeftAndRight/offsetTopAndBottom、LayoutParams、动画、scrollTo、scrollBy、scroller Android系统分层：应用层、应用框架层、系统运行库层、硬件抽象层、Linux内核 init 进程工作：启动属性服务和zygote 进程 zygote启动工作：创建java虚拟机，并注册jni方法、创建 SocketServer 来监听 fork 请求 SystemServer 的工作：启动系统服务、启动Binder 线程池(用于与其他进程通信) Android系统启动流程，可以参考博客 在zygote 通过fork创建进程后，启动它的binder线程池，并通过反射调用ActivityThread 的main 方法，创建主线程环境 ActivityThread 的 attach 方法就是初始化 Application 对象 Launcher 启动某个app应用，首先会为启动的 Activity 的intent 设置 FLAG_ACTIVITY_NEW_TASK，在新任务栈中 新Activity 启动经历三个阶段： Launcher经过Instrumentation 到AMS、AMS 到 ApplicationThread、ActivityThread 启动Activity ApplicationThread 是ActivityThread 的内部类，负责与AMS 进程间通信，收到进程消息后，在ApplicationThread 中通过 handler.sendMessager 的方式向 ActivityThread 中发送消息启动Activity LoadApk 用于描述已经加载进来的 APK 文件的。 通过反射创建Activity，attach 方法将新建的Context 设置成mBase Context包装类目的：ContextImpl 具体实现不会暴露给使用者、组合而不是继承，更灵活 启动应用的的第一个Activity过程中(handleMessage中)，最终会使用LoadApk.makeApplication() 方式创建Application ，同样也是通过反射的方式。 会将 Application 缓存到LoadApk中 Application 的attach ，就是把新建的ContextImpl 设置为mBase，并且，Application 设置为ContextImpl的 mOut变量 获取 Application Context 的方式，首先从 LoadApk中获取，否则 调用ActivityThread 中获取 同理，Activity 的 attach 会将ContextImpl 设置为mBase，并将Activity 对象赋值给 ContextImpl 的 mOuterContext。 类的生命周期， 加载-验证-准备-解析-初始化-使用-卸载 垃圾收集算法： 标记-清除、复制、标记-整理、分代 Java API 中标称自己是线程安全的类，其实大多数不是绝对的线程安全的，如你遍历的时候，读取size 是synchronize修饰的，但是在打印过程中可能被删除了某些元素，这时候读取就会抛异常 线程安全的实现方法： 无同步方案(不共享)、互斥同步、非阻塞同步(如CAS操作) 锁优化：自旋、锁消除(比如在方法内部new出来StringBuffer)、锁粗化(也是StringBuffer的append)、轻量级锁(CAS操作mark word)、偏向锁 轻量级锁，使用CAS操作尝试将对象的 MarkWord 改成轻量级锁标志，如果成功，则拥有锁；否则，判断锁是否指向当前线程，如果是，则直接进入。否则，就等待(个人觉得应该是CAS重试)。如果有两个以上线程在争用这个锁，就升级为重量级锁，后面的线程阻塞。 偏向锁：偏向锁在轻量级锁基础上连 CAS 都不做。在对象第一次被线程获取后，把线程id写在 MarkWord 中(这个当然是CAS操作)，当另一个线程尝试获取的时候，偏向模式就结束(指的是这个CAS操作不做了)，恢复到未锁定或者轻量级锁状态，后续就是轻量级锁规则了 轻量级锁与偏向锁不一定总是有利的，如果程序中大多数锁都被不同线程访问，竞争激烈，那它还得转换状态，因此，有时候禁止它们反而性能提高 https在http之下，tcp之上增加一层 SSL(Secure Socket Layer) ssl 握手前，先要tcp 握手 ssl握手： 算法、随机数 -&gt; 算法(对称、非对称、摘要)、随机数、证书 -&gt; 验证证书、公钥加密“前主密钥” -&gt; 握手摘要 -&gt; 握手摘要 udp：无需握手、无需维护连接(缓存、拥塞控制、序号确认等)、头部小，8个字节，tcp有20个，值得注意的是，它有校验和，用于防止传输过程引入的差错 快重传：收到3个相同 ack，则立即重传 流量控制：避免接收方缓存溢出 拥塞控制：防止整体网络质量堵塞 确定拥塞：超时没收到ack，或者3次重复的ack 拥塞控制方法：慢启动、拥塞避免(收到ack之后，不像慢启动翻倍增长，而是缓慢增长)、快速恢复(窗口减半，之后执行拥塞避免) tcp 时延：握手、拥塞控制、捎带确认、TIME-WAIT 多线程下载大文件速度快，为啥？1、多个下载线程能够抢占更多的实时网络带宽（相当于下载进程占用了更多带宽） 改善tcp性能的方法：并行连接、长连接、管道化连接 死锁条件：互斥条件、不可剥夺、占有等待、环路等待，可以采用基于矩阵的算法来检测死锁 死锁恢复：回滚、杀死进程、抢占(需要人工干预) 按返回键，要先清完当前的栈，再清其他的栈，比如：B是singleInstance，则 A启动B，B启动C，则此时按返回键先到A，再按返回键才看到B 如果想fragment commit 立即生效，可以在 FragmentTrasation.commit() 之后，执行 fragmentManager.executePendingTransactions() Fragment 生命周期： onAttach、onCreate、onCreateView、onActivityCteated、onStart、onResume、onPause、onStop、onDestroyView、onDestroy、onDetach 避免异步使用 commit，因为感知不到Activity 生命周期，可能commit的时候，Activity 结束了 广播分类：标准广播、有序广播、本地广播 BroadcastReceiver 的onReceiver 中也不是不能开启子线程，只是不推荐开启，因为 BroadcastReceiver 的生命周期本身就很短，在子线程还没结束的情况下，Activity 就被退出了，所以能，BroadcastReceiver 的耗时任务建议交给 IntentService 去做 mmkv 可以替代 SharedPreference MVC 在Android 中导致 Activity 的职责不明确，很臃肿。没有涉及Model 时，View 可以直接调用Controller，Controller 可以直接调用View。并且，View 还可以直接更新Model，只不过Model要更新UI必须经过 Controller 。 二叉搜索树查找代价：logN 或者 N，插入，基本上在logN，删除：O(1) 或者 logN 平衡二叉搜索树：查： logN，插入：logN，删除： 2logN 红黑树：查： logN，插入：logN，删除：logN 发起tcp请求，序列号是随机的，这是防止多次重传时候，(假如已经建立连接了)分不出是哪一次了 三次握手，第一二次不可以携带数据(第一次允许，容易引起攻击，并且不确认有接收能力)，但是第三次是可以携带数据的 udp 面向报文，添加首部之后就可以交给ip层，不拆分；tcp 面向字节流，对报文拆分 udp 没有拥塞控制，tcp会有拥塞控制，tcp还有滑动窗口实现流量控制 http2特性：服务端push、新的二进制格式(而不是文本)、多路复用、新的压缩算法、header 压缩、更安全的ssl RxJava 线程切换原理：将Observer 封装成 SubscribeTask ，它实现了Runnable接口，如果在main线程的话，会启用Handler(getMainLooper)将Runnable封装成Message 发送出去，其他线程则交给相应的线程池。 LocalBroadcastManager 初始化的时候会创建一个主线程的Handler，发送广播时，根据intent获取action，依次调用 线程池异常处理：1、继承 ThreadPoolExecutor 再重写 afterExecute ，可以得到实际异常 2、对Runnable 里面的整个try-catch 3、自己写ThreadFactory，即自己创建线程，然后实现 setUncaughtExceptionHandler 来捕捉。 synchronize 同步原理：代码块：monitorenter指令插入到同步代码块的开始处，将monitorexit插入到结束处 ，方法同步，采用另外的标记ACC-synchronized，其实是一样的效果，都是针对monitor 线程阻塞的原因： 调用wait、等待同步锁、执行了sleep、执行了 join yield 将线程状态由Running 转变为 Runnable状态，但是系统可能不理会这个请求，所以不一定可靠，官方只建议用来调试 onCreate 中，子线程可以刷新ui，是因为ViewGroup 的attachInfo 还是空的，后续的线程检测就不进行了。还有，线程判断主要是判断和new 这个view的线程是不是同一个。 LruCache 原理：LinkedList，最近使用过的就插在头部，淘汰的时候，淘汰尾部 Object 的方法： clone、equals、finalize、getClass、hashCode、identityHashCode、notify、notifyAll、toString、wait HashMap 中链表元素达到一定阈值(8个)，就会转化为红黑树，然后转成树key总要通过什么对比吧，其实是通过 System.identityHashCode 来对比的，它不受hashCode 的影响 RecyclerView 的优化：数据处理与视图分开(在bindViewHolder的时候不做数据处理了)、布局优化、设置setHasFixedSize(根据最初的高度、后面就不会重新测量了)、减少item的监听器创建、滑动过程停止加载、DiffUtil工具、公用 RecycledViewPool 嵌套的RecyclerView 中可能用得着 Linearlayoutmanager 的 onSaveInstanceState 和 onRestoreInstanceState 来恢复嵌套的recyclerview的滑动状态 全局捕捉异常，在Application 中为Thread.setUncatchExceptionHandler SharedPreference 在解析xml 的时候，commit 和apply 是不可以调用的，解析完了就会notifyAll 每次调用edit()方法时，都会创建一个 EditorImpl 对象，所以不要频繁 调用 edit() 方法 sp 执行 commit 时，首先更新到内存，之后再在当前线程直接写入到xml文件中，所以要注意这里的耗时 sp的apply方法，首先写到内存，然后交给HandlerThread，即在子线程中，单线程地依次提交到xml文件中 sp 不要跨进程使用sp(会有缓存，不可靠)、不要存储超大的key或者value，因为加载xml一直会等待，然后后来会放在内存中，占用内存、不要存储JSOn等特殊字符很多的value，会触发转义、不要多次执行 edit，不要多次apply(在api 11 之前，activity 退出时，要等待apply的那些 Runnable 执行完成才能退出，如果时间过长，就导致ANR 了) 常见内存泄露：资源性资源未关闭(buffer/cursor)、非静态内部类的静态变量、Context泄露、非静态Handler泄露、注册的对象未反注册、匿名内部类和异步的线程(线程与外部类的生命周期不一致) LeakCanary原理：registerActivityLifecycleCallbacks 监听生命周期、弱引用查看对象是否存在 apk安装过程：安装源、复制apk到/data/data 、解析apk(签名、四大组件注册)、dexopt、更新权限信息(更新到pms)，判断是否允许这些权限、安装完成，发送广播 Android 资源替换原理：替换 AssertManager 热修复原理：DexClassLoder 可以从外部加载 classes.dex，插件化也是利用 DexClassLoder 新特性：5.0-材料设计，ART、6.0-动态权限，Dozen模式、7.0-JIT和ART 交叉编译 、8.0-notification、画中画、9.0-刘海屏支持、Q、文件权限，uri，深色主题、折叠设备 Handler 有三种Message，同步消息、异步消息(Message 中 setAsynchronous(true) 了)、消息屏障消息 消息屏障，MessageQueue.postSyncBarrier 可以发送消息屏障，不过这是私有方法，需要反射(新的api貌似提供了puglic的的调用了)。其实就与普通的post一样，只是它的Message的target 为空，没有handler引用。当处理到这个屏障时，会一直查找是否有异步消息，先处理异步消息，这个过程持续到手动移除消息屏障为止(MessageQueue.removeSyncBarrier) IdleHandler ：在没有Messager 需要处理的时候，就调用IdleHandler 来处理了 BlockCanary 原理：在主线程loop中，在处理msg 之前，会调用Printer类型的mLogging 来打印一下，然后处理完了也打印一下，所以通过设置我们自定义的Printer就能监听到处理msg的耗时 图片巨大，可以使用 BitmapRegionDecoder 来每次加载一部分 Android 16ms 时间是包括 layout、measure、、和draw 三个部分的，cpu执行计算任务将ui计算成多边图形，在交给gpu栅格化，最后gpu绘制到屏幕上 避免丢帧：避免cpu任务过重，减少layout，measure，onDraw 工作量、避免GPU 任务过重，避免无谓的invalidate、减少过度绘制 像素密度：以160dpi 作为密度基准的，1dp = 1px 无响应：input： 5s、service：前台20s，后台200s、广播：前台：10s，后台：60s、provider：10s、Activity 退出时等待 sp 的写入完成 哪些产生ANR： 理论上执行业务时，handler post 这个anr msg之后的任何步骤都可能ANR，因为执行完成之后才会remove 这个 anr 的 msg 为什么用Binder：安全、性能、c/s架构容易管理 动画：帧动画、补间动画、属性动画 签名：v1和v2 TouchDelegate 用来扩大点击区域，如果要设置多个，就建立TouchDelegate 的 list，在onTouchEvent 的时候遍历执行 bitmap内存优化，2.3.3及以下，记得recycle，3.0及以上，可以使用 imBitmap 字段，复用bitmap 内存(当bitmap从Lrucache删除时，其软引用会放在HashSet中，之后通过inBitmap 复用) Java 基础基本查找基本排序插入排序：O(n^2)复杂度，稳定的排序选择排序： 复杂度总是 O(n^2)，每次挑最大最小的，因此不稳定 shell 排序： 最差的时候：O(n^2) 平均复杂度 ： nlogn，不稳定冒泡：有序的情况，一趟完成，OO(n)，平均复杂度O(n^2)，稳定的排序快排序： 分治思想，平均 nlogn ，最坏 O(n^2)，交换数据啊，不稳定堆排序：最坏最好和平均都是 nlogn ，不稳定归并排序： 分治思想，时间复杂度 nlogn ，稳定，主要用于外部排序 归并和快排的平均时间复杂度差不多，但是比快排最差情况要好。但是归并使用的空间比较多，因此一般情况下选择快排 不稳定的排序：希尔、堆、快排","categories":[{"name":"阶段","slug":"阶段","permalink":"https://glassx.gitee.io/categories/%E9%98%B6%E6%AE%B5/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://glassx.gitee.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"第3章：垃圾收集器与内存分配策略","slug":"深入理解Java虚拟机-第3章","date":"2019-04-03T13:10:00.000Z","updated":"2019-11-17T13:49:12.544Z","comments":true,"path":"2019/04/03/深入理解Java虚拟机-第3章/","link":"","permalink":"https://glassx.gitee.io/2019/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0/","excerpt":"对象已死吗引用计数法很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。客观地说，引用计数法的实现简单，但它很难解决对象之间相互循环引用的问题，所以，主流实现中，并不使用这种方式。","text":"对象已死吗引用计数法很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。客观地说，引用计数法的实现简单，但它很难解决对象之间相互循环引用的问题，所以，主流实现中，并不使用这种方式。 可达性分析在主流实现中，都是通过可达性分析来判定对象是否存活。这个算法的基本思路就是通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到GC Roots 没有任何引用链相连时，则证明此对象是不可用的。在Java语言中，可以作为 GC Roots 的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象。 本地方法栈中JNI引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 再谈引用JDK 1.2 以前，对象只有引用和被引用两种状态，未能描述那些“食之无味，弃之可惜”的对象，我们希望描述这样一类对象：当内存还足够时，则能保留在内存之中；如果内存空间在GC后还是非常紧张，则可以抛弃这些对象。因此，JDK 1.2以后对引用的概念进行扩充，分为： 强引用。代码中普遍存在的，类似于 Object obj = new Object() ，只要强引用还在，垃圾收集器永远不会回收被引用的对象。 软引用。是用来描述一些还有用，但是并非必需的对象，在系统将要发生内存溢出的异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。 弱引用。是用来描述非必需对象的，但是强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次GC发生之前。当GC工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 虚引用。是最弱的一种引用关系，不会对对象的生存时间构成影响，也无法通过虚引用获得对象实例。为对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 生存还是死亡即使在可达性分析算法中不可达的对象，也并非“非死不可”的。要真正宣告一个对象的死亡，至少要经历两次标记过程：如果对象在可达性分析后发现没有与GC Roots 相连接的引用链，那么它会被第一次标记，并进行筛选，筛选的条件是此对象是否有必要执行 finalize() 方法，当对象没有覆写 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则都没有必要执行； 如果对象判定有必要执行 finalize() 方法，则对象会被放入F-Queue队列中，稍后由低优先级的线程去触发 执行finalize() 方法，但不会承诺等待它运行结束。这样做的原因是防止 finalize 方法过于缓慢或者死循环。finalize() 方法是对象套多死亡命运的最后一次机会，因为稍后GC将对F-Queue中的对象进行第二次标记，如果对象要在finalize 中拯救自己————只要重新与某个引用链上的任意一个对象关联即可，那么在第二次标记的时候它将被移除出“即将回收”的集合；如果这时候对象还没逃脱，那它就会真的被回收了。 说明这一过程的示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142public class FinalizeEscapeGC&#123; public static FinalizeEscapeGC SAVE_HOOK = null; public void isAlive()&#123; System.out.println(\"yes,i am still alive\"); &#125; @Override protected void finalize（） throws Throwable&#123; super.finalize(); System.out.println(\"finalize method executed\"); FinalizeEscapeGc. SAVE_HOOK = this; &#125; public static void main(String[] args) throws Throwable&#123; SAVE_HOOK = new FinalizeEscapeGC(); //对象第一次成功拯救自己 SAVE_HOOK = null; System.gc(); //因为finalize方法优先级很低，所以暂停0.5秒等待它 Thread.sleep(500); if(SAVE_HOOK != null)&#123; SAVE_HOOK.isAlive(); &#125;else&#123; System.out.println(\"no,i am dead\"); &#125; //下面这段代码与上面的完全相同，但是这次自救却失败了 SAVE_HOOK = null; System.gc(); //因为finalize方法优先级很低，所以暂停0.5秒等待它 Thread.sleep(500); if(SAVE_HOOK != null)&#123; SAVE_HOOK.isAlive(); &#125;else&#123; System.out.println(\"no,i am dead\"); &#125; &#125;&#125; 运行结果： finalize method executedyes,i am still aliveno,i am dead 从结果可以看出，SAVE_HOOK 对象的 finalize 方法确实被GC收集器触发过，并且收集前成功逃脱。但两段完全一样的代码，第二次却被回收了，因为finalize 方法只会被自动调用一次，因此第二次不执行了，所以自救失败。 有些教材上认为 finalize 中适合做“关闭外部资源”之类的工作，在了解以上机制之后，可以认为这完全是一种自我安慰，finalize 能做的，try-finally 或其他方法能做得更好，更及时，所以完全可以忘记这个方法存在（它也仅仅只是Java诞生时讨好C/C++程序员的一个妥协）。 垃圾收集算法标记-清除算法最基础的收集算法是 标记-清除(Mark-Sweep) 算法，它分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，在标记完成后统一回收被标记的对象。它的主要不足有两个：一是效率问题，标记和清除效率都不高；二是清除后会产生大量不连续的内存碎片。 复制算法为了解决效率问题，复制算法出现了。它将可用内存分为大小相等的两块，每次只使用其中一块，当这块内存用完了，就将还存活的对象复制到另一块上，然后把当前内存空间一次清理掉。这样每次都是对整个半区回收，内存分配也不会存在碎片。缺点是可用内存缩小了一半，代价太高。 现在商业虚拟机采用这种方式回收新生代。一般将内存分为较大的 Eden 和两块较小的 Survivor 空间（HotSpot中 Eden 与 Survivor大小比例为 8：1），每次使用Eden 和其中一块 Survivor，当内存回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor，最后清理Eden和刚才用过的Survivor空间，因此，每次只有10%的内存“被浪费”。当然这是基于统计新生代的对象生命周期都很短，差不多只有10%的对象会存活，此外，如果超出10%的存活对象，Survivor空间不够时，需要依赖老年代的空间提供担保（Survivor空间存不下的对象直接通过担保机制进入老年代），这是该分配方式能够运行下去的保障。 复制收集算法在对象存活率较高时要进行较多的复制操作，效率将会变低，更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行担保，防止对象100%存活的极端情况。 标记-整理算法根据老年代特点，有人提出另外一种标记-整理(Mark-Compact)算法，标记过程仍与“标记-清除”算法一样，但后续不是直接清理可回收对象，而是所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。标记整理算法的示意图如下： 关于怎么个移动法，书上没有说明，这里个人做个推测： 1、整个老年代的内存划分为 A 和 B 两个区域，区域 A 的大小是所有还存活对象的总大小，区域 B 大小是是剩余空间。2、按顺序在 A 中找到第一个还存活对象，将它移动到 A 空间的最前端，接下来找第二个还存活的对象，将其移动到第一个对象的后面3、以此类推，即使存活的对象在 B 中也一样顺序复制到A中，直至最后填满A空间，之后清除 B 空间。 分代收集算法商业虚拟机都采用“分代收集”，根据各个年代的特点分别采用适当的收集算法： 在新生代中，每次垃圾收集时都会发现有大批对象死去，只有少量存活（前面提到的统计数据，大部分时候只有 10% 存活），那就选用复制算法。 而老年代中因对象存活率高，没有额外空间对它进行担保，就必须使用“标记-清理”或者“标记-整理”算法进行回收。 CMS 收集器这是自己添加的这个标题，书中的结构并不是如此，因为 Android ART 虚拟机使用的也是CMS收集方式，所以这里特意抽出来理解，方便理解Android的虚拟机。 CMS (Concurrent Mark Sweep) 收集器，并发的“标记-清除”方式实现的收集器。它是一种以获取最短回收停顿时间为目标的收集器。它的整个过程分为4个步骤： 初始标记 并发标记 重新标记 并发清除 其中，初始标记、重新标记 这两个步骤仍然需要“Stop The World”，初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快；并发标记就是进行 GC Roots Tracing 的过程（根据初始标记过程中标识出来的直接关联对象，并发标记存活的对象）；重新标记阶段则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录； 由于整个过程中好事最长的 并发标记 和 并发清除 过程收集器线程都可以与用户线程一起工作，所以，从总体上来讲，CMS收集器的内存回收过程是与用户线程一起并发执行的。 CMS 是优秀的收集器，但是它也有3个明显的缺点： CMS 收集器对 CPU 资源非常敏感。与其他并发设计的程序一样，CMS收集器对 CPU 同样敏感，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用变慢。 CMS 无法处理浮动垃圾(Floating Garbage,个人认为简而言之就是GC过程中用户线程产生的垃圾，类比于你妈妈在打扫房间卫生的时候，你还在继续撕的纸)。 还有最后一个缺点，就是CMS本质还是“标记-清除”算法实现的，这种收集方式在结束后会产生大量的碎片化的空间。 内存分配与回收策略以下是几条最普遍的内存分配规则，可以通过代码去验证这些规则： 对象优先在 Eden 上分配大多数情况下，对象在新生代 Eden 区中分配，当 Eden 区没有足够空间时，虚拟机将发起一次 Minor GC （新生代GC）。可以采用以下方式验证： 通过 -Xms20M、-Xmx20M、-Xmn10M 三个参数限制Java 虚拟机堆大小 20MB，不可扩展，并且其中 10M 分配给新生代，剩下的 10MB 分配给老年代，-XX:SurvivorRatio=8决定新生代中 Edun 区与 一个 Survivor区的比例是 8：1，即 Eden 大小 8192K，两个 survivor 空间分别 1024K，所以新生代总共可用空间是 9216K （Eden 区 + 1个Survivor区）。执行 testAllocation()尝试分配 3个 2M 的大小和1个 4MB 大小的对象。代码执行完成后，可以发现 新生代Eden区被占用了 4M，而老年代被占用了 6M。解释：分配前3个对象时，没有压力，均分配在Eden区域，当分配第4个对象时，内存已经不够了（可用空间是 9216K，而 2M*3 + 4M = 10），因此触发一次Minor GC，此时发现这3个对象都存活，并且 survivor 区间不够容纳存活的对象，因此这3个对象被直接通过担保机制提前转移到老年代中；这次GC结束后，第4个对象就可以顺利分配到Eden空间中。 新生代GC(Minor GC):发生在新生代的垃圾收集，因为Java对象大多朝生夕死，所以Minor GC非常频繁，一般回收速度也比较快老年代GC(Major GC/Full GC)：指的是老年代的GC，对于许多收集器而言，这时候都会伴随至少一次的 Minor GC，老年代的GC一般会比 Minor GC 慢10倍以上。 大对象直接进入老年代所谓大对象是指需要大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组。当然，比大对象更糟糕的是遇到一群朝生夕死的“短命大对象”，这种应当避免。经常出现大对象容易导致内存还有不少空间就提前触发垃圾收集器以获得足够的连续空间来安置它们。 长期存活的对象进入老年代如果对象在Eden出生并经历过第一次Minor GC 后仍然存活并且能被 Survivor 容纳的话，将被移动到Survivor 中，并且年龄设置为 1，此后，每熬过一次 Minor GC ，对象的年龄就加1，当达到某个阈值（系统一般默认 15），就会被晋升到老年代中。 动态对象年龄判定为了更好地适应不同程序内存状况，并不总是要求对象必须达到某个年龄才进入老年代。如果 Survivor 中同龄对象达到某个阈值（一般是一半）时，大于或者等于这个年龄的对象就会移动到老年代。 空间分配担保发生Minor GC 前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，则 Minor GC 可以确保是安全的，如果不成立，则会判断是否允许担保失败，如果允许担保失败，则最终可能会触发一次Full GC。虽然绕了一圈还是有可能触发 Full GC，但是这种情况相对较少。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"第2章：Java内存区域与内存溢出异常","slug":"深入理解Java虚拟机-第2章","date":"2019-04-02T13:10:00.000Z","updated":"2019-11-17T13:49:05.686Z","comments":true,"path":"2019/04/02/深入理解Java虚拟机-第2章/","link":"","permalink":"https://glassx.gitee.io/2019/04/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0/","excerpt":"运行时数据区域根据《Java虚拟机规范(java SE 7)》规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域：程序计数器程序计数器可以看做是当前线程执行的字节码的行号指示器，它是线程私有的。在虚拟机概念模型里（具体虚拟机可能有更高效实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖程序计数器来完成。如果线程在执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行Native方法，这个计数器值为Undefined。此内存区域是Java虚拟机规范中唯一一个没有规定任何 OutOfMemoryError情况的区域。","text":"运行时数据区域根据《Java虚拟机规范(java SE 7)》规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域：程序计数器程序计数器可以看做是当前线程执行的字节码的行号指示器，它是线程私有的。在虚拟机概念模型里（具体虚拟机可能有更高效实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖程序计数器来完成。如果线程在执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行Native方法，这个计数器值为Undefined。此内存区域是Java虚拟机规范中唯一一个没有规定任何 OutOfMemoryError情况的区域。 Java虚拟机栈Java虚拟机栈也是线程私有的。它描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，一个方法从调用至完成，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。这个区域被规定了两种异常状况：如果线程请求的栈深度大于虚拟机允许的深度，就抛出 StackOverflowError异常；如果该区域可以动态扩展，则在扩展时无法申请到足够内存，就会抛出OutOfMemoryError异常。 本地方法栈本地方法栈与虚拟机栈类似，区别只不过是虚拟机栈为执行Java方法(即字节码)服务，而本地方法栈为Native方法服务，同样，本地方法栈也可能抛出StackOverflowError异常以及OutOfMemoryError异常. Java堆Java堆是被所有线程共享的一块内存，虚拟机启动时创建。虚拟机规范描述是，所有对象的实例以及数组都要在堆上分配(当然，不同虚拟机实现不同)。如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区与Java堆一样，方法区也是各个线程共享的内存区域。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常。 提到方法区，不得不提运行时常量池，它是方法区的一个部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是信息常量池，用于存放编译期生成的各种字面量和符号引用（一般来说，翻译出来的直接引用也会存储在运行时常量池中）。 直接内存直接内存(Direct Memory)不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在Java 1.4中新加入了NIO（New Input/Output）类，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectBuffer对象作为这块内存额引用进行操作，这样能在一些场景中显著提高性能，因为它避免在 Java 堆和 Native 堆中来回复制数据。当然，该区域空间在动态扩展时也可能出现OutOfMemoryError异常。 HotSpot 虚拟机对象探秘对象的创建虚拟机遇到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，则必须限制性相应的类加载过程。类加载完成后，便可完全确定对象所需的内存大小，接下来为新生的对象真正分配内存。 对象的内存布局对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)、和对齐填充(Padding)。 对象的访问定位建立对象是为了使用对象，我们的Java程序需要通过栈上的refrence数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针，其中前者通过句柄池间接指向堆中的对象，后者直接指向堆中的对象。 实战OutOfMemoryError异常Java虚拟机规范中，除了程序计数器之外，其他区域都可能发生 OutOfMemoryError异常。 JAVA堆溢出Java堆用于存储实例对象，只要不断地创建对象，并且保证GC root 到对象之间有可达路径来避免垃圾回收，那么就能产生OutOfMemoryError异常。 虚拟机栈和本地方法栈溢出虚拟机栈和本地方法栈理论上分配不到足够的内存同样会报 OutOfMemoryError异常，但是一般情况下，首先会出现StackOverflowError，OutOfMemoryError很难出现。 方法区和运行时常量池溢出由于运行时常量池是方法区的一个部分，因此这两个区域的溢出测试放在一起进行。在此之前我们先了解下String.intern()方法： String.intern()是一个Native方法，它的作用是，如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并返回此String对象的引用。 在JDK1.6及以前，通过设置永久代区域的大小可以间接限制方法区大小，但是从JDK 1.7以后就“去永久代”了，因此以下代码只在JDK 1.6 ，并且设置了 MaxPermSize 时有效： 12345678public static void main(String[] args)&#123; //使用List保持常量池的引用，避免full gc 回收常量池 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); int i = 0; while(true)&#123; list.add(String.valueOf(i++).intern()); &#125;&#125; 同样的原因，还可以引申一个更有意思的影响，如下代码： 1234567public static void main(String[] args)&#123; String str1 = new StringBuilder(\"计算机\").append（“软件”）.toString(); Systemt.out.println(str1.intern() == str1); String str2 = new StringBuilder(\"ja\").append(\"va\").toString(); Systemt.out.println(str2.intern() == str2);&#125; 这段代码在JDK 1.6 中运行，会得到两个false（intern 方法会把首次遇到的字符串实例复制到永久代中，而StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用）；而在JDK 1.7 中会得到一个true（intern 实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此，intern返回的引用和由StringBuilder创建的字符串实例是同一个实例）一个false（“java”字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现，而“计算机软件”这个字符串则是首次出现的—这个解释没看懂，需要再次理解）。 本机直接内存溢出直接或者间接地使用NIO，就可能出现本机直接内存溢出。虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但是抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配。因此可以通过以下代码手动抛出异常，真正抛出异常的地方是unsafe.allocateMemory()。 1234567891011//以下代码能够抛出异常的前提是，设置虚拟机参数 -XX: MaxDirectMemorySize 的值private static final int _1MB = 1024 * 1024;public static void main(String[] args) throws Exception&#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true)&#123; unsafe.allocateMemory(_1MB); &#125;&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深入理解Java虚拟机-JVM高级特性与最佳实践(第2版)","slug":"深入理解Java虚拟机-JVM高级特性与最佳实践-第2版","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC2%E7%89%88/"}]},{"title":"面试题-算法-基本查找","slug":"面试题-算法-基本查找","date":"2019-03-22T09:49:00.000Z","updated":"2020-04-11T13:06:49.236Z","comments":true,"path":"2019/03/22/面试题-算法-基本查找/","link":"","permalink":"https://glassx.gitee.io/2019/03/22/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E6%89%BE/","excerpt":"","text":"704、二分查找，给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1 点击看答案 还没写。。。。。 自己写的时候的问题：这题目自己写得还不错 参考链接：LeetCode","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Android 架构设计之AAC","slug":"Android 架构设计之AAC","date":"2019-03-10T14:00:00.000Z","updated":"2019-11-17T13:59:50.651Z","comments":true,"path":"2019/03/10/Android 架构设计之AAC/","link":"","permalink":"https://glassx.gitee.io/2019/03/10/Android%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B9%8BAAC/","excerpt":"","text":"照例先上官方描述官方提供的应用架构指南","categories":[{"name":"专题","slug":"专题","permalink":"https://glassx.gitee.io/categories/%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://glassx.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"第4章：操作系统基础","slug":"深入理解Android内核设计思想-第4章","date":"2019-03-09T13:10:00.000Z","updated":"2019-11-17T13:48:37.731Z","comments":true,"path":"2019/03/09/深入理解Android内核设计思想-第4章/","link":"","permalink":"https://glassx.gitee.io/2019/03/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E7%AC%AC4%E7%AB%A0/","excerpt":"进程间通信的经典实现共享内存共享内存的工作流程： 创建共享区。进程1从内存中申请一块内存作为共享区域，并且将该区域与某个Key绑定 映射共享区。创建共享区之后，需要将其映射到进程1的空间中才能操作。 访问共享区。进程2利用第一步得到的Key，访问到共享区，之后将这块内存映射到进程2的空间中。 进程间通信。各进程实现了对共享内存的映射后，便可以利用该区域进行信息交换。（注意：整个内存过程都没有实现同步机制，需要进程间自己实现）","text":"进程间通信的经典实现共享内存共享内存的工作流程： 创建共享区。进程1从内存中申请一块内存作为共享区域，并且将该区域与某个Key绑定 映射共享区。创建共享区之后，需要将其映射到进程1的空间中才能操作。 访问共享区。进程2利用第一步得到的Key，访问到共享区，之后将这块内存映射到进程2的空间中。 进程间通信。各进程实现了对共享内存的映射后，便可以利用该区域进行信息交换。（注意：整个内存过程都没有实现同步机制，需要进程间自己实现） 管道 进程A和B分立管道两端，进行数据传输通信 管道是单向的，如果进程既要“读”也要“写”，就需要两根管道这点很像水管的特性 管道同时具有“读取”(read end)端和“写入”(write end)端，比如进程A从 write end 写入，进程 B 就可以从 read end 端读取到数据 管道容量有限制，当pipe满了后，写操作将阻塞；反之，pipe空了之后，读操作将会阻塞 普通的管道是匿名的，这种匿名的管道只适合有斧子关系的进程通信，如果要实现没有任何关系的管道间的通信，就需要命名管道(Named pipe) UNIX DOMAIN SOCKET 简称UDS,也可以说是IPC Socket，与普通的Socket不一样，专门针对单机进程间通信提出来的。 大家熟知的 Network Socket 是以 TCP/IP 协议栈作为基础的，需要分包、重组 等一系列操作，而 UDS 因为是本机内的“安全可靠操作”，实现机制上并不依赖于这些协议。 Android 中使用最多的一种IPC就是Binder，其次就是 UDS 。 RPC（REMOTE PROCEDURE CALLS）RPC 涉及通信双方通常运行于两台不同的机器中。 同步机制的经典实现###信号量（SEMAPHORE） 信号量与PV原语是分不开的，也是最为广泛的互斥方法之一，主要包括以下几个元素： Semaphore S（信号量，用于指示共享资源的可用数量） Operation P （可以减小S计数） Operation V （可以增加S计数） P执行：S = S -1，此时判断若 S&gt;=0 ，说明资源此时允许访问，开始操作共享资源；否则，加入等待队列，待别人释放资源后唤醒。V执行：S=S+1，如果此时S&gt;0，说明当前没有希望访问资源的等待者；否则，唤醒等待队列中的相关对象。其中，PV源于都属于原子操作，意味着他们执行过程是不允许被中断的。 互斥体（MUTEX）Mutex 是 Mutual Exclusion 的缩写，释义为 互斥体。如果资源允许多个对象同时访问，成为 Counting Semaphores；而如果只允许取值0或1（lock/unlocked）的Semaphore，则叫做 Binary Semaphore。Binary Semaphore 与Mutex有相同性质，Mutex通常是对某一排他资源的共享控制——要么这个资源被占用（locked），要么是可以访问的（unlocked）。 管程（MONITOR）针对信号量机制的程序易读性较差，并且信号量管理分散在各个参与对象中，很难维护等缺点，管程被提出来了。管程是可以被多个进程/线程安全访问的对象或者模块，管程中的方法在同一时刻只允许一个范文这使用它们（方法受 mutual exclusion 保护的）。 操作系统内存基础操作系统中任何操作都与内存息息相关，内存管理的底层原理主要注意几个核心： 虚拟内存 内存总是“不够大”的，随着应用的增加，总会填满，虚拟内存为运行更多的程序提供了可能，其基本思想是：1.将硬盘上一部分空间作为内存的扩展；2.出现资源不足时，按照一定算法挑出优先级较低的数据块移动到第1步划出的空间；3.需要用到硬盘中的数据块时，系统将产生“缺页”，之后把硬盘中的数据交换回内存中。 内存分配与回收 分配、native层回收，java层回收 内存保护 内存分页或者分段式管理。进程的逻辑地址不是直接对应物理地址的，因此没办法访问它范围外的内存空间。 顺带一提，mmap函数（Memory Map）正如其名，可以将某个设备或者文件映射到应用进程的内存空间中，这样访问这块内存就相当于对设备/文件进行读写；可见，理论上mmap可以用于进程间通信，即通过映射同一块物理内存来共享内存，这种方式因为减少了复制次数，在一定程度上提高了进程间通信效率。 Android 匿名共享内存（Ashmem）Ashmem 全称 Anony Shared Memory，是Android 特有的内存共享机制，它可以将指定的物理内存分别映射到各个进程的地址空间，从而便捷地实现进程间的内存共享。Ashmem 是一个 misc 设备，其实现依托于 /dev/ashmem 。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深入理解Android内核设计思想-林学森","slug":"深入理解Android内核设计思想-林学森","permalink":"https://glassx.gitee.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E6%9E%97%E5%AD%A6%E6%A3%AE/"}]},{"title":"针对简历的问题","slug":"面试题-针对简历的问题","date":"2019-03-08T13:10:00.000Z","updated":"2020-09-13T12:10:24.219Z","comments":true,"path":"2019/03/08/面试题-针对简历的问题/","link":"","permalink":"https://glassx.gitee.io/2019/03/08/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%92%88%E5%AF%B9%E7%AE%80%E5%8E%86%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"根据技术栈可能的提问1、聊聊 java 中 static 关键字 点击看答案 一旦什么东西设置为 static ，数据或者方法就不会同那个类的任何对象实例有联系。例如以下类： 123class StaticTest&#123; static int i = 47;&#125; 尽管我们可以给StaticTest 类new 出 2个对象来，但是 StaticTest.i 仍然只有一个存储空间，即两个对象共享同样的i，此时，其中一个对象执行 ++i 后，另一个对象的 i值 也会变为 48。 静态的变量或者方法，可以通过对象引用，也可以直接通过类引用，如以上的i，可以使用如下两种方式引用： 假设st 是 StaticTest 类的对象： st.i = 4 或者 StaticTest.i = 4","text":"根据技术栈可能的提问1、聊聊 java 中 static 关键字 点击看答案 一旦什么东西设置为 static ，数据或者方法就不会同那个类的任何对象实例有联系。例如以下类： 123class StaticTest&#123; static int i = 47;&#125; 尽管我们可以给StaticTest 类new 出 2个对象来，但是 StaticTest.i 仍然只有一个存储空间，即两个对象共享同样的i，此时，其中一个对象执行 ++i 后，另一个对象的 i值 也会变为 48。 静态的变量或者方法，可以通过对象引用，也可以直接通过类引用，如以上的i，可以使用如下两种方式引用： 假设st 是 StaticTest 类的对象： st.i = 4 或者 StaticTest.i = 4 2、Kotlin 相关 点击看答案 Kotlin 中的协程用过吗？聊聊？简单使用过，但是仅仅用于线程切换，对协程有一些简单的了解： 协程是编译器级别的，进程和线程是操作系统级的 线程根据os的调度算法，当分配的时间片用完后，保存当前上下文，之后被强制挂起，开发者无法精确控制它们 协程可以看做是轻量级的用户态线程 协程实现的是非抢占式的调度，由当前协程控制什么时候切换到其他协程 每个协程池里都有一个调度器，这个调度器是被动调度的，即当前协程主动让出cpu时调度 目前的协程框架一般设计成 1:N 的模式，即一个线程作为容器，里面包含多个协程 优点 协程轻量，创建成本小，内存消耗小 协作式的用户态调度器，cpu上下文切换开销少 进程/线程 切换需要在内核完成，而协程通过用户态栈实现，速度更快，但协程也放弃了线程中优先级的概念 减少同步加锁，整体性能提高 协程基于事件循环，减少同步加锁的频率。但若存在竞争，该上锁的地方仍需要加上协程锁 可以按照同步思维写异步代码，即用同步的逻辑，写由协程调度的回调 协程可以减少callback 的使用，但是不能完全替代callback，基于事件驱动的变成用callback更合适 缺点： 协程中不能有阻塞操作，否则整个线程被阻塞(协程是语言级别，线程是操作系统级别) 需要特别关注全部变量、对象引用的使用 协程擅长处理IO密集型程序效率问题，但处理cpu密集型不是它的长处 假设线程中有个协程是cpu密集型，但是没有io操作，也就是一时半会不会主动触发调度器调度，从而其他协程得不到执行 适用场景： 高性能计算，牺牲公平性换区吞吐量； 在 IO 密集型程序中。由于io密集型的程序中往往需要 CPU 频繁切换线程，带来大量性能浪费。但是协程可以很好地解决这个问题：比如把一个IO操作写成一个协程，当触发IO操作时就自动让出cpu给其他协程，协程间的切换是很轻的。 流式计算。消除Callback Hell。 Kotlin 优势按照官网上的说法： 简洁。语法简单，代码很少。判空、getter、setter 方法、命名传参(动态改变参数)无需重载，可能结合anko 之类的更加简单 安全，减少空指针等错误、类型判断过后，自动类型转换 兼容java，可以混编 缺点 lateinit，也容易引起空指针，即还未初始化 直接使用 ArrayList 之类的list 是不能直接添加元素的，得使用 MutableList 才行 引入了kotlin 支持库，apk包体积增加 如果某个变量设置为可空的，那么即使你在初始化后，已经不空了，你也只能使用 ? 或者 !! 操作来使用它，感觉会有点乱 kotlin如何实现空安全 可空类型和不可空类型 使用 ? 进行安全调用 入参可以指定可空和非空类型 安全的类型转换，如 a as? Int 可以方便过滤非空元素，如： val intList: List = nullableList.filterNotNull() 一定能避免空指针问题吗？我认为是不能，因为有 lateInit 变量存在，有可能这个变量还没初始化，就会导致是空的 3、有自定义view的经验，那如何理解 MeasureSpec？ 点击看答案 MeasureSpec 的含义是：父View传递给当前 View 的一个建议值。MeasureSpec 是个int 类型的数字，转换成二进制后，前2位代表模式(mode)，后30位代表数值(size)。模式总共分为3种： measureSpec &amp; MODE_MASK 即可获得mode的值；而 measureSpec &amp; ~MODE_MASK 即可获得数值。 那么，measureSpec 的值到底是如何计算得到的？view的 measureSpec 根据view 的布局参数(LayoutParams) 和 父容器的 MeasureSpec 值计算得到的，计算方法如下图所示： 由于UNSPECIFIED模式用于系统内部多次measure 的情况(如listview、gridview 等)，很少用到自定义view上，因此我们很少讨论。以下总结的规律也不讨论： 以上总结中，父容器的剩余空间指的是父容器除了padding之外的所剩余的空间，至于父容器的剩余空间与大小不超过父容器的剩余空间，看代码和看图都没能理解，后续再理解吧 以上内容部分参考自这个链接 4、聊聊 Android 中事件分发机制？ 点击看答案 参考以前写的这篇文章 上面的文章中已经写得很明白了，但是需要重点再提一下的是，如果在 onTouchEvent 中不消耗事件，则在同一个事件序列中，当前View无法再次接到事件。 5、如何处理手势冲突？ 点击看答案 有外部和内部两种方式处理手势冲突。 外部拦截：由上面的事件分配可知，点击事件都会经过父容器拦截处理，如果父容器需要此事件就拦截，否则此事件就不拦截，这样就可以解决事件冲突。外部拦截法需要重写父容器的onInterceptTouchEvent，比较符合事件分发机制。 这里要注意的是，还是上面的原则，在 onInterceptTouchEvent 中，首先是ACTION_DOWN 这个事件，父容器必须返回false，即不拦截，因为一旦拦截了 ACTION_DOWN ,后续的 ACTION_MOVE 和 ACTION_UP 都没法再传递给子view了； 接下来的内容辩证看待：ACTION_MOVE根据需要是否拦截；ACTION_UP 必须返回false，因为如果返回true，那么子view 是接受不到 ACTION_UP 事件，onClick 事件就无法响应。 内部拦截法： 可以利用view事件分发的原则，在适当的地方拦截就行。 当然，也可以让父空间不拦截，如果是ViewGroup的话，可以在 onInterceptTouchEvent 方法中请求忽略外层容器拦截事件：getParent().requestDisallowInterceptTouchEvent(true) 。如果是View的话，那么把getParent().requestDisallowInterceptTouchEvent(true) 写在setOnTouchListener 方法中可能更合适。 以上内容参考自一骑绝尘 和 前行的乌龟 6、如何优化App性能？ 点击看答案 一、精简资源 lint检测，删除无用的资源 二、减轻Application的负担 将非紧急操作，放在子线程中处理 只在主进程中初始化app内容(因为接了百度地图等，会开启多个进程) 三、UI绘制优化 布局优化，尽量使用 ConstraintLayout 减少布局层次(因为深度遍历) 布局复用，比如底部的布局大体相似，都使用同一个 layout 避免过度绘制。排查移除叠加的背景 减少资源数目，因为shape很难复用，故shape换成 固定的控件： ShapedTextView、ShapedConstrainLayout 等 提高显示速度 使用 viewstub 延后显示。 四、内存相关优化 一言以蔽之： 开源节流 webview 新进程 检查内存泄漏(LeakCanery) 正确地使用引用，尤其Activity的context(尽量替换成Application 的context，Activity 的Context 一律弱引用)，以及强引用、弱引用、软引用的正确使用。 使用正确的容器，比如避免自动装箱(使用SparseArray等)、避免hashmap内存浪费(使用ArrayMap等) 枚举替换成注解。 五、cpu 相关优化 解析缓存数据一律放在子线程处理 SharedPreference 存储json改动 webview预加载 六、网络优化 域名替换成ip(选取响应速度最快的ip)，避免劫持同时提升响应速度，webview 中的网络请求由网络框架接管。 七、结构 mvp 八、避开高峰 不要同时，充分利用IdleHandler，快速滑动的时候不加载图片 具体优化方式： 1、内存从经常性的 380M 左右降低到 330M 的水平(adb shell dumpsys com.esun.ui，现在可以使用profile)2、页面秒开(talkingdata数据显示，优化前88%左右,93%的收集数据显示1秒以内打开，从onCreate 到onResume)3、过度绘制(优化前几乎所有主要页面都是红色-蓝、绿、粉、红 分别代表过度绘制 1,2,3,4 次，优化后基本上都是蓝绿，粉色的比较少，红色的可能只有极少数小块)4、App启动速度加快，冷启动，从3.5秒左右降低到1秒左右(录屏，记录从启动到展示flash页面，多次时间取平均值)5、网络连接，网络的错误率4%(按次数统计出的)左右，dns加速后，网络错误率基本上保持，主要集中在网络超时、网络无连接两种异常，其中网络超时占了40%左右 引申-adb shell dumpsys meminfo com.esun.ui 中各数据含义 点击看答案 Native Heap： Native对象malloc得到的内存Dalvik Heap： Java对象new得到的内存Dalvik Other： 类数据结构和索引占据的内存Stack： 栈占用的内存(栈空间使用，如函数调用、局部变量等)Pss Total： 在硬盘上实际占用的空间大小Heap Size： Heap总共内存大小 = Heap Alloc + Heap Free, HeapSize 有限制，超出阈值就oomHeap Alloc： 应用所有实例分配的内存，包括应用从Zygote 共享分享的内存(只是分配的虚拟空间，并没有实际占用，比如：new long[1024*1024]，此时alloc就会新增了8M，但是由于没赋值，所以物理内存上并没有占用，如果针对每个元素赋值，则pss total 就会增加8M)Heap Free： 堆空闲的大小Objects： 统计App内部组件对象的个数，其中Views、ViewRootImpl以及Activities个数，在Activity的onDestroy之后应该都会清零，如果未清零，就可能发生了内存泄露 Private Dirty： 私有的脏内存页(还在使用中)Private Clean： 私有的干净内存页(现在未使用了)Private Dirty + Private Clean 便是应用曾经申请过的内存空间大小 以上内容参考自简书上的博客 7、引申-ArrayMap的原理、SparseArray原理 点击看答案 ArrayMapArrayMap 相对HashMap 而言是以时间换空间。它使用两个数组，一个整数型数组存储 key 的 hashCode，另一个Object[] 类型的数组存储 key-value键值对，如下图所示： 这样的结构避免了为每个key创建额外的对象，也即避免了自动装箱(如需要将int包装成 Integer) ，每次put新元素时，key的hashcode 在hashCode的数组中按照顺序存储，object数组中存储key和value。查询元素时，首先获取key的hashCode，然后用二分法查找该hashCode 在第一个数组中的index，则在object 数组中，key的位置在 index&lt;&lt;1 处，而value在 index&lt;&lt;1 + 1 处，如果此时的key并不是当前的key，则认为发生了冲突，此时以该key为中心点，分别上下匹配，直到匹配到为止。 在插入删除元素时，由于是数组组织形式，因此需要移动相关的元素，因此效率并不高；但是在数据量相对较少的情况下(有些博客说是1000条数据以下)，ArrayMap 带来的时间开销并不明显，但是节省的内存却十分可观。 SparseArraySparseArray 用于key为int类型，value 为 Object 的情形，与HashMap 相比，它避免了Integer 自动装箱，并且没有依赖entry 数据结构，因此更高效。它的结构如下图所示： 因为key是int类型，所以也就不需要什么hash值来计算index了，只要int值相等，就是同一个对象。插入和查找也是二分法，所以原理与ArrayMap 基本上一致，所以不多说。为了提升性能，删除元素时，并不需要马上将元素置为空，而是先将其标记为一个需要删除的元素，等真正需要删除时，才清空处理。即如果要插入新数据，如果数组已经填满了，则尝试垃圾回收一下，把标记为DELETE 的对象回收，然后重新寻找key值对应的索引，并插入。 ** 除了SparseArray 可以替代 HashMap&lt;Integer,V&gt;外，还有 SparseIntArray替换HashMap&lt;Integer,Integer&gt;、SparseLongArray替换HashMap&lt;Integer,Long&gt;、LongSparseArray 替换 HashMap&lt;Long,V&gt; ** 以上内容可以参考这个链接 8、描述http 三次握手？为什么3次，2次或者4次不行？ 点击看答案 首先，准确地说是TCP/IP三次握手。因为http本身是应用层协议，只是因为目前http的传输层确实是TCP/IP，所以可以这么说。但是http并不依赖于tcp/ip。 TCP发起连接的一方A，会随机生成一个32位的序列号，比如是1000，以该序列号为原点，对自己每个将要发送的数据进行编号，连接的另一方B会对A的每次数据进行确认，如果A收到B的确认编号是2001，则意味着 1001~2000 编号已经安全到达B。握手的示意图如下所示： 所以我们可以总结，TCP 连接握手，握的是啥？其实就是告知双方数据原点的序列号。那为什么是3次握手呢？个人认为有两个原因： 确认通信双方的 接收/发送 能力是正常的。第一次握手，B可以知道自己的接收能力、A的发送能力是正常的；第二次握手，A可以知道双方的收/发能力是正常的；第三次握手，B知道双方的收/发能力都正常。 节省资源。我们知道，等3次握手结束后，服务端才给这条链接分配必要端口、缓存等资源。如果是2次握手，那么在收到客户端的请求后服务端就得分配资源了，如果第2次握手由于超时丢失，那么客户端会认为服务器还未响应，可能造成两端都在等。或者客户端等到放弃这次请求，而服务端之前分配的资源会被浪费。 因此，3次握手是必需的，更多的请求次数可以，但是浪费资源，没必要。 以上内容有部分是参考知乎中的内容 9、延伸-http 使用80端口，如果客户端一个tcp/ip在连接，那么就无法建立其他tcp/ip连接，因为80端口在占用？ 点击看答案 不是的，80端口一般只是http应用的默认监听端口，就是说新的连接都是发送到80端口的。但是监听80端口的程序会给新建立的连接分配一个可用的端口，所以实际的这条连接可能是机那里在服务端的 10010端口，客户端的8888端口上的。而80端口会继续监听是否有新的连接到来。 10、描述4次挥手，3次行不行？为什么？ 点击看答案 tcp/ip 是全双工的，client 端在没有数据需要发送给server的时候，就发送FIN 信号告知Server ，然后终止对server 的数据传输，但是server 可以继续对client 发送数据包，这时候就是4次来终止连接，过程如下图所示： 但是，如果Server 收到client 的FIN 包之后，再也没有数据要发给Client 了，那么对Client 的ack 包和 Server 自己的FIN 包就能合并成一个包发送出去，4次挥手就能变成3次挥手。 关于图中的 time_await ，它的作用主要是1、为实现TCP全双工连接的可靠释放；2、为使旧的数据包在网络因过期而消失。更详细的解释可以参考以前的这篇文章 11、了解哪些设计模式？写个单例模式？ 点击看答案 单例模式 建造者模式 工厂模式 适配器模式 装饰模式 观察者模式 12345678910111213141516171819202122//线程安全的单例模式代码public class Singleton&#123; //注意 volatitle 关键字 private static volatitle Singleton instance = null; //构造函数私有 private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if (instance == null)&#123; synchronized(Singleton.class)&#123; if (instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 以下针对项目可能的提问 12、了解多线程使用，聊聊锁可以分为哪些种类 点击看答案 大体可以分为，这不全部指锁的状态，有的指锁的特性，有的指锁的设计： 乐观锁/悲观锁 公平锁/非公平锁 偏向锁 轻量级锁 自旋锁 可重入锁 具体可以参考以前写的这篇博客 13、引申-聊聊 HandlerThread 点击看答案 HandlerThread 继承了 Thread ，所以本质上是个workThread，只不过它带了个Looper，无需开发者自己去做Looper.prepare() 操作，可以看下其关键源码： 12345678910111213@Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; 所以我们在使用的时候，首先new 出一个对象来，接着就要执行其start() 方法，以便完成 Looper 的初始化，其中，notifyAll() 主要用于方法 getLooper() 中通知 Looper 已经准备好，唤醒wait： 12345678910111213141516public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; 在使用完成之后，需要手动退出Thread：mHandlerThread.quit(); ，其原理不用写也知道： 12345678public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false;&#125; 从以上原理我们可以知道，HandlerThread 的使用场景就是：需要在子线程执行耗时的，并且可能有多个任务的操作(每个任务都开线程导致线程太多啊)，比如多个下载任务(非同一个任务多线程下载)，还有一个典型例子就是IntentService。 14、延伸-IntentService 点击看答案 我们知道，IntentService 使用非常简单，不需要自己建立线程，执行完毕后也无需我们自己关闭Service，只需要专心在 onHandleIntent(Intent intent) 方法中实现逻辑即可。IntentService 使用工作线程逐一处理所有启动请求，如果不需要在Service中执行并发任务，IntentService 是最好的选择。至于如何做到的，我们只要看关键源码即可： 12345678910111213141516171819202122232425262728293031public abstract class IntentService extends Service &#123; private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; @Override public void onCreate() &#123; super.onCreate(); HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125;&#125; IntentService onCreate 中创建了 HandlerThread 实例，mServiceHandler 创建时使用了 HandlerThread 的 Looper，这决定了最终业务是在HandlerThread 中的子线程中执行的，在 handleMessage 方法中看到了熟悉的 onHandleIntent 方法调用，待 onHandleIntent 执行完毕后，马上执行Service 的 stopSelf(msg.arg1) 关闭自己。 这里使用 stopSelf(msg.arg1) 而不是 stopSelf()，而msg.arg1 即 startId，而这个 startId 就是 onStartCommand(Intent intent,int flags,int startId) 的最后一个参数。我们知道多次调用startService 来启动同一个Service ，只有第一次会执行 onCreate ，但是会多次调用onStartCommand，以及onStart(所以IntentService 中，在onStart方法里面发送Message到Handler)，并且每次 startId 并不相同，且都大于0。而stopSelf() 最终会调用 stopSelf(-1)。 stopSelf(int startId) 中的startId 与 onStartCommand 的startId 是一一对应的关系，所以，当我们调用stopSelf(int startId)时，系统会检测是否还有其它startId 存在，有的话就不销毁当前service，没有的话则销毁。 所以，为什么是调用stopSelf 而不是调用 stopSelf(int startId)，从上面的比较我们得出：这是为了提高 IntentService 的利用率，如果在 onHandleIntent 方法执行完毕前，又调用了startService 启动了同一个 IntentService ，那么我们就没必要销毁当前service了，直接继续使用当前service 对象执行任务即可，这样有利于减少对象的销毁及创建。再提及一句，由于是使用HandlerThread ，所以多个任务只能是串行方式依次执行。 以上内容参考俗人浮生 的博客，以及 IntentService 官方源码 15、volatile 关键字有了解吗？ 点击看答案 讲解之前，首先了解 原子性、可见性 以及 有序性 的基本概念： 一言以蔽之，volatile 保证可见性、有序性，但是不保证原子性。 保证可见性：多个线程共享一个volatile变量k，如果一个线程在工作内存中修改k的值会立即刷新到主存，同时将其他线程中的该值设置成已过期，其他线程在下次使用k值时，需要从主内存刷新获取。在k值更改前就已经在使用的情形，比如k值在做加法的途中，如果k值改变，则是不受影响的，必须是下一次再次使用k的时候，才会从主存去刷新。还有要注意的是，子线程使用成员变量都会将变量从主存中拷贝一份，而不是直接使用。 保证有序性：我们知道为了提高性能，cpu或者编译器会对代码重排序，代码的执行顺序不一定和我们写的顺序是一致的，它们只保证最终结果一致。volatile 保证读/写volatile 属性时，其前面的代码必须已经执行完成，它后面的代码也不能排到前面来执行。 不保证原子性：也即前面提到的，比如在做加法途中，这个k值改变了，是无法改变正在做的加法中的k值的。这也是volatile 修饰变量并不是线程安全的原因。 如果还不太了解，可以参考以前写的这篇读书笔记、还可以参考这篇文章，讲得很透彻 16、什么是大接口？ 点击看答案 大接口就是所看到的整个页面，都是由一个接口数据决定的。当时基于的背景有几个： 这个行业决定，如果有需求，可能会要求某个版本不让用户使用了。 还是行业决定，页面要求能灵活变动，随时可能某个模块没有了，或者某个tab没有了。 减少接口数量，减轻后台压力，我们知道，频繁的、少量数据的接口请求对后台不友好，可能握手、header 等就能占用很大一部分资源。 怎么做的： 本地有若干指定的view映射，根据后台返回，可以动态添加这些view。一般view都是占满一行，左右两边的边距确定。 17、怎么防止劫持？ 点击看答案 背景：当时有用户反馈，我们的 webview 打开慢，并且有时候弹出广告，可我们自己并没有添加广告，因此初步认定可能是运营商劫持，事实上我们在百度上搜索一下运营商劫持，就有一大把的搜索结果，看来并非我们一家。在这个基础上，分析应该是通过dns 污染导致的。 所以解决方案就是不使用运营商的dns，而使用119(腾讯的 119.29.29.29) 和 114(114.114.114.114) 的dns，参考网上的方案，自己写了个实现。在获取到的ip 中，随机选中一个缓存起来，缓存有效时间为15分钟。 在 API 的http 请求中，拦截请求，查询是否缓存该host的ip，如果有，判断是否过期。如果没有缓存或者过期，则会通过上面步骤获取ip，并把host 换成ip直连。 针对webview的http 类型的get请求，在WebviewClient 的 shouldInterceptRequest 回调中(执行在子线程)，使用自定义构建的网络请求(根据WebResourceRequest 的 url 以及 headers 构建 okhttp 的 okHttpRequest，其中headers也加入okHttpRequest 的headers 中)。该请求会在可能的情况下，将url替换成ip直连，获取结果后，自行重新组装 WebResourceResponse 对象return。 18、一般走查哪些代码？ 点击看答案 关键代码，比如容易出现死循环的重试机制、错误上报机制、安全检测机制 19、如何文档归档 点击看答案 使用wiki，wiki内容包括： 后端接口以及参数说明 前端支持的协议以及支持的格式 关键逻辑的边界和参数，如自动登录尝试的次数，防止出现死循环；网络超时时长 其他部门做业务的时候只需要看wiki就行，不用找具体的技术人员查看客户端代码 20、聊聊这个内部sdk的设计？ 点击看答案 以前没有做过sdk，貌似也没地方可以参考，还有时间也很紧急，所以在技术上直接采用500里面的技术，并没有什么新意，做完之后，有小需求做的同时慢慢重构，自己得出一些经验吧： 控制调用权限。只暴露几个类给用户即可，其余的类不允许用户调用。 确定回调方式。1、调用接口中需要传递 activity，业务中使用用户的activity 执行activityForResult 接受业务返回数据。 2、如果使用广播，则使用本地广播 防止资源名称和宿主app冲突，资源名称添加特定前缀 传入的参数各种各样，需要注意判空、检验数据格式合法性等 尽量不使用第三方的类库，目前sdk中使用第三方类库，接sdk的时候要求用户添加依赖 21、最有成就感的项目？最棘手的问题？ 点击看答案 最有成就感的可能就是xx app吧，接触得比较多，虽然目前的流畅度还是一般般，但是做了比较多的努力： 性能优化 大接口试验 在以前的基础上动过网络框架和图片框架 在安全上也做了一些努力 22、引申-如何重新设计网络框架？ 点击看答案 调用方式改变，不需要传递2次的 responseClass 采用kotlin 的线程调度(GlobalScope.launch()) 而不是rxjava 进行线程间的切换 23、引申-安全做了哪些努力 点击看答案 在native层做app签名校验 广播统一改为本地广播 LeakCanary防止内存泄漏 SharedPreference加密 allowBackUp = false 某些key生成在native代码中做 https证书本地验证。 24、讲一讲你看过的第三方框架的源码？ 点击看答案 可以讲讲 LeakCanary 和 阿里的框架 alpha 25、逛哪些论坛？ 点击看答案 有逛csdn，gank.io(不过gank.io有时候更新得比较慢)，apkbus，androidweekly.cn 啊 等等。 26、平时关注什么技术？ 点击看答案 目前关注的就是 flutter 了 27、有什么想问我的 点击看答案 如果是hr初面： 这个岗位是新开设的还是原岗位人离职了？这个岗位可以为公司带来什么价值？想了解以下公司的培训机制和学习机制 如果是技术人员： 你觉得我能胜任这个职位吗(看这一关是否通过了)？感觉不好，就问：你觉得我还有哪些不足？ 终面的话： 如果顺利，问下部门、公司的发展啦如果觉得基本上没戏了，就问下自己的缺陷在哪如果模棱两可，问下一步流程是怎么样的","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题目","slug":"面试题目","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"}]},{"title":"面试题-算法-基础排序","slug":"面试题-算法-基础排序","date":"2019-03-04T13:10:00.000Z","updated":"2020-03-22T09:22:06.116Z","comments":true,"path":"2019/03/04/面试题-算法-基础排序/","link":"","permalink":"https://glassx.gitee.io/2019/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/","excerpt":"冒泡排序算法 点击看答案 思路：冒泡排序基于交换排序思想。依次比较相邻的两个数，将小数放在前面，大数放在后面。 即第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。之后便是重复第一趟步骤，直至全部排序完成(或者说直到某一趟没有发生交换的时候)。每一趟完成后，最后一个数肯定是最大的那个数，所以一次for循环后，会有 len – 操作，即每趟都比上一趟少比较一次。 12345678910111213141516 private static void bubbleSort1(int[] ints) &#123; int len = ints.length; boolean flag = true; while (flag) &#123; flag = false; for (int i = 1; i &lt; len; i++) &#123; if (ints[i - 1] &gt; ints[i]) &#123; int temp = ints[i]; ints[i] = ints[i-1]; ints[i-1] = temp; flag = true; &#125; &#125; len -- ; &#125;&#125; 冒泡排序在数据有序的情况下，只需要一趟即可，时间复杂度是 O(n)，在最差的情况下，每趟都有比较，时间复杂度是 O(n^2) ，平均复杂度是 O(n^2)，适合数据量较小的情况,它是稳定的排序方法，","text":"冒泡排序算法 点击看答案 思路：冒泡排序基于交换排序思想。依次比较相邻的两个数，将小数放在前面，大数放在后面。 即第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。之后便是重复第一趟步骤，直至全部排序完成(或者说直到某一趟没有发生交换的时候)。每一趟完成后，最后一个数肯定是最大的那个数，所以一次for循环后，会有 len – 操作，即每趟都比上一趟少比较一次。 12345678910111213141516 private static void bubbleSort1(int[] ints) &#123; int len = ints.length; boolean flag = true; while (flag) &#123; flag = false; for (int i = 1; i &lt; len; i++) &#123; if (ints[i - 1] &gt; ints[i]) &#123; int temp = ints[i]; ints[i] = ints[i-1]; ints[i-1] = temp; flag = true; &#125; &#125; len -- ; &#125;&#125; 冒泡排序在数据有序的情况下，只需要一趟即可，时间复杂度是 O(n)，在最差的情况下，每趟都有比较，时间复杂度是 O(n^2) ，平均复杂度是 O(n^2)，适合数据量较小的情况,它是稳定的排序方法， 选择排序 点击看答案 选择排序的基本思想：每次从待排序的数据元素中选出最小(大)的一个元素，放在序列的起始位置。 123456789101112131415161718public static void selectSort(int[] a)&#123; for (int i = 0; i&lt; a.length - 1; i++)&#123; int index = i;//当前趟最小的数所在index for (int j=i+1; j &lt; a.length; j++)&#123; if (a[j] &lt; a[index])&#123; index = j; &#125; &#125; if (index != i)&#123; int temp = a[i]; a[i] = a[index]; a[index] = temp; &#125; &#125;&#125; 它的时间复杂度是O(n^2)，因为它总是要循环那么多次，并且每次都是从待排序的数据中挑选最小的，因此它是不稳定的排序算法。 插入排序 点击看答案 插入排序的原理类似于打牌的时候抓牌，每次抓牌上来，都按照顺序将其插入到之前排好序的牌堆中。 1234567891011public void doInsertSort()&#123; for(int index = 1; index&lt;length; index++)&#123;//外层向右的index，即作为比较对象的数据的index int temp = array[index];//用作比较的数据 int leftindex = index-1; while(leftindex&gt;=0 &amp;&amp; array[leftindex]&gt;temp)&#123;//当比到最左边或者遇到比temp小的数据时，结束循环 array[leftindex+1] = array[leftindex]; leftindex--; &#125; array[leftindex+1] = temp;//把temp放到空位上 &#125;&#125; 时间复杂度是O(n^2)，适用于数据量较少的情况，是稳定的排序。 shell排序 点击看答案 原理： 严格来说是基于插入排序的思想，shell排序有点不大好理解，后续再看看 123456789101112131415161718/** * 思路：三层循环 * 第一层循环：控制增量-增量随着程序的进行依次递减一半 * 第二层循环：遍历数组 * 第三层循环：比较元素，交换元素。 * 这里需要注意的是：比较的两个元素和交换的两个元素是不同的。 */public static shellSort(int[] data) &#123; for (int div = data.length/2; div&gt;0; div/=2) &#123; for (int j = div; j &lt; data.length; j++) &#123; int temp = data[j]; for (int k=j; k&gt;=div &amp;&amp; temp&lt;data[k-div] ; k-=div) &#123; data[k] = data[k-div]; &#125; data[k] = temp; &#125; &#125;&#125; shell排序最差的时间复杂度是 O(n^2)，平均复杂度是 O(nlogn)，是不稳定的排序 快速排序 点击看答案 快速排序的思想是分治思想。假设我们现在对“6 1 2 7 9 3 4 5 10 8”这10个数进行排序。首先在这个序列中随便找一个数作为基准数，为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边。得到一个一个以6为中心的序列，再以6为界限，将左右两边都看成数组，分别按照刚才的方法排序。上个图会比较直观： 代码如下： 1234567891011121314151617181920212223242526272829303132333435public static void quickSort(int[] arr,int low,int high)&#123; int i,j,temp,t; if(low&gt;high)&#123; return; &#125; i=low; j=high; //temp就是基准位 temp = arr[low]; while (i&lt;j) &#123; //先看右边，依次往左递减 while (temp&lt;=arr[j]&amp;&amp;i&lt;j) &#123; j--; &#125; //再看左边，依次往右递增 while (temp&gt;=arr[i]&amp;&amp;i&lt;j) &#123; i++; &#125; //如果满足条件则交换 if (i&lt;j) &#123; t = arr[j]; arr[j] = arr[i]; arr[i] = t; &#125; &#125; //最后将基准为与i和j相等位置的数字交换 arr[low] = arr[i]; arr[i] = temp; //递归调用左半数组 quickSort(arr, low, j-1); //递归调用右半数组 quickSort(arr, j+1, high);&#125; 快排的平均时间复杂度是 O(nlogn) ，最坏情况下为 O(n^2)，这种交换方式导致它是不稳定的排序。 堆排序 点击看答案 堆排序是一种选择排序。 堆排序时，先构建堆(假设大顶堆)，将数组转换成堆，数据在堆中是按层编号的，所以数组中一个编号为 i 的结点的子结点在 2i + 1 和 2i + 2 的位置。开始构建时，首先从最后一个非叶子结点开始(叶子结点不用调，叶子结点只是非叶子结点比较时被动移动)，最后一个非叶子节点的位置在 n/2-1。 构建了大顶堆后，堆顶元素与末尾元素交换，将大元素“沉”到末尾，将除尾部以外的元素再构建大顶堆，如此循环，每次找到最大的下沉的后面。 12345678910111213141516171819202122232425262728293031323334353637383940414243private static void heapSort(int[] arr)&#123; int arrLen = arr.length; int temp; //建立大顶堆 for (int i = arrLen/2 -1;i&gt;=0;i--)&#123; //从第一个非叶子结点(在 arrLen/2 -1 处)从下至上，从右至左调整结构 adjustHeap(arr,i,arrLen); &#125; for (int j = arrLen -1;j &gt;= 0;j--)&#123; //将堆顶元素与末尾元素进行交换 temp = arr[0]; arr[0] = arr[j]; arr[j] = temp; //重新对堆进行调整 adjustHeap(arr,0,j); &#125;&#125;private static void adjustHeap(int[] arr,int start,int end)&#123; //先取出当前元素i int temp = arr[start]; for (int k = 2*start + 1;k &lt; end;k = 2*k + 1)&#123;//从i结点的左子结点(2i+1处)开始 if (k + 1 &lt; end &amp;&amp; arr[k] &lt; arr[k + 1])&#123;//如果左子结点小于右子结点，k指向右子结点 k ++; &#125; //如果子节点大于父节点，将子节点值赋给父节点（不用进行交换） if (arr[k] &gt; temp) &#123; arr[start] = arr[k]; start = k; &#125;else &#123; break; &#125; &#125; //将temp值放到最终的位置 arr[start] = temp;&#125; 它的最坏，最好以及平均复杂度都是 O(nlogn)，它是不稳定排序。 以上内容参考自他人的博客 归并排序 点击看答案 归并排序是基于 分治法 实现的。目前还看不大懂，后续再理解 1234567891011121314151617181920212223242526272829303132 //非递归算法实现二路归并排序，length代表数组长度，即数组最大下标是 legth - 1void mergeSort(int List[],int length)&#123; int size = 1; int low; int mid; int high; //size 是标记当前各个归并序列的high-low，从1，2，4，8，……，2*size while(size &lt;= length - 1)&#123; //从第一个元素开始扫描，low代表第一个分割的序列的第一个元素 low = 0; //当前的归并算法结束的条件 while(low + size &lt;= length - 1)&#123; //mid代表第一个分割的序列的最后一个元素 mid = low + size - 1; //high 代表第二个分割的序列的最后一个元素 high = mid + size; //判断一下：如果第二个序列个数不足size个 if(high &gt; length - 1)&#123; //调整 high 为最后一个元素的下标即可 high = length - 1; &#125; //调用归并函数，进行分割的序列的分段排序 merge(List, low, mid, high); //打印出每次归并的区间 cout &lt;&lt; \"low:\" &lt;&lt; low &lt;&lt; \" mid:\" &lt;&lt; mid &lt;&lt; \" high:\" &lt;&lt; high &lt;&lt; endl; //下一次归并时第一序列的第一个元素位置 low = high + 1; &#125;// end of while //范围扩大一倍，二路归并的过程 size *= 2; &#125;&#125; 归并的思想主要用于外部排序：外部排序可分两步①待排序记录分批读入内存，用某种方法在内存排序，组成有序的子文件，再按某种策略存入外存。②子文件多路归并，成为较长有序子文件，再记入外存，如此反复，直到整个待排序文件有序。 总结上述排序，稳定的排序有：冒泡、插入、合并 ，不稳定排序：选择、shell、快排、堆排","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题-算法-二叉树遍历","slug":"面试题-算法-二叉树遍历","date":"2019-03-03T12:10:00.000Z","updated":"2020-03-22T09:48:50.046Z","comments":true,"path":"2019/03/03/面试题-算法-二叉树遍历/","link":"","permalink":"https://glassx.gitee.io/2019/03/03/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/","excerpt":"二叉树遍历先序遍历 点击看答案 递归方法： 1234567891011void pre(BTreeNode treeNode)&#123; if(treeNode != null)&#123; //显示节点数据 showNodeValue(treeNode); //先序遍历左子树 pre(treeNode.left); //先序遍历右子树 pre(treeNode.right) &#125;&#125; 非递归方法： 123456789101112131415161718192021222324252627//非递归，手算的思想，先变访问边找，找到最左下方的，然后向上再向访问右边的public static void iterativePreOrder(TreeNode p) &#123; if (p == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while (!stack.empty() || p != null) &#123; while (p != null) &#123; visit(p); stack.push(p); p = p.left; &#125; p = stack.pop(); p = p.right; &#125;&#125;//栈的思想，按层次倒着进栈，利用后进先出解决顺序问题public static void iterativePreOrder_2(TreeNode p) &#123; if (p == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); stack.push(p); while (!stack.empty()) &#123; p = stack.pop(); visit(p); if (p.right != null) stack.push(p.right); if (p.left != null) stack.push(p.left); &#125;&#125;","text":"二叉树遍历先序遍历 点击看答案 递归方法： 1234567891011void pre(BTreeNode treeNode)&#123; if(treeNode != null)&#123; //显示节点数据 showNodeValue(treeNode); //先序遍历左子树 pre(treeNode.left); //先序遍历右子树 pre(treeNode.right) &#125;&#125; 非递归方法： 123456789101112131415161718192021222324252627//非递归，手算的思想，先变访问边找，找到最左下方的，然后向上再向访问右边的public static void iterativePreOrder(TreeNode p) &#123; if (p == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while (!stack.empty() || p != null) &#123; while (p != null) &#123; visit(p); stack.push(p); p = p.left; &#125; p = stack.pop(); p = p.right; &#125;&#125;//栈的思想，按层次倒着进栈，利用后进先出解决顺序问题public static void iterativePreOrder_2(TreeNode p) &#123; if (p == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); stack.push(p); while (!stack.empty()) &#123; p = stack.pop(); visit(p); if (p.right != null) stack.push(p.right); if (p.left != null) stack.push(p.left); &#125;&#125; 中序遍历 点击看答案 递归方法： 12345678910public static void middle(BTreeNode treeNode)&#123; if(treeNode != null)&#123; //中序遍历左子树 middle(treeNode.left); //显示节点数据 showNodeValue(treeNode); //中序遍历右子树 middle(treeNode.right); &#125;&#125; 非递归方法： 12345678910111213public static void iterativeInOrder(TreeNode p) &#123; if (p == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while (!stack.empty() || p != null) &#123; while (p != null) &#123; stack.push(p); p = p.left; &#125; p = stack.pop(); visit(p); p = p.right; &#125;&#125; 后序遍历 点击看答案 递归方法： 1234567891011public static void behind(BTreeNode treeNode)&#123; if(treeNode != null)&#123; //后序遍历左子树 behind(treeNode.left); //后序遍历右子树 behind(treeNode.right); //显示节点数据 showNodeValue(treeNode); &#125;&#125; 非递归方法： 123456789101112131415161718//双栈法，易于理解public static void iterativePostOrder_3(TreeNode p) &#123; if (p == null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); Stack&lt;TreeNode&gt; result = new Stack&lt;TreeNode&gt;(); while (!stack.empty() || p != null) &#123; while (p != null) &#123; stack.push(p); result.push(p); p = p.right; &#125; if (!stack.empty()) p = stack.pop().left; &#125; while (!result.empty()) &#123; p = result.pop(); visit(p); &#125;&#125; 层次遍历 点击看答案 1234567891011public static void iterativeLevelOrder(TreeNode p) &#123; if (p == null) return; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(p); while (!queue.isEmpty()) &#123; p = queue.poll(); if (p.left != null) queue.offer(p.left); if (p.right != null) queue.offer(p.right); visit(p); &#125;&#125; 以上内容可以参考这篇博客","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题-算法-经典问题解决","slug":"面试题-算法-经典问题解决","date":"2019-03-02T12:10:00.000Z","updated":"2020-03-08T04:56:35.445Z","comments":true,"path":"2019/03/02/面试题-算法-经典问题解决/","link":"","permalink":"https://glassx.gitee.io/2019/03/02/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"扑克洗牌算法打乱一个已有顺序有多种实现方式，但是要高效地实现，还需要斟酌，以下是目前能想到的最有的解决方案：1234567891011//生成一副牌Card[52] oneCard = generateOneCard;//顺序与 随机位置交换Random r = new Random();for (int i = 0; i &lt; oneCard.size(); i ++)&#123; int j = r.nextInt(52); Card tempCard = oneCard[i]; oneCard[i] = onCard[j]; onCard[j] = tempCard;&#125;","text":"扑克洗牌算法打乱一个已有顺序有多种实现方式，但是要高效地实现，还需要斟酌，以下是目前能想到的最有的解决方案：1234567891011//生成一副牌Card[52] oneCard = generateOneCard;//顺序与 随机位置交换Random r = new Random();for (int i = 0; i &lt; oneCard.size(); i ++)&#123; int j = r.nextInt(52); Card tempCard = oneCard[i]; oneCard[i] = onCard[j]; onCard[j] = tempCard;&#125; 判断链表中是否有环快慢指针法：创建两个指针1和2同时指向这个链表的头节点，然后两个指针分别向后移动，其中指针1每次向后移动一个节点，指针2每次向后移动两个节点，每移动一次就比较两个指针指向的节点是否相同，如果相同说明出链表有环；如果不同，则继续循环，直到有环结束或者到达尾部结束。 原理：两个人在环形跑道上同一位置开始跑，一人速度快，一人速度慢，如此持续跑一段时间，速度快的那个肯定会从速度慢的身后再次追上以及超越，这中间必然有个交汇点。如果是跑直线的话，到终点就结束了，不会再碰面。 1234567891011121314151617//判断是否有环public static &lt;T&gt; boolean isLoopList(ListNode&lt;T&gt; head)&#123; ListNode&lt;T&gt; slowPointer, fastPointer; //使用快慢指针，慢指针每次向前一步，快指针每次两步 slowPointer = fastPointer = head; while(fastPointer != null &amp;&amp; fastPointer.next != null)&#123; slowPointer = slowPointer.next; fastPointer = fastPointer.next.next; //两指针相遇则有环 if(slowPointer == fastPointer)&#123; return true; &#125; &#125; return false;&#125; 引申：如何判断环的入口我们假定链表头到环入口的距离是len，环入口到slow和fast交汇点的距离为x，环的长度为R。slow和fast第一次交汇时，设slow走的长度为：d = len + x，而fast走的长度为：2d = len + nR + x，(n &gt;= 1)，从而我们可以得知：2len + 2x = len + nR + x，即len = nR - x，(n &gt;= 1)。所以，要找出环入口，也要两个指针，一个指针A指向相遇时候的节点，一个指针B指向链表头，两个指针每次都走一步，A指针在遍历过程中可能多次(n &gt;= 1)经过环入口节点，但当B指针第一次达到入口节点时，A指针此时必然也指向入口节点。 123456789101112131415161718192021222324252627282930313233//判断是否有环，有环就返回入口public static &lt;T&gt; ListNode&lt;T&gt; findEntranceInLoopList(ListNode&lt;T&gt; head)&#123; ListNode&lt;T&gt; slowPointer, fastPointer; //使用快慢指针，慢指针每次向前一步，快指针每次两步 boolean isLoop = false; slowPointer = fastPointer = head; while(fastPointer != null &amp;&amp; fastPointer.next != null)&#123; slowPointer = slowPointer.next; fastPointer = fastPointer.next.next; //两指针相遇则有环 if(slowPointer == fastPointer)&#123; isLoop = true; break; &#125; &#125; //一个指针从链表头开始，一个从相遇点开始，每次一步，再次相遇的点即是入口节点 if(isLoop)&#123; slowPointer = head; while(fastPointer != null &amp;&amp; fastPointer.next != null)&#123; //两指针相遇的点即是入口节点 if(slowPointer == fastPointer)&#123; return slowPointer; &#125; slowPointer = slowPointer.next; fastPointer = fastPointer.next; &#125; &#125; return null;&#125; 再引申，两个单链表是否相交两个没有环的链表在某一节点相交，那么在这个节点之后的所有结点都是两个链表所共有的。如果它们相交，则最后一个结点一定是共有的，因此问题转化为：两个链表最后一个结点是否相同（时间复杂度为O(len1+len2)）。要找出相交的第一个结点，可以首先获得两个链表的长度，然后获得两个链表长度差值 K，之后长的链表指向第K个结点，短的链表从头开始，每次向后移动一个结点，再比较当前结点是否相等，第一次相等的那个结点点就是相交节点。 代码略","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"面试题-算法-类似行测","slug":"面试题-算法-类似行测","date":"2019-03-01T12:10:00.000Z","updated":"2020-03-08T07:17:57.509Z","comments":true,"path":"2019/03/01/面试题-算法-类似行测/","link":"","permalink":"https://glassx.gitee.io/2019/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%AE%97%E6%B3%95-%E7%B1%BB%E4%BC%BC%E8%A1%8C%E6%B5%8B/","excerpt":"1、给100盏灯编号 1~100，开始时所有灯都是关着的第1次：把所有编号是1的倍数的灯的开关状态改变一次；第2次：把所有编号是2的倍数的灯的开关状态改变一次；第3次，把所有编号是3的倍数的灯的开关状态改变一次；…第100次，把所有编号是100的倍数的灯的开关状态改变一次；问：最后开着的灯的编号是哪些？","text":"1、给100盏灯编号 1~100，开始时所有灯都是关着的第1次：把所有编号是1的倍数的灯的开关状态改变一次；第2次：把所有编号是2的倍数的灯的开关状态改变一次；第3次，把所有编号是3的倍数的灯的开关状态改变一次；…第100次，把所有编号是100的倍数的灯的开关状态改变一次；问：最后开着的灯的编号是哪些？ 分析：最开始灯是灭的，因此只有经过奇数次开关状态改变，灯才会是亮的。从题意可知一个数字有多少约数就会状态改变多少次，因此这道题可以转换为：1~100数字中约数个数是奇数的有哪些。并且我们知道约数是成对出现的，如8的约数：（1，8）、（2，4），因此如果要出现约数的个数是奇数个，除非它是个平方数，如36的约数：（1，36）、（2，18）、（3，12）、（4，9）、（6），因此，这题又可以转换为1~100数字中的平方数有哪些，这操作。。。。666吧，这就是分析问题的乐趣吧 2、烧一根不均匀的绳子，从头烧到尾总共需要1小时，现在有若干条这样的绳子，问如何用烧绳子的方法来计时1小时15分钟呢 从题目知道，绳子不均匀，不能根据燃烧半根来计量半小时。但是还可以推断，从两头烧，只要半小时。因此可以使用3根绳子来计时：1）第1根绳子点燃两端，第2根绳子点燃一端，第三根绳子先不点燃； 2）第1根绳子烧完计时30分钟，接着第2根绳子另一端也点燃 3）第2根绳子烧完计时15分钟，此时已经计时45分钟了，剩下的半小时只需要将第3条绳子两端点燃就能计算出。 3、有12个外观一样的小球，但有一个与其他小球重量略微不同，用手感觉不出来，用一个天平，能称3次就能找到那个小球吗 把小球编号 112，然后分为3组（想想为什么是3组）：14分为A组，58分为B组，912分为C组。首先A组和B组称量比较：1、天平平衡。则目标小球在C组。将C分为两组：9、10、11分为一组C1，12分为一组C2，再从B中随意拿出3个球分组为B1，C1和B1比较： 1）若平衡，则12号球就是目标球。 2）若不平衡，则目标球在C1内，并且根据天平倾斜，可以判断目标球比普通球重还是轻（若是天平显示B1重，则目标球比较轻；反之目标球比较重），此时随意取 C1 中的2个球放在天平上即可知道结果（如果平衡，则目标球是另一个，如果不平衡，根据轻重可知目标球）。2、天平不平衡。则目标球在A或者B中。 1）若A &gt; B,取（1，2，3，5）为一组X,(4,9,10,11)为一组Y，（6，7，8）为一组Z，比较X和Y，若X&gt;Y，可知不同小球在1，2，3中，且目标球重于普通球，此时再将编号 1，2，3 任取2个放上天平即可知道目标球。若X&lt;Y,则说明4号是目标球；若X=Y，则目标球在Z中（6，7，8），并且目标球轻于普通球，此时只需要将编号 其中任意两个球放上天平即可找出目标球。 2）若 A &lt; B，同样按照上述分为X、Y、Z三组，同理，若X&lt;Y，则目标球在1，2，3中，且目标球轻于普通球，此时再将编号 1，2，3 任取2个放上天平即可知道目标球；若X&gt;Y,说明4号为目标球，若X=Y，则目标球在Z中（6，7，8），并且目标球重于普通球，此时再将编号 6，7，8 任取2个放上天平即可知道目标球。 3、一笔画出经过9个点的4条直线 主要是要突破点，不要局限于点上，不说了，直接上图：9点4线 4、有1块钱1瓶的契税，喝完后2个空瓶换一瓶汽水，问有20块钱，可以喝几瓶汽水？ 总共40瓶（不要浪费最后那个空瓶，找老板借1个，凑2瓶子再喝一瓶，最后这空瓶还给老板。。。） 5、时针分针秒针重合的次数 只有2次，一次是 00:00:00 一次是 12：00：00 假设排列100个球，两个人轮流一拿球装入口袋，能拿到第100个球为胜，条件是每次拿球至少拿1个，最多拿5个，加入你是最先拿球的人，你该拿几个，以后怎么保证拿到最后一个球？ 怎样保证拿到最后一个球呢？最简单的方法是最后剩下6个，并且轮到对方来拿，这样无论对方拿几个，都能保证自己拿到最后一个。（1）首先，要控制每一轮拿出的个数，但是对方拿的个数是不受控制的，假设对方拿n个，自己就拿6-n个（为什么是控制总数是6个，是因为对手最多拿5个，自己最少能拿1个，和值就是6，自己不能把和值控制得更低；而对手至少拿1个，自己最多拿5个，同样自己不能把和值控制得更高。因此只有6才是一个可控的值）。（2）其次，假设第一次拿x个球，以后每次自己和对方拿的和是6，最多可以拿到15轮（除去第一轮的x个，最后留这肯定少于10个了），还剩 10-x个，为了达到之前定的目标最后留6个，所以x应该是4.（3）总结而言就是第一次拿4个，以后每次对方拿了n个后，自己拿 6-n 个。 如何确定用户异地登陆。","categories":[{"name":"面试","slug":"面试","permalink":"https://glassx.gitee.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://glassx.gitee.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Android 事件分发机制","slug":"Android 事件分发机制","date":"2019-02-25T14:00:00.000Z","updated":"2019-11-17T13:59:30.482Z","comments":true,"path":"2019/02/25/Android 事件分发机制/","link":"","permalink":"https://glassx.gitee.io/2019/02/25/Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/","excerpt":"Android 事件分发机制Android 事件分发机制总体来说可以用几张图说明白，相比在代码中打印Log，这种方式更容易理解和记住。针对 ACTION_DOWN 事件只针对 ACTION_DOWN 事件时，事件的完整流向是一个U形图，如下图所示：如果没有中断事件，可能看起来更直观一些，Activity、ViewGroup、View的层次更加清晰：","text":"Android 事件分发机制Android 事件分发机制总体来说可以用几张图说明白，相比在代码中打印Log，这种方式更容易理解和记住。针对 ACTION_DOWN 事件只针对 ACTION_DOWN 事件时，事件的完整流向是一个U形图，如下图所示：如果没有中断事件，可能看起来更直观一些，Activity、ViewGroup、View的层次更加清晰： 针对 ACTION_MOVE 和 ACTION_UP上面讲解的都是针对ACTION_DOWN的事件传递，ACTION_MOVE和ACTION_UP在传递的过程中并不是和ACTION_DOWN 一样，你在执行ACTION_DOWN的时候返回了false，后面一系列其它的action就不会再得到执行了。简单的说，就是当dispatchTouchEvent在进行事件分发的时候，只有前一个事件（如ACTION_DOWN）返回true，才会收到ACTION_MOVE和ACTION_UP的事件。 ViewGroup1 的dispatchTouchEvent 中返回true消费事件红色的箭头代表ACTION_DOWN 事件的流向，蓝色的箭头代表ACTION_MOVE 和 ACTION_UP 事件的流向： ViewGroup2 的dispatchTouchEvent 中返回true消费事件 在View 的dispatchTouchEvent 返回true消费事件,就不画图了，效果和在ViewGroup2 的dispatchTouchEvent return true的差不多，同样的收到ACTION_DOWN 的dispatchTouchEvent函数都能收到 ACTION_MOVE和ACTION_UP。 在View 的onTouchEvent 中返回true消费事件 在ViewGroup 2 的onTouchEvent 中返回true消费事件 在ViewGroup 1 的onTouchEvent 中返回true消费事件 在View的dispatchTouchEvent 中返回false并且ViewGroup 1 的onTouchEvent 返回true消费事件 在View的dispatchTouchEvent 中返回false并且Activity 的onTouchEvent 返回true消费事件 经过这么多图能得出以下规律： ACTION_DOWN事件在哪个控件消费了（return true）， 那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传，如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。 以上文章参考自 Kelin ,这里图片形式贴出来仅仅只是个人做的笔记，方便记忆。","categories":[{"name":"专题","slug":"专题","permalink":"https://glassx.gitee.io/categories/%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"Android机制","slug":"Android机制","permalink":"https://glassx.gitee.io/tags/Android%E6%9C%BA%E5%88%B6/"}]},{"title":"黑苹果折腾记","slug":"黑苹果折腾记","date":"2019-02-16T14:10:00.000Z","updated":"2019-11-17T13:45:21.839Z","comments":true,"path":"2019/02/16/黑苹果折腾记/","link":"","permalink":"https://glassx.gitee.io/2019/02/16/%E9%BB%91%E8%8B%B9%E6%9E%9C%E6%8A%98%E8%85%BE%E8%AE%B0/","excerpt":"过年在家没啥事干，折腾了下黑苹果，安装上了 OSX 10.14.3，整个过程还算顺利，最终除了睡眠和声卡之外，其他貌似ok，目前用来开发（Android studio 以及 XCode）没啥问题。此次记录主要是为了在以后还有闲心折腾黑苹果的时候，能拿出来参考，不至于从头开始爬帖。首先，以一个过来人的身份告诉你，搞黑苹果如果不上 www.tonymacx86.com 网站的话，等于白折腾，这上面有最简便的最新的折腾黑苹果的方法，在国内远景论坛、黑苹果社区等地方看到的清一色古老的安装方式，甚至还有变色龙安装法。不要害怕 English，对于搞黑苹果而言，只需要很简单的英语水平。我这次安装10.14.3参考的就是这个帖子，只要一步步来，基本上是没什么问题的。","text":"过年在家没啥事干，折腾了下黑苹果，安装上了 OSX 10.14.3，整个过程还算顺利，最终除了睡眠和声卡之外，其他貌似ok，目前用来开发（Android studio 以及 XCode）没啥问题。此次记录主要是为了在以后还有闲心折腾黑苹果的时候，能拿出来参考，不至于从头开始爬帖。首先，以一个过来人的身份告诉你，搞黑苹果如果不上 www.tonymacx86.com 网站的话，等于白折腾，这上面有最简便的最新的折腾黑苹果的方法，在国内远景论坛、黑苹果社区等地方看到的清一色古老的安装方式，甚至还有变色龙安装法。不要害怕 English，对于搞黑苹果而言，只需要很简单的英语水平。我这次安装10.14.3参考的就是这个帖子，只要一步步来，基本上是没什么问题的。 这个帖子主要条理清晰地通过5步，即完成了黑苹果的安装：Step 1: Download macOS Mojave（第一步：下载系统）Step 2: Create a Bootable USB with UniBeast（第二步：通过 UniBeast 制作 U盘启动盘）Step 3: Recommended BIOS Settings（第三步：设置 BIOS ）Step 4: Install macOS Mojave(第四步：安装系统)Step 5: Post Installation with MultiBeast（第五步：二次安装） 在开始之前，首先申请 tonymacx86.com 的账号，然后 在从那里下载最新的 UniBeast 和 MultiBeast 工具，之后准备一个 32GB 的U盘吧，教程上面说 16G 以上就够了，但实际上是不够的。其中，UniBeast 的作用是 创建一个可以正常启动10.14.3 的 U盘启动盘。 第一步 下载系统为了全新安装，首先可以从其他苹果系统里面下载系统，在苹果系统中： 打开 App Store -&gt; 下载macos Mojave 更新，下载完成后，在 Applications(应用)里面能够找到它。 第二步 用 UniBeast 创建启动U盘在第二步之前，首先备份好U盘的东西，因为制作启动盘会删除U盘中所有内容。 把U盘插到电脑上，打开：Application（应用）-&gt;Utilities（工具）-&gt; Disk Utility（磁盘工具）,从左边选中你的那个U盘，在Mojava或者更高版本中，可能你首先要设置 View(视图)-&gt;Show All Devices(显示所有设备)，才能看到你的U盘。之后执行 1、 点击 Erase（抹掉）按钮2、填写名称，目前先命名为 USB3、在Format（格式）的地方选择 Mac os Extended(Journaled)4、最后，点击 Erase（抹掉） 按钮正式抹掉 接下来，安装你下载的 UniBeast （这里貌似要求语言是English，否则还装不上，如果有这个要求，改下系统语言就行了），只要一直continue 下去就行，之后同意协议，最后选择安装的 Destination（目的磁盘）的时候，选择刚才抹掉的 USB盘 即可；在 select os Installation （选择安装系统）界面时，选择 Mojave 就行，之后在 Bootloader Options 界面选择 UEFI Boot Mode（根据需要有可能要选择 Legacy Boot Mode）。最后 Graphics Configuration 是可选的，可以根据你的显卡来对应设置。最后确认你的安装选项，输入密码，然后 Install。这时候大概要等待个10分钟，系统会写完。 系统完全写入U盘之后，把下载的 MultiBeast 软件拖到 U 盘，因为安装好之后需要它。 第三步 设置BIOS这里只针对UEFI 方式的BIOS 了（其他方式请参考原文了）。进入到 BIOS 设置中，如果CPU支持 VT-d，将其设置为 disable，CFG-Lock、Secure Boot Mode 、IO Serial Port 也 disable，设置 XHCI 为 Enable，设置 OS 为 Other OS。 第四步 安装 macOS Mojave将U盘插在电脑的USB2.0口上，这点特别要注意，不然第二次安装的时候会提示找不到resource，我就在这里折腾了两回才知道。开机，选择从你的 USB 盘启动（不同的电脑主板不一样，网上搜下即可）。在clover界面，通过键盘上的左右箭头（键盘右下角的上下左右箭头）选择 Boot OS X Install from macOS Mojave 在安装界面，首先选择顶部菜单栏的 Utilities（工具），再打开 Disk Utility（磁盘工具），在左边选中你想要安装系统的分区，之后像之前抹掉U盘那样抹掉这个分区，名字命名为 Mojave（之后你可以改这个名字），之后关闭Disk Utility（磁盘工具），即可继续安装。 安装的时候会提示安装到哪个盘，选择刚才抹掉的 Mojave 盘，之后会继续安装，待安装完成后会自动重启。 第五步在重启的时候要注意再次选择从U盘启动，之后在clover界面选择Mojave，之后就会自动安装，引导设置，完成。之后的事情就是安装驱动了，去论坛找各种kext即可，声卡可能就麻烦些，可能需要dsdt，这里就不细说。 问题集锦休眠导致键盘不可用如果是笔记本并且安装的是双系统（win + mac os），那么如果驱动对休眠的处理不好的话，在mac osx下发生休眠可能会导致系统重启，可能会重启进入windows系统，此时，你的键盘应该是不可用的。解决方案包括以下几个步骤： 启动windows ，在登录界面使用 “轻松使用-屏幕键盘” 的方式输入密码。 在windows 下使用 easyUefi 软件将 黑苹果的 efi 启动序列列为第一个，这样我们开机就会启动 clover。 重启系统，进入clover，此时键盘应该是不可以使用的，左右光标也是没作用的。如果能够看到你要启动的分区，则用鼠标点击直接启动，进入mac os 后，正常关闭，键盘就能正常使用了。 如果未能看到需要启动的分区，此时按字母 A 键，就会进入clover 的 “关于” 页面（这个我只在我电脑上试过，我在尝试按 A 或者 D 的时候发现的，对其他电脑的未做验证），此时，你的电脑键盘应该就可以使用了。这时候就可以退出“关于”页，之后进入黑苹果。 以上操作的主要目的是要正常关闭mac os ，这样键盘才能使用（在 mac os 或者 windows 下）。","categories":[{"name":"linux","slug":"linux","permalink":"https://glassx.gitee.io/categories/linux/"}],"tags":[{"name":"黑苹果","slug":"黑苹果","permalink":"https://glassx.gitee.io/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"}]},{"title":"第五章——理解 RemoteViews","slug":"Android 开发艺术探索-第5章","date":"2018-12-10T14:00:00.000Z","updated":"2019-11-17T13:43:49.306Z","comments":true,"path":"2018/12/10/Android 开发艺术探索-第5章/","link":"","permalink":"https://glassx.gitee.io/2018/12/10/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%AC5%E7%AB%A0/","excerpt":"从字面可以看出这应该是一种远程view，与远程service概念一样，RemoteViews表示的是一种view结构，这种view能够在其他进程显示。由于需要跨进程显示，RemoteViews结构提供了一组基础功能用于跨进程更新View。RemoteViews在Android中有2种应用场景：Notification以及桌面小部件。","text":"从字面可以看出这应该是一种远程view，与远程service概念一样，RemoteViews表示的是一种view结构，这种view能够在其他进程显示。由于需要跨进程显示，RemoteViews结构提供了一组基础功能用于跨进程更新View。RemoteViews在Android中有2种应用场景：Notification以及桌面小部件。 RemoteViews的应用平时的开发过程中，Notifications主要通过NotificationManager的notify方法实现的，它除了默认效果外，还可以另外定义布局。使用RemoteViews实现通知栏时无法像Activity里面一样直接更新View，这是因为RemoteView界面运行在其他进程中，确切来说是系统的SystemServer进程。使用系统默认的样式弹出一个通知是很简单的： 1234567891011121314151617181920212223Notification notification = newNotification();notification.icon = R.drawable.icon;notification.tickerText = \"hello world\";notification.when = System.currentTimeMillis();notification.flags = Notification.FLAG_AUTO_CANCEL;Intent intent = new Intent(this,DemoActivity_1.class);PendingIntent pendingIntent = PendingIntent.getActivity(this,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);//使用普通样式展示一个通知notification.setLatestEventInfo(this,\"chapter_5\",\"this is notification\",pendingIntent);NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);manager.notify(1,notification);//使用RemoteViews的方式展示第一个通知RemoteViews remoteViews = new RemoteViews(getPackageName(),R.layout.layout_notification);remoteViews.setTextViewText(R.id.msg,\"chapter_5\");remoteViews.setImageViewResource(R.id.icon,R.drawable.icon1);PendingIntent openActivity2PendingIntent = PendingIntent.getActivity(this,0,new Intent(this,DemoActivity_2.class),PendingIntent.FLAG_UPDATE_CURRENT);remoteViews.setOnclickPendingIntent(R.id.open_activity2,openActivity2PendingIntent);notification.contentView = remoteViews;notification.contentIntent = pendingIntent;NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);manager.notify(2,notification); 以上代码展示只要提供当前应用的包名以及布局文件的id即可创建一个RemoteViews对象，而更新RemoteViews，由于无法直接访问里面的view，因而只能通过RemoteViews提供的一系列方法来更新，比如设置文本，需要采用 remoteViews.setTextViewText(R.id.msg,”chapter_5”) ，而更新图片则采用 remoteViews.setImageViewResource(R.id.icon,R.drawable.icon1)，如果要给一个控件添加click事件，则要使用PendingIntent并且通过setOnclickPendingIntent。关于PendingIntent，它表示一种待定的Intent，这个Intent中所包含的意图必须由用户来出发。 RemoteViews在桌面小部件上的应用、PendingIntent概述、RemoteViews的内部机制等内容 待后续有集中的时间再添加","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://glassx.gitee.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"}]},{"title":"第9章-单元测试","slug":"从小工到专家-第九章","date":"2018-10-17T14:30:00.000Z","updated":"2019-11-17T13:48:25.422Z","comments":true,"path":"2018/10/17/从小工到专家-第九章/","link":"","permalink":"https://glassx.gitee.io/2018/10/17/%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6-%E7%AC%AC%E4%B9%9D%E7%AB%A0/","excerpt":"照例，如果自学不需要看我这个博客的话，资料如下：官网关于Android Test的介绍的地址Android官方关于测试的例子 ，需要的自取单元测试、集成测试、黑盒测试、白盒测试等，只有单元测试是我们开发人员需要自己完成的，其余都是由测试人员完成的。单元测试本质上也是代码，是验证代码正确性的代码。为什么要做单元测试","text":"照例，如果自学不需要看我这个博客的话，资料如下：官网关于Android Test的介绍的地址Android官方关于测试的例子 ，需要的自取单元测试、集成测试、黑盒测试、白盒测试等，只有单元测试是我们开发人员需要自己完成的，其余都是由测试人员完成的。单元测试本质上也是代码，是验证代码正确性的代码。为什么要做单元测试 便于后期重构。单元测试为后期测试提供了保障，在重构之后，只要单元测试还是全部通过，那么在很大程度上表示重构没有引入新的bug。 优化设计。编写单元测试将使开发者从调用者的角度观察和思考，这样迫使开发者把程序设计成易于调用和低耦合的易测试的形式。 避免代码出现回归。编写完成后，可以随时随地快速运行测试，而不是要求将代码部署到设备上，再手动执行覆盖各种路径。 文档记录。单元测试是极好的“官方文档”，它展示函数或者类如何使用。 Android 测试类型(选自官网)测试代码的位置取决于您要编写的测试的类型。 Android Studio 为以下两种测试类型提供了源代码目录（源集）： 本地单元测试位于 module-name/src/test/java/目录。 这些测试在计算机的本地 Java 虚拟机 (JVM) 上运行。 当您的测试没有 Android 框架依赖项或当您可以模拟 Android 框架依赖项时，可以利用这些测试来尽量缩短执行时间。 在运行时，这些测试的执行对象是去掉了所有 final 修饰符的修改版 android.jar。 这样一来，您就可以使用 Mockito 之类的常见模拟库。 Instrumented测试（仪器测试）位于 module-name/src/androidTest/java/。 这些测试在硬件设备或模拟器上运行。 这些测试有权访问 Instrumentation API，让您可以获取某些信息（例如您要测试的应用的 Context）， 并且允许您通过测试代码来控制受测应用。 可以在编写集成和功能 UI 测试来自动化用户交互时，或者在测试具有模拟对象无法满足的 Android 依赖项时使用这些测试。 由于仪器测试内置于 APK 中（与您的应用 APK 分离），因此它们必须拥有自己的 AndroidManifest.xml 文件。 不过，由于 Gradle 会自动在构建时生成该文件，因此它在您的项目源集中不可见。 您可以在必要时（例如需要为 minSdkVersion 指定其他值或注册测试专用的运行侦听器时）添加自己的清单文件。 构建应用时，Gradle 会将多个清单文件合并成一个清单。 Gradle 构建解读这些测试源集的方式与其解读项目应用源集的方式相同，您可以利用这一点根据构建变体创建测试。 以下示意图诠释了两种测试的代码结构（图中1表示的是仪器测试的代码，2表示的是单元测试的代码结构） Junit4在Android测试框架中，常用的有以下几个框架和工具类：JUnit4、AndroidJUnitRunner、Mockito、Espresso，其中主要的单元测试使用Junit4。Junit4是一套基于注解的单元测试框架，在Android studio中，编写在test目录下的测试类都是基于该框架实现，该目录下的代码直接运行在本地的JVM上，不需要Android真机或者模拟器支持。常用的注解如下(更多内容可以查看Junit4官网)： @BeforeClass 测试类里所有用例运行之前，运行一次这个方法。方法必须是public static void @AfterClass 与BeforeClass对应 @Before 在每个用测试例运行之前都运行一次。 @After 与Before对应 @Test 指定该方法为测试方法，方法必须是public void @RunWith 测试类名之前，用来确定这个类的测试运行器以下用一个简单的测试类来展示测试类的大概形式： 123456789101112131415public class CaculatUtilTest&#123; private CaculatUtil mCaculatUtil; @Before public void setUp()&#123; mCaculatUtil = new CaculatUtil(); &#125; @Test public void addTwoNumbers()&#123; assertEquals(3,mCaculatUtil.add(1,2)); //或者如果是静态方法，就类似于以下这种静态调用方法 assertEquals(3,Caculator.add(1,2)); &#125;&#125; Junit的断言和失败提示Junit提供了多个以assert开头的函数，分别用来验证各类相等性质的问题，大致有如下几类： assertEquals assertEquals的作用是判断两个值或者对象是否相等。接受2个参数，参数1为预期值，参数2为计算得到的值。 assertTrue 与 assertFalse assertTrue 与 assertFalse顾名思义就是分别验证真与假，只需要一个boolean类型的参数。例如 assertTrue(false)测试会失败， 而 assertTrue(true) 测试通过。 assertNull 与 assertNotNull 和assertTrue、assertFalse类似，只不过是用来判断空或者非空。例如：assertNull(null) 会测试失败，因为值为null；而assertNull(“hell”)就能测试通过。 assertSame 与 assertNotSame assertSame用于判断两个对象是否是同一个对象，与assertEquals不同的是，assertSame强调的为同一个对象，而assertEquals只要两个对象相等即可（即调用equals函数时返回true）。 failNotEquals 函数有3个参数，参数1位失败时提示信息，参数2为期望值，参数3是实际值。当两个对象不相等时抛出参数1的错误信息。 failSame与failNotSame failNotSame与failNotEquals类似，不是同一个对象时就抛出参数1的错误信息。 fail(String) 与 fail() fail(String)直接抛出当前测试用例参数1中的错误信息，而fail()给出默认的错误信息。 运行多个测试类——TestSuite如果需要同时运行两个或多个Test类，JUnit提供了Suite注解，在对应的测试目录下创建一个空Test类： @RunWith(Suite.class)：配置Runner运行环境。 @Suite.SuiteClasses({A.class, B.class})：添加需要一起运行的测试类。 12345@RunWith(Suite.class)@Suite.SuiteClasses(&#123;CalculatorTest.class, CalculatorWithParameterizedTest.class&#125;)public class UnitTestSuite&#123; &#125; 上述代码中，UnitTestSuite成了一个空类，测试类被添加到注解中了。或者，如果不用注解，可以通过JUnit4TestAdapter包装测试类，并将JUnit4TestAdapter对象添加到TestSuit中，示例代码如下： 123456789public class MathTestSuite&#123; public static Test suite()&#123; TestSuite suite = new TestSuite(\"com.book.jtm\"); //添加测试用例 suite.addTest(new JUnit4TestAdapter(AdderTest.class)); suite.addTest(new JUnit4TestAdapter(DiverTest.class)); return suite; &#125;&#125; 上述代码有一个静态的suite函数，它返回一个Test对象，这个对象是TestSuite类型的。测试时，以Junit测试用例的形式运行这个MathTestSuite即可运行这两个测试类。 多个参数输入测试当需要传入多个参数进行测试时，可以使用 @Parameters 来进行单个方法的多次不同参数的测试，对于测试类，使用该方法需要如下步骤： 在测试类上添加@RunWith(Parameterized.class)注解 添加测试类的构造函数 添加获取参数集合的static方法，并在方法上添加@Parameters注解 在需要测试的方法中直接使用成员变量，该变量由JUnit通过构造方法生成 直接上示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637@RunWith(Parameterized.class)//为测试类添加注解public class CaculatUtilTest&#123; //两个传入的参数 private final int paramOne; private final int paramTwo; //期望值 private final int expectResult; private CaculatUtil mCaculatUtil; public CaculatUtilTest(int paramOne,int paramTwo,int expectResult)&#123;//添加构造函数 this.paramOne = paramOne; this.paramTwo = paramTwo; this.expectResult = expectResult; &#125; //添加获取参数集合的static方法，并在方法上添加@Parameters注解 @Parameters public static Collection&lt;Object[]&gt; initTestData()&#123; return Arrays.asList(new Object[][]&#123; &#123;0,0,0&#125;, &#123;1,1,2&#125;, &#123;1,5,6&#125; &#125;); &#125; @Before public void setUp()&#123; mCaculatUtil = new CaculatUtil(); &#125; @Test public void addTwoNumbers()&#123; //测试的方法中直接使用成员变量 assertEquals(expectResult,mCaculatUtil.add(paramOne,paramTwo)); &#125;&#125; AndroidJUnitRunner当单元测试中涉及Android系统库的调用时，可以通过AndroidJUnitRunner方案完成测试，这样就能在测试类中使用Context、parcelable、Shareprefrence等类。使用方法是在androidTest目录下创建测试类（因为这涉及到Instrumented测试的内容），在该类上添加@RunWith(AndroidJUnit4.class)注解。如以下代码示范了如何在测试类中使用SharedPrefrences： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@RunWith(AndroidJUnit4.class)public class SharedPreferencesHelperTest &#123; private static final String TEST_NAME = \"Test name\"; private static final String TEST_EMAIL = \"test@email.com\"; private static final Calendar TEST_DATE_OF_BIRTH = Calendar.getInstance(); private SharedPreferenceEntry mSharedPreferenceEntry; private SharedPreferencesHelper mSharedPreferencesHelper; private SharedPreferences mSharePreferences; /** 上下文 */ private Context mContext; …… @Before public void setUp() throws Exception &#123; //获取application的context mContext = InstrumentationRegistry.getTargetContext(); //实例化SharedPreferences mSharePreferences = PreferenceManager.getDefaultSharedPreferences(mContext); mSharedPreferenceEntry = new SharedPreferenceEntry(TEST_NAME, TEST_DATE_OF_BIRTH, TEST_EMAIL); //实例化SharedPreferencesHelper，依赖注入SharePreferences mSharedPreferencesHelper = new SharedPreferencesHelper(mSharePreferences); //以下是在mock的相关操作，模拟commit失败 mMockSharePreferences = Mockito.mock(SharedPreferences.class); mMockBrokenEditor = Mockito.mock(SharedPreferences.Editor.class); when(mMockSharePreferences.edit()).thenReturn(mMockBrokenEditor); when(mMockBrokenEditor.commit()).thenReturn(false); mMockSharedPreferencesHelper = new SharedPreferencesHelper(mMockSharePreferences); &#125; /** * 测试保存数据是否成功 */ @Test public void sharedPreferencesHelper_SavePersonalInformation() throws Exception &#123; assertThat(mSharedPreferencesHelper.savePersonalInfo(mSharedPreferenceEntry), is(true)); &#125; /** * 测试保存数据，然后获取数据是否成功 */ @Test public void sharedPreferencesHelper_SaveAndReadPersonalInformation() throws Exception &#123; mSharedPreferencesHelper.savePersonalInfo(mSharedPreferenceEntry); SharedPreferenceEntry sharedPreferenceEntry = mSharedPreferencesHelper.getPersonalInfo(); assertThat(isEquals(mSharedPreferenceEntry, sharedPreferenceEntry), is(true)); &#125; ……&#125; 模拟所需要的模块有时我们测试需要依赖于其他的功能模块，但是某些原因这个功能模块不能在测试时运用或未开发完，为了不阻塞测试，我们可以Mock对象来完成测试。还有一些场景，诸如对象很难被创建、真实对象运行缓慢、真实对象的错误很难出现等，也可以通过Mock对象来测试。 手动Mock对象举个例子，开发一款记事本软件，登录成功后才能写/存笔记，小明小刘分别负责登录和写/存笔记功能，存笔记的时候时候需要用户信息User的实例，而用户信息在登录成功后才能获得。可行的代码如下： 123456789101112131415161718192021222324252627282930//保存数据的类public class NoteDAO&#123; private NoteDAO noteDAO; public void saveNote(User user,String note)&#123; Log.d(\"NoteDAO\",\"存储笔记\"); &#125;&#125;//测试类public class NoteTest&#123; @Before public void setUp()&#123; noteDAO = new NoteDAO(); &#125; @Test public void testSaveNote()&#123; MockLoginImpl loginImpl = new MockLoginImpl(); noteDAO.saveNote(loginImpl.login(\"dd\",\"pwd\"),\"note_content\"); &#125;&#125;//Mock类public class MockLoginImpl &#123; public User login(String name,String pwd)&#123; return new User(name,\"1234556\"); &#125;&#125; 使用第三方工具Mockito前面有例子已经涉及到Mockito的部分使用，可以在网上搜索相关使用，这里不再详细展开，如果需要，后面会专门介绍。 运行单元测试 在Android studio中，对指定的测试类点击鼠标右键，选择对应的Run或者debug 在Terminal输入gradle testDebugUnitTest或gradle testReleaseUnitTest指令来分别运行debug和release版本的unittesting，在执行的结果可以在xxx\\project\\app\\build\\reports\\tests\\testReleaseUnitTest中查看 声明：整篇文章有部分内容摘抄自博客：https://www.jianshu.com/p/925191464389","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-从小工到专家","slug":"读书笔记-从小工到专家","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6/"}]},{"title":"第13章： 继续进阶——你还应该掌握的高级技巧","slug":"第一行代码（第二版）-第十三章","date":"2018-07-15T10:00:00.000Z","updated":"2019-11-17T13:52:03.247Z","comments":true,"path":"2018/07/15/第一行代码（第二版）-第十三章/","link":"","permalink":"https://glassx.gitee.io/2018/07/15/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/","excerpt":"全局获取Context技巧主要就是自定义 Application ，在 Application 中实现全局获取Context，代码如下：123456789101112public class MyApplication extends Application&#123; private static Context mContext; @Override public void onCreate()&#123; mContext = getApplicationContext(); &#125; public static Context getContext()&#123; return mContext; &#125;&#125;","text":"全局获取Context技巧主要就是自定义 Application ，在 Application 中实现全局获取Context，代码如下：123456789101112public class MyApplication extends Application&#123; private static Context mContext; @Override public void onCreate()&#123; mContext = getApplicationContext(); &#125; public static Context getContext()&#123; return mContext; &#125;&#125; 使用Intent传递对象Intent的putExtra()方法传递数据的时候，支持的数据类型是有限的，虽然常用的一些数据类型它都支持，但是当你想传递一些自定义对象的时候，就会无从下手。其实使用Intent来传递对象通常有两种实现方式：Serializable和Parcelable。 Serializable 方式Serializable是序列化的意思，表示将一个对象转换成可存储或可传输的状态。至于序列化的方法也很简单，只需要实现Serializable这个接口就行，如以下的Person类： 12345678910111213141516171819202122232425public class Person implements Serializable&#123; //TODO 这行在书中是没有的，实际上我们得加上，用于区分版本这个类的版本，不同的这个id不能反序列回来 //如果不写，系统会自动生成，但是如果改动了里面的属性（增加或者减少或者更改了属性），系统生成的这个值会改变 //（注意，如果没有实质改动（如只是改变属性的位置，或者在类中添加了空格）则值不会改变 private static final long serialVersionUID =1L; private String name; private int age; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getAge()&#123; return age; &#125; public void setAge(int age)&#123; this.age = age; &#125;&#125; 如果要在Activity之间传递的话，只需要简单的几行代码即可： 123456Person person = new Person();person.setName(\"Tom\");person.setAge(\"20\");Intent intent = new Intent(this,SecondActivity.class);intent.putExtra(\"person_data\",person);startActivity(intent); 可以看到我们穿件了Person实例，之后直接将它传入putExtra()方法中了，只是因为Person实现了Serializable接口，所以才可以这么写。接下来要在SecondActivity中获取这个对象也很简单： 1Person person = (Person)getIntent().getSerializableExtra(\"person_data\"); 这里调用了getSerializableExtra方法来获取通过参数传递过来的序列化对象，接着再向下转型得到Person对象，就成功实现了Intent传递对象。 Parcelable方式除了Serializable之外，使用Parcelable也可以实现相同的效果，不过不同于将对象进行序列化，Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现了传递对象的功能了。下面修改下Person类的代码： 12345678910111213141516171819202122232425262728293031323334public class Person implements Parcelable&#123; private String name; private int age; 。。。 @Override public int describeContents()&#123; return 0; &#125; @Override public void writeToParcel(Parcel dest,int flags)&#123; dest.writeString(name);//写出name dest.writeInt(age);//写出age &#125; public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;()&#123; @Override public Person createFromParcel(Parcel source)&#123; Person person = new Person(); person.name = source.readString();//读取name person.age = source.readInt(); return person; &#125; @Override public Person[] newArray(int size)&#123; return new Person[size]; &#125; &#125;；&#125; Parcelable 的实现方式要稍微复杂些，首先继承 Parcelable 接口，这样就必须重写 describeContents() 和 writeToParcel() 两个方法。 describeContents 中直接返回0即可，writeToParcel中需要将Person类中的字段一一写出。除此之外，还得再Person类中提供一个 CREATOR 常量。接下来，我们仍然可以通过前面相同的代码来传递Person对象，只不过在SecondActivity中获取对象的时候需要稍加改动： 1Person person = (Person)getIntent().getParcelableExtra(\"person_data\"); 一般来说，Serializable方式比较简单，但是这会把整个对象序列化，因此效率比Parcelable低一些，所以更加推荐Parcelable方式。 定制自己的日志工具实用性不太强，公司项目有更强大的日志工具，因此 略 调试Android程序已经掌握，略 创建定时任务Android中的定时任务一般有两种实现方式：一是Java API中的Timer类，二是Android中的Alarm机制。但Timer类不太适用于哪些需要长期在后台运行的定时任务，因为为了能让电池更加耐用，每种手机都会有自己的休眠策略，Android手机会在长时间不操作的情况下自动让CPU进入睡眠状态，这可能导致Timer中的定时任务无法正常运行。而Alarm则具有唤醒CPU功能，可以保证大多数情况下需要执行定时任务的时候CPU都能正常工作。注意，这里唤醒CPU和唤醒屏幕完全不是一个概念，千万不要混淆。 Alarm机制Alarm机制用法并不复杂，主要借助于AlarmManager实现，跟NotificationManager有点类似，获取实例的方法如下所示： 1AlarmManager manager = (AlarmManager)getSystemService(Context.ALARM_SERVICE); 接下来使用set()方法就可以设置一个定时任务了，比如想设定一个任务在10秒钟后执行： 12long triggerAtTime = SystemClock.elapsedRealtime() + 10 * 1000;manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,triggerAtTime,pendingIntent); 第一个参数是整型参数，用于指定AlarmManager的工作类型，有4种值可选：ELAPSED_REALTIME(让定时任务的触发时间从系统开机开始算，但不会唤醒CPU)、ELAPSED_REALTIME_WAKEUP（表示定时任务从系统开机开始算起，但会唤醒CPU）、RTC（让定时任务触发时间从1970年1月1日0点开始算起，但不会唤醒CPU）、RTC_WAKEUP(让定时任务触发时间从1970年1月1日0点开始算起，但会唤醒CPU)。可以使用SystemClock.elapsedRealtime()获取到系统开机至今所经历的时间的毫秒数。Systemt.currentTimeMillis()可以获取到1970年1月1日0点至今所经历的毫秒数。第二个参数就是定时任务触发的时间，如果第一个参数是ELAPSED_REALTIME或者ELAPSED_REALTIME_WAKEUP，则传入开机至今时间加上延迟执行的时间；如果是RTC或者RTC_WAKEUP，则传入1970年1月1日0点至今的时间再加上延迟执行的时间。第三个参数不多说。 那么如果要实现一个长时间在后台定时运行的服务要如何做呢，其实只要建立一个普通服务，然后将触发定时任务的代码写到onStartCommand()方法中，如下所示： 123456789101112131415161718192021222324252627public class LongRuningService extends Service&#123; ... @Override public int onstartCommand(Intent intent,int flags,int startId)&#123; //TODO 之所以要在子线程里面执行逻辑操作，是因为逻辑操作需要耗时，放在主线程中可能会对定时任务准确性产生轻微影响。 new Thread(new Runnable()&#123; @Override public void run()&#123; //执行具体的逻辑操作 &#125; &#125;).start(); AlarmManager manager = (AlarmManager)getSystemService(ALARM_SERVICE); int anHour = 60 * 60 * 1000;//一小时 long triggerAtTime = SystemClock.elapsedRealtime() + anHour; Intent i = new Intent(this,LongRunningService(this,0,i,0)); //TODO 注意，从4.4开始，Alarm任务的触发将会变得不准确，有可能会延迟一段时间后任务才能得到执行，这不是bug， //而是系统在耗电方面的优化，系统会自动检测目前有多少Alarm任务，然后将触发时间相近的几个任务放在一起执行，可以 //大幅度减少CPU被唤醒的次数，从而延长电池使用。如果要求Alarm任务执行时间必须准确无误，则使用 setExact()方法替代 //下面的set()方法。 manager.set(AlarmManager.ELAPSED_REALTIME_WEKEUP,triggerAtTime,pi); return super.onStartCommand(intent,flags,startId); &#125;&#125; 这样，一旦启动了LongRuningService，就会设定一个定时任务，一个小时后会再次启动LongRuningService，形成一个永久循环。 Doze模式在Android 6.0中，google加入了Doze模式，及大幅度延长电池使用寿命。主要表现为：如果设备未插电源，处于静止（7.0后删除这条件），并且屏幕关闭了一段时间之后，就会进入Doze模式，系统会对CPU、网络、Alarm等活动限制，当然，系统还会间歇性地退出Doze一小段时间，在这段时间，应用可以去完成他们的同步操作、Alarm任务等。如下图所示： 可以看到，随着设备进入Doze模式的时间越长，间歇性退出Doze模式的时间间隔也会越来越长，因为如果设备长时间不使用的话，没必要频繁退出Doze。以下列出Doze模式下有具体哪些功能会收到限制： 网络访问被禁止 系统忽略唤醒CPU或者屏幕操作 系统不再执行WIFI扫描 系统不再执行同步服务 Alarm任务将会在下次退出Doze模式时候执行 不过，如果你真有非常特殊需求，要求Alarm任务在Doze模式也必须正常执行，可以调用AlarmManager的setAndAllowWhileIdle()或setExactAcnAllowWhileIdle()方法就能让定时任务即使在Doze模式下也能正常执行了，这两个方法之间的区别和set()、setExact()方法之间的区别一样。 *** 多窗口模式 在一个屏幕上，同时显示两个app界面。切换到多窗口模式，Activity会经历重新创建的过程。其实这是正常现象，进入多窗口模式后，Activity的大小发生了比较大的变化，此时默认会重新创建活动的。除此之外，像横竖屏也会重新创建活动。如果此时去操作另一个窗口，则当前窗口会执行onPause，而另一个窗口会执行onResume，这很好理解，因为两个窗口都是可见的，所以只会执行到onPause即可。因此，在考虑多窗口模式下，用户仍然可以看到处于暂停状态的应用，那么像视频播放器之类的应用应该在此时能够继续播放视频才对，因此最好不要在Activity的onPause()方法中去处理播放器的暂停逻辑，而应该在onStop()方法中处理，并且在onStart()方法中恢复视频播放。另外，针对进入多窗口时活动会被重新重新创建，如果想改变这一默认行为，可以在AndroidManifest.xml中进行配置： 123&lt;activity android:name=\".MainActivity\" android:configChanges=\"origintation|keyboardHidden|screenSize|screenLayout\" 这样不管进入多窗口模式还是横竖屏切换，Activity都不会被重新创建，而是会将屏幕发生变化的事件通知到Activity的onConfigurationChanged()方法中，因此，如果有这方面的需求，只需要重写onConfigurationChanged()即可。 当然，如果想禁用多窗口模式，只需要在 AndroidManifest.xml 中的 或者 标签中加入如下属性即可： 1android:resizeableActivity=[\"true\" | \"false\"] 需要注意的是，这个属性只有在项目的targetSdkVersion指定成24或者更高的时候才会有用。不过Android规定，如果targetSdkVersion小于24,并且Activity不允许横竖屏切换，那么应用也将不支持多窗口模式，如果不允许应用横竖屏切换，只需要在AndroidManifest.xml中添加如下配置： 1android:screenOrientation=[\"portrait\" | \"landscape\"]","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第10章： 后台默默的劳动者-探究服务","slug":"第一行代码（第二版）-第十章","date":"2018-07-09T10:00:00.000Z","updated":"2019-11-17T13:52:10.474Z","comments":true,"path":"2018/07/09/第一行代码（第二版）-第十章/","link":"","permalink":"https://glassx.gitee.io/2018/07/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%8D%81%E7%AB%A0/","excerpt":"服务非常适合执行那些不需要和用户交互还要求长期运行的任务。要注意的是，服务并不是运行在一个独立的进程当中，而是依赖于创建服务时所在的应用程序进程，当应用程序被杀掉时，所有依赖该进程的服务也会停止。不要被服务的后台概念迷惑，实际上服务并不会自动开启子线程，所有的代码都是默认运行在主线程中。因此在使用服务时要注意主线程被阻塞的情况。","text":"服务非常适合执行那些不需要和用户交互还要求长期运行的任务。要注意的是，服务并不是运行在一个独立的进程当中，而是依赖于创建服务时所在的应用程序进程，当应用程序被杀掉时，所有依赖该进程的服务也会停止。不要被服务的后台概念迷惑，实际上服务并不会自动开启子线程，所有的代码都是默认运行在主线程中。因此在使用服务时要注意主线程被阻塞的情况。 服务的基本用法新建类MyService继承Service，要求重写其唯一一个抽象方法 onBind 。一般又要重写onCreate（服务创建时调用）、onStartCommand（每次服务启动的时候调用）以及onDestroy（服务销毁时调用）方法，它们是服务中最常用的3个方法。如果我们希望服务已启动就立刻执行某个动作，就可以将逻辑写在onStartCommand方法里。另外，还需要在AndroidManifest文件中做如下声明（四大组件都得声明）： 12345&lt;service android:name=\".MyService\" android:enabled=\"true\" android:exported=\"true\"&lt;/service 其中export属性表示是否允许除了当前程序之外的其他程序访问这个服务，enable表示是否启用这个服务。 启动和停止服务通过以下代码可以简单地实现启动和停止服务： 12345678910111213@Overridepublic void onClick(View v)&#123; switch(v.getId())&#123; case R.id.start_service: Intent startIntent = new Intent(this,MyService.class); startService(startIntent); break; case R.id.stop_service: Intent startIntent = new Intent(this,MyService.class); stopService(startIntent); break; &#125;&#125; 构建出Intent对象，使用startService即可启动MyService，会依次执行onCreate-&gt;onStartCommand；同理，使用stopService即可停止，onDestroy就会执行。如果在service里面，那么使用stopSelf即可停止自己。由于刚才点击start的时候，onCreate和onStartCommand都执行了，也许你会疑惑，这两个方法到底有什么区别呢？其实onCreate方法在服务第一次创建时调用，而onStartCommand则在每次启动服务时调用，由于是第一次创建，所以两个方法都执行了，如果多次点击start service按钮，那就只有onStartCommand方法执行了。 活动和服务通信上一节虽然在活动中启动和停止了服务，但是启动服务之后，活动与服务基本上就没关系了，没法控制服务。如果希望控制服务执行，比如MyService提供下载功能，则希望可以决定什么时候开始下载，以及查看下载进度等，主要的思路是创建一个专门的Binder对象来对下载功能进行管理，然后通过ServiceConnection来实现通信。简易代码如下： 12345678910111213141516171819//service代码public class MyService extends Service&#123; private DownloadBinder mBinder = new DownloadBinder(); class DownloadBinder extends Binder&#123; public void startDownload()&#123; &#125; public int getProgress()&#123; return 0; &#125; &#125; @Override public IBinder onBind(Intent intent)&#123; return mBinder; &#125;&#125; 12345678910111213141516171819202122232425//Activity代码private ServiceConnection connection = new ServiceConnection()&#123; @Override public void onServiceDisconnected(ComponentName name)&#123;//解除绑定时调用 &#125; @Override public void onServiceConnected(ComponentName name,Ibinder service)&#123;//绑定时调用 downloadBinder = (MyService.DownloadBinder)service; downloadBinder.startDownload(); downloadBinder.getProgress(); &#125;&#125;@Overridepublic void onClick(View v)&#123; switch(v.getId())&#123; case R.id.bind_service: Intent bindIntent = new Intent(this,MyService.class); bindService(bindIntent,connection,BIND_AUTO_CREATE);//绑定服务 break; case R.id.unbind_service: unbindService(connection);//解绑服务 break; &#125;&#125; 服务生命周期一旦在任何位置调用了Context的startService方法，相应的服务就会启动，如果服务还没创建过，onCrete先执行，在执行onStartCommand，如果已经创建了，则只会执行onStartCommand了，启动后该服务一直运行，直到调用stopService或者stopSelf为止。虽然多次启动服务onStartCommand会被多次执行，但是服务只会存在一个实例。另外，还可以调用Context的bindService来获取一个服务的持久连接，这时会回调服务的onBind方法，类似地，如果之前没创建过该服务，就会先执行onCreate在执行onBind，之后，调用方可以获取到onBind方法里返回的IBinder对象实例，就能自由和服务进行通信。调用unbind方法，也会执行Myservice的onDestroy方法，即销毁服务。 服务的更多技巧使用前台服务由于服务运行在后台，因此其系统优先级比较低，当出现内存不足的情况时，容易被回收，这就考虑使用前台服务。前台服务和普通服务最大的区别在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉可以看到更详细的信息，非常类似于通知效果。其主要实现方法如下： 123456789101112131415161718public class MyService extends Service&#123;... @Override public void onCreate()&#123; super.onCreate(); Intent intent = new Intent(this,MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this,0,intent,0); Notification notification = new NotificationCompat.Builder(this) .setContentTitle(\"title\") .***//其他配置省略了 .build(); //没有像普通Notification一样使用NotificationManager将通知展示出来，而是使用 //startForeground方法 **startForeground(1,notification);//与普通Notification和普通的Service区别的关键在这里** &#125;&#125; 使用IntentService服务中的代码都是默认运行在主线程当中的，如果直接在服务里处理耗时操作，很容易出现ANR。当然，为了避免这种情况，你可以在onStartCommand方法中new 一个Thread来处理耗时逻辑，写法并不复杂，但是程序员容易忘记开启线程或者忘记调用stopSelf。为了简单地创建一个异步的、能够自动停止的服务，Android专门提供了IntentService，在继承Intentservice之后，你可以直接在它的 onHandleIntent方法中执行耗时操作（这是在新的线程里面，可以通过Thread.currentThread().getId()方法查看线程ID，跟主线程不是同一个），在耗时操作执行完毕之后，这个IntentService会自动调用onDestroy停止。 服务的最佳实践——完整版下载示例直接上代码吧，多说无益。用于执行异步任务的AsyncTask： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150//这里AsyncTask传入3个参数类型，第一个泛型指定为String，表示在执行AsyncTask时需要传入一个//字符串给后台任务，第二个指定为Integer，表示使用整型数据作为进度显示单位，第三个泛型Intege则表示使用整数型//数据来反馈执行结果public class DownloadTask extends AsyncTask&lt;String,Integer,Integer&gt;&#123; public static final int TYPE_SUCCESS = 1;//成功 public static final int TYPE_FAILED = 2;//失败 public static final int TYPE_PAUSED = 3;//暂停 public static final int TYPE_CANCELED = 4;//取消 private DownloadListener downloadListener = null; private boolean isPaused = false; private boolean isCancled = false; private int lastProgress; public DownloadTask(DownloadListener listener)&#123; downloadListener = listener; &#125; @Override protected Integer doInBackground(String... params) &#123;//用于后台执行下载逻辑 InputStream is = null; RandomAccessFile savedFile = null; File file = null; try&#123; long downloadedLength = 0;//记录已经下载的文件长度 String downloadUrl = params[0]; String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(\"/\")); //SD卡的Download目录 String directory = Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_DOWNLOADS).getPath(); file = new File(directory + fileName); //如果已经存在要下载的文件了，则读取已经下载的字节数，这样就可以在后面启动端点续传功能 if(file.exists())&#123; downloadedLength = file.length(); &#125; //获取文件总长 long contentLength = getContentLength(downloadUrl); if(contentLength == 0)&#123; return TYPE_FAILED; &#125;else if(contentLength == downloadedLength)&#123; //已下载的字节和总字节相等，说明已经下载完成 return TYPE_SUCCESS; &#125; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() //断点下载，指定从哪个字节开始下载 .addHeader(\"RANGE\",\"bytes=\" + downloadedLength + \"-\") .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if(response != null)&#123; //以下读取服务器响应的数据，并使用Java文件流方式，不断从网络读取数据，不断写到本地，知道 //文件全部下载完成为止 is = response.body().byteStream(); savedFile = new RandomAccessFile(file,\"rw\"); savedFile.seek(downloadedLength);//跳过已下载的字节 byte[] b = new byte[1024]; int total = 0; int len; while ((len = is.read(b)) != -1)&#123; if(isCancled)&#123; return TYPE_CANCELED; &#125;else if (isPaused)&#123; return TYPE_PAUSED; &#125;else &#123; total += len; savedFile.write(b,0,len); //计算已下载的百分比 int progress = (int) ((total + downloadedLength) * 100/contentLength); publishProgress(progress); &#125; &#125; response.body().close(); return TYPE_SUCCESS; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (is != null)&#123; is.close(); &#125; if (savedFile != null)&#123; savedFile.close(); &#125; if (isCancled &amp;&amp; file != null)&#123; file.delete(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; return TYPE_FAILED; &#125; @Override protected void onProgressUpdate(Integer... values) &#123;//用于在界面上更新当前的下载进度 int progress = values[0]; if (progress &gt; lastProgress)&#123; downloadListener.onProgress(progress); lastProgress = progress; Log.e(\"进度\",progress+\"\"); &#125; &#125; @Override protected void onPostExecute(Integer status) &#123;//用于通知最终的下载结果 switch (status)&#123; case TYPE_SUCCESS: downloadListener.onSuccess(); break; case TYPE_FAILED: downloadListener.onFailed(); break; case TYPE_PAUSED: downloadListener.onPaused(); break; case TYPE_CANCELED: downloadListener.onCancled(); break; default: break; &#125; &#125; public void pauseDownload()&#123; isPaused = true; &#125; public void cancelDownload()&#123; isCancled = true; &#125; //获取要下载的内容的大小 private long getContentLength(String downloadUrl) throws IOException&#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if(response != null &amp;&amp; response.isSuccessful())&#123; long contentLength = response.body().contentLength(); response.close(); return contentLength; &#125; return 0; &#125;&#125; 用于执行后台任务的Service 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public class DownloadService extends Service&#123; private DownloadTask downloadTask; private String downloadUrl; private DownloadListener listener = new DownloadListener()&#123; @Override public void onProgress(int progress) &#123; getNotificationManager().notify(1,getNotification(\"Downloading...\",progress)); &#125; @Override public void onSuccess() &#123; downloadTask = null; //下载成功时将前台服务通知关闭，并创建一个下载成功的通知 //这句代码将服务创建成前台服务 stopForeground(true); getNotificationManager().notify(1,getNotification(\"Download Success\",-1)); Toast.makeText(DownloadService.this,\"Download success\",Toast.LENGTH_LONG).show(); &#125; @Override public void onFailed() &#123; downloadTask = null; //下载失败将前台服务通知关闭，并创建一个下载失败的通知 stopForeground(true); getNotificationManager().notify(1,getNotification(\"Download Failed\",-1)); Toast.makeText(DownloadService.this,\"Download failed\",Toast.LENGTH_LONG).show(); &#125; @Override public void onPaused() &#123; downloadTask = null; Toast.makeText(DownloadService.this,\"Paused\",Toast.LENGTH_LONG).show(); &#125; @Override public void onCancled() &#123; downloadTask = null; stopForeground(true); Toast.makeText(DownloadService.this,\"Canceled\",Toast.LENGTH_LONG).show(); &#125; &#125;; //为了让service可以和Activity通信，创了这个binder class DownloadBinder extends Binder&#123; public void startDownload(String url)&#123; if(downloadTask == null)&#123; downloadUrl = url; downloadTask = new DownloadTask(listener); downloadTask.execute(downloadUrl); startForeground(1,getNotification(\"Downloading...\",0)); Toast.makeText(DownloadService.this,\"Downloading...\",Toast.LENGTH_LONG).show(); &#125; &#125; public void pauseDownload()&#123; if (downloadTask != null)&#123; downloadTask.pauseDownload(); &#125; &#125; public void cancelDownload()&#123; if (downloadTask != null)&#123; downloadTask.cancelDownload(); &#125;else&#123; if (downloadUrl != null)&#123; //取消下载时需要将文件删除，并将通知关闭 String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(\"/\")); String directory = Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_DOWNLOADS).getPath(); File file = new File(directory + fileName); if(file.exists())&#123;//如果已经存在要下载的文件了，则读取已经下载的字节数，这样就可以在后面启动端点续传功能 file.delete(); &#125; getNotificationManager().cancel(1); stopForeground(true); Toast.makeText(DownloadService.this,\"Canceled\",Toast.LENGTH_LONG).show(); &#125; &#125; &#125; &#125; private DownloadBinder mBinder = new DownloadBinder(); @Nullable @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; private NotificationManager getNotificationManager()&#123; return (NotificationManager) getSystemService(NOTIFICATION_SERVICE); &#125; private Notification getNotification(String title,int progress)&#123; Intent intent = new Intent(this,MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this,0,intent,0); NotificationCompat.Builder builder; //TODO 注意这段代码，在8.0以后通知要求设置 NotificationChannel，否则会报错 //TODO 在书本中的代码没有这一段 if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O )&#123; NotificationChannel channel = new NotificationChannel(\"im_channel_id\",\"System\", NotificationManager.IMPORTANCE_LOW); NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); if(manager != null)&#123; **manager.createNotificationChannel(channel); &#125; &#125; //书上是 builder = new NotificationCompat.Builder(this); ，但是这个方法现在已经废弃了 builder = new NotificationCompat.Builder(this,\"im_channel_id\"); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)); builder.setContentIntent(pi); builder.setContentTitle(title); if (progress &gt; 0)&#123; //当progress大于或者等于0才需显示下载进度 builder.setContentText(progress + \"%\"); builder.setProgress(100,progress,false); &#125; return builder.build(); &#125;&#125; Activity中的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private DownloadService.DownloadBinder downloadBinder; //为了能够控制service的行为 private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; downloadBinder = (DownloadService.DownloadBinder) service; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.start).setOnClickListener(this); findViewById(R.id.pause).setOnClickListener(this); findViewById(R.id.cancel).setOnClickListener(this); Intent intent = new Intent(this,DownloadService.class); startService(intent); bindService(intent,connection,BIND_AUTO_CREATE); //6.0及以上要求动态申请权限，有权限才能使用这个下载功能 if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this, new String[] &#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1); &#125; &#125; @Override public void onClick(View v) &#123; //首先判断downloadBinder是否有效 if (downloadBinder == null)&#123; return; &#125; switch (v.getId())&#123; case R.id.start: String url = \"https://raw.githubusercontent.com/guolindev/eclipse/master/eclipse-inst-win64.exe\"; downloadBinder.startDownload(url); break; case R.id.pause: downloadBinder.pauseDownload(); break; case R.id.cancel: downloadBinder.cancelDownload(); break; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED)&#123; Toast.makeText(MainActivity.this,\"拒绝权限无法使用程序\",Toast.LENGTH_SHORT).show(); finish(); &#125; break; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(connection); &#125; 当然，还有要注意的是，要在AndroidManifest.xml中注册Service： service android:name=”.DownloadService” 还有，在AndroidManifest.xml中需要标明网络权限和存储权限： uses-permission android:name=”android.permission.INTERNET” uses-permission android:name=”android.permission.WRITE_EXTERNAL_STORAGE” 最后，针对本例子，例子中使用了okhttp，需要在buildgradle中添加依赖： implementation ‘com.squareup.okhttp3:okhttp:3.9.0’","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第9章： 看看精彩的世界-使用网络技术","slug":"第一行代码（第二版）-第九章","date":"2018-06-23T00:00:00.000Z","updated":"2019-11-17T13:51:06.411Z","comments":true,"path":"2018/06/23/第一行代码（第二版）-第九章/","link":"","permalink":"https://glassx.gitee.io/2018/06/23/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B9%9D%E7%AB%A0/","excerpt":"webview的用法这节描述得比较简单，因此记住以下内容就行： webview.setWebClient(new WebViewClient); 为webview设置webViewClient，其主要作用是当需要从一个网页跳转到另一个网页时，我们希望目标网页仍然在当前WebView中显示，而不是打开系统浏览器。","text":"webview的用法这节描述得比较简单，因此记住以下内容就行： webview.setWebClient(new WebViewClient); 为webview设置webViewClient，其主要作用是当需要从一个网页跳转到另一个网页时，我们希望目标网页仍然在当前WebView中显示，而不是打开系统浏览器。 使用HTTP协议访问网络介绍了HttpURLConnection 使用方法，简单上个图： OkHttp的简单使用，并不复杂，略。 解析XML格式数据在网络上传输数据时最常用的格式有两种，XML和JSON，首先学习解析XML。 搭建简易服务器提供数据学习解析xml和json之前，先搭建一个简易服务器提供解析的数据，按照以下步骤即可： 下载一个Apache服务器的安装包，官方下载地址http://httpd.apache.org/download.cgi 一路默认Next，域名随意填写如test.com，安装路径的话，可以选择安装在 C:\\Apache 目录 为了验证安装是否成功，可以打开电脑的浏览器验证，输入 127.0.0.1 出现 It works 界面即可。 接下来进入到安装目录的htdocs目录下，按照上述安装过程应该是C:\\Apache\\htdocs目录，新建get_data.xml文件，编辑，并加入内容： 1234567891011&lt;apps&gt; &lt;app&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;google map&lt;/name&gt; &lt;/app&gt; &lt;app&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;google map&lt;/name&gt; &lt;/app&gt;&lt;/apps&gt; 打开浏览器访问 http://127.0.0.1/get_data.xml就会显示上述内容，同理，如果在其中新建 get_data.json文件，并添加以下数据： 123[&#123;\"id\":\"5\",\"version\":\"5.5\",\"name\":\"map\"&#125;,&#123;\"id\":\"6\",\"version\":\"6.6\",\"name\":\"boom\"&#125;,&#123;\"id\":\"7\",\"version\":\"3.5\",\"name\":\"clash\"&#125;] 打开浏览器访问 http://127.0.0.1/get_data.json 就会返回上述json。 Pull解析方式解析XML格式的数据有多重方式，主要是Pull和SAX两种方式。通过自己搭建的服务器拉取XML数据之后通过Pull解析的示例如下： SAX解析Pull解析方式虽然非常好用，它比XML解析方式要复杂一些，但是语义方面更清楚，通常情况下，我们都会新建一个雷继承自DefaultHandler，并重写父类的5个方法： 每当解析某个节点的时候，startElement方法就会得到调用，其中localName记录当前节点的名字。接下来的工作就非常简单了，修改MainActivity中的代码，如下所示： 解析JSON格式数据JSON相对XML而言优势在于它体积更小，在网络上传输的时候可以更省流量，但缺点是语义性较差。 使用JSONObject比较简单，直接上截图的例子： 使用GSON解析单个的对象比较简单，比如解析： {“name”:”Tom”,”age”:20} 那只需要定义Person类，有String类型的name字段以及int类型的age字段，则可以使用： 12Gson gson = new Gson();Person person = gson.fromJson(jsonData,Person.class); 解析数组稍微麻烦点： 1List&lt;Person&gt; people = gson.fromJson(jsonData,new TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;.getType());","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第8章：丰富你的程序-使用手机多媒体","slug":"第一行代码（第二版）-第八章","date":"2018-06-22T00:00:00.000Z","updated":"2019-11-17T13:51:49.523Z","comments":true,"path":"2018/06/22/第一行代码（第二版）-第八章/","link":"","permalink":"https://glassx.gitee.io/2018/06/22/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%85%AB%E7%AB%A0/","excerpt":"使用通知我们可以在Activity中、BroadcastReceiver以及Service中创建通知，不论在哪里创建，整体步骤是相同的，下面通过示例演示：123456789101112131415161718192021222324252627282930313233343536373839//1、需要NotificationManager管理通知，通过调用Context的getSystemService方法获得NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);//2、创建一个延迟意图（PendingIntent），标明点击notification时的响应，这里可以启动Activity，Broadcast以及service等//PendingIntent有点类似于Intent，不过前者倾向于在某个合适的时机去执行某个动作，而后者倾向于立即执行某个动作Intent intent = new Intent(MainActivity.this,SecondActivity.class);//根据启动的对象（Activity、Broadcast或service），可以使用getActivity()/getBroadcast()/getService()PendingIntent pi = PendingIntent.getActivity(this,0,intent,0);//3、通过Builder构造器创建Notification对象，几乎Android每个版本都会对通知这部分进行修改，因此我们需要使用//support-v4包提供的NotificationCompat类来兼容性地实现，保证在各个版本上都能正常使用通知Notification notification = new NotificationCompat.Builder(context) .setContentTitle(\"title\") .setContentText(\"content\") .setSound(Uri.from(\"\"))//控制通知的声音 //设置通知来的时候震动，数组中的值为时长，单位为毫秒，下标0表示手机静止时长，下标1为手机震动时长，下标2为手机静止 //时长，以此类推，这就实现了通知来时立刻震动1秒，静止1秒，再震动1秒 //注意震动需要权限 &lt;uses-permission android:name=\"android.permission.VIBRATE\"&gt; .setVibrate(new long[]&#123;0,1000,1000,1000&#125;) .setWhen(System.currentMillis())//指定通知被创建的时间，下拉时这个时间会显示在通知上 .setSmallIcon(R.drawable.small_icon)//显示在顶部状态栏上的图标 .setLargeIcon(BitmapFactory.decodeResource(gerResources(),R.drawable.large_icon))//下拉时显示在通知左边 .setContentIntent(pi)//指明点击之后的意图 //通知自动消失,第二种取消方式是，将notification的id传入SecondActivity中，在进入到SecondActivity后，在SecondActivity //的onCreate方法中重新获取manager，并且关闭这个通知： //NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE); manager.cancel(id); .setLights(Color.GREEN,1000,1000)//设置灯光绿色和一闪一闪的效果 .setAutoCancel(true) //设置style，一般通知只会显示很短的内容文字，但如果真的非常需要长文字，也是支持的，这样设置style，如果要显示一张大图片， //以下换成NotificationCompat.BigTextStyle().bigPicture(bitmap)即可 .setStyle(new NotificationCompat.BigTextStyle().bigText(\"fdasfdsafdsafdafdasfsdafadsfdsfasdffasdfdsfdsfsda\")) //设置通知优先级，如果设置为最高的话，即要求用户立刻看，不会像普通通知只在状态栏显示一个图标，而是弹出一个横幅 //不论你当前在玩游戏还是看电影，这个横幅都会弹 .setPriority(NotificationCompat.PRIORITY_MAX) .build();//4、发出通知manager.notify(1,notification);//第一个参数指定notification的id","text":"使用通知我们可以在Activity中、BroadcastReceiver以及Service中创建通知，不论在哪里创建，整体步骤是相同的，下面通过示例演示：123456789101112131415161718192021222324252627282930313233343536373839//1、需要NotificationManager管理通知，通过调用Context的getSystemService方法获得NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);//2、创建一个延迟意图（PendingIntent），标明点击notification时的响应，这里可以启动Activity，Broadcast以及service等//PendingIntent有点类似于Intent，不过前者倾向于在某个合适的时机去执行某个动作，而后者倾向于立即执行某个动作Intent intent = new Intent(MainActivity.this,SecondActivity.class);//根据启动的对象（Activity、Broadcast或service），可以使用getActivity()/getBroadcast()/getService()PendingIntent pi = PendingIntent.getActivity(this,0,intent,0);//3、通过Builder构造器创建Notification对象，几乎Android每个版本都会对通知这部分进行修改，因此我们需要使用//support-v4包提供的NotificationCompat类来兼容性地实现，保证在各个版本上都能正常使用通知Notification notification = new NotificationCompat.Builder(context) .setContentTitle(\"title\") .setContentText(\"content\") .setSound(Uri.from(\"\"))//控制通知的声音 //设置通知来的时候震动，数组中的值为时长，单位为毫秒，下标0表示手机静止时长，下标1为手机震动时长，下标2为手机静止 //时长，以此类推，这就实现了通知来时立刻震动1秒，静止1秒，再震动1秒 //注意震动需要权限 &lt;uses-permission android:name=\"android.permission.VIBRATE\"&gt; .setVibrate(new long[]&#123;0,1000,1000,1000&#125;) .setWhen(System.currentMillis())//指定通知被创建的时间，下拉时这个时间会显示在通知上 .setSmallIcon(R.drawable.small_icon)//显示在顶部状态栏上的图标 .setLargeIcon(BitmapFactory.decodeResource(gerResources(),R.drawable.large_icon))//下拉时显示在通知左边 .setContentIntent(pi)//指明点击之后的意图 //通知自动消失,第二种取消方式是，将notification的id传入SecondActivity中，在进入到SecondActivity后，在SecondActivity //的onCreate方法中重新获取manager，并且关闭这个通知： //NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE); manager.cancel(id); .setLights(Color.GREEN,1000,1000)//设置灯光绿色和一闪一闪的效果 .setAutoCancel(true) //设置style，一般通知只会显示很短的内容文字，但如果真的非常需要长文字，也是支持的，这样设置style，如果要显示一张大图片， //以下换成NotificationCompat.BigTextStyle().bigPicture(bitmap)即可 .setStyle(new NotificationCompat.BigTextStyle().bigText(\"fdasfdsafdsafdafdasfsdafadsfdsfasdffasdfdsfdsfsda\")) //设置通知优先级，如果设置为最高的话，即要求用户立刻看，不会像普通通知只在状态栏显示一个图标，而是弹出一个横幅 //不论你当前在玩游戏还是看电影，这个横幅都会弹 .setPriority(NotificationCompat.PRIORITY_MAX) .build();//4、发出通知manager.notify(1,notification);//第一个参数指定notification的id 调用摄像头和相册平时使用QQ或者微信的时候经常要别人分享图片，这些图片可以使手机摄像头拍摄也可以从相册中选取，这种功能非常普遍。 摄像头拍照直接上代码展示可能更加清晰： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748takePhoto.setOnclickListener(new View.OnclickListener()&#123; @Override public void onClick(View v)&#123; //创建File对象，用于存储拍照后的图片 File outputImage = new File(getExternalCacheDir(),\"output.jpg\"); try&#123; if(outputImage.exists())&#123;//存在了 outputImage.delete(); &#125; outputImage.createNewFile(); &#125;catch(IOException e)&#123; &#125; if(Build.VERSION.SDK_INT &gt;= 24)&#123; imageUri = FileProvider.getUriForFile(MainActivity.this, \"com.example.fileprovider\",outputImage); &#125;else&#123; imageUri = Uri.fromFile(outputImage); &#125; //启动相机 Intent intent = new Intent(\"android.media.action.IMAGE_CAPTURE\"); intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri); startActivityForResult(intent,TAKE_PHOTO); &#125;&#125;);@Overrideprotected void onActivityResult(int requestCode,int resultCode,Intent data)&#123; switch(requestCode)&#123; case TAKE_PHOTO: if(resultCode == RESULT_OK)&#123; try&#123; //将拍摄的照片显示出来 Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver() .openInputStream(imageUri)); ivPic.setImageBitmap(bitmap); &#125;catch (FileNotFoundException e)&#123; &#125; &#125; break; &#125;&#125; 上面的代码中我们用了内容提供器，因此还需要在AndroidManifest.xml中声明这个提供器(有一点要注意的是,在4.4以前（4.4及以后不需要）访问SD卡得应用关联目录也是要声明权限的，为了兼容老版本的手机，需要声明 WRITE_EXTERNAL_STORAGE 权限)： 123456789101112131415161718&lt;users-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt;&lt;application android:icon=\"@mipmap/ic_launcher\" ... android:theme=\"@style/AppTheme\"&gt; &lt;privider &lt;!--这里，android:name属性的值是固定的，android:authorities属性的值必须要和刚才FileProvider.getUriForFile()--&gt; &lt;!--方法中的第二个参数一致，另外，meta-data中用resource指定了Uri的共享路径--&gt; android:name=\"android.support.v4.content.FileProvider\" android:authorities=\"com.example.fileprovider\" android:exported=\"false\" android:grantUriPermissions=\"true\"&gt; &lt;meta-data android:name=\"android.support.FILE_PROVIDER_PATHS\" android:resource=\"@xml/file_paths\"/&gt;&lt;/application&gt; 当然，provider声明中使用了@xml/file_paths资源，这个资源我们还没创建，因此在res目录下可以创建这么个xml，内容如下： 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"&gt;&lt;paths xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;!--这里面external-path指定Uri共享的，name属性随便填，path属性表示共享的具体路径，这里设置空值就表示将整个SD卡进行共享--&gt; &lt;!--当然，你可以仅仅共享我们存放output.jpg这张图片的路径--&gt; &lt;external-path name=\"my_images\" path=\"\"&gt;&lt;/paths&gt; 以上整个代码首先创建了一个File对象，用于存放摄像头拍下的图片，我们将其命名为output.jpg，并将它存放在手机SD卡的应用关联缓存目录（指SD卡中专门用于存放当前应用缓存数据的位置，路径为/sdcard/Android/data//cache，调用getExternalCacheDir()方法就可以得到这个目录）下。为什么使用应用关联缓存目录来存放图片呢？因为从Android 6.0开始，读写SD卡被列为危险权限，如果将图片存放SD卡得任何其他目录，都要进行运行时权限处理才行，而使用应用关联目录则可以跳过这一步。 接着会判断如果设备版本低于7.0，就调用Uri.fromFile()方法将File对象转换为Uri对象，这个Uri标识着图片的本地真实路径。否则就调用FileProvider的getUriForFile()方法获得Uri对象。之所以这样是因为从7.0开始，直接使用本地真实路径的Uri被认为是不安全的，会抛出异常，而FileProvider则是一种特殊的内容提供器，可以选择性地将封装过的Uri共享给外部，提高应用安全性。 最后就是启动摄像头拍照并且回调获取图片了。 从相册中选择照片直接选取一张现有图片比打开相机拍一张照片更加常用，一个优秀的应用应该将这两种方式都提供给用户。废话不多说直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111chooseFromAlbum.setOnclickListener(new View.OnclickListener()&#123; @Override public void onClick(View v)&#123; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1); &#125;else&#123; openAlbum(); &#125; &#125;&#125;);private void openAlbum()&#123; Intent intent = new Intent(\"android.intent.action.GET_CONTENT\"); intent.setType(\"image/*\"); startActivityForResult(intent,CHOOSE_PHOTO);//打开相册&#125;@Overridepublic void onRequestPermissionsResult(int requestCode,String[] permissions,int[] grantResults)&#123; swithc(requestCode)&#123; case 1: if(grantResults.lenght &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else&#123; Toast.makeText(this,\"you denied the permission\",Toast.LENGTH_SHORT).show(); &#125; break; &#125;&#125;@Overrideprotected void onActivityResult(int requestCode,int resultCode,Intent data)&#123; switch(requestCode)&#123; case CHOOSE_PHOTO: if(resultCode == RESULT_OK)&#123; if(Build.VERSION.SDK_INT &gt;= 19)&#123;//4.4及以上 handleImageOnKitKat(data); &#125;else&#123;//4.4以下 handleImageBeforeKitKat(data); &#125; &#125; break; &#125;&#125;//4.4及以上处理方式@TargetApi(19)private void handleImageOnKitKat(Intent data)&#123; String imagePath = null; Uri uri = data.getData(); //如果是document类型Uri，则通过document id处理 if(DocumentsContract.isDocumentUri(this,uri))&#123; String docId = DocumentsContract.getDocumentId(uri); if(\"com.android.providers.media.documents\".equals(uri.getAuthority())&#123; //解析出数字格式的id String selection = MediaStore.Images.Media._ID + \"=\" + id; imagePath = getImagePaht(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,selection); &#125;else if(\"com.android.providers.downloads.documents\".equals(uri.getAuthority()))&#123; Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"),Long.valueOf(docId)); imagePath = getImagePath(contentUri,null); &#125; &#125;else if(\"content\".equalsIgnoreCase(uri.getScheme()))&#123;//如果是content类型的uri，则使用普通方式处理 imagePath = getImagePath(uri,null); &#125;else if(\"file\".eualsIgnoreCase(uri.getScheme()))&#123;//如果是file类型的uri，直接获取推按路径即可 imagePath = uri.getPath(); &#125; //根据路径显示图片 displayImage(imagePath);&#125;//4.4以前处理方式private void handleImageBeforeKitKat(Intent data)&#123; Uri uri = data.getData(); //因为他的Uri没有封装过的，不需要任何解析直接去获取真实路径即可 String imagePath = getImagePath(uri,null); displayImage(imagePath);&#125;//通过Uri和selection来获取真实的图片路径private String getImagePath(Uri uri,String selection)&#123; String path = null; Cursor cursor = getContentResolver().query(uri,null,selection,null,null); if(cursor != null)&#123; if(cursor.moveToFirst())&#123; path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); &#125; cursor.close(); &#125; return path;&#125;//根据路径显示图片private void displayImage(String imagePath)&#123; if(imagePath != null)&#123; Bitmap bitmap = BitmapFactory.decodeFile(imagePath); ivPicture.setImageBitmap(bitmap); &#125;else&#123; Toast.makeText(this,\"failed to get image\",Toast.LENGTH_SHORT).show(); &#125;&#125; 因为照片是存在SD卡上的，所以我们首先进行权限处理，WRITE_EXTERNAL_STORAGE表示授予了对SD卡的读和写的能力。在onActivityResult回调中针对不同版本使用不同方式处理图片，因为从4.4开始，选取相册中的图片不再返回真实的Uri了，而是一个封装过的Uri，因此必须对这个Uri解析才行，在handleImageOnKitKat()方法中，如果返回的Uri是document类型的话，就取出document id进行处理，如果Uri的authority是media格式的话，document id还需要进行一次解析，要通过字符串分割的方式取出后半部分才能得到真正的数字id。 播放多媒体文件播放音频和视频比较简单，没有兼容性等复杂问题，仅仅只需要记住： 申请 WRITE_EXTENAL_STORAGE 权限 使用 MediaPlayer 播放音频结束时，在 onDestroy方法中要进行 MediaPlayer.stop() 和 MediaPlayer.release() ，将资源释放掉; 使用 VideoView 播放视频结束时，在 onDestroy方法中要进行 VideoView.suspend() ，将资源释放掉; 其他内容略过。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第7章： 数据存储全方案——跨程序共享数据：探究内容提供器","slug":"第一行代码（第二版）-第七章","date":"2018-06-21T00:00:00.000Z","updated":"2019-11-17T13:50:51.222Z","comments":true,"path":"2018/06/21/第一行代码（第二版）-第七章/","link":"","permalink":"https://glassx.gitee.io/2018/06/21/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%83%E7%AB%A0/","excerpt":"可能你会有些疑惑，为什么要将我们程序中的数据共享给其他程序呢？当然，这是视情况而定的，比如账号密码之类的隐私数据显然是不能共享给其他程序的，不过一些可以让其他程序进行二次开发的基础性数据，我们还是可以选择共享。例如联系人程序、短信程序、多媒体库等，它们的数据库中保存了很多基础数据，如果不允许其他应用进行访问，则方便性就会大打折扣。","text":"可能你会有些疑惑，为什么要将我们程序中的数据共享给其他程序呢？当然，这是视情况而定的，比如账号密码之类的隐私数据显然是不能共享给其他程序的，不过一些可以让其他程序进行二次开发的基础性数据，我们还是可以选择共享。例如联系人程序、短信程序、多媒体库等，它们的数据库中保存了很多基础数据，如果不允许其他应用进行访问，则方便性就会大打折扣。 运行时权限Android的权限机制在一开始就存在，但是在6.0以前保护隐私方面比较有限，因为像微信这种大家都离不开的软件，容易“店大欺客”，不同意它所有的权限只能不安装，这并不合理。 权限机制详解开发者在AndroidManifest.xml中声明权限，一种情况是，用户如果在低于6.0的系统上安装该程序，会在安装时列出该应用所需要的权限，从而决定是否要安装这个程序，并且在用户安装成功之后，还能在设置中查看程序所申请的权限，但是对于那些离不开的程序（比如微信）来说，要么全部同意它申请的权限，要么不安装，这不太合理；如果在6.0及以上的系统中安装，则用户不必在安装时一次性授权所有申请的权限，而是在软件使用的过程中再对危险权限进行授权，就算拒绝了这个权限，仍然可以使用应用的其他功能，而不是以前那样直接无法安装。 Android 6.0 及以上将所有权限分为两类，普通权限和危险权限，普通权限是指不会直接威胁用户的安全和隐私的权限，这部分权限系统自动帮我们授权，避免用户不停地手动授权；危险权限则表示会触及用户隐私或者设备安全性的权限，如获取联系人、定位设备位置等，必须由程序员动态申请，由用户手动点击授权才可以，否则无法使用相应功能。目前为止，Android中的危险权限有9组共24个权限，如下列表所示（图片来自官网）： 这张表格无需记住，在使用的时候作为参照，如果权限在这张表中，则进行运行时处理就好。另外注意一下，表格中每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权了，那么该权限对应的权限组中所有的其他权限也会同时被授权。 在程序运行时申请权限以拨打电话的权限为例来说明权限的申请，点击一个按钮，就拨打指定的号码，在6.0以前可能是这样实现的： 在AndroidManifest.xml中申请权限：1&lt;uses-permission android:name=\"android.permission.CALL_PHONE\"/&gt; 在代码中实现： 12345678btnCall.setOnclickListener(new View.OnclickListener()&#123; @Override public void onClick(View v)&#123; Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse(\"tel:10086\")); startActivity(Intent); &#125;&#125;); 在6.0以下系统上能正常拨打电话，但是在6.0或者以上系统运行，会报错Permission Denial，可以看出是由于权限被禁止导致的，因此我们应该尝试使用以下方式来申请权限： 123456789101112131415161718192021222324252627282930313233343536btnCall.setOnclickListener(new View.OnclickListener()&#123; @Override public void onClick(View v)&#123; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermission(MainActivity.this,new String[]&#123;Manifest.permission.CALL_PHONE&#125;,1); &#125;else&#123; call(); &#125; &#125;&#125;);private void call()&#123; Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse(\"tel:10086\")); startActivity(Intent);&#125;@Overridepublic void onRequestPermissionResult(int requestCode,String[] permissions,int[] grantResults)&#123; switch(requestCode)&#123; case 1: if(grantResults.lenght &gt; 0 &amp;&amp; grantResults(0) == PackageManager.PERMISSION_GRANTED)&#123; call(); &#125;else&#123; Toast.makeText(this,\"You denied the permission\",Toast.LEGHTH_SHORT).show(); &#125; break; &#125; &#125; 上述第一步先判断用户是不是已经给我们授权了，使用的是ContextCompat.checkSelfPermission，如果已经授权，直接拨打电话，否则调用ActivityCompat.requestPermission方法向用户申请授权，这时候用户可以选择同意或者拒绝我们的申请，不论哪种结果，都会通过回调onRequestPermissionResult告知，在回调中根据不同的结果做不同的处理。记住，在动态声明权限后，AndroidManifest中还得添加 声明。 访问其他程序中的数据内容提供器的用法一般有两种，一是使用现有的内容提供器来读取和操作响应程序中的数据，另一种是创建自己的内容提供器给我们的数据提供外部访问接口。 ContentResolver的基本使用如果想要访问内容提供器共享的数据，就一定要借助ContentResolver类，可以通过Context中的getContentResolver方法获取到该类的实例。可以对内容进行CRUD操作，不同于SQLiteDatabase，ContentResolver增删改查不接收表名参数，而是使用Uri参数代替，该Uri主要由两部分组成：authority和path，前者用于对不同的应用程序做区分，一般采用程序包名形式，如某个程序的包名是com.example.app，那么对应的authority就可以命名为com.example.app.provider；path则是对同一应用程序中不同表做区分的，通常会添加到authority后面，所以内容Uri的形式一般如下所示(带协议声明)： content://com.example.app.provicer/table1content://com.example.app.provicer/table2 正式查询的时候，将Uri作为参数传入，代码如下： 12Uri uri = Uri.parse(\"content://com.example.app.provicer/table1\");Cuisor cursor = getContentResolver().query(uri,projection,selection,selectionArgs,sortOrder); 其中，query方法中各个参数对应的含义如下所示： 接下来便可以进行相应的增删改查操作，代码如下： 1234567//查if(cursor != null)&#123; while(cursor.moveToNext())&#123; String colomn1 = cursor.getString(cursor.getColumnIndex(\"column1\")); int colomn2 = cursor.getInt(cursor.getColumnIndex(\"column2\")); &#125;&#125; 12345//增ContentValues values = new ContentValues();values.put(\"column1\",\"text\");values.put(\"column2\",1);getContentResolver().insert(uri,values); 1234//改，把column1的值清空ContentValues values = new ContentValues();values.put(\"column1\",\"\");getContentResolver().update(uri,values,\"column1 = ? and column2 = ?\",new String[]&#123;\"text\",\"1\"&#125;); 12//删除getContentResolver().delete(uri,\"column2 = ?\",new String[]&#123;\"1\"&#125;); 其实整体就相当于sql语句，因此并不太难。 创建自己的内容提供器因为基本上没有这样的需求，暂时略后续补上","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第6章：数据存储全方案：详解持久化技术","slug":"第一行代码（第二版）-第六章","date":"2018-06-11T00:00:00.000Z","updated":"2019-11-17T13:51:55.602Z","comments":true,"path":"2018/06/11/第一行代码（第二版）-第六章/","link":"","permalink":"https://glassx.gitee.io/2018/06/11/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%85%AD%E7%AB%A0/","excerpt":"Android系统主要提供了3种方式用于简单地实现数据持久化功能——文件存储、SharedPreference存储以及数据库存储。文件存储文件存储是Android中最基本的存储方式，它不对存储内容进行任何的格式化处理，因而比较适合用于存储一些简单的文本数据或者二进制数据。将数据存储到文件Context类提供了一个openFileOutput()方法，可以用于将数据存储到指定文件，需要两个参数，第一个参数是文件名，纯粹的名称，不可以包含路径，因为所有的文件都是默认存储到/data/data//files/目录下；还有个参数是操作模式，主要有两种（其他2种在4.2被废弃了）：","text":"Android系统主要提供了3种方式用于简单地实现数据持久化功能——文件存储、SharedPreference存储以及数据库存储。文件存储文件存储是Android中最基本的存储方式，它不对存储内容进行任何的格式化处理，因而比较适合用于存储一些简单的文本数据或者二进制数据。将数据存储到文件Context类提供了一个openFileOutput()方法，可以用于将数据存储到指定文件，需要两个参数，第一个参数是文件名，纯粹的名称，不可以包含路径，因为所有的文件都是默认存储到/data/data//files/目录下；还有个参数是操作模式，主要有两种（其他2种在4.2被废弃了）： MODE_PRIVATE:默认的操作模式，表示当指定同样文件名的时候，所写入的内容将会覆盖原来文件中的内容。 MODE_APPEND:表示如果该文件已经存在，就往文件里面追加内容，不存在就创建新文件。 保存文件的一般如以下代码操作： 123456789101112131415161718192021public void save()&#123; String dataStr = \"data to save\"; FileOutputStream out = null; BufferedWriter writer = null; try&#123; //文件名是data out = openFileOutput(\"data\",Context.MODE_PRIVATE); writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(dataStr); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finnaly&#123; try&#123; if(writer != null)&#123; writer.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 存储成功后，可以通过Android Device Monitor 进入File Explorer标签，在目录中/data/data//files/中就能找到 data 文件。同理，读取存到文件中的代码应如下所示： 12345678910111213141516171819202122232425public String load()&#123; FileInputStream in = null; BufferedReader reader = null; StringBuilder content = new StringBuilder(); try&#123; in = openFileInput(\"data\"); reader = new BufferedReader(new InputStreamReader(in)); String line = \"\"; while((line = reader.readLine()) != null)&#123; content.append(line); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finnaly&#123; try&#123; if(reader != null)&#123; reader.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; return content.toString();&#125; SharedPreferenceSharedPreference是使用键值对的方式来存储数据的，保存一条数据的时候，需要给这条数据提供一个对应的键，读取数据时通过这个键把对应的值读取出来，SharedPreference文件都是存放在/data/data//shared_prefs目录下。要想存储数据，首先要获取到SharedPreference对象，Android主要提供了3中方式： Context类中的getSharedPreference()方法：此方法接收两个参数，第一个用于指定文件名称，第二个用于指定操作模式，目前只有MODE_PRIVATE可选（其他的几种在4.2或者6.0版本被废弃了），并且是默认的操作模式，表示只有当前应用程序才可以对这个文件进行读写。 Activity中的getPreferences()方法：和Context类中的getSharedPreference()方法类似，只不过它只接受一个操作模式参数，因为使用这个方法时会自动将当前Activity的类名作为SharedPreference的文件名。 PreferenceManager类中的getDefaultSharedPreferences()方法：它接受一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreference文件。 获取到SharedPreference对象之后，就可以开始存储数据了，主要分为3步实现： 调用SharedPreference对象的edit()方法获取SharedPreference.Editor对象 向SharedPreference.Editor对象添加数据。 调用apply()方法提交，从而完成存储操作。 代码形式应该是这样的： 1234567SharedPreferences.Editor editor = getSharedPreferences(\"data\",MODE_PRIVATE).edit();editor.putString(\"name\",\"Tom\");editor.apply();//存储完成后，读取数据SharedPreferences pref = getSharedPreferences(\"data\",MODE_PRIVATE);String name = pref.getString(\"name\",\"\"); SQLite数据库存储文件存储和SharedPrefrences存储只适用于保存一些简单的数据和键值对，要存储大量复杂的关系型数据的时候，有点难以应付了。 创建数据库Android为了让我们更方便地管理数据库，专门提供了一个SQLiteOpenHelper抽象类，要想使用的话，我们就需要创建一个自己的类去继承它，它有两个抽象方法，onCreate和onUpgrade用来创建和升级数据库，其它两个重要的实例方法：getReadableDatabase和getWritableDatabase，他们都可以创建或者打开一个现有的数据库（没有就创建），在数据库不可写入的时候（如磁盘满了），前者以只读的形式打开数据库，后者会出现异常。它有两个构造方法可重写，一般使用哪个参数较少的即可，总共4个参数，第一个context，第二个是数据库名，第三个是自定义的Cursor，一般传null，第四个表示当前的数据库版本号，用于对数据库进行升级操作。一般代码如下图所示： 12345678910111213public class MyDatabaseHelper extends SQLiteOpenHelper&#123; public static final CREATE_BOOK = \"create table Book (\" + \"id integer primary key autoincrement,\" + \"author text,\" + \"price real,\" + \"pages integer,\" +\"name text)\"; @Override public void onCreate(SQLiteDatabase db)&#123; db.exeSQL(CREATE_BOOK); &#125;&#125; 使用的时候应该是这样子的： 123dbHelper = new MyDatabaseHelper(this,\"BookStore.db\",null,1);//就会创建成功了dbHelper.getWritableDatabase(); 上例创建了一个Book表，使用primary key 将id设置为主键，并用autoincrement关键字表示id是自增长的。可以使用 adb shell 命令，之后cd到/data/data//databases/目录下用ls列出该目录的文件，可以看到BookStore.db文件，以及BookStore.db-journal文件，后者是数据库的临时文件。SQLite没有其他数据库一样有很多繁杂的数据类型，它的数据类型很简单：integer表示整型，real表示浮点型，text表示文本，blob表示二进制类型； 升级数据库此时项目中有一张Book表用于存放输的各种详细数据了，但是如果再想添加一张Category表用于记录图书的分类，如果仅仅直接在MyDatabaseHelper的onCreate中写成： 12345@Overridepublic void onCreate(SQLiteDatabase db)&#123; db.exeSQL(CREATE_BOOK); db.exeSQL(CREATE_CATEGORY);&#125; 是行不通的，因为使用的时候先初始化helper：dbHelper = new MyDatabaseHelper(this,”BookStore.db”,null,1)再获取数据库：dbHelper.getWritableDatabase()，而由于此时已经存在数据库BookStore.db了，因此不会再执行helper的onCreate方法了。此时清除app数据可以做到创建Category表，但是这在实际应用中不合理，而我们可以用onUpgrade方法来解决，我们前面构造了MyDatabaseHelper，第4个参数是版本号，我们目前是1，所以只要传入的值大于当前版本号1，onUpgrade方法就可以执行，因此我们可以这样增加Category表： 123456789101112public class MyDatabaseHelper extends SQLiteOpenHelper&#123; ... @Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion)&#123; db.exeSQL(\"drop table if exists Book\"); db.exeSQL(\"drop table if exists Category\"); onCreate(db); &#125;&#125; 上述代码执行了两条drop语句，发现数据库已经存在Book表和Category表了就删除，然后调用onCreate方法重新创建，因此在onCreate中也得写成： 12345@Overridepublic void onCreate(SQLiteDatabase db)&#123; db.exeSQL(CREATE_BOOK); db.exeSQL(CREATE_CATEGORY);&#125; 在使用的时候也得升级版本号： 123dbHelper = new MyDatabaseHelper(this,\"BookStore.db\",null,2);//就会创建成功了dbHelper.getWritableDatabase(); 获取到数据库，接下来可以对其CRUD操作，其中C代表添加（Create），R代表查询（retrieve），U代表更新（Update），D代表删除（Delete）。Android开发者水平参差不齐，并非每一个都会SQL语言，Android提供了一系列的辅助性方法，是的在Android中即使不去编写SQL语句，也能轻松完成所有CRUD操作。getReadableDatabase与getWriteableDatabase方法不仅可以用来创建和升级数据库，他们还会返回一个SQLiteDatabase对象，借助这个对象就可以轻松CRUD： 1234567891011121314151617181920212223242526272829/**添加数据**/SQLiteDatabase db = dbHelper.getWritableDatabase();ContentValues values = new ContentValues();values.put(\"name\",\"thinking in java\");values.put(\"price\",16.96);values.put(\"pages\",512);//插入时指定表名为\"Book\"db.insert(\"Book\",null,values);/**以下是更新**/values.clear();values.put(\"price\",20);//第三个参数对应SQL语句中的where部分，表示更新所有name等于?的行，而?是一个占位符，//可以通过第四个参数提供的一个字符串数组为第三个参数中的每个占位符指定相应内容db.update(\"Book\",values,\"name=?\",new String[]&#123;\"thinking in java\"&#125;);/**以下是删除**///表示删除pages的值大于500的数据db.delete(\"Book\",\"pages &gt; ?\",new String[]&#123;\"500\"&#125;);/**以下是查询**/Cursor cusor = db.query(\"Book\",null,null,null,null,null,null);if(cursor.moveToFirst())&#123; do&#123; String name = cursor.getString(cursor.getColumnIndex(\"name\")); String pages = cursor.Double(cursor.getColumnIndex(\"price\")); &#125;while(cursor.moveToNext());&#125;cusor.close(); 当然，可以直接使用SQL语句直接完成上述操作： 1234567891011//添加db.execSQL(\"insert into Book (name,pages,price) values(?,?,?)\",new String[]&#123;\"thinking in java\",\"512\",\"20\"&#125;);//升级db.execSQL(\"update Book set price = ? where name = \",new String[]&#123;\"20\",\"thinking in java\"&#125;);//删除db.execSQL(\"delete from Book where pages &gt; ?\",new String[]&#123;\"500\"&#125;);//查询db.execSQL(\"select * from Book\",null); 使用LitePal略","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第5章： 全局大喇叭：详解广播机制","slug":"第一行代码（第二版）-第五章","date":"2018-06-10T00:00:00.000Z","updated":"2020-05-05T12:39:05.652Z","comments":true,"path":"2018/06/10/第一行代码（第二版）-第五章/","link":"","permalink":"https://glassx.gitee.io/2018/06/10/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%94%E7%AB%A0/","excerpt":"广播机制介绍Android中广播分为标准广播和有序广播，标准广播是一种完全异步执行的广播，广播发出后，所有广播接收器机会会在同一时刻接收到广播，但同时意味着它也是无法被截断的。有序广播是一种同步执行的广播，同一时刻只有一个广播接收器能收到这条消息，当这个广播接收器的逻辑执行完毕之后才会继续传递，优先级高的广播接收器可以先收到广播，并且还可以阶段正在传递的广播，这样后面的广播接收器就收不到这条广播消息。","text":"广播机制介绍Android中广播分为标准广播和有序广播，标准广播是一种完全异步执行的广播，广播发出后，所有广播接收器机会会在同一时刻接收到广播，但同时意味着它也是无法被截断的。有序广播是一种同步执行的广播，同一时刻只有一个广播接收器能收到这条消息，当这个广播接收器的逻辑执行完毕之后才会继续传递，优先级高的广播接收器可以先收到广播，并且还可以阶段正在传递的广播，这样后面的广播接收器就收不到这条广播消息。 动态注册和静态注册广播动态注册一般在Activity的onCreate方法中写上类似于： 1234IntentFilter filter = new IntentFilter();filter.addAction(\"com.example.MyReceiver\");receiver = new MyReceiver();registerReceiver(receiver,filter); 并且在onDestroy方法中注销广播： 1&gt; unregisterReceiver(receiver); 然后，完善一般是内部类的MyReceiver： 123456class MyReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context,Intent intent)&#123; Toast.makeText(context,\"receive the broadcast\",Toast.LENGTH_SHORT).show(); &#125;&#125; 最后得在适当的时候发送广播： 12Intent intent = new Intent(\"com.example.MyReceiver\");sendBroadcast(intent); 当然，如果你是用广播在APP中实现强制退出登录（如QQ账号在另一台设备上登录了），那你只需要在当前Activity上弹一个窗提示已经被强制下线即可，因此有必要将广播在BaseActivity中注册，并且在BaseActivity的onPause方法（注意不是onDestroy方法了，因为我们只需要栈顶的Activity能够响应就行）中注销广播即可。如果是接收系统级广播，可能还得在AndroidManife.xml中声明相关权限。APP中实现强制退出登录时的广播接收器可以这样写： 1234567891011121314151617181920class ForceOfflineReceiver extends BroadcastReceiver&#123; @Override public void onReceive(final Context context,Intent intent)&#123; AltertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(\"warning\"); builder.setMessage(\"force offline\"); builder.setCancelable(false); builder.setPositiveButton(\"ok\",new DialogInterface.OnclickListener()&#123; @Override public void onclick(DialogInterface dialog,int which)&#123; ActivityCollector.finishAll();//销毁所有活动 Intent intent = new Intent(context,LoginActivity.class); context.startActivity(intent); &#125; &#125;); &#125;&#125; 静态注册广播是在AndroidManife.xml中做如下的声明，其中MyReceiver类一般不是内部类，因为即使app未启动也能接收广播： 123456789101112&lt;application android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/appname\"&gt; ... &lt;receiver android:name=\".MyReceiver\" android:enabled=\"true\" android:exported=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.example.MyReceiver\" &lt;/receiver&gt; &lt;/application&gt; 如果要发送有序广播，只需要将以上发送广播的代码sendBroadcast(intent)替换成sendOrderedBroadcast(intent,null);即可。设置广播的优先级只需要设置intentFilter的priority属性即可（AndroidManifest文件中是intent-filter属性）。 使用本地广播前面发送的广播属于系统全局广播，发出的广播可以被任何应用接收到，并且我们也可以接受来自其它任何应用发出的广播，这容易引起安全性问题，比如关键数据广播被其他应用截获，或者其他应用发送各种垃圾广播。本地广播的发送有些不同： 123LocalBroadcastManager manager = LocalBroadcastManager.getInstance(this);Intent intent = new Intent(\"com.example.MyReceiver\");manager.sendBroadcast(intent); 注册： 1234IntentFilter filter = new IntentFilter();filter.addAction(\"com.example.MyReceiver\");localReceiver = new LocalReceiver();manager.registerReceiver(localReceiver,filter); 同样注销广播： 1manager.unregisterReceiver(localReceiver); 本地广播的几点优势： 可以明确地知道正在发送的广播不会离开我们的程序，因此不必担心机密数据泄露。 其他的程序无法将广播发送到我们程序内部，因此不用担心会有安全漏洞隐患。 发送本地广播比发送系统全局广播更加高效。 另有一点需要说明：本地广播是无法通过静态注册方式来接收的，其实这也完全可以理解，因为静态注册主要就是为了让程序在未启动的情况下也能接收广播，而发送本地广播时，我们的程序肯定是已经启动了；此外，不要再onReceive方法中添加过多的逻辑或者进行任何耗时的操作，因为广播接收器中是不允许开启线程的，当onReceive方法运行了较长时间而没有结束时，程序就会报错。因此它更多的只是扮演一种打开程序其他组件的角色，如弹一条通知，或者启动一个服务等。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第4章：手机平板要兼顾：探究fragment","slug":"第一行代码（第二版）-第四章","date":"2018-06-09T08:00:00.000Z","updated":"2019-11-17T13:52:15.858Z","comments":true,"path":"2018/06/09/第一行代码（第二版）-第四章/","link":"","permalink":"https://glassx.gitee.io/2018/06/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E5%9B%9B%E7%AB%A0/","excerpt":"这一章前面部分主要讲解Fragment的基本使用，这点我觉得官方文档关于fragment的知识可能会更好一些，以下是官方的阐述：主要是平时使用Fragment时，对其使用方法有疑惑，以下或许能解释部分：为什么使用Fragment参考自官方：主要是为了在大屏幕手机（如平板电脑）上更加零落的UI设计，可以更方便地组合和交换UI组件。","text":"这一章前面部分主要讲解Fragment的基本使用，这点我觉得官方文档关于fragment的知识可能会更好一些，以下是官方的阐述：主要是平时使用Fragment时，对其使用方法有疑惑，以下或许能解释部分：为什么使用Fragment参考自官方：主要是为了在大屏幕手机（如平板电脑）上更加零落的UI设计，可以更方便地组合和交换UI组件。 Fragment的创建想为Fragment提供布局，则必须实现onCreateView()回调，可以通过xml定义布局资源，为此，onCreateView()提供了一个LayoutInflater对象： public static class ExampleFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // Inflate the layout for this fragment return inflater.inflate(R.layout.example_fragment, container, false); } }向Activity中添加Fragment1、在Activity的布局文件中声明：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:name=&quot;com.example.ListFragment&quot; android:id=&quot;@+id/list&quot; android:layout_weight=&quot;1&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;fragment android:name=&quot;com.example.AticleFragment&quot; android:id=&quot;@+id/viewer&quot; android:layout_weight=&quot;2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/LinearLayout&gt; 官方解释:Activity初始化布局时，会实例化布局中指定的每个fragment，并为每个Fragment调用onCreateView()方法，系统会直接插入Fragment返回的View来替代元素。 2、通过编程方式将Fragment添加到某个现有的ViewGroup：可以在Activity运行期间将Fragment添加进去，你只需要指定Fragment要放入哪个ViewGroup，这需要使用FragmentTransaction： FragmentManager fragmentManager = getFragmentManager(); FragmentTransaction transaction = fragmentManager.beginTransaction();然后，你可以使用add()方法添加一个fragment： ExampleFragment fragment = new ExampleFragment(); transaction.add(R.id.fragment_container,fragment); transaction.commit(); 一旦通过FragmentTransaction做出了更改，就必须commit以使更改生效。 3、添加没有UI的Fragment：你可以使用Fragment为Activity提供后台行为，而不显示额外的UI。使用函数： add(Fragment,String)String类型参数为Fragment提供一个唯一的字符串标记，由于Fragment没有雨Activity中的视图关联，因此不会收到onCreate()调用，因此你可以不实现这个方法。如果你稍后想从Activity中获取到这个Fragment，可以使用findFragmentByTag()。 可以在SDK的sample中查看具体用法：/APIDemos/app/src/main/java/com/example/android/apis/app/FragmentRetainInstance.java 执行Fragment事务需要使用FragmentTransaction，可以使用： add() 、remove() 、replace()等方法设置想要执行的更改，然后commit生效。 不过在commit之前你可能想调用 addToBackStack()将其添加到Fragment事务返回栈，允许用户按返回键返回上一Fragment状态。 来个例子： /**create new fragment and transaction**/ Fragment newFragment = new ExampleFragment(); FragmentTransaction transaction = getFragment().beginTransaction(); /**Replace whatever is in the fragment_container view with this fragment and add the transaction to the back stack**/ transaction.replace(R.id.fragment_container,newFragment); transaction.addToBackStack(null); //commit the transaction transaction.commit();向FragmentTransaction添加更改的顺序无关紧要，但有一些注意事项： commit操作不会立即执行，而是等主线程认为可以执行的时候再运行，不过，如果有必要，你也可以从主线程调用executePendingTransactions() 以立即执行commit。 最后必须调用commit，而且只能在用户离开Activity之前commit，否则会引发异常，如果对于需要commit的更改无关紧要，可以使用commitAllowingStateLoss()。 可以向同一个容器中添加多个fragment，你添加的顺序决定他们在视图层次结构中出现的顺序。 管理Fragment需要使用FragmentManager，你可以使用它执行以下操作： findFragmentById() （对于在Activity布局中提供UI的Fragment）或者findFragmentByTag()（对于提供或者不提供UI的Fragment都可）。 popBackStack() (模拟用户发出的返回命令)，将Fragment从返回栈中弹出。 addOnBackStackChangedListener() 监听返回栈变化 与Activity通信Fragment可以通过getActivity()访问Activity实例，并轻松执行诸如在Activity布局中查找视图等任务： View listView = getActivity().findViewById(R.id.list);同样，Activity也可以使用findFragmentById 或者 findFragmentByTag,通过从FragmentManager获取Fragment的引用来调用Fragment中的方法： ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);一个应用场景例子一个新闻应用中Activity两个Fragment，Fragment A放列表list，Fragment B 放对应内容，那么A在列表项选定后，告诉Activity，以便Activity通知B显示该新闻。其方案可以这样设计： 在A中声明接口OnArticleSelectedListener ： public static class FragmentA extends ListFragment { ... // Container Activity must implement this interface public interface OnArticleSelectedListener { public void onArticleSelected(Uri articleUri); } ... }同事在Activity中实现接口OnArticleSelectedListener，在A的onAttach方法时判断Activity是否这样做了： public static class FragmentA extends ListFragment { OnArticleSelectedListener mListener; ... @Override public void onAttach(Activity activity) { super.onAttach(activity); try { mListener = (OnArticleSelectedListener) activity; } catch (ClassCastException e) { throw new ClassCastException(activity.toString() + &quot; must implement OnArticleSelectedListener&quot;); } } ... }当有点击事件的时候，A看起来是这样子的： public static class FragmentA extends ListFragment { OnArticleSelectedListener mListener; ... @Override public void onListItemClick(ListView l, View v, int position, long id) { // Append the clicked item&apos;s row ID with the content provider Uri Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id); // Send the event and Uri to the host activity mListener.onArticleSelected(noteUri); } ... }Fragment的生命周期如下图： 其中将fragment进行至fragment的resume状态（即可以跟用户交互）的核心序列如下： onAttach(Activity) ：activity与fragment关联的时候调用. onCreate(Bundle) ：fragment初始化的时候调用. onCreateView(LayoutInflater, ViewGroup, Bundle) ：为fragment创建返回view界面. onActivityCreated(Bundle): 通知fragment它绑定的那个Activity已经执行完了onCreate()操作. onViewStateRestored(Bundle)： 通知fragment它保存的view state已经被恢复了. onStart()： fragment对用户可见 (还要取决于包含这个fragment的activity是否已经启动了). onResume()： 使fragment可以和用户交互了 (还要取决于包含这个fragment的activity是否已经resume了).如果一个fragment不再使用了，它会执行一系列相反的过程: onPause()： fragment不能与用户交互（可能是由于activity的pause）。 onStop()： fragment不可见了（可能是由于activitystop了）。 onDestroyView()：通知fragment清理与它相关的view资源。 onDestroy()：在完全清理fragment的状态时调用。 onDetach()：当fragment与activity解除绑定时调用。 动态加载布局的技巧使用限定符如果使用平板就会发现里面的应用基本上是双页模式，但是在手机上限于屏幕大小，都是单页模式。如果判断该使用双页模式还是单页模式，这就要借助限定符（qualifiers）来实现了，我们可以有两个布局文件，一个 layout_single.xml 单页模式布局放在layout目录，一个 layout_double.xml 双页模式布局放在 layout-large 目录，其中的large是个限定符。Android中常用限定符如下： 使用最小限定符前面解决了单页双页模式，但是到底怎么才算large，我们需要更精确地控制的话，需要最小限定符。我们新建layout-600dp文件夹，将双页布局文件放入其中，这样就会意味着，当程序运行在宽度小于600dp的设备上时，显示的是单页布局，否则使用的是双页布局。 以上两种技巧可以将手机版和pad版都使用同一个app，避免维护多个app，一处改动，需要在两个app中同步改动。注意在代码中区别目前是双页模式还是单页模式，可以用以下方式： 12345if(findViewById(R.id.anotherpageid) == null)&#123; //单页&#125;else&#123; //双页&#125; 其中R.id.anotherpageid是在单页中所没有的那个布局的id。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第3章：软件和也要拼脸蛋","slug":"第一行代码（第二版）-第三章","date":"2018-06-09T00:00:00.000Z","updated":"2019-11-17T13:50:58.877Z","comments":true,"path":"2018/06/09/第一行代码（第二版）-第三章/","link":"","permalink":"https://glassx.gitee.io/2018/06/09/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%89%E7%AB%A0/","excerpt":"布局文件中如果添加Button，并指定其text为”button”的话，但是显示的是”BUTTON”，全部变为大写了，要去掉这一效果，可以添加属性android:textAllCaps=”false”RelativeLayout 中还有另外一组对于控件进行定位的属性，android:layout_alignLeft表示让一个控件的左边缘和另一个控件的左边缘对齐，同理，还有android:layout_alignRight、Top、Bottom 。","text":"布局文件中如果添加Button，并指定其text为”button”的话，但是显示的是”BUTTON”，全部变为大写了，要去掉这一效果，可以添加属性android:textAllCaps=”false”RelativeLayout 中还有另外一组对于控件进行定位的属性，android:layout_alignLeft表示让一个控件的左边缘和另一个控件的左边缘对齐，同理，还有android:layout_alignRight、Top、Bottom 。 创建自定义控件我们所用的所有控件都是直接或者间接继承自View的，所有的布局都是直接或者间接继承ViewGroup，View是Android中最基本的一种UI组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是在View的基础上添加各自特有功能；而ViewGroup则是一种特殊的View，它可以包含很多子View和子ViewGroup，是一个防止控件和布局的容器。常用控件和布局的继承结构如下图所示： App中的标题栏几乎在每个界面都是一样的，除了标题不一样，其他的诸如左边按钮点击就finish当前页面，右边的是菜单按钮，这些功能基本上一样，如果在每个页面都单独为这些按钮重复添加相同的监听，比较繁琐。所以可以将标题栏单独封装成单独的一个TitleLayout的，每次只需要引入到布局中即可。 使用listview可以继承ArrayAdapter简化操作，类似如下(当然，这里在getView的时候没有进行复用优化，仅仅只是示例)： 12345678910111213141516171819public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt;&#123; private int resourceId; public FruitAdapter(Context context,int resourceId,List&lt;Fruit&gt; objects)&#123; super(context,resourceId,objects); this.resourceId = resourceId; &#125; @Override public View getView(int position,View convertView,ViewGroup parent)&#123; Fruit fruit = getItemt(position); View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false); ImageView ivFruit = view.findViewById(R.id.img); TextView tvFruit = view.findViewById(R.id.txt); ivFruit.setImageResource(fruit.getImageId()); tvFruit.setText(fruit.getName()); return view; &#125;&#125; 使用更强大的RecyclerView在设置LayoutManager的时候，可以指定排布的方向比如以下代码： 12LinearLayoutManager manager = new LinearLayoutManager(this);manager.setOrientation(LinearLayoutManager.HORIZONTAL);//平时一般使用竖直方向，这里特意指定横向 为什么Listview很难或者根本无法实现这种效果呢，其实这主要得益于RecyclerView的出色设计，ListView的布局排列是由自身去管理的，，而RecyclerView则将这个工作交给了LayoutManager，LayoutManager指定了一套可扩展的布局排列接口，自雷只要按照接口的规范来实现，就能定制出不同排列方式的布局了。 实现点击事件，可以在Adapter中的onCreateViewHolder方法中来做到，诸如以下实现： 123456789101112@Overridepublic ViewHolder onCreateViewHolder(ViewGroup parent,int viewType)&#123; View view = LayoutInflater.from(parent.getContext).inflate(R.layout.fruit_item,parent,false); final ViewHolder holder = new ViewHolder(view); holder.ivFruit.setOnclickListener(new View.OnclickListener()&#123; @Override public void onClick(View v)&#123; int postion = holder.getAdapterPosition(); //doSomeThing you want &#125; &#125;);&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"Intent 传递的数据过大","slug":"Intent传递数据过大","date":"2018-06-07T00:00:00.000Z","updated":"2019-11-17T14:01:29.047Z","comments":true,"path":"2018/06/07/Intent传递数据过大/","link":"","permalink":"https://glassx.gitee.io/2018/06/07/Intent%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7/","excerpt":"","text":"这个问题源于最近做的项目中出现的bug，一个Activity A通过startActivity(intent)的方式（intent中携带了String类型的data）启动另一个Activity B时，发生了崩溃，查看错误日志如下：可以看到，这是 android.os.TransactionTooLargeException ，字面意思是事务太大。这就很好理解了，因为笔者使用了intent携带数据，在事后分析这个data在传入的时候大约50k，因此导致了这个问题。后来使用SharedPreference将数据捎带过去解决了问题，这个bug本身看懂了报错就很简单，因此不再赘述。后面有空有兴趣之后再补上分析Intent传递数据到底是多大的限制。","categories":[{"name":"问题","slug":"问题","permalink":"https://glassx.gitee.io/categories/%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"问题记录","slug":"问题记录","permalink":"https://glassx.gitee.io/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"Listview 中 CheckBox 状态错误问题原因及解决方案","slug":"listview搭配checkbox问题","date":"2018-06-05T00:00:00.000Z","updated":"2019-11-17T14:01:36.696Z","comments":true,"path":"2018/06/05/listview搭配checkbox问题/","link":"","permalink":"https://glassx.gitee.io/2018/06/05/listview%E6%90%AD%E9%85%8Dcheckbox%E9%97%AE%E9%A2%98/","excerpt":"在开发过程中碰到很多问题，有些问题在锤子便签中记录了一个概要，有的问题甚至连记录都没有，此次开个头，将碰到的问题记录下来。今天要写的问题跟Listview有关，顺便复习下ListView的相关复用机制，以及Listview的Adapter中getView方法为什么需要ViewHolder，是怎么提高加载效率的。下面开始进入回忆状态，事情的经过是这样的：","text":"在开发过程中碰到很多问题，有些问题在锤子便签中记录了一个概要，有的问题甚至连记录都没有，此次开个头，将碰到的问题记录下来。今天要写的问题跟Listview有关，顺便复习下ListView的相关复用机制，以及Listview的Adapter中getView方法为什么需要ViewHolder，是怎么提高加载效率的。下面开始进入回忆状态，事情的经过是这样的： 在平时的 Android 开发过程中，我们可能需要去实现以下效果： 在 Listview 中使用CheckBox，但是会碰到 CheckBox 选中/非选中 这种状态错乱的问题，笔者最近在项目中就碰到了，比如我选中了 id0、id1、id2 三个 CheckBox ，再想选择 id15 ，这就要求滑动 Listview 了，滑到 id15 CheckBox 将其选中，再滑动到顶部，握草，发现 id0、id1、id2 已经变成 非选中 状态了，莫非是我记错了？再重新来一次，还是一样！这就不科学了，一定是哪里出了问题，我当时的代码是这样的： @Override public View getView(final int i, View view, ViewGroup viewGroup) { ViewHolder viewHolder = null; if(view == null){ viewHolder = new ViewHolder(); view = LayoutInflater.from(context).inflate(R.layout.layout,null); viewHolder.cb = (CheckBox) view.findViewById(R.id.select_cb); viewHolder.tvName = (TextView) view.findViewById(R.id.name_tv); view.setTag(viewHolder); }else{ viewHolder = (ViewHolder) view.getTag(); } viewHolder.cb.setChecked(data.get(i).isSlected()); viewHolder.tvName.setText(data.get(i).getName()); viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() { @Override public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked) { data.get(i).setSlected(isChecked); } }); return view; }脑子里第一反应是各处的 item 串了，联想到使用 viewholder 来复用 item ，于是就去了解了一番 Listview 对 item 的复用机制。 复用机制我们知道，listview 需要承载大量的数据，并且需要写一个 Adapter 与其适配，这样数据就能展现出来了，但是不知道大家有没有仔细想过，为什么需要 Adapter 这个东西，它到底起了个什么作用。 从 Adapter 说起说到底，Android 中控件就是为了展示数据以及交互用，只不过Listview特殊些，它用于展示大量的信息的，但是 Listview 只承担交互和展示工作的，至于数据来自哪里，它不care。这样，listview工作最基本需要一个 Listview 控件和一个数据源，但是数据源可能是数组，可能是集合，甚至可能是数据库表中查询出来的游标，如果 Listview 要去为每一种数据源进行匹配的话，它一定会变得非常臃肿了，于是 Adapter 出现了。 顾名思义，Adapter 是适配器的意思，它在 Listview 与数据源之间起了一个桥梁作用，与之前的情况不同的是，Adapter 的接口都是统一的，因此 Listview 不需要担心任何适配问题。而 Adapter 是个接口（interface），它可以有各种子类，比如 ArrayAdapter 可用于数组和 List 类型的数据源匹配，SimpleCursorAdapter 可以用于游标类型的数据源匹配，这样把适配问题解决了，并且扩展性不错。 RecycleBin 类在解释复用机制之前，还有必要说一下 RecycleBin 类，因为它是 Listview 能够展现成百上千条数据并且不会 OOM 的关键，RecycleBin 是 AbsListview 的一个内部类，其主要代码如下： /** * The RecycleBin facilitates reuse of views across layouts. The RecycleBin * has two levels of storage: ActiveViews and ScrapViews. ActiveViews are * those views which were onscreen at the start of a layout. By * construction, they are displaying current information. At the end of * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews * are old views that could potentially be used by the adapter to avoid * allocating views unnecessarily. */ class RecycleBin { private RecyclerListener mRecyclerListener; /** * The position of the first view stored in mActiveViews. */ private int mFirstActivePosition; /** * Views that were on screen at the start of layout. This array is * populated at the start of layout, and at the end of layout all view * in mActiveViews are moved to mScrapViews. Views in mActiveViews * represent a contiguous range of Views, with position of the first * view store in mFirstActivePosition. */ private View[] mActiveViews = new View[0]; /** * Unsorted views that can be used by the adapter as a convert view. */ private ArrayList&lt;View&gt;[] mScrapViews; private int mViewTypeCount; private ArrayList&lt;View&gt; mCurrentScrap; /** * Fill ActiveViews with all of the children of the AbsListView. * * @param childCount * The minimum number of views mActiveViews should hold * @param firstActivePosition * The position of the first view that will be stored in * mActiveViews */ void fillActiveViews(int childCount, int firstActivePosition) { if (mActiveViews.length &lt; childCount) { mActiveViews = new View[childCount]; } mFirstActivePosition = firstActivePosition; final View[] activeViews = mActiveViews; for (int i = 0; i &lt; childCount; i++) { View child = getChildAt(i); AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams(); // Don&apos;t put header or footer views into the scrap heap if (lp != null &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) { // Note: We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in // active views. // However, we will NOT place them into scrap views. activeViews[i] = child; } } } /** * Get the view corresponding to the specified position. The view will * be removed from mActiveViews if it is found. * * @param position * The position to look up in mActiveViews * @return The view if it is found, null otherwise */ View getActiveView(int position) { int index = position - mFirstActivePosition; final View[] activeViews = mActiveViews; if (index &gt;= 0 &amp;&amp; index &lt; activeViews.length) { final View match = activeViews[index]; activeViews[index] = null; return match; } return null; } /** * Put a view into the ScapViews list. These views are unordered. * * @param scrap * The view to add */ void addScrapView(View scrap) { AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams(); if (lp == null) { return; } // Don&apos;t put header or footer views or views that should be ignored // into the scrap heap int viewType = lp.viewType; if (!shouldRecycleViewType(viewType)) { if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) { removeDetachedView(scrap, false); } return; } if (mViewTypeCount == 1) { dispatchFinishTemporaryDetach(scrap); mCurrentScrap.add(scrap); } else { dispatchFinishTemporaryDetach(scrap); mScrapViews[viewType].add(scrap); } if (mRecyclerListener != null) { mRecyclerListener.onMovedToScrapHeap(scrap); } } /** * @return A view from the ScrapViews collection. These are unordered. */ View getScrapView(int position) { ArrayList&lt;View&gt; scrapViews; if (mViewTypeCount == 1) { scrapViews = mCurrentScrap; int size = scrapViews.size(); if (size &gt; 0) { return scrapViews.remove(size - 1); } else { return null; } } else { int whichScrap = mAdapter.getItemViewType(position); if (whichScrap &gt;= 0 &amp;&amp; whichScrap &lt; mScrapViews.length) { scrapViews = mScrapViews[whichScrap]; int size = scrapViews.size(); if (size &gt; 0) { return scrapViews.remove(size - 1); } } } return null; } public void setViewTypeCount(int viewTypeCount) { if (viewTypeCount &lt; 1) { throw new IllegalArgumentException(&quot;Can&apos;t have a viewTypeCount &lt; 1&quot;); } // noinspection unchecked ArrayList&lt;View&gt;[] scrapViews = new ArrayList[viewTypeCount]; for (int i = 0; i &lt; viewTypeCount; i++) { scrapViews[i] = new ArrayList&lt;View&gt;(); } mViewTypeCount = viewTypeCount; mCurrentScrap = scrapViews[0]; mScrapViews = scrapViews; } } 注释说 RecycleBin 用于view的reuse，它维持了两个存储空间，ActiveViews 和 ScrapViews，前者存放显示在屏幕上的view，到列表最后的时候，它里面的view都会去到 ScrapViews 中。而后者用于存放 old views ，这些view可能可以直接以convertView的形式直接利用，避免没必要的 allocat 内存，这就是Adapter中convertView的由来。 fillActiveViews() :这个方法会根据传入的参数来将 Listview 中指定的元素存储到 mActiveViews 数组中。 getActiveView() :跟 fillActiveViews 方法对应，用于从 mActiveViews 中获取数据，需要注意的是，一旦第 position 个数据被获取成功之后，该view就会从 mActiveViews 中移除，下次再获取第position个位置将会返回 null，也就是说mActiveViews不能复用。 addScrapView() :用于将一个废弃的view进行缓存，当一个view要废弃的时候（比如滚出屏幕），就调用该方法缓存，以便下次使用。 getScrapView() :从 ScrapViews 中取出一个view，这些废弃缓存中的view是没有顺序可言的，因此取的算法也非常简单，获取尾部的就行。 setViewTypeCount() :我们知道在 adapter 中我们可以重写 getViewTypeCount() 来表示Listview中有几种类型的数据项，而setViewTypeCount()的作用就是为每种类型的数据项都单独启用一个 RecycleBin 缓存机制。 扯点view的绘制Listview 再牛逼，也是继承自view的，而view的执行流程就是3步，onMeasure() 用于测量 view 的大小，onLayout() 用于确定 View 的布局，onDraw() 用于将 view 绘制到界面上。 Listview 最特殊的地方在于 onLayout() ,而这是在它父类 AbsListview 中实现的，它主要就一个重要判断：如果 Listview 的大小或者位置发生了变化，那就要求所有子布局强制重绘。而 layoutchildren() 方法是用来进行子元素布局的，具体由 Listview 自己实现，可以解析下。 刚开始，Listview 中没有任何子view，因此会去调用 fillActiveViews() 方法，这是为了将 Listview 中的子 view 进行缓存的，由于此时子 view 为空，因此会调用 fillFromTop() ，最终调用到 fillDown() 方法，进行 Listview 的填充操作。fillDown() 中有个while循环，当遍历完从 Listview 顶部到底部的距离的item或者 adapter 中的数据遍历结束，while就跳出。在while中，执行 makeAndAddView() ，它会尝试从 RecycleBin 中快速获取 active view ，但此时 RecycleBin 中还未缓存任何view，因此获得null，所以就会尝试调用 obtainView() ，它是可以保证返回一个 view 的，于是将获取到的view立刻传入到了 setupChild() 中。 那到底 obtainView() 怎么保证获取到view的？不夸张地说，Listview 中最重要的内容都在 obtainView() 中了，该方法里首先调用了 RecycleBin 的 getScrapView() 方法尝试获取一个废弃缓存中的 view ，当然这时候是获取不到的，得到null，之后再调用 mAdapter 的 getView() 方法来获取一个 view ，这时候似曾相识了，有 adapter 和 getView() 方法了，对，就是我们平常写的那个 adapter，然后重写的那个 getView(),这时候会传入 position，convertView (此时为null)，parent (当然是 this 了)。 捋一下item的复用一切从 onLayout 开始，当大小或者位置发生了变化，就会调用onLayout，onLayout完毕之后，就剩下 ondraw 去绘制了。onLayout中，（为了叙述方便，不考虑数据不足以填满Listview的情况），首先要拿item的view放到Listview中，先从ActiveViews中拿，如果为空，则打算从 ScrapViews 中拿，还是为空，则利用 adapter 去创造，创造一屏 itemview 填充于 ActiveViews 中，之后 Listview 从 ActiveViews 中取出 itemview ，ActiveViews 删除该 itemview ，如果 itemview 滑动隐藏了，就会丢弃到 ScrapViews 中，这样滑动的时候触发 onLayout ，onLayout 再去找 itemview 填充，如果有现成的就用，没有就创造。 分析源码谈原因再来看源码，为了更方便，加上toast提示： @Override public View getView(final int i, View view, ViewGroup viewGroup) { ViewHolder viewHolder = null; if(view == null){ viewHolder = new ViewHolder(); view = LayoutInflater.from(context).inflate(R.layout.layout,null); viewHolder.cb = (CheckBox) view.findViewById(R.id.select_cb); viewHolder.tvName = (TextView) view.findViewById(R.id.name_tv); view.setTag(viewHolder); }else{ viewHolder = (ViewHolder) view.getTag(); } viewHolder.cb.setChecked(data.get(i).isSlected()); viewHolder.tvName.setText(data.get(i).getName()); viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() { @Override public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked) { Toast.makeText(context,&quot;这是点击了第&quot; + i + &quot;个&quot; ,Toast.LENGTH_SHORT).show(); data.get(i).setSlected(isChecked); } }); return view; }运行之后我们看到整个列表，选中第1个，会弹toast “这是点击了第0个” 接着往上慢慢滑动，直至将第一个item隐藏的时候，发现 toast 弹出来了，显示 这是点击了第0个！而这个时候最下面之前被第一条隐藏的item也展现出来了，综合上面的知识，可以知道，这个隐藏的item是复用了第1个item的view，复用view的时候，由于该隐藏item是未checked，而第一条item是已经checked，因此它执行 viewHolder.cb.setChecked(data.get(i).isSlected()); 的时候，会触发 OnCheckedChangeListener ，由于之前第一个 item 设置了监听： viewHolder.cb.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() { @Override public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked) { Toast.makeText(context,&quot;这是点击了第&quot; + i + &quot;个&quot; ,Toast.LENGTH_SHORT).show(); data.get(i).setSlected(isChecked); } });这时候就触发了监听事件，因此toast就弹出来了，并且把第一条item的数据也由checked改成unchecked，因此你下次再见到第一个item的时候，状态就变成unchecked了。 结论最后可以说结论了，这个现象是由于listview中item复用导致，如果你不用viewholder是不会有这问题的，其实这个结论并不重要，重要的是理解这里面的发生机制。当然，说了问题起因，当然得给个解决方案，方法不止一种，我个人用的一种方法是在 viewHolder.cb.setChecked(data.get(i).isSlected()); 之前添加一句： viewHolder.cb.setOnCheckedChangeListener(null); 我想你肯定知道为什么。 注：参考（引用）以下博客劳动成果： 郭霖 ： Android ListView工作原理完全解析，带你从源码的角度彻底理解","categories":[{"name":"问题","slug":"问题","permalink":"https://glassx.gitee.io/categories/%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"问题记录","slug":"问题记录","permalink":"https://glassx.gitee.io/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"第2章：先从看得到的入手","slug":"第一行代码（第二版）-第二章","date":"2018-06-01T00:00:00.000Z","updated":"2019-11-17T13:51:11.986Z","comments":true,"path":"2018/06/01/第一行代码（第二版）-第二章/","link":"","permalink":"https://glassx.gitee.io/2018/06/01/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"Intent使用显式地就不说了，使用隐式的Intent时并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，并帮我们找出合适的活动去启动。普通的隐式Intent使用比如在AndroidManifest.xml中声明activity的时候，可以添加：","text":"Intent使用显式地就不说了，使用隐式的Intent时并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，并帮我们找出合适的活动去启动。普通的隐式Intent使用比如在AndroidManifest.xml中声明activity的时候，可以添加： 1234&lt;intent-filter&gt; &lt;action android:name=\"com.example.ACTION_START\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt;&lt;intent-filter&gt; 在代码中就能以下面代码来启动这个activity了（由于category是DEFAULT，所以在intent中并未指定category了）： 12Intent intent = new Intent(\"com.example.ACTION_START\");startActivity(intent); 如果在AndroidManifest.xml中声明activity的时候同时指定了action和category，那么必须要在Intent中严格匹配才能打开，否则可能报错，比如写成： 12345&lt;intent-filter&gt; &lt;action android:name=\"com.example.ACTION_START\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;category android:name=\"com.example.MY_CATEGORY\"/&gt;&lt;intent-filter&gt; 则代码中必须添加以下代码才能正确运行。 123Intent intent = new Intent(\"com.example.ACTION_START\");**intent.addCategory(\"com.example.MY_CATEGORY\");**startActivity(intent); 更多隐式Intent用法使用隐式的Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，比如说要在应用程序中点击一个按钮，然后要在浏览器中打开一个网页，则使用以下代码： 123Intent intent = new Intent(Intent.ACTION_VIEW);intent.setData(Uri.parse(\"http://www.baidu.com\"));startActivity(Intent); 这里面，setData()接收一个Uri对象，主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传入到Uri.parse()方法中解析产生的。那如果我们要自己写个浏览器应用，让其它应用也能像这样利用我们的APP打开网页，又该怎么做呢，这就要求在中添加一个&lt;data标签&gt;，用于更精确地指定当前活动能够响应什么类型的数据。标签中可以配置以下内容： android:scheme。用于指定数据的协议部分，例如上例中的http部分。 android:host。用于指定数据的主机名部分，如上例中的www.baidu.com。 android:port。用于指定数据的端口部分。 android:path。用于指定主机名和端口之后的部分。 所以，如果我们要做一个浏览器，至少要在AndroidManifest.xml对主activity声明： 123456&lt;intent-filter&gt; &lt;action android:name=\"com.example.ACTION_START\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:scheme=\"http\"&gt;&lt;intent-filter&gt; 下次其他APP需要用http协议打开网页时，我们的APP也会在候选列表中了。除了http协议意外，我们还可以指定很多其他协议，比如geo表示地理位置、tel表示拨打电话。 活动的生命周期 onCreate()，活动第一次被创建的时候调用，应该在这里面完成活动的初始化操作。 onStart()，在活动由不可见变为课件的时候调用。 onResume()，在活动准备好和用户进行交互的时候调用，此时活动一定位于返回栈的栈顶，并且处于运行状态。 onPause()，在系统准备去启动或者恢复另一个活动的时候调用，通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但是工作不能太多，不然会影响下一个Activity的使用。 onStop(),活动完全不可见的时候调用，它和onPause主要的区别在于，如果启动的新活动是一个对话框式的活动，那么onPause方法会得到执行，而onStop不会执行。 onDestroy()，活动晓辉之前调用。 onRestart()，由停止状态变为运行状态之前调用。一般是由上一个活动返回到当前活动。 活动回收了怎么办想象以下场景，应用中有活动A，在A的基础上启动活动B，活动A此时进入了停止状态，此时由于内存不足，将活动A回收了，然后用户按Back键返回活动A，会出现什么情况呢？其实还是会正常显示A，只不过这是并不会执行onRestart方法，而是会执行活动A的onCreate方法，因为活动A在这种情况下会被重新创建一次。 如果A进程中有输入框，并且已经输入了一些文字了，如果回收被重新创建，那么会丢失输入的信息，影响用户体验。Activity中还提供了一个onSaveInstanceState()回调方法，这个方法可以保证在活动回收之前一定会被调用，这个方法会携带一个Bundle类型的参数，它允许以key-value的形式存取值，我们可以这样将要保存的数据存下来： 12345@Override public void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putString(\"name\",\"glassx\"); &#125; 数据已经保存下来了，但是在哪里恢复呢？其实我们一直使用的onCreate方法其实也有一个Bundle类型的参数，这个参数一般情况下是null，如果在活动呗系统回收之前有通过onSaveInstanceState保存的话，这个参数就会带有之前所保存的全部数据，因此通过以下方法取即可： 12345678@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if(savedInstanceState != null)&#123; String name = savedInstanceState.getString(\"glassx\"); &#125; &#125; 活动的启动模式在实际项目中我们应该根据特定的需求为每个活动指定恰当的启动模式，启动模式一种四种：standard、singleTop、singleTask、singleInstance。 standard是默认的启动模式。每次启动都会创建一个新的实例。 singleTop：有些情况下，可能会觉得standard不太合理，活动明明已经在栈顶了，为毛还要再创建新的实例呢？singleTop模式可以解决这个问题，当活动以该模式启动时，如果发现返回栈的栈顶已经是该活动，那就直接使用它，不创建新的实例，并且调用栈顶实例的onNewIntent方法；如果栈顶不是该活动，就创建该活动的新的实例。 singleTask：如果活动的启动模式指定为singleTask，那么每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果有，把这个活动之上的所有活动统统出栈，并且直接使用该实例，并调用该实例的onNewIntent方法？？（存疑，等会实践下）。反之没有的话就创建该活动的实例。 singleInstance：指定为singleInstance模式的活动会启用一个新的返回栈来管理这个活动（其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈）。 那么这样做有什么意义呢？想象以下场景，我们的程序中有一个活动是允许其他程序调用的，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，应该如何实现呢？前面3中模式做不到，因为每个应用程序都会有自己的返回栈，同一个活动在不同的返回栈中入栈必然是创建了新的实例。而使用singleInstance模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活动，不管哪个应用来访问这个活动，都公用一个返回栈，也就解决了共享活动实例的问题。 注意：如果三个活动，A和C都是standard模式，B是singleInstance模式，那么A启动B，B启动C后，在C界面按返回键是回退到A，再按返回键回退到B，接着按返回键才会退出应用，因为A和C是同一个回退栈中，B单独在一个栈中，可以用如下图来理解这一过程。 活动的最佳实践知晓当前是在哪一个活动建一个BaseActivity，在onCreate的时候打印出来当前实例的类名，之后其他的activity都继承这个activity即可： 123456@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(\"BaseActivity\",getClass().getSimpleName()); &#125; 随时随地退出app如果你在第三个activity界面，这个时候想要退出App是非常不方便的，可以新建一个类来管理所有Activity： 1234567891011121314151617public class ActivityController&#123; public static List&lt;Activity&gt; activities = new ArrayList&lt;Activity&gt;(); public static void addActivity(Activity ac)&#123; activities.add(ac); &#125; public static void removeActivity(Activity ac)&#123; activities.remove(ac); &#125; public static void finishAll()&#123; for(Activity ac : activities)&#123; ac.finish(); &#125; &#125;&#125; 这样只需要在BaseActivity的onCreate里面执行ActivityController的addActivity方法，即可把Activity添加进去，在BaseActivity的onDestroy方法中执行removeActivity，将其移除，在需要退出app的时候，只需要执行finishAll即可。 启动活动最佳写法每个Activity中都写上启动自己的方法： public class TestActivity extends BaseActivity{ public static void actionStart(Context context,String name,String sex){ Intent intent = new Intent(context,TestActivity.class); intent.putExtra(\"name\",name); intent.putExtra(\"sex\",sex); context.startActivity(intent); } } 这样做的一个好处就是，启动这个activity所需要的参数一目了然，而无需阅读这个activity的源码就可以直接调用方法就能避免漏掉参数。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第1章：开启启程","slug":"第一行代码（第二版）-第一章","date":"2018-05-31T10:00:00.000Z","updated":"2019-11-17T13:50:45.237Z","comments":true,"path":"2018/05/31/第一行代码（第二版）-第一章/","link":"","permalink":"https://glassx.gitee.io/2018/05/31/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89-%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"Android系统架构 最底层是Linux内核层。 为Android设备各种硬件提供了底层驱动，如显示驱动，音频驱动等。 系统运行库层。 这层通过一些C/C++库来为Android系统提供主要的特性支持。如Sqlite库提供了数据库支持，OpenGL|ES提供提供3D绘图等。 应用框架层。 主要提供了构建应用程序可能用到的各种API。 应用层。 所有安装在手机上的应用程序都属于这一层。比如系统自带的联系人、短信等程序，自己开发的应用。","text":"Android系统架构 最底层是Linux内核层。 为Android设备各种硬件提供了底层驱动，如显示驱动，音频驱动等。 系统运行库层。 这层通过一些C/C++库来为Android系统提供主要的特性支持。如Sqlite库提供了数据库支持，OpenGL|ES提供提供3D绘图等。 应用框架层。 主要提供了构建应用程序可能用到的各种API。 应用层。 所有安装在手机上的应用程序都属于这一层。比如系统自带的联系人、短信等程序，自己开发的应用。 Android应用开发特色四大组件四大组件分别是活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）和内容提供器（Content Provider） build.gradle 文件中，compileSdkVersion用于指定项目的编译版本；buildToolsVersion用于指定项目构建工具的版本；applicationId用于指定项目的包名，并且它的优先级高于在 AndroidManifest.xml中指定的包名；minSdkVersion用于指定项目最低兼容的Android版本;targetSdkVersion表明你在该目标版本上做过了充分的测试，系统将为你的应用程序启用一些最新的功能和特性。比如说Android6.0 系统中引入了运行时权限这个功能，如果你将targetSdkVersion指定成23或者更高，那么系统就会为你的程序启用运行时权限功能；否则就不会启用运行时权限功能。 而在build.gradle的dependencies闭包中，声明了当前项目所有的依赖关系，Android studio 项目一共有3中依赖方式，本地依赖、库依赖和远程依赖，本地依赖可以对本地的jar包或者目录添加依赖关系，形式如：compile fileTree(dir: ‘libs’, include: [‘*.jar’])；库依赖可以对项目中的库模块添加依赖关系，如compile(name: ‘testsdk’, ext: ‘aar’)；远程依赖则可以对jcenter库上的开源项目添加依赖关系，如compile ‘com.android.support.constraint:constraint-layout:1.0.2’，其中，com.android.support.constraint是域名，用于和其他公司的库作区分，constraint-layout是组名称，用于和同一个公司其他库作区分。 关于日志：不用System.out.println()，因为Log系统可以对日志分级，可以展示打印时间，可以添加过滤器等等。Log快捷键：如果要打Log.d，则输入logd，按tab键即可，同理Log.i只需要logi之后按Tab键，以此类推，四种级别的日志都能快捷打出来。还有，如果在oncreate方法外面输入logt，然后按下Tab键，就会以当前的类名作为值自动生成一个类似下面的TAG常量： 1234public class HelloWorldActivity extends AppCompatActivity&#123; private static final String TAG = \"HelloWorldActivity\";&#125;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-第一行代码（第二版）","slug":"读书笔记-第一行代码（第二版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/"}]},{"title":"第6章：死锁","slug":"现代操作系统（第三版）-第6章","date":"2018-05-30T10:00:00.000Z","updated":"2019-11-17T13:50:18.895Z","comments":true,"path":"2018/05/30/现代操作系统（第三版）-第6章/","link":"","permalink":"https://glassx.gitee.io/2018/05/30/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-%E7%AC%AC6%E7%AB%A0/","excerpt":"如果有两个进程A和B需要将扫描的文档记录到CD上，进程A请求扫描仪并被授权使用，请求CD时发现已被B占用了，于是被拒绝，同理，B请求扫描仪也会被拒绝，于是产生死锁。在一个数据库系统中，为了避免竞争，可对若干记录加锁，如果进程A对R1加锁了，进程B对R2加了锁，接着这两个进程又试图把各自对方的记录也加锁，这是也会产生死锁。所以，软硬件资源都可能出现死锁。","text":"如果有两个进程A和B需要将扫描的文档记录到CD上，进程A请求扫描仪并被授权使用，请求CD时发现已被B占用了，于是被拒绝，同理，B请求扫描仪也会被拒绝，于是产生死锁。在一个数据库系统中，为了避免竞争，可对若干记录加锁，如果进程A对R1加锁了，进程B对R2加了锁，接着这两个进程又试图把各自对方的记录也加锁，这是也会产生死锁。所以，软硬件资源都可能出现死锁。 资源和死锁条件资源分为两类，一类是可抢占资源（preemptable resource） 可以从拥有它的进程中枪战而不产生任何副作用，比如存储器。一个系统拥有256M的用户内存和一条打印机，如果有两个256M内存的进程都想打印，进程A获得了打印机，而B战友内存，但是幸运的是可以通过把进程B患处内存、把进程A换入内存可以实现抢占B的内存，这样，进程A继续运行并执行打印任务，然后释放打印机和内存。另一类是不可抢占资源（nonpreemptable resource）是指在不引起相关的计算失败的情况下，无法把它从占有它的进程中抢占过来，如CD刻录机。如果一个进程已经在开始刻盘，突然将刻录机分配给另一个进程，那么将划坏CD盘。 因此，总的来说，死锁和不可抢占资源有关，有关可抢占资源的潜在死锁通常可以通过在进程之间重新分配资源而化解，所以我们主要关注不可抢占资源上。当然，Coffman等人总结了发生（资源）死锁需要具备四个必要条件： 不可抢占。 已经分配给一个进程的资源不能强制性地被抢占，他只能被占有它的进程显式地释放。 互斥条件。 每个资源要么已经分配了一个进程，要么就是可用的。 占有和等待。 已经得到了某个资源的进程还可以再请求新的资源。 环路等待。 死锁发生时，系统中一定有由两个或者以上的进程组成一条环路，该环路中每个进程都在等待着下一个进程所占有的资源。 注意：死锁发生时，以上四个条件一定是同时满足的。任何一个不成立就不会发生死锁 死锁建模在讨论死锁解决方案之前，讨论如何对死锁建模是有意义的。有个叫Holt的人指出可以利用有向图建立死锁四个条件的模型——在有向图中有两类节点：用圆形表示进程，用方形表示资源。从资源节点到进程节点的有向边代表该资源已被请求、授权并被进程占用，由进程节点到资源节点的有向边表明当前进程正在请求该资源。以下是一个示意图： 图中，当前资源R整备进程A占用，进程B正等待着资源S，图c)进入了死锁状态，进程C等待着资源T，资源T被进程D占用，进程D又等待着由进程C占用的资源U。 处理方法总而言之，有四种处理死锁的策略： 忽略该问题。也许如果你忽略它，他也会忽略你。 检测死锁并恢复。 让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题。 仔细对资源进行分配，动态地避免死锁。 破坏引起死锁的四个必要条件之一，防止死锁产生。 以下对这四种策略分别阐述。 忽略问题最简单的方法是鸵鸟算法：把头埋进沙子里，假装根本没有问题发生。不同人对于该方法的看法不同，数学家认为这种方法不能接受，不管代价多大，都要彻底防止死锁产生；而对于工程师，它们会考量死锁发生的频率和严重性，如果平均5年一次死锁，那么大多数工程师不会以性能损失和可用性代价去防止死锁。 检测死锁和死锁恢复每种类型一个资源的死锁检测从最简单的例子开始，假定每种类型的资源只有一个，即排除了同时有两台打印机的情况。我们假设一个系统包括A到G共7个进程，R到W共6中资源，资源的占有情况和进程对资源的请求情况如下：（1）A进程持有R资源，且需要S资源。（2）B进程不持有任何资源，但需要T资源。（3）C进程不吃油任何资源，但需要S资源。（4）D进程持有U资源，且需要S资源和T资源。（5）E进程持有T资源，且需要V资源。（6）F进程持有W资源，且需要S资源。（7）G进程持有V资源，且需要U资源。 问：系统是否存在死锁？如果存在，涉及哪些进程？ 回答这一问题，初看很难，但是建模构造一张资源分配图之后，可以直观地看到图中包含了一个环，如下图所示： 在换种，可以看出进程D、E、G已经死锁，A、C、F没有死锁，因为可以把资源S分配给它们中的任意一个。 每种类型有多个资源的死锁检测如果一类资源可能存在多个，就需要采用另一个方法来检测死锁。现在我们提供一种基于矩阵的算法来检测从P1到Pn这n个进程中的死锁。假设资源类型数为m，E1代表资源类型1，E2代表资源类型2，以此类推。E是现有资源向量，代表每种已存在的资源总数，比如资源类型1代表磁带机，那么E1=2就表示系统有两台磁带机。 在任意时刻，某些资源已被分配所以不可用，假设A是可用资源向量，那么Ai表示当前可供使用的资源数（即没有被分配的资源）。如果仅有的两台磁带机都已经分配出去了，那么A1的值为0 。 现在我们需要两个数组：C代表当前当前分配矩阵，R代表请求矩阵。C的第i行代表Pi当前所持有的每一种类型资源的资源数，所以Cij代表进程i所持有的资源j的数量，同理Rij代表Pi所需要的资源j的数量，数据结构如下图： 这四种数据结构之间有一个重要的恒等式，具体地说，某种资源要么已分配，要么可用，这个结论意味着： 换言之，如果我们将所有已分配的资源j的数量加起来在和所有可供使用的资源数相加，结果就是该类资源的资源总数。死锁检测算法就是给予向量的比较，我们定义向量A和向量B之间的关系为A小于或等于B以表明A的每一个分量要么等于要么小于和B向量对应的分量。 每个进程起初是没有被标记的，算法开始会对进程做标记，进程被标记后就表明它们能够被执行，不会进入死锁，死锁检测算法如下： 寻找一个没有标记的进程Pi，对于它而言，R矩阵的第i行向量小于或等于A。 如果找到了这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转到第1步。 如果没有这样的进程，算法终止。 算法的第1步是寻找可以运行完毕的进程，该进程有资源请求并且该请求可被当前的可用资源满足。这一选中的进程随后就被运行完毕，在这段时间内它释放自己持有的所有资源并将它们返回到可用资源库中，然后，这一进程被标记为完成，如果所有的进程最终都能运行完的话，就不存在死锁，如果进程一直不能被运行，那它们就是死锁进程。 从死锁恢复我们讨论各种从死锁中恢复的方法，尽管这些方法看起来都不那么令人满意： 利用抢占恢复。 临时将资源从当前所有者哪里转移到另一个进程，许多情况下这是需要人工敢于的。比如，要将激光打印机从它持有的进程那里拿走，管理员可以收集已打印好的文档，然后该进程被挂起，接着打印机被分配给另一个进程。 利用回滚恢复。 周期性地将进程的状态写入一个文件以备重启。一旦检测到死锁，拥有所需要资源的进程会回滚到一个时间点，在此时间点之前该进程获得了一些其他资源，在该检查点之后所做的工作都丢失。实际上，是将该进程复位到一个更早的状态，那时候它还没取得所需的这个资源。接着就把这个资源分配给一个死锁进程。 杀死进程恢复。 杀死环中的一个进程。或者杀死环外带有该资源的一个进程。 动态避免死锁利用资源轨迹图、安全状态和不安全状态、银行家算法去解决。这里略复杂，暂时先不深入研究。 破坏引起死锁的四个条件之一 破坏互斥条件，如果资源不被一个进程独占，那么死锁肯定不会产生。 当然，允许两个进程同时使用打印机会造成混乱，通过采用假脱机（spooling printer）技术可以允许若干个进程同时产生输出。该模型中唯一真正请求使用物理打印机的进程是打印机守护进程，由于守护进程绝不会请求其他资源，因此不会产生死锁。 破坏占有和等待条件。只要禁止已持有资源的进程再等待其他资源便可以消除死锁。 一种实现方法是规定所有进程在开始执行前请求所需的全部资源。如果所需的全部资源可用，那么就将它们分配给这个进程，于是该进程肯定能够运行结束。如果一个或者多个资源正被使用，那么就不分配，进程等待。另一种方案是，要求当一个进程请求资源时，先暂时释放其当前占用的所有资源，然后再尝试一次获得所需要的全部资源。 破坏不可抢占条件。 假如一个进程已分配到一台打印机且正在进行打印输出，如果由于它需要的绘图仪无法获得而强制性把打印机抢占掉，则会引起混乱。但是，一些资源可以通过虚拟化的形式来避免发生这样的情况，假脱机打印机向磁盘输出，并且只允许打印机守护进程访问真正的物理打印机，就可以消除涉及打印机的死锁。然而，不是所有资源都可以进行类似的虚拟化，比如数据库中的记录在操作的时候必须要锁定，因此存在死锁的可能 破坏环路等待。 消除环路有几种方法。比较靠谱的方案是，对所有的资源统一编号，现在的规则是，进程可以在任何时刻提出资源请求，但是所有请求必须按照资源编号的顺序（升序）提出，如下图所示，进程可以先请求打印机后请求磁带机，但不可以先请求绘图仪后请求打印机。 最后，总结一张图用于预防死锁：","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-现代操作系统（第三版）","slug":"读书笔记-现代操作系统（第三版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/"}]},{"title":"第2章：进程与线程","slug":"现代操作系统（第三版）-第2章","date":"2018-05-29T10:00:00.000Z","updated":"2019-11-17T13:50:12.084Z","comments":true,"path":"2018/05/29/现代操作系统（第三版）-第2章/","link":"","permalink":"https://glassx.gitee.io/2018/05/29/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-%E7%AC%AC2%E7%AB%A0/","excerpt":"进程是操作系统提供的最古老也是最重要的抽象概念之一。即使CPU只有一个，但他们也支持（伪）并发操作的能力。他们将一个单独的CPU变换成多个虚拟的CPU，没有进程的抽象，现代计算将不复存在。进程在任何多道程序设计系统中，CPU由一个进程快速切换到另一个进程，使每个进程各运行几十或者几百个毫秒，严格地来说，在某一个瞬间，CPU只能运行一个进程，但在1秒钟期间，它可能运行多个进程，这样就能产生并行的错觉，这就是伪并行。伪并行概念用来区分多处理器系统（系统有两个或者更多CPU并共享同一个物理内存）的真正硬件并行。","text":"进程是操作系统提供的最古老也是最重要的抽象概念之一。即使CPU只有一个，但他们也支持（伪）并发操作的能力。他们将一个单独的CPU变换成多个虚拟的CPU，没有进程的抽象，现代计算将不复存在。进程在任何多道程序设计系统中，CPU由一个进程快速切换到另一个进程，使每个进程各运行几十或者几百个毫秒，严格地来说，在某一个瞬间，CPU只能运行一个进程，但在1秒钟期间，它可能运行多个进程，这样就能产生并行的错觉，这就是伪并行。伪并行概念用来区分多处理器系统（系统有两个或者更多CPU并共享同一个物理内存）的真正硬件并行。 进程模型一个进程就是一个正在执行的程序的实例，包括程序计数器、寄存器和变量当前值。从概念上讲，每个进程拥有它自己的CPU，当然，真正的CPU在各进程间来回切换，这种快速的切换称作多道程序设计。在多道程序计算机内存中有若干道程序，这些程序被抽象为若干个各自拥有自己控制流程（即每个程序自己的逻辑程序计数器）的进程，并且每个程序都独立地运行。当然，实际上只有一个物理程序计数器，所以程序运行时，它的逻辑程序计数器被装入实际的程序计数器，当该程序结束（或暂停）执行时，物理程序计数器被保存在内存中该进程的逻辑程序计数器中。 由于CPU在各进程之间来回快速切换，所以每个进程执行器运算的速度是不确定的，并且当同一进程再次运行时，器运算速度通常也不可再现。例如，考虑一个 I/O 进程，它执行一个10000次的空循环以等待磁带机达到正常速度，然后发出命令读取第一个记录。如果CPU决定在空循环期间切换到其他进程，则磁带机进程可能在第一条记录通过磁头之后还未被再次执行。 进程和程序间的却别是微妙的，但是非常重要。想象以为父亲正在为他的女儿烘制生日蛋糕，则做蛋糕的食谱就是程序（即用适当形式描述的算法），这位父亲是处理器（CPU），而做蛋糕各种原料（面粉、糖、鸡蛋等）就是输入的数据，进程就是他阅读食谱、取各种原料以及烘制蛋糕等一系列动作的总和。现假设他的儿子被蜜蜂蛰了哭着跑进来，父亲于是就记录下当前照着食谱做到哪里了（保存进程当前状态），拿出急救手册，为儿子处理蜇伤，我们看到处理机从一个进程（做蛋糕）切换到另一个优先级高的进程（医疗救治），每个进程有各自的程序（食谱和急救手册）。当急救完成之后，父亲又继续做蛋糕，从离开时的那一步继续做下去。值得注意的是，我们可能经常两次去启动同一个字处理软件，即一个程序运行了两遍，这也要算作两个进程。 创建进程有4中主要事件导致进程创建： 系统初始化 启动操作系统时，通常会创建若干进程，这些进程中有些是前台进程，用于同用户（人类）交互。其他的是后台进程，后台进程一般具有某些专门的功能，例如，设计一个后台进程接收发来的电子邮件，这个进程在一天的大部分时间都在睡眠，但是当电子邮件达到时就被唤醒了。停留在后台处理诸如电子邮件、web页面、新闻、打印之类的活动的进程称为守护进程（daemon）。 正在运行的进程进行系统调用创建 正在运行的进程发出系统调用，以便创建一个或者多个线程协助其工作。 用户请求创建一个新的进程。 用户双击图标或者输入命令行，启动一个新的程序。 一个批处理作业的初始化 仅在大型机的批处理系统中应用，用户在这种系统中提交批处理作业，在操作系统认为有资源科运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。 在Unix系统中，只有一个系统调用可以创建新的进程：fork。它会创建一个与调用进程相同的副本，这两个进程（父进程和子进程）拥有相同的存储镜像、同样的环境字符串和同样的打开文件，这就是全部情形。通常，子进程接着执行execve或者一个类似的系统调用，以修改器存储镜像并运行一个新的程序。例如，当一个用户在shell中输入sort时，shell就创建一个子进程，然后这个子进程执行sort。在Windows中，情形正相反，一个win32函数调用 CreateProcess既处理进程的创建，也负责把正确的程序装入新的进程。不论在Unix还是Windows中，进程创建后，父进程和子进程有各自不同的地址空间。 进程的终止进程终止，通常由下列条件引起： 正常退出（自愿） 进程完成了自己的工作，调用系统调用，通知工作已经完成。 出错退出（自愿） 进程发现了严重错误，如要编译某个文件，但是该文件不存在，于是编译器就会退出。再给出了错误参数时，面向屏幕的交互式进程通常不退出，相反，这些程序会弹出一个对话框，并要求用户再试一次。 严重错误（非自愿） 进程引起的错误，通常是由于程序中的错误导致，例如执行了非法指令，引用不存在的内存等。在这类错误中，进程会收到信号（被中断），而不是在这类错误出现时终止。 被其他进程杀死（非自愿） 进程的状态尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但进城之间经常需要相互作用，一个进程的输出结果可能作为另一个进程的输入，在shell命令： cat chapter1 chapter2 chapter3 | grep tree 中，第一个进程运行cat，将三个文件链接并输出，第二个进程运行grep，它从输入中选择所有包含单词tree的那些行。根据这两个进程的相对速度，可能发生这种情况：grep准备就绪可以运行，但输入还没有完成，于是必须阻塞grep；还有可能是：一个概念上能够运行的进程被迫停止，因为操作系统调度另一个进程占用了CPU。下图可以看到显示进程的三种状态的状态图： 运行态和就绪态在逻辑上是类似的，二者都可以运行，只是后者还没有CPU分配给它，阻塞态就完全不同，处于该状态的进程不能运行，即使CPU空闲也不行。在操作系统发现进程不能继续运行下去时，发生转换1；转换2和3是由于进程调度引起的；当进程等待的一个外部事件发生时（如一些输入到达），则发生转换4。 进程的实现操作系统维护者一张表格，即进程表（process table）。每个进程占用一个进程表项，该表项包含了进程状态的重要信息，诸如程序计数器、堆栈指针，内存分配状况、所打开的文件的状态、账号和调度信息等。下图展示了典型系统中的关键字段： 多道程序设计模型采用多道程序设计可以提高CPU利用率，从概率的角度来看cpu的利用率是比较好。假设一个进程等待I/O操作的时间与其停留在内存中的时间比是p,当内存中有n个进程时，则所有n个进程都在等待I/O（此时CPU空转）的概率是p的n次方，CPU的利用率由一下公式给出： 从完全精确的角度考虑，应该指出此概率模型只是描述了一个大致的状况。它假设所有n个进程都是独立的，即内存中的5个进程中，3个运行，2个等待是完全可以接受的，但在单cpu中，不能同时运行3个进程，所以当CPU忙时，已就绪的进程必须等待CPU，因而，进程不是独立的，更精确的模型应该使用排队论构造，但它仍然是具有参考意义的，下图以n为变量的函数表示CPU的利用率，n称为多道程序设计的道数（degree of multiprogramming）。 从图中可以看到，如果进程花费80%的时间等待I/O，为使CPU的浪费低于10%，至少要有10个进程同时在内存中。当读者认识到一个等待用户从终端输入的交互式进程是处于I/O等待状态时，很明显，80%甚至更多的I/O等待时间是普遍的，即使是在服务器中，做大量磁盘I/O操作的进程也会花费同样或更多的等待时间。虽然图中的模型很粗略，但它依然对预测CPU的性能很有效。例如，假设计算机有512MB内存，操作系统占128MB，每个用户程序占128MB，那么这些内存允许3个用户程序同时驻留内存，若80%时间用于I/O等待，则CPU利用率大约是1-0.80.80.8 ，大约49%，在增加512MB内存后，CPU利用率可以提高到79%，换而言之，第二个512M内存提高了30%的吞吐量。但是增加第三个512MB内存只能讲CPU利用率提高到91%，吞吐量仅提高12%，因此可以确定第一次增加内存是合算的投资，第二个则不是。 线程线程的使用人们认为需要使用线程的理由如下： 并行的线程可以共享同一个地址空间和所有可用数据的。 对于某些应用而言，这是必需的，二者正式多进程模型（它们具有不同的地址空间）所无法表达的。 线程比进程更轻量级，更快捷地创建和撤销。 在许多系统中，创建一个线程较一个进程要快10~100倍。在有大量线程需要动态和快速修改时，这一特性很有用。 若多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行，从而加快应用程序执行速度。 在多CPU系统中，多线程是有益的，在这样的系统中，真正的并行有了实现的可能。 假如字处理软件被编写成含有3个线程的程序，一个与用户交互，另一个在后台重新进行格式处理，一旦有某一句语句被删掉，交互线程就通知格式化线程对整个文档重新进行处理，同时交互线程继续监控键盘和鼠标，并相应诸如滚动到第一页之类的简单命令。剩下那个每隔一段时间进行磁盘备份，防止程序崩溃或者系统崩溃。拥有三个线程的情形如下图所示： 如果程序是单线程的，那么在进行磁盘备份时，来自键盘和鼠标的命令就会被忽略，直到备份工作完成为止。并且，很显然在这里三个不同的进程是不能工作的，这是因为三个线程都需要在同一个文件上进行操作，通过让三个线程代替三个进程，三个线程共享公共内存，于是它们都可以访问同一个正在编辑的文件。 现在考虑另一个多线程发挥作用的例子，一个web服务器，某些页面较其它页面相比，有更多的访问，比如对主页的访问比其它更深层次的页面访问次数更多。利用这一事实，web服务器可以把获得大量访问的页面集合保存在内存中，这样的一种页面集合称为高速缓存（cache），高速缓存也应用在其它很多场合。一种组织web服务器的方式如下图所示： 上图中，一个称为分派程序（dispatcher）的线程从网络中读入工作请求，在检查请求之后，分派现成挑选一个空转的（即被阻塞的）工作线程（worker thread）提交该请求。接着分派现成唤醒该工作线程，将它由阻塞状态转变为就绪状态。工作线程被唤醒后，它检查有关的请求是否在web页面的cache中，这个高速缓存是所有线程都可以访问的，如果没有，该线程开始执行从磁盘中调入页面的I/O操作，并且进入阻塞直到磁盘操作完成。当上述工作线程阻塞在磁盘操作时，为了完成更多操作，分派线程可能挑选另一个工作线程运行，也可以把另一个已经就绪的工作线程投入运行。 这种模型允许把服务器编写为一个集合，在分派线程的程序中包含一个无限循环，该循环用来获得工作请求并把工作请求派给工作线程。每个工作线程的代码包含一个从分派线程接收请求的无限循环，收到请求后，如果页面存在，则返回给客户机，接着该工作线程阻塞，等待一个新的请求到来。 在没有多线程的情况下，编写web服务器。一种可能的方式是：web服务器的主循环获得请求，检查请求，并在取下一个请求之前完成整个工作。在等待磁盘操作时，服务器空转，不处理任何到来的其他请求。课件线程较好地改善了web服务器的性能。如果对于这种性能的降低不可接受，那如果使用read系统调用，则还有一种可能的方式。在请求到来时，这个唯一的线程对请求进行考察，如果请求能在高速缓存中得到满足，那么一切都好，否则，就启动一个非阻塞的磁盘操作。服务器在表格中记录当前请求的状态，然后去处理下一个事件。下一个事件可能是一个新工作的请求，或是磁盘对先前操作的回答。如果是新工作的请求，就开始该工作；如果是磁盘的回答，就从表格中取出对应的信息，并处理该回答。对于非阻塞磁盘I/O而言，这种回答多数会以信号或者中断的形式出现。注意，这种情况下，“顺序进程”模型消失了，每次服务器从为某个请求工作的状态切换到另一个状态时，都必须显式地保存或者重新装入相应的计算状态。这里，每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，我们把这类设计称为有限状态机（finite-state machine）。 现在很清楚多线程必须提供的是什么了，多线程使得“顺序进程”的思想得以保留下来，这种顺序进程阻塞了系统调用（如磁盘I/O），但是仍旧实现了并行性。 经典线程模型进程用于把资源集中到一起，而线程是在CPU上被调度执行的实体。在同一个进程环境中，多个线程共享一个地址空间和其他资源，这意味着线程间共享同样的全局变量，一个线程也可以读、写甚至清除另一个线程的堆栈，线程间是没有保护的，因为这是没有必要的，因为同一个进程中的多个线程是合作而不是竞争关系。线程之间对于资源的持有如下图所示： 和传统进程一样（即只有一个线程的进程），线程可以处于若干种状态的任何一个：运行、阻塞、就绪或者终止。认识到每个线程有其自己的堆栈很重要，下图展示这一状况： 每个线程的堆栈有一帧，供各个被调用但是还没有从中返回的过程使用。例如，如果过程X调用过程Y，而Y又调用Z，那么当Z执行时，供X、Y和Z使用的帧会全部存在堆栈中。通常每个线程会调用不同的过程，从而有一个各自不同的执行历史，这就是为什么每个线程需要有自己的堆栈的原因。这里还可以了解线程的join操作和yield操作。 POSIX 线程POSIX线程是线程的POSIX（Portable Operating System Interface of UNIX，可移植操作系统接口）标准。它定义的线程包叫做Pthread。有两种主要的方法实现线程包：在用户空间中和在内核中。这两种方法互有利弊，不过混合实现方式也是可能的。 在用户空间中实现线程这种方法是把整个线程包放在用户空间，内核对线程包一无所知，从内核角度考虑，就是按单线程进程方式管理。这种方法的优点： 最明显的优点是：用户级线程包可以在不支持线程的操作系统上实现。 线程在一个运行时系统的顶部运行，这个运行时系统是一个管理线程的过程的集合。在用户空间管理线程时，每个进程需要有其专用的线程表（thread table），用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器等。该线程表由运行时系统管理，当一个线程转换到就绪态或者阻塞态时，需要在线程表中存放重新启动该线程所需的信息。如下图可以对比不同方式实现的线程包： 可以方便地在进程内调度切换到另一个线程，并且线程切换非常快捷。 在线程运行完成，例如，线程调用thread_yield ，就可以把线程的信息保存在线程表中，进而，线程调度程序来选择另一个要运行的线程。保存该线程状态的过程和调度程序都只是本地过程，所以启动它们比进行内核调用效率更高。 允许进程有自己定制的调度算法。 例如，那些有垃圾收集线程的应用程序就不用担心线程会在不合适的时刻停止。 尽管用户级线程具有上述的优点，但是它的缺点也明显： 第一个问题是如何实现阻塞系统调用。 假设在还没有任何按键动作之前，一个线程读取键盘，让该线程时机进行该系统调用时不可接受的，因为这会停止所有的线程。使用线程的一个主要目标是：首先要允许每个线程使用阻塞调用，但是还要避免被阻塞的线程影响其他的线程。有了阻塞系统的调用，这个目标不太容易实现。 页面故障问题。 如果某个程序调用或者跳转到了一条不在内存的指令上，而操作系统将到磁盘上取回这个丢失的指令（和该指令的“邻居们”），这就称为页面故障。如果有一个线程引起页面故障，内核甚至不知道有线程存在，通常会把整个进程阻塞，直到磁盘I/O完成为止，尽管其他线程是可以运行的。 如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU。 在一个单独的进程内部，没有时间中断，所以不可能用轮转调度（轮流）的方式调度进程。 可能反对用户级线程的最大负面意见是，程序员通常在经常发生线程阻塞的应用中才希望使用多个线程。 在内核中实现线程由上面在用户空间实现的线程和在内核空间实现的线程对比图可以看出，在内核中实现线程不在需要运行时系统，另外，每个进程中也没有线程表。所有能够阻塞线程的调用都以系统调用的形式实现，这与运行时系统过程相比，代价是相当可观的。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程或者运行另一个进程中的线程。而在用户级线程中，运行时始终运行自己进程的线程，直到内核剥夺它的CPU。如果某个进程中的线程引起页面故障，内核可以很方便地检查该进程是否还有其他可运行的线程，如果有，在等待所需要的页面从磁盘读入时，就选择一个线程运行。 在内核中实现线程有以下缺点： 但是内核中创建、撤销、切换线程操作代价都比较大。 在内核中尽量减少创建和撤销线程，最好能实现复用（在执行完成后，标记为不可运行，当要创建新线程时，再将其启用）。 信号是发给进程而不是线程，当信号达到时要考虑将信号交给哪个线程处理。 即使线程可以注册感兴趣的信号，但是多个线程注册同一个信号如何处理也是个问题。 混合实现有试图将用户级线程的优点与内核级线程的优点结合起来的方法，一种方法是使用内核级线程，然后将用户级线程与某些内核线程多路复用起来，如下图所示： 进程间通信这个部分看了两次都不甚明白，先跳过。 调度进程行为几乎所有进程的（磁盘）I/O请求或计算都是交替突发的。如下图所示，CPU不停顿地运行一段时间，然后发出一个系统调用以便读写文件。如下图所示： 图中有一件事值得注意，某些进程花了大多数时间在计算上，称为计算密集型；有些在等待I/O上花了大多数啊时间，称为I/O密集型。有必要指出，随着CPU越来越快，更多的进程倾向于I/O密集型，这里的基本思想是，如果需要运行I/O密集型进程，那么就应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙碌。 何时调度 创建新进程后，决定运行父进程还是子进程。 在一个进程退出时必须做出调度决策。 一个进程阻塞时，必须选择另一个进程运行。 发生I/O中断时，做出调度决策。 调度算法的目标在讨论目标前，有必要了解我们会处于那些环境中，在不同的应用领域有不同的环境，可以将其分为三类： 批处理 交互式 实时 下图针对所有环境列出不同的目标： 批处理系统的调度算法 先来先服务最短作业优先最短剩余时间优先 交互式系统调度算法 轮转调度优先级调度多级队列调度：最短进程优先保证调度彩票调度公平分享调度","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-现代操作系统（第三版）","slug":"读书笔记-现代操作系统（第三版）","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/"}]},{"title":"第14章：安全HTTP","slug":"HTTP 权威指南-第14章","date":"2018-05-25T00:00:00.000Z","updated":"2019-11-17T13:47:43.323Z","comments":true,"path":"2018/05/25/HTTP 权威指南-第14章/","link":"","permalink":"https://glassx.gitee.io/2018/05/25/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC14%E7%AB%A0/","excerpt":"前面讨论的基本认证方式和摘要认证以及报文完整性检查都是轻量级的方法，但对于重要的如银行业务处理，大规模网上购物来说，这还不够，我们需要一种能够提供下列功能的HTTP安全技术： 服务器验证，客户端验证服务器是真的还是伪造的 客户端认证，服务器验证客户端是真的还是伪造的 完整性，客户端和服务器的数据不被修改 加密，无需担心会话被窃听 效率，算法的运行要求足够快 普适性，基本上所有的客户端和服务器都支持这种协议 其他","text":"前面讨论的基本认证方式和摘要认证以及报文完整性检查都是轻量级的方法，但对于重要的如银行业务处理，大规模网上购物来说，这还不够，我们需要一种能够提供下列功能的HTTP安全技术： 服务器验证，客户端验证服务器是真的还是伪造的 客户端认证，服务器验证客户端是真的还是伪造的 完整性，客户端和服务器的数据不被修改 加密，无需担心会话被窃听 效率，算法的运行要求足够快 普适性，基本上所有的客户端和服务器都支持这种协议 其他 httpshttps是最流行的HTTP安全形式，它的URL以** https:// ** 而不是 http:// 开头。所有的HTTP请求和响应数据在发送到网络之前都要进行加密，HTTPS在HTTP下面提供了一个安全层，可以使用SSL，也可以使用其后继者TSL（Transport Layer Security，传输层安全），由于二者十分类似，所以一般不太严格地用SSL来表示SSL和TSL。 数字加密概念 密码：对文本进行编码的算法。 密钥：改变密码行为的数字化参数 对称密钥加密系统：编/解码使用相同密钥的算法 不对称密钥加密系统：编/解码使用不同密钥的算法 公开密钥加密算法：一种能够使数百万计算机便捷地发送机密报文的系统 数字签名：用来验证报文是否被改动的校验和。 数字证书：由可信的组织验证和签发的识别信息 假如使用rot3（循环移位3字符）方式对报文加密，则 明文 meet 加密后为 phhw，示意图如下： 那在概念中，密码就是 “循环移位N字符” ，N的值是由密钥控制的，在这里N的值是3。 改变密钥的值就能产生不同的密文。编码算法和编码机器都可能落入敌人手中，但是只要没有正确的号盘设置（密钥值），也无法实现解码。这种属于使用了密钥的密码。 数字密码：数字密码只是一些数字，这些数字密钥值是编码/解码算法的输入，编码算法就是一些函数，这些函数会读取一块数据，并根据算法和密钥的值对其进行编码/解码。给定一段明文P、一个编码函数E和一个数字编码密钥e，就可以生成一段经过编码的密文C，通过解码函数D和解码密钥d，就可以将密文C解码为原始的明文P，当然，编码/解码函数互为反函数。 对称密钥加密技术对称密钥加密在编码时候使用的密钥值和解码时候的密钥值一样的。保持密钥的机密很重要，在很多情况下，编码解码算法都是众所周知的，因此密钥是唯一保密的东西了。可用密钥的数量取决于密钥中的位数，以及可能的密钥中有多少是有效的。就对称加密而言，通常所有的密钥值都是有效的（知名的非对称密钥加密系统RSA中，有效密钥必须以某种方式与质数相关，因此并非所有的密钥都有效）。8位的密钥只有256个可能，40位的密钥可以有2的40次方个可能的密钥值等等。 流行的对称密钥加密算法有:DES/Triple-DES、RC2、RC4 缺点：发送者和接收者在对话前一定要有一个共享的保密密钥，服务器与每个客户端都需要有一个独立的密钥，以致如果客户端数量过多的情况下，服务器保存的密钥数量可观。如果N个节点，每个节点都要和其他所有N-1个节点通信，总共大概会保存N的平方个密钥，这将是一个管理噩梦。 公开密钥加密技术公开密钥加密技术使用了两个非对称密钥，一个用来对报文编码，一个用来对报文解码。编码密钥是可以公之于众的，每个不同的客户端可以用相同的编码密钥进行加密，但是只有主机自己才知道私有的解密密钥，只有解密密钥才能解码。 在引入公钥加密机制之前，可以先看两个问题： 问题1:314159265358979 × 314159265358979 的结果是多少？问题2： 3912571506419387090594828508241 的平方根是多少？ 如果不用计算器，第一个问题，相信大多数人花上一两个小时用纸笔能够计算出来，而第二个问题，即使花上一两天，估计也基本上没人能解出来。虽然平方和开方互为逆运算，但是它们的复杂度差异却很大，这种不对称性构成了公钥密码体系的基础。一种叫做RSA的公钥机制表明，对计算机来说，大数的乘法比对大数进行因式分解要容易得多。所有公开密钥非对称加密系统的要求是，即便拥有以下线索： 公开密钥（共有的，每个人都可以获得） 一小片拦截下来的密文（可以网络嗅探获得） 一条报文以及与之相关的密文（对一段文本使用公钥加密就可以得到） 也无法计算出保密的私有密钥。 RSA 就是满足这些条件的流行的公开机密要加密系统。RSA的算法是公开的，源代码也可以获得，破解的难度与一个极大的数字进行质因数分解的难度一样。 混合加密系统和会话密钥任何人只要知道了公开密钥，就可以向一台公共服务器发送安全报文，所以非对称的公开密钥加密系统是很好用的，两个节点无须为了进行安全的通信而先交换私有密钥。但公开密钥加密算法的计算可能会很慢，比较常见的做法是在两个节点之间通过便捷的公开密钥加密技术建立起安全通信，然后再利用那条安全通道产生并发送临时的随机对称密钥，通过更快的对称加密技术对其余的数据进行加密。 数字签名除了加密/解密报文之外，还可以用加密系统对报文进行签名（sign），以说明是谁编写的报文，同时证明报文未被篡改过，这种技术被称为数字签名（digital signing）。签名是加了密的校验和，使用数字签名有以下两个好处： 签名可以证明是作者编写了这条报文。 只有作者才有最机密的私有密钥，因此只有作者才能计算出这些校验和。 签名可以防止报文被篡改。 如果恶意攻击者在传输过程中修改了报文，则校验和就不再匹配了，攻击者没有私钥，无法为篡改的报文伪造正确的验证码。 以下例子说明了节点A是如何向节点B发送一条报文，并对其进行签名： 节点A将变长报文提取为定长摘要。 节点A对摘要应用一个“签名”函数，这个函数会将用户的私有秘钥作为参数。因为只有A知道私有密钥，所以正确的签名函数会说明签名者就是所有者。在下图中，由于解码函数D中包含了用户的私有密码，所以我们将其作为签名函数使用。 一旦计算出签名，节点A就将其附加在报文末尾，并将报文和签名都发给B 在接收端，如果B需要确定报文确实是A写的，而且没有被篡改过，节点B就可以对签名进行检查。节点B接收经过私有秘钥扰码的签名，并应用了使用公开密钥的反函数，如果拆包后的摘要与节点B自己的摘要版本不匹配，就说明要么被篡改了，要么发送者不是A。 数字证书数字证书都是由可信任的颁发机构颁发，它通常包括 对象的名称、过期时间，证书颁发者，来自证书发布者的数字签名、通常还包括对象的公开密钥以及对象使用签名算法的描述性信息。典型的数字签名格式如下： 数字证书没有单一的全球标准，但现在大多数证书都以一种标准格式 ——X.509 v3 描述。 用证书对服务器进行认证通过https建立一个安全的web事务之后，现代的浏览器会自动获取所连接服务器的数字证书，如果如武器没有证书，安全连接就会失败，服务器证书中包含很多字段，包括： web站点的名称和主机名； web站点的公开密钥； 颁发机构的名称； 颁发机构的签名。 浏览器收到证书时会对签名颁发机构进行检查，如果这个机构是很权威的公司，那浏览器一般已经知道其公开密钥了（浏览器会预先安装很多签名颁发机构的证书），就能像之前那样验证签名了。如果对签名颁发机构一无所知，浏览器就无法确定是否应该信任这个签名颁发机构，它通常会向用户展示一个对话框，看用户是否相信这个签名发布者，因为发布者可能是本地IT部门。以下展示了验证签名的过程： HTTPS-细节介绍https就是在安全的传输层上发送的http，它在将http报文发送给TCP之前，先将其发送给一个安全层，对其进行加密。对web服务器发起请求时，我们需要一种方式来告知web服务器去执行http的安全协议版本，这是在URL的方案中实现的，对web资源执行某事务时，它会检查URL方案： 如果URL方案是http，客户端会打开一条到服务器端口80的连接（默认情况下），并发送http命令。 如果URL的方案是https，客户端就会打开一条到服务器端口443（默认情况）的连接，然后与服务器握手，以二进制格式与服务器交换一些SSL安全参数，附上加密的http命令。 在https中，客户端首先打开一条到web服务器端口443（默认情况）的连接，一旦建立了TCP连接，客户端和服务器就会初始化SSL层，对加密参数进行沟通，并交换密钥，握手完成后，SSL就初始化完成了，客户端就可以将请求报文发送给安全层了，在将这些报文发送给TCP之前，要先对其进行加密。http和https的对比： SSL握手在发送已加密的HTTP报文之前，客户端和服务端要进行一次SSL握手，主要完成以下工作： 交换协议版本号 选择一个两端都了解的密码 对两端身份进行验证 生成临时会话密钥，以便加密信道 SSL握手简化版示意图如下： 在一个web服务器上执行安全事务，比如提交银行卡信息时，总是希望在于你所认为的那个组织对话，因此https事务总是要求使用服务器证书的。站点证书有效性检查步骤如下： 日期检测。检查证书的起始日期和结束日期。 签名颁发者可信度检测。每个证书是由某个证书颁发机构（CA）签发的，它们负责位服务器担保，证书有不同的等级，每种证书都要求不同级别的背景验证。比如申请某个电子商务服务证书，通常要求提供一个营业的合法证明。 签名检测。一旦判定签名授权是可信的，浏览器就要对签名使用颁发机构的公开密钥，并将其与校验码比较，以查看证书的完整性。 站点身份检测。为防止服务器复制其他人的证书，或拦截他人流量，大部分浏览器都会试着去验证证书中的域名与它们所对话的服务器的域名是否匹配。 虚拟主机与证书对于虚拟主机（一台服务器上有多个主机名），有些流行的web服务器程序只支持一个证书，如果用户请求的是虚拟主机名，与证书名称并不完全匹配，浏览器就会显示警告框。比如cajun-shop.com网站，站点的托管服务提供商提供的官方名称位 cajun-shop.securesites.com。 用户进入http://www.cajun-shop.com时，服务器证书中列出的官方主机名（*.securesites.com）与用户浏览的虚拟主机名（www.cajun-shop.com）不匹配，以至于出现警告。 为了防止出现这个问题，cajun-shop.com的所有者会在开始处理安全事务时，将所有用户都重定向到cajun-shop.securesites.com。 通多代理以隧道形式传输安全流量很多公司都会在公司网络和公共因特网的安全边界上放置一个代理，代理是防火墙路由器唯一允许进行http流量交换的设备，它可能会进行病毒检测或者其他的内容控制工作。 但只要客户端开始用服务器的公开密钥对发往服务器的数据进行加密，代理就再也不能读取http首部了！代理不能读取首部，意味着无法知道应该将请求转向何处。 这种情况一种常用的技术就是https SSL 隧道协议，客户端首先要告知代理，他想要连接的安全主机和端口，这是在开始加密之前以明文形式告知的，所以代理可以理解这条信息。 http通过新的名为connect的扩展方法来发送明文形式的端点信息，connect方法会告诉代理，打开一条到期望主机和端口号的连接，这项工作完成之后，直接在客户端和服务器之间以隧道形式传输数据。 以下示意了一个connet：","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-HTTP 权威指南","slug":"读书笔记-HTTP-权威指南","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"}]},{"title":"第12、13章：认证机制","slug":"HTTP 权威指南-第12、13章","date":"2018-05-23T00:00:00.000Z","updated":"2019-11-17T13:47:34.904Z","comments":true,"path":"2018/05/23/HTTP 权威指南-第12、13章/","link":"","permalink":"https://glassx.gitee.io/2018/05/23/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC12%E3%80%8113%E7%AB%A0/","excerpt":"第12章——基本认证机制当访问某些需要授权才能访问的资源时，服务器会返回401要求登录认证，web服务器会将受保护的文档组织成一个 安全域（security realm），每个安全域可以有不同的授权用户集。一个例子假设web服务器建立了两个安全域，一个用于公司的财务信息，一个用于个人家庭的文档，那么公司的CEO应当能够访问销售额预测资料，但不应该允许CEO访问员工和其家人度假的照片。","text":"第12章——基本认证机制当访问某些需要授权才能访问的资源时，服务器会返回401要求登录认证，web服务器会将受保护的文档组织成一个 安全域（security realm），每个安全域可以有不同的授权用户集。一个例子假设web服务器建立了两个安全域，一个用于公司的财务信息，一个用于个人家庭的文档，那么公司的CEO应当能够访问销售额预测资料，但不应该允许CEO访问员工和其家人度假的照片。 下面是一个假想的基本认证质询，它指定了一个域： HTTP/1.0 401 UnauthorizedWWW-Authenticate：Basic realm=”Family” 域应该有一个描述性字符名，比如 Family（员工个人家庭照片），以帮助用户了解应该使用哪个用户名和密码。 缺点基本认证的机制很简单，但是存在以下主要的安全隐患： 基本认证以 username:pwd 的形式将用户名密码拼接起来，并且通过Base-64的加密后通过网络发送用户名和密码，这基本上相当于明文传输（base-64很容易破解）。 即使使用其他更难解密的方式加密，也没有机制防止重放攻击。 没有针对中间节点的防护，头部不被更改，能通过认证，但是报文内容更改了也能造成很大的危害。 第13章——摘要认证摘要认证试图修复基本认证协议的严重缺陷，它遵循的箴言是“绝不通过网络发送密码”，相对基本认证，它做了如下改进： 永远不以明文在网络上发送密码 可以防止恶意用户捕获并且重放的握手过程 可以选择性地防止对报文内容的篡改 防范其他常见形式的攻击 原理摘要认证的主要原理是“对信息主体的浓缩”，它认证的主要流程如下： 客户端请求了某个受保护的文档。 在客户端能够证明身份前，服务器拒绝提供文档，并向客户端发起质询，询问用户名和摘要形式的密码。 客户端传递用户名和密码的摘要。服务器知道所有用户的密码，将收到的摘要与自己用密码计算出来的摘要对比，即可校验用户身份真伪。 如果验证通过，则开始向客户端提供文档。 注意：整个过程都没有在网络上发送密码！而是发送密码的“摘要”或者说是指纹 整个过程图示如下： 摘要摘要是一种单向函数，主要用于将无限的输入值转换为有限的浓缩输出值，有时也将摘要函数称为加密的校验和、单向散列函数或者指纹函数。常见的摘要函数是 MD5 ，会将任意长度的字节序列转换为一个128位的摘要。MD5输出的128位的摘要通常会被写成32个16进制的字符，每个字符表示4位。 重放攻击使用单向摘要就无需以明文发送密码了，但是别有用心的人还是可以截获摘要，并一遍遍地重放给服务器，进行重放攻击，在这点上，摘要和密码一样好用。 为了防止重放攻击，服务器可以向客户端发送一个称为 随机数（nonce）的特殊令牌，这个数会经常发生变化（根据具体规则来定，可以每次认证都变化），客户端在计算摘要之前要先将这个随机数令牌附加到密码上去。在密码中加入随机数就会使摘要随着随机数的每次变化而变化，没有密码就无法计算出正确的摘要。 摘要认证的握手机制摘要认证的握手步骤流程如下： 客户端请求被保护的文档。 服务器计算出一个随机数，放入质询报文（WWW-Authenticate）中，与服务器支持的算法列表一同发给客户端。 客户端选择其中一个算法，计算出密码和其他数据的摘要。并将摘要放在认证报文（Authorization）中发回服务器，如果客户端要对服务器进行质询，可以发送客户端的随机数。 服务器接受摘要、选中的算法以及支撑数据，在本地生成摘要，并与客户端发来的摘要对比验证。如果客户端有对服务器进行质询，就会创建服务端摘要。 摘要认证会话过程优化预授权普通的认证方式中，事务结束前，每条请求都要有一次 请求/质询 的循环，如果客户端事先知道下一个随机数是什么，就可以取消这个 请求/质询 循环，这样客户端就可以在服务端发出请求之前，正确地生成Authorization首部了。这样就能减少报文的数量，对性能也有很大的提升，如图： 此外，还有几种预授权的方式： 服务器预先在Authentication-info成功首部中发送下一个随机数。 这虽然避免了 请求/质询 循环，但是它也破坏了对同一条服务器的多条请求进行管道化的功能，因为在发布下一条请求之前，一定要收到下一个随机值才行。 服务器允许在一段时间内使用同一个随机数。 可能会有一定次数的重放攻击的可能性。 客户端和服务器使用同步的、可以预测的随机数生成方法。 报文完整性保护如果使用了完整性保护（qop=”auth-init”），对应的内容就是对实体主体部分，而不是报文主体部分的散列，对于发送者，要在应用任意传输编码方式之前计算，而对于接收者，则应在去除所有传输编码之后计算。 总结安全隐患和相应解决方案 重放攻击。 用生成随机数解决，可能可以包括IP地址、时间戳、资源Etag等计算摘要。 多重认证机制。 比如同时存在基本认证和摘要认证时。可以考虑使用最强认证方案。 首部篡改。 防范方式：要么端到端加密，要么对首部进行数字签名，最好二者结合。 词典攻击。 没有好的对策，设置合理的密码过期策略，和难以猜测和破译的密码吧。 恶意代理攻击和中间人攻击。 没有更好的方法，唯一方式是使用SSL。 选择明文攻击。 利用摘要词典获取密码明文，或者暴力枚举可能的密码。 存储密码。 如果摘要认证密码文件被入侵，攻击者就获取到域中所有文件，而无需进行解码了。消除这个问题的方法：（1）加强保护 （2）确保域名在所有域中是唯一的。如果密码文件被入侵，所造成的破坏也局限于某一特定域。 摘要加密没有为内容的安全提供保障，可能可以知道内容是否被篡改，真正安全的事务是通过SSL才能实现。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-HTTP 权威指南","slug":"读书笔记-HTTP-权威指南","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"}]},{"title":"第11章：客户端识别与cookie机制","slug":"HTTP 权威指南-第11章","date":"2018-05-22T00:00:00.000Z","updated":"2019-11-17T13:46:12.102Z","comments":true,"path":"2018/05/22/HTTP 权威指南-第11章/","link":"","permalink":"https://glassx.gitee.io/2018/05/22/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC11%E7%AB%A0/","excerpt":"HTTP提供匿名、无状态的请求/响应 服务，为了给用户个性化的服务，有必要识别用户，主要的方式有： HTTP首部承载用户身份信息 HTTP请求首部有From （用户的email地址）、user-agent（用户的浏览器软件）、Referer（用户是从这个页面跳转过去的）、Authorization（用户名和密码）等字段，利用这些字段可以识别用户。","text":"HTTP提供匿名、无状态的请求/响应 服务，为了给用户个性化的服务，有必要识别用户，主要的方式有： HTTP首部承载用户身份信息 HTTP请求首部有From （用户的email地址）、user-agent（用户的浏览器软件）、Referer（用户是从这个页面跳转过去的）、Authorization（用户名和密码）等字段，利用这些字段可以识别用户。 以下是首部承载的信息： 跟踪客户端IP地址，通过IP地址识别用户。 IP识别有弊端，（1）它识别的是及其，不是用户 （2）网络服务提供商可能会提供动态的IP （3）如果使用了代理，那获取到的IP可能只是代理的IP.（4）为了安全，用户可能通过网络地址转换（Network Address Translation， NAT） 防火墙来浏览网络内容，这些NAT设备隐藏了防火墙后面的那些实际客户端的IP。 用户登录，用认证方式识别用户。 如果服务器希望在为用户提供对站点的访问前先登录，则可以返回 401 Login Required ,然后浏览器会弹出登录框。这样就能显式地询问用户是谁。 胖UTL，在URL中嵌入识别信息的技术 有些web站点会为每个用户生成特定版本的URL来追踪身份，用户浏览站点时，web服务器会动态生成一些超链，继续维护URL中的信息。但是，这种方案有几点问题： 无法共享URL，包含了特定用户的信息，如果分享出去，无意中将积累的个人信息共享出去了 需要对每个用户动态生成胖URL，额外的服务器负荷 破坏缓存。为每个URL生成用户特有的版本，意味着不再有供公共访问的URL缓存了。 cookie 是目前识别用户，实现持久会话的最好方式。包括 会话cookie 和 持久cookie ，他们之间的唯一区别就是他们的过期时间。浏览器会记住从服务器返回的set-cookies或者set-cookie2首部中的cookie内容，并将cookie存储在cookie数据库，将来用户访问同一站点时，浏览器会按照某些规则将cookie放在cookie请求首部中将其传回去。 以下是为用户设置cookie的情形： cookie的域属性： 产生cookie的服务器可以向set-cookie响应首部添加一个Domain属性来控制哪些站点可以看到那个cookie，比如，下面的HTTP响应首部告知浏览器将 cookie user=”haha” 发送给域 “.baidu.com”中的所有站点： set-cookie: user=”haha”;domain=”baidu.com” 如果访问的是www.baidu.com 、news.baidu.com 或其他任何以 .baidu.com 结尾的站点，下列的cookie都会被发布出去； Cookie :user=”haha” cookie 规范甚至允许用户将cookie域部分web站点关联起来，可以通过path属性来实现： 例如，某个web服务器可能是由两个组织共享的，每个组织都有独立的cookie，站点 www.baidu.com 可能会将部分web站点用于外卖，如 www.baidu.com/waimai/ ，可以用一个独立的cookie来记录用户喜欢的外卖口味，如： Set-cookie: taste=hot; domain=”baidu.com”; path=/waimai/ 如果用户访问 http://www.baidu.com/waimai/bj/index.html 时就会获得两个cookie： Cookie: user=”haha”Cookie: taste=”hot” 因此，可以理解为：cookie就是由服务器贴到客户端上，由客户端维护的状态片段，只会回送给那些合适的站点。 我们有Set-Cookie 和 Set-Cookie2 两种，后者属于更新的版本。Cookie2首部告知服务器，用户Agent代理理解新形势的cookie，病提供了所支持的cookie标准版本，：Cookie2： $Version=”1”如果服务器理解新形式的cookie，就能识别出Cookie2首部，并在响应首部发送Set-Cookie2（而不是Set-Cookie），如果客户端从同一个响应中既获得了Set-Cookie 首部又获得了 Set-cookie2首部，就会忽略老的 Set-cookie首部。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-HTTP 权威指南","slug":"读书笔记-HTTP-权威指南","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"}]},{"title":"第4章：连接管理","slug":"HTTP 权威指南-第4章","date":"2018-05-21T13:10:00.000Z","updated":"2019-11-17T13:46:03.820Z","comments":true,"path":"2018/05/21/HTTP 权威指南-第4章/","link":"","permalink":"https://glassx.gitee.io/2018/05/21/HTTP%20%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0/","excerpt":"TCP连接HTTP的连接实际上就是TCP的连接和一些使用连接的规则。TCP是可靠的数据管道：TCP为HTTP提供了一条可靠的比特传输管道，从TCP连接一端输入的字节会从另一端以原有顺序、正确地传送出来。TCP流是分段的，由IP分组传送：HTTP以流的形式将报文数据通过一条打开的TCP连接传输，TCP会将数据流分成若干段，每个TCP段都是由IP分组承载，从一个IP地址发送到另一个IP地址。","text":"TCP连接HTTP的连接实际上就是TCP的连接和一些使用连接的规则。TCP是可靠的数据管道：TCP为HTTP提供了一条可靠的比特传输管道，从TCP连接一端输入的字节会从另一端以原有顺序、正确地传送出来。TCP流是分段的，由IP分组传送：HTTP以流的形式将报文数据通过一条打开的TCP连接传输，TCP会将数据流分成若干段，每个TCP段都是由IP分组承载，从一个IP地址发送到另一个IP地址。 任意时刻计算机都可以有多条TCP连接处于打开状态，TCP是通过端口号来保持这些连接的正确运行。 TCP的连接是通过4个值来识别的：&lt;源IP地址、源端口号、目的IP地址、目的端口号&gt; ，这4个值定义了唯一一条连接，IP地址可以将你连接到正确地计算机，而端口号可以将你连接到正确的应用程序。 以下表示四条不同的TCP连接，各连接要么源IP不同，要么目的IP不同，要么源端口不同，要么目的端口不同： 利用套接字操纵TCP客户端和服务器之间的连接： HTTP性能讨论性能概述HTTP事务流程主要包括几个方面： 客户端首先根据URI确定WEB服务器的IP和端口，如果没有DNS缓存的话，这个过程可能花费数十秒。 接下来，客户端向服务器发送TCP连接请求，并等待服务器应答，每条新的TCP连接都会有连接建立时延。 一旦连接建立起来，服务器处理请求、因特网传输请求报文都需要时间。 HTTP位于TCP上层，所以HTTP事务的性能很大程度上取决于TCP通道的性能。这其中，对HTTP性能影响最常见的是TCP相关的时延，包括： TCP连接建立握手 小的HTTP事务可能会在TCP建立上花费50%的时间，这是不合理的。 用于捎带确认的TCP延迟确认算法 每个TCP段都有一个序列号和数据完整性校验和，每个段的接收者收到完好的段时，都会向发送者回送确认分组。如果发送者没有在指定的时间窗口收到确认信息，发送者就认为分组已损坏，并重新发送数据。由于确认报文很小，所以TCP允许TCP将返回的确认信息与输出的数据分组结合在一起，可以更有效地利用网络。为了增加确认报文找到输出数据分组的可能性，很多TCP栈都实现了一种“延迟确认”算法，延迟确认算法会在一个特定的窗口时间（通常100~200毫秒）内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组，如果那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。 TCP慢启动拥塞(se)控制 TCP数据传输的性能还取决于TCP连接的使用期（age）。TCP连接会随着时间进行自我“调谐”——期初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输速度，这种“调谐”称为 TCP慢启动，用于防止因特网的突然过载和拥塞。例如，如果HTTP事务有大量的数据要发送，是不能一次将所有分组发送出去的，必须发送一个分组等待确认，然后可以发送两个分组，每个分组都必须确认，这样就可以发送四个分组了，这种方式被称为“打开拥塞窗口”。由于存在这种拥塞控制，所以新连接的传输速度会比已经传输过一定量数据的“已调谐”的连接慢一些。由于已“调谐”的连接快，因此HTTP中有一些可以重用现存连接的工具，提高效率。 数据聚集的Nagle算法与TCP_NODELAY 如果每次发送的数据量很少，但是传输的次数很多，就会产生大量包含少量数据的分组，网络性能就会下降，Nagle算法鼓励发送全尺寸（LAN上最大尺寸的分组大约1500字节，因特网上是几百字节）的段，试图在发送一个分组前，将大量TCP数据绑在一起，提高网络效率，毕竟每个TCP段中哪怕只放了一个字节，也至少装载了40个字节的标记和首部。但是这也会引发HTTP性能问题，首先，可能某个小的HTTP报文无法填满一个分组，但等待那些永远不会到来的额外数据而产生时延。其次，Nagle算法与前面体积的延迟确认似乎是矛盾的 —— Nagle算法会阻止数据发送，直到有确认分组抵达为止，但是确认分组会被延迟确认算法延迟100~200毫秒。 TIME_WAIT时延和端口耗尽 当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，这类信息指挥维持一小段时间，通常是所估计的最大分段使用期的2倍（称为2MSL，通常为2分钟）。 HTTP的性能改善有几种方法可以提高HTTP的性能： 并行连接，通过发起多条TCP连接发起并发的HTTP请求。这样可以避免单条连接的空载时间和没有充分利用带宽。以下两个图为对比：串行： 并行：2. 持久连接，用于消除连接及关闭的时延。 以前使用 keep-alive 字段，现在使用 persistent。3. 管道化连接。通常，http请求总是顺序发送的，下一个请求只有在当前请求的响应被完全接受的时候才会被发送。由于网络延迟和带宽的限制，这样会导致在服务器发送下一个响应的时候中间有很大的延迟。管道化连接可以将多条连接放入队列，当第一条请求发出之后，第二条第三条请求也可以开始发送了，这样做可以降低网络环回时间，提高性能。 如果一个事务，不管是执行一次还是很多次，得到的结果都是相同的，那我们说这个事务是幂等的。 GET、HEAD PUT DELETE TRACE OPTIONS 是幂等的，但POST不是幂等的，所以不应该以管道化的方式发送POST请求。 书本之外：关于TIME_WAIT以下内容参考自博客： https://blog.csdn.net/u013616945/article/details/77510925 描述首先调用close()发起主动关闭的一方，在发送最后一个ACK之后会进入time_wait的状态，也就说该发送方会保持2MSL时间之后才会回到初始状态。MSL值得是数据包在网络中的最大生存时间。产生这种结果使得这个TCP连接在2MSL连接等待期间，定义这个连接的四元组（客户端IP地址和端口，服务端IP地址和端口号）不能被使用。 产生的原因 为实现TCP全双工连接的可靠释放 假设发起主动关闭的一方（client）最后发送的ACK在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前，client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常。 为使旧的数据包在网络因过期而消失 为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。 time_wait状态如何避免首先服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://glassx.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记-HTTP 权威指南","slug":"读书笔记-HTTP-权威指南","permalink":"https://glassx.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"}]},{"title":"Ubuntu下利用github和hexo搭建自己的博客","slug":"Ubuntu下利用github和hexo搭建自己的博客","date":"2018-05-03T12:46:00.000Z","updated":"2019-11-18T13:02:01.768Z","comments":true,"path":"2018/05/03/Ubuntu下利用github和hexo搭建自己的博客/","link":"","permalink":"https://glassx.gitee.io/2018/05/03/Ubuntu%E4%B8%8B%E5%88%A9%E7%94%A8github%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"最近打算开始写点东西，发出来，一来可以督促自己持续地将所学所感悟的东西记录下来，二来，以前一直在自己遇到问题解决不了的时候去google，获取他人的答疑解惑，而自己写的总结性的东西都在有道云笔记上（主要怕误导大家），这次重新搭建自己的博客，附上了评论系统，所以希望即使写出来的东西不完善也能让大家留个评论，能够及时改正，因此就膨胀发出来了。同时希望这个教程能够帮到一些人亲手搭建自己的博客。","text":"最近打算开始写点东西，发出来，一来可以督促自己持续地将所学所感悟的东西记录下来，二来，以前一直在自己遇到问题解决不了的时候去google，获取他人的答疑解惑，而自己写的总结性的东西都在有道云笔记上（主要怕误导大家），这次重新搭建自己的博客，附上了评论系统，所以希望即使写出来的东西不完善也能让大家留个评论，能够及时改正，因此就膨胀发出来了。同时希望这个教程能够帮到一些人亲手搭建自己的博客。 根据一直以来的经验，使用第三方框架之前一定要仔细阅读官方的文档，先不要去获取网上所谓的教程，因为每个教程里面针对的 操作系统、搭设的环境等 不一定和你的一模一样，而官方文档一般是能涵盖你所碰到的大多数问题的 先放上官方的（语言可以选择中文的哦）： hexo的主页在这里：https://hexo.io/ hexo的文档在这里：https://hexo.io/docs/ 如果你自己能看文档解决，那是再好不过了，如果根据官方文档踩到坑跳不出来，可以参考参考以下的教程。 一、安装nodejs 与 npm首先声明，博主目前主要使用Ubuntu进行Android开发，然后进行一些简单的日常使用，对Ubuntu玩得并非很6，看到hexo官网上说要先安装nodejs和npm，首先想到的是去nodejs官网，但是下载下来解压之后，一脸懵逼，不知道怎么操作了。官网上没有很直观的文档(是不仔细找还不好发现)，google 上也是众说纷纭，遂又硬着头皮去官网上找找解决方法，我最后找到的官方指引，点击这里就是，有针对各种系统安装nodejs的说明（同时会自动安装 npm），为了节约大家去看文档的时间，以下还是列出ubuntu环境下nodejs的安装过程： 在终端输入： curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash - 注：在写本教程的时候，最新的LTS版本的nodejs是 8.11.1，所以我这里是8.x，这个版本号可以依据自己需要的版本而改动 当然，如果提示你还未安装curl，则使用以下命令安装即可： $ sudo apt-get install curl 完成之后，再在终端输入： $ sudo apt-get install -y nodejs 最后，输入以下命令检测是否安装成功 ： $ nodejs -v v8.11.1 $ npm -v 5.6.0 如果显示这些版本号，说明安装成功。 二、安装hexo根据hexo的官方介绍，里面很详细地介绍了安装过程： 1、安装hexo(如果提示权限问题请在命令前加上 sudo) $ npm install -g hexo-cli 2、初始化hexo 在终端cd到你想要存放blog的目录，执行 $ hexo init BLOG 这行命令会帮你创建一个BLOG文件夹，并且做一些初始化操作，这里BLOG是你想要新建的存放hexo必要文件的文件夹。 3、安装依赖 $ cd BLOG $ npm install 三、配置github申请github账号，并且在本地电脑上安装git ，并且将本地生成的公钥更新到github上，以便本机有权限将生成的静态网页push到github服务器。参考附件：github官方提供的ssh设定：https://help.github.com/articles/connecting-to-github-with-ssh/ 在github上新建project在github上新建project ，只需要注意project的名字一定得是 username.github.io 就行了，像我的博客地址是 glassx.github.io，因此我的project的名字是 glassx.github.io 。 四、配置hexo 以及 关联hexo与github在正式写作之前，我们需要配置hexo，并且将hexo与github关联起来。 主题配置首先是选择 主题（theme），当然也可以使用hexo的默认主题，我目前使用的是yilia主题，这个纯属个人爱好，你可以去知乎上搜索好看的hexo主题，也能从我认为的hexo主题大全中选择你中意的主题。只需将下载好的主题放到 *BLOG/themes/ *目录下备用。 用yilia主题的话，别忘了在BLOG目录下终端执行： $ npm i hexo-generator-json-content –save 修改hexo的配置文件打开 ** BLOG/ 目录下的 **_config.yml 文件，找到 theme 字段，将它的值改成你需要的主题名称，比如我的就是 ： theme: yilia 除此之外，还需要找到 deploy 字段，将它下面的字段配置成类似于： deploy: type: git repository: https://github.com/glassx/glassx.github.io.git branch: master将 https://github.com/glassx/glassx.github.io.git 换成你自己的就好了（其实这里整个就是你前面在github上新建的仓库的地址）。 安装必要控件使用以下命令安装deploy的git工具： $ npm install hexo-deployer-git –save 如果不安装，在部署的时候会报错： ERROR Deployer not found: git 注意：一定要在第三步的时候将你的公钥上传到github上去，也就是第三步中的 github提供的ssh设定 那个部分，否则在部署的时候会提示没有权限 五、开始写作准备工作终于做完了，开始发挥吧！首先新建博文： 在终端里定位到上述的BLOG文件夹下，执行 $ hexo new post “firstpage” 之后会在 BLOG/source/_post/ 目录下生成 firstpage.md 文件，编辑firstpage.md 文件，注意该文件的编辑使用的是 markdown 语法，如果不懂这个语法的话，就去google一下吧，语法很简单。 关于Ubuntu下的编辑器，我目前在使用的是 Remarkable，个人觉得挺好用，因此也安利一波。 编辑完成之后，终端中定位到 BLOG/ 目录，使用hexo命令生成静态文件： $ hexo generate 生成静态文件命令也可以直接简化成： $ hexo g 生成静态文件的过程就是将markdown文件 firstpage.md导出成index.html之类的静态文件，静态文件生成之后，便只需要部署了： $ hexo deploy 同样，部署命令也可以简化成： hexo d 部署过程实际上是将静态文件push到github指定仓库的过程，期间需要输入你的github的username，比如我的就是glassx ，之后回车；再提示你输入github登录密码（输入密码是看不见的，输入了看不见不要慌），输完回车就OK了。 当然你可以做到一行命令生成静态文件后自动部署： $ hexo generate –deploy 或者 $ hexo deploy –generate 二者的效果是一样的，都是生成静态文件后自动部署。 部署成功之后，就可以通过 username.github.io 访问你的页面了（username换成你的名字，比如我的就是 glassx.github.io） 总结一下，在整个过程中，hexo的安装按照官方给出的步骤一步步执行就可以了，nodejs的安装也不困难，建立的github仓库其实就是为了存放静态页面，只有在deploy的时候将静态文件推送上去，当然，github提供的page功能会将你的静态页面展示出来。 建议：为了能够在不同的平台上方便地更新博客，并且防止系统损坏等意外导致博客丢失，建议在github上另外建立一个仓库，用于存放BLOG文件夹的内容 更多的博客装修内容可以参考：https://blog.csdn.net/weidong_y/article/details/90904781","categories":[{"name":"linux","slug":"linux","permalink":"https://glassx.gitee.io/categories/linux/"}],"tags":[{"name":"手摸手","slug":"手摸手","permalink":"https://glassx.gitee.io/tags/%E6%89%8B%E6%91%B8%E6%89%8B/"}]}]}